import { Directive, Input, ViewContainerRef, Component, ElementRef, Renderer2, forwardRef, Inject, Optional, SkipSelf, Injectable, ChangeDetectorRef, ComponentFactoryResolver, ViewChild, Pipe, EventEmitter, Output, NgZone, NgModule, InjectionToken, HostBinding, ContentChild, ContentChildren, ViewEncapsulation, ChangeDetectionStrategy, Injector, PLATFORM_ID, APP_INITIALIZER } from '@angular/core';
import { isPresent, isBlank, MapWrapper, AppConfig, Environment, noop, uuid, isStringMap, assert, StringWrapper, isType, objectToName, FieldPath, isArray, isString, isFunction, isJsObject, objectValues, unimplemented, ListWrapper, isBoolean, equals, isDate, isEntity, RoutingService, AribaCoreModule, BooleanWrapper, print } from '@aribaui/core';
import { FormControl, FormGroup, Validators, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';
import { DomSanitizer } from '@angular/platform-browser';
import { CurrencyPipe, CommonModule, DecimalPipe, isPlatformBrowser } from '@angular/common';
import { BehaviorSubject, of, Subject } from 'rxjs';
import { InputTextModule } from 'primeng/components/inputtext/inputtext';
import { distinctUntilChanged, debounceTime, switchMap } from 'rxjs/operators';
import { ButtonModule, ToolbarModule, CheckboxModule, AutoComplete, AutoCompleteModule, DropdownModule, InputTextModule as InputTextModule$1, CalendarModule, RadioButtonModule, InputTextareaModule, EditorModule, AccordionTab, AccordionModule, SharedModule, DomHandler, Listbox, ListboxModule, OverlayPanel, TreeDragDropService, ConfirmationService, MessageService, Header, Footer, PrimeTemplate, Column, Row, HeaderColumnGroup, FooterColumnGroup, Accordion, AUTOCOMPLETE_VALUE_ACCESSOR, BlockUI, BlockUIModule, Breadcrumb, BreadcrumbModule, ButtonDirective, Button, Captcha, CaptchaModule, CALENDAR_VALUE_ACCESSOR, Calendar, Card, CardModule, Carousel, CarouselModule, UIChart, ChartModule, CHECKBOX_VALUE_ACCESSOR, Checkbox, CHIPS_VALUE_ACCESSOR, Chips, ChipsModule, CodeHighlighter, CodeHighlighterModule, COLORPICKER_VALUE_ACCESSOR, ColorPicker, ColorPickerModule, ConfirmDialog, ConfirmDialogModule, ContextMenuSub, ContextMenu, ContextMenuModule, DataGrid, DataGridModule, DataList, DataListModule, DataScroller, DataScrollerModule, DTRadioButton, DTCheckbox, ColumnHeaders, ColumnFooters, TableBody, ScrollableView, DataTable, DataTableModule, DeferredLoader, DeferModule, Dialog, DialogModule as DialogModule$1, Draggable, Droppable, DragDropModule, DROPDOWN_VALUE_ACCESSOR, Dropdown, EDITOR_VALUE_ACCESSOR, Editor, Fieldset, FieldsetModule, FileUpload, FileUploadModule, Galleria, GalleriaModule, GMap, GMapModule, Growl, GrowlModule, InplaceDisplay, InplaceContent, Inplace, InplaceModule, INPUTMASK_VALUE_ACCESSOR, InputMask, InputMaskModule, INPUTSWITCH_VALUE_ACCESSOR, InputSwitch, InputSwitchModule, InputText, InputTextarea, KEYFILTER_VALIDATOR, KeyFilter, KeyFilterModule, Lightbox, LightboxModule, LISTBOX_VALUE_ACCESSOR, MegaMenu, MegaMenuModule, MenuItemContent, Menu, MenuModule, MenubarSub, Menubar, MenubarModule, Messages, MessagesModule, UIMessage, MessageModule, MULTISELECT_VALUE_ACCESSOR, MultiSelect, MultiSelectModule, OrderList, OrderListModule, OrganizationChartNode, OrganizationChart, OrganizationChartModule, OverlayPanelModule, Paginator, PaginatorModule, Panel, PanelModule, BasePanelMenuItem, PanelMenuSub, PanelMenu, PanelMenuModule, Password, PasswordModule, PickList, PickListModule, ProgressBar, ProgressBarModule, ProgressSpinner, ProgressSpinnerModule, RADIO_VALUE_ACCESSOR, RadioButton, RATING_VALUE_ACCESSOR, Rating, RatingModule, Schedule, ScheduleModule, ScrollPanel, ScrollPanelModule, SELECTBUTTON_VALUE_ACCESSOR, SelectButton, SelectButtonModule, SlideMenuSub, SlideMenu, SlideMenuModule, SLIDER_VALUE_ACCESSOR, Slider, SliderModule, Sidebar, SidebarModule, SPINNER_VALUE_ACCESSOR, Spinner, SpinnerModule, SplitButton, SplitButtonModule, Steps, StepsModule, TabViewNav, TabPanel, TabView, TabViewModule, TabMenu, TabMenuModule, Terminal, TerminalModule, TieredMenuSub, TieredMenu, TieredMenuModule, TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButton, ToggleButtonModule, Toolbar, Tooltip, TooltipModule, UITreeNode, Tree, TreeModule, TreeTableService, TreeTable, TTBody, TTScrollableView, TTSortableColumn, TTSortIcon, TTResizableColumn, TTReorderableColumn, TTSelectableRow, TTSelectableRowDblClick, TTContextMenuRow, TTCheckbox, TTHeaderCheckbox, TTEditableColumn, TreeTableCellEditor, TreeTableToggler, TreeTableModule, TRISTATECHECKBOX_VALUE_ACCESSOR, TriStateCheckbox, TriStateCheckboxModule } from 'primeng/primeng';
import { DialogModule } from 'primeng/dialog';
import { animate, AnimationBuilder, state, style, transition, trigger } from '@angular/animations';
import { RouterModule } from '@angular/router';
import { ObjectUtils } from 'primeng/components/utils/objectutils';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * When we have a custom component like dropdown, radiobuttonlist and
 * many more we want to provide a custom content to it like so:
 *
 * ```
 *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
 *      {{item.userName}}
 *
 *   <aw-dropdown
 *
 * ```
 * Who else would know how to render list of objects..
 *
 * But its not possible in current form. if I do not provide Angular some as they call it this
 * syntactic sugar *,
 *
 *
 * ```
 *  <aw-dropdown *mySugerDirective=.....>
 *      {{item.userName}}
 *
 *   <aw-dropdown
 * ```
 *
 *
 * then angular will not know  inside is a template and I wont be able to get hold of TemplateRef
 * inside the component
 *
 * So the only way I found (expecting I do not want to change anything in terms of bindings and the
 * signature I use it. I have to use it like this:
 *
 * ```
 *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
 *      <ng-template let-item> {{item.userName}}</ng-template>
 *
 *   <aw-dropdown
 *
 * ```
 *
 *  This way it could work. Since I am inside ngFor I want to render the item into the correct
 * viewContainer of ngFor's current item.
 *
 *  This way I can also expose item outside using Angular's special local variable called:
 * $implicit.
 *
 * This gets even more complex if we try to pass this template 2 levels down, like in case of
 * RadioButtonList. But later on I might want to refactor this into custom NG FOR
 *
 * @deprecated in favor of ngTemplateOutlet (will be removed in the next version)
 *
 */
class EmbeddedItemDirective {
    /**
     * @param {?} _viewContainer
     */
    constructor(_viewContainer) {
        this._viewContainer = _viewContainer;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    set item(item) {
        this._implicitValue = item;
    }
    /**
     *
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (isPresent(this._viewRef)) {
            this._viewContainer.remove(this._viewContainer.indexOf(this._viewRef));
        }
        if (isPresent(this.embeddedItem)) {
            /** @type {?} */
            let context = new EmbededItem(this._implicitValue);
            this._viewRef = this._viewContainer.createEmbeddedView(this.embeddedItem, context);
        }
    }
}
EmbeddedItemDirective.decorators = [
    { type: Directive, args: [{ selector: '[embeddedItem]' },] }
];
/** @nocollapse */
EmbeddedItemDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
EmbeddedItemDirective.propDecorators = {
    embeddedItem: [{ type: Input }],
    item: [{ type: Input }]
};
/**
 * Wrapper class around Angular's EmbeddedViewRef.context()
 *
 */
class EmbededItem {
    /**
     * @param {?} $implicit
     */
    constructor($implicit) {
        this.$implicit = $implicit;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * GenericContainerComponent is used by include-component.directive to dynamically create an
 * HTMLElement and use this element to wrap a child component. This is very useful when we want to
 * modify a child by wrapping it with a border, a background, or bold its text.
 *
 * The wrapper element is dynamically created. It's element is specified by the tagName property in
 * the bindings \@Input.
 *
 *  ### Example.  Directly in html
 *
 *   app.html
 *      <aw-generic-container tagName="tagName" bindings="bindings">
 *          <my-component ..bindings..></my-component>
 *      </aw-generic-container>
 *
 *   app.component.ts
 *
 *       tagName = (bBold) ? 'h1' : 'span';
 *       bindings = {  style: 'background-color: red' }
 *
 */
class GenericContainerComponent {
    /**
     * param renderer - Renderer is used to create 'tagName' element.
     * @param {?} renderer
     * @param {?} element
     */
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.nativeElement = element.nativeElement;
    }
    /**
     * During the initialization, verify that at least one input has been set.
     * @return {?}
     */
    ngOnInit() {
        // If there's no input, this component wouldn't know what to do and throw exception.
        if (isBlank(this.bindings) && isBlank(this.tagName)) {
            throw new Error('GenericContainerComponent input bindings or tagName ' +
                'have not been set.');
        }
        // If the tagName is blank, the get it from bindings.
        if (isBlank(this.tagName)) {
            this.tagName = this.bindings.get('tagName');
            if (isBlank(this.tagName)) {
                this.tagName = GenericContainerComponent.DefaultTagName;
            }
        }
        // Save first added
        this.childElement = this.nativeElement.firstChild;
        this.doRender();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (isPresent(this.childElement) &&
            this.childElement.parentNode !== this.nativeElement.firstChild) {
            this.nativeElement.firstChild.appendChild(this.childElement);
        }
    }
    /**
     * After content has been initialized. Create the tagName element. Apply all the bindings on to
     * the element as attribute. Finally, move the child element, <ng-content>, to inside the
     * wrapper component.
     * @return {?}
     */
    doRender() {
        /** @type {?} */
        const el = this.renderer.createElement(this.tagName);
        if (isPresent(this.nativeElement)) {
            this.renderer.appendChild(this.nativeElement, el);
        }
        // Loop through all the bindings and add them to the element.
        MapWrapper.iterable(this.bindings).forEach((v, k) => {
            this.renderer.setStyle(el, k, v);
        });
        // Attach the component to this divElement.
        el.appendChild(this.childElement);
    }
}
/**
 * Default tagName if none is specified inside bindings.
 *
 */
GenericContainerComponent.DefaultTagName = 'div';
GenericContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-generic-container',
                template: '<ng-content></ng-content>'
            }] }
];
/** @nocollapse */
GenericContainerComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
GenericContainerComponent.propDecorators = {
    bindings: [{ type: Input }],
    tagName: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *  Base component shares common functionality among all the components (layouts, widgets).
 *
 * @abstract
 */
class BaseComponent {
    /**
     * @param {?=} env
     */
    constructor(env) {
        this.env = env;
        /**
         * Adds disabled flag to the component
         *
         */
        this.disabled = false;
        /**
         * Weather this component is visible
         * Default is false;
         */
        this.visible = false;
        /**
         * Tell  the component if we are in editing mode.
         *
         */
        this.editable = true;
        /**
         * Removes padding from the component. Usually used when we are nesting other component with
         * its own grid.
         */
        this.omitPadding = false;
        /**
         * Prefix for the correct asset path
         */
        this.assetFolder = 'assets';
        this.extBindings = new Map();
        this.omitPadding = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.assetFolder = this.env.getValue(AppConfig.AssetFolder);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
}
BaseComponent.propDecorators = {
    disabled: [{ type: Input }],
    visible: [{ type: Input }],
    editable: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    styleClass: [{ type: Input }],
    omitPadding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const WidgetSizeColumns = {
    xsmall: 1,
    small: 3,
    medium: 6,
    large: 9,
    xlarge: 12,
};
WidgetSizeColumns[WidgetSizeColumns.xsmall] = 'xsmall';
WidgetSizeColumns[WidgetSizeColumns.small] = 'small';
WidgetSizeColumns[WidgetSizeColumns.medium] = 'medium';
WidgetSizeColumns[WidgetSizeColumns.large] = 'large';
WidgetSizeColumns[WidgetSizeColumns.xlarge] = 'xlarge';
/**
 *  BaseFormComponnet extends BaseComponent for add specific form behavior
 *
 * @abstract
 */
class BaseFormComponent extends BaseComponent {
    /**
     * Some of the BaseFormComponent can wrap other component and in these cases we want to
     * inherit some of the behavior from parent
     *
     * \@Inject(Environment) public env: Environment : is tem a workaround as without inject
     * on this specific component it complains that Environment is unresolved symbol
     *
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * Is current element visible
         */
        this.hidden = false;
        /**
         * Renders required flex around the component
         *
         */
        this.required = false;
        /**
         *  a text displayed when value is empty or NULL
         */
        this.placeHolder = '';
        /**
         * Identify if this control is used directly or if its part of some other control
         * e.g. GenericChooser and managed by this control.
         * Meaning State is mananged outside of this component
         *
         */
        this.isStandalone = true;
        this.onModelChanged = noop;
        this.onModelTouched = noop;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isPresent(this.parentContainer)) {
            this.formGroup = this.parentContainer.formGroup;
            this.editable = this.parentContainer.editable;
        }
        this.checkInitForm();
    }
    /**
     * Make sure that we have available formGroup and Name and ID
     *
     * @return {?}
     */
    checkInitForm() {
        if (isBlank(this.env.currentForm)) {
            this.env.currentForm = new FormGroup({});
        }
        /**
                 * Todo: Right now I just need to initialize name , but ideally it needs to be generated
                 * number basedon some semantics app.page.component if there are more component on the page
                 * then app.page.componentNumber. Simple solution is to is to get Elementref and query it.
                 */
        if (isBlank(this.name)) {
            this.name = uuid();
        }
        if (isBlank(this.id)) {
            this.id = uuid();
        }
    }
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    doRegister(name, value) {
        /** @type {?} */
        let fControl;
        if (isBlank(this.formGroup.controls[name])) {
            this.formGroup.registerControl(name, new FormControl(value));
            fControl = /** @type {?} */ (this.formGroup.controls[name]);
        }
        else {
            fControl = /** @type {?} */ (this.formGroup.controls[name]);
            /** @type {?} */
            let updatedValue = isPresent(fControl.value) ? fControl.value : value;
            fControl.patchValue(updatedValue, { onlySelf: true, emitEvent: false });
        }
        return fControl;
    }
    /**
     * When we are dealing with Forms this is a helper method to register control
     *
     *
     * @param {?} value default value to be pre-set
     * @return {?}
     */
    registerFormControl(value) {
        this.formControl = this.doRegister(this.name, value);
        if (this.disabled) {
            this.formControl.disable();
        }
    }
    /**
     * @return {?}
     */
    get formGroup() {
        return isPresent(this._formGroup) ? this._formGroup : this.env.currentForm;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set formGroup(value) {
        this._formGroup = value;
    }
    /**
     * Indicates if we can pass field type as a binding to the components. e.g. InputField need
     * such type to correctly render input type=text, number
     *
     * todo: is this needed? can we maybe pass this to the formRow?
     * @return {?}
     */
    canSetType() {
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChanged = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
/*
     *  Supported layout constants. It is expected there will be more options as we currently
     *  support only these two there will be other variations of it. e.g. for stacked it will not
     *  be 1 columns like it is now but multiple columns
     *
     */
BaseFormComponent.LayoutStacked = 'stacked';
BaseFormComponent.LayoutInline = 'inline';
/** @nocollapse */
BaseFormComponent.ctorParameters = () => [
    { type: Environment, decorators: [{ type: Inject, args: [Environment,] }] },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
BaseFormComponent.propDecorators = {
    name: [{ type: Input }],
    id: [{ type: Input }],
    hidden: [{ type: Input }],
    required: [{ type: Input }],
    placeHolder: [{ type: Input }],
    isStandalone: [{ type: Input }],
    formGroup: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Simple component rendering values in the read only mode. Just needed some component used
 * to render Strings in read only mode
 *
 *
 *  ### Example
 *
 * Using it inside form container along with label
 *
 *
 *  ```
 * \@Component({
 *              selector: 'userInfo' ,
 *              template: `
 *                      <aw-form-table [editable]="false" >
 *                          <aw-form-row [name]="fieldName"  [label]="label">
 *                                 <aw-string [value]="inputValue" ></aw-string>
 *                           </aw-form-row>
 *                      </aw-form-table>
 *
 *                  `
 *          })
 *          export class UserProfileComponent
 *          {
 *              inputValue: string = 'Some text';
 *              inputType: string = 'string';
 *              fieldName: string = 'firstName';
 *              label: string = 'My Name';
 *              required: boolean = true;
 *              editing: boolean = true;
 *              labelsOnTop: boolean = false;
 *
 *          }
 *
 *  ```
 *
 * You can also pass html tags.
 *
 */
class StringComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} sanitizer
     * @param {?} parentContainer
     */
    constructor(env, sanitizer, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.sanitizer = sanitizer;
        this.parentContainer = parentContainer;
        /**
         *  Value to be interpolated
         *
         */
        this._value = '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this.sanitizer.bypassSecurityTrustHtml(this._value);
    }
}
StringComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-string',
                template: `
        <span class="w-string-field" [innerHTML]="value"></span>
    `,
                styles: [".w-string-field{display:inline-block}"]
            }] }
];
/** @nocollapse */
StringComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomSanitizer },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
StringComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * A class holding a references to components. The methods are self-explanatory.
 *
 */
class ComponentRegistry {
    /**
     * @param {?} env
     */
    constructor(env) {
        this.env = env;
        this._nameToType = new Map();
    }
    /**
     * @param {?} references
     * @return {?}
     */
    initialize(references) {
        this.registerTypes(references);
        /** @type {?} */
        let promise = new Promise((resolve) => {
            resolve(true);
        });
        return promise;
    }
    /**
     * @param {?} name
     * @param {?} type
     * @return {?}
     */
    registerType(name, type) {
        if (!this.nameToType.has(name)) {
            this._nameToType.set(name, type);
        }
    }
    /**
     * @param {?} references
     * @return {?}
     */
    registerTypes(references) {
        if (!isStringMap(references)) {
            return;
        }
        Object.keys(references).forEach((name) => {
            this.registerType(name, references[name]);
        });
    }
    /**
     * @return {?}
     */
    get nameToType() {
        return this._nameToType;
    }
}
ComponentRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ComponentRegistry.ctorParameters = () => [
    { type: Environment }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *  `IncludeComponent` directive dynamically instantiate and insert a components into the screen
 * based on the name. It can accepts bindings as well which will be automatically bound and applied
 * to the component
 *
 *  ### usage:
 *
 *  Instead of inserting component in the way:
 *
 *  ```
 *    <textfield value="some value">
 *
 *  ```
 *
 *  you can do so dynamically like this:
 *
 * ```
 *  <aw-include-component 'TextfieldComponent' [bindings]=bindings ></aw-include-component>
 * ```
 *
 * This is the main building block to dynamically generated UI.
 *
 *
 * Todo: Currently the way Angular API work and we use it to create programatically components
 * is too complext we need to create everything 3 different calls to place a component to the
 * container. What I want is is to create some kind of representation of ContainerElement and this
 * can be also parent for our BaseComponent with method add and remove content. Then we could have
 * some AWContent.
 *
 * e.g.: to replace applyContentElementIfAny where we have several calls to create and add
 * component to the view.
 *
 * ```ts
 *  let containerElement = AWConcreteTemplate(viewContainer, factoryResolver)
 *  containerElement.add('Clck Me')
 * ```
 *
 * To assemble different components together - not only adding string content
 *
 * ```ts
 *  let content = new AWContent(ButtonComponent, bindingsMap)
 *  content.add('Click Me');
 *  containerElement.add(content)
 *
 * ```
 *
 * add more component hierarchy:
 *
 * ```ts
 *  let content = new AWContent(HoverCardComponnets, bindingsMap)
 *  content.add(createLayout();
 *  containerElement.add(content)
 *
 * ```
 *
 *
 *
 *
 */
class IncludeComponentDirective {
    /**
     * @param {?} viewContainer
     * @param {?} factoryResolver
     * @param {?} cd
     * @param {?} compRegistry
     */
    constructor(viewContainer, factoryResolver, cd, compRegistry) {
        this.viewContainer = viewContainer;
        this.factoryResolver = factoryResolver;
        this.cd = cd;
        this.compRegistry = compRegistry;
        /**
         * I use this flag to identify that component is rendering for first time or its updated during
         * change detection
         *
         */
        this.initRenderInProgress = false;
        /**
         * Not sure if we need this, but want to keep it here or maybe move it to some service so we
         * can cache created components and maybe reuse them.
         *
         */
        this.componentReferences = new Map();
        this.bindings = new Map();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initRenderInProgress = true;
        // todo: check if this the right lifecycle callback, this is called only once and you want
        // to probably listen for changes, and change dection decide there is some change and we
        // need to re-draw the view
        this.viewContainer.clear();
        this.doRenderComponent();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (isPresent(changes['name']) &&
            (changes['name'].currentValue !== changes['name'].previousValue)) {
            this.viewContainer.clear();
            this.doRenderComponent();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.initRenderInProgress = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // check to see if we need to render and reposition DOM element both for wrapper and
        // content
        this.createWrapperElementIfAny();
        this.createContentElementIfAny();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * Handles a case where we need to resolve additional component and wrap the current one.
     * Just like reateContentElementIfAny() this method needs to be executed after all
     * is created and initialized (inside the ngAfterViewInit() )
     *
     * @return {?}
     */
    createWrapperElementIfAny() {
    }
    /**
     * Renders a component into actual View Container. The process goes as this.
     *  1. We retrieve component Type based on the component name, which creates componentRef
     *  2. Place the component onto the screen
     *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
     *  4. Manually spin change detection to update the screen. Mainly for case where I need to
     * redraw a screen
     * @return {?}
     */
    doRenderComponent() {
        this.placeTheComponent();
        // this.currentComponent.changeDetectorRef.detach();
        this.applyBindings(this.componentReference(), this.currentComponent, this.bindings);
        // this.currentComponent.changeDetectorRef.detectChanges();
        // Still not sure about this what all I should release here.
        this.currentComponent.onDestroy(() => {
            // this.bindings.clear();
            // this.bindings = undefined;
            //
            // this.componentReferences.clear();
            // this.componentReferences = undefined;
            this.destroy();
        });
    }
    /**
     * Place actual component onto the screen using ViewContainerRef
     *
     * @return {?}
     */
    placeTheComponent() {
        /** @type {?} */
        let reference = this.componentReference();
        this.currentComponent = this.viewContainer.createComponent(reference.resolvedCompFactory);
    }
    /**
     * When inserting Component that needs to have a content like e.g. hyperlink or button
     *
     * ```
     *   <button> MY NG CONTENT </button>
     *
     * ```
     *  this method applies and insert a child content into the main component. This method insert
     * a simple string. We are not wrapping existing component with another component here.
     *
     * @return {?} need to run detect changes ? default is false
     */
    createContentElementIfAny() {
        /** @type {?} */
        let detectChanges = false;
        /** @type {?} */
        let ngContent = this.ngContent();
        /** @type {?} */
        let ngContentElement = this.ngContentElement();
        if (isPresent(ngContent)) {
            /** @type {?} */
            let awContentComponent = this.factoryResolver.resolveComponentFactory(StringComponent);
            /** @type {?} */
            let component = this.viewContainer.createComponent(awContentComponent, 0);
            (/** @type {?} */ (component.instance)).value = ngContent;
            /** @type {?} */
            let awContentContainer = this.currentComponent.location.nativeElement.firstChild;
            awContentContainer.appendChild(component.location.nativeElement);
            detectChanges = true;
        }
        else if (isPresent(ngContentElement)) ;
        return detectChanges;
    }
    /**
     *
     * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
     * applying other bindings.
     *
     * @return {?}
     */
    ngContent() {
        /** @type {?} */
        let content;
        if (isPresent(content = this.bindings.get(IncludeComponentDirective.NgContent))) {
            this.bindings.delete(IncludeComponentDirective.NgContent);
        }
        return content;
    }
    /**
     * @return {?}
     */
    ngContentElement() {
        /** @type {?} */
        let content;
        if (isPresent(content = this.bindings.get(IncludeComponentDirective.NgContentElement))) {
            this.bindings.delete(IncludeComponentDirective.NgContentElement);
        }
        return content;
    }
    /**
     * We need to convert a component name to actual a type and then use ComponentFactoryResolver
     * to instantiate a a component and save its information into our component references. The
     * reason why we have this component reference is we need to store Angular's component metadata
     * so we can iterate thru all the inputs and bind them to the context.
     *
     * returns {ComponentReference} a reference representing a compoent currently being rendered
     * @return {?}
     */
    componentReference() {
        if (isPresent(this.resolvedComponentRef)) {
            return this.resolvedComponentRef;
        }
        /** @type {?} */
        let currType = this.resolveComponentType();
        /** @type {?} */
        let componentFactory = this.factoryResolver
            .resolveComponentFactory(currType);
        /** @type {?} */
        let componentMeta = this.resolveDirective(componentFactory);
        /** @type {?} */
        let compReference = {
            metadata: componentMeta,
            resolvedCompFactory: componentFactory,
            componentType: currType,
            componentName: this.name
        };
        this.resolvedComponentRef = compReference;
        return compReference;
    }
    /**
     * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
     * 'this.bindings'
     * @param {?} cRef
     * @param {?} component
     * @param {?} bindings
     * @return {?}
     */
    applyBindings(cRef, component, bindings) {
        /** @type {?} */
        let inputs = cRef.metadata.inputs;
        if (isBlank(inputs) || inputs.length === 0) {
            return;
        }
        // should we do any type conversion?
        MapWrapper.iterable(bindings).forEach((v, k) => {
            if (isPresent(component.instance[k])) {
                component.instance[k] = v;
            }
        });
    }
    /**
     * Resolves a component Type based on the string literal
     *
     * @return {?} component type used by `ComponentFactoryResolver`
     *
     * todo: rename the method so its clear that it returns component type based on string.
     */
    resolveComponentType() {
        /** @type {?} */
        let componentType = this.compRegistry.nameToType.get(this.name);
        if (isBlank(componentType)) {
            assert(false, this.name + ' component does not exists. Create Dummy Component instead' +
                ' of throwing this error');
            return;
        }
        return componentType;
    }
    /**
     * @param {?} compFactory
     * @return {?}
     */
    resolveDirective(compFactory) {
        /** @type {?} */
        let compMeta = {
            inputs: [],
            outputs: []
        };
        if (isPresent(compFactory.inputs) && compFactory.inputs.length > 0) {
            compFactory.inputs.forEach((input) => {
                compMeta.inputs.push(input.propName);
            });
        }
        if (isPresent(compFactory.outputs) && compFactory.outputs.length > 0) {
            compFactory.outputs.forEach((output) => {
                compMeta.outputs.push(output.propName);
            });
        }
        return compMeta;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (isPresent(this.currentComponent)) {
            this.currentComponent.destroy();
            this.currentComponent = undefined;
        }
        if (isPresent(this.viewContainer)) {
            this.viewContainer.clear();
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (isPresent(this.currentComponent)) {
            this.currentComponent = null;
            this.resolvedComponentRef = null;
        }
    }
}
IncludeComponentDirective.NgContent = 'ngcontent';
IncludeComponentDirective.NgContentElement = 'ngcontentElement';
IncludeComponentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'aw-include-component'
            },] }
];
/** @nocollapse */
IncludeComponentDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: ComponentRegistry }
];
IncludeComponentDirective.propDecorators = {
    name: [{ type: Input }],
    bindings: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Error Manager is a service used by Forms components to map error codes into meaningful messages.
 * Currently it does not have much but once we plug in localization it will make more sense
 *
 *
 * todo: Once ng-translate is implemented replace this with ng-translate functionality so we can
 * externalize these messages into locale files.
 *
 */
class ErrorManagerService {
    constructor() {
        this.messages = {
            'required': 'Required field',
            'minlength': 'Field does not meet minimum length',
            'maxlength': 'Field does not meet maximum length',
            'customMsg': '%s',
            'metavalid': '%s'
        };
    }
    /**
     * @param {?} validatorName
     * @param {?=} validatorValue
     * @return {?}
     */
    errorMessage(validatorName, validatorValue) {
        /** @type {?} */
        let message = this.messages[validatorName];
        if (StringWrapper.contains(message, '%s')) {
            // todo: use ng-translate with proper message formatting
            return StringWrapper.replace(message, '%s', validatorValue.msg);
        }
        return message;
    }
}
ErrorManagerService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ErrorManagerService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * ErrorMessagesComponent is used by form's component like FormRow to print its validation errors.
 * Its  based on ModelDriven (Reactive forms) and it reads errors from FormControl
 *
 *
 *
 */
class ErrorMessagesComponent {
    /**
     * @param {?} errManager
     */
    constructor(errManager) {
        this.errManager = errManager;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    hasMessage() {
        /** @type {?} */
        let msg = this.errorMsg;
        return isPresent(msg);
    }
    /**
     * Retrieve a messages if any registered by added validators
     *
     * @return {?}
     */
    get errorMsg() {
        for (let propertyName in this.control.errors) {
            if (this.control.errors.hasOwnProperty(propertyName) && this.control.touched) {
                return this.errManager.errorMessage(propertyName, this.control.errors[propertyName]);
            }
        }
    }
    /**
     *
     * Show errors? We currently shows errors if the control is not valid, it was touched by user.
     * Most of the type on blur event  and at last its not pristine anymore (its dirty)
     *
     * @return {?}
     */
    showErrors() {
        return !this.control.valid && !this.control.pristine && this.control.touched;
    }
}
ErrorMessagesComponent.decorators = [
    { type: Component, args: [{
                selector: 'a-error-messages',
                template: `
            <div class="ui-g">
                    <small *ngIf="hasMessage()"
                        class="ui-g-12 ui-message ui-messages-error ui-corner-all">
                        {{ errorMsg }}
                    </small>
            </div>
    `,
                styles: [""]
            }] }
];
/** @nocollapse */
ErrorMessagesComponent.ctorParameters = () => [
    { type: ErrorManagerService }
];
ErrorMessagesComponent.propDecorators = {
    control: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Modal service is used to to create modal dialogs. It creates modal dialogs dynamically.
 * The service also keeps track of the created modal dialog and can close it by calling the
 * service's close()
 *
 * Modal service requires a ViewContainer to insert newly created modals. This is taken care
 * by the ModalComponent.
 *
 * Usage:
 *     Add   <aw-modal></aw-modal>  into your application main html. It needs to be on every
 *     page where a modal dialog will appear.
 *
 *    1.  Popup a dialog without creating your own component.
 *        Use the existing DialogComponent in widgets.
 *
 *             this.modalService.open<DialogComponent>(DialogComponent, {
 *                     title: 'My Popup Title',
 *                     body: 'My Popup Body'
 *              });
 *
 *
 *   2.   Creating your own Dialog Component to popup.
 *
 *         let componentRef = this.modalService.open<MyDialogComponent>(MyDialogComponent,
 * {inputs});
 *
 * \@Component({
 *                selector: 'aw-mydialog' ,
 *                           template: `
 *                                         <aw-dialog (onClose)="closePopup()">
 *                                              <ng-template #titleTemplate>
 *                                                 <span><i class="fa fa-envira" ></i>This is my
 *     Title </span>
 *                                              </ng-template>
 *                                              <ng-template #bodyTemplate>
 *                                                 <span><i class="fa fa-envira" ></i>This is my
 *     Body </span>
 *                                              </ng-template>
 *                                        </aw-dialog>
 *                                     `
 *         })
 *         export class MyDialogComponent extends DialogComponent implements OnInit {
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     closePopup() {
 *                            this.modalService.close();
 *                      }
 *         }
 */
class ModalService {
    /**
     * DI ComponentFactoryResolver to be used to create modal component.
     *
     * @param {?} cfr
     */
    constructor(cfr) {
        this.cfr = cfr;
    }
    /**
     *  PlaceHolder for modal to be inserted.
     *
     * @param {?} vcRef
     * @return {?}
     */
    registerViewContainerRef(vcRef) {
        this.vcRef = vcRef;
    }
    /**
     * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
     *
     * @template T
     * @param {?} component
     * @param {?=} parameters
     * @return {?}
     */
    open(component, parameters) {
        /** @type {?} */
        const cf = this.cfr.resolveComponentFactory(component);
        /** @type {?} */
        let componentRef = this.vcRef.createComponent(cf);
        // Auto set visiblity to true. So that the Dialog will display
        parameters = (parameters) ? parameters : {};
        parameters['visible'] = true;
        // Handle output parameters.
        ModalService.OUTPUT_PARAMETERS.forEach((param) => {
            if (parameters[param]) {
                (/** @type {?} */ (componentRef.instance))[param].subscribe(parameters[param]);
                delete parameters[param];
            }
        });
        Object.assign(componentRef.instance, parameters);
        // had to cast it in order to avoid any index Error
        // Attach a destroy method to the newly created component.
        (/** @type {?} */ (componentRef.instance))['destroy'] = () => {
            componentRef.destroy();
        };
        // Save the instance, so it can be destroyed later.
        this.instance = componentRef;
        return componentRef;
    }
    /**
     * Calling close() will remove the modal from view.
     * @return {?}
     */
    close() {
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
    }
}
/**
 * This is a static list of output parameter from Dialog, Confirmation components
 * that needs to be handled.
 *
 */
ModalService.OUTPUT_PARAMETERS = ['onClose', 'onConfirm', 'onCancel'];
ModalService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ModalService.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Place holder for all modal dialogs. This component works with the modalService by providing
 * a place holder for it to inject Dialog component into.
 */
class ModalComponent {
    /**
     * @param {?} modalService
     */
    constructor(modalService) {
        this.modalService = modalService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.modalService.registerViewContainerRef(this.viewContainerRef);
    }
}
ModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-modal',
                template: "<div #modal></div>\n",
                styles: [""]
            }] }
];
/** @nocollapse */
ModalComponent.ctorParameters = () => [
    { type: ModalService }
];
ModalComponent.propDecorators = {
    viewContainerRef: [{ type: ViewChild, args: ['modal', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * This currency formatter will ignore null and empty string for value.
 * Issue : https://github.com/angular/angular/issues/8694  DI fails when extends other classes
 */
class CurrencyFormatPipe {
    /**
     * @param {?} currencyPipe
     */
    constructor(currencyPipe) {
        this.currencyPipe = currencyPipe;
    }
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        /** @type {?} */
        let currencyCode = 'USD';
        /** @type {?} */
        let symbolDisplay = true;
        /** @type {?} */
        let digits = '1.0-2';
        if (!value || value.length === 0) {
            return value;
        }
        if (args && args.length > 0) {
            /** @type {?} */
            let code = args[0];
            if (code && code.length > 0) {
                currencyCode = code;
            }
        }
        return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
    }
}
CurrencyFormatPipe.decorators = [
    { type: Pipe, args: [{
                name: 'currencyFormat',
                pure: false
            },] }
];
/** @nocollapse */
CurrencyFormatPipe.ctorParameters = () => [
    { type: CurrencyPipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Simple utility directive that is used by NG For cycle in situation where we need to call a
 * or execute some logic after each iteration
 */
class NgForSetDirective {
    constructor() {
        this.onItem = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onItem.emit('--');
    }
}
NgForSetDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngForSet]'
            },] }
];
/** @nocollapse */
NgForSetDirective.ctorParameters = () => [];
NgForSetDirective.propDecorators = {
    onItem: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Simple convenient service to work with the dom. All the future logic related to DOM manipulation
 * or traversal should be put into this service
 *
 */
class DomUtilsService {
    constructor() {
    }
    /**
     * goes all the way up to the body and checks if there is a element identified by a 'selector'
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    hasParent(nativeElement, selector) {
        return isPresent(this.closest(nativeElement, selector));
    }
    /**
     *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
     * not found
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    closest(nativeElement, selector) {
        /** @type {?} */
        let firstChar = selector.charAt(0);
        /** @type {?} */
        let parentNode = nativeElement;
        while (isPresent((parentNode = parentNode.parentNode))) {
            if (firstChar === '.' && parentNode.classList.contains(selector.substr(1))) {
                return parentNode;
            }
            if (firstChar === '#' && parentNode.id === selector.substr(1)) {
                return parentNode;
            }
            // If selector is a tag
            if (parentNode.nodeType === 1 && parentNode.tagName.toLowerCase() === selector) {
                return parentNode;
            }
            if (parentNode.nodeType === 1 && parentNode.tagName === 'BODY') {
                return null;
            }
        }
        return null;
    }
    /**
     * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
     * which always corresponds with _nghost_INDEX, this works fine if we have actual component
     * that is already rendered. If we are creating component programatically there is no way to
     * identify where the actual ng-content is placed within the component
     *
     * e.g. Consider following example:
     *
     *
     * Button Component Template:
     *
     * ```
     *  <span class=mybuttonTitle><ng-content></ng-content></span>
     * ```
     *
     * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
     *
     * ```
     * <aw-button _nghost_123>
     *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
     * </aw-button>
     * ```
     *
     * But with programmatic API you instantiate Button and since it created without a Content it
     * looks like this;
     *
     *  ```
     * <aw-button _nghost_123>
     *  <span class=mybuttonTitle></span>
     * </aw-button>
     * ```
     *
     * Where do you place you child (content component)? Therefore utility css class was created
     * to wrap <ng-content> to get around this limitation.
     *
     *  ```
     *   <span class="u-ngcontent">
     *      <ng-content></ng-content>
     *   </span>
     *  ````
     *
     *
     *
     *
     * @param {?} parentNativeEl
     * @param {?} childNativeEl
     * @return {?}
     */
    insertIntoParentNgContent(parentNativeEl, childNativeEl) {
        /** @type {?} */
        let ngContentParent = parentNativeEl;
        /** @type {?} */
        let foundNgContent = parentNativeEl.querySelector('.u-ngcontent');
        if (isPresent(foundNgContent)) {
            // we don't cover a case where there could be multiple ngcontents
            ngContentParent = foundNgContent;
        }
        ngContentParent.appendChild(childNativeEl);
    }
    /**
     *
     * Retrieves current browser window width and height
     *
     * @return {?}
     */
    browserDimentions() {
        return {
            width: (window.innerWidth || document.documentElement.clientWidth
                || document.body.clientWidth),
            height: (window.innerHeight || document.documentElement.clientHeight
                || document.body.clientHeight)
        };
    }
    /**
     *
     * Retrieves elemements dimensions
     *
     * @param {?} element
     * @return {?}
     */
    elementDimensions(element) {
        if (isPresent(element.getBoundingClientRect)) {
            return element.getBoundingClientRect();
        }
        return { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0, width: 0, height: 0 };
    }
}
DomUtilsService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DomUtilsService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * The Infinite Scroll allows you to perform an action when the user
 * scrolls a specified distance from the bottom or top of the page.
 *
 * The expression assigned to the `infinite` event is called when
 * the user scrolls to the specified distance. When this expression
 * has finished its tasks, it should call the `complete()` method
 * on the infinite scroll instance.
 *
 * ## Usage
 *
 * ```html
 *
 *  <div  *ngFor="let item of items">{{item}} </div>
 *   <aw-infinite-scroll (onLoad)="doInfinite($event)">
 *  </aw-infinite-scroll>
 *
 * ```
 *
 *
 * You can also set a threshold to change the distance when the lazy load kicks
 * in.
 * ## Usage
 *
 * ```html
 *
 *  <div  *ngFor="let item of items">{{item}} </div>
 *   <aw-infinite-scroll (onLoad)="doInfinite($event)"  [distance]="'15%'">
 *  </aw-infinite-scroll>
 *
 * ```
 */
class InfiniteScrollComponent {
    /**
     * @param {?} _render
     * @param {?} _zone
     * @param {?} domUtils
     * @param {?} _cd
     */
    constructor(_render, _zone, domUtils, _cd) {
        this._render = _render;
        this._zone = _zone;
        this.domUtils = domUtils;
        this._cd = _cd;
        this._lastCheck = 0;
        this._lastScrollTop = 0;
        this._thr = '10%';
        this._thrPx = 0;
        this._thrPc = 0.10;
        this._init = false;
        /**
         * \@internal
         */
        this.state = STATE_ENABLED;
        /**
         * \@output {event} Emitted when the scroll reaches
         * the threshold distance. From within your infinite handler,
         * you must call the infinite scroll's `complete()` method when
         * your async operation has completed.
         */
        this.onLoad = new EventEmitter();
        /**
         *
         * Lazy load current numbers. tell the app starting point and what is the size of loaded
         * list
         *
         */
        this.fetchSize = 0;
        this.loadOffset = 0;
    }
    /**
     * \@input {string} The threshold distance from the bottom
     * of the content to call the `onLoad` output event when scrolled.
     * The threshold value can be either a percent, or
     * in pixels. For example, use the value of `10%` for the `infinite`
     * output event to get called when the user has scrolled 10%
     * from the bottom of the page. Use the value `100px` when the
     * scroll is within 100 pixels from the bottom of the page.
     * Default is `15%`.
     * @return {?}
     */
    get distance() {
        return this._thr;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set distance(val) {
        this._thr = val;
        if (val.indexOf('%') > -1) {
            this._thrPx = 0;
            this._thrPc = (parseFloat(val) / 100);
        }
        else {
            this._thrPx = parseFloat(val);
            this._thrPc = 0;
        }
    }
    /**
     * \@input {boolean} If true, Whether or not the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     * @param {?} shouldEnable
     * @return {?}
     */
    set enabled(shouldEnable) {
        this.enable(shouldEnable);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._render.addClass(document.body, 'has-infinite-scroll');
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    _onScroll(ev) {
        if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
            return;
        }
        // must throttle the class by 100ms
        if (this._lastCheck + 100 > ev.timeStamp) {
            // no need to check less than every XXms
            return;
        }
        this._lastCheck = ev.timeStamp;
        /** @type {?} */
        let scrollTop = this.scrollTop();
        /** @type {?} */
        let winHeight = this.domUtils.browserDimentions().height;
        /** @type {?} */
        const height = Math.max(this._docBody.scrollHeight, this._docBody.offsetHeight, winHeight, this._content.scrollHeight, this._content.offsetHeight);
        if (!height) {
            // if there is no height of this element then do nothing
            return;
        }
        /** @type {?} */
        const threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
        /** @type {?} */
        let distanceFromInfinite = this._content.scrollHeight - winHeight - scrollTop - threshold;
        // console.log('Document height (' + height + ') , Distance from bottom '
        // + distanceFromInfinite + ',  => threshold = ' +
        //     this.distance + ' (' + threshold + ')');
        if (distanceFromInfinite < 0 && this._lastScrollTop < scrollTop) {
            this.fireOnLazyLoad();
        }
        else if (this._lastScrollTop > scrollTop && scrollTop < winHeight
            && this.loadOffset !== this.fetchSize) {
            this.fireOnLazyUnLoad();
        }
        this._lastScrollTop = scrollTop;
        return;
    }
    /**
     * Todo: refactor to one method
     * @return {?}
     */
    fireOnLazyLoad() {
        this._zone.run(() => {
            if (this.state !== STATE_LOADING && this.state !== STATE_DISABLED) {
                this.state = STATE_LOADING;
                this.onLoad.emit({
                    isLoad: true,
                    limit: this.fetchSize,
                    offset: this.loadOffset
                });
                // start on the next record
                this.loadOffset += this.fetchSize;
            }
        });
    }
    /**
     * @return {?}
     */
    fireOnLazyUnLoad() {
        this._zone.run(() => {
            if (this.state !== STATE_LOADING && this.state !== STATE_DISABLED) {
                this.state = STATE_LOADING;
                // start on the next record
                this.loadOffset = this.fetchSize;
                this.onLoad.emit({
                    isLoad: false,
                    limit: this.fetchSize,
                    offset: this.loadOffset
                });
            }
        });
    }
    /**
     * @return {?}
     */
    scrollTop() {
        return (window.pageYOffset || this._content.scrollTop);
    }
    /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     * @return {?}
     */
    complete() {
        if (this.state !== STATE_LOADING) {
            return;
        }
        setTimeout(() => {
            this.state = STATE_ENABLED;
            // need to trigger extra detect changes to rerender loading icon
            this._cd.detectChanges();
        }, 100);
    }
    /**
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     * @param {?} shouldEnable  If the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     * @return {?}
     */
    enable(shouldEnable) {
        this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
        this._setListeners(shouldEnable);
    }
    /**
     * Subscribes to native windows scroll event
     * @param {?} shouldListen
     * @return {?}
     */
    _setListeners(shouldListen) {
        if (this._init) {
            if (shouldListen) {
                if (!this._scLsn) {
                    this._zone.runOutsideAngular(() => {
                        this._scLsn = this._onScroll.bind(this);
                        window.addEventListener('scroll', this._scLsn);
                    });
                }
            }
            else {
                if (isPresent(this._scLsn)) {
                    window.removeEventListener('scroll', this._scLsn);
                    this._scLsn = null;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    isLoading() {
        return this.state === STATE_LOADING;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._init = true;
        this._docBody = document.body;
        this._content = document.documentElement;
        this._setListeners(this.state !== STATE_DISABLED);
        if (this.loadOffset === 0) {
            this.fireOnLazyLoad();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._setListeners(false);
    }
}
InfiniteScrollComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-infinite-scroll',
                template: "<div class=\"w-infinite-loader-panel\" *ngIf=\"isLoading()\">\n    <span class=\"sap-icon icon-synchronize u-spin-icon\"></span>\n</div>\n",
                styles: [".w-infinite-loader-panel{display:flex;align-items:center;justify-content:center;background-color:#fff;width:100%;height:100px;z-index:300;bottom:100px}.w-infinite-loader-panel span{color:#4a4a4a;font-size:2em}"]
            }] }
];
/** @nocollapse */
InfiniteScrollComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: NgZone },
    { type: DomUtilsService },
    { type: ChangeDetectorRef }
];
InfiniteScrollComponent.propDecorators = {
    distance: [{ type: Input }],
    enabled: [{ type: Input }],
    onLoad: [{ type: Output }],
    loadPanel: [{ type: ViewChild, args: ['loadinPanel',] }],
    fetchSize: [{ type: Input }]
};
/** @type {?} */
const STATE_ENABLED = 'enabled';
/** @type {?} */
const STATE_DISABLED = 'disabled';
/** @type {?} */
const STATE_LOADING = 'loading';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AwNameStore {
    constructor() {
        this.store = new Map();
    }
    /**
     * @param {?} name
     * @param {?} el
     * @return {?}
     */
    add(name, el) {
        if (this.collides(name)) {
            throw new Error('Name is not unique!');
        }
        return this.store.set(name, el);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    remove(name) {
        return this.store.delete(name);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    collides(name) {
        return this.store.has(name);
    }
    /**
     * @return {?}
     */
    clear() {
        this.store.clear();
    }
}
AwNameStore.decorators = [
    { type: Injectable }
];
/** @nocollapse */
AwNameStore.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * The 'awName' directive attaches a identifier to decorated element to aid selectors for testing
 * purposes. The 'awName' directive tries to generate a unique identifier based on contextual data
 * and inherant immutable element attributes.
 *
 * **Generating the Base Name**
 *
 * The 'awName' directive generates a base name from element tag name and attributes which are
 * static by nature.
 *
 *     Example:
 *         <button name="order" awName>
 *
 *     Result:
 *         <button name="order" awname="button_order">
 *
 * If the element has an 'id', that value takes precedent and is used instead of a generated
 * name.
 *
 *     Example:
 *         <button name="order" id="myOrderButton" awName>
 *
 *     Result:
 *         <button name="order" id="myOrderButton" awname="button_myOrderButton">
 *
 *
 * **Repeated Elements and the 'ext' Parameter**
 *
 * There are many cases where elements are generated dynamically in the code as lists or tables.
 * In such cases, it may not be easy to distinguish individual elements by standard HTML
 * attributes, so the 'awName' directive allows custom extentions to the base name to be provided
 * using the 'ext' attribute.
 *
 *    Example:
 *        fruits = ['apple', 'banana', 'orange'];
 *
 *        <ul>
 *            <li *ngFor="let fruit of fruits" awName ext="{{fruit}}">{{fruit}}</li>
 *        </ul>
 *
 *   Result:
 *       <ul>
 *           <li awname="li_apple">apple</li>
 *           <li awname="li_banana">banana</li>
 *           <li awname="li_orane">orange</li>
 *       </ul>
 *
 * **Adding Context Through Ancestor Inspection**
 *
 * In order to provide context to the element naming, the 'awName' directive loops through the
 * parent ancestry and searches for any unique element 'id' to prepend to the base name.
 *
 *     Example:
 *         <form id="applicant">
 *            <input type="text" name="firstName" awName>
 *            <input type="text" name="lastName" awName>
 *         </form>
 *         <form id="spouse">
 *            <input type="text" name="firstName" awName>
 *            <input type="text" name="lastName" awName>
 *         </form>
 *
 *     Result:
 *         <form id="applicant">
 *            <input type="text" name="firstName" awname="applicant_input_firstName">
 *            <input type="text" name="lastName" awname="applicant_input_lastName">
 *         </form>
 *         <form id="spouse">
 *            <input type="text" name="firstName" awname="spouse_input_firstName">
 *            <input type="text" name="lastName" awname="spouse_input_lastname">
 *         </form>
 *
 * **Uniqueness Check**
 *
 * 'awName' keeps track of the names it creates by adding them to a map store. Whenever it
 * creates a new name during the `ngOnInit` phase it checks it against the existing map,
 * and will throw an error if it encounters a duplicate. Moreover during the element destruction
 * phase, `ngOnDestroy`, 'awName' removes the generated name from the store.
 *
 *
 * **In Production**
 *
 * Using 'awName' adds a small bit of rendering overhead for each element it is used on. In
 * a production environment, 'awName' serves no functionality to the end user, but may have
 * a performance impact on the application. As such, 'awName' takes into account the
 * `AppConfig` settings and disables name generation when `AppConfig.isProductionMode()`
 * is `true`.
 *
 * In your application, you can turn on production mode by setting `devmode.enabled` to
 * `false` when configuring `AribaCoreModule`:
 *
 *     AribaCoreModule.forRoot({
 *         'devmode.enabled': false
 *     })
 *
 */
class AwNameDirective {
    /**
     * @param {?} el
     * @param {?} store
     * @param {?} config
     */
    constructor(el, store, config) {
        this.el = el;
        this.store = store;
        this.config = config;
        this.separator = '_';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.createName(this.el);
        this.addElementToStore(this.name, this.el);
        this.el.nativeElement.setAttribute('awname', this.name);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.store.remove(this.name);
    }
    /**
     * Add element name/id and reference to map store. If name/id already
     * exists in store then it throws an error.
     *
     * @param {?} name
     * @param {?} elem
     * @return {?}
     */
    addElementToStore(name, elem) {
        try {
            this.store.add(name, elem);
        }
        catch (e) {
            console.error(e.message + `. "${name}" is already in use.`, elem.nativeElement);
            return;
        }
    }
    /**
     * Generate name/id for element.
     *
     * param elem Reference to element
     * @param {?} elem
     * @return {?} String Name/ID
     */
    createName(elem) {
        /** @type {?} */
        const tagName = this.getTagName(elem);
        /** @type {?} */
        const parts = [];
        /** @type {?} */
        const parentID = this.getAncestorId(elem);
        if (parentID) {
            parts.push(parentID);
        }
        // Check the tag type
        if (tagName === 'option') {
            /** @type {?} */
            const parentName = this.getParentName(elem);
            if (parentName) {
                parts.push(parentName);
            }
        }
        // Get tagname
        parts.push(tagName);
        // Choose id property if it exists
        if (elem.nativeElement.id) {
            parts.push(elem.nativeElement.id);
            // Otherwise build extension from tag properties
        }
        else {
            // check for a name attribute
            if (elem.nativeElement.hasAttribute('name')) {
                parts.push(elem.nativeElement.name);
            }
            // check for value attribute if 'option' tag
            if (tagName === 'option') {
                if (elem.nativeElement.hasAttribute('value')) {
                    parts.push(this.spacesToUnderscore(elem.nativeElement.value));
                }
            }
        }
        // Add custom extension if it exists
        if (this.ext) {
            parts.push(this.spacesToUnderscore(this.ext));
        }
        return parts.join(this.separator);
    }
    /**
     * Get tag name from element reference.
     * @param {?} elem Reference to element
     * @return {?}
     */
    getTagName(elem) {
        return elem.nativeElement.tagName.toLowerCase();
    }
    /**
     * Traverse element ancestry and return first id attribute
     * encountered.
     * @param {?} elem Reference to element
     * @return {?}
     */
    getAncestorId(elem) {
        /** @type {?} */
        let parent = elem.nativeElement.parentNode;
        /** @type {?} */
        let id = '';
        while (parent && !id) {
            if (parent.id) {
                id = parent.id;
            }
            parent = parent.parentNode;
        }
        return id;
    }
    /**
     * Get name attribute from parent if name attribute exists.
     * @param {?} elem Reference to element
     * @return {?}
     */
    getParentName(elem) {
        /** @type {?} */
        const parent = elem.nativeElement.parentNode;
        return (parent.name && !parent.id) ? parent.name : null;
    }
    /**
     * @param {?} str
     * @return {?}
     */
    spacesToUnderscore(str) {
        return str.replace(/\s+/g, '_');
    }
}
AwNameDirective.decorators = [
    { type: Directive, args: [{
                selector: '[awName]',
            },] }
];
/** @nocollapse */
AwNameDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: AwNameStore },
    { type: AppConfig }
];
AwNameDirective.propDecorators = {
    ext: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWCoreComponentModule {
}
AWCoreComponentModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    EmbeddedItemDirective,
                    IncludeComponentDirective,
                    GenericContainerComponent,
                    ErrorMessagesComponent,
                    ModalComponent,
                    CurrencyFormatPipe,
                    NgForSetDirective,
                    InfiniteScrollComponent,
                    AwNameDirective
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    GenericContainerComponent,
                    ModalComponent
                ],
                exports: [
                    EmbeddedItemDirective,
                    IncludeComponentDirective,
                    GenericContainerComponent,
                    ErrorMessagesComponent,
                    ModalComponent,
                    CurrencyFormatPipe,
                    NgForSetDirective,
                    InfiniteScrollComponent,
                    AwNameDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Parent class for all modal dialogs. Provides defaults functionality for all modals.
 */
class ModalContainer extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Override function.
         */
        this.destroy = noop;
    }
    /**
     * function that closes the dialog by calling destroy on the component reference.
     * Method inherited by all its children.
     * @return {?}
     */
    closeModal() {
        this.destroy();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * DataTypeProviderRegistry aggregates different DataProviders per type.
 */
class DataTypeProviderRegistry {
    constructor() {
        this.registryByProvider = new Map();
        this.registryNameToClass = new Map();
    }
    /**
     * For every single registered DataProvider implementation we also need store its prototype
     * in order to be able to support some kind of inheritance. You can register a provider for
     * a parent class if needed
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    registerProvider(target, provider) {
        if (isBlank(target) || (!isStringMap(target) && !isType(target))) {
            throw new Error(' Cannot register non-object');
        }
        /** @type {?} */
        let name = isType(target) ? target.prototype.constructor.name : target.constructor.name;
        this.registryByProvider.set(name, provider);
        /** @type {?} */
        let prototype = Object.getPrototypeOf(target);
        this.registryNameToClass.set(name, prototype);
    }
    /**
     * Search for best matching provider. If not found then use object prototype to get hold of its
     * parent and see if there is a provider registered on this level
     *
     * @template T
     * @param {?} className
     * @return {?}
     */
    bestMatchForClass(className) {
        /** @type {?} */
        let registeredClassName = className;
        /** @type {?} */
        let classProto = this.registryNameToClass.get(className);
        while (isPresent(registeredClassName)) {
            /** @type {?} */
            let provider = this.registryByProvider.get(registeredClassName);
            if (isPresent(provider)) {
                provider.type = className;
                return provider;
            }
            // Go up to parent
            if (isPresent(classProto)) {
                classProto = Object.getPrototypeOf(classProto);
                /** @type {?} */
                let parentName = objectToName(classProto);
                registeredClassName =
                    (isPresent(parentName) && parentName !== registeredClassName) ? parentName
                        : null;
            }
            else {
                return null;
            }
        }
        return null;
    }
    /**
     * The same as bestMatchForClass() with the difference to pass a type. If you want to
     * support object inheritance you need this.
     *
     *
     * @template T
     * @param {?} type
     * @return {?}
     */
    bestMatchForType(type) {
        /** @type {?} */
        let name = objectToName(type);
        this.registryNameToClass.set(name, type);
        return this.bestMatchForClass(name);
    }
}
DataTypeProviderRegistry.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DataTypeProviderRegistry.ctorParameters = () => [];
/**
 * Provider is a data driver that can access data and retrieve them. It knows how to get 1
 * or more records, maybe do paging and some other things.
 *
 * @abstract
 * @template T
 */
class DataProvider {
    constructor() {
        /**
         * Notifies all the listeners in case of data are available or if they changed due to some user
         * interaction  (search, adding or removing).
         *
         */
        this.dataChanges = new BehaviorSubject([]);
    }
    /**
     *  Return size of the source
     *
     * @param {?=} params
     * @return {?}
     */
    expectedCount(params) {
        return -1;
    }
    /**
     *
     * Returns non-async current state of data
     * @return {?}
     */
    data() {
        return this.dataChanges.getValue();
    }
    /**
     * Tells if this DataProvider supports INSERT, REMOVE
     *
     * @return {?}
     */
    canCRUD() {
        return false;
    }
    /**
     * Tells if this DataProvider supports query capability
     *
     * @return {?}
     */
    canQuery() {
        return false;
    }
    /**
     * Implement to support insertion. After record is inserted emit event for dataChanges to
     * inform all subscribers
     *
     * @param {?} obj
     * @return {?}
     */
    insert(obj) {
    }
    /**
     * Implement to support record removal. After record is removed emit event for dataChanges to
     * inform all subscribers.
     *
     * @param {?} obj
     * @return {?}
     */
    remove(obj) {
    }
    /**
     * Implement to provide access to low level searcg API.
     *
     * @param {?} params
     * @return {?}
     */
    query(params) {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Default implementation for Arrays.
 * @template T
 */
class ArrayDataProvider extends DataProvider {
    /**
     * @param {?} values
     */
    constructor(values) {
        super();
        this.values = values;
        this.type = Array;
        this.offScreenData = this.values;
        this.dataChanges.next(this.values);
    }
    /**
     * @param {?=} params
     * @return {?}
     */
    expectedCount(params) {
        return this.offScreenData.length;
    }
    /**
     * @param {?=} params
     * @return {?}
     */
    dataForParams(params) {
        if (isBlank(params)) {
            return this.offScreenData;
        }
        /** @type {?} */
        let data = this.offScreenData;
        if (isPresent(params) && params.has('offset') && params.has('limit')) {
            /** @type {?} */
            let offset = params.get('offset');
            /** @type {?} */
            let limit = params.get('limit');
            if (data.length > (offset + limit)) {
                data = data.slice(offset, offset + limit);
            }
            else {
                data = data.slice(offset, data.length);
            }
        }
        if (params.has('orderby') && params.has('selector')) {
            this.sort(data, params.get('orderby'), params.get('selector'));
        }
        return data;
    }
    /**
     * @param {?} params
     * @return {?}
     */
    fetch(params) {
        return of(this.dataForParams(params));
    }
    /**
     * Provides default implementation for sorting current dataset by one column / key
     *
     * for sortOrdering please see Datatable and its sortOrderingForNumber()
     *
     *      1  = ascending
     *      -1 = descending
     * @param {?} arrayToSort
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    sort(arrayToSort, key, sortOrder) {
        arrayToSort.sort((data1, data2) => {
            /** @type {?} */
            let value1 = FieldPath.getFieldValue(data1, key);
            /** @type {?} */
            let value2 = FieldPath.getFieldValue(data2, key);
            /** @type {?} */
            let result = null;
            if (value1 == null && value2 != null) {
                result = -1;
            }
            else if (value1 != null && value2 == null) {
                result = 1;
            }
            else if (value1 == null && value2 == null) {
                result = 0;
            }
            else if (typeof value1 === 'string' && typeof value2 === 'string') {
                result = value1.localeCompare(value2);
            }
            else {
                result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
            }
            return (sortOrder * result);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Provides top level accessor class in order to make {\@link DataProvider} retrieval process easier.
 * Using {\@link DataTypeProviderRegistry} we either retrieve registered instance of concrete
 * provider or instantiate our implicit provider for native types such as Array.
 *
 *
 */
class DataProviders {
    /**
     * @param {?} registry
     */
    constructor(registry) {
        this.registry = registry;
    }
    /**
     * Finds the best matching  DataProvider or create new one in case of Array
     * More room to register and instantiate some other implicit Providers
     * @param {?} target
     * @return {?}
     */
    find(target) {
        if (isArray(target)) {
            return new ArrayDataProvider(target);
        }
        else if (isString(target)) {
            return this.registry.bestMatchForClass(target);
        }
        return this.registry.bestMatchForType(target);
    }
    /**
     * Registers new provider within DataTypeProviderRegistry
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    register(target, provider) {
        this.registry.registerProvider(target, provider);
    }
}
DataProviders.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DataProviders.ctorParameters = () => [
    { type: DataTypeProviderRegistry }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Provides a registry of different data Finders used mostly by DataSources. All Finders are
 * registered by this class as we don't have any needs right now to expose this to developer.
 *
 */
class DataFinders {
    constructor() {
        this.findersByType = new Map();
        this.initFinders();
    }
    /**
     * Finds the best matching DataFinder based on the object type and queryType.
     * @param {?} forProvider
     * @param {?} forType
     * @return {?}
     */
    find(forProvider, forType) {
        /** @type {?} */
        let finderMatch;
        this.findersByType.forEach((v, k) => {
            if (k.accepts(forProvider, forType)) {
                finderMatch = v;
                return true;
            }
        });
        if (isPresent(finderMatch)) {
            /** @type {?} */
            let copy = new finderMatch();
            copy.forData(forProvider);
            return copy;
        }
        return null;
    }
    /**
     * Registers new finder
     *
     * @template T
     * @param {?} prototype
     * @param {?} type
     * @return {?}
     */
    register(prototype, type) {
        this.findersByType.set(prototype, type);
    }
    /**
     * @return {?}
     */
    initFinders() {
        // create a prototype for each
        this.findersByType.set(new FullTextArrayDataFinder(), FullTextArrayDataFinder);
        this.findersByType.set(new OutlineFullTextArrayDataFinder(), OutlineFullTextArrayDataFinder);
    }
}
DataFinders.decorators = [
    { type: Injectable }
];
/** @nocollapse */
DataFinders.ctorParameters = () => [];
/** @enum {number} */
const QueryType = {
    FullText: 0,
    FullTextOutline: 1,
    Predicate: 2,
    FullTextAndPredicate: 3,
};
QueryType[QueryType.FullText] = 'FullText';
QueryType[QueryType.FullTextOutline] = 'FullTextOutline';
QueryType[QueryType.Predicate] = 'Predicate';
QueryType[QueryType.FullTextAndPredicate] = 'FullTextAndPredicate';
/**
 * This class provides matching capability for given DataProvider.
 * @abstract
 */
class DataFinder {
    /**
     * In order to find concrete DataFinder we need to know the target type and the query type
     *
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    accepts(forData, forType) {
        return false;
    }
    /**
     *
     * Query can be a simple string literal or a map having different key value pair as a
     * filter
     *
     * @template T
     * @param {?} query
     * @param {?=} max
     * @return {?}
     */
    match(query, max = -1) {
        return unimplemented();
    }
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    matchWithSelections(selections, query, max) {
        return unimplemented();
    }
}
/**
 * Simple FullText implementation based on infix string matching which works on top of
 * ArrayDataProvider.
 *
 */
class FullTextArrayDataFinder extends DataFinder {
    /**
     * @param {?} key
     * @return {?}
     */
    set lookupKey(key) {
        this._keyPath = isPresent(key) ? new FieldPath(key) : null;
    }
    /**
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    accepts(forData, forType) {
        return forData instanceof ArrayDataProvider && forType === QueryType.FullText;
    }
    /**
     * @param {?} provider
     * @return {?}
     */
    forData(provider) {
        this._provider = provider;
        return this;
    }
    /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    instantMatch(query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        /** @type {?} */
        let list = this._provider.dataForParams(new Map().set('limit', max));
        return this.instantMatchWithSelections(list, query, max);
    }
    /**
     * @template T
     * @param {?} selectionsForMatch
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    instantMatchWithSelections(selectionsForMatch, query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        if (isBlank(query)) {
            return selectionsForMatch;
        }
        /** @type {?} */
        let result = [];
        /** @type {?} */
        let toLowerPattern = query.toLowerCase();
        for (let i = 0; i < selectionsForMatch.length; i++) {
            /** @type {?} */
            let item = selectionsForMatch[i];
            if (this.matches(item, toLowerPattern)) {
                result.push(item);
                if (result.length >= max) {
                    break;
                }
            }
        }
        return result;
    }
    /**
     *
     * Warning: If you dont supply search Key and you want fulltext search and you use this
     * default implementation be aware that it can  perform poorly as it is naive implementaion
     * that does not do deep compare.
     *
     * @template T
     * @param {?} item
     * @param {?} pattern
     * @return {?}
     */
    matches(item, pattern) {
        /** @type {?} */
        let val = (isPresent(this._keyPath)) ? this._keyPath.getFieldValue(item) : item;
        if (isFunction(val)) {
            val = val.call(item);
        }
        else if (isJsObject(item)) {
            return this.hasObjectValue(item, pattern);
        }
        else {
            return isBlank(pattern) ||
                isPresent(val) && val.toString().toLowerCase().indexOf(pattern) > -1;
        }
    }
    /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    match(query, max) {
        return of(this.instantMatch(query, max));
    }
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    matchWithSelections(selections, query, max) {
        return of(this.instantMatchWithSelections(selections, query, max));
    }
    /**
     * @param {?} obj
     * @param {?} pattern
     * @return {?}
     */
    hasObjectValue(obj, pattern) {
        /** @type {?} */
        let values = objectValues(obj);
        /** @type {?} */
        let parentObj = objectToName(obj);
        /** @type {?} */
        let length2 = values.filter((value) => {
            if (isBlank(value) || isArray(value)) {
                return false;
            }
            else if (!isJsObject(value) && !isFunction(value)) {
                return value.toString().toLowerCase().indexOf(pattern) !== -1;
            }
            else if (isJsObject(value) && objectToName(value) !== parentObj) {
                return this.hasObjectValue(value, pattern);
            }
            return false;
        }).length;
        return length2 > 0;
    }
}
/**
 * Extends basic Infix implementation to work on top of OutlineNodes. It first checks all the
 * children on lowest level and moving up to the root and marking nodes that can be removed.
 *
 *  For simple data structure which operates on local array this should be good enough we this
 *  can never match with real DB full text search.
 *
 */
class OutlineFullTextArrayDataFinder extends FullTextArrayDataFinder {
    /**
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    accepts(forData, forType) {
        return forData instanceof ArrayDataProvider && forType === QueryType.FullTextOutline;
    }
    /**
     * @template T
     * @param {?} selectionsForMatch
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    instantMatchWithSelections(selectionsForMatch, query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        if (isBlank(query)) {
            return selectionsForMatch;
        }
        /** @type {?} */
        let toLowerPattern = query.toLowerCase();
        /** @type {?} */
        let sourceToSearch = selectionsForMatch.slice();
        this.rollup(sourceToSearch, toLowerPattern);
        return this.shake(sourceToSearch);
    }
    /**
     *
     * Going thru the tree from bottom up and mark all that matches query
     *
     * @param {?} nodes
     * @param {?} query
     * @return {?}
     */
    rollup(nodes, query) {
        nodes.forEach((item) => {
            /** @type {?} */
            let hasChildrenMatch = false;
            if (isPresent(item.children) && item.children.length > 0) {
                hasChildrenMatch = this.rollup(item.children, query);
            }
            item.visible = hasChildrenMatch || this.matches(item, query);
        });
        return nodes.some((item) => item.visible);
    }
    /**
     * Filter out all the nodes that are marked as visible = false and make sure and
     * don't modify original list
     *
     * @param {?} nodes
     * @return {?}
     */
    shake(nodes) {
        return nodes
            .filter(node => node.visible)
            .map(node => (Object.assign({}, node, { isExpanded: node.visible, children: node.children && this.shake(node.children) })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const DATA_SOURCE = new InjectionToken('DATA_SOURCE');
/**
 * DataSource describes basic functionality for handling stream of data specific to component
 *
 * It is expected that DataSource will be defined as component provider using
 *
 * \@Components ({
 *      ...
 *      providers:[
 *
 *          provide: DATA_SOURCE, useClass: ChooserDataSourcePlainArrayExample,
 * deps: [DataProviders, DataFinders]
 *      ]
 *
 * })
 *
 *
 * so all the dependencies (DataProviders, DataFinders) are properly injected.
 *
 * DataProvider uses open() method to broadcast changes to all the subscribers in reactive way.
 * Or you can use instant() method to retrieve current state of this DataSource (sync)
 *
 * @abstract
 */
class DataSource {
    /**
     *
     * Each DataSource have injected DataProviders and DataFinders to retrieve concrete
     * implementation
     *
     * @param {?=} dataProviders
     * @param {?=} finders
     */
    constructor(dataProviders, finders) {
        this.dataProviders = dataProviders;
        this.finders = finders;
    }
    /**
     * Returns a data instantly from the internal state of DataProvider
     * @template T
     * @return {?}
     */
    instant() {
        return unimplemented();
    }
}
DataSource.MaxLength = 10;
DataSource.MaxRecentSelected = 5;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class TopZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad ';
    }
}
TopZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-top',
                template: '<ng-content></ng-content>'
            }] }
];
TopZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class LeftZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
}
LeftZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-left',
                template: '<ng-content></ng-content>'
            }] }
];
LeftZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class MiddleZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-md-6 ui-lg-4 ui-g-nopad';
    }
}
MiddleZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-middle',
                template: '<ng-content></ng-content>'
            }] }
];
MiddleZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class RightZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
}
RightZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-right',
                template: '<ng-content></ng-content>'
            }] }
];
RightZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class BottomZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
}
BottomZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-bottom',
                template: '<ng-content></ng-content>'
            }] }
];
BottomZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Used by FormTable to layout fields into Rows. Each FormTable row is reasonable for not only to
 * include actual component such is DropDown or InputField but mainly provides a enough context for
 * the component to specify the size, how it should layout, whether we need to show required flag,
 * to show/hide labels in case if we have no label layout and much more.
 *
 * FormRow component also registers angular validator for the current row/field. As already
 * mentioned We treat our widgets with minimal responsibility as possible to present and retrive
 * information to/from user and let somebody else to figure out where it appear and how.
 *
 * todo: Move under FormTable
 */
class FormRowComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, 
    // Event this creates CI depends. Need to have a reference to parent
    // I need to refactor more parent to not use this child and refactor layouting
    parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Hides the label
         *
         */
        this.noLabelLayout = false;
        /**
         * Renders row with highlighted background
         *
         */
        this.highlightRow = false;
        /**
         *
         *  Field label that should appear above or next to the control
         *
         */
        this.label = '';
        /**
         * Tells the form row that we are rendering another nested form in this row. so we need
         * to go 100%
         */
        this.isNestedLayout = false;
        /**
         *
         * For single column layout without zones we need to apply grid directly to the FormRow tag
         * so we don't need to introduce extra div level
         *
         */
        this.classList = '';
        this._size = 'ui-g-12 ui-md-' + WidgetSizeColumns.medium;
    }
    /**
     * Right now we just initialize this once and use the values we do not expect now to react to
     * changes
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(null);
        this.registerValidators();
        this.omitPadding = this.parentContainer.omitPadding;
        this.classList += isPresent(this.parentContainer) ? ' ui-g-12 ' : '';
        this.classList = this.highlightRow ? this.classList + ' highlight-row ' : this.classList;
        this.classList = this.omitPadding ? this.classList + ' ui-g-nopad ' : this.classList;
    }
    /**
     * Just a size getter
     *
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
     * right now. but we should extend this for other screen sizes
     *
     *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
     *
     *  Also check if this is dynamic size that should vary based on the how many number of columns
     * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
     * small.
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        /** @type {?} */
        let isDynVal = false;
        if (StringWrapper.startsWidth(value, 'd-')) {
            isDynVal = true;
            value = value.substr(2, value.length - 1);
        }
        if (isPresent(value) && !this.isNestedLayout) {
            this._size = value;
            /** @type {?} */
            let dSize = this.dynSize(value, isDynVal);
            this._size = 'ui-g-12 ui-md-' + dSize;
        }
        else if (this.isNestedLayout) {
            this._size = 'ui-g-12 ui-md-12';
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
        if (isPresent(this.parentContainer) && this.editable !== this.parentContainer.editable) {
            this.editable = this.parentContainer.editable;
        }
    }
    /**
     * Push out of box angular validator as well as custom one to current FormControl
     * @return {?}
     */
    registerValidators() {
        /** @type {?} */
        let validators = [];
        if (isPresent(this.maxLength)) {
            validators.push(Validators.maxLength(this.maxLength));
        }
        if (isPresent(this.minLength)) {
            validators.push(Validators.minLength(this.minLength));
        }
        if (isPresent(this.required) && this.required) {
            validators.push(Validators.required);
        }
        if (isPresent(this.pattern)) {
            validators.push(Validators.pattern(this.pattern));
        }
        if (isPresent(this.customValidators)) {
            ListWrapper.addAll(validators, this.customValidators);
        }
        if (validators.length === 1) {
            this.formControl.setValidators(validators[0]);
        }
        else if (validators.length > 1) {
            this.formControl.setValidators(Validators.compose(validators));
        }
        if (isPresent(this.customAsyncValidators) && this.customAsyncValidators.length === 1) {
            this.formControl.setAsyncValidators(this.customAsyncValidators[0]);
        }
        else if (isPresent(this.customAsyncValidators) && this.customAsyncValidators.length > 1) {
            this.formControl.setAsyncValidators(Validators.composeAsync(this.customAsyncValidators));
        }
    }
    /**
     *
     * Do we have labels on TOP, try to read this from Parent
     *
     * @return {?}
     */
    get labelsOnTop() {
        if (isBlank(this._labelsOnTop) && isPresent(this.parentContainer)) {
            return (/** @type {?} */ (this.parentContainer)).isLabelsOnTop();
        }
        return false;
    }
    /**
     *
     * Can refactor all into 1 line but its hard to debug so this is just for read
     *
     * @param {?} value
     * @param {?} isDynValue
     * @return {?}
     */
    dynSize(value, isDynValue) {
        /** @type {?} */
        let normalizeSize = value.toLowerCase().replace('-', '');
        if (isPresent(this.parentContainer) &&
            (/** @type {?} */ (this.parentContainer)).hasTwoColumn && isDynValue) {
            /** @type {?} */
            let enumValues = Object.keys(WidgetSizeColumns);
            normalizeSize = enumValues[enumValues.indexOf(normalizeSize) + 1];
        }
        return (/** @type {?} */ (WidgetSizeColumns))[normalizeSize];
    }
}
FormRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-form-row',
                template: "<div *ngIf=\"!hidden\"\n     class=\"w-form-row ui-g\"\n     [class.highlight-row]=\"highlightRow\"\n     [class.required]=\"required\"\n     [class.label-on-top]=\"labelsOnTop\"\n     [class.label-on-side]=\"!labelsOnTop\"\n     [class.has-danger]=\"!formControl.valid && !formControl.pristine \"\n     [ngClass]=\"styleClass\">\n\n    <div class=\"control-label ui-g-12 ui-g-nopad\"\n         *ngIf=\"!noLabelLayout\"\n         [class.ui-md-3]=\"!labelsOnTop\">\n        <label [class.sr-only]=\"noLabelLayout\">{{label}}</label>\n    </div>\n\n    <div class=\"control-value ui-g-nopad\" [ngClass]=\"size\"\n         [class.read-only]=\"!editable\">\n        <ng-content></ng-content>\n        <a-error-messages [control]=\"formControl\"></a-error-messages>\n    </div>\n</div>\n",
                providers: [
                    { provide: BaseFormComponent, useExisting: forwardRef(() => FormRowComponent) }
                ],
                styles: [".required label:after{content:\"*\";color:red}/deep/ .highlight-row{background-color:#f7f8fa}.w-form-row.highlight-row{background-color:#f7f8fa}.w-form-row.label-on-top{padding-bottom:13px}.w-form-row.label-on-top .control-label,.w-form-row.label-on-top .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-top .control-label{padding-bottom:12px}.w-form-row.label-on-side .control-label,.w-form-row.label-on-side .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-side .control-label ::ng-deep .w-string-field,.w-form-row.label-on-side .control-value ::ng-deep .w-string-field{line-height:36px}.w-form-row.label-on-side .control-label ::ng-deep .sap-icon,.w-form-row.label-on-side .control-value ::ng-deep .sap-icon{line-height:26px}.w-form-row.label-on-side .control-label label,.w-form-row.label-on-side .control-value label{line-height:36px}.w-form-row.label-on-side .control-label .fa,.w-form-row.label-on-side .control-value .fa{line-height:18px}.w-form-row .w-form-row{padding-top:.5em;padding-bottom:.5em}.control-label{color:#636363}.u-validation-error{border-color:red}"]
            }] }
];
/** @nocollapse */
FormRowComponent.ctorParameters = () => [
    { type: Environment },
    { type: FormTableComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormTableComponent),] }] }
];
FormRowComponent.propDecorators = {
    noLabelLayout: [{ type: Input }],
    highlightRow: [{ type: Input }],
    label: [{ type: Input }],
    maxLength: [{ type: Input }],
    minLength: [{ type: Input }],
    pattern: [{ type: Input }],
    customAsyncValidators: [{ type: Input }],
    customValidators: [{ type: Input }],
    isNestedLayout: [{ type: Input }],
    classList: [{ type: HostBinding, args: ['class',] }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * FormTable is a specific layout component for rendering Labels and its controls in two columns
 * and 5 different zones.
 *
 * We support LEFT, MIDDLE, RIGHT, TOP, BOTTOM zone where we can place our component or widgets.
 * This
 * component is used as primary layout to wrap all the common use cases. E.g. When we lay out
 * fields in the form I do not want controls to be aware of error validation, size, labels, and
 * some other things. Control such INPUT is just responsible for retrieve user value but not how it
 * appear on the page.
 *
 * This way we can be flexible how we treat widgets for different kinds of situation depending
 * where they appear
 * FormTable just like the rest of the components are using Model driven approach how to work with
 * data, mean we are using FormGroup, FormControl etc. FormGroup can be passed into the FormTable,
 * otherwise its automatically created when the FormTable is instantiated.
 *
 * FormGroup is saved insode Environment where we are using this to pass this around the pages and
 * components.
 *
 * ### Example
 *
 * Simple Layout fields and its control
 *
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: `
 *  			<aw-form-table [formGroup]="formGroup" (onSubmit)=>
 *  				<aw-form-row [label]="'name'" [name]="'name'">
 *  					<aw-input-field [type]="'string'"></aw-input-field>
 *  				</aw-form-row>
 *
 *  				<aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
 *  					<aw-checkbox-list [list]="checkBoxListValues"
 *  					                 [selections]="selectedValues"
 *  					                 [layout]="'inline'"
 *  					                 (onSelection)="onCBClick($event)">
 *  					</aw-checkbox-list>
 *  				</aw-form-row>
 *  				<aw-form-row [label]="'Gender'" [name]="'gender'">
 *
 *  					<aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
 *
 *  					</aw-radiobutton-list>
 *
 *  				</aw-form-row>
 *  				<aw-form-row [label]="'My birthdate'" [name]="'birthDate'" [size]="'small'">
 *
 *  					<aw-date-time [value]="date" [editable]="editable" [showTime]="showTime">
 *  					</aw-date-time>
 *  				</aw-form-row>
 *  			</aw-form-table>
 *    `
 *  })
 *  export class ShowUserInfoComponent
 *  {
 *       checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' , 'silver'
 *     , 'black' , 'Green'
 *     , 'Gray' , 'Navy' ,
 *          'Olive' , 'Aqua' , 'Purple'];
 *      selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
 *      rbValues: string[] = ['male' , 'female' , 'other'];
 *      rbSelection: string = 'male';
 *      editable: boolean = true;
 *      showTime: boolean = true;
 *
 *      formGroup: FormGroup = new FormGroup({});
 *
 *
 *      onCBClick (event): void
 *      {
 *          console.log('onCBClick = ' + event);
 *      }
 *
 *      onSubmit (model: any): void
 *      {
 *         console.log(model)
 *
 *         // will print { name:null, myColors:['blue' , 'Olive' , 'Aqua' , 'Purple'], gender:
 *     male}
 *      }
 *
 *  }
 *
 *  ```
 *
 *  Or you can use zone to layout these fields into two columns:
 *
 *  Current zones are implement with <ng-content SELECT> which is just a selector to searches for
 *     specific pattern. In our case instead of creating extra wrapper custom component use simple
 *     CSS class
 *
 *
 *  ```
 *            <aw-form-table #metaFormTable [editable]="editing"
 *                          [useFiveZone]="isFiveZoneLayout"
 *                          (onSubmit)="onSaveAction($event)">
 *
 *                <aw-left  *ngIf="canShowZone('zLeft')">
 *
 *                        <aw-form-row [label]="'name'" [name]="'name'">
 *                            <aw-input-field [type]="'string'"></aw-input-field>
 *                        </aw-form-row>
 *
 *                        <aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
 *                            <aw-checkbox-list [list]="checkBoxListValues"
 *                                             [selections]="selectedValues"
 *                                             [layout]="'inline'"
 *                                             (onSelection)="onCBClick($event)">
 *                            </aw-checkbox-list>
 *                        </aw-form-row>
 *                </aw-left>
 *
 *
 *                <aw-right  *ngIf="canShowZone('zRight')">
 *                        <aw-form-row [label]="'Gender'" [name]="'gender'">
 *                                <aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
 *                                </aw-radiobutton-list>
 *                        </aw-form-row>
 *
 *                        <aw-form-row [label]="'My birthdate'" [name]="'birthDate'"
 *     [size]="'small'">
 *                            <aw-date-time [value]="date" [editable]="editable"
 *     [showTime]="showTime">
 *                            </aw-date-time>
 *                        </aw-form-row>
 *                </<aw-right>
 *            </aw-form-table>
 *
 *  ```
 *
 *  todo: remove my css selectors for zones and replace it with real component even just a tag
 *  todo: would work file
 *
 */
class FormTableComponent extends BaseFormComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env, null);
        this.env = env;
        /**
         * Used for the form layout to see if we need to render labels stacked  or side by side next to
         * the control
         *
         */
        this.labelsOnTop = false;
        /**
         *
         * Is this a 4 zone layout
         *
         */
        this.useFiveZone = false;
        /**
         * For certain usecase we dont want to set automatically this to all children
         */
        this.editabilityCheck = true;
        /**
         *  Triggers when the <form> is submitted. onSubmit we emit the whole formController objects
         *
         *
         */
        this.onSubmit = new EventEmitter();
        /**
         * Cache calculated properties when init this component
         *
         */
        this.hasOneColumn = false;
        this.hasTwoColumn = false;
        this.hasThreeColumn = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (isPresent(changes['editable']) &&
            changes['editable'].previousValue !== changes['editable'].currentValue) {
            this.updateFormFields();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSubmitForm(event) {
        this.onSubmit.emit(event);
    }
    /**
     *
     * Are labels on top
     *
     * @return {?}
     */
    isLabelsOnTop() {
        return this.labelsOnTop;
    }
    /**
     *
     * Used by child component to inherit editability
     *
     * @return {?}
     */
    isFormEditable() {
        return this.editable;
    }
    /**
     * @return {?}
     */
    applyColumns() {
        if (!this.useFiveZone && this.hasAnyZones()) {
            throw new Error('Zones detected in the FormTable but useFiveZone option is false');
        }
        this.hasOneColumn = !isPresent(this.rightZone) && !isPresent(this.middleZone);
        this.hasTwoColumn = isPresent(this.leftZone) && isPresent(this.rightZone) &&
            !isPresent(this.middleZone);
        this.hasThreeColumn = isPresent(this.leftZone) && isPresent(this.rightZone) &&
            isPresent(this.middleZone);
        if (this.hasTwoColumn && !this.isTwoZoneReady()) {
            this.leftZone.classList += ' ui-md-6 ui-lg-6';
            this.rightZone.classList += ' ui-md-6 ui-lg-6';
        }
        if (this.hasThreeColumn && !this.isThreeZoneReady()) {
            this.leftZone.classList += ' ui-md-6 ui-lg-4';
            this.rightZone.classList += ' ui-md-6 ui-lg-4';
        }
    }
    /**
     * @return {?}
     */
    hasAnyZones() {
        return isPresent(this.leftZone) || isPresent(this.rightZone) || isPresent(this.middleZone)
            || isPresent(this.topZone) || isPresent(this.bottomZone);
    }
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    isTwoZoneReady() {
        return this.leftZone.classList.indexOf('ui-lg-6') > 0 &&
            this.leftZone.classList.indexOf('ui-lg-6') > 0;
    }
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    isThreeZoneReady() {
        return this.leftZone.classList.indexOf('ui-lg-4') > 0 &&
            this.leftZone.classList.indexOf('ui-lg-4') > 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // problem since Angular 4.2, ngAfterContentInit
        // without this I get error that value was changed after view was checked
        // todo: refactor  - mainly our zones left, right middle
        setTimeout(() => {
            this.applyColumns();
            this.updateFormFields();
            this.adjustLayout();
        });
    }
    /**
     * @return {?}
     */
    updateFormFields() {
        if (this.editabilityCheck && isPresent(this.formFields) && this.formFields.length > 0) {
            this.formFields.forEach((item) => {
                item.editable = this.editable;
                // item.formGroup = this.formGroup;
            });
        }
    }
    /**
     * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
     * form row.
     * @return {?}
     */
    adjustLayout() {
        if (isPresent(this.rows) && this.rows.length > 0) {
            if (this.hasThreeColumn) {
                this.rows.forEach((item) => item.size = 'large');
            }
        }
    }
}
FormTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-form-table',
                template: "<form class=\"w-form-table ui-g ui-fluid\" [formGroup]=\"formGroup\"\n      [ngClass]=\"styleClass\"\n      (ngSubmit)=\"onSubmitForm(formGroup.value)\" novalidate>\n\n    <div class=\"ui-g-12 ui-g-nopad\">\n\n        <div class=\"ui-g\">\n            <ng-content></ng-content>\n        </div>\n\n    </div>\n</form>\n\n",
                providers: [
                    { provide: BaseFormComponent, useExisting: forwardRef(() => FormTableComponent) }
                ],
                styles: [".page-container>form{margin-top:1em}.w-form-table button{float:right}"]
            }] }
];
/** @nocollapse */
FormTableComponent.ctorParameters = () => [
    { type: Environment }
];
FormTableComponent.propDecorators = {
    labelsOnTop: [{ type: Input }],
    useFiveZone: [{ type: Input }],
    editabilityCheck: [{ type: Input }],
    onSubmit: [{ type: Output }],
    leftZone: [{ type: ContentChild, args: [LeftZoneComponent,] }],
    middleZone: [{ type: ContentChild, args: [MiddleZoneComponent,] }],
    rightZone: [{ type: ContentChild, args: [RightZoneComponent,] }],
    topZone: [{ type: ContentChild, args: [TopZoneComponent,] }],
    bottomZone: [{ type: ContentChild, args: [BottomZoneComponent,] }],
    formFields: [{ type: ContentChildren, args: [BaseFormComponent, { descendants: true },] }],
    rows: [{ type: ContentChildren, args: [forwardRef(() => FormRowComponent), { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWFormTableModule {
}
AWFormTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    FormTableComponent,
                    FormRowComponent,
                    TopZoneComponent,
                    LeftZoneComponent,
                    RightZoneComponent,
                    MiddleZoneComponent,
                    BottomZoneComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    FormTableComponent,
                    FormRowComponent,
                    TopZoneComponent,
                    LeftZoneComponent,
                    RightZoneComponent,
                    MiddleZoneComponent,
                    BottomZoneComponent
                ],
                exports: [
                    FormTableComponent,
                    FormRowComponent,
                    TopZoneComponent,
                    LeftZoneComponent,
                    RightZoneComponent,
                    MiddleZoneComponent,
                    BottomZoneComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * This component represent a Input field and it can  accept different types of values such as
 * text, number.
 *
 *
 *
 * ### Example
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: '<aw-input-field [value]="inputValue" [type]="inputType"></aw-input-field>'
 *  })
 *  export class TestInputComponent
 *  {
 *      inputValue: string = 'Some text';
 *
 *      // by default input type is text, you can pass string, String, or text
 *      inputType: string = 'string';
 *  }
 *
 * ```
 *
 *
 *
 * ### Example wher input field is initialized with ngModel
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: '<aw-input-field [value]="inputValue" [(ngModel)]="inputType"></aw-input-field>'
 *  })
 *  export class TestInputComponent
 *  {
 *      inputValue: string = 'Some text';
 *
 *      // by default input type is text, you can pass string, String, or text
 *      inputType: string = 'string';
 *  }
 *
 * ```
 *
 *  Note: if you are using this outside of FormTable please provide your own FormGroup
 *
  @type {?} */
const INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => InputFieldComponent),
    multi: true
};
class InputFieldComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value used to save and read  when rendering and updating a component
         *
         */
        this.value = '';
        /**
         * The formatted decimal value. Uses angular decimalPipe to format based on locale.
         */
        this.displayValue = '';
        /**
         * Input field type. Currently we support either Number or text
         */
        this._type = 'string';
        this.decimalPipe = new DecimalPipe(env.locale);
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     *
     * generated setter to check for value and normalizing into expected either number or text
     *
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        if (value.toLowerCase() === 'string' || value.toLowerCase() === 'text') {
            this._type = 'text';
        }
        else if (value.toLowerCase() === 'number') {
            this._type = 'number';
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.bigDecimal);
        this.vchSubscriber = this.formControl.valueChanges
            .pipe(distinctUntilChanged())
            .subscribe(val => {
            this.value = val;
            this.onModelChanged(this.value);
        });
        if (this.bigDecimal) {
            this.displayValue = this.formatNumber(this.bigDecimal.amount);
        }
        else {
            this.displayValue = this.value;
        }
    }
    /**
     * @return {?}
     */
    canSetType() {
        return true;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    onKeyDown(el) {
        if (this._type === 'number') {
            this.displayValue = el.value;
            this.onModelChanged(this.displayValue);
        }
    }
    /**
     * @param {?} el
     * @return {?}
     */
    onBlur(el) {
        if (this._type === 'number') {
            this.bigDecimal = new BigDecimal(Number(el.value));
            this.displayValue = this.formatNumber(this.bigDecimal.amount);
            this.onModelChanged(this.displayValue);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.displayValue) {
            this.value = value;
            this.displayValue = '';
            if (this.value) {
                this.displayValue = this.value;
            }
            this.formControl.setValue(value, { onlySelf: true });
        }
    }
    /**
     * Format the number object according to its precision.
     *
     * @param {?} value
     * @return {?}
     */
    formatNumber(value) {
        if (!value) {
            return '';
        }
        // If precision is present, use it for format the bigDecimal value for display.
        if (isPresent(this.precision) &&
            this._type === 'number') {
            /** @type {?} */
            let digits = '1.0-2';
            digits = '1.0-' + this.precision;
            return this.decimalPipe.transform(value, digits);
        }
        return value;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (isPresent(this.vchSubscriber)) {
            this.vchSubscriber.unsubscribe();
        }
    }
}
InputFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-input-field',
                template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\" class=\"w-input-wrapper\">\n\n    <input pInputText\n           #inputFieldValue\n           [attr.name]=\"name\"\n           [attr.type]=\"type\"\n           class=\"w-input-field\"\n           [ngClass]=\"styleClass\"\n           [class.has-icon]=\"icon\"\n           placeholder=\"{{placeHolder}}\"\n           [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n           formControlName=\"{{name}}\"\n           (keydown)=\"onKeyDown(inputFieldValue)\"\n           (blur)=\"onBlur(inputFieldValue)\"\n           [value]=\"displayValue\">\n    <span *ngIf=\"icon\" class=\"sap-icon\" [ngClass]=\"icon\"></span>\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"displayValue\"></aw-string>\n</ng-template>\n",
                providers: [
                    INPUT_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => InputFieldComponent) }
                ],
                styles: [".w-input-wrapper{position:relative}.w-input-field{padding-right:35px}.w-input-field~span{top:13px;position:absolute;right:15px}"]
            }] }
];
/** @nocollapse */
InputFieldComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
InputFieldComponent.propDecorators = {
    value: [{ type: Input }],
    precision: [{ type: Input }],
    bigDecimal: [{ type: Input }],
    icon: [{ type: Input }],
    type: [{ type: Input }]
};
/**
 * BigDecimal object is represented as a value, locale, and currencyCode
 */
class BigDecimal {
    /**
     * @param {?=} amount
     * @param {?=} locale
     */
    constructor(amount = 0, locale = 'en_US') {
        this.amount = amount;
        this.locale = locale;
    }
    /**
     * @return {?}
     */
    getTypes() {
        return {
            amount: Number,
            locale: String
        };
    }
    /**
     * @return {?}
     */
    className() {
        return 'BigDecimal';
    }
    /**
     * @return {?}
     */
    $proto() {
        return new BigDecimal(1, 'en_US');
    }
    /**
     * @return {?}
     */
    toString() {
        return this.amount + ', locale: ' + this.locale;
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    clone(data = {}) {
        return new BigDecimal(isPresent(data.amount) ? data.amount : this.amount, isPresent(data.locale) ? data.locale : this.locale);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWStringFieldModule {
}
AWStringFieldModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    StringComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                entryComponents: [
                    StringComponent
                ],
                exports: [
                    StringComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWInputFieldModule {
}
AWInputFieldModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    InputFieldComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    InputFieldComponent
                ],
                exports: [
                    InputFieldComponent,
                    AWStringFieldModule,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * basic navigation bar provide a main action buttons for its content (page level buttons).
 * This is not the Top level application navigation. This component provides by default action OK,
 * CANCEL and you are free to modify how the OK or CANCEL will be call as well as subscribe to the
 * event. Or you can provide your own buttons template which will be used instead of this default
 * one.
 *
 *
 *
 *
 *
 * ### Example 1:
 *
 * In order to use navigation bar in its basic usage you can do following:
 * this will render buttons on the top as well as on the bottom around the content.
 *
 *
 *  ```html
 *
 *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
 *
 *            <div class="container">
 *                <form>
 *                    User name: <input type=text value="peter.pan">
 *                </<form>>
 *            </div>
 *      </aw-basic-navigator>
 *
 *
 * ```
 *
 *  if you do not want button on the top or bottom you can say thi using binding showTop or
 * showBottom.
 *
 *
 * ### Example 2:
 *  In this example we are providing custom buttons as well as brank section
 *
 *
 *  ```html
 *
 *
 *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
 *            <ng-template #buttons>
 *                <ul class="nav navbar-nav float-md-right collapse navbar-toggleable-xs">
 *                    <li class="nav-item ">
 *                        <button class="btn btn-secondary" type="button"
 * (click)="onSaveAction($evemt)">Cancel</button>
 *                    </li>
 *                    <li class="nav-item active">
 *                        <button class="btn btn-primary" type="button"
 * (click)="onCancelAction($event)"> Save
 *                        </button>
 *                    </li>
 *                </ul>
 *            </ng-template>
 *
 *            <ng-template #brand>
 *                <span class="brand-title">Ariba</span>
 *            </ng-template>
 *
 *
 *            <div class="container">
 *                <form>
 *                    User name: <input type=text value="peter.pan">
 *                </<form>>
 *            </div>
 *      </aw-basic-navigator>
 *
 *
 * ```
 *
 */
class BasicNavigatorComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} appConfig
     */
    constructor(env, appConfig) {
        super(env);
        /**
         * Indicates that buttons will be rendered on the top
         *
         * Default value is TRUE
         *
         */
        this.showTop = true;
        /**
         * Indicates that buttons will be rendered on the bottom
         *
         * Default value is TRUE
         *
         */
        this.showBottom = true;
        /**
         * Indicates that brand section that is on the left side and only in the top bar is visible
         *
         * Default value is TRUE
         *
         */
        this.showBrand = true;
        /**
         *
         * EventEmitter that is triggered when you click on default OK Action
         *
         */
        this.onOKAction = new EventEmitter();
        /**
         *
         * EventEmitter that is triggered when you click on default CANCEL Action
         *
         */
        this.onCancelAction = new EventEmitter();
        // todo: load this from resource file using ngTranslate service
        this.okActionLabel = 'OK';
        this.cancelActionLabel = 'Cancel';
        this.brandImg = 'images/aribalogobal.png';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.showCancelButton)) {
            this.showCancelButton = this.editable || (this.onCancelAction.observers.length > 0
                && this.onOKAction.observers.length > 0);
        }
    }
    /**
     * Returns if buttonsTemplate is available
     *
     * @return {?}
     */
    hasButtonTemplate() {
        return isPresent(this.buttonsTemplate);
    }
    /**
     * Returns if brandTemplate is available
     *
     * @return {?}
     */
    hasBrandTemplate() {
        return isPresent(this.brandTemplate);
    }
}
BasicNavigatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-basic-navigator',
                template: "<p-toolbar *ngIf=\"showTop\" [class]=\"'w-basic-navigator'\">\n    <div class=\"ui-toolbar-group-left\">\n\n        <a class=\"nav-brand\" href=\"#\" *ngIf=\"showBrand\">\n            <ng-template [ngIf]=\"!hasBrandTemplate()\">\n                <img src=\"{{assetFolder}}/{{brandImg}}\" height=\"30\" alt=\"\">\n                <span class=\"nav-brand-title\">Ariba</span>\n            </ng-template>\n\n            <ng-template [embeddedItem]=\"brandTemplate\" [item]=\"context\"\n                         *ngIf=\"hasBrandTemplate()\"></ng-template>\n        </a>\n\n    </div>\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n\n\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n<ng-content></ng-content>\n\n<p-toolbar *ngIf=\"showBottom\">\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n\n\n",
                styles: ["a.nav-brand{vertical-align:middle;line-height:inherit;text-decoration:none;color:#2d353c}a.nav-brand:focus,a.nav-brand:hover{text-decoration:none}a.nav-brand span{vertical-align:middle}.nav-brand img{display:inline-block;vertical-align:middle;padding:3px}"]
            }] }
];
/** @nocollapse */
BasicNavigatorComponent.ctorParameters = () => [
    { type: Environment },
    { type: AppConfig }
];
BasicNavigatorComponent.propDecorators = {
    showTop: [{ type: Input }],
    showBottom: [{ type: Input }],
    showBrand: [{ type: Input }],
    brandImg: [{ type: Input }],
    okActionLabel: [{ type: Input }],
    cancelActionLabel: [{ type: Input }],
    context: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    onOKAction: [{ type: Output }],
    onCancelAction: [{ type: Output }],
    buttonsTemplate: [{ type: ContentChild, args: ['buttons',] }],
    brandTemplate: [{ type: ContentChild, args: ['brand',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Button component that implements consistent styling, behavior. Button can be rendered either as
 * a button or as a link. It could be standalone or be part of a form.
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *   <aw-form-table >
 *       <aw-form-row [label]="'Amount'" [name]="'amount'" [size]="'small'">
 *
 *           <aw-button [type]="'submit'" [name]="'button'"
 *                     (action)="onClicked($event)" [value]="command"
 *                     [style]="'warning'" >Button</aw-button>
 *       </aw-form-row>
 *   </aw-form-table>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        command:boolean;
 *
 *        constructor ()
 *        {
 *        }
 *
 *        onClicked(value:string) {
 *           if (value) {
 *              // submit form.
 *           }
 *        }
 *    }
 */
class ButtonComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
        /**
         * Button types  [ button | submit | reset ]
         *
         */
        this.type = 'button';
        /**
         * styling for this button. See ButtonStyle for all supported styles.
         */
        this.style = 'primary';
        /**
         * sizing for this button. [large, normal, small].
         */
        this.size = 'normal';
        /**
         * Event fired when user select a item
         */
        this.action = new EventEmitter();
        // Default button class is secondary.
        this.buttonClass = 'ui-button-secondary';
        // Default disabled
        this.disabled = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // How to style this button.
        if (isPresent(this.style)) {
            if (this.style === 'primary') {
                // Default .ui-button and .ui-button-primary get the same style.
                // .ui-button-primary is necessary because button style can be overridden
                // when included inside other widgets. So specify primary
                this.buttonClass = 'ui-button-primary';
            }
            else {
                this.buttonClass = 'ui-button-' + this.style;
            }
        }
        // Determine the button class based on input size.
        if (this.size) {
            switch (this.size) {
                case 'large':
                    this.buttonClass += ' btn-lg';
                    break;
                case 'normal':
                    this.buttonClass += ' btn-mid';
                    break;
                case 'small':
                    this.buttonClass += ' btn-sm';
                    break;
            }
        }
    }
    /**
     * This is little hacky hackity hack as currently primeng button directive does not work with
     * ngcontent projection but it has a label bindings, which is not the way developers work with
     * button. you want to
     *
     * <button> MY CONTENT</button instead of <button label='MyContent'></button>
     *
     *
     * \@Todo: Change this until the time keep a test that check that they are still using ui-button
     *     that we are expecting and replacing
     * @return {?}
     */
    ngAfterViewInit() {
        if (isPresent(this.element)) {
            /** @type {?} */
            let button = this.element.nativeElement.querySelector('button');
            /** @type {?} */
            let buttonTitle = button.children[0];
            button.children[0].textContent = this.element.nativeElement.textContent.trim()
                .replace('ui-button', '').replace('ui-btn', '');
            button.classList.remove('ui-button-text-empty');
            button.textContent = '';
            button.appendChild(buttonTitle);
        }
    }
    /**
     *  Action clicked. Call parent action.
     * @param {?} $event
     * @return {?}
     */
    clicked($event) {
        this.action.emit(isBlank(this.value) ? $event : this.value);
    }
}
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-button',
                template: "<button\n    pButton\n    [attr.type]=\"type\"\n    [attr.name]=\"name\"\n    [ngClass]=\"buttonClass\"\n    [disabled]=\"disabled\"\n    [attr.value]=\"value\"\n    (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</button>\n",
                styles: [".ui-button-link{color:#337ab7;font-weight:400;border-radius:0;background-color:transparent}.ui-button-link,.ui-button-link.active,.ui-button-link:active,.ui-button-link:focus,.ui-button-link:hover,.ui-button-link[disabled]{border-color:transparent}.ui-button-link:focus,.ui-button-link:hover{color:#337ab7;-webkit-text-decoration:#337ab7;text-decoration:#337ab7;background-color:transparent}.ui-button-link[disabled]:focus,.ui-button-link[disabled]:hover{color:#2399e5;text-decoration:none}.ui-button{margin-right:5px}.btn-mid{height:36px;padding:5px 10px}.btn-lg{height:42px;font-size:16px;padding:5px 12px}.btn-sm{height:30px;font-size:12px;padding:5px 10px}"]
            }] }
];
/** @nocollapse */
ButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
ButtonComponent.propDecorators = {
    type: [{ type: Input }],
    name: [{ type: Input }],
    style: [{ type: Input }],
    size: [{ type: Input }],
    target: [{ type: Input }],
    value: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWButtonModule {
}
AWButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ButtonComponent
                ],
                imports: [
                    CommonModule,
                    ButtonModule,
                ],
                entryComponents: [
                    ButtonComponent
                ],
                exports: [
                    ButtonComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWBasicNavigatorModule {
}
AWBasicNavigatorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    BasicNavigatorComponent
                ],
                imports: [
                    CommonModule,
                    ToolbarModule,
                    AWButtonModule,
                    AWCoreComponentModule
                ],
                exports: [
                    BasicNavigatorComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class CardZoneTopComponent {
}
CardZoneTopComponent.decorators = [
    { type: Directive, args: [{
                selector: `aw-card-top`,
                host: {
                    'class': 'w-card-ztop'
                }
            },] }
];
class CardZoneBottomComponent {
}
CardZoneBottomComponent.decorators = [
    { type: Directive, args: [{
                selector: `aw-card-bottom`,
                host: {
                    'class': 'w-card-zbottom'
                }
            },] }
];
/**
 *
 * Card component is a container rendering its content inside 3 different zones.
 *
 *  ------------------------------------------
 *  |   TITLE                       | ACTION |
 *  |-----------------------------------------
 *  |                                        |
 *  |   TOP                                  |
 *  |                                        |
 *  ------------------------------------------
 *  |                                        |
 *  |   BOTTOM                               |
 *  |                                        |
 *  |                                        |
 *  ------------------------------------------
 *
 *
 *  There are 3 zones  + 1 placeholder for the actionIcon
 *
 *  Cards can be selectable which means when you click on it there will be rendered a border with
 *  a check mark inside Action zone (this is default behavior).
 *  You can use [selectable] binding to disable this, in such case card will have just a border
 *  without any check mark.
 *
 *  Cards can also contain custom Action which is rendered inside ACTION zone and on the
 *  application level you can listen for (click) events as well as you can provide your own action
 *  icon
 *
 *  Besides ACTION, TITLE, TOP and BOTTOM content zones cards support hover overlay effect and
 *  when its activated there is a overlay displayed on top of the card with Icon in the middle.
 *  Please note when [hasHover] is TRUE all the actions and selectability are disabled as there is
 *  only one action which click on the hover overlay.
 *
 *
 * ###example 1:
 *  Basic hover card which by default support selectable mode
 *
 * ```
 *          <aw-card #card1 [hasAction]="false" [width]="'202px'" [height]="'154px'">
 *
 *                 <aw-card-title [align]="'bottom-left'">
 *                     <span class="a-supplier-tag">
 *                         Preferred
 *                     </span>
 *                 </aw-card-title>
 *
 *                 <aw-card-top>
 *                     <div class="supplierName">
 *                         Haight Pumps
 *                     </div>
 *                     <div class="supplierLocation">
 *                         Palo Alto, CA, USA
 *                     </div>
 *                 </aw-card-top>
 *
 *                 <aw-card-bottom class="w-card-zbottom">
 *                     some text about the supplier and his parents<br/>
 *                     and some contacts
 *                 </aw-card-bottom>
 *
 *             </aw-card>
 *
 * ```
 *
 *  ###example 2:
 *   Hover card with custom action. when unselected action will appear and user can click on it.
 *
 * ```
 *          <aw-card #card1 [selectable]="true" [actionIcon]="'icon-question-mark'"
 *                     (onAction)="onAction(3, $event)">
 *
 *                 <aw-card-title [align]="'bottom-left'">
 *                     <span class="a-supplier-tag">
 *                         Preferred
 *                     </span>
 *                 </aw-card-title>
 *
 *                 <aw-card-top>
 *                     <div class="supplierName">
 *                         Haight Pumps
 *                     </div>
 *                     <div class="supplierLocation">
 *                         Palo Alto, CA, USA
 *                     </div>
 *                 </aw-card-top>
 *
 *                 <aw-card-bottom class="w-card-zbottom">
 *                     some text about the supplier and his parents<br/>
 *                     and some contacts
 *                 </aw-card-bottom>
 *
 *             </aw-card>
 *
 * ```
 *
 *
 *
 */
class CardComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Tells if we should explicitly hide the action
         *
         */
        this.hasAction = false;
        /**
         *
         * Is selectable mode supported? Saying Yes, card will have by default check-mark in the
         * ACTION zone when selected
         *
         */
        this.selectable = true;
        /**
         * Option to pass custom "Card Selected" Icon
         *
         */
        this.selectedIcon = 'icon-accept';
        /*
             * Enable and disables hover effect on top of the card
             */
        this.hasHover = false;
        /**
         *
         * Default icon name for the hover overlay. This icons shows up in the middle over the card
         * vertically and horizontally centered
         *
         */
        this.hoverIcon = 'icon-add';
        /**
         *  Selection state
         *
         */
        this.selected = true;
        /**
         * Fired when the card is selected.
         *
         */
        this.onSelect = new EventEmitter();
        /**
         * Fired when action icon is clicked.
         *
         */
        this.onAction = new EventEmitter();
        /**
         * Fired when the user clicks on the hover overlay.
         *
         */
        this.onHoverAction = new EventEmitter();
        /**
         * Usually when template is provided we want to use it and replace internal one but in this
         * case it will be always conditional and application developer can switch between default
         * template with zones and custom one provided by developer.
         *
         */
        this.useBodyTemplate = false;
        // sets default value
        this.width = '202px';
        this.height = '154px';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // If application wants to use action it must provide actionIcon
        if (isBlank(this.actionIcon) && this.hasAction) {
            throw new Error('You need to provide action icon');
        }
    }
    /**
     * @return {?}
     */
    showBottomSection() {
        return isPresent(this.bottom);
    }
    /**
     * fires select and unselect event.
     * @param {?} event
     * @return {?}
     */
    toggleSelect(event) {
        if (!this.selectable) {
            event.preventDefault();
            event.stopPropagation();
        }
        else {
            this.selected = !this.selected;
            this.onSelect.emit(this.selected);
        }
    }
    /**
     *
     * Only fired when action is rendered and user clicks on custom actionIcon
     *
     * @param {?} event
     * @return {?}
     */
    onActionClick(event) {
        if (this.hasAction && (!this.selected || !this.selectable)) {
            this.onAction.emit(this.selected);
        }
    }
    /**
     * Triggered  when hover effect is on + user click on the card
     *
     * @param {?} isEnter
     * @return {?}
     */
    onHover(isEnter) {
        if (isPresent(this.hoverDiv)) {
            this.hoverDiv.nativeElement.style.opacity = isEnter ? 0.5 : 0;
        }
    }
    /**
     *
     * Used to decide if we should render implicit card template with our zones or
     * user provided template
     *
     * @return {?}
     */
    showBodyTemplate() {
        return isPresent(this.bodyTemplate) && this.useBodyTemplate;
    }
}
CardComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-card',
                template: "<div class=\"w-card\" [style.width]=\"width\" [style.height]=\"height\"\n     [class.u-is-hover]=\"hasHover\"\n     (mouseenter)=\"onHover(true)\"\n     (mouseleave)=\"onHover(false)\"\n     [class.u-card-selected]=\"selected\"\n     [class.u-card-unselected]=\"!selected\"\n     [ngClass]=\"styleClass\"\n>\n\n    <div class=\"card-body ui-g\"  *ngIf=\"!showBodyTemplate()\">\n        <!-- Hover element that is triggered by mouseenter, mouseleave events-->\n        <div #hoverDiv *ngIf=\"hasHover\" class=\"u-card-hover\" (click)=\"onHoverAction.emit($event)\">\n            <span [style.width]=\"'100%'\" class=\"sap-icon\" [ngClass]=\"hoverIcon\"></span>\n        </div>\n        <!-- HEADER HAVING TITLE AND ICONS/ACTIONS-->\n        <div class=\"ui-g-12 ui-g-nopad w-card-header\">\n            <div class=\"w-card-ztitle ui-g-nopad\" (click)=\"toggleSelect($event)\"\n                 [class.u-card-pointer]=\"selectable\"\n                 [ngClass]=\"{'ui-g-9': hasAction || selectable, 'ui-g-11': !hasAction && !selectable}\">\n                <ng-content select=\"aw-card-title\"></ng-content>\n            </div>\n\n            <div *ngIf=\"hasAction || selectable\" class=\"w-card-zaction ui-g-nopad ui-g-3\">\n\n                <span *ngIf=\"selected && selectable\" class=\"sap-icon selection\"\n                      [class.u-card-pointer]=\"selectable\"\n                      [class.u-card-action-bg]=\"selected\"\n                      (click)=\"toggleSelect($event)\"\n                      [ngClass]=\"selectedIcon\"></span>\n\n\n                <span *ngIf=\"hasAction && (!selected || !selectable) \"\n                      class=\"sap-icon action\"\n                      [class.u-card-pointer]=\"true\"\n                      (click)=\"onActionClick($event)\"\n                      [ngClass]=\"actionIcon\"\n                ></span>\n            </div>\n        </div>\n\n        <!--TOP CARD SECTION-->\n        <div class=\"w-card-ztop ui-g-nopad ui-g-12 \"\n             (click)=\"toggleSelect($event)\"\n             [class.u-card-pointer]=\"selectable\">\n            <ng-content select=\"aw-card-top\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-g-nopad w-card-line-divider  \" *ngIf=\"showBottomSection()\"></div>\n        <!--BOTTOM CARD SECTION-->\n        <div *ngIf=\"showBottomSection()\" class=\"ui-g-12 ui-g-nopad w-card-zbottom\"\n             [class.u-card-pointer]=\"selectable\"\n             (click)=\"toggleSelect($event)\">\n            <ng-content select=\"aw-card-bottom\"></ng-content>\n        </div>\n    </div>\n\n    <div *ngIf=\"showBodyTemplate()\" class=\"w-card-user-cnt\" >\n        <ng-container *ngTemplateOutlet=\"bodyTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n",
                styles: [".w-card{border:2px solid #0076cb;display:inline-block;overflow:hidden;color:#636363;box-sizing:border-box}.w-card-header{position:relative;height:30px;padding-left:1em}.w-card-ztitle{height:100%;padding-top:3px}.w-card-ztitle ::ng-deep .w-card-title{height:100%;width:100%;display:flex}.w-card-ztitle ::ng-deep .w-card-title>*{flex:0 1}.w-card-zaction{height:100%;display:inline-block;text-align:right}.w-card-zaction .sap-icon{width:29px;height:29px;text-align:center;display:inline-block;font-size:1.5em;line-height:1.4em}.w-card-zaction .sap-icon.selection{color:#fff}.w-card-zaction .sap-icon.action{color:#969696}.w-card-zbottom,.w-card-ztop{padding:1em}.w-card-line-divider{border-top:1px solid #d6d6d6;margin:0 14px}.w-card-user-cnt{width:100%;height:100%;position:relative;background-color:#eee}.u-card-hover{position:absolute;height:100%;width:100%;opacity:0;transition:.5s;background-color:#0076cb;z-index:100}.u-card-hover .sap-icon{text-align:center;display:inline-block;font-size:4em;color:#fff;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.u-card-action-bg{background:#0076cb}.u-is-hover{position:relative}.u-card-selected{border-color:#0076cb}.u-card-unselected{border-color:#d7d7d7}.u-card-hover,.u-card-pointer{cursor:pointer}"]
            }] }
];
/** @nocollapse */
CardComponent.ctorParameters = () => [
    { type: Environment }
];
CardComponent.propDecorators = {
    hasAction: [{ type: Input }],
    selectable: [{ type: Input }],
    selectedIcon: [{ type: Input }],
    actionIcon: [{ type: Input }],
    hasHover: [{ type: Input }],
    hoverIcon: [{ type: Input }],
    selected: [{ type: Input }],
    onSelect: [{ type: Output }],
    onAction: [{ type: Output }],
    onHoverAction: [{ type: Output }],
    bottom: [{ type: ContentChild, args: [CardZoneBottomComponent,] }],
    bodyTemplate: [{ type: ContentChild, args: ['body',] }],
    hoverDiv: [{ type: ViewChild, args: ['hoverDiv',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Maps our internal alignment value to real css values
 *
  @type {?} */
const VAlignMap = {
    'top-left': 'flex-start',
    'top-center': 'flex-start',
    'top-right': 'flex-start',
    'center-left': 'center',
    'center-center': 'center',
    'center-right': 'center',
    'bottom-left': 'flex-end',
    'bottom-center': 'flex-end',
    'bottom-right': 'flex-end'
};
/** @type {?} */
const HAlignMap = {
    'top-left': 'flex-start',
    'top-center': 'center',
    'top-right': 'flex-end',
    'center-left': 'flex-start',
    'center-center': 'center',
    'center-right': 'flex-end',
    'bottom-left': 'flex-start',
    'bottom-center': 'center',
    'bottom-right': 'flex-end'
};
/**
 * Title zone provides a content placeholder for the Title Area. This zone is adding ability
 * to align its content into 9 different position.
 *
 * You can use this Title zone within <aw-card> as:
 *
 *
 * ```html
 *
 *  <aw-card  [width]="'202px'" [height]="'154px'" [hasHover]="true"
 *                       [selectable]="false" [hasAction]="false"
 *                  (onHoverAction)="onAction(7, $event)" >
 *
 *                  <aw-card-title [align]="'bottom-left'">
 *                      <span class="a-supplier-tag">
 *                          Preferred
 *                      </span>
 *                  </aw-card-title>
 *
 *   </aw-card>
 *
 * ```
 * Default alignment is top-left
 *
 *
 *
 *
 */
class CardZoneTitleComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} elem
     */
    constructor(env, elem) {
        super(env);
        this.env = env;
        this.elem = elem;
        /**
         * Special property which is used to apply flex properties for aligning content vertically
         * as well as horizontally
         *
         */
        this.align = 'top-left';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.elem.nativeElement.style.alignItems = VAlignMap[this.align];
        this.elem.nativeElement.style.justifyContent = HAlignMap[this.align];
    }
}
CardZoneTitleComponent.decorators = [
    { type: Directive, args: [{
                selector: `aw-card-title`,
                host: {
                    'class': 'w-card-title'
                }
            },] }
];
/** @nocollapse */
CardZoneTitleComponent.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef }
];
CardZoneTitleComponent.propDecorators = {
    align: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWCardModule {
}
AWCardModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    CardComponent,
                    CardZoneTitleComponent,
                    CardZoneTopComponent,
                    CardZoneBottomComponent
                ],
                entryComponents: [
                    CardComponent
                ],
                exports: [
                    CardComponent,
                    CardZoneTitleComponent,
                    CardZoneTopComponent,
                    CardZoneBottomComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 *
 * Implements standard HTML checkbox on top of PrimeNG. There are 2 types of
 * {\@link CheckboxComponent}: form and action checkbox as described above.
 *
 *
 * Usage: Basic example having red checkbox checked
 *
 * ```HTML
 *        <aw-checkbox [name]="'color'" [value]="'red'" [label]="'Red'"
 *                                        [(ngModel)]="model">
 *        </aw-checkbox>
 *        <aw-checkbox [name]="'color'" [value]="'blue'" [label]="'Blue'"
 *                                        [(ngModel)]="model">
 *       </aw-checkbox>
 *
 * ```
 *
 * ```ts
 *
 *
 *   class CBBasicWithNgModelComponent
 *   {
 *
 *       model: string[] = ['red'];
 *
 *       constructor()
 *       {
 *       }
 *   }
 *
 * ```
 *
 * For more examples please see a playground or unit test.
 *
  @type {?} */
const CB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckboxComponent),
    multi: true
};
class CheckboxComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value associated with this checkbox
         *
         */
        this.value = '';
        /**
         * Type of checkbox. Form based updates model and Action based only fires click events
         *
         */
        this.type = 'form';
        /**
         * Trigger click event.
         *
         */
        this.action = new EventEmitter();
        /**
         * PrimeNG has this type called binary which works only with Boolean meaning it does not add or
         * remove values.
         *
         * In our case Checktype = Action is always binary or when this.value is boolean
         *
         */
        this.isBinary = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.model = this.value;
        this.type = this.action.observers.length > 0 ? 'action' : this.type;
        if (this.isFormType()) {
            super.ngOnInit();
            if (this.isStandalone) {
                super.registerFormControl(this.value);
                this.model = this.formControl.value;
                this.onModelChanged(this.model);
            }
            else {
                // get control from parent
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
        // When value is boolean we are dealing with PrimeNg Binary checkbox
        // which only sets TRUE/FALSE and does not add or remove values
        this.isBinary = isBoolean(this.value);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (isPresent(changes['value']) &&
            (changes['value'].currentValue !== changes['value'].previousValue)) {
            this.model = changes['value'].currentValue;
        }
    }
    /**
     * Called when Checkbox is clicked and it either fire action or updates the model.
     *
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        if (this.isFormType()) {
            this.onModelChanged(this.model);
            if (this.isStandalone) {
                this.formControl.setValue(this.model);
            }
        }
        else {
            this.action.emit(event);
        }
    }
    /**
     *
     * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
     * applicable for certain type.
     *
     * @return {?}
     */
    isFormType() {
        return this.type === 'form';
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.model && this.isFormType()) {
            this.model = value;
            if (this.isStandalone) {
                this.onModelChanged(this.model);
                this.formControl.setValue(this.model);
            }
        }
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-checkbox',
                template: "<span class=\"w-checkbox\">\n\n    <ng-template [ngIf]=\"editable && isFormType()\">\n        <p-checkbox [name]=\"name\" [value]=\"value\" [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    [binary]=\"isBinary\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\"\n                    [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        >\n        </p-checkbox>\n    </ng-template>\n\n\n    <ng-template [ngIf]=\"!isFormType()\">\n        <p-checkbox [binary]=\"isBinary\"\n                    [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\">\n        </p-checkbox>\n\n    </ng-template>\n</span>\n",
                providers: [
                    CB_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => CheckboxComponent) }
                ],
                styles: ["/deep/ .ui-chkbox .ui-chkbox-box{width:22px;height:22px}/deep/ .ui-chkbox .pi{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.07em;line-height:1.42em}/deep/ .ui-chkbox .pi.pi-check:before{content:'\\e05b'}"]
            }] }
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
CheckboxComponent.propDecorators = {
    value: [{ type: Input }],
    type: [{ type: Input }],
    label: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWCheckBoxModule {
}
AWCheckBoxModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CheckboxComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CheckboxModule
                ],
                entryComponents: [
                    CheckboxComponent
                ],
                exports: [
                    CheckboxComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 *  Checkbox list is a wrapper class around 'Checkbox' component to simply assembly of multi choice
 * component
 *
 * In Addition it adds ability to work with complex object. PrimeNG checkboxes work only with
 * primitive values.
 *
 * @see {\@link check-box/check-box.component.ts}
 *
 *
 * ### Example
 *
 *
 * \@Component({
 *       selector: 'showCheckBoxList' ,
 *       template: `
 *           <aw-checkbox-list [list]="checkBoxListValues" [selections]="selectedValues"
 *
 *            [name]="'myColors'" [formGroup]="formGroup" (onSelection)="onCBClick">
 *           </aw-checkbox-list>
 *       `
 *
 *       })
 *        class MyShowCLComponent
 *        {
 *            checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' ,
 *     'silver' , 'black' ,
 *            'Green' , 'Gray' , 'Navy' , 'Olive' , 'Aqua' , 'Purple'];
 *
 *            selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
 *
 *
 *            formGroup: FormGroup = new FormGroup({});
 *
 *
 *            onCBClick (event): void
 *            {
 *                console.log('onCBClick = ' + event);
 *            }
 *
 *        }
 * *
  @type {?} */
const CB_LIST_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckBoxListComponent),
    multi: true
};
class CheckBoxListComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} cd
     * @param {?} parentContainer
     */
    constructor(env, cd, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.cd = cd;
        this.parentContainer = parentContainer;
        /**
         * Fires event when checkbox is selected/clicked. Emits current clicked checkboxed. not the
         * actuall internal model value in this case array of choices
         *
         */
        this.onSelection = new EventEmitter();
        /**
         * Internal model
         */
        this.model = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.selections)) {
            this.selections = [];
        }
        this.registerFormControl(this.selections);
        this.updateModel(this.selections);
        this.onModelChanged(this.selections);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        let updatedModel = [];
        this.model.forEach((index) => updatedModel.push(this.list[index]));
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
        this.cd.detectChanges();
    }
    /**
     * Label is extracted into this method so in the future we can play more how we want to display
     * the value. Since I want to support formatters for each components we might have a chance to
     * decide how label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    labelValue(item) {
        if (isPresent(this.labelFormatter)) {
            return this.labelFormatter(item);
        }
        return item.toString();
    }
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     * @param {?} item
     * @return {?}
     */
    value(item) {
        return item;
    }
    /**
     * Delegate event outside of this component and convert indexed model to original objects
     *
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        /** @type {?} */
        let updatedModel = [];
        this.model.forEach((index) => {
            updatedModel.push(this.list[index]);
        });
        this.onSelection.emit(updatedModel);
        this.onModelChanged(updatedModel);
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
    }
    /**
     * Since we might be dealing with complex object store only INDEXes number in the model.
     *
     * @param {?} sourceList
     * @return {?}
     */
    updateModel(sourceList) {
        sourceList.forEach((item) => {
            /** @type {?} */
            let index = this.list.findIndex((elem) => {
                return equals(item, elem);
            });
            this.model.push(index);
        });
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (isPresent(this.model) && isPresent(value)) {
            /** @type {?} */
            let newModel = value;
            this.updateModel(newModel);
            // this.cd.markForCheck();
        }
    }
}
CheckBoxListComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-checkbox-list',
                template: "<div *ngFor=\"let item of list; let i = index\" class=\"ui-g\">\n\n    <!-- in the future we should be able to to support inline and stack-->\n    <div class=\"ui-g-12\">\n        <aw-checkbox [(ngModel)]=\"model\"\n                     (ngModelChange)=\"onChange($event)\"\n                     [editable]=\"editable\"\n                     [isStandalone]=\"false\"\n                     [name]=\"name\"\n                     [value]=\"i\"\n                     [label]=\"labelValue(item)\">\n\n        </aw-checkbox>\n    </div>\n\n</div>\n\n",
                providers: [
                    CB_LIST_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => CheckBoxListComponent) }
                ],
                styles: [""]
            }] }
];
/** @nocollapse */
CheckBoxListComponent.ctorParameters = () => [
    { type: Environment },
    { type: ChangeDetectorRef },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
CheckBoxListComponent.propDecorators = {
    list: [{ type: Input }],
    selections: [{ type: Input }],
    onSelection: [{ type: Output }],
    labelFormatter: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWCheckBoxListModule {
}
AWCheckBoxListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CheckBoxListComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCheckBoxModule
                ],
                exports: [
                    CheckBoxListComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Hyperlink component that implements consistent styling, behavior. Hyperlink supports all of the
 * native link functionality. In addition, it supports navigation to components through the action
 * binding.
 *
 *
 * for more info please see class Doc of the:
 * @see {\@link button/button.component.ts}
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *           <aw-hyperlink  [type]="'text/html'" [name]="'link'"
 *                        (action)="onClicked($event)" [value]="customerId"
 *                        [size]="'large'" >my link</aw-hyperlink>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        command:boolean;
 *
 *        constructor ()
 *        {
 *        }
 *
 *        onClicked(customerId:string) {
 *           if (customerId) {
 *              // display customer details component.
 *           }
 *        }
 *    }
 */
class HyperlinkComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * sizing for this link. [large, normal, small].
         */
        this.size = 'normal';
        /**
         * Event fired when user select a item
         */
        this.action = new EventEmitter();
        /**
         * Internal CSS class that styles this hyperlink based on input 'size'
         */
        this.linkClass = 'link';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // Determine the link class based on input size.
        if (this.size) {
            switch (this.size) {
                case 'large':
                    this.linkClass += ' link-lg';
                    break;
                case 'normal':
                    this.linkClass += ' link-mid';
                    break;
                case 'small':
                    this.linkClass += ' link-sm';
                    break;
            }
        }
        // If I have an action tag, and no href. We add default styling and behavior.
        if (this.action.observers.length > 0) {
            this.linkClass += ' link-bh';
        }
    }
    /**
     *  Action clicked. Call parent action.
     * @param {?} event
     * @return {?}
     */
    clicked(event) {
        this.action.emit({
            event: event,
            value: this.value
        });
    }
}
HyperlinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-hyperlink',
                template: "<a [attr.type]=\"type\"\n   [attr.href]=\"href\"\n   [attr.rel]=\"rel\"\n   [attr.target]=\"target\"\n   [ngClass]=\"linkClass\"\n   [class.disabled]=\"disabled\"\n   (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</a>\n",
                styles: [".link{color:#0275d8;cursor:pointer}.link.link-bh{color:#0275d8}.link.link-bh:hover{text-decoration:underline;cursor:pointer}.link-sm{font-size:.875em}.link-mid{font-size:1em}.link-lg{font-size:1.25em}.link.disabled{pointer-events:none;cursor:default;color:#ddd}"]
            }] }
];
/** @nocollapse */
HyperlinkComponent.ctorParameters = () => [
    { type: Environment }
];
HyperlinkComponent.propDecorators = {
    type: [{ type: Input }],
    href: [{ type: Input }],
    rel: [{ type: Input }],
    size: [{ type: Input }],
    target: [{ type: Input }],
    value: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWHyperlinkModule {
}
AWHyperlinkModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    HyperlinkComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    HyperlinkComponent
                ],
                exports: [
                    HyperlinkComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Selection State for the chooser in order to be able to comunicate with the parent object using a
 * chooser. If I would have to manage only single values with no addional methods i would user
 * emitters to do the job, but in this case we need this interface (abstract class) between a
 * chooser and actual object.
 *
 *
 * @abstract
 */
class ChooserSelectionState {
    /**
     *
     * Set selection state is usually triggered by selecting and unselecting a item (in case of
     * multiselect) and it should update its list of objects with either settings/adding item or
     * removing it.
     *
     *
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
    }
    /**
     * The most recent selection . Null if last action was a deselection. Usually used by Chooser
     * or ChooserState to get cuurent value.
     *
     * @return {?}
     */
    selectedObject() {
        return unimplemented();
    }
    /**
     * The most recent selections.
     *
     * @return {?}
     */
    selectedObjects() {
        return unimplemented();
    }
    /**
     *
     * Check if the item selection items is in the selectedObjects
     * @param {?} selection
     * @return {?}
     */
    isSelected(selection) {
        return unimplemented();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
 * selection as well as it can broadcast any updates.
 *
 *
 */
class ChooserState {
    /**
     * @param {?=} chooserSelectionState
     * @param {?=} isMulti
     */
    constructor(chooserSelectionState, isMulti = true) {
        /**
         * Indicates if there are any validation like entered value does not much with the source list.
         *
         */
        this.isInvalid = false;
        /**
         *
         * indicates that we started to some editing e.g. starting to type in something into the
         * filter, or removing already selected items
         */
        this.addMode = false;
        this.recentSelectedDisplayed = 0;
        /**
         * When this option is active we do not show all selected items, but max number that is
         * defined. User is able to toggle to expand the view to see all selections and hide them as
         * well
         */
        this.showAllRecentlySelected = false;
        this.selectionState = chooserSelectionState;
        this.multiselect = isMulti;
        if (isBlank(this.selectionState)) {
            this.selectionState = new DefaultSelectionState(this.multiselect);
        }
    }
    /**
     *
     * It will select and persist an item using ChooserSelectionState provider.
     *
     * @param {?} item
     * @return {?}
     */
    updatedSelectedObjects(item) {
        if (isBlank(item)) {
            item = this.currentItem;
        }
        if (!this.multiselect) {
            this.setSelectionState(item, true);
        }
        else {
            /** @type {?} */
            let selectedObject = this.selectedObject();
            /** @type {?} */
            let selectedObjects = this.selectedObjects();
            if (this.addMode) {
                if (this.isInvalid) {
                    if (isPresent(selectedObject)) {
                        this.setSelectionState(selectedObject, false);
                    }
                }
                this.setSelectionState(item, !ListWrapper.containsComplex(selectedObjects, item));
            }
            else {
                if (isPresent(selectedObject)) {
                    this.setSelectionState(selectedObject, false);
                }
                this.setSelectionState(item, true);
            }
        }
    }
    /**
     * When user selection is large we use this method to check if we need to show all selected
     * items or only MaxRecentSelected
     * @return {?}
     */
    toggleAllSelected() {
        this.showAllRecentlySelected = !this.showAllRecentlySelected;
    }
    /**
     *
     * Renders user's selection under the input field
     *
     * @return {?}
     */
    get recentSelectedObjects() {
        if (!this.multiselect) {
            return [];
        }
        /** @type {?} */
        let recentSelectedObjects = [];
        this.recentSelectedDisplayed = 0;
        /** @type {?} */
        let selectedObjects = this.selectedObjects();
        /** @type {?} */
        let size = selectedObjects.length;
        /** @type {?} */
        let maxCount = DataSource.MaxRecentSelected;
        if (size > DataSource.MaxRecentSelected && !this.showAllRecentlySelected) {
            maxCount -= 1;
        }
        if (this.showAllRecentlySelected) {
            maxCount = size;
        }
        for (let i = size - 1; i >= 0 && (this.recentSelectedDisplayed < maxCount); i--) {
            /** @type {?} */
            let selection = selectedObjects[i];
            recentSelectedObjects.push(selection);
            this.recentSelectedDisplayed++;
        }
        return recentSelectedObjects;
    }
    /**
     * @return {?}
     */
    selectedObject() {
        return this.selectionState.selectedObject();
    }
    /**
     * @return {?}
     */
    selectedObjects() {
        return this.selectionState.selectedObjects();
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
        if (isPresent(selection)) {
            this.selectionState.setSelectionState(selection, selected);
        }
    }
}
/**
 * Dummy implementation ChooserSelectionState
 */
class DefaultSelectionState extends ChooserSelectionState {
    /**
     * @param {?} multiSelect
     */
    constructor(multiSelect) {
        super();
        this.multiSelect = multiSelect;
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
        if (selected) {
            this._selectedObject = selection;
            if (this.multiSelect && !ListWrapper.containsComplex(this.selectedObjects(), selection)) {
                this.selectedObjects().push(selection);
            }
        }
        else {
            if (this.multiSelect) {
                ListWrapper.removeIfExist(this.selectedObjects(), selection);
            }
        }
    }
    /**
     * @return {?}
     */
    selectedObject() {
        return this._selectedObject;
    }
    /**
     * @return {?}
     */
    selectedObjects() {
        if (isBlank(this._selectedObjects)) {
            this._selectedObjects = [];
        }
        return this._selectedObjects;
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    isSelected(selection) {
        return super.isSelected(selection);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
 *
 * 1) You can use default DataSource injected inside component constructor and just call
 * initialize to configure it with correct DataProvider and DataFinder:
 *
 *
 * ```
 *   this.dataSource.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 * and then you can use it to simply retrieve data or run queries.
 *
 * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
 * binding
 *
 * ```
 *
 *   this.ds = new ChooserDataSource(this.data, this.finders);
 *   this.ds.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 *
 */
class ChooserDataSource extends DataSource {
    /**
     * @param {?} dataProviders
     * @param {?} finders
     */
    constructor(dataProviders, finders) {
        super(dataProviders, finders);
        this.dataProviders = dataProviders;
        this.finders = finders;
    }
    /**
     * To initialize this DataSource with current DataFinder and Provider as well as state we use
     * an interface DSChooserInitParams to have all init values typed checked
     *
     *
     * @param {...?} args
     * @return {?}
     */
    init(...args) {
        if (isBlank(args) || args.length !== 1 && !isDSChooserInitParams(args[0])) {
            throw new Error('You need to initialize DS with (DSChooserInitParams)');
        }
        /** @type {?} */
        let init = args[0];
        this.dataProvider = isPresent(init.dataProvider) ? init.dataProvider
            : this.dataProviders.find(init.obj);
        this.dataFinder = isPresent(init.dataFinder) ? init.dataFinder
            : this.finders.find(this.dataProvider, init.queryType);
        assert(isPresent(this.dataProvider) && isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
        if (isPresent(init.state)) {
            this.state = init.state;
        }
        else {
            this.state = new ChooserState(null, init.multiselect);
        }
        this.dataFinder.lookupKey = init.lookupKey;
        this.state.lookupKey = init.lookupKey;
    }
    /**
     * @param {?} pattern
     * @param {?} max
     * @return {?}
     */
    find(pattern, max) {
        this.state.pattern = pattern;
        this.state.lastFullMatchPattern = pattern;
        if (pattern.length === 0) {
            return;
        }
        if (pattern === '*') {
            // query everything
            pattern = '';
        }
        /** @type {?} */
        let origKey = this.dataFinder.lookupKey;
        this.dataFinder.lookupKey = this.state.lookupKey;
        this.dataFinder.forData(this.dataProvider).match(pattern, max)
            .subscribe((result) => {
            this.state.matches = result;
            if (this.state.multiselect) {
                for (let i = 0; i < this.state.selectedObjects().length; i++) {
                    /** @type {?} */
                    let item = this.state.selectedObjects()[i];
                    ListWrapper.removeIfExist(this.state.matches, item);
                }
            }
            this.dataFinder.lookupKey = origKey;
        });
    }
    /**
     *
     * When multiselect this method checks if we need to show SHOW MORE label under the selected
     * items. We do not want show e.g. 50 selection under the chooser that would take up whole
     * page.
     *
     * @return {?}
     */
    showMoreSelected() {
        return this.state.selectedObjects().length >= DataSource.MaxRecentSelected;
    }
    /**
     * @template T
     * @return {?}
     */
    open() {
        return this.dataProvider.dataChanges.asObservable();
    }
    /**
     * @return {?}
     */
    close() {
        this.dataProvider = null;
        this.dataFinder = null;
        this.state = null;
    }
    /**
     * @template T
     * @return {?}
     */
    instant() {
        return this.dataProvider.data();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.state.addMode = true;
        if (isArray(value)) {
            /** @type {?} */
            let items = value;
            items.forEach((item) => this.state.updatedSelectedObjects(item));
        }
        else {
            this.state.updatedSelectedObjects(value);
        }
        this.state.addMode = false;
    }
    /**
     * @return {?}
     */
    get lookupKey() {
        return this.dataFinder.lookupKey;
    }
}
/**
 * @param {?} init
 * @return {?}
 */
function isDSChooserInitParams(init) {
    return isPresent(init.obj) || isPresent(init.queryType);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Typeahead chooser that supports both single and multi-select. Not like Dropdown, this chooser
 * requires little bit different setup. It requires at minimum \@Input dataSource or
 * destinationClass
 *
 *
 * By default chooser is multi-select. If you want single select then you must provide multi-select
 * with \@Input.
 *
 * ### Example
 *
 * In simple scenario you can use Chooser like so:
 *
 *
 * ```
 * \@Component({
 *      selector: 'chooser-app' ,
 *      template: `<aw-chooser  [formGroup]="formGroup" name="color"'
 *                      [dataSource]="ds"></aw-chooser>`
 *  })
 *  export class MyChooserApp
 *  {
 *
 *      ds: ChooserDataSource;
 *
 *     constructor(private data: DataProviders, private finders: DataFinders){
 *          this.ds = new ChooserDataSource(this.data, this.finders);
 *
 *       this.ds.init({
 *           obj: ['blue', 'red', 'yellow'], queryType: QueryType.FullText, state: null,
 *            multiselect: true
 *       });
 *
 *     }
 *  }
 *
 * ````
 *  Above example will use provided dataSource and render multi-select chooser. With default
 *  implementation  selected values will appear as a tags under the input box
 *
 *
 *
 * * ### Example
 *
 *  In this example we provide custom template to change the way how chooser's MenuItem are
 *     rendered as well as template for the selection item looks like
 *
 * ```
 * \@Component({
 *      selector: 'chooser-app' ,
 *      template: `<aw-chooser  name="commodity"' [dataSource]="ds">
 *
 *          <ng-template #menuItem let-item>
 *             	<span>
 *             		<i class="fa fa-envira " ></i>
 *             		{{item}}
 *             	</span>
 *
 *          </ng-template>
 *
 *          <ng-template #selectionItem let-item>
 *             	<span class="tag tag-circle">
 *             		item: {{item }}
 *             		<i class="fa fa-close" (click)="chooser.removeValue(item)"></i>
 *             	</span>
 *
 *
 *          </ng-template>
 *
 *
 *          </aw-chooser>
 *      `
 *      style: [`
 *              .tag-circle {
 *              	border-radius: 6rem;
 *              	height: 7rem;
 *              	color: #e8eef1;
 *              	background-color: rgba(53, 56, 58, 0.67);
 *              	line-height: 6rem;
 *              }
 *      `]
 *  })
 *
 * ````
 *
 *  In above example we change how the chooser's menu item look like as well as we define custom
 *     template for selection item to turn all selection to circles with text in the middle.
 *
 *
 *
  @type {?} */
const CHOOSER_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ChooserComponent),
    multi: true
};
class ChooserComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} elemementRef
     * @param {?} _defaultDS
     * @param {?} parentContainer
     */
    constructor(env, elemementRef, _defaultDS, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.elemementRef = elemementRef;
        this._defaultDS = _defaultDS;
        this.parentContainer = parentContainer;
        /**
         * Max number of items return at single Match so we do not return 1000 items at single time.
         *
         */
        this.maxLength = 10;
        /**
         * Max number of items return at single Match so we do not return 1000 items at single time.
         *
         */
        this.minLenForSearch = 1;
        /**
         * Is this multiselect
         *
         */
        this.multiselect = true;
        this.delay = 300;
        /**
         * Event fired when user select a item
         */
        this.onSelection = new EventEmitter();
        if (isBlank(this.placeHolder)) {
            // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
            this.placeHolder = 'Search';
        }
        // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
        this.hideLink = 'Hide';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.dataSource)) {
            this.dataSource = this._defaultDS;
            this.initDatasource();
        }
        if (isPresent(this.formControl) && isPresent(this.formControl.value)) {
            this.dataSource.updateValue(this.formControl.value);
        }
        this.initInternalModel();
        if (this.isStandalone) {
            super.registerFormControl(this.internalChooserModel);
        }
        else {
            if (isPresent(this.name)) {
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
    }
    /**
     * Add Search icon in case of multiselect.
     * todo: Once PrimeNG will provide a template to override default behavior remove it
     *
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.dataSource.state.multiselect) {
            return;
        }
        /** @type {?} */
        let searchInput = this.elemementRef.nativeElement.querySelector('.ui-autocomplete-input-token');
        if (isPresent(searchInput)) {
            /** @type {?} */
            let iconElement = document.createElement('span');
            iconElement.className = 'search-icon-right fa fa-fw fa-search';
            searchInput.appendChild(iconElement);
        }
        if (isPresent(this.selectionAppendTo) && isPresent(this.selectionViewElem)) {
            /** @type {?} */
            let parentElem = this.selectionAppendTo instanceof ElementRef ?
                this.selectionAppendTo.nativeElement : this.selectionAppendTo;
            parentElem.appendChild(this.selectionViewElem.nativeElement);
        }
    }
    /**
     * Need to change current behavior since we want to show selection under the chooser. K
     *
     * @return {?}
     */
    ngAfterViewChecked() {
        if (!this.dataSource.state.multiselect) {
            return;
        }
        /** @type {?} */
        let tokens = this.elemementRef.nativeElement.querySelectorAll('.ui-autocomplete .ui-autocomplete-token');
        if (isPresent(tokens) && tokens.length > 0) {
            tokens.forEach((item) => {
                item.remove();
            });
        }
    }
    /**
     *
     * When value is entered into search box, we ask our DataSource to match this pattern
     * against data repository. It will retrieve all possible matches limited by MaxLen and this
     * is again filtered so it does not include already selected items.
     *
     *  the matched resulted is saved in the: this.dataSource.state.matches
     * @param {?} pattern
     * @return {?}
     */
    match(pattern) {
        /** @type {?} */
        let maxLen = this.maxLength ? this.maxLength : ChooserDataSource.MaxLength;
        this.dataSource.find(pattern, maxLen);
        // fix: for tests: In version 4 we need to explicitly focus input otherwise autocomplete
        // doesn't give us any popup panel
        if (this.env.inTest && isPresent(this.autoCompleteComponent)) {
            this.autoCompleteComponent.focusInput();
        }
    }
    /**
     *
     * Invoked by Dropdown button in case of single select and here we want to invoke match
     * to retrieve all suggestions without any filter
     *
     * @param {?} event
     * @return {?}
     */
    onDropdownClick(event) {
        this.match('*');
        setTimeout(() => {
            this.match('*');
        }, 100);
    }
    /**
     *
     * Chooser state is updated  with user selection. Please see writeValue. When do not need
     * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
     * shares the same references so its important that we first save reference to
     * this.chooserState.selectedObjects() and then back to internalChooserModel
     *
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        this.onSelection.emit(this.internalChooserModel);
        this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
        this.formControl.markAsDirty({ onlySelf: true });
        this.dataSource.state.addMode = true;
        this.onModelChanged(this.internalChooserModel);
        this.dataSource.state.updatedSelectedObjects(item);
        this.dataSource.state.addMode = true;
        if (!this.dataSource.state.multiselect) {
            this.autoCompleteComponent.inputEL.nativeElement.value =
                this.displayItem(this.internalChooserModel);
        }
    }
    /**
     *
     * Unselect item
     *
     * @param {?} item
     * @return {?}
     */
    removeValue(item) {
        this.dataSource.state.addMode = true;
        this.dataSource.state.updatedSelectedObjects(item);
        this.dataSource.state.addMode = false;
        this.internalChooserModel = this.dataSource.state.selectedObjects();
        this.onSelection.emit(this.internalChooserModel);
        this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
        this.formControl.markAsDirty({ onlySelf: true });
        this.onModelChanged(this.internalChooserModel);
        if (isPresent(this.autoCompleteComponent)) {
            this.autoCompleteComponent.focusInput();
        }
    }
    /**
     *
     * Convert a object if any into the string representation
     *
     * todo: implement better way how to work with objects
     *
     * @param {?} item
     * @return {?}
     */
    displayItem(item) {
        if (isBlank(item)) {
            return null;
        }
        this.dataSource.state.currentItem = item;
        if (isPresent(this.valueTransformer)) {
            return this.valueTransformer(item);
        }
        else if (isPresent(this.dataSource.lookupKey)) {
            return item[this.dataSource.lookupKey];
        }
        else {
            return item.toString();
        }
    }
    /**
     *
     * Returns a label that is shown under the selected item when user selection is >
     * MaxRecentSelected
     *
     * @return {?}
     */
    moreSelectString() {
        /** @type {?} */
        let moreSelected = this.dataSource.state.selectedObjects().length -
            this.dataSource.state.recentSelectedDisplayed;
        if (moreSelected < 2 && !this.dataSource.state.showAllRecentlySelected) {
            return '';
        }
        if (this.dataSource.state.showAllRecentlySelected) {
            return this.hideLink;
        }
        return `${moreSelected} more selected...`;
    }
    /**
     * In case of multiselect = false check if we want to show a selected value inside the input
     * field
     *
     * @return {?}
     */
    singleValueSelected() {
        return !this.dataSource.state && isPresent(this.dataSource.state.currentItem)
            && !this.dataSource.state.addMode;
    }
    /**
     * @return {?}
     */
    hasMenuTemplate() {
        return isPresent(this.menuTemplate);
    }
    /**
     * @return {?}
     */
    hasSelectionTemplate() {
        return isPresent(this.selectionTemplate);
    }
    /**
     * Internal. Please see ControlValueAccessor
     * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
     * initialization once we have a value and we only accept []
     *
     *
     * ? Should we do some deeper comparision?
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (isBlank(value)) {
            return;
        }
        if (isPresent(this.dataSource)) {
            this.dataSource.updateValue(value);
        }
        else {
            /** @type {?} */
            let selState = new DefaultSelectionState(this.multiselect);
            /** @type {?} */
            let chState = new ChooserState(selState, this.multiselect);
            this.initDatasource(chState);
            this.dataSource.updateValue(value);
        }
        this.initInternalModel();
    }
    /**
     * @param {?=} chooserState
     * @return {?}
     */
    initDatasource(chooserState) {
        assert(isPresent(this.destinationClass), 'You need to provide destinationClass or custom DataSource');
        this.dataSource.init({
            obj: this.destinationClass,
            queryType: QueryType.FullText,
            lookupKey: this.field,
            state: chooserState,
            multiselect: this.multiselect
        });
    }
    /**
     *
     * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
     * ngModel property
     *
     * @return {?}
     */
    initInternalModel() {
        if (this.dataSource.state.multiselect) {
            this.internalChooserModel = this.dataSource.state.selectedObjects();
        }
        else {
            this.internalChooserModel = this.dataSource.state.selectedObject();
        }
        if (isPresent(this.formControl)) {
            this.formControl.setValue(this.internalChooserModel);
        }
    }
}
ChooserComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-chooser',
                template: "<div class=\"w-chooser \">\n\n    <p-autoComplete #autoCompplete [(ngModel)]=\"internalChooserModel\"\n                    [suggestions]=\"dataSource.state.matches\"\n                    [multiple]=\"dataSource.state.multiselect\"\n                    [dropdown]=\"!dataSource.state.multiselect\"\n                    [minLength]=\"minLenForSearch\"\n                    [placeholder]=\"placeHolder\"\n                    [delay]=\"delay\"\n                    [disabled]=\"disabled\"\n                    (onDropdownClick)=\"onDropdownClick($event)\"\n                    (completeMethod)=\"match($event.query)\"\n                    (onSelect)=\"selectItem($event)\"\n                    (onUnselect)=\"removeValue($event)\">\n\n\n        <ng-template let-internalChooserModel pTemplate=\"item\">\n            <ng-template [ngIf]=\"!hasMenuTemplate()\">\n                {{ displayItem(internalChooserModel) }}\n            </ng-template>\n            <ng-template [embeddedItem]=\"menuTemplate\" [item]=\"internalChooserModel\"\n                         *ngIf=\"hasMenuTemplate()\"></ng-template>\n        </ng-template>\n    </p-autoComplete>\n\n    <!--\n        Wrap whole selection with one extra element so we can move it around\n\n         see: selectionAppendTo\n    -->\n    <span #selectionView>\n        <div class=\"w-chooser-selections\"\n             *ngIf=\"multiselect && dataSource.state.recentSelectedObjects.length > 0\">\n\n        <ng-template [ngIf]=\"!hasSelectionTemplate()\">\n\n            <!-- no selection template render it as it is from CORE-->\n            <ul class=\"ui-autocomplete-multiple-container ui-widget ui-state-default \"\n                [ngClass]=\"{'ui-state-disabled':disabled,'ui-state-focus':autoCompleteComponent.focus}\">\n\n                <li #token *ngFor=\"let item of dataSource.state.recentSelectedObjects\"\n                    class=\"ui-autocomplete-token ui-state-highlight ui-corner-all\" tabindex=\"0\"\n                    (keyup.delete)=\"removeValue(item)\"\n                    (keyup.backspace)=\"removeValue(item)\">\n\t\t\t\t\t<span class=\"ui-autocomplete-token-icon sap-icon icon-decline\"\n                          (click)=\"removeValue(item)\"></span>\n                    <span class=\"ui-autocomplete-token-label\">{{ displayItem(item) }}</span>\n                </li>\n            </ul>\n        </ng-template>\n\n            <!--Yes there is selection template let's iterate and push each item to be rendered-->\n        <ng-template ngFor [ngForOf]=\"dataSource.state.recentSelectedObjects\" let-item>\n            <ng-template [embeddedItem]=\"selectionTemplate\" [item]=\"item\"\n                         *ngIf=\"hasSelectionTemplate()\"></ng-template>\n        </ng-template>\n\n        <ng-template [ngIf]=\"dataSource.showMoreSelected()\">\n\t\t\t<span class=\"more-selected\">\n\t\t\t\t<aw-hyperlink [size]=\"'small'\" (action)=\"dataSource.state.toggleAllSelected()\">\n\t\t\t\t\t{{moreSelectString()}}\n\t\t\t\t</aw-hyperlink>\n\t\t\t</span>\n        </ng-template>\n    </div>\n    </span>\n\n\n</div>\n\n",
                providers: [
                    CHOOSER_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => ChooserComponent) },
                    { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                ],
                styles: ["/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-input,/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-multiple-container{width:100%}/deep/ .w-chooser .ui-autocomplete-multiple{line-height:normal}/deep/ .w-chooser .ui-autocomplete-input{width:100%}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button{right:0;position:absolute;border:0;width:30px;background:0 0}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button input{padding-right:30px}/deep/ .w-chooser .ui-autocomplete-input-token{padding:0;margin:0;vertical-align:baseline;width:inherit}/deep/ .w-chooser .ui-autocomplete-input-token .fa{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.2em}/deep/ .w-chooser .ui-autocomplete-input-token .fa-search:before{content:'\\e00d'}/deep/ .w-chooser .ui-autocomplete-input-token input{width:inherit;padding-right:25px}/deep/ .w-chooser .ui-autocomplete-input-token span{position:absolute;right:5px;top:0;padding-top:.6em}/deep/ .w-chooser .ui-autocomplete-dropdown{height:36px}/deep/ .w-chooser .ui-autocomplete-panel .ui-autocomplete-list-item{padding:.65em 2em .65em .64em;margin:0}/deep/ body .ui-autocomplete.ui-autocomplete-multiple .ui-autocomplete-multiple-container{padding:.4em .5em .4em 1em}.w-chooser-selections{margin-top:2px}.w-chooser-selections ul{margin:0;padding:0}.w-chooser-selections .ui-autocomplete-multiple-container{border:0}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token{font-size:.85em;letter-spacing:.1px;font-weight:400;padding:0;background:#e0f2ff;margin-right:5px;margin-bottom:5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-label{padding:4px 21px 4px 5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-icon{font-size:.78em;padding-right:.28em}.w-chooser-selections .ui-autocomplete-multiple-container .sap-icon{line-height:inherit}.w-chooser-selections .more-selected{display:inline-block}"]
            }] }
];
/** @nocollapse */
ChooserComponent.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef },
    { type: ChooserDataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
ChooserComponent.propDecorators = {
    maxLength: [{ type: Input }],
    minLenForSearch: [{ type: Input }],
    valueTransformer: [{ type: Input }],
    multiselect: [{ type: Input }],
    dataSource: [{ type: Input }],
    selectionAppendTo: [{ type: Input }],
    delay: [{ type: Input }],
    destinationClass: [{ type: Input }],
    field: [{ type: Input }],
    onSelection: [{ type: Output }],
    menuTemplate: [{ type: ContentChild, args: ['menuItem',] }],
    selectionTemplate: [{ type: ContentChild, args: ['selectionItem',] }],
    autoCompleteComponent: [{ type: ViewChild, args: ['autoCompplete',] }],
    selectionViewElem: [{ type: ViewChild, args: ['selectionView',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWChooserModule {
}
AWChooserModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ChooserComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AutoCompleteModule,
                    AWHyperlinkModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    ChooserComponent
                ],
                exports: [
                    ChooserComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * A popup like component rendering list of values as. Based on PrimeNG component and one of the
 * main reason why we need to wrap this is to extend its capabilities to accept almost any
 * data type without using Primens's specific SelectItem type.
 *
 *
 * ### Example
 *
 * ```
 * \@Component({
 *      selector: 'showDropDown' ,
 *      template: '<aw-dropdown [list]="testItemSmall"
 *     (onSelection)="onSelection($event)"></aw-dropdown>'
 *  })
 *  export class MyDropComponent
 *  {
 *      testItemSmall: string[] = ['view' , 'edit'];
 *
 *      // when you switch list binding to refert to large item fiilter automatically is shown and
 *     max 10 items are
 *      // visible
 *      testItemLarge: string[] = ['view' , 'edit' , 'frank' , 'kolar' , 'The Sun' , 'Dog' ,
 *     'Computer' , 'A Desk' ,
 *      'My Car' , 'Pencil' , 'This Page' , 'Yesterday' , 'Monday' , 'Tuesday' , 'BMW R1200 GS' ,
 *     'Czech Republic' ,
 *      'Last Item'];
 *
 *
 *      itemSelected: string = 'view';
 *      itemSelectedLg: string = 'Monday';
 *
 *      noselString: string = '(no selection)';
 *
 *
 *      onSelection (event): void
 *      {
 *          this.itemSelected = event;
 *
 *      }
 *  }
 *
 *  ```
 *
  @type {?} */
const DD_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DropdownComponent),
    multi: true
};
class DropdownComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Event fired when user select a item
         */
        this.onSelection = new EventEmitter();
    }
    /**
     * Todo: Put back the scrolling option once we decide so. Currently the requirements are
     * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
     * search filter.
     * @return {?}
     */
    ngOnInit() {
        if (this.isStandalone) {
            super.ngOnInit();
            super.registerFormControl(this.selection);
        }
        else {
            if (isPresent(this.name)) {
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
        // transform a value to PrimeNg Format, we are not really be using a label field only a
        // value.
        this.internalList = [];
        // if (isPresent(this.noSelectionString)) {
        //     this.internalList.push({
        //         label: this.noSelectionString,
        //         value: null
        //     });
        //
        //     if (isBlank(this.selection)) {
        //         this.selection = this.noSelectionString;
        //     }
        // }
        if (isPresent(this.list) && this.list.length >= DropdownComponent.MaxNumShown) {
            this.internalList = this.list.slice(0, DropdownComponent.MaxNumShown).map((item) => {
                return { label: item.toString(), value: item };
            });
        }
        else if (isPresent(this.list)) {
            this.internalList = this.list.slice(0).map((item) => {
                return { label: item.toString(), value: item };
            });
        }
    }
    /**
     * @return {?}
     */
    hasEmbeddedTemplate() {
        return isPresent(this.itemTemplate);
    }
    /**
     * Check to prevent Empty item to be rendered
     *
     * todo: Report this on PrimeNg
     *
     * @param {?} item
     * @return {?}
     */
    itemExist(item) {
        return isPresent(item);
    }
    /**
     * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
     * input field
     * @return {?}
     */
    showFilter() {
        return false;
        // return isPresent(this.list) && this.list.length > DropdownComponent.MaxNumShown;
    }
    /**
     *
     * Updates internal models of current selections and triggers onSelection event
     *
     * @param {?} value
     * @return {?}
     */
    onItemSelection(value) {
        this.selection = value.value;
        this.onSelection.emit(value.value);
        if (this.isStandalone) {
            this.formControl.setValue(this.selection);
            this.formControl.markAsDirty({ onlySelf: true });
        }
        this.onModelChanged(value.value);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    displayItem(item) {
        return isPresent(item) ? item.label : 'No Selection';
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!equals(value, this.selection)) {
            this.selection = value;
            this.formControl.setValue(value);
        }
    }
}
DropdownComponent.MaxNumShown = 10;
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dropdown',
                template: "<div class=\"w-dropdown\" [formGroup]=\"formGroup\">\n\n    <ng-template [ngIf]=\"isStandalone\">\n        <p-dropdown [options]=\"internalList\"\n                    [formControlName]=\"name\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n\n                </ng-template>\n            </ng-template>\n\n\n        </p-dropdown>\n    </ng-template>\n</div>\n\n\n<!-- no formControl Name here. ngModel cannot have formGroup around -->\n<ng-template [ngIf]=\"!isStandalone\">\n    <div class=\"w-dropdown\">\n        <p-dropdown [options]=\"internalList\"\n                    [(ngModel)]=\"selection\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n                </ng-template>\n            </ng-template>\n        </p-dropdown>\n    </div>\n</ng-template>\n",
                providers: [
                    DD_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => DropdownComponent) }
                ],
                styles: ["/deep/ .ui-dropdown-panel{z-index:10010!important;top:35px!important}/deep/ .ui-dropdown-panel .ui-dropdown-items-wrapper{max-height:none!important}/deep/ .ui-dropdown-panel .ui-dropdown-item{padding:.65em 2em .65em .64em;margin:0}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container{width:100%}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container .fa{top:1.2em}/deep/ .ui-dropdown-panel .ui-dropdown-list{padding:1em 0}/deep/ .w-dropdown:not(.ng-dirty) label{color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger.ui-corner-right{border-left:none;color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-dropdown .ui-dropdown-trigger .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-dropdown .ui-dropdown-label{padding-right:2.4em}"]
            }] }
];
/** @nocollapse */
DropdownComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
DropdownComponent.propDecorators = {
    list: [{ type: Input }],
    selection: [{ type: Input }],
    noSelectionString: [{ type: Input }],
    onSelection: [{ type: Output }],
    itemTemplate: [{ type: ContentChild, args: ['itemTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWDropdownModule {
}
AWDropdownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DropdownComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DropdownModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    DropdownComponent
                ],
                exports: [
                    DropdownComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Lightweight and configurable Currency component based on the ng bootstrap directive. This
 * component combines an input and currency code dropdown.
 *
 *
 * for more info please see class Doc of the:
 * @see {\@link currency/currency.component.ts}
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'amount' ,
 *    template: `
 *
 *      <aw-currency [money]="price" [currencies]="currencies" [name]="'currency'">
 *      </aw-currency>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        amount: number = 1000;
 *        currencies: string[] = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
 *        currencyCode: string = this.currencies[0];
 *
 *        constructor ()
 *        {
 *        }
 *    }
  @type {?} */
const CURRENCY_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CurrencyComponent),
    multi: true
};
class CurrencyComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Disable user to change Money's currency code and still
         * allow user to edit Money's amount.
         */
        this.readonlyCurrencyCode = false;
        // Initialize currencies.
        this.initCurrencies();
        this.currencyPipe = new CurrencyPipe(env.locale);
        env.onLocaleChange.subscribe((locale) => {
            this.currencyPipe = new CurrencyPipe(locale);
            if (isPresent(this.money)) {
                this.displayValue = this.formatCurrency(this.money.amount);
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.money);
        this.initCurrencies();
        if (isBlank(this.currencySelection)) {
            this.currencySelection = this._currencies[0];
        }
        // ready the money field if it exists. and override the existing values.
        if (this.money) {
            this.currencySelection = this.money.currency;
        }
        else {
            this.money = new Money(null, this.currencySelection);
        }
        this.displayValue = this.formatCurrency(this.money.amount);
    }
    /**
     * @return {?}
     */
    initCurrencies() {
        if (!this._currencies || this._currencies.length === 0) {
            this._currencies = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
        }
    }
    /**
     * Display the real value when the user clicks in the currency widget. Then he can modify the
     * value without seeing the formatting.
     *
     * @param {?} el
     * @return {?}
     */
    onFocus(el) {
        if (isPresent(this.money) && isPresent(this.money.amount)) {
            this.displayValue = this.money.amount.toString();
        }
    }
    /**
     * display the formatted currency value when the user navigates away.
     * @param {?} el
     * @return {?}
     */
    onBlur(el) {
        this.money = this.money.clone({ amount: Number(el.value) });
        this.displayValue = this.formatCurrency(this.money.amount);
        this.onModelChanged(this.money);
    }
    /**
     * @param {?} currency
     * @return {?}
     */
    onSelection(currency) {
        this.currencySelection = currency;
        this.displayValue = this.formatCurrency(this.money.amount);
    }
    /**
     * Function will check to see if currency is a valid number before formatting.
     * @param {?} val
     * @return {?}
     */
    formatCurrency(val) {
        if (!val || val.length === 0) {
            return val;
        }
        if (isNaN(val)) {
            return val;
        }
        /** @type {?} */
        let code = 'USD';
        if (this.currencySelection) {
            code = this.currencySelection;
        }
        this.money = this.money.clone({ currency: this.currencySelection });
        /** @type {?} */
        let digits = '1.0-2';
        // If precision is present, use it for format the money value for display.
        if (isPresent(this.precision)) {
            digits = '1.0-' + this.precision;
        }
        return this.currencyPipe.transform(val, code, 'symbol', digits);
    }
    /**
     * @return {?}
     */
    getMoneyCurrency() {
        if (isPresent(this.displayValue) && this.displayValue.length > 0) {
            return this.currencySelection;
        }
        return '';
    }
    /**
     * @return {?}
     */
    get currencies() {
        return this._currencies;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currencies(value) {
        if (isPresent(value)) {
            this._currencies = value;
        }
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if ((value instanceof Money) && !equals(value, this.money)) {
            this.money = value;
            if (isPresent(this.money.currency)) {
                this.currencySelection = this.money.currency;
            }
            this.displayValue = this.formatCurrency(this.money.amount);
            this.formControl.setValue(this.money);
        }
    }
}
CurrencyComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-currency',
                template: "<ng-template [ngIf]=\"editable\">\n    <div class=\"w-currency-field ui-fluid\" [formGroup]=\"formGroup\">\n        <div class=\"ui-g \">\n            <div class=\"ui-g-8 ui-g-nopad \">\n                <input #currencyInput\n                       pInputText\n                       type=\"text\" class=\"w-text-field currency-format\"\n                       [attr.name]=\"name\"\n                       [attr.placeholder]=\"placeHolder\"\n                       [value]=\"displayValue\"\n                       (focus)=\"onFocus(currencyInput)\"\n                       (blur)=\"onBlur(currencyInput)\"\n                       [disabled]=\"disabled\">\n            </div>\n            <div class=\"ui-g-4 ui-g-nopad w-cc-field\">\n                <aw-dropdown *ngIf=\"!readonlyCurrencyCode\"\n                             [isStandalone]=\"false\" [list]=\"currencies\"\n                             [selection]=\"money.currency\"\n                             (onSelection)=\"onSelection($event)\"\n                             [disabled]=\"disabled\">\n\n                </aw-dropdown>\n                <div *ngIf=\"readonlyCurrencyCode\" class=\"w-cc-readonly-field\">{{money.currency}}</div>\n            </div>\n        </div>\n    </div>\n</ng-template>\n\n<!-- currency:'USD':true -->\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{displayValue}} {{ getMoneyCurrency() }}\"></aw-string>\n</ng-template>\n",
                providers: [
                    CURRENCY_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => CurrencyComponent) }
                ],
                styles: [".w-currency-field [readonly],.w-currency-type-field [readonly]{background-color:#fff}.w-currency-field input,.w-currency-type-field input{min-width:80px}.w-currency-field i.fa,.w-currency-type-field i.fa{cursor:pointer}.w-currency-field{margin-top:0}.w-currency-field /deep/ .ui-dropdown{min-width:80px}.w-cc-field{display:flex;align-items:center}.w-cc-readonly-field{padding-left:5px;color:#969696}.no-gutter>[class*=ui-g-]{padding-right:0;padding-left:0}"]
            }] }
];
/** @nocollapse */
CurrencyComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
CurrencyComponent.propDecorators = {
    money: [{ type: Input }],
    readonlyCurrencyCode: [{ type: Input }],
    currencySelection: [{ type: Input }],
    precision: [{ type: Input }],
    currencies: [{ type: Input }]
};
/**
 * Money object is represented as a value, locale, and currencyCode
 */
class Money {
    /**
     * @param {?=} amount
     * @param {?=} currency
     * @param {?=} locale
     */
    constructor(amount = 0, currency = 'USD', locale = 'en_US') {
        this.amount = amount;
        this.currency = currency;
        this.locale = locale;
    }
    /**
     * @return {?}
     */
    getTypes() {
        return {
            amount: Number,
            currency: String,
            locale: String
        };
    }
    /**
     * @return {?}
     */
    className() {
        return 'Money';
    }
    /**
     * @return {?}
     */
    $proto() {
        return new Money(1, '23', '33');
    }
    /**
     * @return {?}
     */
    toString() {
        return this.amount + ', locale: ' + this.locale + ', code:  ' + this.currency;
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    clone(data = {}) {
        return new Money(isPresent(data.amount) ? data.amount : this.amount, isPresent(data.currency) ? data.currency : this.currency, isPresent(data.locale) ? data.locale : this.locale);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWCurrencyModule {
}
AWCurrencyModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CurrencyComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule$1,
                    DropdownModule,
                    AWDropdownModule,
                    AWStringFieldModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    CurrencyComponent
                ],
                exports: [
                    CurrencyComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: [CurrencyPipe]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Lightweight and configurable Date and Time component based on the primeng. This
 * component combines both date picker as well as time picker
 *
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'myTimer' ,
 *    template: `
 *    <aw-date-time [value]="date" [editable]="editable"  [name]="'dueDate'">
 *    </aw-date-time>
 *
 *    `
 *    })
 *    export class MyTimmerComponet
 *    {
 *
 *        date: Date = new Date();
 *
 *
 *        constructor ()
 *        {
 *            this.date.setFullYear(2016 , 10 , 3);
 *            this.date.setHours(10 , 10 , 10);
 *        }
 *    }
 *
 * ```
 *
 * By default you will see date field and time field is hidden to show both you just do following:
 *
 *  ```
 *
 * \@Component({
 *    selector: 'myTimer' ,
 *    template: `
 *
 *    <aw-date-time [value]="date"  [showTime]="showTime" [editable]="editable"  [name]="'bbdd'">
 *    </aw-date-time>
 *
 *    `
 *    })
 *    export class MyTimmerComponet
 *    {
 *        date: Date = new Date();
 *        showTime = true;
 *
 *        constructor ()
 *        {
 *            this.date.setFullYear(2016 , 10 , 3);
 *            this.date.setHours(10 , 10 , 10);
 *        }
 *    }
 *
 * ```
 *
 *
 *
  @type {?} */
const DATETIME_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DateAndTimeComponent),
    multi: true
};
class DateAndTimeComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Default date format pattern used if none is passed
         *
         */
        this.formatPattern = 'mm/dd/yy';
        /**
         * Special workaround as formatters in the primeNG and angular are different so until its
         * fixed we need to keep this extra pattern.
         */
        this.formatPatternNG = 'MM/dd/yy';
        /**
         * Shows and hides navigation bar with year and months selections
         */
        this.showNavigation = false;
        /**
         * Shows and hides navigation bar with year and months selections
         */
        this.showIcon = true;
        /**
         * Whether to show timepicker
         */
        this.showTime = false;
        /**
         * Whether to show DatePicker. Even we can hide it. it should be for most of the case always
         * true
         */
        this.showDate = true;
        /**
         *
         * Tells the date picker what format it should use when presenting time. When hourFormat is 12,
         * it shows the AM, PM
         *
         */
        this.hourFormat = '24';
        /**
         * Triggers event when specific date is clicked inside DatePicker
         *
         */
        this.onChange = new EventEmitter();
        /**
         * Set the date to highlight on first opening if the field is blank.
         *
         */
        this.defaultDate = new Date();
        this.timePlaceHolder = 'hh:ss';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.value);
        // default to dateTime pattern which is defined in resource files
        if (this.hourFormat !== '12' && this.hourFormat !== '24') {
            this.hourFormat = '24';
        }
        this.timePlaceHolder = (this.hourFormat === '12') ?
            ` ${DateAndTimeComponent.NgTime12}` : ` ${DateAndTimeComponent.NgTime24}`;
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe((val) => {
            this.value = val;
            this.onModelChanged(this.value);
        });
        this.initTranslations();
        this.env.onLocaleChange.subscribe((locale) => {
            this.initTranslations();
        });
    }
    /**
     * Need to refactor this as this really get complicated trying to cover usecase with time
     * and date and every format we have. We should probably have separate patterns for
     * dates only and date + time
     * @return {?}
     */
    initTranslations() {
        this.formatNameWithTime = this.formatPattern;
        if (!this.showDate) {
            this.formatPatternNG = this.formatPattern += (this.hourFormat === '12') ?
                ` ${DateAndTimeComponent.NgTime12}` : ` ${DateAndTimeComponent.NgTime24}`;
        }
        if (this.showTime) {
            /** @type {?} */
            let timeStarts = this.formatPattern.indexOf('h');
            if (timeStarts !== -1) {
                this.formatNameWithTime = this.formatPattern.substring(0, timeStarts);
            }
            this.formatPatternNG += (this.hourFormat === '12') ?
                ` ${DateAndTimeComponent.NgTime12}` : ` ${DateAndTimeComponent.NgTime24}`;
        }
        this.i18n = {
            firstDayOfWeek: 0,
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
                'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
                'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                'Nov', 'Dec']
        };
    }
    /**
     * Fired when dates changes. Here we update  this.value - > date and also update value inside
     * formController
     *
     * @param {?} event
     * @return {?}
     */
    onDateChange(event) {
        if (isBlank(event)) {
            // throw some error ?
            return;
        }
        this.value = isDate(event) ? event : new Date(event);
        this.formControl.setValue(this.value, { onlySelf: false, emitEvent: true });
        this.onModelChanged(this.value);
        this.onChange.emit(this.value);
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value);
        }
    }
}
DateAndTimeComponent.NgTime12 = 'hh:mm a';
DateAndTimeComponent.NgTime24 = 'HH.mm a';
DateAndTimeComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-date-time',
                template: "<ng-template [ngIf]=\"editable\">\n\n    <div class=\"w-datetime \" [class.has-time]=\"showTime\" [formGroup]=\"formGroup\">\n\n        <p-calendar formControlName=\"{{name}}\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    dateFormat=\"{{showTime ? formatNameWithTime : formatPattern}}\"\n                    [yearNavigator]=\"showNavigation\"\n                    [monthNavigator]=\"showNavigation\"\n                    [yearRange]=\"yearRange\"\n                    placeholder=\"{{showTime ? formatNameWithTime.toUpperCase() : formatPattern.toUpperCase()}}\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [timeOnly]=\"!showDate\"\n                    [readonlyInput]=\"true\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n        <p-calendar *ngIf=\"showTime\"\n                    icon=\"icon-history\"\n                    formControlName=\"{{name}}\"\n                    [hourFormat]=\"hourFormat\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    [timeOnly]=\"showTime\"\n                    [showTime]=\"showTime\"\n                    [placeholder]=\"timePlaceHolder\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n    </div>\n</ng-template>\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{value | date: formatPatternNG}}\"></aw-string>\n</ng-template>\n",
                providers: [
                    DATETIME_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => DateAndTimeComponent) }
                ],
                styles: ["/deep/ .w-datetime .ui-calendar button{border:0;width:0}/deep/ .w-datetime .ui-calendar.ui-calendar-w-btn .ui-inputtext{width:100%}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.4em}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.pi-calendar:before{content:'\\e0e0'}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.icon-history:before{content:'\\e02d'}/deep/ .ui-datepicker{width:24.28em;line-height:25px;padding:0;border-color:#979797;box-shadow:none}/deep/ .ui-datepicker .ui-datepicker-header{padding:.92em 0;font-weight:400;color:#000;font-size:1em}/deep/ .ui-datepicker .ui-datepicker-next,/deep/ .ui-datepicker .ui-datepicker-prev{top:1em}/deep/ .ui-datepicker .ui-datepicker-prev{left:.2em}/deep/ .ui-datepicker .ui-datepicker-next{right:.2em}/deep/ .ui-datepicker table{font-size:1em;margin:0 0 1.5em}/deep/ .ui-datepicker th{font-weight:400;background-color:#ececec;color:#363636;padding:.786em 1.07em}/deep/ .ui-datepicker td{padding:.1em}/deep/ .ui-datepicker td a{text-align:center;width:2.7em;height:2.7em;line-height:2.7em;padding:0;border-radius:50%}/deep/ .ui-datepicker td a.ui-state-default{border-color:transparent}/deep/ .ui-datepicker td a.ui-state-active{background-color:#199de0;color:#fff}/deep/ .ui-datepicker .pi{font-size:1em}/deep/ .ui-datepicker .pi.pi-chevron-left:before{content:'\\e1ee'}/deep/ .ui-datepicker .pi.pi-chevron-right:before{content:'\\e1ed'}/deep/ .ui-datepicker .ui-datepicker-calendar td:not(.ui-state-disabled) a:hover{border-color:transparent;background-color:rgba(25,157,224,.7);opacity:.75;color:#363636}/deep/ .ui-datepicker-timeonly{width:100%}/deep/ .ui-timepicker{font-size:1.14em;color:#767676;font-weight:400}/deep/ .ui-timepicker .pi{font-size:1em}/deep/ .ui-timepicker .pi.pi-chevron-up:before{content:'\\e1f0'}/deep/ .ui-timepicker .pi.pi-chevron-down:before{content:'\\e1ef'}/deep/ .ui-timepicker>div{margin-left:0}/deep/ .ui-timepicker .ui-separator{width:.1em;min-width:.1em}/deep/ .ui-timepicker .ui-separator .pi{font-size:0}/deep/ .ui-datepicker-trigger{background-color:transparent}/deep/ .ui-datepicker-trigger.ui-button:enabled:hover,/deep/ .ui-datepicker-trigger.ui-button:focus{background-color:transparent}/deep/ .has-time{display:flex;flex-wrap:nowrap}/deep/ .has-time p-calendar:first-child{width:55%;margin-right:14px}/deep/ .has-time p-calendar:last-child{width:45%}/deep/ .has-time p-calendar:last-child .ui-datepicker{padding:0}/deep/ .has-time .ui-button-icon-left{line-height:18px}"]
            }] }
];
/** @nocollapse */
DateAndTimeComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
DateAndTimeComponent.propDecorators = {
    value: [{ type: Input }],
    formatPattern: [{ type: Input }],
    formatPatternNG: [{ type: Input }],
    showNavigation: [{ type: Input }],
    yearRange: [{ type: Input }],
    showIcon: [{ type: Input }],
    showTime: [{ type: Input }],
    showDate: [{ type: Input }],
    hourFormat: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWDateAndTimeModule {
}
AWDateAndTimeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DateAndTimeComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CalendarModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    DateAndTimeComponent
                ],
                exports: [
                    DateAndTimeComponent,
                    ReactiveFormsModule,
                    FormsModule
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * An dialog header area.
 *
 * See {\@link DialogComponent} for more explanation.
 */
class DialogHeaderComponent {
}
DialogHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dialog-header',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * An dialog header area.
 *
 * See {\@link DialogComponent} for more explanation.
 */
class DialogFooterComponent {
}
DialogFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dialog-footer',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Dialog Component that provides the look and feel for a modal dialog. This component has three
 * sections: header, body, and footer. It can be used by itself or extended.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<DialogComponent>), service.close()
 *
 * Usage:
 *    1.  Using Dialog directly to display a modal popup. This usage is a quick way to show a
 * message to the user.
 *
 *             this.modalService.open<DialogComponent>( DialogComponent, {
 *                     title: 'My Popup Title',
 *                     body: 'My Popup Body'
 *              });
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                              <aw-dialog [(visible)]="display" [modal]="true"
 *                                        (onOpen)="openAction()" (onClose)="closeAction()">
 *
 *                                    <aw-dialog-header>Dialog Header</aw-dialog-header>
 *
 *                                     Dialog Body: Creating a dialog using the dialog component
 *
 *                                    <aw-dialog-footer>
 *                                      <aw-button [size]="'small'" [style]="'primary'"
 *                                                 (click)="close()">OK</aw-button>
 *                                    </aw-dialog-footer>
 *                              </aw-dialog>
 *
 *                          <aw-button [size]="'small'" (click)="open()">Open Dialog</aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     display: boolean = false;
 *
 *                     dialogAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     open() {
 *                        this.display = true;
 *                     }
 *
 *                     openAction()  {
 *                        this.dialogAction = "open";
 *                      }
 *       }
 *
 *
 */
class DialogComponent extends ModalContainer {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * support two way data binding on visible property.
         */
        this.visibleChange = new EventEmitter();
        /**
         * whether this dialog blocks the rest of the page or not when displayed.
         */
        this.modal = true;
        /**
         * Whether there's an x at the top right that makes the dialog closable.
         */
        this.closable = true;
        /**
         * Event fired when dialog is closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event fired when the dialog is opened.
         */
        this.onOpen = new EventEmitter();
        this.width = 300;
        this.height = 'auto';
    }
    /**
     * Open this dialog.
     * @return {?}
     */
    open() {
        this.visible = true;
        this.onOpen.emit();
        // visible is a 2-way binding variable.
        this.visibleChange.emit(true);
    }
    /**
     * close the dialog
     * @return {?}
     */
    close() {
        this.visible = false;
        this.onClose.emit();
        // Important to make sure change is set on parent binding.
        // Otherwise, the variable and dialog open/close state can be out
        // of sync and we wouldn't trigger change detection.
        this.visibleChange.emit(false);
    }
    /**
     * Does this dialog have header.
     *
     * @return {?}
     */
    hasHeader() {
        return isPresent(this.header);
    }
    /**
     * Does this dialog have footer.
     *
     * @return {?}
     */
    hasFooter() {
        return isPresent(this.footer);
    }
}
DialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dialog',
                template: "<p-dialog [header]=\"title\" [(visible)]=\"visible\"\n          [modal]=\"modal\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n          [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onShow)=\"open()\" (onHide)=\"close()\">\n\n    <p-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-dialog-header\"></ng-content>\n    </p-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n    <p-footer *ngIf=\"hasFooter()\">\n        <div class=\"dialog-footer-separator\"></div>\n        <ng-content select=\"aw-dialog-footer\"></ng-content>\n    </p-footer>\n</p-dialog>\n",
                styles: ["::ng-deep .ui-dialog .ui-dialog-titlebar{background-color:#f2f2f2;padding:15px 20px}::ng-deep .ui-dialog .ui-dialog-titlebar .ui-dialog-titlebar-icon:hover{border-color:transparent}::ng-deep .ui-widget-header{font-weight:400;font-size:16px}::ng-deep .ui-dialog .ui-dialog-content{padding:15px 20px;line-height:1.3em}::ng-deep .ui-dialog .ui-widget-content{border:none}::ng-deep .ui-dialog.ui-widget-content{border:none;box-shadow:0 2px 10px 0 rgba(0,0,0,.3)}::ng-deep .ui-dialog .dialog-footer-separator{border-top:1px solid #d7d7d7;height:14px}::ng-deep .ui-dialog .ui-dialog-footer{padding:0 20px 15px}"]
            }] }
];
/** @nocollapse */
DialogComponent.ctorParameters = () => [
    { type: Environment }
];
DialogComponent.propDecorators = {
    title: [{ type: Input }],
    body: [{ type: Input }],
    visibleChange: [{ type: Output }],
    modal: [{ type: Input }],
    closable: [{ type: Input }],
    appendTo: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    header: [{ type: ContentChild, args: [DialogHeaderComponent,] }],
    footer: [{ type: ContentChild, args: [DialogFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWDialogModule {
}
AWDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DialogComponent,
                    DialogHeaderComponent,
                    DialogFooterComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                    DialogModule
                ],
                entryComponents: [
                    ModalComponent,
                    DialogComponent,
                    DialogHeaderComponent,
                    DialogFooterComponent
                ],
                exports: [
                    DialogComponent,
                    DialogHeaderComponent,
                    DialogFooterComponent,
                    AWCoreComponentModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Convenient wrapper class around controls such as radiobuttons, dropdown, checkboxes,
 * Chooser. The type of the chooser may be determined dynamically based on the number of items in
 * the data source list, or can be specified explicitly via the "type" binding.
 *
 *
 *
 */
class GenericChooserComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} _viewContainer
     * @param {?} dataSource
     * @param {?} parentContainer
     */
    constructor(env, _viewContainer, dataSource, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this._viewContainer = _viewContainer;
        this.dataSource = dataSource;
        this.parentContainer = parentContainer;
        /**
         *  Is this a List property, or a to-one.
         */
        this.multiselect = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.object)) {
            this.object = (/** @type {?} */ (this._viewContainer.injector)).view.context;
        }
        this.keyPath = new FieldPath(this.key);
        /** @type {?} */
        let defaultDataProvider = null;
        if (isPresent(this.list)) {
            defaultDataProvider = this.dataSource.dataProviders.find(this.list);
        }
        else {
            defaultDataProvider = this.dataSource.dataProviders.find(this.destinationClass);
        }
        /** @type {?} */
        let projectedSize = defaultDataProvider.expectedCount(this.choiceProviderParams);
        this.initType(projectedSize);
        if (this.type === 'Chooser') {
            this.dataSource.init({
                dataProvider: defaultDataProvider,
                queryType: QueryType.FullText,
                lookupKey: this.displayKey,
                state: new ChooserState(new GCChooserState(this), this.multiselect),
                multiselect: this.multiselect
            });
        }
        else {
            // do we need to read this value in async?
            this.list = defaultDataProvider.data();
        }
        super.registerFormControl(this.selection);
        this.validateRequired();
        if (isBlank(this.selection)) {
            // this.noSelectionString = this.i18n.instant('Widgets.gchooser.noSelString');
            this.noSelectionString = 'Select a Item';
        }
    }
    /**
     *
     * When \@Input type is not passed we try to guess and select the best type for current data
     *
     * @param {?} projectedSize
     * @return {?}
     */
    initType(projectedSize) {
        if (isBlank(this.type)) {
            if (this.multiselect) {
                this.type = (projectedSize <= 0 || projectedSize > 8) ? 'Chooser' : 'Checkbox';
            }
            else {
                this.type = (projectedSize <= 0 || projectedSize > 20) ? 'Chooser'
                    : (projectedSize < 6) ? 'Radio' :
                        'Dropdown';
            }
        }
    }
    /**
     * There are certain properties which are required by this component. As already mentioned
     * above GenericChooser works with references and thefore two key properties are object and key
     * so we can access an object
     *
     *
     * @return {?}
     */
    validateRequired() {
        if (isBlank(this.object)) {
            throw Error('Cannot continue without a object');
        }
        if (isBlank(this.key)) {
            throw Error('Cannot continue without a key binding');
        }
        if (isBlank(this.list) && isBlank(this.destinationClass)) {
            throw Error('Cannot continue without having either list of values or destinationClass');
        }
        if (isPresent(this.type) &&
            (this.type !== 'Radio' && this.type !== 'Checkbox' && this.type !== 'Dropdown' &&
                this.type !== 'Chooser')) {
            throw Error('Cannot instantiate GenericChooser  - invalid type');
        }
        if (isBlank(this.displayKey)) {
            this.displayKey = 'toString';
        }
    }
    /**
     *
     * Used when displaying value both from primitive type as well complex object. If you want to
     * control how item is displayed you can provide display key, which is can be a  method or
     * property of the object you are displaying.
     *
     * Todo: think about formatters as well
     *
     * @param {?} item
     * @return {?}
     */
    displayValue(item) {
        if (isBlank(this.displayKey)) {
            return item;
        }
        /** @type {?} */
        let fieldValue = FieldPath.getFieldValue(item, this.displayKey);
        if (isFunction(fieldValue)) {
            return fieldValue.call(item);
        }
        return fieldValue;
    }
    /**
     *  Retrieve a current value from the parent/target object
     *
     * @return {?}
     */
    get selection() {
        return this.keyPath.getFieldValue(this.object);
    }
    /**
     *  set value back to the object
     *
     * @param {?} value
     * @return {?}
     */
    set selection(value) {
        this.keyPath.setFieldValue(this.object, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onSelection(value) {
        this.selection = value;
        this.formControl.setValue(this.selection);
        this.formControl.markAsDirty();
    }
}
GenericChooserComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-generic-chooser',
                template: "<ng-container [ngSwitch]=\"type\">\n\n    <ng-template [ngSwitchCase]=\"'Checkbox'\">\n        <aw-checkbox-list [list]=\"list\"\n                          [editable]=\"editable\"\n                          [selections]=\"selection\"\n                          [name]=\"name\"\n                          [disabled]=\"disabled\"\n                          [labelFormatter]=\"displayValue\"\n                          (onSelection)=\"onSelection($event)\">\n        </aw-checkbox-list>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Radio'\">\n        <aw-radiobutton-list [list]=\"list\"\n                             [selection]=\"selection\"\n                             [editable]=\"editable\"\n                             [name]=\"name\"\n                             [disabled]=\"disabled\"\n                             [labelFormatter]=\"displayValue\"\n                             (onSelection)=\"onSelection($event)\">\n        </aw-radiobutton-list>\n    </ng-template>\n\n    <ng-template [ngSwitchCase]=\"'Dropdown'\">\n        <aw-dropdown [list]=\"list\"\n                     [isStandalone]=\"false\"\n                     [editable]=\"editable\"\n                     [noSelectionString]=\"noSelectionString\"\n                     [selection]=\"selection\"\n                     [disabled]=\"disabled\"\n                     [name]=\"name\"\n                     (onSelection)=\"onSelection($event)\">\n            <ng-template #itemTemplate let-item>\n\n                <!-- todo: allow to pass a PIPE to do some additional formatting -->\n                {{ displayValue(item.value) }}\n            </ng-template>\n        </aw-dropdown>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Chooser'\">\n        <aw-chooser #chooser\n                    [editable]=\"editable\"\n                    [isStandalone]=\"false\"\n                    [name]=\"name\"\n                    [multiselect]=\"multiselect\"\n                    [dataSource]=\"dataSource\"\n                    [valueTransformer]=\"displayValue\"\n                    [disabled]=\"disabled\">\n\n        </aw-chooser>\n\n    </ng-template>\n\n</ng-container>\n",
                providers: [
                    { provide: BaseFormComponent, useExisting: forwardRef(() => GenericChooserComponent) },
                    { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                ],
                styles: [""]
            }] }
];
/** @nocollapse */
GenericChooserComponent.ctorParameters = () => [
    { type: Environment },
    { type: ViewContainerRef },
    { type: ChooserDataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
GenericChooserComponent.propDecorators = {
    list: [{ type: Input }],
    object: [{ type: Input }],
    key: [{ type: Input }],
    destinationClass: [{ type: Input }],
    choiceProviderParams: [{ type: Input }],
    multiselect: [{ type: Input }],
    type: [{ type: Input }],
    displayKey: [{ type: Input }],
    noSelectionString: [{ type: Input }]
};
/**
 * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
 *
 */
class GCChooserState extends ChooserSelectionState {
    /**
     * @param {?} gChooser
     */
    constructor(gChooser) {
        super();
        this.gChooser = gChooser;
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
        if (selected === this.isSelected(selection)) {
            return;
        }
        if (this.gChooser.multiselect) {
            /** @type {?} */
            let multiRel = this.gChooser.keyPath.getFieldValue(this.gChooser.object);
            if (isBlank(multiRel)) {
                multiRel = [];
            }
            else if (isPresent(multiRel) && !isArray(multiRel)) {
                throw new Error('I can not store multiselect value into non-array object');
            }
            if (selected) {
                multiRel.push(selection);
                this.gChooser.selection = multiRel;
            }
            else {
                ListWrapper.removeIfExist(multiRel, selection);
            }
        }
        else {
            if (!selection) {
                selection = null;
            }
            this.gChooser.selection = selection;
        }
    }
    /**
     * @return {?}
     */
    selectedObject() {
        if (this.gChooser.multiselect) {
            /** @type {?} */
            let objects = this.selectedObjects();
            return (isBlank(objects) || ListWrapper.isEmpty(objects)) ? null : ListWrapper.last(objects);
        }
        return this.gChooser.selection;
    }
    /**
     * @return {?}
     */
    selectedObjects() {
        /** @type {?} */
        let selection = this.gChooser.selection;
        if (this.gChooser.multiselect && isBlank(selection)) {
            selection = [];
        }
        return (this.gChooser.multiselect && isArray(selection)) ? selection : [selection];
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    isSelected(selection) {
        if (this.gChooser.multiselect) {
            return ListWrapper.containsComplex(this.selectedObjects(), selection);
        }
        /** @type {?} */
        let curValue = this.selectedObject();
        return equals(curValue, selection);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Wrapper class for RadioButton component providing convenient way to to render RadioButton Groups
 *
 *
 * ### Example
 *
 *
 * ```
 * \@Component({
 *          selector: 'gender-selector' ,
 *          template: `
 *              <aw-radiobutton-list [list]="rbListValues" [layout]="layout"
 *     [selection]="selectedValue" [name]="'name'">
 *               </aw-radiobutton-list>
 *      `
 *      })
 *      export class GenderSelectorComponent
 *      {
 *          rbListValues: string[] = ['male' , 'female' , 'other'];
 *          selectedValue: string = 'other';
 *          layout: string = 'stacked';
 *
 *
 *          formGroup: FormGroup = new FormGroup({});
 *
 *
 *          onCBClick (event): void
 *          {
 *              console.log('onCBClick = ' + event);
 *          }
 *
 *      }
 *
 * ```
  @type {?} */
const RB_LIST_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RadioButtonListComponent),
    multi: true
};
class RadioButtonListComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * Fires an event when radio button is selected
         *
         */
        this.onSelection = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isPresent(this.selection)) {
            this.model = 0;
        }
        this.updateModel(this.selection);
        this.onModelChanged(this.selection);
        this.registerFormControl(this.selection);
    }
    /**
     * Label is extracted into a method so in the future we can play how we want to display the
     * value. Since I want to support formatters for each components we might have a chance to
     * decide how the label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    labelValue(item) {
        if (isPresent(this.labelFormatter)) {
            return this.labelFormatter(item);
        }
        return item.toString();
    }
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     *
     *
     * @param {?} item
     * @return {?}
     */
    value(item) {
        return item;
    }
    /**
     *
     * On NGModel change retrieve actual record based on the INDEX and propagate it to both
     * ngModel as well as FormGroup.
     *
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        /** @type {?} */
        let updatedModel = this.list[this.model];
        this.onSelection.emit(updatedModel);
        this.onModelChanged(updatedModel);
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
    }
    /**
     * Since we might be dealing with complex object store only INDEX number in the model.
     *
     * @param {?} souceItem
     * @return {?}
     */
    updateModel(souceItem) {
        /** @type {?} */
        let index = this.list.findIndex((elem) => {
            return souceItem === elem;
        });
        this.model = index === -1 ? 0 : index;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        let updatedModel = this.list[this.model];
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
        // this.cd.detectChanges();
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            /** @type {?} */
            let newModel = value;
            this.updateModel(newModel);
        }
    }
}
RadioButtonListComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-radiobutton-list',
                template: "<div *ngFor=\"let item of list;  let i = index\" class=\"ui-g\">\n\n    <div class=\"ui-g-12\">\n        <aw-radiobutton\n            [(ngModel)]=\"model\"\n            (ngModelChange)=\"onChange($event)\"\n            [isStandalone]=\"false\"\n            [name]=\"name\"\n            [value]=\"i\"\n            [label]=\"labelValue(item)\">\n        </aw-radiobutton>\n    </div>\n\n</div>\n",
                providers: [
                    RB_LIST_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => RadioButtonListComponent) }
                ],
                styles: [""]
            }] }
];
/** @nocollapse */
RadioButtonListComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
RadioButtonListComponent.propDecorators = {
    list: [{ type: Input }],
    selection: [{ type: Input }],
    labelFormatter: [{ type: Input }],
    onSelection: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 *
 * Implements standard HTML radio button on top of PrimeNG with ariba styling
 *
 * ### Example
 *
 * 1. Basic usage using ngModel pre-selected first radio
 *
 *  ```ts
 *
 * \@Component({
 *          selector: 'demo-comp',
 *          template: `
 *              <aw-radiobutton [name]="'color'" [value]="'red'" [label]="'Red'"
 *                             [(ngModel)]="model">
 *             </aw-radiobutton>
 *              <aw-radiobutton [name]="'color'" [value]="'blue'" [label]="'Blue'"
 *                      [(ngModel)]="model">
 *              </aw-radiobutton>
 *      `
 *      })*
 *      class BasicWithNgModelComponent
 *      {
 *          model: string[] = ['red'];
 *
 *          constructor()
 *          {
 *          }
 *      }
 *
 *  ```
 *
 *
 * 2. Basic usage with formGroup
 *
 *
 * ```ts
 * \@Component({
 *           selector: 'demo-comp',
 *           template: `
 *          <div [formGroup]="env.currentForm">
 *               <aw-radiobutton [name]="'color2'" [value]="'red'" [label]="'Red'"
 *               (onChange)="onChange($event)">
 *               </aw-radiobutton>
 *               <aw-radiobutton [name]="'color2'" [value]="'blue'" [label]="'Blue'"
 *               (onChange)="onChange($event)">
 *               </aw-radiobutton>
 *
 *       </div>
 *       `
 *       })
 *       class BasicWithFormGroupComponent implements OnInit
 *       {
 *           model: string = 'blue';
 *
 *           constructor(public env: Environment)
 *           {
 *           }
 *
 *           ngOnInit(): void
 *           {
 *               this.env.currentForm = new FormGroup({});
 *               this.env.currentForm.registerControl('color2', new FormControl(this.model));
 *           }
 *
 *
 *           onChange(event: any): void
 *           {
 *               this.modelSet = event;
 *           }
 *
 *       }
 *  ````
 *
 *
 *
 *
  @type {?} */
const RAB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RadioButtonComponent),
    multi: true
};
class RadioButtonComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value associated with this radio
         *
         */
        this.value = '';
        /**
         * Trigger click event with currrent selected value
         *
         */
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (this.isStandalone) {
            super.registerFormControl(this.value);
            this.model = this.formControl.value;
            this.onModelChanged(this.model);
        }
        else {
            this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
        }
    }
    /**
     * Called when radio is clicked. Not using PrimeNG click event as it is fired before
     * the model is changed. Therefore need to listen on (ngModelChange)
     *
     * @param {?} newVal
     * @return {?}
     */
    onModelChange(newVal) {
        this.onModelChanged(this.model);
        if (this.isStandalone) {
            this.formControl.setValue(this.model, { emitEvent: true });
        }
        this.onChange.emit(this.model);
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.model) {
            this.model = value;
            if (this.isStandalone) {
                this.formControl.setValue(this.model, { emitEvent: true });
            }
            this.onModelChanged(this.model);
        }
    }
}
RadioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-radiobutton',
                template: "<span class=\"w-radiobutton\">\n\n    <ng-template [ngIf]=\"editable \">\n        <p-radioButton [name]=\"name\"\n                       [value]=\"value\"\n                       [label]=\"label\"\n                       [(ngModel)]=\"model\"\n                       [disabled]=\"disabled\"\n                       (ngModelChange)=\"onModelChange($event)\"\n                       [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\">\n        </p-radioButton>\n    </ng-template>\n</span>\n",
                providers: [
                    RAB_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => RadioButtonComponent) }
                ],
                styles: ["/deep/ .w-radiobutton .ui-radiobutton-box{width:23px;height:23px;line-height:23px}/deep/ .w-radiobutton .ui-radiobutton-icon{font-size:1.5em;line-height:1em}"]
            }] }
];
/** @nocollapse */
RadioButtonComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
RadioButtonComponent.propDecorators = {
    value: [{ type: Input }],
    label: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWRadioButtonModule {
}
AWRadioButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RadioButtonComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    RadioButtonModule
                ],
                entryComponents: [
                    RadioButtonComponent
                ],
                exports: [
                    RadioButtonComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWRadioButtonListModule {
}
AWRadioButtonListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RadioButtonListComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWRadioButtonModule
                ],
                entryComponents: [
                    RadioButtonListComponent
                ],
                exports: [
                    RadioButtonListComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWGenericChooserModule {
}
AWGenericChooserModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    GenericChooserComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCoreComponentModule,
                    AWDropdownModule,
                    AWCheckBoxListModule,
                    AWChooserModule,
                    AWRadioButtonListModule
                ],
                entryComponents: [
                    GenericChooserComponent
                ],
                exports: [
                    ReactiveFormsModule,
                    FormsModule,
                    GenericChooserComponent
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * OutlineState is the key gluing part for the OutlineFor and OutlineController components. It
 * holds all important information for the current outline tree and manages expansion states in form
 * of so called expansionPath and expansionStates
 *
 * We need to have a way how to work with generic data structure in order not to hold UI specific
 * information on the domain object model just like we had it before, where we had an interface
 * called OutlineNode, with fields (expanded, selected, etc.. )
 *
 *
 * `expansionPath`: Holds an array of currently selected and expanded nodes. This is filled by
 * OutlineController.
 *
 *
 * If we are dealing with Entity or anything that has identity then we have easier situation as we
 * can ask for ID and it is more efficient for serialization
 */
class OutlineState {
    constructor() {
        /**
         *
         * When outline is rendered for first time or re-rendered and we set default value for the
         * expansionStates. This way we can pretty easily execute CollapseAll, ExpandAll
         *
         */
        this.isExpandedAll = false;
        /**
         *
         * Holds current level during tree node rendering so we can apply correct indentation
         *
         */
        this.currentLevel = -1;
        this.expansionStates = new Map();
    }
    /**
     * For the collapseAll and expandAll we are using simple mechanism where we clean up all
     * selection and then set the global expand state, this whey isExpand method returns the same
     * state for all items
     * @return {?}
     */
    collapseAll() {
        if (isPresent(this.outlineFor) &&
            this.outlineFor.isTreeModelFormat()) {
            // for this case we collapse all but root nodes
            if (this.outlineFor.pushRootSectionOnNewLine) {
                this.outlineFor.list.forEach((item) => {
                    this.updateNodes(item.children || [], false);
                });
            }
            else {
                this.updateNodes(this.outlineFor.list || [], false);
            }
        }
        else {
            this.expansionStates.clear();
        }
        this.isExpandedAll = false;
    }
    /**
     * @return {?}
     */
    expandAll() {
        if (isPresent(this.outlineFor) &&
            this.outlineFor.isTreeModelFormat()) {
            this.updateNodes(this.outlineFor.list, true);
        }
        else {
            this.expansionStates.clear();
        }
        this.isExpandedAll = true;
    }
    /**
     * @return {?}
     */
    get expansionPath() {
        if (isBlank(this._expansionPath)) {
            this._expansionPath = [];
        }
        return this._expansionPath;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expansionPath(value) {
        this._expansionPath = value;
        if (isBlank(this._expansionPath)) {
            return;
        }
        this._expansionPath.forEach((item) => {
            this.setExpansionState(item, true);
        });
    }
    /**
     * @param {?} currentPath
     * @param {?=} children
     * @return {?}
     */
    toggleExpansion(currentPath, children) {
        if (isBlank(currentPath)) {
            return;
        }
        /** @type {?} */
        let item = ListWrapper.last(currentPath);
        /** @type {?} */
        let itemChildren = children || [];
        /** @type {?} */
        let newState = !this.isExpanded(item);
        this.setExpansionState(item, newState);
        if (!newState) {
            ListWrapper.removeLast(currentPath);
            this.updateNodes(itemChildren, newState);
        }
        this.setExpansionPath(currentPath);
    }
    /**
     * @param {?} nodes
     * @param {?} newState
     * @return {?}
     */
    updateNodes(nodes, newState) {
        nodes.forEach((child) => {
            /** @type {?} */
            let items = this.outlineFor.childrenForItem(child);
            if (isPresent(items) && items.length > 0) {
                this.updateNodes(items, newState);
            }
            this.setExpansionState(child, newState);
        });
    }
    /**
     * @param {?} item
     * @param {?} isExpanded
     * @return {?}
     */
    setExpansionState(item, isExpanded) {
        // Even for tree mode format save the state so we can use it later on in case object
        // references gets meesed up
        if (this.outlineFor &&
            this.outlineFor.isTreeModelFormat()) {
            (/** @type {?} */ (item)).isExpanded = isExpanded;
        }
        else {
            /** @type {?} */
            let key = this.itemToKey(item);
            if (isExpanded === this.isExpandedAll) {
                this.expansionStates.delete(key);
            }
            else {
                this.expansionStates.set(key, (isExpanded) ? true : false);
            }
        }
    }
    /**
     * To improve state persisting lets check if we are dealing with an Object that has Identity
     * so we can extract an ID otherwise use object to compare by reference
     *
     *
     * @param {?} item
     * @return {?}
     */
    itemToKey(item) {
        return isEntity(item) ? (/** @type {?} */ (item)).identity() : item;
    }
    /**
     * @param {?} items
     * @return {?}
     */
    setExpansionPath(items) {
        this.expansionPath = items;
        items.forEach((node) => {
            this.setExpansionState(node, true);
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isExpanded(item) {
        if (isPresent(this.outlineFor) &&
            this.outlineFor.isTreeModelFormat()) {
            return (/** @type {?} */ (item)).isExpanded;
        }
        else {
            /** @type {?} */
            let key = this.itemToKey(item);
            if (!this.expansionStates.has(key)) {
                return this.isExpandedAll;
            }
            return this.expansionStates.get(key);
        }
    }
}
OutlineState.decorators = [
    { type: Injectable }
];
/** @nocollapse */
OutlineState.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Checks type for OutlineNode
 *
 * @param {?} node
 * @return {?}
 */
function isOutlineNode(node) {
    return isPresent(node) && isPresent((/** @type {?} */ (node)))
        && isPresent((/** @type {?} */ (node)).parent)
        && isPresent((/** @type {?} */ (node)).children);
}
/**
 *
 * OutlineForComponent is like ngFor, but for hierarchical (outline/tree) structures -- i.e. in
 * those cases where an item may have children.
 *
 *
 * It uses outline `<aw-outline-control>` to provide expanding functionality, indentation
 * and other things.
 *
 *
 * This component has minimal styling to make sure it can be changed easily.
 *
 * ### Example rendering tree section, where based on the type we format the out plus
 * for the main root section we always render little popup menu.
 *
 * ```
 *
 *   <aw-outline-for [list]="list" [hasChildren]="hasChildren">
 *
 *       <ng-template #outline let-item>
 *
 *           <div class="my-section">
 *               <div class="outline">
 *                   <aw-outline-control>
 *                       <ng-container [ngSwitch]="item.type">
 *                           <ng-template [ngSwitchCase]="'text'">
 *                               <div class="as-paragraf">
 *                                   {{item?.content}}
 *                               </div>
 *                           </ng-template>
 *
 *
 *                           <ng-template ngSwitchDefault>
 *                               {{item?.content}}
 *                           </ng-template>
 *
 *
 *                       </ng-container>
 *
 *
 *                   </aw-outline-control>
 *               </div>
 *
 *               <div class="filters" *ngIf="item.type === 'section'" >
 *
 *                   <aw-hover-card [linkTitle]="'Filter Items'">
 *                       <aw-list [list]="filterItems" [borderless]="true"></aw-list>
 *                   </aw-hover-card>
 *
 *               </div>
 *           </div>
 *     </ng-template>`
 *   </aw-outline-for>
 *
 * ```
 *
 *
 * We can use it also in embedded mode where we use the `awOutlineFor` directive
 *
 * ## Example
 *
 *
 * ````
 *  <table  class="tree-table" >
 *      <thead>
 *          <tr>
 *              <th>Name</th>
 *              <th>Type</th>
 *          </tr>
 *      </thead>
 *      <tbody #ooo2 awOutlineFor [list]="list"
 *             [hasChildren]="hasChildren"
 *             class="outline-table"
 *      >
 *          <ng-template #outline let-item>
 *              <tr>
 *                  <td class="item-name outline-animation">
 *                      <div><aw-outline-control>
 *                          {{item?.content}}
 *                      </aw-outline-control></div>
 *                  </td>
 *                  <td class="item-type outline-animation">
 *                      <div>{{item.type}}</div>
 *                  </td>
 *              </tr>
 *          </ng-template>
 *      </tbody>
 *  </table>
 *
 * ```
 *
 * I was thinking maybe for first time we don't need the same animation like expanding and
 * collapsing. Maybe we need fade-in. In such case I would probably apply \@section anim only
 * on items where level > 0 (in the template I keep levels) and if level == 0 then I would
 * execute the same rendering just without [\@section]
 *
 *
 * Todo: Think about how to do animation for the table case. Must also write unitest - due to
 * AribaLive aggressive schedule we are skipping them for now
 *
 */
class OutlineForComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} _viewContainer
     * @param {?} builder
     * @param {?} element
     */
    constructor(env, _viewContainer, builder, element) {
        super(env);
        this.env = env;
        this._viewContainer = _viewContainer;
        this.builder = builder;
        this.element = element;
        /**
         * Tells the component not to render expansion control, in such case we expandAll as a
         * default behavior
         *
         */
        this.showExpansionControl = true;
        /**
         * Opens all tree nodes.
         *
         */
        this.expandAll = false;
        /**
         *
         * Set indentation size to be used for each level
         *
         */
        this.indentationPerLevel = 25;
        this.pushRootSectionOnNewLine = false;
        /**
         *
         * Identifies current model mode.
         *
         * We recognize two modes:
         *
         * Free - Application needs to implement a children method to retrieve a list of children for
         * each node and format is pretty much upt to the application
         *
         * Tree - this is more restrictive where we have concrete data structure
         * interface that needs to be folled
         *
         * todo: instead of passing format binding try to look into the list to see what type so
         * we dont make it mandatory
         *
         */
        this.format = 'free';
        /**
         *
         * Used when in selection mode to push current selected Item to the application
         *
         */
        this.onItemSelected = new EventEmitter();
        /**
         *
         * This event is triggered by OutlineControl when node is expanded or collapsed
         *
         */
        this.onExpandChange = new EventEmitter();
        this.embedded = false;
        /**
         * Flag that tells us that component is fully rendered
         *
         */
        this.viewInitialized = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.state)) {
            this.state = new OutlineState();
        }
        if (isBlank(this.state.outlineFor)) {
            this.state.outlineFor = this;
        }
        if (this.expandAll) {
            this.showExpansionControl = false;
        }
        this.state.isExpandedAll = this.expandAll;
        // in case we want to render content of tree outside of outlineFor
        if (isPresent(this.externalTemplate)) {
            this.controlTemplate = this.externalTemplate;
        }
        this.embedded = this.element.nativeElement.hasAttribute('awoutlinefor');
        if (isBlank(this.context)) {
            this.context = this;
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @return {?}
     */
    isTreeModelFormat() {
        return this.format === 'tree';
    }
    /**
     * Used by template and OutlineControl to identify which item is expanded and collapsed
     *
     * @param {?} item
     * @param {?=} currentLevel
     * @return {?}
     */
    isExpanded(item, currentLevel = -1) {
        if (currentLevel === 0 && this.pushRootSectionOnNewLine) {
            // always override/reset for root nodes
            if (this.isTreeModelFormat()) {
                (/** @type {?} */ (item)).isExpanded = true;
            }
            return true;
        }
        return this.state.isExpanded(item);
    }
    /**
     *
     * Since we have currently two ways how to pass children items we need have this method to
     * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
     * we expect current object to have `children` field
     *
     * @param {?} item
     * @return {?}
     */
    childrenForItem(item) {
        if (this.isTreeModelFormat()) {
            return (/** @type {?} */ (item)).children || [];
        }
        else {
            return this.hasChildren(item) ? this.doGetChildren(item) : [];
        }
    }
    /**
     *
     * Check if the current item has a children and needs to be rendered
     *
     * @param {?} item
     * @return {?}
     */
    hasChildren(item) {
        if (this.isTreeModelFormat()) {
            /** @type {?} */
            let children = (/** @type {?} */ (item)).children;
            return isPresent(children) && children.length > 0;
        }
        else if (isBlank(this.children) && isBlank(item.children)) {
            assert(false, 'Missing [children] method binding');
        }
        return this.doGetChildren(item).length > 0;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    doGetChildren(item) {
        return this.children.apply(this.context, [item]);
    }
    /**
     *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
     *  put together inside `OutlineControl` where we iterate all the way to the root and add
     *  each item to the `currentPath` array. This way we collect list of item representing current
     *  current expansionPath.
     *
     *
     * @return {?}
     */
    toggleExpansion() {
        if (this.animationInProgress) {
            // backup procedure in case onAnimationDone fails
            setTimeout(() => {
                if (this.animationInProgress) {
                    // change only if its fails
                    this.animationInProgress = false;
                }
            }, 200);
            return;
        }
        if (!this.embedded) {
            this.animationInProgress = true;
        }
        /** @type {?} */
        let currentItem = ListWrapper.last(this.state.currentPath);
        this.state.toggleExpansion(this.state.currentPath, this.childrenForItem(currentItem));
        if (this.embedded) ;
    }
    /**
     * Angular anim. callback that sets back the flag to make sure we don't trigger animations
     * when one is in progress.
     *
     * @param {?} event
     * @return {?}
     */
    onAnimationDone(event) {
        this.animationInProgress = false;
    }
    /**
     * Calculated indentation used to shift the nested section to the right or later on to the
     * left when RTL is supported
     *
     *
     * @param {?} currentLevel
     * @return {?}
     */
    indentation(currentLevel) {
        if (this.pushRootSectionOnNewLine && currentLevel > 0) {
            currentLevel -= 1;
        }
        return (currentLevel === 0 && this.pushRootSectionOnNewLine)
            ? 0 : (this.indentationPerLevel * currentLevel);
    }
    /**
     * Not all rows are visible by default, there can be a case where you dont want to render items
     * using outline. e.g. Datatable with detail row.
     * @param {?} item
     * @return {?}
     */
    isVisible(item) {
        if (isPresent(this.filterOut)) {
            return !this.filterOut(item);
        }
        return true;
    }
}
OutlineForComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-outline-for, [awOutlineFor]',
                template: "<!--\n    Starts with the list, where nestingLevel is -1.\n    call template outlineItems to iterate and render each item\n-->\n<ng-container [ngIf]=\"list\" *ngTemplateOutlet=\"outlineItems;\n            context:{ $implicit: list, nestingLevel: 0, parentItem: null, expanded: true}\">\n</ng-container>\n\n<!--\n    Main Entry point for the recursion. this is called by the block above as well as byt the inner\n    piece that calls this template recursively again when an item has children\n-->\n<ng-template #outlineItems let-children let-nestingLevel=\"nestingLevel\"\n             let-parent=\"parentItem\" let-expanded=\"expanded\">\n\n    <ng-template ngFor let-item [ngForOf]=\"children\" let-rowIndex=\"index\">\n\n        <ng-container *ngTemplateOutlet=\"outlineItem;\n            context:{ $implicit: item, nestingLevel: nestingLevel, parentItem: parent,\n            expanded: expanded, rowIndex:rowIndex}\">\n        </ng-container>\n\n        <!--\n\n            Recursion piece:\n\n            For non embedded case when even if its not expanded we need to iterate children\n            as we want to apply animation that should go with ngIf which inside the outineItem\n            template\n\n            Dont recurse/ render items that are not visible.\n        -->\n\n        <ng-template [ngIf]=\"hasChildren(item) && (isExpanded(item, nestingLevel) || !embedded) && isVisible(item)\">\n            <ng-container *ngTemplateOutlet=\"outlineItems;\n                        context:{ $implicit: childrenForItem(item),\n                                nestingLevel: nestingLevel+1,\n                                expanded: isExpanded(item, nestingLevel),\n                                parentItem:item }\">\n            </ng-container>\n        </ng-template>\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Renders actual outline node and applies animation while expanding and collapsing\n\n    [@section]=\"expanded || isExpanded(item) ? 'visible' : 'hidden'\"\n-->\n<ng-template #outlineItem let-item let-nestingLevel=\"nestingLevel\" let-parent=\"parentItem\"\n             let-rowIndex=\"rowIndex\"\n             let-expanded=\"expanded\">\n\n    <div class=\"w-outline-item\"\n         *ngIf=\"!embedded && expanded\"\n         [style.padding-left.px]=\"indentation(nestingLevel)\"\n         initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n         [setCurrrentItem]=\"item\"\n         [@section]\n         (@section.done)=\"onAnimationDone($event)\">\n\n        <ng-container *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex }\">\n        </ng-container>\n    </div>\n\n    <!--\n        When outline control is used as embedded meaning its inside e..g datatable we\n        cannot have any tags around it.\n\n        Todo: Refactor this in the way so we can do animation when table lines are\n        expanded. Since its embedded we can not have any wrapping element around, the template\n        is fully responsible\n    -->\n    <ng-template [ngIf]=\"embedded && expanded\"\n                 initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n                 [setCurrrentItem]=\"item\"\n    >\n        <ng-container #renderedItem *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex  }\">\n        </ng-container>\n    </ng-template>\n\n</ng-template>\n\n\n",
                animations: [
                    trigger('section', [
                        state('*', style({
                            'overflow-y': 'hidden',
                            'height': '*',
                            'opacity': '1'
                        })),
                        state('void', style({
                            'height': '0',
                            'opacity': '0',
                            'overflow-y': 'hidden'
                        })),
                        transition('* => void', animate('200ms ease-out')),
                        transition('void => *', animate('200ms ease-in'))
                    ]),
                ],
                styles: [".is-outline-animation>div,::ng-deep .w-outline-item{overflow:hidden}"]
            }] }
];
/** @nocollapse */
OutlineForComponent.ctorParameters = () => [
    { type: Environment },
    { type: ViewContainerRef },
    { type: AnimationBuilder },
    { type: ElementRef }
];
OutlineForComponent.propDecorators = {
    list: [{ type: Input }],
    showExpansionControl: [{ type: Input }],
    children: [{ type: Input }],
    filterOut: [{ type: Input }],
    expandAll: [{ type: Input }],
    state: [{ type: Input }],
    indentationPerLevel: [{ type: Input }],
    externalTemplate: [{ type: Input }],
    context: [{ type: Input }],
    pushRootSectionOnNewLine: [{ type: Input }],
    format: [{ type: Input }],
    onItemSelected: [{ type: Output }],
    onExpandChange: [{ type: Output }],
    controlTemplate: [{ type: ContentChild, args: ['outline',] }],
    outlineItem: [{ type: ViewChild, args: ['renderedItem',] }]
};
/**
 *
 * Since we can not directly set `*ngTemplateOutlet` context variables to the typescript class we
 * use this directive to do the Job
 *
 */
class InitNestingDirective {
    /**
     * @param {?} outline
     */
    constructor(outline) {
        this.outline = outline;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isPresent(this.setLevel)) {
            this.outline.state.currentLevel = this.setLevel;
        }
        if (isPresent(this.setCurrrentItem)) {
            this.outline.currentItem = this.setCurrrentItem;
            if (this.outline.isTreeModelFormat()) {
                this.outline.currentItem['$$parentItem']
                    = (/** @type {?} */ (this.setCurrrentItem)).parent;
            }
        }
        if (!this.outline.isTreeModelFormat() && isPresent(this.setParentItem)) {
            this.outline.currentItem['$$parentItem'] = this.setParentItem;
        }
    }
}
InitNestingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[initNesting]'
            },] }
];
/** @nocollapse */
InitNestingDirective.ctorParameters = () => [
    { type: OutlineForComponent }
];
InitNestingDirective.propDecorators = {
    setLevel: [{ type: Input }],
    setCurrrentItem: [{ type: Input }],
    setParentItem: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * OutlineControlComponent renders the indentation, arrow, and text for a node in an outline.
 * It should be used either in the body of an OutlineFor component, or inside datatable
 *
 *
 * ##Usage inside body:
 *
 *  Here you can see that we need to wrap out content inside ng-template which will push us
 *  give us current item item and then we can place OutlineControlComponent to control
 *  the tree.
 *
 * ```
 *  <aw-outline-for2 #ooo [list]="list" [hasChildren]="hasChildren">
 *
 *      <ng-template #outline let-item>
 *          <div class="my-section">
 *              <div class="outline">
 *                  <aw-outline-control>
 *                      {{item?.content}}
 *                  </aw-outline-control>
 *              </div>*
 *          </div>
 *      </ng-template>
 *  </aw-outline-for2>
 *
 *
 * ```
 *
 *
 *
 *
 */
class OutlineControlComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} outlineState
     * @param {?} parentControl
     * @param {?} outlineFor
     */
    constructor(env, outlineState, parentControl, outlineFor) {
        super(env);
        this.env = env;
        this.outlineState = outlineState;
        this.parentControl = parentControl;
        this.outlineFor = outlineFor;
        /**
         *
         *  If TRUE it changes the behavior of the outline node text which click is triggered
         *  it selects the item and broadcast the `onItemSelected` event
         *
         */
        this.allowSelection = false;
        this.allowEdit = false;
        /**
         *
         * Triggers action when outline item is expanded
         *
         */
        this.action = new EventEmitter();
        this.isRootItem = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.prepareControl();
    }
    /**
     *
     * We dont show expansion icons when there no children
     *
     * @return {?}
     */
    hasExpansionControl() {
        return this.outlineFor.hasChildren(this.item) && this.outlineFor.showExpansionControl;
    }
    /**
     * @return {?}
     */
    isSelected() {
        return this.outlineFor.state.selectedItem === this.item;
    }
    /**
     * @return {?}
     */
    calculateStyleClass() {
        if (!this.hasExpansionControl() ||
            (this.outlineFor.pushRootSectionOnNewLine && isBlank(this.item.$$parentItem))) {
            return '';
        }
        if (this.outlineFor.embedded) {
            return this.outlineFor.isExpanded(this.item) ? 'icon-slim-arrow-down'
                : 'icon-slim-arrow-right';
        }
        else {
            return this.outlineFor.isExpanded(this.item)
                ? 'icon-slim-arrow-right outline-icon-expanded' : 'icon-slim-arrow-right';
        }
    }
    /**
     * Collapses and expands current node
     *
     * @param {?} event
     * @return {?}
     */
    toggleExpansion(event) {
        this.outlineFor.state.currentPath = [];
        /** @type {?} */
        let currentPath = this.item;
        while (isPresent(currentPath)) {
            this.outlineFor.state.currentPath.unshift(currentPath);
            currentPath = currentPath.$$parentItem;
        }
        this.outlineFor.toggleExpansion();
        /** @type {?} */
        let payload = {
            item: this.item,
            expanded: this.outlineFor.state.isExpanded(this.item)
        };
        this.action.emit(payload);
        this.outlineFor.onExpandChange.emit(payload);
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    select() {
        this.outlineFor.state.selectedItem = this.item;
        this.outlineFor.onItemSelected.emit(this.item);
    }
    /**
     * @return {?}
     */
    prepareControl() {
        if (isBlank(this.outlineFor) && isPresent(this.outlineState)) {
            this.outlineFor = this.outlineState.outlineFor;
        }
        assert(isPresent(this.outlineFor), 'Missing outlineFor component');
        if (this.outlineFor.embedded) {
            /** @type {?} */
            let level = this.outlineFor.state.currentLevel;
            if (this.outlineFor.pushRootSectionOnNewLine && level > 0) {
                level -= 1;
            }
            this.indentation = (this.outlineFor.indentationPerLevel * level);
        }
        this.item = this.outlineFor.currentItem;
        this.isRootItem = isBlank(this.item.$$parentItem);
    }
}
OutlineControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-outline-control',
                template: "<!--\n    Control is just the two flex box items for displaying expand/collapse icon and content\n\n    Since we animate only standalone/non-embedded case now then we need to also animate the icon\n    so we use only icon-slim-arrow-right and do tranformation on top of this to make it rotate.\n\n    If embedded case we use both icons icon-slim-arrow-right / icon-slim-arrow-down\n-->\n<div class=\"w-outline-control\"\n     [ngClass]=\"{'outline-u-unselectable-text': outlineFor.pushRootSectionOnNewLine && !item.$$parentItem}\">\n    <div class=\"outline-icon sap-icon\"\n         *ngIf=\"!outlineFor.pushRootSectionOnNewLine || !isRootItem\"\n         (click)=\"toggleExpansion($event)\"\n         [style.margin-left.px]=\"indentation\"\n         [ngClass]=\"calculateStyleClass()\">\n    </div>\n\n    <ng-container *ngIf=\"allowSelection; then withSelection else withoutSelection\">\n    </ng-container>\n</div>\n\n<!--\n We support two case for the content\n\n Selection: When you click on the content it will add extra class so you can style currently\n selected item as well as broadcast event outside so developer can hook in some custom logic\n\n If we dont support selection: Then clicking on the content is just like clicking on expandable\n icon, it toggles the state\n-->\n\n<ng-template #withSelection>\n     <span class=\"outline-content outline-content-selected\" *ngIf=\"!allowEdit && isSelected()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span class=\"outline-content\" *ngIf=\"!allowEdit && !isSelected()\" (click)=\"select()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n\n</ng-template>\n\n\n<ng-template #withoutSelection>\n    <span *ngIf=\"!allowEdit\" class=\"outline-content\" (click)=\"toggleExpansion($event)\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span *ngIf=\"allowEdit\" class=\"outline-content\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n</ng-template>\n\n\n<ng-template #ngContent>\n    <ng-content></ng-content>\n</ng-template>\n\n",
                styles: [".w-outline-control{overflow:hidden;display:flex;flex-wrap:nowrap;cursor:pointer}.w-outline-control .outline-icon{flex:0 0 15px;color:#ababab;font-size:14px;font-weight:700;min-width:11px;-ms-grid-row-align:center;align-self:center;transition:transform 50ms ease-in;transition:transform 50ms ease-in,-webkit-transform 50ms ease-in;-webkit-transform-origin:25% 65%;transform-origin:25% 65%;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.w-outline-control .outline-icon.outline-icon-expanded{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.w-outline-control .outline-content{flex:1 1 auto;flex-wrap:wrap;padding:0 4px}.w-outline-control .outline-content.outline-content-selected{cursor:default;font-weight:700}.outline-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;cursor:auto}"]
            }] }
];
/** @nocollapse */
OutlineControlComponent.ctorParameters = () => [
    { type: Environment },
    { type: OutlineState, decorators: [{ type: Optional }, { type: Inject, args: [forwardRef(() => OutlineState),] }] },
    { type: OutlineControlComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => OutlineControlComponent),] }] },
    { type: OutlineForComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => OutlineForComponent),] }] }
];
OutlineControlComponent.propDecorators = {
    allowSelection: [{ type: Input }],
    allowEdit: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWOutlineForModule {
}
AWOutlineForModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    OutlineForComponent,
                    OutlineControlComponent,
                    InitNestingDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCoreComponentModule
                ],
                exports: [
                    OutlineForComponent,
                    OutlineControlComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Renders html text area component
 *
 * ### Example
 *
 * ```typescript
 *
 * \@Component({
 *          selector: 'myNote' ,
 *          template: '<aw-text-area [value]="inputValue" [autoResize]="autoResize" >
 *              </aw-text-area>'
 *      })
 *      export class MyNoteComponent
 *      {
 *          inputValue: string = 'Some really long text';
 *          autoResize: false;
 *      }
 *
 * ```
 *  Note: if you are using this outside of FormTable please provide your own FormGroup
  @type {?} */
const TEXTAREA_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TextAreaComponent),
    multi: true
};
class TextAreaComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value used to store and read user input
         *
         */
        this.value = '';
        /**
         * Spefifies visible number of lines
         */
        this.rows = 2;
        /**
         * Specifies visible width
         */
        this.columns = 20;
        /**
         * when this option is TRUE and user starts typing it will maximize textarea's width and height
         */
        this.autoResize = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.value);
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(val => {
            this.value = val;
            this.onModelChanged(this.value);
        });
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value, { onlySelf: true });
        }
    }
}
TextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-text-area',
                template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\">\n\n\t<textarea\n        pInputTextarea\n        [attr.name]=\"name\"\n        class=\"w-text-area\"\n        [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        [class.disabled]=\"disabled\"\n        formControlName=\"{{name}}\"\n        [rows]=\"rows\"\n        [cols]=\"columns\"\n        [autoResize]=\"autoResize\"\n        [attr.placeholder]=\"placeHolder\"\n\n    ></textarea>\n\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                providers: [
                    TEXTAREA_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => TextAreaComponent) }
                ],
                styles: [""]
            }] }
];
/** @nocollapse */
TextAreaComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
TextAreaComponent.propDecorators = {
    value: [{ type: Input }],
    rows: [{ type: Input }],
    columns: [{ type: Input }],
    autoResize: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWTextAreaModule {
}
AWTextAreaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    TextAreaComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextareaModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    TextAreaComponent
                ],
                exports: [
                    TextAreaComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Page-Notification component that implements a notification system for the user regarding
 * the current object he's working on. Typical notification are:
 *      Success - saved.
 *      Warning - Sourcing request requires 3 suppliers.
 *      Error   - cannot connect to server, check internet connection.
 *
 *
 *
 * Usage 1:  As part of page wrapper.
 *
 * \@Component({
 *    selector: 'MyPage' ,
 *    template: `
 *       <aw-object-page-wrapper
 *                        [title]="MyPage"
 *                        [objectType]="MyType"
 *                        [notification]="pageNotification">
 *             page content
 *          `
 *       </aw-object-pager-wrapper>
 *    })
 *    export class MyPage
 *    {
 *
 *        pageNotification: PageNotification = new PageNotification("warn",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *    }
 *
 * Usage 2: directly into the page.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *      <aw-header></aw-header>
 *        Page Header
 *
 *        <ng-template [ngIf]="hasNotifications()">
 *          <div class="ui-g-12 u-nopadding">
 *            <aw-page-notification [notification]="notification"></aw-page-notification>
 *          </div>
 *        </ng-template>
 *
 *      <aw-footer></aw-footer>
 *    `
 *    })
 *    export class MyPage
 *    {
 *
 *        notification: PageNotification = new PageNotification("warning",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *    }
 *
 */
class PageNotificationComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
    /**
     * @return {?}
     */
    notificationClass() {
        return `notification-${this.notification.type}`;
    }
    /**
     * @return {?}
     */
    notificationIcon() {
        return `ariba-icon icon-${this.notification.type}`;
    }
}
PageNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-notification',
                template: "<div class=\"page-notification\">\n    <div [class]=\"notificationClass()\">\n        <i [class]=\"notificationIcon()\"></i>\n        <span class=\"content\">\n              <span class=\"title\">{{notification.title}}</span>\n              <span class=\"description\">\n                    <ng-template *ngIf=\"notification.hasTemplate(); else description\"\n                                 [ngTemplateOutlet]=\"notification.contentTmpl\">\n                    </ng-template>\n                    <ng-template #description>{{notification.description}}</ng-template>\n              </span>\n      </span>\n    </div>\n</div>\n",
                styles: [".page-notification{margin:0 0 5px}.notification-error,.notification-info,.notification-success,.notification-warning{padding:9px 8px}.notification-error i,.notification-info i,.notification-success i,.notification-warning i{font-size:24px;margin:10px}.notification-success i{color:#58b957}.notification-info i{color:#199de0}.notification-warning i{color:#f90}.notification-error i{color:#c00}.notification-success{background-color:#f1f9f1;border:1px solid rgba(88,185,87,.5)}.notification-info{background-color:#edf8fd;border:1px solid rgba(25,157,224,.5)}.notification-warning{background-color:#fff8dd;border:1px solid rgba(255,153,0,.5)}.notification-error{background-color:#ffebeb;border:1px solid rgba(204,0,0,.5)}.icon-error:before{content:\"\\EA9D\"}.icon-warning:before{content:\"\\EA9C\"}.content{vertical-align:super}.title{font-weight:700;margin-right:10px}"]
            }] }
];
/** @nocollapse */
PageNotificationComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
PageNotificationComponent.propDecorators = {
    notification: [{ type: Input }]
};
/**
 * Page Notification are messages for this page only. It displays in the center of the page
 * right under page title. Typical page notifications are 'save confirmation',
 * 'error during submit', warnings of field requirements, etc.
 */
class PageNotification {
    /**
     * @param {?} type
     * @param {?} title
     * @param {?} description
     * @param {?=} contentTmpl
     */
    constructor(type, title, description, contentTmpl) {
        this.type = type;
        this.title = title;
        this.description = description;
        this.contentTmpl = contentTmpl;
    }
    /**
     * @return {?}
     */
    hasTemplate() {
        return isPresent(this.contentTmpl);
    }
    /**
     * @return {?}
     */
    toString() {
        return this.type + ', title: ' + this.title + ', description:  ' + this.description;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWPageNotificationModule {
}
AWPageNotificationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PageNotificationComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    PageNotificationComponent
                ],
                exports: [
                    PageNotificationComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Represents an event triggered when a page has been initialized.
 *
 */
class PageInitialized {
    /**
     * @param {?} title
     */
    constructor(title) {
        this.title = title;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageInitializied(title: ${this.title})`;
    }
}
/**
 * Represents an event triggered when a page has been destroyed.
 *
 */
class PageDestroyed {
    /**
     * @param {?} title
     */
    constructor(title) {
        this.title = title;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageDestroyed(title: ${this.title})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Page LifeCycle Service monitors all page initialization and destructions.
 * The purpose of this service is to help the application monitor page lifecycle, subscribe
 * to lifecycle events and execute actions such as user analytics.
 *
 * Usage:
 *
 *    1.  Inject PageLifeCycleService into your constructor
 *
 *    constructor(pageLifecycle:PageLifeCycleService) {
 *        pageLifecycle.pageEvents.subscribe(event:Event => {
 *            if(event instanceof PageInitialized) {
 *            }
 *            // PageDestroyed
 *
 *        });
 *     }
 */
class PageLifeCycleService {
    /**
     *
     */
    constructor() {
        /**
         * Page event queue when all page lifecycle events: init, destroy are emitted.
         * Listeners can subscribe to these events.
         */
        this.pageEvents = new Subject();
    }
    /**
     * Called when page is initialized.
     * @param {?} pageTitle
     * @return {?}
     */
    onPageInit(pageTitle) {
        this.pageEvents.next(new PageInitialized(pageTitle));
    }
    /**
     * Call when page has been destroyed
     * @param {?} pageTitle
     * @return {?}
     */
    onPageDestroy(pageTitle) {
        this.pageEvents.next(new PageDestroyed(pageTitle));
    }
}
PageLifeCycleService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
PageLifeCycleService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const PageType = {
    Init: 0,
    // Init Page type
    Login: 1,
    // Login Page
    Object: 2,
    // Object detail page
    List: 3,
    // List Page
    MasterDetail: 4,
    // MasterDetail
    Dashboard: 5,
    // Dashboard page
    Modal: 6 // Modal page, it can be configured to be a popup, or standalone page.
    ,
};
PageType[PageType.Init] = 'Init';
PageType[PageType.Login] = 'Login';
PageType[PageType.Object] = 'Object';
PageType[PageType.List] = 'List';
PageType[PageType.MasterDetail] = 'MasterDetail';
PageType[PageType.Dashboard] = 'Dashboard';
PageType[PageType.Modal] = 'Modal';
/**
 *  Page wrapper is the base class for all pages. The idea is that there are different page types
 *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
 *  a object page will render one object in detail.
 *
 *  They share common attributes such as page type and page id.
 *
 *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
 *  destroyed, it'll be complete.
 * @abstract
 */
class PageWrapper extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} pageType
     * @param {?} componentRegistry
     * @param {?} pageLifecycleService
     */
    constructor(env, pageType, componentRegistry, pageLifecycleService) {
        super(env);
        this.env = env;
        this.componentRegistry = componentRegistry;
        this.pageLifecycleService = pageLifecycleService;
        /**
         * What type of page this is.
         *
         */
        this.pageType = PageType.Init;
        this.pageType = pageType;
    }
    /**
     * Get the unique Id for this page.
     *
     * @return {?}
     */
    getId() {
        if (this.id) {
            return this.id;
        }
        this.id = this.generatePageId();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *  This is a temporary implementation for the page header component.
 *  When the real implementation of side menu is done, PageHeaderComponent will
 *  be swaped to use it.
 *
 */
class SidenavComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
    /**
     * @return {?}
     */
    getSidenavClass() {
        // Only show if I have items
        return (this.show && this.items) ? 'sidenav sidenav-active' : 'sidenav';
    }
    /**
     * @return {?}
     */
    open() {
        this.show = true;
    }
    /**
     * @return {?}
     */
    close() {
        this.show = false;
    }
    /**
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
    }
}
SidenavComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-sidenav',
                template: "<div [ngClass]=\"getSidenavClass()\">\n    <div class=\"sidenav-content\">\n        <a *ngFor=\"let item of items\" [routerLink]=\"item.link\">\n            <span class=\"sidenav-icon\"><i [ngClass]=\"'sap-icon ' + item.icon\"></i></span>\n            {{item.label}}\n        </a>\n    </div>\n</div>\n",
                styles: [".sidenav{height:100%;width:0;position:fixed;z-index:1;top:50px;left:0;background-color:#363636;overflow-x:hidden;padding-top:20px;transition:.5s}.sidenav-active{width:250px}.sidenav a{padding:8px 8px 8px 32px;text-decoration:none;font-size:16px;color:#fff;display:block;transition:.3s}.sidenav a:hover{background-color:#111}.sidenav-icon{font-size:30px;color:#ccc;margin-right:10px}"]
            }] }
];
/** @nocollapse */
SidenavComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
SidenavComponent.propDecorators = {
    items: [{ type: Input }],
    show: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Header component that implements consistent styling, behavior for an Ariba page.
 * Header includes a menu, user profile, and alerts.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *                <aw-page-header [showBackAction]="true" userName="Chad Noll"
 *                                 [menuItems]="menuItems" [notifications]="userNotifications">
 *                     <div class="page-header-center">
 *                           <a class="navbar-brand" tabindex="0" href="/">
 *                               <img class="navbar-logo" src="./images/SAP_Ariba_DB.png"
 *                                   alt="Go to homepage" data-pin-nopin="true">
 *                          </a>
 *                     </div>
 *                </aw-page-header>
 *
 *    `
 *    })
 *    export class MyPage
 *    {
 *      menuItems: PageMenuItem[] = [new PageMenuItem('icon-home', 'Home', '/play/'),
 *                                  new PageMenuItem('icon-expense-report', 'Reports',
 *                                                     '/play/pageheader'),
 *                                  new PageMenuItem('icon-sales-order', 'Purchase Order',
 *                                                       '/play/pageheader'),
 *                                  new PageMenuItem('icon-account', 'Accounts',
 *                                                     '/play/pageheader')];
 *
 *     userNotifications: UserNotification[] = [
 *       new UserNotification('icon-expense-report', 'Expense report EXP453 has been approved.',
 *                             '/play/'),
 *         new UserNotification('icon-sales-order', 'Sales Order SO1234 has been created.',
 *                             '/play/'),
 *           new UserNotification('icon-account', 'Supplier account SA1234 has been updated.',
 *                               '/play/')
 *        ];
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
class PageHeaderComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     * @param {?} routing
     */
    constructor(element, env, routing) {
        super(env);
        this.element = element;
        this.env = env;
        this.routing = routing;
        /**
         * Should the user notification icon be hidden. Default it to show the icon even
         * if there's no notifications.
         *
         */
        this.hideNotification = false;
        /**
         * displays the back link that navigates user to the previous page when clicked.
         */
        this.showBackAction = false;
        this.showNotificationPanel = false;
    }
    /**
     * @return {?}
     */
    backAction() {
        this.routing.goBack();
    }
    /**
     * Do i have any menu items.
     *
     * @return {?}
     */
    hasMenuItems() {
        return (this.menuItems && this.menuItems.length > 0);
    }
    /**
     * Toggle the side navigation menu.
     * @return {?}
     */
    showHideMenu() {
        this.sidenav.toggle();
    }
    /**
     * Do I have any notifications.
     *
     * @return {?}
     */
    hasNotifications() {
        return isPresent(this.notifications) && this.notifications.length > 0;
    }
    /**
     * toggling wheather notification panel is displayed or not.
     * @return {?}
     */
    toggleNotificationPanel() {
        this.showNotificationPanel = !this.showNotificationPanel;
    }
}
PageHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-header',
                template: "<nav class=\"navbar page-header\" role=\"navigation\">\n\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-4 navbar-left\">\n\n        <span *ngIf=\"hasMenuItems()\">\n            <a (click)=\"showHideMenu()\">\n                <i class=\"sap-icon icon-paging\"></i>\n            </a>\n\n            <!-- Side menu -->\n            <aw-sidenav #sidemenu [items]=\"menuItems\"></aw-sidenav>\n        </span>\n            <!-- End Hamburger menu. -->\n\n            <!--  back action -->\n            <span class=\"back-action\">\n            <a (click)=\"backAction()\">\n                <i *ngIf=\"showBackAction\" class=\"sap-icon icon-arrow-left\" role=\"button\"></i>\n            </a>\n        </span>\n\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-center\">\n\n            <!-- central section.  Application can add Ariba-logo, search box, etc -->\n            <ng-content select=\".page-header-center\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-right\">\n        <span *ngIf=\"userName\">\n            <img id=\"userProfilePicture\" class=\"profile-logo\" aria-hidden=\"true\"\n                 [title]=\"userName\" src=\"{{assetFolder}}/images/default_image_small.png\">\n            <span class=\"profile-user\" title=\"{{userName}}\">{{userName}}</span>\n        </span>\n\n            <span *ngIf=\"!hideNotification\" class=\"notification-container\">\n\n            <i #notificationIcon class=\"ariba-icon icon-notification\"\n               (click)=\"toggleNotificationPanel()\"></i>\n            <span *ngIf=\"hasNotifications()\" class=\"notification-badge\" aria-hidden=\"true\">{{notifications.length}}</span>\n\n                <!-- Originally I was using p-overlay-panel, however, it doesn't position correctly under the notification icon.\n                     The positioning logic in prime ng needs some more investigation. So for now, use a div instead-->\n            <div *ngIf=\"showNotificationPanel\" class=\"notification-panel\">\n\n                <div class=\"notification-header\">\n                     Notifications\n                </div>\n\n                <ul class=\"notification-content\">\n                    <li *ngFor=\"let noti of notifications\" class=\"notification-item\">\n                        <a [routerLink]=\"noti.link\">\n                            <span class=\"notification-item-icon\"><i\n                                [ngClass]=\"'sap-icon ' + noti.icon\"></i></span>\n                            {{noti.label}}\n                        </a>\n                    </li>\n                </ul>\n            </div>\n        </span>\n        </div>\n\n\n    </div>\n</nav>\n",
                styles: [".page-header i{font-size:32px}.page-header .icon-paging{font-size:30px;position:relative;top:2px}.back-action{display:inline-block;margin-left:15px}.back-action i{position:relative;top:3px}.navbar{background:#000;color:#fff}.navbar-left{padding-left:15px;height:50px}.navbar-center{text-align:center;height:50px}.navbar-right{text-align:right;height:50px}.profile-logo{width:30px;height:30px;position:relative;top:2px}.profile-user{vertical-align:super;margin-right:30px}.icon-notification:before{content:\"\\eA14\"}.navbar #sidebar-menu-icon{position:relative;top:.5em}.notification-container{position:relative;margin-right:20px;display:inline-block}.notification-badge{display:inline-block;padding:2px 5px;font-size:12px;font-weight:700;color:#fff;background-color:#c00;border-radius:10px;position:absolute;top:0;left:16px}.notification-panel{position:absolute;right:-27px;top:45px;width:350px;color:#767676;box-shadow:0 2px 10px 0 rgba(0,0,0,.13);background-color:#fff;overflow:hidden;transition:.3s ease-in-out}.notification-panel .notification-header{background-color:#f3f3f3;font-size:16px;height:50px;line-height:50px;text-align:center}.notification-panel .notification-content{padding:0;margin:0}.notification-panel .notification-item{height:50px;border-top:1px solid #d7d7d7;padding:15px 10px;white-space:nowrap;text-overflow:ellipsis}.notification-panel .notification-item a{color:#767676;text-decoration:none;line-height:35px}.notification-panel .notification-item:hover{background-color:#f7f8fa}.notification-panel .notification-item-icon{margin-right:15px;color:#767676;display:inline-block;margin-top:10px;vertical-align:middle}"]
            }] }
];
/** @nocollapse */
PageHeaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment },
    { type: RoutingService }
];
PageHeaderComponent.propDecorators = {
    menuItems: [{ type: Input }],
    notifications: [{ type: Input }],
    hideNotification: [{ type: Input }],
    showBackAction: [{ type: Input }],
    userName: [{ type: Input }],
    sidenav: [{ type: ViewChild, args: ['sidemenu',] }]
};
/**
 * PageMenuItem represents an item in the page menu structure.
 */
class PageMenuItem {
    /**
     * @param {?} icon    - Icon of this menu item.
     * @param {?} label   - label of this item.
     * @param {?} link    - link to the destination when user clicks on it.
     */
    constructor(icon, label, link) {
        this.icon = icon;
        this.label = label;
        this.link = link;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageMenuItem: (label, ${this.label})`;
    }
}
/**
 * notification for the current logged in user.
 * Ex:  PR2049 has been approved.
 *      Order PO518 received.
 */
class UserNotification {
    /**
     * @param {?} icon   - alert notification icon
     * @param {?} label  - alert notification label
     * @param {?} link   - link
     */
    constructor(icon, label, link) {
        this.icon = icon;
        this.label = label;
        this.link = link;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageUserNotification: (label, ${this.label})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Footer component that implements consistent styling, behavior.
 * This footer component self contained.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *          <aw-page-footer>
 *               <div class="page-footer-logo">
 *                   <img src="images/ariba_logo_white_bkgd.png">
 *               </div>
 *               <div class="page-footer-user-info">
 *                   Chad Noll (cnoll) last visit {{last_visited | date:'MM/dd/yyyy h:mma' }}
 *                   | Buyer Organization
 *               </div>
 *               <span class="page-footer-copyright" #copyright>
 *                   <p>© 2020–2028 The Future, Inc. All rights reserved</p>
 *               </span>
 *           </aw-page-footer>
 *    `
 *    })
 *    export class MyPage
 *    {
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
class PageFooterComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
        /**
         * show default copyright. If copyright is passed in, then show the passed in one.
         */
        this.showDefaultCopyright = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.showDefaultCopyright = !isPresent(this.copyright);
    }
}
PageFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-footer',
                template: "<div class=\"page-footer\">\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-8\">\n\n            <ng-content select=\".page-footer-logo\"></ng-content>\n\n            <div class=\"user-info\">\n                <ng-content select=\".page-footer-user-info\"></ng-content>\n            </div>\n\n            <ul class=\"footer-links\">\n                <li role=\"presentation\"><a href=\"http://www.ariba.com/legal/ariba_tou.cfm\">Terms of\n                    Use</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_security_policy.cfm\">Security\n                    Disclosure</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_privacy_statement.cfm\">Privacy\n                    Statement</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Cookie Statement</a>\n                </li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Participant\n                    Statement</a></li>\n            </ul>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4\">\n            <div class=\"u-bottom-align\"></div>\n            <div class=\"u-hright copyright\">\n                <ng-content select=\".page-footer-copyright\"></ng-content>\n            </div>\n\n            <!-- Default Copyright -->\n            <div *ngIf=\"showDefaultCopyright\" class=\"u-hright copyright\">\n                <p>\u00A9 1996\u20132017 Ariba, Inc. All rights reserved</p>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                styles: [".page-footer{background:#fff;padding:15px 0 0;font-size:11px;border-top:1px solid #d7d7d7}.page-footer .user-info{color:#ccc}.page-footer .ui-g{margin:0 auto}.page-footer .copyright{color:#ccc}.footer-links{list-style:none;margin:0 -15px;padding:0;font-size:10px}.footer-links li{float:left}.footer-links:after,.footer-links:before{content:\" \";display:table}.footer-links:after{clear:both}.footer-links>li,.footer-links>li>a{position:relative;display:block}.footer-links>li>a{padding:10px 15px;color:#199de0}"]
            }] }
];
/** @nocollapse */
PageFooterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
PageFooterComponent.propDecorators = {
    copyright: [{ type: ContentChild, args: ['copyright',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Object Page Wrapper Component renders any object instance in detail. It has a uniform layout,
 * Header, Page title, Page notification, actions, content, and Footer.
 *
 *
 *  Usage:
 *
 * \@Component({
 *    selector: 'RFXPage' ,
 *    template: `
 *       <aw-object-page-wrapper
 *                        [title]="rfxEntity.headerInfo.title"
 *                        [objectType]="rfxEntity.headerInfo.eventTypeString"
 *                        [notification]="pageNotification">
 *
 *
 *           <aw-page-actions>
 *               <aw-button [type]="'submit'" [name]="'edit'" [value]="edit" [style]="'primary'">
 *                   Edit
 *                </aw-button>
 *               <aw-button [type]="'button'" [name]="'cancel'" [value]="cancel"
 *                                                         [style]="'secondary'">
 *                  Cancel
 *               </aw-button>
 *           </aw-page-actions>
 *
 *           <aw-page-content>
 *             <aw-section title="Sourcing request info" (onStateChanged)="onStateChange($event)">
 *
 *                   <m-context [object]="rfxEntity.headerInfo"
 *                              [operation]="this.editabilityState.headerInfoOp"
 *                              layout="Inspect"
 *                              uiGroup="HeaderGeneral"
 *                   >
 *                       <m-include-component></m-include-component>
 *                   </m-context>
 *
 *             </aw-section>
 *           </aw-page-content>
 *       </aw-object-page-wrapper>
 *    `
 *    })
 *    export class RFXPage
 *    {
 *       // To keep track what section is editable and which read only
 *       editabilityState: EditabilityState;
 *
 *       // Current RFX event
 *       rfxEntity: RfxEventEntity;
 *
 *       // Notifications
 *       notification: PageNotification = new PageNotification("warn",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
class ObjectPageWrapperComponent extends PageWrapper {
    /**
     * @param {?} element
     * @param {?} env
     * @param {?} componentRegistry
     * @param {?} pageLifecycleService
     */
    constructor(element, env, componentRegistry, pageLifecycleService) {
        super(env, PageType.Object, componentRegistry, pageLifecycleService);
        this.element = element;
        this.env = env;
        /**
         * Set true if page should not include any header. Need to set to true even no header
         * object is passed in. Otherwise, a default Header component will be added.
         */
        this.hideHeader = false;
        /**
         * Set true if page should not include any footer. Need to set to true even no footer
         * object is passed in. Otherwise, a default Footer component will be added.
         */
        this.hideFooter = false;
        /**
         * The positioning of the page actions (page buttons)
         *   'top' :    page buttons are placed at the top of the page, below the title, to the right.
         *   'bottom' : page buttons are placed at the bottom of the page, above the footer.
         *   'both'   : page buttons are placed at both top and bottom.
         *
         */
        this.pageActionPosition = 'top';
        /**
         * This flag is driven by pageActionPosition. The default position is top.
         * Value is true for both 'top' and 'both' of pageActionPosition.
         */
        this.hasTopPageActions = true;
        this.objectStateIndex = 0;
        // Setting Default header component
        this.header = PageHeaderComponent;
        this.footer = PageFooterComponent;
    }
    /**
     * Generate a unique Id for this object.
     *
     * @return {?}
     */
    generatePageId() {
        return this.objectType + '_' + this.title + (this.id) ? ('_' + this.id) : '';
    }
    /**
     * Does my page have page notification?
     *
     * @return {?}
     */
    hasNotifications() {
        return (this.notifications && this.notifications.length > 0);
    }
    /**
     * @return {?}
     */
    hasObjectStates() {
        return isPresent(this.objectStates);
    }
    /**
     * Initialize my local components
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // New Component types that are used in c-include-component
        if (this.header) {
            this.componentRegistry.registerType(this.header.name, this.header);
        }
        // New Component types that are used in c-include-component
        if (this.footer) {
            this.componentRegistry.registerType(this.footer.name, this.footer);
        }
        /** notify subscribers of the page lifecycle service  */
        this.pageLifecycleService.onPageInit(this.title);
        // Setting the page action position.
        if (this.pageActionPosition === 'bottom') {
            this.hasTopPageActions = false;
            this.hasBottomPageActions = true;
        }
        else if (this.pageActionPosition === 'both') {
            this.hasTopPageActions = true;
            this.hasBottomPageActions = true;
        }
        if (isPresent(this.objectStates) && this.objectStates.length > 1
            && isPresent(this.currentState)) {
            this.objectStateIndex = this.objectStates.indexOf(this.currentState);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (isPresent(changes['currentState']) &&
            changes['currentState'].currentValue !== changes['currentState'].previousValue) {
            // we dont need to check if objectStates exists
            this.objectStateIndex = this.objectStates.indexOf(this.currentState);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.pageLifecycleService.onPageDestroy(this.title);
    }
}
ObjectPageWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-object-page-wrapper',
                template: "<div class=\"page-wrapper\">\n    <ng-template [ngIf]=\"!hideHeader\">\n        <aw-include-component [name]='header.name'></aw-include-component>\n    </ng-template>\n\n    <div class=\"arc-object-detail\">\n\n        <div class=\"ui-g\">\n\n            <!-- page header -->\n            <div class=\"ui-g-12 page-title\">\n\n                <!-- page title -->\n                <div class=\"ui-g-8 ui-md-8 page-title-text\">{{title}}</div>\n\n                <div class=\"ui-g-4 ui-md-4 page-status\">\n                    <span class=\"object-status-label\">{{objectStatusLabel}} &nbsp;</span>\n                    <span class=\"object-status\">{{objectStatus}}</span>\n                </div>\n            </div>\n\n            <!-- page actions -->\n            <div class=\"ui-g-12 page-actions\" *ngIf=\"hasTopPageActions\">\n                <ng-template [embeddedItem]=\"actionsTemplate\"\n                             *ngIf=\"hasTopPageActions\"></ng-template>\n            </div>\n\n            <!-- object states  displays only if state exists. -->\n            <div class=\"ui-g-12 page-state\">\n                <div class=\"ui-g-3 page-state-left\" [class.content]=\"hasObjectStates()\">\n                    <ng-content select=\".page-state-left\"></ng-content>\n                </div>\n                <div class=\"ui-g-6 page-state-center\">\n                    <ng-container *ngIf=\"hasObjectStates()\">\n                        <aw-stepper [steps]=\"objectStates\"\n                                    [currentStep]=\"objectStateIndex\"></aw-stepper>\n                    </ng-container>\n                </div>\n                <div class=\"ui-g-3 page-state-right\">\n                    <ng-content select=\".page-state-right\"></ng-content>\n                </div>\n            </div>\n\n\n            <!-- Page Notification -->\n            <ng-template [ngIf]=\"hasNotifications()\">\n                <div class=\"ui-g-12 u-nopadding\">\n\n                    <aw-page-notification *ngFor=\"let notification of notifications\"\n                                          [notification]=\"notification\"></aw-page-notification>\n                </div>\n            </ng-template>\n\n            <!-- additional content -->\n            <ng-content select=\"aw-page-content\"></ng-content>\n\n        </div>\n\n    </div>\n\n    <!-- page actions -->\n    <div class=\"ui-g-12 page-actions-bottom\" *ngIf=\"hasBottomPageActions\">\n        <ng-template [embeddedItem]=\"actionsTemplate\"\n                     *ngIf=\"hasBottomPageActions\"></ng-template>\n\n    </div>\n\n    <div class=\"page-push\"></div>\n</div>\n\n<ng-template [ngIf]=\"!hideFooter\">\n    <aw-include-component [name]='footer.name'></aw-include-component>\n</ng-template>\n",
                styles: [".page-wrapper{background-color:#f2f2f2;min-height:100%;margin-bottom:-100px}.arc-object-detail{padding:20px}.page-title-text{font-size:22px;color:#000;padding:14px 0}.page-title{padding:5px 0;border-bottom:1px solid #d7d7d7}.page-actions{padding:15px 0 5px}.page-actions-bottom{padding:0 20px}.page-state,.page-state-center,.page-state-left,.page-state-right{padding:0}.content::after{content:'\\x000a0';font-size:0}.page-title /deep/ .ui-button{min-width:100px}.page-status{text-align:right;padding:18px 0}.page-status .object-status-label{color:#767676}.page-status .object-status{font-weight:700;color:#038719}.page-push{height:100px}"]
            }] }
];
/** @nocollapse */
ObjectPageWrapperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment },
    { type: ComponentRegistry },
    { type: PageLifeCycleService }
];
ObjectPageWrapperComponent.propDecorators = {
    title: [{ type: Input }],
    objectType: [{ type: Input }],
    objectStatusLabel: [{ type: Input }],
    objectStatus: [{ type: Input }],
    objectStates: [{ type: Input }],
    currentState: [{ type: Input }],
    header: [{ type: Input }],
    hideHeader: [{ type: Input }],
    footer: [{ type: Input }],
    hideFooter: [{ type: Input }],
    pageActionPosition: [{ type: Input }],
    actionsTemplate: [{ type: ContentChild, args: ['pageActions',] }],
    notifications: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Page actions is a wrapper for all page actions, buttons, links, menus that interacts it with the
 * page. The wrapper use the ability to position it as needed.
 */
class PageActionsComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
}
PageActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-actions',
                template: "<div class=\"page-actions\">\n    <ng-content></ng-content>\n</div>\n",
                styles: [".page-actions{text-align:right;padding-top:0;padding-right:0}"]
            }] }
];
/** @nocollapse */
PageActionsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Page content is a wrapper for page content.
 * Currently, it's pretty bare, but as we add more interactions on the page, like a side bar,
 * the page content area will likely get affected.
 */
class PageContentComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
}
PageContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-content',
                template: '<ng-content></ng-content>',
                styles: [':host {width: 100%; padding: 0 .5em;}']
            }] }
];
/** @nocollapse */
PageContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const STEPPER_COMPLETED_STEP_COLOR = '#58b957';
/** @type {?} */
const STEPPER_CURRENT_STEP_COLOR = '#0076CB';
/** @type {?} */
const STEPPER_REMAINING_STEP_COLOR = '#D7D7D7';
/**
 * Stepper component displays a list of steps for user to follow. It can be used as a checklist
 * to indicate completed, current and remaining items. It could be also be used to indicate
 * the state of an document, created, submitted, approved, etc...
 *
 *
 * Usage:
 *   1.   Use the component inside your template. provide a list of steps and the current step.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                <aw-stepper [steps]="steps" [currentStep]="currentStep"></aw-stepper>
 *
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     steps: string[] = ['Monitor', 'Add Supplier', 'Get Quote'];
 *                     currentStep: number = 1;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *       }
 *
 *   2.  Override the default colors.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                            <aw-stepper [steps]="steps" [stepColorCurrent]="'#ff9900'"
 *                                        [stepColorRemaining]="'#CC0000'"
 *                                        [stepColorCompleted]="'#97a822'"
 *                                        [currentStep]="currentStep">
 *                            </aw-stepper>
 *                  `
 */
class StepperComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Local variable to indicate whether to use the colors array or not.
         */
        this.bUseColorArray = false;
        /**
         * The current step that's on. If not provided default to the first step.
         */
        this.currentStep = 0;
        // Initial color for the different stages of steps.
        this.stepColorCompleted = STEPPER_COMPLETED_STEP_COLOR;
        this.stepColorCurrent = STEPPER_CURRENT_STEP_COLOR;
        this.stepColorRemaining = STEPPER_REMAINING_STEP_COLOR;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Calculate the connector width based on how many steps
        if (isPresent(this.steps) && this.steps.length > 1) {
            // (100% - 20% (side margins)) / (NumOfSteps -1)
            this.connectorWidth = Math.ceil(80 / (this.steps.length - 1)) + '%';
        }
        /**
                 * Use the color array if it's defined.
                 */
        if (isPresent(this.colors)) {
            this.bUseColorArray = true;
            if (this.colors.length !== this.steps.length) {
                throw new Error(`The size of the steps and colors don't match:
                  (steps.length = ${this.steps.length}), (colors.length = ${this.colors.length}`);
            }
        }
    }
    /**
     * Getting the color of the step for the current index
     *
     * @param {?} index
     * @return {?}
     */
    getStepColor(index) {
        // Color Array overrides everything else.
        if (this.bUseColorArray) {
            return this.colors[index];
        }
        if (index < this.currentStep) {
            return this.stepColorCompleted;
        }
        else if (index === this.currentStep) {
            return this.stepColorCurrent;
        }
        else {
            return this.stepColorRemaining;
        }
    }
    /**
     * The connector colors are driven by the step colors.
     *
     * @param {?} index
     * @return {?}
     */
    getConnectorColor(index) {
        // Color Array overrides everything else.
        if (this.bUseColorArray) {
            return this.colors[index];
        }
        if (index < this.currentStep) {
            return this.stepColorCompleted;
        }
        else {
            return this.stepColorRemaining;
        }
    }
    /**
     * Next step.
     * @return {?}
     */
    nextStep() {
        this.currentStep++;
    }
    /**
     * previous step.
     * @return {?}
     */
    prevStep() {
        this.currentStep--;
    }
}
StepperComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-stepper',
                template: "<div class=\"stepper-container\">\n    <div class=\"steps\">\n        <div class=\"step-spacing\"></div>\n\n        <ng-container *ngFor=\"let step of steps; let i=index; let last=last;\">\n            <div class=\"step\">\n                <aw-step [title]=\"step\" [color]=\"getStepColor(i)\"></aw-step>\n            </div>\n            <div *ngIf=\"!last\" class=\"step-connector\" [style.width]=\"connectorWidth\">\n                <div class=\"connector\" [style.borderBottomColor]=\"getConnectorColor(i)\"></div>\n            </div>\n        </ng-container>\n\n        <div class=\"step-spacing\"></div>\n    </div>\n\n    <div class=\"step-labels\"></div>\n</div>\n\n\n",
                styles: [".stepper-container{display:table;table-layout:fixed;width:100%}.steps{display:table-row}.step-spacing{display:table-cell;width:10%}.step{display:table-cell;width:32px}.step-connector{display:table-cell;vertical-align:middle}.connector{height:1px;border-bottom:3px solid #58b957}.step-labels{display:table-row;height:50px}"]
            }] }
];
/** @nocollapse */
StepperComponent.ctorParameters = () => [
    { type: Environment }
];
StepperComponent.propDecorators = {
    steps: [{ type: Input }],
    colors: [{ type: Input }],
    stepColorCompleted: [{ type: Input }],
    stepColorCurrent: [{ type: Input }],
    stepColorRemaining: [{ type: Input }],
    currentStep: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** *
 * Renders html step component
 *
 *  * Usage:
 *       Straight forward to use. But mostly it would be used as part of the stepper component.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                           <aw-step [title]="step" [color]="color"></aw-step>
 *                           `
  @type {?} */
const DEFAULT_COLOR = '#58b957';
class StepComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        this.env = env;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isBlank(this.color)) {
            this.color = DEFAULT_COLOR;
        }
    }
}
StepComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-step',
                template: "<div class=\"step-container\">\n    <div class=\"outer-circle\" [style.borderColor]=\"color\">\n        <div class=\"inner-circle\" [style.borderColor]=\"color\" [style.backgroundColor]=\"color\"></div>\n    </div>\n\n    <div class=\"step-title\">{{title}}</div>\n</div>\n\n",
                styles: [".step-container{position:relative;width:32px}.outer-circle{width:26px;height:26px;border-radius:50%;background-color:#fff;border:3px solid #58b957;position:relative}.inner-circle{width:8px;height:8px;border-radius:50%;border:2px solid #58b957;background-color:#58b957;margin:0 auto;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.step-title{position:absolute;width:150px;top:40px;left:-60px;text-align:center}"]
            }] }
];
/** @nocollapse */
StepComponent.ctorParameters = () => [
    { type: Environment }
];
StepComponent.propDecorators = {
    color: [{ type: Input }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWStepperModule {
}
AWStepperModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    StepComponent,
                    StepperComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                ],
                entryComponents: [
                    StepComponent,
                    StepperComponent
                ],
                exports: [
                    StepComponent,
                    StepperComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWPageWrapperModule {
}
AWPageWrapperModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ObjectPageWrapperComponent,
                    PageActionsComponent,
                    PageContentComponent,
                    PageFooterComponent,
                    PageHeaderComponent,
                    SidenavComponent
                ],
                imports: [
                    CommonModule,
                    RouterModule,
                    AWCoreComponentModule,
                    AWStepperModule,
                    AWPageNotificationModule
                ],
                entryComponents: [
                    PageFooterComponent,
                    PageActionsComponent,
                    PageContentComponent,
                    PageHeaderComponent
                ],
                exports: [
                    ObjectPageWrapperComponent,
                    PageActionsComponent,
                    PageContentComponent,
                    PageFooterComponent,
                    PageHeaderComponent,
                    SidenavComponent
                ],
                providers: [PageLifeCycleService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const EditorType = {
    Default: 0,
    // Default Editor supports Minimal set of functionality
    // [ bold | italic | underline | ordered | bullet | alignment]
    Full: 1,
    // The full list of functionality,
    TextFormat: 2,
    // Functionalities that affects text formatting.
    Custom: 3 // Custom toolbar.
    ,
};
EditorType[EditorType.Default] = 'Default';
EditorType[EditorType.Full] = 'Full';
EditorType[EditorType.TextFormat] = 'TextFormat';
EditorType[EditorType.Custom] = 'Custom';
/** @type {?} */
const EDITOR_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RichTextAreaComponent),
    multi: true
};
class RichTextAreaComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * A value used to save and read when rendering and updating this component
         */
        this.value = '';
        /**
         * Expose editorType so that it can be used in this components template.
         */
        this.EditorType = EditorType;
        this.type = EditorType.Default;
        this.styleClass = 'default-editor';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.value);
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(val => {
            this.value = val;
            this.onModelChanged(this.value);
        });
    }
    /**
     * Internal. Please see ControlValueAccessor
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value);
        }
    }
}
RichTextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-richtextarea',
                template: "<ng-template [ngIf]=\"editable\">\n\n    <!-- Basic editor, also the default, which the most used features enabled. -->\n    <div *ngIf=\"type === EditorType.Default\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                    <span class=\"ql-formats\">\n                        <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                        <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                        <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                        <button class=\"ql-list\" value=\"ordered\"></button>\n                        <button class=\"ql-list\" value=\"bullet\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                            <button value=\"left\" selected></button>\n                            <button value=\"center\"></button>\n                            <button value=\"right\"></button>\n                            <button value=\"justify\"></button>\n                    </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Editor with all the features enabled -->\n    <div *ngIf=\"type === EditorType.Full\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\"></p-editor>\n    </div>\n\n    <!-- Editor with all Text formatting  -->\n    <div *ngIf=\"type === EditorType.TextFormat\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n            <span class=\"ql-format-group\">\n              <select title=\"Font\" class=\"ql-font\">\n                <option value=\"sans-serif\" selected=\"\">Sans Serif</option>\n                <option value=\"serif\">Serif</option>\n                <option value=\"monospace\">Monospace</option>\n              </select>\n              <select title=\"Size\" class=\"ql-size\">\n                <option value=\"10px\">Small</option>\n                <option value=\"13px\" selected=\"\">Normal</option>\n                <option value=\"18px\">Large</option>\n                <option value=\"32px\">Huge</option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                    <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                    <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                </span>\n                <span class=\"ql-format-group\">\n              <select title=\"Text Color\" class=\"ql-color\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\" selected=\"\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n              <span class=\"ql-format-separator\"></span>\n              <select title=\"Background Color\" class=\"ql-background\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\" selected=\"\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                <button class=\"ql-list\" value=\"ordered\"></button>\n                <button class=\"ql-list\" value=\"bullet\"></button>\n            </span>\n                <span class=\"ql-formats\">\n                    <button value=\"left\" selected></button>\n                    <button value=\"center\"></button>\n                    <button value=\"right\"></button>\n                    <button value=\"justify\"></button>\n            </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Custom header Text Editor -->\n    <div *ngIf=\"type === EditorType.Custom\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                <ng-content select=\"custom-header\"></ng-content>\n            </p-header>\n        </p-editor>\n    </div>\n\n</ng-template>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                providers: [
                    EDITOR_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => RichTextAreaComponent) }
                ],
                styles: ["/deep/ .ui-editor-toolbar{background-color:#f5f5f5;border:1px solid #d7d7d7}/deep/ p-editor:active /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow{border-color:#199de0}/deep/ p-editor:active /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-content.ql-container.ql-snow{border-color:#199de0}"]
            }] }
];
/** @nocollapse */
RichTextAreaComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
RichTextAreaComponent.propDecorators = {
    type: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWRichTextAreaModule {
}
AWRichTextAreaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RichTextAreaComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    EditorModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    RichTextAreaComponent
                ],
                exports: [
                    RichTextAreaComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Allow developer to override default actions. Must have this declared before class when we
 * want to have this declaration inside the same file.
 */
class SectionActionsComponent {
}
SectionActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-section-actions',
                template: `<ng-content></ng-content> `
            }] }
];
/**
 *
 * Section component that implements a section of the page. It's an outline box that
 * has the ability to expand and hide its content.
 *
 * ```ts
 * \@Component({
 *    selector: 'rfx-details' ,
 *    template: `
 *         <aw-section title="Sourcing request info" (onEdit)="onStateChange($event)"
 *                          [editable]="true">
 *
 *                <m-context [object]="rfxEntity.headerInfo"
 *                          [operation]="this.editabilityState.headerInfoOp"
 *                          layout="Inspect"
 *                          uiGroup="HeaderGeneral">
 *                   <m-include-component></m-include-component>
 *               </m-context>
 *           </aw-section>
 *
 *
 *           <aw-section #supplierSection title="Selected suppliers" (onOpen)="onOpen()"
 *                [opened]="false">
 *               <supplier-profile-card></supplier-profile-card>
 *           </aw-section>
 *
 *           <aw-section title="RFQ Details"
 *                       description="Review and update information for suppliers to respond."
 *                       [disableClose]="true">
 *
 *               <aw-subsection title="Event timeline">
 *                   <aw-form-table [useFiveZone]="false" [editable]="true">
 *
 *                       <aw-form-row [label]="'Start Date'" [name]="'startDate'" [size]="'small'"
 *                                   [highlightRow]="true">
 *                           <aw-date-time
 *                               formatName="dateTime"
 *                               name="startDate" [value]="rfxEntity.created"
 *                               [showTime]="true"></aw-date-time>
 *                       </aw-form-row>
 *                   </aw-form-table>
 *               </aw-subsection>
 *          </aw-section>
 *    `
 *    })
 *    export class MyPage
 *    {
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 *
 * ```
 *
 * Section component also supports editability modes and if enabled it will render action buttons
 * in the footer. Developer can also override default behavior and provide custom actions.
 *
 *
 * e.g:
 *
 * ```
 *      <aw-section [title]="title" [editable]="true"
 *                          (onCancelAction)="someHandler1($event)"
 *                          (onSaveAction)="someHandler2($event)" >
 *              section content
 *
 *
 *   </aw-section>
 *
 * ```
 *
 * or custom action buttons:
 *
 *
 * ```html
 *
 *       <aw-section-actions>
 *                      <aw-button >
 *                            ButtonTest1
 *                      </aw-button>
 *                      <aw-button>
 *                            ButtonTest2
 *                      </aw-button>
 *     </aw-section-actions>
 *
 * ```
 *
 *
 * There are two edit modes
 *  # Default
 *      Renders action buttons in the footers and emit actions to the application
 *
 *  # External
 *     No action buttons are shown in the footer and behavior is handled by application. Only event
 *     is emited.
 *
 *
 *  e.g:
 *
 *  ```ts
 *
 *      <aw-section title="User Information" (onEdit)="onAddSomething($event)"
 *                  [editable]="true" [editMode]="'external'" >
 *                  <div>
 *                      Content
 *                  </div>
 *      </aw-section>
 *
 *  ```
 *
 * Note: When using editing mode you have to call at the end of the editing cycle method
 * `completeEditing()` to commit editing which changes internal state of the Section.
 *
 *
 *
 */
class SectionComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
        /**
         * Should this section be opened at the start. Default is opened.
         */
        this.opened = true;
        /**
         * Whether this section can be closed or not.
         *
         */
        this.disableClose = false;
        /**
         * Whether this section is in EditState or not.
         *
         * When in editing state and we show "Cancel / Save" button developer needs use this binding
         * to control the state.
         */
        this.editState = false;
        /**
         * Current Editing mode. Tells the components if its its default behavior or driven by
         * application using this component.
         *
         * {\@see EditMode}
         *
         */
        this.editMode = 'default';
        /**
         * Developer can provide custom Edit action icon that will appear in the right top corner
         */
        this.actionIcon = 'icon-edit';
        /**
         * Event emitted when the section is fully opened.
         */
        this.onOpen = new EventEmitter();
        /**
         * Event emitted when the section is fully closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Edit state to broadcast state of current section
         */
        this.onEdit = new EventEmitter();
        /**
         * When in editing state and default buttons are rendered on click broadcast Cancel action
         */
        this.onCancelAction = new EventEmitter();
        /**
         * When in editing state and default buttons are rendered on click broadcast Save action
         */
        this.onSaveAction = new EventEmitter();
        this.onEditingComplete = new EventEmitter();
        this.editable = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // If I have not header, then I can't close the section.
        if (!this.isHeaderDisplayed()) {
            this.disableClose = true;
        }
        // If I can't close the section, then it should default open.
        if (this.disableClose) {
            this.opened = true;
        }
        // initialize the expanded state.
        this.expanded = this.opened;
    }
    /**
     * Don't display header area if I don't have title and description.
     *
     * @return {?}
     */
    isHeaderDisplayed() {
        return (isPresent(this.title) || isPresent(this.description));
    }
    /**
     * Css Class that control the look and feel for section component.
     * @return {?}
     */
    aClass() {
        if (!this.isHeaderDisplayed()) {
            return 'section-no-header';
        }
        return '';
    }
    /**
     * Since we introduced buttons and editState the decision on when to exit editing mode
     * should be on the developer using this component therefore only startEditing
     *
     * @param {?} $event
     * @return {?}
     */
    onEditAction($event) {
        // when in editing make sure we dont switch state as there can be some Form errors
        // which needs to be handled by developer and only then change the editState
        if (!this.editState) {
            this.editState = !this.editState;
            /** @type {?} */
            let state$$1 = (this.editState) ? 'inEdit' : 'notInEdit';
            this.onEdit.emit(state$$1);
            this.open();
        }
        // prevent the original event from bubbling up. Because the edit icon is inside
        // the header. If the click even is bubbled up, this event will cause the section to
        // expand or collapse.
        if (isPresent($event.event)) {
            $event.event.stopPropagation();
            $event.event.preventDefault();
        }
    }
    /**
     * @return {?}
     */
    hasDescription() {
        return isPresent(this.description);
    }
    /**
     * Open this section, if it's already open, will do nothing.
     * @param {?=} event
     * @return {?}
     */
    open(event) {
        if (!this.expanded) {
            this.accordionTab.toggle(event);
        }
    }
    /**
     * Close this section, if it's already close, will do nothing.
     * @param {?} event
     * @return {?}
     */
    close(event) {
        if (this.expanded) {
            this.accordionTab.toggle(event);
        }
    }
    /**
     * Callback to be invoked when accordion is opened
     *
     * @param {?} event
     * @return {?}
     */
    onSectionOpen(event) {
        this.expanded = true;
        this.onOpen.emit('open');
    }
    /**
     * Callback to be invoked when accordion is closed
     *
     * @param {?} event
     * @return {?}
     */
    onSectionClose(event) {
        this.expanded = false;
        this.onClose.emit('close');
    }
    /**
     *
     * Tells us if we need to render application defined custom actions
     *
     * @return {?}
     */
    hasCustomActions() {
        return isPresent(this.customActions);
    }
    /**
     * Emit the editing state back to non-editable
     * @return {?}
     */
    completeEditing() {
        this.editState = false;
        this.onEditingComplete.emit(this.editState);
    }
}
SectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-section',
                template: "<div class=\"ui-g-12 section-container\"\n     [class.editing]=\"editable && editState && editMode === 'default'\">\n\n    <p-accordion (onOpen)=\"onSectionOpen($event)\" (onClose)=\"onSectionClose($event)\"\n                 [styleClass]=\"aClass()\">\n        <p-accordionTab #accordionTab [selected]=\"opened\" [disabled]=\"disableClose\">\n            <p-header>\n                <!-- title and description -->\n                <div class=\"section-header-container\">\n                    <div class=\"section-title\">{{title}}</div>\n                    <div *ngIf=\"hasDescription()\" class=\"section-description\">{{description}}</div>\n\n                    <!-- actions: Hide when in editing and editMode is default -->\n                    <div *ngIf=\"(editable && !editState && editMode === 'default') ||\n                        (editable && editMode === 'external')\"\n                         class=\"section-actions\">\n                        <aw-hyperlink (action)=\"onEditAction($event)\">\n                            <i class=\"sap-icon section-edit-action\" [ngClass]=\"actionIcon\"></i>\n                        </aw-hyperlink>\n                    </div>\n                </div>\n            </p-header>\n\n            <ng-content></ng-content>\n        </p-accordionTab>\n    </p-accordion>\n    <!--\n        need to put it outside of p-accordion otherwise button will inherit different\n        color scheme\n    -->\n    <div class=\"section-footer-container\" *ngIf=\"editable && editState &&\n            editMode === 'default'\">\n        <div class=\"footer-actions\">\n\n            <ng-template [ngIf]=\"!hasCustomActions()\">\n                <aw-button [style]=\"'secondary'\" size=\"small\"\n                           (action)=\"onCancelAction.emit($event)\">\n                    Cancel\n                </aw-button>\n                <aw-button size=\"small\" (action)=\"onSaveAction.emit($event)\">\n                    Save\n                </aw-button>\n            </ng-template>\n\n            <ng-content select=\"aw-section-actions\"></ng-content>\n        </div>\n    </div>\n</div>\n",
                styles: [".section-header-container{position:relative}.section-container{margin:10px 0;background-color:#fff;padding:.2em .5em;border:2px dashed transparent}.section-container.editing{border-color:#199de0}.section-container ::ng-deep .ui-accordion-header>a{display:flex}.section-container ::ng-deep .ui-accordion-header>a .ui-accordion-toggle-icon{flex:0 0 30px;padding-top:2px}.section-container ::ng-deep .ui-accordion-header>a p-header{flex:1 0}.section-container /deep/ .ui-accordion-header.ui-state-disabled{opacity:1}.section-title{font-size:1.1em}.section-description{font-size:.9em;padding:.6em 0 .2em}.section-footer-container{margin:1em 2em 0;padding:.8em 0 1.5em .8em;border-top:1px solid #d7d7d7}.section-footer-container .footer-actions{display:inline-block;text-align:right;width:100%}.section-actions{position:absolute;top:0;right:0;z-index:1}.section-actions /deep/ a.link,.section-actions /deep/ a.link:hover{padding:0;text-decoration:none}.section-edit-action{font-size:1.5em;position:relative;padding:.1em 0 .1em .5em;cursor:pointer}.section-edit-action.icon-edit{font-size:1.4em}.section-container /deep/ .ui-accordion-header{color:#363636;border:none;background:#fff!important;padding:0 1em}.section-container /deep/ .ui-accordion-content{border:none;padding:1em 2em}.section-container /deep/ .ui-accordion-header /deep/ a[role=tab]{padding:.75em 0;text-decoration:none}.section-container /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:1px solid #d7d7d7;color:#363636}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header{height:1px}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:none}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header .section-edit-action{cursor:pointer!important}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down,:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right{font-family:\"SAP icon fonts\";font-size:1.1em;top:.8em;left:.1em;color:#767676;margin-top:0}:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .fa,:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .pi{display:none}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right:before{content:\"\\e1ed\"}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down:before{content:\"\\e1ef\"}"]
            }] }
];
/** @nocollapse */
SectionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
SectionComponent.propDecorators = {
    title: [{ type: Input }],
    description: [{ type: Input }],
    opened: [{ type: Input }],
    disableClose: [{ type: Input }],
    editState: [{ type: Input }],
    editMode: [{ type: Input }],
    actionIcon: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }],
    onEdit: [{ type: Output }],
    onCancelAction: [{ type: Output }],
    onSaveAction: [{ type: Output }],
    onEditingComplete: [{ type: Output }],
    accordionTab: [{ type: ViewChild, args: ['accordionTab',] }],
    customActions: [{ type: ContentChild, args: [SectionActionsComponent,] }]
};
class SubSectionComponent {
}
SubSectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-subsection',
                template: `
                    <h4 class="subsection-title">{{title}}</h4>
                    <ng-content></ng-content>
                 `,
                styles: ['.subsection-title {color: #363636; }']
            }] }
];
SubSectionComponent.propDecorators = {
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWSectionModule {
}
AWSectionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SectionComponent,
                    SubSectionComponent,
                    SectionActionsComponent
                ],
                imports: [
                    CommonModule,
                    AccordionModule,
                    AribaCoreModule,
                    AWStringFieldModule,
                    AWHyperlinkModule,
                    AWButtonModule,
                    SharedModule
                ],
                entryComponents: [
                    SectionComponent,
                    SubSectionComponent,
                    SectionActionsComponent
                ],
                exports: [
                    SectionComponent,
                    SectionActionsComponent,
                    SubSectionComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * DTColumn represent single column including header and its body. Each column has its own
 * rendererTemplate which a entry to this component.
 *
 * Keeping this separate from the datatable where DT is not really aware what it is rendering,
 * it allows us more flexibility in terms of different type of column inheriting from this
 * one.. Such as:
 *  DTRowDetail  column
 *  DTSingleSelection column
 *  DTMultiSelection column
 *
 * This way we don't do IF/THEN/ELSE inside the datatable and trying to create different cases.
 *
 *  Then later on this will let us create additional logic for the pivotal layout. Because DT
 *  does know anything about the type of the column so whatever is added to the DT.columns it
 *  will be rendered.
 *
 *
 *  Columns can be also frozen meaning if the content overflows they dont scroll. To make the
 *  column frozen we need to use [frozen] binding and se it to TRUE plus it requires a [width]
 *  binding to be set (in px).
 *  We need this to be able to properly position the second table which is changed to absolute
 *  positioning.
 *
 *
 *
 */
class DTColumn2Component extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env);
        this.env = env;
        this.domHandler = domHandler;
        /**
         *
         * Cell alignment. It inserts regular align attribute to the table cell
         *
         */
        this.align = 'left';
        /**
         *
         * If false applies dt-is-hidden style that hides the column
         *
         */
        this.isVisible = true;
        /**
         * Sorting direction
         *
         */
        this.sortOrdering = 'descending';
        /**
         * Tells the template if whether to render a label
         *
         */
        this.showColumnLabel = true;
        /**
         *
         * See AWDataTable
         *
         */
        this.showSubHeader = false;
        /**
         *
         * Used together with cell selectionMode to tell which column is selectable
         *
         */
        this.selectable = false;
        /**
         * Use globally defined HEADER template for current column
         *
         */
        this.useGlobalHeader = true;
        /**
         * Use globally defined SubHeader template for current column
         *
         */
        this.useGlobalSubHeader = true;
        /**
         * Use globally defined body template
         *
         */
        this.useGlobalBody = true;
        /**
         * Tells if the column is data column  - if it is rendering data or just a label or some
         * control
         *
         * This is important when calculating a column span and we need to know which columns are or
         * will be just for selection controls and which holds data
         */
        this.isDataColumn = true;
        /**
         * Identifies column that will not scroll horizontally with other columns. Column is
         * frozen.
         *
         * For such columns that are marked as frozen binding [width] is required.
         *
         */
        this.frozen = false;
        this.maxWidthPx = 0;
        this.minWidthPx = 0;
        this.widthPx = 0;
        this.widestCell = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.key) && isBlank(this.label)) {
            throw new Error('Missing required binding: ' +
                '[key] or [label] bindings must be used at minimum');
        }
        // To be able to position second DT we require [width] to be set as well
        if (this.frozen && isBlank(this.width)) {
            throw new Error('Missing required binding [width]: ' +
                'when [frozen]=true then [width] binding needs to be specified.');
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // need to deffer this and trigger change detection otherwise I get
        // value was changed after it was checked error
        // setTimeout(() =>
        // {
        // });
    }
    /**
     *
     * When cell selectionMode is enabled this method is triggered when we click on header.
     * It delegates the call to the DT where it toggles currently selected value
     *
     * @param {?} event
     * @param {?} element
     * @return {?}
     */
    handleHeaderClick(event, element) {
        if (this.isHeaderSelectable()) {
            this.dt.onHeaderSelectionChange(element, this);
        }
        else if (this.sortable) {
            this.sort(event);
        }
        event.preventDefault();
    }
    /**
     *
     * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
     *
     * @param {?} event
     * @return {?}
     */
    sort(event) {
        if (!this.sortable) {
            return;
        }
        /** @type {?} */
        let targetNode = event.target;
        if (this.domHandler.hasClass(targetNode, 'dt-u-sortable') ||
            this.domHandler.hasClass(targetNode, 'dt-col-title') ||
            this.domHandler.hasClass(targetNode, 'dt-col-sortable-icon')) {
            if (isPresent(this.dt.sortColumn) && this.dt.sortColumn.key === this.key) {
                this.sortOrder = this.sortOrder * -1;
                this.sortOrdering = this.dt.sortOrderingForNumber(this.sortOrder);
            }
            else {
                this.dt.sortColumn = this;
            }
            this.dt.dataSource.state.sortKey = this.key;
            this.dt.dataSource.state.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
            this.dt.sortSingle();
        }
        this.dt.updateDataToRender();
    }
    /**
     * Calculated style class based on data
     *
     *
     * @param {?} item
     * @return {?}
     */
    dynamicBodyClass(item) {
        /** @type {?} */
        let dynClass = isPresent(this.bodyClassFn)
            ? this.bodyClassFn.apply(this.dt.context, [this, item]) : '';
        if (isPresent(this.bodyStyleClass)) {
            dynClass += ' ' + this.bodyStyleClass;
        }
        else if (isPresent(this.styleClass)) {
            dynClass += ' ' + this.styleClass;
        }
        return dynClass;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isRowSelectable(item) {
        if (isPresent(this.dt.isRowSelectable)) {
            return this.dt.isRowSelectable(item);
        }
        return false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isCellSelectable(item) {
        return this.dt.selectionMode === 'cell' && this.isRowSelectable(item) && this.selectable;
    }
    /**
     * @return {?}
     */
    isHeaderSelectable() {
        return this.dt.selectionMode === 'cell' && this.selectable;
    }
    /**
     * @return {?}
     */
    getSortOrder() {
        /** @type {?} */
        let order = 0;
        if (isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key) {
            order = this.dt.sortColumn.sortOrder;
        }
        return order;
    }
    /**
     * @return {?}
     */
    isSorted() {
        if (!this.sortable) {
            return false;
        }
        return isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key;
    }
    /**
     * @param {?} table
     * @return {?}
     */
    initialize(table) {
        this.dt = table;
        if (isPresent(this.dt.initialSortKey) && this.dt.initialSortKey === this.key) {
            this.sortable = true;
            this.sortOrder = this.dt.sortOrderingForString(this.dt.initialSortOrder);
            this.dt.sortColumn = this;
        }
        if (isBlank(this.bodyTemplate) && this.useGlobalBody) {
            this.bodyTemplate = this.dt.bodyTemplate;
        }
        if (isBlank(this.headerTemplate) && this.useGlobalHeader) {
            this.headerTemplate = this.dt.headerTemplate;
        }
        if (isBlank(this.subHeaderTemplate) && this.useGlobalSubHeader) {
            this.subHeaderTemplate = this.dt.subHeaderTemplate;
        }
        if (isBlank(this.bodyClassFn)) {
            this.bodyClassFn = this.dt.bodyClassFn;
        }
        this.maxWidthPx = this.widthToPx(this.maxWidth);
        this.minWidthPx = this.widthToPx(this.minWidth);
        this.widthPx = this.widthToPx(this.width);
    }
    /**
     * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
     *
     * In case we use MaxWidth directive we set new width once for all columsn
     * @param {?} myIndex
     * @return {?}
     */
    postInitialize(myIndex) {
        /** @type {?} */
        const colIndex = myIndex + 1;
        /** @type {?} */
        let table;
        if (this.dt.hasFrozenColumns()) {
            table = (/** @type {?} */ (this.dt)).el
                .nativeElement.querySelector('.dt-body-frozen table');
        }
        else {
            table = (/** @type {?} */ (this.dt)).el.nativeElement.querySelector('table');
        }
        if (this.widestCell > 0) {
            /** @type {?} */
            let all = table.querySelectorAll('tr th:nth-child(' + colIndex + '), ' +
                'tr td:nth-child(' + colIndex + ')').forEach((node) => {
                node.style.width = this.widestCell + 'px';
            });
        }
    }
    /**
     * You either use this binding directly and say its datacolumn or when there is a [key]
     * biding we know it refers to some field.
     *
     * @return {?}
     */
    isValueColumn() {
        return (isPresent(this.isDataColumn) && BooleanWrapper.isTrue(this.isDataColumn)) ||
            isPresent(this.key);
    }
    /**
     * When we are in outline mode  we need to also indend each selection control accordingly.
     *
     * indent - 1 > only offset with
     * indent
     * @param {?} cell
     * @param {?} level
     * @return {?}
     */
    indentForControl(cell, level) {
        if (this.dt.isOutline() && level > 0 && cell.offsetWidth > 0
            && isPresent(cell.nextElementSibling)) {
            /** @type {?} */
            let outlineNodePadding = parseInt(getComputedStyle(cell.nextElementSibling).paddingLeft) || 0;
            // 1st level is pushed as root
            if (this.dt.pushRootSectionOnNewLine) {
                return (level === 1) ? null : (this.dt.indentationPerLevel * level)
                    - outlineNodePadding;
            }
            else {
                return (this.dt.indentationPerLevel * level) + outlineNodePadding;
            }
        }
        return null;
    }
    /**
     *
     * Internal
     * @param {?} width
     * @return {?}
     */
    widthToPx(width) {
        /** @type {?} */
        let px;
        if (isPresent(width)) {
            if (width.indexOf('%') > 0) {
                /** @type {?} */
                const nonPc = parseFloat(width) / 100;
                px = nonPc * (/** @type {?} */ (this.dt)).el.nativeElement.offsetWidth;
            }
            else {
                px = parseFloat(width);
            }
        }
        return px;
    }
}
DTColumn2Component.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-column2',
                template: "<!--\n    To make it more readable Each Column type has its own rendering template instead of putting\n    all this into datatable as this is more responsibility of the column. And the main goal\n    was try to be modular as possible. When There will be different types of columns\n\n    - Regular DTColumn (current implementation),\n    - SelectionColumn (Single/Multi select) - todo,\n    - DetailRow column, then pivotal collumn to render row/column/detail attributes - todo.\n\n    When implementing new column type you just inherit this DTColumnComponent and provide your\n    own rendering template and DT take care of the rest.\n\n    todo: We have SingleSelect, Multiselect rendering template that is Added programatically\n    todo: We have pivotal rendering template\n\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex, data: dataToRender,\n                 rowIndex:rowIndex}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Templates for header columns. Here we are rendering two types. Header and Subheader that we\n    usually use here as some kind of summary columns. Not really having summary at the bottom like other\n    DT.\n\n    TH column and their text are usually unselectable and most of these were inherited from\n    original PrimeNg DT even not many things got left after we refactor this but the idea is the\n    same.\n\n    Each cell has its dt-cell-def class that sets default styling like font, background, alignment\n    padding, etcs..\n\n\n-->\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\" let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <th #headerCell1 [class]=\"headerStyleClass||styleClass\" *ngIf=\"!isSubHeader\"\n        (click)=\"handleHeaderClick($event, headerCell1)\"\n        [ngClass]=\"{'dt-is-default dt-u-unselectable-text' :true,\n                    'dt-cell-def': dt.selectionMode !== 'cell' || (!dt.isOutline() || !dt.pivotalLayout),\n                    'dt-u-sortable': sortable,\n                    'dt-is-active': isSorted(),\n                    'dt-is-hidden': !isVisible}\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [attr.tabindex]=\"sortable ? 1 : null\"\n        [dtMaxWidth]=\"maxWidthPx\"\n    >\n\n        <ng-template [ngIf]=\"dt.headerFilterTemplate && columnIndex === 0 \">\n            <ng-container *ngTemplateOutlet=\"dt.headerFilterTemplate\">\n            </ng-container>\n        </ng-template>\n        <!--\n            when cell are selectable we need two version where one wrap the cell content in div\n        -->\n        <ng-template [ngIf]=\"isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"selectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n    </th>\n\n    <th #headerCell2 [class]=\"headerStyleClass||styleClass\" *ngIf=\"isSubHeader\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{'dt-is-default dt-cell-def dt-sub-header dt-u-unselectable-text':true}\"\n        [dtMaxWidth]=\"maxWidthPx\">\n\n        <span class=\"dt-col-title\" *ngIf=\"dt.showSubHeader && subHeaderTemplate\">\n            <ng-container *ngTemplateOutlet=\"subHeaderTemplate;\n                    context: {$implicit: this, rowData: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </span>\n    </th>\n</ng-template>\n\n\n<!--\n    Template for the body = the TD. For the body and we might want to do the same for header we\n    allow to have calculated body class that comes from the application. So based on the data types\n    you might want to apply different class in order to apply custom styling.\n-->\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        (click)=\"dt.onCellSelectionChange(cell, this, data)\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{ 'dt-is-default': true,\n        'dt-cell-def': !isCellSelectable(data),\n        'dt-is-hidden': !isVisible}\"\n        [dtMaxWidth]=\"maxWidthPx\"\n        >\n\n        <!--\n            Since we need to support cell selection when we need to draw border around it\n            We are wrapping such sells with div which gives us better flexibility\n        -->\n        <ng-template [ngIf]=\"isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"selectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex }\">\n            </ng-container>\n\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </ng-template>\n\n    </td>\n</ng-template>\n\n<!--\n    Todo: create better solution instead of using different template create directive that wraps\n    it with the div conditionally\n-->\n<ng-template #selectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isHeaderSelected(this)}\">\n        <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #headerCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && !headerTemplate\">\n                {{label}}\n    </span>\n\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && headerTemplate\">\n                    <ng-container *ngTemplateOutlet=\"headerTemplate;\n                        context: {$implicit: this, rowData: data, rowIndex: rowIndex }\">\n                    </ng-container>\n    </span>\n\n    <span class=\"dt-col-sortable-icon sap-icon icon-sort\" *ngIf=\"sortable\"\n          [ngClass]=\"{'icon-sort-descending': (getSortOrder() == -1),\n                           'icon-sort-ascending': (getSortOrder() == 1)}\">\n    </span>\n</ng-template>\n\n\n<ng-template #selectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isBodyCellSelected(this, data)}\">\n        <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #bodyCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <!--\n           when no template is used use our FieldPath to access the object value based on the\n           key binding\n        -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"!bodyTemplate\">\n            {{dt.getValue(data, key)}}\n        </span>\n\n\n    <!--\n        In case application wants to provide their own cell component they use\n        #body ng-template to do so.\n    -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"bodyTemplate\">\n            <ng-container *ngTemplateOutlet=\"bodyTemplate;\n            context: {$implicit: this, rowData: data, rowIndex: rowIndex}\"></ng-container>\n        </span>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler],
                styles: [".dt-sortable-col{cursor:pointer}.dt-col-sortable-icon{display:inline-block;margin-left:.125em}th.dt-cell-def{font-weight:400;color:#4a4a4a}th.dt-is-default{background-color:#f2f2f2;white-space:nowrap}th.dt-is-default.dt-cell-def:not(.dt-sub-header){border-bottom-color:#f2f2f2}th.dt-sub-header{background-color:#fff}th .dt-cell-selected{border-color:#58b957}td .dt-cell-selected{border-left-color:#4f9fcf}.dt-root-section .dt-selection-column,.dt-selection-column{width:46px;padding:0 12px}.dt-pivot-layout td.dt-selection-column,th.dt-selection-column{border-right-color:transparent}thead tr:first-child th{border-top-color:transparent}tbody tr:last-child:not(.dt-drag-row-bottom) td{border-bottom-color:transparent}td:first-child,th:first-child{border-left-color:transparent}td:last-child,th:last-child{border-right-color:transparent}tbody .dt-drag-row-top>td{background:linear-gradient(0deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-bottom>td{background:linear-gradient(180deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-both>td{background:linear-gradient(0deg,#0271d2 0,#fff 3%,#fff 97%,#0271d2 100%)}tbody .dt-row-dragging>td{background-color:#ececec;color:#b9b9b9}tbody .dt-row-dragging .ui-state-active{opacity:.5;cursor:not-allowed}"]
            }] }
];
/** @nocollapse */
DTColumn2Component.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];
DTColumn2Component.propDecorators = {
    label: [{ type: Input }],
    key: [{ type: Input }],
    align: [{ type: Input }],
    bodyClassFn: [{ type: Input }],
    isVisible: [{ type: Input }],
    sortable: [{ type: Input }],
    sortOrdering: [{ type: Input }],
    showColumnLabel: [{ type: Input }],
    showSubHeader: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    bodyStyleClass: [{ type: Input }],
    selectable: [{ type: Input }],
    useGlobalHeader: [{ type: Input }],
    useGlobalSubHeader: [{ type: Input }],
    useGlobalBody: [{ type: Input }],
    isDataColumn: [{ type: Input }],
    frozen: [{ type: Input }],
    maxWidth: [{ type: Input }],
    minWidth: [{ type: Input }],
    rendererTemplate: [{ type: ViewChild, args: ['renderingTemplate',] }],
    headerTemplate: [{ type: ContentChild, args: ['header',] }],
    subHeaderTemplate: [{ type: ContentChild, args: ['subHeader',] }],
    bodyTemplate: [{ type: ContentChild, args: ['body',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * An datatable header area.
 *
 * See {\@link DataTableComponent} for more explanation.
 */
class DTHeaderComponent2 {
}
DTHeaderComponent2.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-header2',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Custom column implementation to render detail row spaning its column across whole table width.
 *
 *
 */
class DTDetailRowComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        /**
         *
         * tells if we need to render a line between item row and its detail
         *
         */
        this.showRowLine = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // just to get around the check in parent class
        this.key = '';
        super.ngOnInit();
    }
    /**
     * Check if we need to keep some leading TDs
     *
     * @return {?}
     */
    visibleLeadingCols() {
        return this.dt.numberOfColsBeforeData - (this.dt.hasInvisibleSelectionColumn() ? 1 : 0);
    }
    /**
     *
     * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
     * Here can hook on application level custom method to decide if current item has detail row
     * or not
     *
     * Or we can use isVisible=true to tell all row have detail row
     *
     * @param {?} item
     * @return {?}
     */
    showDetailRow(item) {
        /** @type {?} */
        let isVisible = this.isVisible;
        if (isPresent(this.isVisibleFn)) {
            isVisible = this.isVisibleFn.apply(this.dt.context, [this, item]);
        }
        return isVisible;
    }
    /**
     * @param {?} table
     * @return {?}
     */
    initialize(table) {
        super.initialize(table);
        this.isVisible = !this.dt.isOutline() || !this.dt.pivotalLayout;
    }
}
DTDetailRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-detail-column',
                template: "<!--\n    Renders application defined detail column. This template just renders a detail row and\n    not expansion control. This is implemented by different DtColumn implementation and its added\n    (will be) added programmatically during column initialization\n-->\n<ng-template #renderingTemplate let-column=\"column\" let-rowData=\"data\">\n\n    <tr #detailRowElement class=\"dt-body-row dt-detail-row\">\n\n        <td *ngIf=\"dt.hasInvisibleSelectionColumn()\" width=\"1px\"></td>\n        <td *ngIf=\"visibleLeadingCols() > 0\" colspan=\"visibleLeadingCols()\" width=\"1px\">\n            &nbsp;&nbsp;\n        </td>\n        <td [attr.colspan]=\"dt.startOfFirstDataColumn\" [class]=\"dynamicBodyClass(rowData)\"\n            [ngClass]=\"{ 'dt-is-default dt-cell-def': true}\">\n\n            <ng-container\n                *ngTemplateOutlet=\"bodyTemplate; context:{$implicit: this, rowData:rowData}\">\n            </ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n",
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler],
                styles: [""]
            }] }
];
/** @nocollapse */
DTDetailRowComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];
DTDetailRowComponent.propDecorators = {
    isVisibleFn: [{ type: Input }],
    showRowLine: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 *
 *
 *
 */
class DTDetailRowExpanderComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        // we dont want to show the row/column unless application says so
        this.isVisible = false;
        // default width of the selection control
        this.width = '45px';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // just to get around the check in parent class
        this.key = '';
        super.ngOnInit();
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    toggleExpansion(event, item) {
        this.dt.detailRowExpansionState.toggle(item);
        event.stopPropagation();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    calculateStyleClass(item) {
        return this.dt.detailRowExpansionState.isExpanded(item) ?
            'icon-slim-arrow-down' : 'icon-slim-arrow-right';
    }
}
DTDetailRowExpanderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-detail-column-expand',
                template: "<!--\n   Special column that renders expand/collapse control for detail row when detail row is enabled.\n\n   Just like for the other column it renders header section as well as body section with\n   expand control to toggle the expansion\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\" let-columnIndex=\"columnIndex\" let-rowIndex=\"rowIndex\">\n\n\n    <ng-template [ngIf]=\"isHeader && !isSubHeader\">\n        <th #headerCell1 [class]=\"headerStyleClass||styleClass\"\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-cell-def' :true,\n                        'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender)}\">\n        </th>\n\n    </ng-template>\n\n    <ng-template [ngIf]=\"!isHeader && !isSubHeader\">\n        <td #cell\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{ 'dt-is-default': true,\n                    'dt-cell-def': !isCellSelectable(dataToRender),\n                    'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender),\n                    'dt-det-row-with-ln' : dt.rowDetailColumn.showRowLine}\">\n\n            <span (click)=\"toggleExpansion($event, dataToRender)\"\n                  class=\"dt-det-row-expand sap-icon\"\n                  [ngClass]=\"calculateStyleClass(dataToRender)\">\n\n            </span>\n\n        </td>\n\n    </ng-template>\n\n\n</ng-template>\n\n",
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler],
                styles: [".dt-row-cell-expando{width:14px;text-align:right;padding:17px 5px 17px 17px;border-right-color:transparent}.dt-row-cell-expando .dt-det-row-expand{cursor:pointer;line-height:21px}td.dt-det-row-expanded:not(.dt-det-row-with-ln),td.dt-det-row-expanded:not(.dt-det-row-with-ln)~td{border-bottom-color:transparent}"]
            }] }
];
/** @nocollapse */
DTDetailRowExpanderComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * @license
 * Copyright 2017 SAP Ariba
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 *
 */
/** @type {?} */
const DragEvents = ['mousedown', 'dragstart', 'dragover', 'dragenter', 'dragleave',
    'drop', 'dragend'];
/** @enum {string} */
const DragDirection = {
    None: 'none',
    Up: 'dt-drag-row-top',
    Down: 'dt-drag-row-bottom',
    Middle: 'dt-drag-row-both',
};
/** @enum {string} */
const DropPosition = {
    Before: 'before',
    After: 'after',
    Into: 'into',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Concrete DataSource implementation for Datatable which defines state and column definition that
 * can programmatically modify rendered columns (if provided) and method for inserting and
 * and deleting records;
 *
 * All operations dealing with data use Observable<T> and instant() method to retrieve current
 * state is not implemented.
 *
 *
 */
class DT2DataSource extends DataSource {
    /**
     * @param {?=} dataProviders
     * @param {?=} finders
     */
    constructor(dataProviders, finders) {
        super(dataProviders, finders);
        this.dataProviders = dataProviders;
        this.finders = finders;
        this.initialized = false;
        this.state = Datatable2State.create();
        this.debugTime = new Date().getTime();
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    init(...args) {
        if (isBlank(args) || args.length !== 1 && !isDTInitParams(args[0])) {
            throw new Error('You need to initialize DS with (DSChooserInitParams)');
        }
        /** @type {?} */
        let init = args[0];
        // use existing or find best match for dataProvider
        this.dataProvider = isPresent(init.dataProvider) ? init.dataProvider
            : this.dataProviders.find(init.obj);
        // use existing or find best match for dataFinder
        this.dataFinder = isPresent(init.dataFinder) ? init.dataFinder
            : this.finders.find(this.dataProvider, init.queryType);
        assert(isPresent(this.dataProvider) && isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
        this.dataFinder.lookupKey = init.lookupKey;
        if (isBlank(init.state)) {
            this.state = new Datatable2State();
        }
        else {
            this.state = init.state;
        }
        this.initialized = true;
    }
    /**
     * Triggers async fetch data request and result is given back using dataProvider.dataChanges
     *
     * @param {?=} withParams
     * @return {?}
     */
    fetch(withParams) {
        /** @type {?} */
        let params = null;
        if (isPresent(withParams)) {
            params = new Map().set('offset', withParams.offset)
                .set('limit', withParams.limit)
                .set('orderby', withParams.sortKey)
                .set('selector', withParams.sortOrder);
        }
        this.dataProvider.fetch(params).subscribe((result) => {
            if (withParams.offset > 0) {
                /** @type {?} */
                let incrData = [...this.dataProvider.dataChanges.getValue(), ...result];
                this.dataProvider.dataChanges.next(incrData);
            }
            else {
                this.dataProvider.dataChanges.next(result);
            }
        });
    }
    /**
     * Component uses this method to open up continuous stream to listen for any changes which
     * need to be reflected on the UI.
     *
     * Dont forget to unsubscribe when component is destroyed.
     * @template T
     * @return {?}
     */
    open() {
        return this.dataProvider.dataChanges.asObservable();
    }
    /**
     * @return {?}
     */
    close() {
        this.dataProvider = null;
        this.dataFinder = null;
    }
    /**
     * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
     * dataProvider.dataChanges that are new data. If not enabled we have default implementation
     * which works with local array
     *
     * @param {?} object
     * @return {?}
     */
    insert(object) {
        if (this.dataProvider.canCRUD()) {
            this.dataProvider.insert(object);
        }
        else {
            this.dataProvider.offScreenData.push(object);
            this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
        }
    }
    /**
     * Please see {\@link insert} method
     *
     * @param {?} object
     * @return {?}
     */
    remove(object) {
        if (this.dataProvider.canCRUD()) {
            this.dataProvider.remove(object);
        }
        else {
            ListWrapper.removeIfExist(this.dataProvider.offScreenData, object);
            this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
        }
    }
    /**
     *
     * Provides access to DataFinder which can accept either plain string or Map.
     *
     * To be able to provide correct input we need to ask DataFinder if it supports FullText like
     * type query or Predicate. In case of Predicate we build the Map with different key/value
     * pairs
     *
     *
     * @param {?=} pattern
     * @return {?}
     */
    find(pattern) {
        if (isBlank(pattern) || pattern.length === 0) {
            // if we received empty string return orginal list
            this.fetch(this.state);
            return;
        }
        /** @type {?} */
        let searchParam = pattern;
        if (this.dataFinder.accepts(this.dataProvider, QueryType.Predicate)) {
            searchParam = new Map().set('query', pattern).set('limit', DT2DataSource.MaxLimit);
            if (isPresent(this.state.sortKey)) {
                searchParam.set('orderby', this.state.sortKey);
            }
            if (isPresent(this.state.sortKey)) {
                searchParam.set('selector', this.state.sortOrder);
            }
        }
        else {
            assert(isString(pattern), 'Cannot pass non-string value to FullText Finder');
        }
        this.dataFinder.match(searchParam).subscribe((result) => {
            this.dataProvider.dataChanges.next(result);
        });
    }
    /**
     *
     * Data source delegates the responsibility to the given data provider which needs to implement
     * specific sorting mechanism
     *
     * Todo: Extend to sort by multiple columns
     *
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    sort(key, sortOrder) {
        if (isBlank(this.dataProvider.data()) || this.dataProvider.data().length === 0) {
            return;
        }
        this.state.sortKey = key;
        this.state.sortOrder = sortOrder;
        this.fetch(this.state);
    }
    /**
     *
     * Persist db state
     *
     * @param {?} offset
     * @param {?} sortField
     * @param {?} sOrder
     * @return {?}
     */
    updateState(offset, sortField, sOrder) {
        this.state.offset = offset;
        this.state.sortKey = sortField;
        this.state.sortOrder = sOrder;
    }
    /**
     *
     * reshuffles current array based on new row D&D result.
     *
     * Since there is a difference if we move item from bottom or from the top and then accordingly
     * highlighting a space between rows. We need to reflect this in here as well.
     *
     * UseCase 1:
     *
     * 1. You can grab item with index 0 and move it down so that you can see a dropping line
     * between row with index 2 - 3
     *
     * 2. In this case splice() starts from position 2 and insert all elements after 2
     *      splice(start: number, deleteCount: number, ...items: T[]): T[];
     *
     * 3. no need to update newPos
     *
     * UseCase 2:
     *
     * 1. You can grab item with index 0 and move all the way down of the DT and now move the
     * row toward TOP and space between rows with index 2 - 3 is highlighted again.
     *
     * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
     * it seems the same but its highlighted row #3 with line at the TOP.
     *
     * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
     * where where the line between rows is created.
     *
     *
     * We don't need any complicated calculation trying to find out if we are on one half of the row
     * or second half and based on this try to apply certain style. This would not give so much
     * space if we want drop row into the row. And the calculation with coordinates woudl be too
     * complicated.
     *
     * We simply remember the direction we are moving and based on this we apply style to
     * to create a line at the TOP if we are going upwards or bottom otherwise.
     *
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    reorderRows(origPos, newPos, dropPos) {
        /** @type {?} */
        let array = this.dataProvider.data().slice();
        // take something from top and drag&drop under
        if (newPos > origPos && dropPos === DropPosition.Before && newPos < array.length) {
            newPos -= 1;
            // take something from bottom and drag&drop above
        }
        else if (newPos < origPos && dropPos === DropPosition.After && newPos >= 0) {
            newPos += 1;
        }
        array.splice(newPos, 0, ...array.splice(origPos, 1)[0]);
        this.dataProvider.dataChanges.next(array);
    }
}
DT2DataSource.MaxLimit = 100;
/**
 * Keeps current datatable state the state which drivers the way while fetching the data as well
 * encapsulate set of properties that needs to be persistet in order to recover a state after e.g.
 * browser refresh
 *
 *
 * todo: Create methods to convert this state from and to JSON for easier serialization
 */
class Datatable2State {
    constructor() {
        /**
         * Properties for paging and fetching
         */
        this.offset = 0;
        this.limit = 0;
        /**
         * Identifies default value that is used to render N number of rows in non-fullscreen
         * mode
         *
         */
        this.displayLimit = 0;
        /**
         * Sorting order of the sort field. DataTable support sorting for multiple column but we
         * dont persist it now. Maybe in the future
         */
        this.sortOrder = Datatable2State.Ascending;
        /**
         * If we are using global filter for current datatable then save it here
         */
        this.currentSearchQuery = '';
        this.outlineState = new Map();
        this.detailRowExpandState = new Map();
    }
    /**
     * @param {?=} offset
     * @param {?=} limit
     * @param {?=} displayLimit
     * @param {?=} sortField
     * @param {?=} sOrder
     * @param {?=} searchQuery
     * @param {?=} filter
     * @param {?=} outlineState
     * @param {?=} detailRowState
     * @return {?}
     */
    static create(offset = 0, limit = 15, displayLimit = 5, sortField = '', sOrder = 0, searchQuery, filter, outlineState = new Map(), detailRowState = new Map()) {
        /** @type {?} */
        let s = new Datatable2State();
        s.offset = offset;
        s.limit = limit;
        s.displayLimit = displayLimit;
        s.sortKey = sortField;
        s.sortOrder = sOrder;
        s.currentSearchQuery = searchQuery;
        s.currentFilter = filter;
        s.outlineState = outlineState;
        s.detailRowExpandState = detailRowState;
        return s;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static fromJSON(data) {
        /** @type {?} */
        let state$$1 = JSON.parse(data);
        /** @type {?} */
        let ds = new Datatable2State();
        ds.offset = state$$1.offset;
        ds.limit = state$$1.limit;
        ds.displayLimit = state$$1.displayLimit;
        ds.sortKey = state$$1.sortKey;
        ds.sortOrder = state$$1.sortOrder;
        ds.currentSearchQuery = state$$1.currentSearchQuery;
        ds.outlineState = MapWrapper.createFromAnyMap(state$$1.outlineState);
        ds.detailRowExpandState = MapWrapper.createFromAnyMap(state$$1.detailRowExpandState);
        return ds;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static toJSON(data) {
        /** @type {?} */
        let toConvert = {
            offset: data.offset,
            limit: data.limit,
            displayLimit: data.displayLimit,
            sortKey: data.sortKey,
            sortOrder: data.sortOrder,
            currentSearchQuery: data.currentSearchQuery,
            outlineState: MapWrapper.toAnyMap(data.outlineState),
            detailRowExpandState: MapWrapper.toAnyMap(data.detailRowExpandState)
        };
        return JSON.stringify(toConvert);
    }
}
Datatable2State.Ascending = 1;
Datatable2State.Descending = -1;
/**
 * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
 * simple we have a map holding item reference as a key and boolean value indicating if the
 * detail row is visible
 *
 * Todo: move this out to DS
 */
class DetailRowExpansionState {
    /**
     * @param {?} dt
     */
    constructor(dt) {
        this.dt = dt;
    }
    /**
     * @return {?}
     */
    get detailExpansionEnabled() {
        return isPresent(this.expansionStates);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set detailExpansionEnabled(value) {
        if (value) {
            this.expansionStates = new Map();
        }
        else {
            this.expansionStates = null;
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    toggle(item) {
        /** @type {?} */
        let key = this.itemToKey(item);
        if (!this.isExpanded(item)) {
            this.expansionStates.set(key, true);
        }
        else {
            this.expansionStates.delete(key);
        }
        this.dt.dataSource.state.detailRowExpandState = this.expansionStates;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isExpanded(item) {
        /** @type {?} */
        let key = this.itemToKey(item);
        // handle special case where we collapse parent of parent while detail row is expanded
        if (this.dt.isOutline() && !this.dt.outlineState.isExpanded(key)) {
            this.expansionStates.delete(key);
            return false;
        }
        /** @type {?} */
        let isOutlineExpanded = this.dt.isOutline() ? this.dt.outlineState.isExpanded(key) : true;
        return isPresent(key) && this.expansionStates.has(key);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    itemToKey(item) {
        return isEntity(item) ? (/** @type {?} */ (item)).identity() : item;
    }
}
/**
 * @param {?} init
 * @return {?}
 */
function isDTInitParams(init) {
    return isPresent(init.obj) || isPresent(init.queryType) || isPresent(init.entity);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Column implementation for the Multiselection where we show checkbox control
 *
 *
 */
class DTMultiSelectColumnComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        // default width of the selection control
        this.width = '45px';
    }
}
DTMultiSelectColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-multi-select-column',
                template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n\n        <ng-template [ngIf]=\"dt.showSelectAll\">\n            <aw-checkbox [type]=\"'action'\" (action)=\"dt.toggleAllColumns($event)\"\n                         [value]=\"dt.isToggleAllColumnSelected()\"\n                         [disabled]=\"dt.isToggleAllColumnDisabled()\">\n            </aw-checkbox>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!dt.showSelectAll\">&nbsp;\n        </ng-template>\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-checkbox [type]=\"'action'\" [value]=\"dt.isRowSelected(data)\">\n        </aw-checkbox>\n\n    </td>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler],
                styles: [""]
            }] }
];
/** @nocollapse */
DTMultiSelectColumnComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Column implementation for the SingleSelect where we show checkbox control
 *
 *
 */
class DTSingleSelectColumnComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        // default width of the selection control
        this.width = '45px';
    }
}
DTSingleSelectColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-single-select-column',
                template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n        &nbsp;\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-radiobutton [name]=\"'DTRadio'\" [value]=\"data\" [(ngModel)]=\"dt.dataSource.state.selection\">\n        </aw-radiobutton>\n    </td>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler],
                styles: [""]
            }] }
];
/** @nocollapse */
DTSingleSelectColumnComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * DT component that implements the data grid that shows tabular data. Even the basic
 * structure is based on PrimeNG datatable its completely refactored into smaller pieces that
 * allows more extensibility and trying to stay as close as possible to existing AWL implementation
 *
 * There are 3 main pieces:
 *
 *  Table Wrapper - focuses on the outer structure. Container with basic datable layout plus
 *  contains any additional panels that datatable needs such as our new concept how editing will
 *  work - sliding panel from the bottom
 *
 *  Datatable Column - Instead of rendering everything inside DT I split the part that renders
 *  column into separate component. This way component column has its own renderer template which
 *  can render both header and data cells.
 *  Later on DTColumn is then extended to support other additional column types
 *  SingleSelectionColumn, MultiSelectionColumn, both responsible for rendering selection controls.
 *
 * To support pivotal layout this can be extended for other additional columns that implements their
 * own rendering templates
 *
 * Datatable - The main component that is only focus on header and body rendering and basaed on the
 * column type it will render the correct template
 * column type it will render the correct template
 *
 *
 *
 *
 *
 */
class Datatable2Component extends BaseComponent {
    /**
     *
     * In case of outline table we are inject OutlineState which is provided in the DT component
     * definition. This is used by nested outlineFor component it set itself as reference and
     * initialize the state so it can be used later on inside OutlineControl
     *
     *
     * Each Datatable is pre-defaulted with its own version of DataSource so all the observers
     * inside are unique for this component
     *
     * @param {?} env
     * @param {?} el
     * @param {?} _defaultDS
     * @param {?} changeDetector
     * @param {?} factoryResolver
     * @param {?} outlineState
     * @param {?} zone
     * @param {?} injector
     */
    constructor(env, el, _defaultDS, changeDetector, factoryResolver, outlineState, zone, injector) {
        super(env);
        this.env = env;
        this.el = el;
        this._defaultDS = _defaultDS;
        this.changeDetector = changeDetector;
        this.factoryResolver = factoryResolver;
        this.outlineState = outlineState;
        this.zone = zone;
        this.injector = injector;
        /**
         *  Hides or shows table heading where we have filters and tools menus
         */
        this.showTableHeader = true;
        /**
         * See AWDataTable
         *
         */
        this.pivotalLayout = false;
        /**
         * See AWDataTable
         */
        this.initialSortOrder = 'descending';
        /**
         * When DT is loaded in the page and we are not in the full screen (full page mode), this
         * is hte number of lines that DT will show
         *
         * todo: come up with better name
         */
        this.displayRowSize = 10;
        /**
         * Used for paging on lazy loading using infinite scroller to set initial fetch limit size
         *
         * todo: come up with better name !!!
         *
         */
        this.pageSize = 15;
        /**
         * Default message when there are no data .
         *
         * todo: Use i18n value and create resource file
         */
        this.emptyMessage = 'No records found';
        /**
         *
         * See AWDataTable
         *
         */
        this.selectionMode = 'none';
        /**
         *
         * Can provide custom icon. These icons are not animated divs, we used css
         * transformation to rotate them.
         *
         */
        this.loadingIcon = 'icon-synchronize';
        /**
         * Additional indent can be added when rendering detail row
         */
        this.indentDetailRow = false;
        /**
         * See AWDataTable
         *
         */
        this.indentationPerLevel = 25;
        /**
         *
         *  SubHeader is used to show summary columns, which in our UX is shown at the top just under
         *  the regular table header
         *
         */
        this.showSubHeader = false;
        /**
         * See OutlineFor - only used in the tree mode
         */
        this.expandAll = false;
        /**
         *
         * See OutlineFor  - format - only used in the tree mode
         */
        this.outlineFormat = 'free';
        /**
         * See AWDataTable
         */
        this.pushRootSectionOnNewLine = true;
        /**
         * Render or hide expansion control for row detail columns. Expansion control makes sense for
         * simple table, when using this inside outline (tree table), its driven by outline control
         */
        this.showRowDetailExpansionControl = true;
        /**
         * See AWDataTable
         *
         */
        this.showSelectionColumn = true;
        /**
         * See AWDataTable
         *
         */
        this.showSelectAll = true;
        /**
         * Show or hide global search term input field in the header
         */
        this.showGlobalSearch = true;
        /**
         * Enables or disables row reordering
         *
         */
        this.dndRowEnabled = false;
        /**
         *
         * Fires event that sorting is enabled for column and we trigger sorting
         *
         */
        this.onSort = new EventEmitter();
        /**
         * Based on selection mode it triggers even
         *
         */
        this.onRowClick = new EventEmitter();
        /**
         *
         * When multi or single selection mode is enabled it will trigger event when checkbox or
         * radio buttons is selected
         *
         * todo: implement SingleSelectionDTColumn, MultiSelectionDTColumn with their renderers
         */
        this.onRowSelectionChange = new EventEmitter();
        /**
         * When cell body selection changes we fire event
         *
         */
        this.onCellChange = new EventEmitter();
        /**
         * When cell header selection changes we fire event
         *
         */
        this.onHeaderSelection = new EventEmitter();
        /**
         *
         * Triggers when items in the list are updated
         *
         */
        this.valueChange = new EventEmitter();
        this.classList = 'w-datatable ';
        /**
         *  Indicates that columns were initialed Also used when we hide and show column to trigger
         *  change.
         *
         */
        this.columnsChanged = false;
        /**
         * See AWDataTable
         */
        this.numberOfColsBeforeData = 0;
        /**
         * See AWDataTable
         */
        this.startOfFirstDataColumn = 0;
        this.dataSource = this._defaultDS;
    }
    /**
     * Pushes a state out to application. Can be use as two way bindings
     *
     * [(state)]=dtState(s)
     *
     * @return {?}
     */
    get state() {
        return this.dataSource.state;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set state(val) {
        this.dataSource.state = val;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isPresent(this.list) && isPresent(this.destinationClass)) {
            throw new Error('You cannot use both bindings [list] and [destinationClass]!');
        }
        this.detailRowExpansionState = new DetailRowExpansionState(this);
        // init default columns
        this.rowDetailExpandColumn = this.factoryResolver
            .resolveComponentFactory(DTDetailRowExpanderComponent).create(this.injector).instance;
        this.multiSelectColumn = this.factoryResolver
            .resolveComponentFactory(DTMultiSelectColumnComponent).create(this.injector).instance;
        this.singleSelectColumn = this.factoryResolver
            .resolveComponentFactory(DTSingleSelectColumnComponent).create(this.injector).instance;
        /**
                 * If the data are not deferred and we get list directly then it creates DS. If
                 * ngOnChanges is called first we properly init DS and clean this.list
                 *
                 */
        if (isPresent(this.destinationClass) || isPresent(this.list)) {
            this.initDatasource();
        }
        else if (this.dataSource.initialized) {
            this.initDatasource(false);
        }
        // since we work with references let's pass created map inside our state
        this.outlineState.expansionStates = this.state.outlineState;
    }
    /**
     * When data arrives later maybe due to REST API latency, initialize DS only when we have a
     * data, otherwise if data changed thru the bindings just trigger dataChange event
     *
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes['list'] && isPresent(changes['list'].currentValue)
            && !this.dataSource.initialized) {
            this.initDatasource();
        }
        else if (this.dataSource.initialized) {
            this.dataSource.dataProvider.dataChanges.next(this.list);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // make sure we init a state when detail column is present
        // todo: move this initialization to datasource
        this.detailRowExpansionState.detailExpansionEnabled = isPresent(this.rowDetailColumn);
        this.initColumns();
        this.columnsSubscription = this.colsQuery.changes.subscribe(_ => {
            this.initColumns();
            this.changeDetector.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // assign it programatically as we want to have a context for the filter
        if (isPresent(this.rowDetailColumn) && isPresent(this.outlineState.outlineFor)) {
            this.outlineState.outlineFor.filterOut = this.skipOutlineItem.bind(this);
        }
        if (isPresent(this.outlineState.outlineFor)) ;
        this.initialized = true;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.columnsChanged && this.el.nativeElement.offsetParent) {
            this.columnsChanged = false;
        }
        if (this.hasFrozenColumns()) {
            this.frozenColumns.forEach((col, index) => col.postInitialize(index));
        }
        else {
            this.columns.forEach((col, index) => col.postInitialize(index));
        }
    }
    /**
     * Key entry method that initialized our columns. Later on when we will support selection and
     * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
     * components and add them to the list so they can be rendered.
     *
     * so the idea here is:
     *
     * When DT component initialize and we are in editing mode and we support Single/Multi selection
     * we will use ComponentFactoryResolver to create component and add it as first item to the list
     * and then it will be rendered just like anythign else.
     *
     * @return {?}
     */
    initColumns() {
        this.columns = [];
        this.frozenColumns = [];
        if (this.detailRowExpansionState.detailExpansionEnabled) {
            this.initDetailColumnExpansion();
        }
        if (this.hasLeadingSelectColumn() && this.selectionMode === 'multi') {
            this.multiSelectColumn.initialize(this);
            this.columns.push(this.multiSelectColumn);
        }
        else if (this.hasLeadingSelectColumn() && this.selectionMode === 'single') {
            this.singleSelectColumn.initialize(this);
            this.columns.push(this.singleSelectColumn);
        }
        /**
                 * Add expansion column when detail row is enabled
                 */
        if (this.detailRowExpansionState.detailExpansionEnabled && !this.isOutline()) {
            this.rowDetailExpandColumn.initialize(this);
            this.columns.push(this.rowDetailExpandColumn);
        }
        this.colsQuery
            .filter((col1) => !col1.frozen)
            .forEach((col) => {
            col.initialize(this);
            this.columns.push(col);
        });
        this.initFrozenColumns();
        this.initColumnInfo();
        this.columnsChanged = true;
    }
    /**
     * Check if current column is programmatically created
     *
     * @param {?} col
     * @return {?}
     */
    isInternalColumn(col) {
        return col instanceof DTSingleSelectColumnComponent ||
            col instanceof DTMultiSelectColumnComponent ||
            col instanceof DTDetailRowExpanderComponent;
    }
    /**
     * Create new Datasource based on passed values. It tries to initialize DS for first time
     * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
     * can be triggered also from ngOnChanges.
     *
     * @param {?=} initialize
     * @return {?}
     */
    initDatasource(initialize = true) {
        if (isBlank(this.state)) {
            this.state = Datatable2State.create(0, this.pageSize, this.displayRowSize, this.initialSortKey, this.sortOrderingForString(this.initialSortOrder));
        }
        else {
            this.state.limit = this.state.displayLimit = this.displayRowSize;
            if (isPresent(this.initialSortKey)) {
                this.state.sortKey = this.initialSortKey;
                this.state.sortOrder = this.sortOrderingForString(this.initialSortOrder);
            }
        }
        if (initialize) {
            /** @type {?} */
            let qType = (this.isOutline() && this.outlineFormat === 'tree') ?
                QueryType.FullTextOutline : QueryType.FullText;
            this.dataSource.init({
                obj: isPresent(this.destinationClass) ? this.destinationClass : this.list,
                queryType: qType,
                state: this.state,
                multiselect: false
            });
        }
        this.dataSource.fetch(this.state);
        // reset list to make sure it comes from DataProvider, we use list  to initialize
        this.list = null;
        // This is the ENTRY point for the DATA CHANGES. All addition, edits, deletion ends up
        // here. We dont work directly with LIST. Any change is reactive and here is listener
        this.dataSource.open().subscribe((data) => {
            this.updateList(data);
        });
    }
    /**
     * When detailRow column is present we initialize a state holding information which item is
     * expanded.
     *
     * todo: This is temporary here and once we suport lazy loading move this to datasource.
     *
     * For example for outline tree table we need to connect a state from outline with a state in
     * here as we are using outline control to expand and collapse items
     * @return {?}
     */
    initDetailColumnExpansion() {
        if (isPresent(this.rowDetailColumn)) {
            this.rowDetailColumn.initialize(this);
        }
        this.detailRowExpansionState.detailExpansionEnabled = isPresent(this.rowDetailColumn) &&
            BooleanWrapper.isTrue(this.showRowDetailExpansionControl);
    }
    /**
     * This method is executed after we initialize all the columns in order to calculate correct
     * numbers used for indentation while rendering selection columns as well as detail row columns.
     *
     * Here we need to be aware how many columns to span
     *
     * @return {?}
     */
    initColumnInfo() {
        this.numberOfColsBeforeData = 0;
        this.columns.forEach((col) => {
            if (!col.isValueColumn()) {
                this.numberOfColsBeforeData++;
            }
        });
        if (this.indentDetailRow) {
            this.numberOfColsBeforeData++;
        }
        this.startOfFirstDataColumn = this.columns.length - this.numberOfColsBeforeData;
    }
    /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    onCellSelectionChange(cell, column, item) {
        if (this.selectionMode !== 'cell') {
            return;
        }
        /** @type {?} */
        let lookupKey = {
            col: column.key || column.label,
            item: item
        };
        if (isPresent(this.state.selection) && this.state.selection.length > 0) {
            /** @type {?} */
            let foundIndex = ListWrapper.findIndexComplex(this.state.selection, lookupKey);
            /** @type {?} */
            let isSelected = foundIndex !== -1;
            if (isSelected) {
                this.state.selection = this.state.selection
                    .filter((val, index) => index !== foundIndex);
            }
            else {
                this.state.selection = [...this.state.selection, lookupKey];
            }
        }
        else {
            this.state.selection = [lookupKey];
        }
        this.onCellChange.emit(this.state.selection);
    }
    /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @return {?}
     */
    onHeaderSelectionChange(cell, column) {
        if (isPresent(this.state.headerSelection)) {
            if (this.isHeaderSelected(column)) {
                this.state.headerSelection = null;
            }
            else {
                this.state.headerSelection = column;
            }
        }
        else {
            this.state.headerSelection = column;
        }
        this.onHeaderSelection.emit(this.state.headerSelection);
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onHandleRowClicked(event, item) {
        // special alt key modifier. When used with rows it indicates there is a D&D enabled
        if (event.altKey) {
            return;
        }
        if (this.selectionMode === 'multi') {
            this.onRowToggle(event, item);
        }
        else if (this.selectionMode === 'single') {
            this.onRowSelect(event, item);
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onRowToggle(event, item) {
        /** @type {?} */
        let rowSelected = true;
        if (isPresent(this.state.selection) && this.state.selection.length > 0) {
            /** @type {?} */
            let foundIndex = ListWrapper.findIndexComplex(this.state.selection, item);
            /** @type {?} */
            let isSelected = foundIndex !== -1;
            if (isSelected) {
                this.state.selection = this.state.selection
                    .filter((val, index) => index !== foundIndex);
                rowSelected = false;
            }
            else {
                this.state.selection = [...this.state.selection, item];
            }
            // for the outline go up and down the sync with treeitems
            if (this.isOutline()) {
                this.onHandleOutlineRowToggleToChildren(item, isSelected);
                this.oHandleOutlineRowToggleToParent(item, isSelected);
            }
        }
        else {
            this.state.selection = [item];
            if (this.isOutline()) {
                this.onHandleOutlineRowToggleToChildren(item, false);
                this.oHandleOutlineRowToggleToParent(item, false);
            }
        }
        this.onRowSelectionChange.emit({
            isSelected: rowSelected,
            item: this.state.selection
        });
        event.stopPropagation();
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onRowSelect(event, item) {
        this.state.selection = item;
        event.stopPropagation();
        this.onRowSelectionChange.emit(item);
    }
    /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    onHandleOutlineRowToggleToChildren(currentItem, isSelected) {
        /** @type {?} */
        let childrenForNode = this.children.apply(this.context, [currentItem]) || [];
        if (childrenForNode.length > 0) {
            // If is selected currently then toggle to other state
            if (!isSelected) {
                // when checking all from root, deselect children and add all
                this.onHandleOutlineRowToggleToChildren(currentItem, true);
                this.state.selection = [...this.state.selection, ...childrenForNode];
            }
            else {
                // remove each child
                for (let child of childrenForNode) {
                    /** @type {?} */
                    let foundIndex = ListWrapper.findIndexComplex(this.state.selection, child);
                    this.state.selection = this.state.selection
                        .filter((val, index) => index !== foundIndex);
                }
            }
            // apply the same for children of children
            for (let child of childrenForNode) {
                this.onHandleOutlineRowToggleToChildren(child, isSelected);
            }
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    oHandleOutlineRowToggleToParent(currentItem, isSelected) {
        /** @type {?} */
        let parent = currentItem.$$parentItem;
        if (isPresent(parent)) {
            /** @type {?} */
            let childrenForNode = this.children.apply(this.context, [parent]) || [];
            /** @type {?} */
            let allSelected = true;
            for (let child of childrenForNode) {
                allSelected = ListWrapper.findIndexComplex(this.state.selection, child) !== -1
                    && allSelected;
            }
            if (!isSelected) {
                if (allSelected) {
                    this.state.selection.push(parent);
                }
            }
            else {
                if (!allSelected) {
                    /** @type {?} */
                    let parentIndex = ListWrapper.findIndexComplex(this.state.selection, parent);
                    this.state.selection = this.state.selection
                        .filter((val, index) => index !== parentIndex);
                }
            }
            this.oHandleOutlineRowToggleToParent(currentItem.$$parentItem, isSelected);
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    onDnDRowDrop(origPos, newPos, dropPos) {
        if (isPresent(this.dataSource)) {
            // console.log('Dropping row #: ', origPos + ' ' + dropPos + ' row #: ' + newPos);
            this.dataSource.reorderRows(origPos, newPos, dropPos);
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    onOutlineExpandChange(event) {
        /** @type {?} */
        let item = event.item;
        // We dont really need to store a state form outline locally as we are using the same object
        // reference
        // this.state.outlineState = this.outlineState.expansionStates;
        if (this.canUseForDetailRow(item)) {
            this.detailRowExpansionState.toggle(item);
        }
    }
    /**
     * See AWDataTable
     *
     *
     * @return {?}
     */
    sortSingle() {
        if (isPresent(this.list) && isPresent(this.sortColumn)) {
            assert(isPresent(this.sortColumn.key), 'Invalid column to sort');
            this.dataSource.sort(this.sortColumn.key, this.sortColumn.sortOrder);
            this.onSort.emit({
                field: this.sortColumn.key,
                order: this.sortColumn.sortOrder
            });
        }
    }
    /**
     * See AWDataTable
     *
     * @return {?}
     */
    handleDataChange() {
        if (this.state.sortKey || this.sortColumn) {
            if (!this.sortColumn && this.columns) {
                this.sortColumn = this.columns.find(col => col.key === this.state.sortKey);
            }
        }
        this.updateDataToRender();
        this.valueChange.emit(this.list);
    }
    /**
     * @param {?=} datasource
     * @return {?}
     */
    updateDataToRender(datasource) {
        this.dataToRender = datasource || this.list;
        if (isBlank(this.children) && isPresent(this.dataToRender)
            && this.dataToRender.length > 0 && isOutlineNode(this.dataToRender[0])) {
            this.outlineFormat = 'tree';
        }
        // this.changeDetector.markForCheck();
        this.changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    reset() {
        this.sortColumn = null;
        this.updateDataToRender();
    }
    /**
     * See AWDataTable
     * @param {?} item
     * @return {?}
     */
    isHeaderSelected(item) {
        if (isBlank(this.state.headerSelection)) {
            return false;
        }
        /** @type {?} */
        let colMatched = item.key || item.label;
        /** @type {?} */
        let currentCol = this.state.headerSelection.key || this.state.headerSelection.label;
        return colMatched === currentCol;
    }
    /**
     *
     * See AWDataTable
     *
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    isBodyCellSelected(column, item) {
        /** @type {?} */
        let lookupKey = {
            col: column.key || column.label,
            item: item
        };
        return isPresent(this.state.selection) &&
            ListWrapper.findIndexComplex(this.state.selection, lookupKey) !== -1;
    }
    /**
     *  See AWDataTable
     *
     * @param {?} item
     * @return {?}
     */
    isRowSelected(item) {
        if (this.hasLeadingSelectColumn() && isPresent(this.state.selection)) {
            if (this.selectionMode === 'multi') {
                return ListWrapper.findIndexComplex(this.state.selection, item) !== -1;
            }
            else if (this.selectionMode === 'single') {
                return equals(this.state.selection, item);
            }
        }
        return false;
    }
    /**
     *
     * Do we have data to render Used inside template to tell if we should use the NoData template
     *
     * @return {?}
     */
    isEmpty() {
        return isBlank(this.dataToRender) || (this.dataToRender.length === 0);
    }
    /**
     * @return {?}
     */
    hasFrozenColumns() {
        return isPresent(this.frozenColumns) && this.frozenColumns.length > 0;
    }
    /**
     * See AWDataTable
     * @return {?}
     */
    hasInvisibleSelectionColumn() {
        return this.hasLeadingSelectColumn() && !this.showSelectionColumn;
    }
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    hasLeadingSelectColumn() {
        return this.selectionMode !== 'none' && this.selectionMode !== 'cell';
    }
    /**
     * @return {?}
     */
    visibleColumns() {
        return this.columns ? this.columns.filter(c => c.isVisible) : [];
    }
    /**
     * See AWDataTable
     *
     * @param {?} direction
     * @return {?}
     */
    sortOrderingForString(direction) {
        if (isBlank(direction) || direction === 'ascending') {
            return 1;
        }
        if (isBlank(direction) || direction === 'descending') {
            return -1;
        }
        // todo: log bad key
        return 1;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    sortOrderingForNumber(direction) {
        if (isBlank(direction) || direction === 1) {
            return 'ascending';
        }
        if (isBlank(direction) || direction === -1) {
            return 'descending';
        }
        // todo: log bad key
        return 'ascending';
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    toggleAllColumns(event) {
        /** @type {?} */
        let currentItems = this.dataToRender || [];
        /** @type {?} */
        let selectedObject = this.state.selection || [];
        if (selectedObject.length >= currentItems.length) {
            this.state.selection = [];
        }
        else {
            this.state.selection = [];
            this.state.selection = [...currentItems];
        }
    }
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    isToggleAllColumnSelected() {
        /** @type {?} */
        let currentItems = this.dataToRender || [];
        /** @type {?} */
        let selectedObject = this.state.selection || [];
        return currentItems.length > 0 && selectedObject.length >= currentItems.length;
    }
    /**
     * @return {?}
     */
    isToggleAllColumnDisabled() {
        /** @type {?} */
        let currentItems = this.dataToRender || [];
        return currentItems.length === 0;
    }
    /**
     *
     * Used by template to decide if we need to render DetailRow template. We need to have
     * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
     * check if the item that is about to be rendered is eligible for detail row
     *
     * @param {?} item
     * @return {?}
     */
    showDetailColumn(item) {
        if (this.canUseForDetailRow(item) && this.detailRowExpansionState.isExpanded(item)) {
            return true;
        }
        return false;
    }
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    isOutline() {
        return isPresent(this.children) || this.outlineFormat === 'tree';
    }
    /**
     *
     * When dealing with detail column (detail row) and outline all together we need have a
     * mechanism to tell to the outline "don't render the next level of items" and use detail row.
     * So certain item type needs to be skipped.
     *
     * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
     * if we should skip next level.
     *
     * @param {?} item
     * @return {?}
     */
    skipOutlineItem(item) {
        return this.canUseForDetailRow(item);
    }
    /**
     *
     * See AWDaTable
     *
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    getValue(data, field) {
        return FieldPath.getFieldValue(data, field);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.columnsSubscription) {
            this.columnsSubscription.unsubscribe();
        }
    }
    /**
     * Makes sure that we also include programmatic column if present. Move them to the correct
     * array
     *
     * @return {?}
     */
    initFrozenColumns() {
        this.colsQuery
            .filter((col1) => col1.frozen)
            .forEach((col) => {
            col.initialize(this);
            this.frozenColumns.push(col);
        });
        if (this.frozenColumns.length > 0) {
            /** @type {?} */
            let lastInx = this.columns.slice()
                .reverse()
                .findIndex((col) => this.isInternalColumn(col));
            if (lastInx !== -1) {
                /** @type {?} */
                let idx = this.columns.length - 1 - lastInx;
                /** @type {?} */
                let internalCols = this.columns.splice(0, idx + 1);
                this.frozenColumns = [...internalCols, ...this.frozenColumns];
            }
            /** @type {?} */
            let hasValidCols = this.columns
                .findIndex((col) => isBlank(col.width)) === -1;
            assert(hasValidCols || isPresent(this.scrollWidth), 'When using [frozen] binding you need specify [width] for each ' +
                'column or [scrollWidth] on datatable!');
            assert(isBlank(this.rowDetailColumn), 'You cannot combine aw-dt-detail-column with frozen columns!');
        }
    }
    /**
     * Updates current immutable list and trigger change detection. Need to wrap it with
     * setTimeout as the change can easily come after view checked and this would result some errors
     *
     * @param {?} newList
     * @return {?}
     */
    updateList(newList) {
        setTimeout(() => {
            this.list = newList;
            this.handleDataChange();
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    canUseForDetailRow(item) {
        return isPresent(this.rowDetailColumn) &&
            (/** @type {?} */ (this.rowDetailColumn)).showDetailRow(item);
    }
}
Datatable2Component.decorators = [
    { type: Component, args: [{
                selector: 'aw-datatable2',
                template: "<!--\n    This template focus only on header and body rendering.\n\n    This datatable also supports frozen column and for this rendering it is pretty much transparent\n    as it received sets of column that it needs to render from the TableWrapper.\n\n    TableWrapper in case of frozen columns calls #headerRows and #bodyRows templates twice to\n    render to separate tables where one has frozen columns and another one has the rest and its\n    scrollable\n-->\n\n<aw-dt-wrapper #dtWrapper>\n    <ng-template #headingArea>\n        <ng-content select=\"aw-dt-header2\"></ng-content>\n    </ng-template>\n\n    <ng-template #headerRows let-colsToRender let-frozenView=\"frozenColumns\">\n        <ng-container\n            *ngTemplateOutlet=\"header; context:{$implicit: colsToRender, frozen:frozenView }\">\n        </ng-container>\n    </ng-template>\n\n    <ng-template #bodyRows let-colsToRender>\n        <ng-template [ngIf]=\"isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyOutline; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n        <ng-template [ngIf]=\"!isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyPlain; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n    </ng-template>\n</aw-dt-wrapper>\n\n\n<!--\n    Each rendering column has its own renderTemplate which define how things should be render.\n    Based on different column types this code should be transparent as we dont care on this\n    level what kind of column we are rendering.\n\n    Later on when we will support single/multi selection, this will be just another column extending\n    DTColumn and providing its own template\n\n    We pass into this template if we are rendering header, subHeader, or data\n-->\n<ng-template #header let-colsToRender let-frozen=\"frozen\">\n    <tr>\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\"\n                     let-columnIndex=\"index\">\n\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:false,\n                columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n\n    <tr *ngIf=\"showSubHeader\">\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:true}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n<ng-template #bodyPlain let-colsToRender>\n\n    <tbody [ngClass]=\"{'dt-content dt-data-cells ': true, 'dt-is-hoverable-row': rowHover}\">\n\n    <ng-template ngFor let-rowData [ngForOf]=\"dataToRender\" let-even=\"even\" let-odd=\"odd\"\n                 let-rowIndex=\"index\" [ngForTrackBy]=\"rowTrackBy\">\n\n        <ng-container *ngTemplateOutlet=\"rowTemplate; context:{$implicit: rowData, even:even,\n                                          odd:odd, rowIndex:rowIndex, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n\n<ng-template #bodyOutline let-colsToRender>\n    <tbody #outlineFor awOutlineFor [list]=\"dataToRender\"\n           [format]=\"outlineFormat\"\n           [context]=\"context\"\n           [indentationPerLevel]=\"indentationPerLevel\"\n           [pushRootSectionOnNewLine]=\"pushRootSectionOnNewLine\"\n           [children]=\"children\" [expandAll]=\"expandAll\"\n           [state]=\"outlineState\"\n           [ngClass]=\"{'dt-content dt-data-cells ': true,\n                           'dt-is-hoverable-row': rowHover}\"\n           (onExpandChange)=\"onOutlineExpandChange($event)\">\n\n    <ng-template #outline let-rowData let-nestingLevel=\"nestingLevel\" let-rowIndex=\"rowIndex\">\n        <ng-container *ngTemplateOutlet=\"rowTemplate;\n                                context:{$implicit: rowData, nestingLevel:nestingLevel, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n<!--\n    Default template that is display when there are no data\n-->\n<ng-template #noData>\n    <tr *ngIf=\"isEmpty()\" class=\" dt-emptymessage-row\"\n        [style.visibility]=\"loading ? 'hidden' : 'visible'\">\n\n        <td [attr.colspan]=\"visibleColumns().length\" class=\"dt-emptymessage\">\n            <span *ngIf=\"!emptyMessageTemplate\">{{emptyMessage}}</span>\n            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n<!--\n    Template that renders actual row. Renders both header and body column. Each rendered\n    column has its own template called rendererTemplate that has all things that needs to be\n    rendered and we just tell the template if we are rendering header, subheader or body\n-->\n<ng-template #rowTemplate let-rowData let-even=\"event\" let-odd=\"odd\" let-rowIndex=\"rowIndex\"\n             let-nestingLevel=\"nestingLevel\" let-colsToRender=\"colsToRender\">\n\n\n    <tr #rowElement dtDraggableRow [dndRowIndex]=\"rowIndex\"\n        class=\"dt-body-row\"\n        (click)=\"onHandleRowClicked($event, rowData)\"\n        [attr.nestingLevel]=\"nestingLevel\"\n        [ngClass]=\"{'dt-even-row': even, 'dt-odd-row': odd,\n            'dt-row-selected': isRowSelected(rowData),\n            'dt-row-draggable': dndRowEnabled,\n            'dt-root-section': nestingLevel === 0 }\">\n\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-colIndex=\"index\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:rowIndex,\n                    nestingLevel:nestingLevel}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n",
                providers: [
                    ObjectUtils,
                    OutlineState,
                    { provide: DATA_SOURCE, useClass: DT2DataSource, deps: [DataProviders, DataFinders] },
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".w-datatable{position:relative;display:block;box-sizing:border-box}.w-datatable table{border-collapse:collapse;width:100%;table-layout:fixed}.w-datatable tbody,.w-datatable td,.w-datatable th{outline:0}.dt-cell-def,.dt-cell-def-selectable{border:1px solid transparent;padding:17px 16px;box-sizing:border-box}.dt-cell-def-selectable{cursor:pointer;width:100%;height:100%}th .dt-cell-def-selectable{border-width:4px 1px 1px;padding:14px 16px 17px}td .dt-cell-def-selectable{border-width:0 1px 0 5px;padding:17px 16px 17px 13px}.dt-data-cells tr.dt-is-highlight,.dt-data-cells tr.dt-is-hover{border-color:inherit;font-weight:inherit;cursor:pointer}.w-datatable-rtl{direction:rtl}.w-datatable-rtl.w-datatable-rtl.w-datatable thead th{text-align:right}.dt-root-section .dt-cell-def,.dt-root-section .dt-cell-def-selectable{background-color:#f3f6f8;padding:10px 16px;border-bottom-color:transparent;border-right-color:transparent}.dt-plain-layout .dt-is-active,.dt-plain-layout .dt-is-default,.dt-plain-layout .dt-is-highlight,.dt-plain-layout .dt-is-hover,.dt-plain-layout .dt-is-hoverable-row{border-right-color:transparent}.dt-is-active,.dt-is-default,.dt-is-highlight,.dt-is-hover,.dt-is-hoverable-row{border:1px solid #d7d7d7;background-color:#fff;color:#363636}.dt-row-selected td{background-color:rgba(238,255,238,.71)}.dt-is-active{border-color:#065d9c;color:#199de0}.dt-is-highlight{background-color:rgba(65,117,5,.18)}.dt-is-hidden{display:none}.dt-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none}.dt-u-sortable{cursor:pointer}"]
            }] }
];
/** @nocollapse */
Datatable2Component.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef },
    { type: DT2DataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: OutlineState },
    { type: NgZone },
    { type: Injector }
];
Datatable2Component.propDecorators = {
    list: [{ type: Input }],
    destinationClass: [{ type: Input }],
    tableStyleClass: [{ type: Input }],
    bodyClassFn: [{ type: Input }],
    isRowSelectable: [{ type: Input }],
    showTableHeader: [{ type: Input }],
    pivotalLayout: [{ type: Input }],
    context: [{ type: Input }],
    initialSortOrder: [{ type: Input }],
    initialSortKey: [{ type: Input }],
    displayRowSize: [{ type: Input }],
    pageSize: [{ type: Input }],
    dataSource: [{ type: Input }],
    emptyMessage: [{ type: Input }],
    rowTrackBy: [{ type: Input }],
    rowHover: [{ type: Input }],
    loading: [{ type: Input }],
    selectionMode: [{ type: Input }],
    loadingIcon: [{ type: Input }],
    indentDetailRow: [{ type: Input }],
    indentationPerLevel: [{ type: Input }],
    showSubHeader: [{ type: Input }],
    children: [{ type: Input }],
    showExpansionControl: [{ type: Input }],
    expandAll: [{ type: Input }],
    outlineFormat: [{ type: Input }],
    pushRootSectionOnNewLine: [{ type: Input }],
    showRowDetailExpansionControl: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    showSelectAll: [{ type: Input }],
    showGlobalSearch: [{ type: Input }],
    scrollWidth: [{ type: Input }],
    dndRowEnabled: [{ type: Input }],
    onSort: [{ type: Output }],
    onRowClick: [{ type: Output }],
    onRowSelectionChange: [{ type: Output }],
    onCellChange: [{ type: Output }],
    onHeaderSelection: [{ type: Output }],
    header: [{ type: ContentChild, args: [DTHeaderComponent2,] }],
    emptyMessageTemplate: [{ type: ContentChild, args: ['noDataTempl',] }],
    headerTemplate: [{ type: ContentChild, args: ['dtHeader',] }],
    subHeaderTemplate: [{ type: ContentChild, args: ['dtSubHeader',] }],
    bodyTemplate: [{ type: ContentChild, args: ['dtBody',] }],
    headerFilterTemplate: [{ type: ContentChild, args: ['headerFilter',] }],
    colsQuery: [{ type: ContentChildren, args: [DTColumn2Component,] }],
    rowDetailColumn: [{ type: ContentChild, args: [DTDetailRowComponent,] }],
    valueChange: [{ type: Output }],
    classList: [{ type: HostBinding, args: ['class',] }],
    state: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Please see datatable for more detail description. But the main goal of this wrapper to remove
 * all the common surrounding parts around the datatable and make sure DT can focus only actual
 * header and body structure
 *
 * It is expected that wrapper also provides some code for the sliding up panel containing
 * buttons and other actions that will be used during editing
 *
 *
 * Todo: Extract the expand logic out into some directive or component or just a class
 *
 */
class DTWrapper extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} render
     * @param {?} thisElement
     * @param {?} domUtils
     * @param {?} platformId
     * @param {?} dt
     */
    constructor(env, render, thisElement, domUtils, platformId, dt) {
        super(env);
        this.env = env;
        this.render = render;
        this.thisElement = thisElement;
        this.domUtils = domUtils;
        this.platformId = platformId;
        this.dt = dt;
        /**
         * Color that is used by full screen div overlay to create expanding effect which needs to have
         * little tent;
         *
         */
        this.expandColorFrom = '#f3f3f3';
        /**
         * Color that is used to set after we are in the full screen so our overlay div hide everything
         * on the page
         *
         */
        this.expandColorTo = '#FFFFFF';
        /**
         * In order to debounce the typing we need to use subject
         *
         */
        this.searchTerms = new Subject();
        /**
         *  Specifies if we are in viewing/editing mode that can browse whole dataset lazily
         *
         */
        this.isFullScreenMode = false;
        /**
         * Tells if we can support full screen mode - only available for the browser
         *
         */
        this.supportFullScreen = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.querySubscription = this.searchTerms.pipe(
        // wait 300ms after each keystroke before considering the term
        debounceTime(300), 
        // ignore new term if same as previous term
        distinctUntilChanged(), switchMap((term) => of(term))).subscribe((term) => {
            if (isPresent(term)) {
                this.dt.dataSource.find(term);
            }
        });
        this.loadingSub = this.dt.valueChange
            .subscribe((data) => this.loadingFinished());
    }
    /**
     * Iterates over all columns marked as frozen and retrieve a width so we can update
     * parent div
     *
     * @return {?}
     */
    calculateFrozenWidth() {
        if (!this.dt.hasFrozenColumns()) {
            return null;
        }
        /** @type {?} */
        let fWidth = 0;
        this.dt.frozenColumns.forEach((col) => {
            if (col.maxWidthPx > 0) {
                fWidth += col.widestCell;
            }
            else {
                fWidth += parseInt(col.width);
            }
        });
        return fWidth;
    }
    /**
     * When having two separate tables we need to make sure that rows of the tables are aligned.
     *
     * Therefore this method takes first column from each table read the height of the rows and set
     * the max height to both rows.
     *
     *
     * @param {?} frozenView
     * @param {?} unFrozenView
     * @return {?}
     */
    alignTablesHeights(frozenView, unFrozenView) {
        assert(isPresent(frozenView) && isPresent(frozenView), 'Cant align table views as one of the view is undefined');
        /** @type {?} */
        let frozenRows = frozenView.querySelectorAll('table tr');
        /** @type {?} */
        let unFrozenRows = unFrozenView.querySelectorAll('table tr');
        assert(frozenRows.length === unFrozenRows.length, 'Frozen Column: Two tables does not much!');
        Array.from(frozenRows).forEach((frozen, index) => {
            /** @type {?} */
            let h = Math.max(frozen.offsetHeight, unFrozenRows[index].offsetHeight);
            frozen.style.height = h + 'px';
            unFrozenRows[index].style.height = h + 'px';
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initFullScreen();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.dt.hasFrozenColumns()) {
            /** @type {?} */
            let frozenView = this.thisElement.nativeElement.querySelector('.dt-body-frozen');
            /** @type {?} */
            let unFrozenView = this.thisElement.nativeElement.querySelector('.dt-body-unfrozen');
            /** @type {?} */
            let frozenWidth = this.calculateFrozenWidth();
            frozenView.style.width = frozenWidth + 'px';
            if (isPresent(unFrozenView)) {
                // include border and create indent effect by having 1px white space
                unFrozenView.style.left = (frozenWidth + 2) + 'px';
                unFrozenView.style.width = unFrozenView.parentElement.offsetWidth
                    - frozenView.offsetWidth + 'px';
                this.alignTablesHeights(frozenView, unFrozenView);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (isPresent(this.querySubscription)) {
            this.querySubscription.unsubscribe();
        }
        if (isPresent(this.loadingSub)) {
            this.loadingSub.unsubscribe();
        }
    }
    /**
     *
     * When fullscreen functionality is enabled this method switches between norml and full screen
     * mode
     *
     * @param {?} event
     * @return {?}
     */
    toggleFullScreen(event) {
        if (this.isFullScreenMode) {
            this.closeFullScreen(event);
        }
        else {
            this.openFullScreen(event);
        }
    }
    /**
     * To push this component to full screen mode or maybe full page mode we need run following:
     *
     *  - Execute expand transformation, where we have additional overlay div that we slowly expand
     *  and this creates impression the DT is expanding
     *
     *  - apply full-screen class on top host element  - in this case its DataTable to switch
     *  to absolute positioning
     *
     *  - make sure we are scrolled all the way up
     *
     *  - hide all the elements on the page so their dimension don't interfere with this table.
     *
     *
     * @param {?} event
     * @return {?}
     */
    openFullScreen(event) {
        this.isFullScreenMode = true;
        this.runExpandEffect();
        this.originalScrollPosition = window.pageYOffset;
        window.scroll(0, 0);
        this.toggleFullScreenOnDT(true);
        /** @type {?} */
        let parentNode = this.thisElement.nativeElement.parentNode;
        while (isPresent(parentNode) && parentNode.tagName !== 'BODY') {
            parentNode.classList.add('u-full-screen-element');
            parentNode = parentNode.parentNode;
        }
        this.hideNonFullScreenElement(document.body);
        this.dt.state.limit = Math.round(this.calculateLimit());
        this.dt.dataSource.fetch(this.dt.state);
        // once loaded set back correct page size we use when loading data
        this.dt.state.limit = this.dt.pageSize;
    }
    /**
     *
     * The same like above method (openFullScreen) but in reverse order.
     *
     * @param {?} event
     * @return {?}
     */
    closeFullScreen(event) {
        this.isFullScreenMode = false;
        this.showNonFullScreenElement();
        this.runCollapseEffect();
        this.toggleFullScreenOnDT(false);
        this.dt.dataSource.state.limit = this.dt.dataSource.state.displayLimit;
        this.dt.dataSource.state.offset = 0;
        this.dt.dataSource.fetch(this.dt.dataSource.state);
        setTimeout(() => {
            window.scroll(0, this.originalScrollPosition);
        }, 300);
    }
    /**
     * Applies set of set of css properties to make the DT main component on the page expand to
     * full page mode and back
     *
     * We want to make it with little delay to let other animation finish
     * @param {?} fullScreen
     * @return {?}
     */
    toggleFullScreenOnDT(fullScreen) {
        this.dt.el.nativeElement.style.opacity = 0;
        setTimeout(() => {
            if (fullScreen) {
                this.dt.classList += 'dt-full-screen';
                this.dt.el.nativeElement.style.opacity = 1;
            }
            else {
                this.dt.classList = this.dt.classList.replace('dt-full-screen', '');
                this.dt.el.nativeElement.style.opacity = 1;
            }
        }, 200);
    }
    /**
     * Listen for infinite scroll event and request new data from data source
     *
     * @param {?} event
     * @return {?}
     */
    onLazyLoad(event) {
        if (event.isLoad) {
            this.dt.state.offset = event.offset;
            this.dt.dataSource.fetch(this.dt.state);
        }
        else {
            /** @type {?} */
            let dataProvider = this.dt.dataSource.dataProvider;
            /** @type {?} */
            let data = dataProvider.dataChanges.getValue();
            dataProvider.dataChanges.next(data.slice(0, event.offset));
        }
    }
    /**
     * Creates animation effect to make it feel like the element (in this case DT) is expanding
     * from the middle to the full page mode.
     *
     * We take the dimension of the table then it is scaled slowly to the full page
     * @return {?}
     */
    runExpandEffect() {
        this.dtBoundingClientRect = this.thisElement.nativeElement.getBoundingClientRect();
        this.updateElement();
        this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorFrom;
        this.dtFullScreenOverlay.nativeElement.style.opacity = 1;
        this.applyTransformation(true);
        setTimeout(() => {
            this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorTo;
        }, 300);
    }
    /**
     * Applies the transformation and scale the helper div (overlay) down to make it look like
     * it collapses
     * @return {?}
     */
    runCollapseEffect() {
        this.updateElement();
        this.applyTransformation(false);
        setTimeout(() => {
            this.updateElement();
            this.dtFullScreenOverlay.nativeElement.style.opacity = 0;
        }, 200);
        setTimeout(() => {
            this.updateElement(this.dtBoundingClientRect.left, this.dtBoundingClientRect.top, 0, 0);
        }, 400);
    }
    /**
     * DFS  - to go thru all the element under BODY and remove them from the page.
     *
     * @param {?} parentElement
     * @return {?}
     */
    hideNonFullScreenElement(parentElement) {
        if (this.thisElement.nativeElement.parentNode === parentElement) {
            return;
        }
        for (let i = 0; i < parentElement.children.length; i++) {
            /** @type {?} */
            let element = parentElement.children[i];
            if (this.needTraverseDown(element)) {
                this.hideNonFullScreenElement(element);
            }
            else if (!element.classList.contains('dt-full-screen')) {
                element.classList.add('u-fs-element-out');
            }
        }
    }
    /**
     * Put all the element that were previously removed by hideNonFullScreenElement() back
     * @return {?}
     */
    showNonFullScreenElement() {
        Array.from(document.querySelectorAll('.u-fs-element-out'))
            .forEach((elem) => elem.classList.remove('u-fs-element-out'));
    }
    /**
     * \@Internal
     *
     * @param {?} element
     * @return {?}
     */
    needTraverseDown(element) {
        return isPresent(element) && element.tagName !== 'SCRIPT' &&
            element.classList.contains('u-full-screen-element') &&
            !element.classList.contains('dt-full-screen');
    }
    /**
     * When we enter full screen /page mode when need to calculate how many rows to load initially
     *
     * @return {?}
     */
    calculateLimit() {
        /** @type {?} */
        let browserH = this.domUtils.browserDimentions().height;
        /** @type {?} */
        let rowH = this.dt.el.nativeElement.querySelector('tbody tr:first-child').offsetHeight;
        return (isPresent(rowH) && rowH > 0) ? (browserH / rowH) + 20 : 50;
    }
    /**
     * \@Internal
     *
     * @param {?=} l
     * @param {?=} t
     * @param {?=} w
     * @param {?=} h
     * @return {?}
     */
    updateElement(l = this.dtBoundingClientRect.left, t = this.dtBoundingClientRect.top, w = this.dtBoundingClientRect.width, h = this.dtBoundingClientRect.height) {
        this.dtFullScreenOverlay.nativeElement.style.left = l + 'px';
        this.dtFullScreenOverlay.nativeElement.style.top = t + 'px';
        this.dtFullScreenOverlay.nativeElement.style.width = w + 'px';
        this.dtFullScreenOverlay.nativeElement.style.height = h + 'px';
    }
    /**
     * \@Internal
     *
     * @param {?} expand
     * @return {?}
     */
    applyTransformation(expand) {
        /** @type {?} */
        let x;
        /** @type {?} */
        let y;
        /** @type {?} */
        let tx;
        /** @type {?} */
        let ty;
        if (expand) {
            x = window.innerWidth / this.dtBoundingClientRect.width;
            y = window.innerHeight / this.dtBoundingClientRect.height;
            tx = (window.innerWidth / 2 - this.dtBoundingClientRect.width / 2
                - this.dtBoundingClientRect.left) / x;
            ty = (window.innerHeight / 2 - this.dtBoundingClientRect.height / 2
                - this.dtBoundingClientRect.top) / y;
        }
        else {
            x = 1;
            y = 1;
            tx = this.dtBoundingClientRect.left;
            ty = this.dtBoundingClientRect.top;
        }
        this.dtFullScreenOverlay.nativeElement.style.transform =
            'scaleX(' + x + ') scaleY(' + y + ') translate3d(' + (tx) + 'px, ' + (ty) + 'px, 0px)';
    }
    /**
     * INFINITE SCROLLING METHODS
     * @return {?}
     */
    initFullScreen() {
        if (!isPlatformBrowser(this.platformId)) {
            this.supportFullScreen = false;
            return;
        }
        this.render.appendChild(document.body, this.dtFullScreenOverlay.nativeElement);
    }
    /**
     * When loading is finished mark loading icon is done so we can hide it. I am using little
     * delay to make the animation visible
     * @return {?}
     */
    loadingFinished() {
        if (isPresent(this.infiniteScroll)) {
            setTimeout(() => this.infiniteScroll.complete(), 200);
        }
    }
}
DTWrapper.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-wrapper',
                template: "<div [ngClass]=\"dt.styleClass\" [class.dt-full-screen-mode]=\"isFullScreenMode\"\n     [style.width]=\"dt.width\"\n>\n    <div class=\"dt-loading-overlay\" *ngIf=\"dt.loading\"></div>\n    <div class=\"dt-loading-content\" *ngIf=\"dt.loading\">\n        <i [class]=\"'sap-icon u-dt-spin-icon ' + dt.loadingIcon\"></i>\n    </div>\n\n    <div class=\"dt-header\" *ngIf=\"dt.showTableHeader\">\n        <ng-template *ngIf=\"dt.header; then appDefinedHeader else defaultHeader\"></ng-template>\n    </div>\n\n    <!-- DT BODY with table headers and values -->\n    <div class=\"dt-body-wrapper-view\">\n        <ng-template\n            *ngIf=\"dt.hasFrozenColumns(); then dtBodyWithFrozenColumns else dtBodyNoFrozenColumns\">\n        </ng-template>\n    </div>\n\n    <!--<div class=\"dt-footer\" *ngIf=\"footer\">-->\n    <!--&lt;!&ndash; footerArea&ndash;&gt;-->\n    <!--<ng-content select=\"aw-dt-footer\"></ng-content>-->\n    <!--</div>-->\n</div>\n\n<!-- todo: dont activate this if we reached the end of list - -->\n<aw-infinite-scroll #infiniteScroll *ngIf=\"isFullScreenMode\"\n                    [distance]=\"'10%'\"\n                    [fetchSize]=\"dt.state.limit\"\n                    (onLoad)=\"onLazyLoad($event)\">\n</aw-infinite-scroll>\n\n\n<ng-template #appDefinedHeader>\n    <ng-container *ngTemplateOutlet=\"heading;\"></ng-container>\n</ng-template>\n\n<ng-template #defaultHeader>\n    <div class=\"dt-global-filter\">\n        <span class=\"sap-icon icon-filter\"></span>\n    </div>\n\n    <div class=\"dt-global-actions\">\n        <div class=\"dt-action-combo\">\n            <span *ngIf=\"supportFullScreen\" class=\"sap-icon icon-resize\"\n                  (click)=\"toggleFullScreen($event)\"></span>\n\n            <aw-input-field *ngIf=\"dt.showGlobalSearch\" styleClass=\"dt-table-search\"\n                            [(ngModel)]=\"dt.state.currentSearchQuery\"\n                            placeHolder=\"search\"\n                            icon=\"icon-search\"\n                            (ngModelChange)=\"searchTerms.next($event)\">\n            </aw-input-field>\n            <span class=\"ariba-icon icon-more\"></span>\n        </div>\n    </div>\n</ng-template>\n\n<!--\n    Each section frozen/non-frozen is calculated inside table-wrapper in the ngAfterViewChecked, where we set\n    proper width for each frame as well as left coordinates for the right one\n-->\n<ng-template #dtBodyNoFrozenColumns>\n    <!--\n        For non-frozen case we also need to set TRUE as the view is actually frozen and does not\n        scroll.\n        We use this frozenColumns flag inside DT to properly set column index on the header level\n        columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))\n\n        therefore we need to set true even in this case to return real columnIndex since we dont\n        have the second table.\n    -->\n    <ng-container *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: true }\">\n    </ng-container>\n</ng-template>\n\n<ng-template #dtBodyWithFrozenColumns>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.frozenColumns, frozenColumns: true }\">\n    </ng-container>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: false }\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #dtBody let-columns let-frozenColumns=\"frozenColumns\">\n\n    <div #dtContainer class=\"dt-body-wrapper\"\n         [style.width.px]=\"this.calculateFrozenWidth()\"\n         [class.dt-body-unfrozen]=\"dt.hasFrozenColumns() && !frozenColumns\"\n         [class.dt-body-frozen]=\"dt.hasFrozenColumns() && frozenColumns\"\n    >\n\n        <table [ngClass]=\"dt.tableStyleClass\"\n               [style.width]=\"frozenColumns ? null : dt.scrollWidth\"\n               [class.dt-pivot-layout]=\"dt.pivotalLayout\"\n               [class.dt-plain-layout]=\"!dt.pivotalLayout && !dt.isOutline()\">\n\n            <!-- Render TH header rows-->\n            <thead class=\"dt-thead\">\n            <ng-container *ngTemplateOutlet=\"headerRows; context:{$implicit: columns,frozenColumns:frozenColumns }\">\n            </ng-container>\n            </thead>\n\n            <!--\n                Render data rows. For data rows we need to keep tbody tag inside DT table\n                due to Outline\n             -->\n            <ng-container *ngTemplateOutlet=\"bodyRows; context:{$implicit: columns,  frozenColumns:frozenColumns }\">\n            </ng-container>\n        </table>\n    </div>\n</ng-template>\n\n\n<div #dtFullScreenOverlay class=\"dt-full-screen-overlay u-full-screen-element\"></div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".dt-footer,.dt-header{text-align:center;padding:.5em .75em;box-sizing:border-box}.dt-footer{border-top:0}.dt-thead tr{border-width:0}.dt-body-wrapper-view{position:relative}.dt-body-wrapper{overflow:hidden;border:1px solid #d7d7d7}.dt-body-wrapper.dt-body-unfrozen{border-left-color:transparent;position:absolute;top:0;overflow-x:auto}.dt-loading-overlay{position:absolute;background-color:#9b9b9b;width:100%;height:100%;opacity:.1;z-index:1}.dt-loading-content{position:absolute;left:50%;top:25%;z-index:2}.dt-header{width:100%;display:flex;flex-flow:row nowrap;justify-content:space-between;color:#363636;border-bottom:1px solid #f1f1f1;margin-bottom:30px}.dt-header .dt-global-filter{flex:0 0;align-items:flex-start;font-size:18px}.dt-header .dt-global-actions{flex:0 0;align-items:flex-end}.dt-header .dt-action-combo{display:flex;flex-flow:row nowrap;color:#7d7d7d}.dt-header .dt-action-combo .ariba-icon,.dt-header .dt-action-combo .sap-icon{margin-left:15px;font-size:20px;-ms-grid-row-align:center;align-self:center;cursor:pointer}.dt-header .dt-action-combo .dt-table-search{border-top-color:transparent;border-left-color:transparent;border-right-color:transparent}.dt-header .dt-action-combo .icon-resize{color:#4a4a4a;font-size:16px;line-height:18px;margin-right:15px}.u-dt-spin-icon{display:inline-block;-webkit-animation:2s linear infinite doSpin;animation:2s linear infinite doSpin}@-webkit-keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dt-full-screen-overlay{position:fixed;z-index:100;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transition:.4s ease-in-out}.dt-full-screen{width:98vw;z-index:120;position:absolute;top:15px;pointer-events:all;transition:opacity .5s ease-in-out}.u-fs-element-out{display:none}"]
            }] }
];
/** @nocollapse */
DTWrapper.ctorParameters = () => [
    { type: Environment },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DomUtilsService },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: Datatable2Component, decorators: [{ type: Inject, args: [forwardRef(() => Datatable2Component),] }] }
];
DTWrapper.propDecorators = {
    expandColorFrom: [{ type: Input }],
    expandColorTo: [{ type: Input }],
    heading: [{ type: ContentChild, args: ['headingArea',] }],
    headerRows: [{ type: ContentChild, args: ['headerRows',] }],
    bodyRows: [{ type: ContentChild, args: ['bodyRows',] }],
    footer: [{ type: ContentChild, args: ['footerArea',] }],
    dtFullScreenOverlay: [{ type: ViewChild, args: ['dtFullScreenOverlay',] }],
    infiniteScroll: [{ type: ViewChild, args: ['infiniteScroll',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * This directive is responsible for checking and setting the widest content width onto
 * Column component as the widestCell property.
 *
 * We use this directive inside dt-column.component to store a current width for each td,th
 *
 *
 */
class SetCellMaxWidthDirective {
    /**
     * @param {?} element
     * @param {?} render
     * @param {?} td
     */
    constructor(element, render, td) {
        this.element = element;
        this.render = render;
        this.td = td;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('Cell Max Width: ' + this.dtMaxWidth, this.dtMaxWidth > 0);
        if (isPresent(this.dtMaxWidth) && this.dtMaxWidth > 0) {
            /** @type {?} */
            let inlineData = this.element.nativeElement.querySelector('.dt-col-cell-data');
            if (isPresent(inlineData)) {
                inlineData.style.whiteSpace = 'nowrap';
                inlineData.style.display = 'inline-block';
                /** @type {?} */
                let cellWidth = inlineData.offsetWidth; // td
                inlineData.style.whiteSpace = 'normal';
                inlineData.style.display = 'inline';
                if (!this.isInThresHold(cellWidth)) {
                    return;
                }
                cellWidth += this.tdPadding();
                if (cellWidth > this.td.widthPx) {
                    if (cellWidth < this.dtMaxWidth) {
                        this.td.widestCell = cellWidth > this.td.widestCell ? cellWidth :
                            this.td.widestCell;
                    }
                    else if (cellWidth >= this.dtMaxWidth) {
                        this.td.widestCell = (this.dtMaxWidth > this.td.widestCell)
                            ? this.dtMaxWidth : this.td.widestCell;
                    }
                }
            }
        }
    }
    /**
     *
     * Is the new width the same as the one already set on the column? If yes then probably
     * new content does not differ that much. We still keep certain threshold as the new content
     * width might differ 1 or 2 pixes depending how set the css.
     *
     * To make sure we resize column only if necessary because it could be original size
     * is 400px but the new one is 401px since somewhere add some extra border we have this
     * safe threshold
     *
     * @param {?} newWidth
     * @return {?}
     */
    isInThresHold(newWidth) {
        if (this.td.widestCell > 0) {
            return Math.abs(this.td.widestCell - newWidth) > 3 && newWidth > this.td.widestCell;
        }
        return true;
    }
    /**
     * @return {?}
     */
    tdPadding() {
        /** @type {?} */
        let computedStyle = getComputedStyle(this.element.nativeElement);
        /** @type {?} */
        let cell = parseInt(computedStyle.paddingLeft) || 0;
        cell += parseInt(computedStyle.paddingRight) || 0;
        cell += parseInt(computedStyle.borderRightWidth) || 0;
        cell += parseInt(computedStyle.borderLeftWidth) || 0;
        // plus give it some little space around the text so it nots px to px inner width of the td
        // cuz it could wrap
        cell += 5;
        return cell;
    }
}
SetCellMaxWidthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dtMaxWidth]'
            },] }
];
/** @nocollapse */
SetCellMaxWidthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DTColumn2Component }
];
SetCellMaxWidthDirective.propDecorators = {
    dtMaxWidth: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Directive used inside DT in order to support table rows re-ordering. This manages all the
 * D&D necessary logic for this functionality.
 *
 * [dtDraggableRow] is used inside the `rowTemplate` like this:
 *
 *
 * ```html
 *
 * <ng-template #rowTemplate let-rowData let-even='event" let-odd="odd" let-rowIndex="rowIndex"
 *              let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">
 *
 *     <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
 *          class="dt-body-row"
 *
 *
 *
 * ```
 *
 * which enabled or disables based on the used DT binding [dndRowEnabled]. By default its disabled.
 *
 *
 *
 */
class DTDraggableRowDirective {
    /**
     * @param {?} element
     * @param {?} dt
     * @param {?} domUtils
     * @param {?} ngZone
     */
    constructor(element, dt, domUtils, ngZone) {
        this.element = element;
        this.dt = dt;
        this.domUtils = domUtils;
        this.ngZone = ngZone;
        /**
         *
         * Tells the directive if we enable middle row zone to create an effect that we are dropping
         * into the row. Used for outline DT mainly.
         *
         */
        this.dropIntoEnabled = false;
        /**
         * Current TR index number
         *
         */
        this.dndRowIndex = 0;
        /**
         * Holds information about our dragging direction UP and DOWN in order to assign correct style
         * that highlights the row at the top or bottom
         *
         */
        this.dragDir = DragDirection.None;
        /**
         * Indicates that we dragged our row and stopped in the middle of the other row
         *
         */
        this.inMiddle = false;
        /**
         *
         * Current drag Y coordinates which is used together with the dragDir when assinging dragging
         * direction.
         *
         */
        this.dragY = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dt.dndRowEnabled) {
            this.setupEventListeners();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.dt.dndRowEnabled) {
            this.releaseEventListeners();
        }
    }
    /**
     * Setups listeners and returns handle to them so we can later on unsubscribe.
     * @return {?}
     */
    setupEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            this.eventHandlers = {};
            this.eventHandlers['mousedown'] = this.onMouseDownEvent.bind(this);
            this.element.nativeElement.addEventListener('mousedown', this.eventHandlers['mousedown']);
            this.eventHandlers['dragstart'] = this.onDragStartEvent.bind(this);
            this.element.nativeElement.addEventListener('dragstart', this.eventHandlers['dragstart']);
            this.eventHandlers['dragover'] = this.onDragOverEvent.bind(this);
            this.element.nativeElement.addEventListener('dragover', this.eventHandlers['dragover']);
            this.eventHandlers['dragleave'] = this.onDragLeaveEvent.bind(this);
            this.element.nativeElement.addEventListener('dragleave', this.eventHandlers['dragleave']);
            this.eventHandlers['drop'] = this.onDropEvent.bind(this);
            this.element.nativeElement.addEventListener('drop', this.eventHandlers['drop']);
            this.eventHandlers['dragend'] = this.onDragEndEvent.bind(this);
            this.element.nativeElement.addEventListener('dragend', this.eventHandlers['dragend']);
        });
    }
    /**
     * Removes all the created listeners inside destroy() callback
     * @return {?}
     */
    releaseEventListeners() {
        DragEvents.forEach((name) => {
            document.removeEventListener('name', this.eventHandlers[name]);
        });
    }
    /**
     *
     * This is first event where we:
     *
     *  - Mark element draggable to enable D&D
     *  - Set click position relative to the middle of the current row
     *      This is mainly needed when we are trying to calculate something for
     *      dropInto row (outline)
     *
     * event.target usually contains reference to TD element
     * @param {?} event
     * @return {?}
     */
    onMouseDownEvent(event) {
        if (event.altKey && this.domUtils.hasParent(event.target, '.dt-row-draggable')) {
            this.element.nativeElement.draggable = true;
            /** @type {?} */
            let elToBeDragged = this.domUtils.elementDimensions(event.target);
            this.dt.env.setValue('ddClickDeviance', (elToBeDragged.height / 2) - event.offsetY);
        }
        else {
            this.element.nativeElement.draggable = false;
        }
    }
    /**
     * This is second triggered event when the actual dragging starts. Here we need to disable
     * dragged row and save information that are common to a table.
     *
     * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
     * if we would go without it then D&D framework would create a copy of row in disabled state.
     * Now we grab a row with active state and after a 200ms delay we disable the original row.
     *
     * @param {?} event
     * @return {?}
     */
    onDragStartEvent(event) {
        setTimeout(() => {
            if (isPresent(event.target.classList)) {
                event.target.classList.add('dt-row-dragging');
            }
        }, 200);
        this.dt.env.setValue('isDragging', true);
        this.dt.env.setValue('dndId', this.dndRowIndex);
        event.dataTransfer.setData('text', this.dndRowIndex);
    }
    /**
     *
     * This events happens anytime as we drag over rows. This event triggered after certain
     * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
     *
     * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
     * show a user where we are.
     *
     * Once we know the direction and the drop target is valid we mark the row with correct class
     * that does the trick
     * @param {?} event
     * @return {?}
     */
    onDragOverEvent(event) {
        event.dataTransfer.dropEffect = 'move';
        if (this.dragY < event.pageY) {
            this.dragDir = DragDirection.Down;
        }
        else if (this.dragY > event.pageY) {
            this.dragDir = DragDirection.Up;
        }
        // dont set again unless its different
        if (this.dragY !== event.pageY) {
            this.dragY = event.pageY;
        }
        if (this.isValidDropTarget(event)) {
            // todo test this preventDefault() so it does not create some sideeffect
            event.preventDefault();
            this.markRowWithClass(event, this.domUtils.closest(event.target, 'tr'));
        }
    }
    /**
     * This is finishing event just before D&D is done. It takes current information and
     * broadcast them to the DT so DT can do necessary row reordering
     *
     *
     * @param {?} event
     * @return {?}
     */
    onDropEvent(event) {
        this.clearClasses(event.target.parentElement);
        /** @type {?} */
        let origIndx = this.dt.env.getValue('dndId');
        /** @type {?} */
        let dropPos = this.inMiddle ? DropPosition.Into : (this.dragDir === DragDirection.Up ? DropPosition.Before : DropPosition.After);
        this.dt.onDnDRowDrop(origIndx, this.dndRowIndex, dropPos);
        this.inMiddle = false;
        this.dragY = 0;
    }
    /**
     * Every time we drag over the element we apply some classes to the it. this method does the
     * opposite which is to remove everything so we are ready for the next row
     *
     *
     * @param {?} event
     * @return {?}
     */
    onDragLeaveEvent(event) {
        /** @type {?} */
        let tr = this.domUtils.closest(event.target, 'tr');
        this.clearClasses(tr);
        this.dt.env.deleteValue('dndOnHoldIndex');
    }
    /**
     *
     * This is last event within D&D flow. Mainly used to clean up all the resource that has not
     * been clean up already inside onDropEvent.
     *
     * @param {?} event
     * @return {?}
     */
    onDragEndEvent(event) {
        if (isPresent(event.target.classList)) {
            event.target.classList.remove('dt-row-dragging');
        }
        this.clearClasses(event.target);
        this.element.nativeElement.draggable = false;
        this.dt.env.deleteValue('isDragging');
        this.dt.env.deleteValue('dndId');
        this.dt.env.deleteValue('ddClickDeviance');
    }
    /**
     * Assign CSS classes to the row to create an highlighting effect to capture current position
     * for the user.
     *
     * Based on the Drag direction we either apply
     * css class that creates a line on top or bottom.  Only for the dropInto functionality we
     * need to calculate some more to identify if we are really in the middle of the row.
     *
     * DropInto:
     * ---------
     *
     * Initially we captured a position (in mousedown) the distance to the middle of the row and
     * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
     * perfect.
     *
     * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
     *      Read center of current row
     *
     * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
     *      Read mouse coordinates relative to current row/td and add to it our deviation.
     *
     *
     * @param {?} event
     * @param {?} activeRow
     * @return {?}
     */
    markRowWithClass(event, activeRow) {
        this.clearClasses(activeRow);
        /** @type {?} */
        let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
        /** @type {?} */
        let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
        if (this.dropIntoEnabled) {
            this.inMiddle = Math.abs(currentTrCenter - draggedTrCenter) < 2;
        }
        if (this.inMiddle) {
            activeRow.classList.add(DragDirection.Middle);
        }
        else {
            activeRow.classList.add(this.dragDir);
        }
    }
    /**
     *
     * Drop target must be only another TR and it cannot be the element itself the one we are
     * dragging and it does not make sense to allow to drop to the same position we started from
     *
     * @param {?} event
     * @return {?}
     */
    isValidDropTarget(event) {
        /** @type {?} */
        let origInx = this.dt.env.getValue('dndId');
        /** @type {?} */
        let siblingRow = this.dndRowIndex - origInx;
        return event.target.parentElement.tagName === 'TR' && this.dndRowIndex !== origInx &&
            !(siblingRow === 1 && this.dragDir === DragDirection.Up) &&
            !(siblingRow === -1 && this.dragDir === DragDirection.Down);
    }
    /**
     *  private
     *
     * @param {?} tr
     * @return {?}
     */
    clearClasses(tr) {
        tr.classList.remove('dt-drag-row-top');
        tr.classList.remove('dt-drag-row-bottom');
        tr.classList.remove('dt-drag-row-both');
    }
    /**
     *  private
     *
     * @return {?}
     */
    dragDirToString() {
        switch (this.dragDir) {
            case DragDirection.Up:
                return 'Up';
            case DragDirection.Down:
                return 'Down';
            default:
                return 'Not Sure';
        }
    }
}
DTDraggableRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dtDraggableRow]'
            },] }
];
/** @nocollapse */
DTDraggableRowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Datatable2Component, decorators: [{ type: Inject, args: [forwardRef(() => Datatable2Component),] }] },
    { type: DomUtilsService },
    { type: NgZone }
];
DTDraggableRowDirective.propDecorators = {
    dropIntoEnabled: [{ type: Input }],
    dndRowIndex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWDatatable2Module {
}
AWDatatable2Module.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Datatable2Component,
                    DTWrapper,
                    DTColumn2Component,
                    DTHeaderComponent2,
                    DTDetailRowComponent,
                    DTDetailRowExpanderComponent,
                    DTMultiSelectColumnComponent,
                    DTSingleSelectColumnComponent,
                    DTDraggableRowDirective,
                    SetCellMaxWidthDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    AWCoreComponentModule,
                    AWCheckBoxModule,
                    AWOutlineForModule,
                    AWRadioButtonModule,
                    AWInputFieldModule
                ],
                entryComponents: [
                    DTDetailRowExpanderComponent,
                    DTMultiSelectColumnComponent,
                    DTSingleSelectColumnComponent
                ],
                exports: [
                    Datatable2Component,
                    DTColumn2Component,
                    AWOutlineForModule,
                    DTHeaderComponent2,
                    DTDetailRowComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * An confirmation header area.
 *
 * See {\@link ConfirmationComponent} for more explanation.
 */
class ConfirmationHeaderComponent {
}
ConfirmationHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-confirmation-header',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * An confirmation header area.
 *
 * See {\@link ConfirmationComponent} for more explanation.
 */
class ConfirmationFooterComponent {
}
ConfirmationFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-confirmation-footer',
                template: '<ng-content></ng-content>'
            }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Confirmation Component is a specific version of the dialog where it supports confirm and cancel
 * functionality. It behaves like a dialog, is modal, and not closable by default.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<ConfirmationComponent>), service.close()
 *
 * Usage:
 *    1.  Using ModalService directly to display a modal popup. This usage is a quick way to show
 *        a confirmation to the user.
 *
 *          this.modalService.open<ConfirmationComponent>(ConfirmationComponent, {
 *                        title: 'Confirmation',
 *                        body: ` Are you sure ? `,
 *                        width: 300,
 *                        onConfirm: () => {
 *                              this.confirmAction();
 *                        },
 *                        onCancel: () => {
 *                              this.cancelAction();
 *                        }
 *           });
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                              <aw-confirmation [title]="'Confirmation'"
 *                                      [(visible)]="display"
 *                                     (onConfirm)="confirmAction()"
 *                                    (onCancel)="cancelAction()">
 *                                       <i class="sap-icon icon-alert"></i>
 *                                       Are you sure you want to delete your hard drive?
 *                            </aw-confirmation>
 *
 *                                   <aw-button [size]="'small'" (click)="open()">
 *                                       Open Confirmation
 *                                   </aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     display: boolean = false;
 *
 *                     confirmAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     open() {
 *                        this.display = true;
 *                     }
 *
 *                     confirmAction()  {
 *                        this.confirmAction = "confirmed";
 *                      }
 *
 *                      close() {
 *                         this.display = false;
 *                      }
 *
 *                      cancelAction() {
 *                          this.confirmAction = "canceled";
 *                      }
 *
 *       }
 *
 *
 */
class ConfirmationComponent extends ModalContainer {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * support two way data binding on visible property.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether there's an x at the top right that makes the dialog closable.
         */
        this.closable = false;
        /**
         * Event fired when dialog is closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event fired when the dialog is opened.
         */
        this.onOpen = new EventEmitter();
        /**
         * Fired when user clicked on confirm button.
         */
        this.onConfirm = new EventEmitter();
        /**
         * Fired when user clicked on cancel button.
         */
        this.onCancel = new EventEmitter();
        this.width = 400;
        this.height = 'auto';
        // Todo: internationalize.
        this.confirmActionLabel = 'Confirm';
        this.cancelActionLabel = 'Cancel';
    }
    /**
     * open confirmation.
     * @return {?}
     */
    open() {
        this.visible = true;
        this.onOpen.emit();
        this.visibleChange.emit(true);
    }
    /**
     * close confirmation.
     * @return {?}
     */
    close() {
        this.visible = false;
        this.onClose.emit();
        // Important to make sure change is set on parent binding.
        // Otherwise, the variable and dialog open/close state can be out
        // of sync and we wouldn't trigger change detection.
        this.visibleChange.emit(false);
    }
    /**
     * Does the confirmation have header content?
     * @return {?}
     */
    hasHeader() {
        return isPresent(this.header);
    }
    /**
     * Does the confirmation have footer content?
     * @return {?}
     */
    hasFooter() {
        return isPresent(this.footer);
    }
    /**
     * Confirm action.
     * @return {?}
     */
    confirm() {
        this.close();
        this.onConfirm.emit();
    }
    /**
     * Cancel action.
     * @return {?}
     */
    cancel() {
        this.close();
        this.onCancel.emit();
    }
}
ConfirmationComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-confirmation',
                template: "<aw-dialog [title]=\"title\" [(visible)]=\"visible\"\n           [modal]=\"true\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n           [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onOpen)=\"open()\" (onClose)=\"close()\">\n\n    <aw-dialog-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-confirmation-header\"></ng-content>\n    </aw-dialog-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n\n    <aw-dialog-footer *ngIf=\"hasFooter(); else defaultFooter\">\n        <ng-content select=\"aw-confirmation-footer\"></ng-content>\n    </aw-dialog-footer>\n\n    <ng-template #defaultFooter>\n        <aw-dialog-footer>\n            <aw-button name=\"confirm\" [style]=\"'primary'\" (action)=\"confirm()\">\n                {{confirmActionLabel}}\n            </aw-button>\n\n            <aw-button name=\"cancel\" [style]=\"'secondary'\" (action)=\"cancel()\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n        </aw-dialog-footer>\n    </ng-template>\n\n</aw-dialog>\n",
                styles: [".confirmation-footer-separator{border-top:1px solid #d7d7d7;height:14px}"]
            }] }
];
/** @nocollapse */
ConfirmationComponent.ctorParameters = () => [
    { type: Environment }
];
ConfirmationComponent.propDecorators = {
    title: [{ type: Input }],
    body: [{ type: Input }],
    confirmActionLabel: [{ type: Input }],
    cancelActionLabel: [{ type: Input }],
    visibleChange: [{ type: Output }],
    closable: [{ type: Input }],
    appendTo: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    onConfirm: [{ type: Output }],
    onCancel: [{ type: Output }],
    header: [{ type: ContentChild, args: [ConfirmationHeaderComponent,] }],
    footer: [{ type: ContentChild, args: [ConfirmationFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWConfirmationModule {
}
AWConfirmationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ConfirmationComponent,
                    ConfirmationHeaderComponent,
                    ConfirmationFooterComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                    AWDialogModule,
                    AWButtonModule
                ],
                entryComponents: [
                    ModalComponent,
                    ConfirmationComponent,
                    ConfirmationHeaderComponent,
                    ConfirmationFooterComponent
                ],
                exports: [
                    ConfirmationComponent,
                    ConfirmationHeaderComponent,
                    ConfirmationFooterComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * Container panel providing scrolling functionality for its children. You can configure this
 * container to let it to scroll its content either horizontally, vertically or let the content
 * wrap.
 *
 *
 * Usage is pretty simple:
 *
 *  ### Example using horizontal scroll (default behavior):
 *
 *  ```
 *            <aw-scrollable>
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *
 *  ```
 *
 *  ### Example using vertical scroll:
 *
 *  ```
 *            <aw-scrollable [direction]="'vertical'" [height]="'40vh'">
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *
 * ```
 *
 *  ### Example scrolling is disabled and content wraps and centers:
 *
 *  ```
 *            <aw-scrollable [direction]="'none'" [alignment]="'center'">
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *  ```
 *
 * ### Height property:
 *
 * When using "horizontal scrolling" it set "flexbox-direction" to "row" where height
 * is set automatically based on its content. The height should be always 100% when using
 * this in parent container.
 *
 * If "vertical scrolling" is used you need to make sure that:
 *   - your parent container sets the boundaries with correctly set width and height
 *   otherwise it will use 100% of the viewport
 *   - if used as standalone you need to limit the height otherwise it will expand to 100% of
 *   the document
 *
 *
 *
 *
 */
class ScrollableContainerComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} elementRef
     */
    constructor(env, elementRef) {
        super(env);
        this.env = env;
        this.elementRef = elementRef;
        /**
         * Defines scrolling direction of the container meaning tells which overflow axies will be
         * disabled or enabled.
         *
         * Default value is "horizontal": Here we lock overflow-y and overflow-x set to auto.
         *
         * When scrolling direction is "vertical" please make sure you maintain correct height and
         * width.
         *
         */
        this.direction = 'horizontal';
        /**
         * Defines how flexbox container items should be aligned. Default behavior is LEFT
         *
         */
        this.alignment = 'left';
        this.height = '100%';
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initDefault();
    }
    /**
     * Make sure we re-initialize default when Input Bindings changes
     *
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.initDefault();
    }
    /**
     * Initialize default values and Calculates layout and alignment class. The reason for using
     * these utility classes is that we can change the behavior anytime as compared to using
     * directly [style.xxx] bindings.
     *
     * ### Direction flow class:
     *  - u-scrollable-f<direction>
     *
     * ### Alignment class:
     *  - u-scrollable-a<alignment>
     *
     * @return {?}
     */
    initDefault() {
        this.layoutClass = 'u-scrollable-fh';
        if (this.direction === 'vertical') {
            this.layoutClass = 'u-scrollable-fv';
        }
        if (this.direction === 'vertical-row') {
            this.layoutClass = 'u-scrollable-fv-row';
        }
        else if (this.direction === 'both') {
            this.layoutClass = 'u-scrollable-fb';
        }
        else if (this.direction === 'none') {
            this.layoutClass = 'u-scrollable-fn';
        }
        this.layoutClass += ' u-scrollable-a' + this.alignment.substring(0, 1);
        if (isPresent(this.styleClass)) {
            this.layoutClass += ` ${this.styleClass}`;
        }
        // make sure we default width and height to some value in case somebody passes null
        if (isBlank(this.width)) {
            this.width = '100%';
        }
        if (isBlank(this.height)) {
            this.height = '100%';
        }
    }
    /**
     * Tells if the horizontal scrollbar is visible
     *
     * @return {?}
     */
    hasHorizontalScroll() {
        /** @type {?} */
        let scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
        return scrollContainer.scrollWidth > scrollContainer.clientWidth;
    }
    /**
     * Tells if the vertical scrollbar is visible
     *
     * @return {?}
     */
    hasVerticalScroll() {
        /** @type {?} */
        let scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
        return scrollContainer.scrollHeight > scrollContainer.clientHeight;
    }
}
ScrollableContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-scrollable',
                template: "<div class=\"w-scrollable\" [ngClass]=\"layoutClass\" [style.width]=\"width\"\n     [style.height]=\"height\">\n    <ng-content></ng-content>\n</div>\n",
                styles: [".w-scrollable{display:flex;display:-webkit-flex;backface-visibility:hidden;-webkit-backface-visibility:hidden;will-change:overflow}.w-scrollable /deep/>*{flex:0 0 auto;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;margin:10px}.u-scrollable-fh{flex-flow:row nowrap;overflow-x:auto;overflow-y:hidden}.u-scrollable-fv{flex-flow:column nowrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fb{flex-flow:row nowrap;overflow-x:auto;overflow-y:auto}.u-scrollable-fv-row{flex-flow:row wrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fn{flex-flow:row wrap}.u-scrollable-al{justify-content:flex-start;-webkit-justify-content:flex-start}.u-scrollable-ar{justify-content:flex-end;-webkit-justify-content:flex-end}.u-scrollable-ac{justify-content:center;-webkit-justify-content:center}.u-scrollable-aj,.u-scrollable-aj-around{justify-content:space-between;-webkit-justify-content:space-between}"]
            }] }
];
/** @nocollapse */
ScrollableContainerComponent.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef }
];
ScrollableContainerComponent.propDecorators = {
    direction: [{ type: Input }],
    alignment: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWScrollableContainerModule {
}
AWScrollableContainerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ScrollableContainerComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    ScrollableContainerComponent
                ],
                exports: [
                    ScrollableContainerComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const LB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ListComponent),
    multi: true
};
/**
 *
 * The List component represent a structure which contains a list of selectable items. Items
 * selection can be configured in single-selection, multi-selection or multi-selection with visible
 * checkboxes mode.
 * In addition it can display data inside 3 zones LEFT, MIDDLE and RIGHT in order to provide
 * easy way for application developer to layout its own custom content or even change out of box
 * behavior.
 *
 *
 *  ### Examples
 *
 *  1. Render simple single selection list
 *
 *  ```html
 *
 *      <aw-list [list]="list"></aw-list>
 *
 *  ```
 *  2. Render list - multi selection with custom RIGHT content to show a CheckMark when item
 *  is selected
 *
 *  ```html
 *
 *   <aw-list #awlist [list]="list"
 *                       height="150px"
 *                       width="250px"
 *                       [selectionMode]="'multi'">
 *
 *                  <ng-template #right let-item>
 *
 *                      <span class="sap-icon"
 *                            [ngClass]="{'icon-accept': awlist.pListBox.isSelected(item),
 *                            '': !awlist.pListBox.isSelected(item)}">
 *
 *                      </span>
 *                  </ng-template>
 *   </aw-list>
 *
 *  ```
 *
 * 3. Render list - multi selection with visible checkboxes and custom MIDDLE content to change
 *  the way item name is rendered
 *
 *
 *
 *  ```html
 *
 *   <aw-list [list]="list" height="180px"
 *                       width="200px"
 *                       [selection]="selection"
 *                       [selectionMode]="'multiWithCheckbox'">
 *
 *                  <ng-template #middle let-item>
 *                      XX-{{item.value}}
 *                  </ng-template>
 *    </aw-list>
 *
 *  ```
 *
 *
 *
 */
class ListComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Component recognizes 3 modes: single, multi, multi with visible checkboxes
         */
        this.selectionMode = 'single';
        /**
         * Don't render Listbox border. Used for embedding this inside other components
         *
         */
        this.borderless = false;
        /**
         * Triggered when we double click on the list Item
         *
         */
        this.action = new EventEmitter();
        /**
         * Event fired when user select a item
         *
         */
        this.onSelection = new EventEmitter();
        this.listStyle = {};
        this.isMultiple = false;
        this.showCheckbox = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.isMultiple = this.selectionMode === 'multi' ||
            this.selectionMode === 'multiWithCheckbox';
        this.showCheckbox = this.selectionMode === 'multiWithCheckbox';
        // cannot have both either we use field to get display value or valueTransformer
        if (isPresent(this.field) && isPresent(this.valueTransformer)) {
            throw new Error('You can have either [field] or [valueTransformer].');
        }
        if (isPresent(this.list)) {
            this.initList();
        }
        else {
            throw new Error('Missing [list] binding.');
        }
        // Also add overflowY to make sure it can scroll and does not expand based on its content
        if (isPresent(this.height)) {
            this.listStyle['height'] = this.height;
            this.listStyle['overflow-y'] = 'auto';
        }
        if (isPresent(this.width)) {
            this.listStyle['width'] = this.width;
        }
        if (this.borderless) {
            this.listStyle['border-color'] = 'transparent';
        }
        if (this.isStandalone) {
            super.registerFormControl(this.selection);
            if (isBlank(this.selection)) {
                this.selection = this.formControl.value;
            }
        }
    }
    /**
     *
     * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
     * checkbox as well as item text.
     *
     *
     * @param {?} event
     * @param {?} item
     * @param {?} checkbox
     * @return {?}
     */
    itemClicked(event, item, checkbox) {
        this.pListBox.onOptionClick(event, item);
        event.stopPropagation();
        event.preventDefault();
    }
    /**
     * Internal
     *
     * @return {?}
     */
    hasRightTempl() {
        return isPresent(this.rZoneTempl);
    }
    /**
     * @return {?}
     */
    hasLeftTempl() {
        return isPresent(this.lZoneTempl);
    }
    /**
     * @return {?}
     */
    hasMiddleTempl() {
        return isPresent(this.mZoneTempl);
    }
    /**
     *
     * Triggered by p-listbox component when item is selected. When state is managed internally
     * we also update FormControl model.
     *
     * @param {?} event
     * @return {?}
     */
    onItemSelected(event) {
        if (isBlank(event.value)) {
            return;
        }
        this.onSelection.emit(event.value);
        if (this.isStandalone) {
            this.formControl.setValue(event.value, { emitEvent: true });
        }
        this.onModelChanged(event.value);
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!equals(value, this.selection)) {
            this.selection = value;
            if (this.isStandalone) {
                this.formControl.setValue(value);
            }
        }
    }
    /**
     * Translates external form of the list into PrimeNG expected format where it uses
     * SelectionItem interface
     * @return {?}
     */
    initList() {
        if (isPresent(this.list)) {
            this.internalList = this.list.map((item) => {
                return { label: this.displayValue(item), value: item };
            });
        }
    }
    /**
     *  Generates label value for the list box.
     *
     * @param {?} item
     * @return {?}
     */
    displayValue(item) {
        if (isBlank(item)) {
            return '';
        }
        /** @type {?} */
        let val = item.toString();
        if (isPresent(this.field)) {
            val = item[this.field];
        }
        else if (isPresent(this.valueTransformer)) {
            val = this.valueTransformer(item);
        }
        return val;
    }
}
ListComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-list',
                template: "<p-listbox #listbox [options]=\"internalList\" [multiple]=\"isMultiple\" [checkbox]=\"showCheckbox\"\n           [(ngModel)]=\"selection\" [disabled]=\"disabled\" [style]=\"listStyle\" [showToggleAll]=\"false\"\n           (onChange)=\"onItemSelected($event)\" (onDblClick)=\"action.emit($event.value)\"\n           [styleClass]=\"styleClass\">\n\n\n    <ng-template let-item pTemplate=\"item\">\n        <div class=\"w-li-wrapper\">\n            <div class=\"w-li-left\">\n                <ng-template *ngIf=\"hasLeftTempl(); else defaultLeft\"\n                             [ngTemplateOutlet]=\"lZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n\n                <ng-template #defaultLeft>\n                    <span (click)=\"itemClicked($event, item, null)\">\n                        <aw-checkbox #check *ngIf=\"isMultiple && showCheckbox\"\n                                     [isStandalone]=\"false\"\n                                     [value]=\"listbox.isSelected(item)\"\n                                     type=\"action\">\n                    </aw-checkbox></span>\n                </ng-template>\n            </div>\n\n            <div class=\"w-li-middle\" (click)=\"itemClicked($event, item, null)\">\n\n                <ng-template *ngIf=\"hasMiddleTempl(); else defaultMiddle\"\n                             [ngTemplateOutlet]=\"mZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n                <ng-template #defaultMiddle>\n                    {{item.label}}\n                </ng-template>\n\n            </div>\n\n            <div class=\"w-li-right\" *ngIf=\"hasRightTempl()\">\n                <ng-template [ngTemplateOutlet]=\"rZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\">\n                </ng-template>\n\n            </div>\n        </div>\n    </ng-template>\n</p-listbox>\n",
                providers: [
                    LB_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => ListComponent) }
                ],
                styles: ["::ng-deep .ui-listbox-item>.ui-chkbox{display:none}::ng-deep .ui-listbox-item .ui-chkbox{margin-right:1em}.w-li-wrapper{display:flex;align-items:flex-start}.w-li-wrapper .w-li-left,.w-li-wrapper .w-li-right{flex:0 1 auto}.w-li-wrapper .w-li-middle{flex:1 1 auto}"]
            }] }
];
/** @nocollapse */
ListComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
ListComponent.propDecorators = {
    list: [{ type: Input }],
    selection: [{ type: Input }],
    selectionMode: [{ type: Input }],
    valueTransformer: [{ type: Input }],
    field: [{ type: Input }],
    borderless: [{ type: Input }],
    action: [{ type: Output }],
    onSelection: [{ type: Output }],
    pListBox: [{ type: ViewChild, args: ['listbox',] }],
    lZoneTempl: [{ type: ContentChild, args: ['left',] }],
    mZoneTempl: [{ type: ContentChild, args: ['middle',] }],
    rZoneTempl: [{ type: ContentChild, args: ['right',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWListModule {
}
AWListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ListComponent
                ],
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    FormsModule,
                    ListboxModule,
                    AWCheckBoxModule
                ],
                entryComponents: [
                    ListComponent
                ],
                exports: [
                    ListComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WizardProgressComponent {
    constructor() {
        this.currentStep = 0;
        this.stepChanged = new EventEmitter();
        this.totalSteps = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.steps) {
            /** @type {?} */
            let currentIndex = this.steps.indexOf(this.steps.filter(step => step.current)[0]);
            this.totalSteps = this.steps.length;
            this.setCurrentStep(~currentIndex ? currentIndex : 0);
        }
    }
    /**
     * @param {?=} index
     * @return {?}
     */
    setCurrentStep(index = 0) {
        this.steps[index].current = true;
        this.currentStep = index;
        this.stepChanged.emit({ current: this.currentStep });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    goToStep(index) {
        if (!this.steps[index].complete) {
            return;
        }
        /** @type {?} */
        let currentIndex = this.steps.indexOf(this.steps.filter(step => step.current)[0]);
        this.steps[currentIndex].current = false;
        this.setCurrentStep(index);
    }
}
WizardProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-wizard-progress',
                template: "<div class=\"step-indicator\">{{currentStep + 1}}/{{totalSteps}}</div>\n<div class=\"aw-step-progress\">\n    <div class=\"aw-step-progress__item\" *ngFor=\"let step of steps; let i = index;\"\n         [ngClass]=\"{ 'aw-step-progress__item--is-active': step.current === true }\"\n         (click)=\"goToStep(i);\">\n    </div>\n</div>\n",
                styles: [":host{display:block}.step-indicator{width:100%;text-align:center;font-size:14px;font-weight:600;padding-bottom:.3rem}.aw-step-progress{display:flex;flex-direction:row;padding:.2rem;justify-content:center}.aw-step-progress__item{cursor:pointer;list-style:none;width:1.2rem;margin:0 .2rem;border-radius:.3rem;height:.4rem;background-color:#eaeaea}.aw-step-progress__item:last-child{margin-right:0}.aw-step-progress__item:first-child{margin-left:0}.aw-step-progress__item--is-active{background-color:#09a7af}"]
            }] }
];
/** @nocollapse */
WizardProgressComponent.ctorParameters = () => [];
WizardProgressComponent.propDecorators = {
    steps: [{ type: Input }],
    currentStep: [{ type: Input }],
    stepChanged: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class WizardProgressModule {
}
WizardProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    WizardProgressComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    WizardProgressComponent
                ],
                exports: [
                    WizardProgressComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Renders a Toggle Switch
 *
 * ### Example
 *
 * ```typescript
 *
 * \@Component({
 *          selector: 'myToggleSection' ,
 *          template: '<aw-toggle [model]="inputValue" [labelText]="labelText" >
 *              </aw-toggle>'
 *      })
 *      export class MyNoteComponent
 *      {
 *          inputValue: boolean = false;
 *          labelText: string = 'my label';
 *      }
 *
 * ```
 */
class ToggleSwitchComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * toggle model
         */
        this.model = false;
    }
    /**
     * click handler for toggle
     * @return {?}
     */
    changeHandler() {
        this.model = !this.model;
    }
}
ToggleSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-toggle',
                template: "<div class=\"w-toggle\">\n    <label class=\"w-toggle__label\" *ngIf=\"labelText\">\n        {{ labelText }}\n    </label>\n    <div class=\"slider\" (click)=\"changeHandler()\">\n        <div class=\"slider__button\" [ngClass]=\"{ 'slider__button--is-active': model === true }\"></div>\n    </div>\n</div>\n",
                styles: [":host{display:block}.w-toggle input{display:none}.w-toggle__label{color:#999;margin-right:.2rem}.w-toggle .slider{position:relative;height:.6rem;width:1.5rem;background-color:#d8d8d8;border-radius:.9rem;display:inline-block;border-top:1px solid #7e7e7e;border-left:1px solid #b5b5b5;border-right:1px solid #b5b5b5}.w-toggle .slider__button{left:-.1rem;transition:left .1s ease-out;cursor:pointer;position:absolute;height:1rem;width:1rem;border-radius:50%;background-color:#eaeaea;top:-.2rem}.w-toggle .slider__button--is-active{left:calc(100% - .8rem);background-color:#09a7af}"]
            }] }
];
/** @nocollapse */
ToggleSwitchComponent.ctorParameters = () => [
    { type: Environment }
];
ToggleSwitchComponent.propDecorators = {
    model: [{ type: Input }],
    labelText: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class ToggleSwitchModule {
}
ToggleSwitchModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ToggleSwitchComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    ToggleSwitchComponent
                ],
                exports: [
                    ToggleSwitchComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Overlay Component is a simple version of the dialog where there's only content.
 * Overlay will appear at the position where the action performed trigger an overlay.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<OverlayComponent>), service.close()
 *
 * Usage:
 *    1.  Using ModalService directly to display a modal popup. The usage is a little tricky
 *        because angular currently doesn't support dynamic content projection.
 *
 *          let overlay = this.modalService.open<OverlayComponent>(OverlayComponent, {});
 *
 *            // Add content. There's not support for dynamic content projection yet.
 *            // So have add content directly.
 *            // This is probably not the best way.
 *          overlay.instance.overlay.el.nativeElement.querySelector(".ui-overlaypanel-content")
 *               .innerHTML = `<img style='width:300px;' src="sales.png" alt="Sales Chart" />`;
 *
 *          // delay the opening after ng lifecycle has been initialized.
 *          setTimeout(() => { overlay.instance.open(event); }, 1);
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                                <aw-overlay #overlay (onOpen)="overlayAction='open'"
 *                                                     (onClose)="overlayAction='close'">
 *                                      <img src="sales.png" alt="Chart"/>
 *                                </aw-overlay>
 *
 *                                <aw-button [size]="'small'" (click)="overlay.open($event)">
 *                                    Open Overlay
 *                                </aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     overlayAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *       }
 *
 *
 */
class OverlayComponent extends ModalContainer {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Enables hide overlay when outside is clicked.
         */
        this.dismissable = true;
        /**
         * displays the close icon 'x' at top of right corner.
         */
        this.showCloseIcon = false;
        /**
         * Event fired when overlay is closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event fired just before overlay is closed
         */
        this.beforeClose = new EventEmitter();
        /**
         * Event fired when the overlay is opened.
         */
        this.onOpen = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // place holder to be overridden by Modal Service
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // place holder to be overridden by Modal Service
    }
    /**
     * Open Overlay
     * @param {?} event
     * @return {?}
     */
    open(event) {
        setTimeout(() => {
            this.overlay.show(event);
            this.onOpened(null);
        }, 1);
    }
    /**
     * Close Overlay
     * @return {?}
     */
    close() {
        this.beforeClose.emit(null);
        this.overlay.hide();
    }
    /**
     * toggle open and close.
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        setTimeout(() => {
            this.overlay.toggle(event);
        }, 0);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onOpened(event) {
        this.onOpen.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClosed(event) {
        this.onClose.emit(event);
    }
}
OverlayComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-overlay',
                template: "<p-overlayPanel [dismissable]=\"dismissable\" [showCloseIcon]=\"showCloseIcon\"\n                [styleClass]=\"styleClass\" [appendTo]=\"appendTo\"\n                (onHide)=\"onClosed($event)\">\n    <ng-content></ng-content>\n</p-overlayPanel>\n",
                styles: ["::ng-deep .ui-overlaypanel{border:1px solid #d7d7d7;box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .ui-overlaypanel-content{padding:2em 3.4em .6em 1.43em}::ng-deep .ui-overlaypanel-close{border-radius:0;top:.5em;right:.5em}::ng-deep .ui-overlaypanel-close.ui-state-default{border:none}"]
            }] }
];
/** @nocollapse */
OverlayComponent.ctorParameters = () => [
    { type: Environment }
];
OverlayComponent.propDecorators = {
    dismissable: [{ type: Input }],
    showCloseIcon: [{ type: Input }],
    appendTo: [{ type: Input }],
    onClose: [{ type: Output }],
    beforeClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    overlay: [{ type: ViewChild, args: [OverlayPanel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @enum {number} */
const HCCardPosition = {
    top: 0,
    bottom: 1,
    none: 2,
};
HCCardPosition[HCCardPosition.top] = 'top';
HCCardPosition[HCCardPosition.bottom] = 'bottom';
HCCardPosition[HCCardPosition.none] = 'none';
/** @enum {number} */
const HCCardAlignment = {
    left: 0,
    paddedLeft: 1,
    right: 2,
    paddedRight: 3,
    default: 4,
};
HCCardAlignment[HCCardAlignment.left] = 'left';
HCCardAlignment[HCCardAlignment.paddedLeft] = 'paddedLeft';
HCCardAlignment[HCCardAlignment.right] = 'right';
HCCardAlignment[HCCardAlignment.paddedRight] = 'paddedRight';
HCCardAlignment[HCCardAlignment.default] = 'default';
/** *
 * Maps position to styles that are applied to the Card container. This is just to make it easier
 * as we are working with enumerations and have already enum type.
 *
 * u-hc-arrow-b: Arrow will appear at the bottom
 * u-hc-arrow-t: Arrow will appear at the top
 *
 * u-hc-shadow-t: Border shadow will appear at the top
 * u-hc-shadow-b: Border shadow will appear at the bottom
  @type {?} */
const PositionToStyle = {
    top: ' w-hc-panel-arrow u-hc-arrow-b u-hc-shadow-t',
    bottom: ' w-hc-panel-arrow u-hc-arrow-t u-hc-shadow-b',
    none: ''
};
/** *
 *
 * Maps aligned Card container to custom styles in order to apply correct arrow
 *
 * -ll: Stands for Large Left (large: there is plenty of space around )
 * -lr: Stands for Large right
 * -sl: Stands for Small left (Small and resized screen where we try to fit card container
 * somewhere in between)
 * -sr: Stands for Large right
 *
  @type {?} */
const AlignmentToStyle = {
    left: ' u-hc-arrow-ll',
    right: ' u-hc-arrow-lr',
    paddedLeft: ' u-hc-arrow-sl',
    paddedRight: ' u-hc-arrow-sr',
    default: ' u-hc-arrow-ll',
};
/**
 * The HoverCard components adds hover behavior to text, the specified content is loaded
 * on the left or right side of the element.
 *
 * Todo: extends so we can wrap any element and any element can be triggering this. Not only
 * linkTitle
 *
 *
 * ### Example:
 *
 * ```
 *
 *   <aw-hover-card [linkTitle]="'Frank kolar'">
 *       <h3>My Card Title</h3>
 *       <div>
 *
 *           This is my contents
 *
 *       </div>
 *
 *
 *    </aw-hover-card>
 * ```
 *
 * By default there is [forceClose]=true which forces the user to use X close icon
 *
 *
 *
 */
class HoverCardComponent extends BaseComponent {
    /**
     * @param {?} elem
     * @param {?} env
     * @param {?} cd
     */
    constructor(elem, env, cd) {
        super(env);
        this.elem = elem;
        this.env = env;
        this.cd = cd;
        /**
         * Should we keep the hover card open and force user to manually close
         *
         */
        this.forceClose = true;
        /**
         *
         * This current workaround until we find better solution. PrimeNG overlays operates within
         * its relative element so if the overlay is wrapped inside some other relative container
         * the overlay content is croped by its parent and content is not visible.
         *
         * They have [appendTo] binding which we need to use for this purpose
         *
         */
        this.appendContentToBody = true;
        /**
         *
         * Internal style class to use to apply additional styles when it needs to show a Arrow on the
         * card
         *
         */
        this.arrowClass = '';
        this.opening = false;
        this.currrentPosition = HCCardPosition.none;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        assert(isPresent(this.linkTitle), 'You must provide [linkTitle] binding !');
        // make sure there is open HC when we start new component
        this.env.deleteValue('hc-open');
        if (!this.appendContentToBody) {
            this.appendTo = null;
        }
        this.overlayOnAnimationStart = this.awOverlay.overlay.onAnimationStart;
        this.awOverlay.overlay.onAnimationStart = (event) => {
            this.overlayOnAnimationStart.call(this.awOverlay.overlay, event);
            this.cardOpened();
            this.onAnimationStart(event);
        };
        // this span is always available
        this.dynamicContent = this.elem.nativeElement.querySelector('.u-ngcontent');
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onAnimationStart(event) {
        if (this.opening) {
            /** @type {?} */
            let container = this.awOverlay.overlay.container;
            /** @type {?} */
            let cntRect = container.getBoundingClientRect();
            if (this.currrentPosition !== HCCardPosition.none) {
                this.adjustCard(container, cntRect, this.awOverlay.overlay);
            }
            else {
                this.arrowClass = '';
            }
            this.opening = false;
        }
    }
    /**
     * @return {?}
     */
    injectDynamicContent() {
        if (this.awOverlay.overlay.visible) {
            /** @type {?} */
            let overlayCnt = this.elem.nativeElement
                .querySelector('.ui-overlaypanel-content .u-ngcontent');
            if (isBlank(overlayCnt) && this.dynamicContent.children.length > 0) {
                overlayCnt = this.elem.nativeElement.querySelector('.ui-overlaypanel-content');
                overlayCnt.prepend(this.dynamicContent);
                this.dynamicContent.style = 'block';
            }
        }
        else {
            this.dynamicContent.style = 'none';
        }
    }
    /**
     * Init elements BoundingClientRect that we use for calculation
     *
     * @return {?}
     */
    initElements() {
        /** @type {?} */
        let titleElem = this.elem.nativeElement.querySelector('.w-hc-title');
        /** @type {?} */
        let triggerElem = this.elem.nativeElement.querySelector('.sap-icon');
        this.titleAreaRect = titleElem.getBoundingClientRect();
        this.trigRect = triggerElem.getBoundingClientRect();
        this.trigIconMiddle = this.trigRect.width / 2;
    }
    /**
     *
     * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
     * only one Card is opened at the time it uses Environment to save extra information for it
     *
     *
     * @param {?} event
     * @return {?}
     */
    openCard(event) {
        if (isPresent(this.awOverlay) && !this.env.hasValue('hc-open')) {
            this.awOverlay.open(event);
            this.cd.detectChanges();
            this.env.setValue('hc-open', true);
        }
    }
    /**
     *
     * Fired at the end of the opening cycle when all is initialized and the card is about to
     * fade in.
     *
     * This method first simulates displaying card by setting display:block and
     * domHandler.absolutePosition so we can read dimensions and then later on position the card
     * accordingly.
     *
     * @param {?=} event
     * @return {?}
     */
    cardOpened(event) {
        /** @type {?} */
        let container = this.awOverlay.overlay.container;
        /** @type {?} */
        let target = this.awOverlay.overlay.target;
        this.openForAdjustments(container);
        this.injectDynamicContent();
        // pre-run positioning so we can calculate new coordinates
        this.awOverlay.overlay.domHandler.absolutePosition(container, target);
        /** @type {?} */
        let cntRect = container.getBoundingClientRect();
        this.currrentPosition = this.positionForCard(container, cntRect);
        this.applyStyleClass(container, cntRect, this.awOverlay.overlay);
        this.closeForAdjustments(container);
        this.opening = true;
    }
    /**
     *
     * When card is closed we need to release it and delete all the references from Environment
     *
     *
     * @param {?} event
     * @return {?}
     */
    cardClosed(event) {
        this.env.deleteValue('hc-open');
    }
    /**
     *
     * Before overlay is closed we hide internal content other it does little shake..
     *
     *
     * @param {?} event
     * @return {?}
     */
    beforeClose(event) {
        this.dynamicContent.style = 'none';
    }
    /**
     *
     * Applies style.TOP and style.LEFT to the container in order to reposition it and add
     * extra arrow.
     *
     * First based on the initial position we apply style.TOP and depending if its on the
     * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
     *
     * Then for positioning horizontally we use two types.
     *  - When there is allot of space the arrow is 25% from the edge
     *
     *    -----^------------   or       -----------^----
     *
     *
     *  - When there is less or none space we have only 10% far away form the edge
     *
     *    --^------------   or       -----------^--
     *
     *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
     *  either to the left or right.
     *
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    adjustCard(container, containerRect, modalContainer) {
        /** @type {?} */
        let diff = (this.currrentPosition === HCCardPosition.bottom) ? 1 : -1;
        /** @type {?} */
        let scrollTop = modalContainer.domHandler.getWindowScrollTop();
        /** @type {?} */
        let posWithScroll = containerRect.top + scrollTop;
        container.style.top = (posWithScroll + (HoverCardComponent.ArrowPad * diff)) + 'px';
        /** @type {?} */
        let alignment = this.alignmentForCard(containerRect, modalContainer);
        container.style.left = this.calcLeftForAlignment(containerRect, alignment) + 'px';
    }
    /**
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    applyStyleClass(container, containerRect, modalContainer) {
        if (this.currrentPosition !== HCCardPosition.none) {
            /** @type {?} */
            let alignment = this.alignmentForCard(containerRect, modalContainer);
            this.arrowClass = (/** @type {?} */ (PositionToStyle))[(/** @type {?} */ (HCCardPosition))[this.currrentPosition]];
            this.arrowClass += (/** @type {?} */ (AlignmentToStyle))[(/** @type {?} */ (HCCardAlignment))[alignment]];
        }
        else {
            this.arrowClass = '';
        }
    }
    /**
     *
     * Detects if the card is going to be shown on the top of the Link label or under. Or if
     * its covering it.
     *
     * @param {?} container
     * @param {?} boundingRect
     * @return {?}
     */
    positionForCard(container, boundingRect) {
        /** @type {?} */
        let borderWidth = getComputedStyle(container).borderWidth;
        /** @type {?} */
        let cntWidth = parseFloat(borderWidth || '0');
        /** @type {?} */
        let pos = HCCardPosition.none;
        if (this.trigRect.bottom < boundingRect.top) {
            pos = HCCardPosition.bottom;
        }
        else if (this.trigRect.top > (boundingRect.bottom - cntWidth)) {
            pos = HCCardPosition.top;
        }
        return pos;
    }
    /**
     *
     * Detect horizontal alignment.
     *
     * @param {?} boundingRect
     * @param {?} modalContainer
     * @return {?}
     */
    alignmentForCard(boundingRect, modalContainer) {
        /** @type {?} */
        let alignment = HCCardAlignment.left;
        /** @type {?} */
        let viewPort = modalContainer.domHandler.getViewport();
        if (this.trigRect.left.toFixed(0) === boundingRect.left.toFixed(0) &&
            boundingRect.left > HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.left;
        }
        else if (boundingRect.left < HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.paddedLeft;
        }
        else if ((viewPort.width - boundingRect.right) < HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.paddedRight;
        }
        else if (this.trigRect.right.toFixed(0) === boundingRect.right.toFixed(0) ||
            (viewPort.width - boundingRect.right) > HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.right;
        }
        else {
            alignment = HCCardAlignment.default;
        }
        return alignment;
    }
    /**
     *
     * Turn on temporary display to BLOCK so we can read dimensions
     *
     * @param {?} container
     * @return {?}
     */
    openForAdjustments(container) {
        container.style.visibility = 'hidden';
        container.style.display = 'block';
        this.initElements();
    }
    /**
     *
     * Turn off display back NONE
     *
     * @param {?} container
     * @return {?}
     */
    closeForAdjustments(container) {
        container.style.visibility = 'visible';
        // container.style.display = 'none';
    }
    /**
     *
     * Calculates positioning for style.LEFT. As already said they are two types of triangles that
     * are applies for these case:
     *
     *
     * a) Large left, Large right
     *
     *  PrimeNG aligns the card with either the right side or left side of the triggering icon
     *
     *
     *  V                                                                V
     *  ......^........................ or  .......................^......
     *
     *
     *
     *
     *  b) Small left , small right
     *
     *  This is for cases where there is not enough space and PrimeNG position the card off to the
     *  triggering icons, so even primeNg does not have space to align it with the V
     *
     *
     *     V                                                      V
     *  ....^........................ or  .......................^....
     *
     *
     * c)Aligned with the edge of browser
     *
     * On the right side this is problem as we cannot calculate full future width of the card.
     * but we applly for this case #b (arrow 10% )
     *
     *
     *
     * @param {?} boundingRect
     * @param {?} alignment
     * @return {?}
     */
    calcLeftForAlignment(boundingRect, alignment) {
        /** @type {?} */
        let wLargeTriangle = boundingRect.width * 0.25;
        /** @type {?} */
        let wSmallTriangle = boundingRect.width * 0.10;
        switch (alignment) {
            case HCCardAlignment.right:
                /** @type {?} */
                let shiftRight = boundingRect.left + wLargeTriangle;
                /** @type {?} */
                let trigRight = this.trigRect.right - this.trigIconMiddle;
                return shiftRight - (boundingRect.right - trigRight);
            case HCCardAlignment.paddedRight:
                /** @type {?} */
                let shiftRightS = boundingRect.left + wSmallTriangle;
                /** @type {?} */
                let trigRightS = this.trigRect.right - this.trigIconMiddle;
                return shiftRightS - (boundingRect.right - trigRightS);
            case HCCardAlignment.paddedLeft:
                /** @type {?} */
                let shiftLeftPad = boundingRect.left - wSmallTriangle;
                return shiftLeftPad + this.trigIconMiddle;
            case HCCardAlignment.left:
            default:
                /** @type {?} */
                let shiftLeft = boundingRect.left - wLargeTriangle;
                return shiftLeft + this.trigIconMiddle;
        }
    }
}
/**
 * Default padding representing a height of the Arrow for which we need to vertically adjust
 * Card container
 *
 */
HoverCardComponent.ArrowPad = 10;
/**
 * Defines safe threshold where there might not be enough space around or Card is aligned with
 * the left or right edge of the viewport for which we need to position the Arrow closer to the
 * side of the card
 *
 */
HoverCardComponent.SpacingLimit = 50;
HoverCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-hover-card',
                template: "<span class=\"w-hc\">\n    <span class=\"w-hc-title\">\n        <aw-string [value]=\"linkTitle\"></aw-string>\n        <span class=\"sap-icon icon-slim-arrow-down\" (mouseover)=\"openCard($event)\"></span>\n    </span>\n\n    <div class=\"w-hc-body\">\n\n         <aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"\n                     [styleClass]=\"arrowClass\"\n                     [appendTo]=\"appendTo\"\n                     (beforeClose)=\"beforeClose($event)\"\n                     (onClose)=\"cardClosed($event)\">\n             <ng-content></ng-content>\n        </aw-overlay>\n\n\n        <!-- this is workaround to create a dynamic _ngcontent  reference so we can refer to later on with dynamic\n                projection. We cannot really use componentFactory.create[injector, projectedContent] as what we\n                want to add is another angular component that needs to be still rendered.\n\n                Starting PrimeNG 6.1+ they put in ngIf which complicates programmatic creation of this\n                component and injecting another dynamic content into ngContent is hard, so we need to little\n                hacky hackity hack.\n\n                We have this extra span with a class that we use to insert out dynamic content using nativeElement\n                and its DOM manipulation and once the overlay is shown and ng-content appears we move \"u-ngcontent\"\n                to new location.\n\n         -->\n        <span class=\"u-ngcontent\" [style.display]=\"'none'\">\n        </span>\n    </div>\n</span>\n\n\n",
                styles: [".w-hc-title{padding-right:1.4em;position:relative;white-space:nowrap}.w-hc-title .sap-icon{font-size:1em;color:#00679e;position:absolute;padding-top:.2em;right:0}::ng-deep .w-hc-panel-arrow.u-hc-shadow-b{box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow.u-hc-shadow-t{box-shadow:0 -2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow:after,::ng-deep .w-hc-panel-arrow:before{left:25%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}::ng-deep .w-hc-panel-arrow:after{border-color:rgba(136,183,213,0);border-width:.7em;margin-left:-.7em}::ng-deep .w-hc-panel-arrow:before{border-color:rgba(255,136,56,0);border-width:.8em;margin-left:-.8em}::ng-deep .u-hc-arrow-ll:after,::ng-deep .u-hc-arrow-ll:before{left:25%}::ng-deep .u-hc-arrow-lr:after,::ng-deep .u-hc-arrow-lr:before{left:75%}::ng-deep .u-hc-arrow-sl:after,::ng-deep .u-hc-arrow-sl:before{left:10%}::ng-deep .u-hc-arrow-sr:after,::ng-deep .u-hc-arrow-sr:before{left:90%}::ng-deep .u-hc-arrow-t:after,::ng-deep .u-hc-arrow-t:before{bottom:100%}::ng-deep .u-hc-arrow-t:after{border-bottom-color:#fff}::ng-deep .u-hc-arrow-t:before{border-bottom-color:#d7d7d7}::ng-deep .u-hc-arrow-b:after,::ng-deep .u-hc-arrow-b:before{top:100%}::ng-deep .u-hc-arrow-b:after{border-top-color:#fff}::ng-deep .u-hc-arrow-b:before{border-top-color:#d7d7d7}"]
            }] }
];
/** @nocollapse */
HoverCardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment },
    { type: ChangeDetectorRef }
];
HoverCardComponent.propDecorators = {
    linkTitle: [{ type: Input }],
    forceClose: [{ type: Input }],
    appendContentToBody: [{ type: Input }],
    awOverlay: [{ type: ViewChild, args: ['overlay',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Spy lifecycle directive is used for debugging purposes to track lifecycle callback
 *
 * ###Usage
 *
 * ```
 *   <my-directive spyhooks><my-directive>
 *
 * ```
 */
class SpyLifeCycleHooksDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.logIt('onInit');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.logIt('onDestroy');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.logIt('ngOnChanges = ' + changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.logIt('ngDoCheck');
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.logIt('ngAfterContentInit');
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.logIt('ngAfterContentChecked');
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.logIt('ngAfterViewInit');
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.logIt('ngAfterViewChecked');
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    logIt(msg) {
        /** @type {?} */
        let level = 0;
        /** @type {?} */
        let me = this.elementRef.nativeElement;
        /** @type {?} */
        let tagBody = me;
        while ((tagBody = tagBody.parentNode) != null) {
            level++;
            if (tagBody.tagName === 'APP-ROOT' || level === 6) {
                break;
            }
        }
        /** @type {?} */
        let indent = '';
        /** @type {?} */
        let indentNumber = level;
        while (level > 0) {
            indent += '\t';
            level--;
        }
        /** @type {?} */
        let params = '';
        if (isPresent(me.attributes)) {
            for (let i = 0; i < me.attributes.length; i++) {
                /** @type {?} */
                let attr = me.attributes.item(i);
                if (this.ignore(attr.name.toLowerCase())) {
                    continue;
                }
                params += '(' + attr.name + '=' + attr.value + '),  ';
            }
        }
        print(indent + me.tagName + '(' + indentNumber + '): ' + msg + ' => ' + params);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    ignore(name) {
        return name.indexOf('_ng') > -1 ||
            name.indexOf('ng-') > -1 ||
            name.indexOf('spyhooks') > -1;
    }
}
SpyLifeCycleHooksDirective.decorators = [
    { type: Directive, args: [{ selector: '[spyHooks]' },] }
];
/** @nocollapse */
SpyLifeCycleHooksDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

var components = /*#__PURE__*/Object.freeze({
    AWCoreComponentModule: AWCoreComponentModule,
    ErrorMessagesComponent: ErrorMessagesComponent,
    ModalContainer: ModalContainer,
    ModalService: ModalService,
    ModalComponent: ModalComponent,
    CurrencyFormatPipe: CurrencyFormatPipe,
    BaseComponent: BaseComponent,
    BaseFormComponent: BaseFormComponent,
    WidgetSizeColumns: WidgetSizeColumns,
    DomUtilsService: DomUtilsService,
    EmbeddedItemDirective: EmbeddedItemDirective,
    EmbededItem: EmbededItem,
    ErrorManagerService: ErrorManagerService,
    GenericContainerComponent: GenericContainerComponent,
    IncludeComponentDirective: IncludeComponentDirective,
    ComponentRegistry: ComponentRegistry,
    DataTypeProviderRegistry: DataTypeProviderRegistry,
    DataProviders: DataProviders,
    DataFinders: DataFinders,
    DataFinder: DataFinder,
    FullTextArrayDataFinder: FullTextArrayDataFinder,
    QueryType: QueryType,
    DATA_SOURCE: DATA_SOURCE,
    DataProvider: DataProvider,
    ArrayDataProvider: ArrayDataProvider,
    NgForSetDirective: NgForSetDirective,
    AwNameDirective: AwNameDirective,
    AwNameStore: AwNameStore,
    FormTableComponent: FormTableComponent,
    AWFormTableModule: AWFormTableModule,
    FormRowComponent: FormRowComponent,
    TopZoneComponent: TopZoneComponent,
    LeftZoneComponent: LeftZoneComponent,
    MiddleZoneComponent: MiddleZoneComponent,
    RightZoneComponent: RightZoneComponent,
    BottomZoneComponent: BottomZoneComponent,
    AWInputFieldModule: AWInputFieldModule,
    AWStringFieldModule: AWStringFieldModule,
    AWBasicNavigatorModule: AWBasicNavigatorModule,
    AWButtonModule: AWButtonModule,
    AWCardModule: AWCardModule,
    AWCheckBoxModule: AWCheckBoxModule,
    AWCheckBoxListModule: AWCheckBoxListModule,
    AWHyperlinkModule: AWHyperlinkModule,
    AWChooserModule: AWChooserModule,
    AWDropdownModule: AWDropdownModule,
    AWCurrencyModule: AWCurrencyModule,
    AWDateAndTimeModule: AWDateAndTimeModule,
    AWDialogModule: AWDialogModule,
    AWGenericChooserModule: AWGenericChooserModule,
    AWRadioButtonModule: AWRadioButtonModule,
    AWRadioButtonListModule: AWRadioButtonListModule,
    AWOutlineForModule: AWOutlineForModule,
    AWTextAreaModule: AWTextAreaModule,
    AWPageNotificationModule: AWPageNotificationModule,
    AWPageWrapperModule: AWPageWrapperModule,
    AWRichTextAreaModule: AWRichTextAreaModule,
    AWSectionModule: AWSectionModule,
    AWStepperModule: AWStepperModule,
    AWDatatable2Module: AWDatatable2Module,
    AWConfirmationModule: AWConfirmationModule,
    AWScrollableContainerModule: AWScrollableContainerModule,
    AWListModule: AWListModule,
    WizardProgressModule: WizardProgressModule,
    ToggleSwitchModule: ToggleSwitchModule,
    BasicNavigatorComponent: BasicNavigatorComponent,
    ButtonComponent: ButtonComponent,
    CheckBoxListComponent: CheckBoxListComponent,
    CHOOSER_CONTROL_VALUE_ACCESSOR: CHOOSER_CONTROL_VALUE_ACCESSOR,
    ChooserComponent: ChooserComponent,
    ChooserState: ChooserState,
    DefaultSelectionState: DefaultSelectionState,
    ChooserSelectionState: ChooserSelectionState,
    ChooserDataSource: ChooserDataSource,
    isDSChooserInitParams: isDSChooserInitParams,
    CURRENCY_CONTROL_VALUE_ACCESSOR: CURRENCY_CONTROL_VALUE_ACCESSOR,
    CurrencyComponent: CurrencyComponent,
    Money: Money,
    DateAndTimeComponent: DateAndTimeComponent,
    DATETIME_CONTROL_VALUE_ACCESSOR: DATETIME_CONTROL_VALUE_ACCESSOR,
    DialogComponent: DialogComponent,
    DialogHeaderComponent: DialogHeaderComponent,
    DialogFooterComponent: DialogFooterComponent,
    ConfirmationComponent: ConfirmationComponent,
    ConfirmationHeaderComponent: ConfirmationHeaderComponent,
    ConfirmationFooterComponent: ConfirmationFooterComponent,
    OverlayComponent: OverlayComponent,
    DD_CONTROL_VALUE_ACCESSOR: DD_CONTROL_VALUE_ACCESSOR,
    DropdownComponent: DropdownComponent,
    GCChooserState: GCChooserState,
    GenericChooserComponent: GenericChooserComponent,
    HyperlinkComponent: HyperlinkComponent,
    INPUT_CONTROL_VALUE_ACCESSOR: INPUT_CONTROL_VALUE_ACCESSOR,
    InputFieldComponent: InputFieldComponent,
    RadioButtonListComponent: RadioButtonListComponent,
    StringComponent: StringComponent,
    TEXTAREA_CONTROL_VALUE_ACCESSOR: TEXTAREA_CONTROL_VALUE_ACCESSOR,
    TextAreaComponent: TextAreaComponent,
    CardComponent: CardComponent,
    CardZoneTitleComponent: CardZoneTitleComponent,
    CardZoneTopComponent: CardZoneTopComponent,
    CardZoneBottomComponent: CardZoneBottomComponent,
    OutlineForComponent: OutlineForComponent,
    OutlineControlComponent: OutlineControlComponent,
    OutlineState: OutlineState,
    isOutlineNode: isOutlineNode,
    PageContentComponent: PageContentComponent,
    PageNotificationComponent: PageNotificationComponent,
    PageNotification: PageNotification,
    PageInitialized: PageInitialized,
    PageDestroyed: PageDestroyed,
    PageWrapper: PageWrapper,
    PageLifeCycleService: PageLifeCycleService,
    ObjectPageWrapperComponent: ObjectPageWrapperComponent,
    PageHeaderComponent: PageHeaderComponent,
    PageMenuItem: PageMenuItem,
    UserNotification: UserNotification,
    PageFooterComponent: PageFooterComponent,
    SidenavComponent: SidenavComponent,
    PageActionsComponent: PageActionsComponent,
    SectionComponent: SectionComponent,
    SubSectionComponent: SubSectionComponent,
    SectionActionsComponent: SectionActionsComponent,
    EditorType: EditorType,
    RichTextAreaComponent: RichTextAreaComponent,
    CheckboxComponent: CheckboxComponent,
    RadioButtonComponent: RadioButtonComponent,
    StepperComponent: StepperComponent,
    StepComponent: StepComponent,
    ScrollableContainerComponent: ScrollableContainerComponent,
    HoverCardComponent: HoverCardComponent,
    ListComponent: ListComponent,
    Datatable2Component: Datatable2Component,
    DTHeaderComponent2: DTHeaderComponent2,
    DTColumn2Component: DTColumn2Component,
    DTDetailRowComponent: DTDetailRowComponent,
    Datatable2State: Datatable2State,
    isDTInitParams: isDTInitParams,
    DT2DataSource: DT2DataSource,
    DetailRowExpansionState: DetailRowExpansionState,
    DTMultiSelectColumnComponent: DTMultiSelectColumnComponent,
    WizardProgressComponent: WizardProgressComponent,
    ToggleSwitchComponent: ToggleSwitchComponent,
    DomHandler: DomHandler,
    TreeDragDropService: TreeDragDropService,
    ConfirmationService: ConfirmationService,
    MessageService: MessageService,
    Header: Header,
    Footer: Footer,
    PrimeTemplate: PrimeTemplate,
    Column: Column,
    Row: Row,
    HeaderColumnGroup: HeaderColumnGroup,
    FooterColumnGroup: FooterColumnGroup,
    SharedModule: SharedModule,
    AccordionTab: AccordionTab,
    Accordion: Accordion,
    AccordionModule: AccordionModule,
    AUTOCOMPLETE_VALUE_ACCESSOR: AUTOCOMPLETE_VALUE_ACCESSOR,
    AutoComplete: AutoComplete,
    AutoCompleteModule: AutoCompleteModule,
    BlockUI: BlockUI,
    BlockUIModule: BlockUIModule,
    Breadcrumb: Breadcrumb,
    BreadcrumbModule: BreadcrumbModule,
    ButtonDirective: ButtonDirective,
    Button: Button,
    ButtonModule: ButtonModule,
    Captcha: Captcha,
    CaptchaModule: CaptchaModule,
    CALENDAR_VALUE_ACCESSOR: CALENDAR_VALUE_ACCESSOR,
    Calendar: Calendar,
    CalendarModule: CalendarModule,
    Card: Card,
    CardModule: CardModule,
    Carousel: Carousel,
    CarouselModule: CarouselModule,
    UIChart: UIChart,
    ChartModule: ChartModule,
    CHECKBOX_VALUE_ACCESSOR: CHECKBOX_VALUE_ACCESSOR,
    Checkbox: Checkbox,
    CheckboxModule: CheckboxModule,
    CHIPS_VALUE_ACCESSOR: CHIPS_VALUE_ACCESSOR,
    Chips: Chips,
    ChipsModule: ChipsModule,
    CodeHighlighter: CodeHighlighter,
    CodeHighlighterModule: CodeHighlighterModule,
    COLORPICKER_VALUE_ACCESSOR: COLORPICKER_VALUE_ACCESSOR,
    ColorPicker: ColorPicker,
    ColorPickerModule: ColorPickerModule,
    ConfirmDialog: ConfirmDialog,
    ConfirmDialogModule: ConfirmDialogModule,
    ContextMenuSub: ContextMenuSub,
    ContextMenu: ContextMenu,
    ContextMenuModule: ContextMenuModule,
    DataGrid: DataGrid,
    DataGridModule: DataGridModule,
    DataList: DataList,
    DataListModule: DataListModule,
    DataScroller: DataScroller,
    DataScrollerModule: DataScrollerModule,
    DTRadioButton: DTRadioButton,
    DTCheckbox: DTCheckbox,
    ColumnHeaders: ColumnHeaders,
    ColumnFooters: ColumnFooters,
    TableBody: TableBody,
    ScrollableView: ScrollableView,
    DataTable: DataTable,
    DataTableModule: DataTableModule,
    DeferredLoader: DeferredLoader,
    DeferModule: DeferModule,
    Dialog: Dialog,
    DialogModule: DialogModule$1,
    Draggable: Draggable,
    Droppable: Droppable,
    DragDropModule: DragDropModule,
    DROPDOWN_VALUE_ACCESSOR: DROPDOWN_VALUE_ACCESSOR,
    Dropdown: Dropdown,
    DropdownModule: DropdownModule,
    EDITOR_VALUE_ACCESSOR: EDITOR_VALUE_ACCESSOR,
    Editor: Editor,
    EditorModule: EditorModule,
    Fieldset: Fieldset,
    FieldsetModule: FieldsetModule,
    FileUpload: FileUpload,
    FileUploadModule: FileUploadModule,
    Galleria: Galleria,
    GalleriaModule: GalleriaModule,
    GMap: GMap,
    GMapModule: GMapModule,
    Growl: Growl,
    GrowlModule: GrowlModule,
    InplaceDisplay: InplaceDisplay,
    InplaceContent: InplaceContent,
    Inplace: Inplace,
    InplaceModule: InplaceModule,
    INPUTMASK_VALUE_ACCESSOR: INPUTMASK_VALUE_ACCESSOR,
    InputMask: InputMask,
    InputMaskModule: InputMaskModule,
    INPUTSWITCH_VALUE_ACCESSOR: INPUTSWITCH_VALUE_ACCESSOR,
    InputSwitch: InputSwitch,
    InputSwitchModule: InputSwitchModule,
    InputText: InputText,
    InputTextModule: InputTextModule$1,
    InputTextarea: InputTextarea,
    InputTextareaModule: InputTextareaModule,
    KEYFILTER_VALIDATOR: KEYFILTER_VALIDATOR,
    KeyFilter: KeyFilter,
    KeyFilterModule: KeyFilterModule,
    Lightbox: Lightbox,
    LightboxModule: LightboxModule,
    LISTBOX_VALUE_ACCESSOR: LISTBOX_VALUE_ACCESSOR,
    Listbox: Listbox,
    ListboxModule: ListboxModule,
    MegaMenu: MegaMenu,
    MegaMenuModule: MegaMenuModule,
    MenuItemContent: MenuItemContent,
    Menu: Menu,
    MenuModule: MenuModule,
    MenubarSub: MenubarSub,
    Menubar: Menubar,
    MenubarModule: MenubarModule,
    Messages: Messages,
    MessagesModule: MessagesModule,
    UIMessage: UIMessage,
    MessageModule: MessageModule,
    MULTISELECT_VALUE_ACCESSOR: MULTISELECT_VALUE_ACCESSOR,
    MultiSelect: MultiSelect,
    MultiSelectModule: MultiSelectModule,
    OrderList: OrderList,
    OrderListModule: OrderListModule,
    OrganizationChartNode: OrganizationChartNode,
    OrganizationChart: OrganizationChart,
    OrganizationChartModule: OrganizationChartModule,
    OverlayPanel: OverlayPanel,
    OverlayPanelModule: OverlayPanelModule,
    Paginator: Paginator,
    PaginatorModule: PaginatorModule,
    Panel: Panel,
    PanelModule: PanelModule,
    BasePanelMenuItem: BasePanelMenuItem,
    PanelMenuSub: PanelMenuSub,
    PanelMenu: PanelMenu,
    PanelMenuModule: PanelMenuModule,
    Password: Password,
    PasswordModule: PasswordModule,
    PickList: PickList,
    PickListModule: PickListModule,
    ProgressBar: ProgressBar,
    ProgressBarModule: ProgressBarModule,
    ProgressSpinner: ProgressSpinner,
    ProgressSpinnerModule: ProgressSpinnerModule,
    RADIO_VALUE_ACCESSOR: RADIO_VALUE_ACCESSOR,
    RadioButton: RadioButton,
    RadioButtonModule: RadioButtonModule,
    RATING_VALUE_ACCESSOR: RATING_VALUE_ACCESSOR,
    Rating: Rating,
    RatingModule: RatingModule,
    Schedule: Schedule,
    ScheduleModule: ScheduleModule,
    ScrollPanel: ScrollPanel,
    ScrollPanelModule: ScrollPanelModule,
    SELECTBUTTON_VALUE_ACCESSOR: SELECTBUTTON_VALUE_ACCESSOR,
    SelectButton: SelectButton,
    SelectButtonModule: SelectButtonModule,
    SlideMenuSub: SlideMenuSub,
    SlideMenu: SlideMenu,
    SlideMenuModule: SlideMenuModule,
    SLIDER_VALUE_ACCESSOR: SLIDER_VALUE_ACCESSOR,
    Slider: Slider,
    SliderModule: SliderModule,
    Sidebar: Sidebar,
    SidebarModule: SidebarModule,
    SPINNER_VALUE_ACCESSOR: SPINNER_VALUE_ACCESSOR,
    Spinner: Spinner,
    SpinnerModule: SpinnerModule,
    SplitButton: SplitButton,
    SplitButtonModule: SplitButtonModule,
    Steps: Steps,
    StepsModule: StepsModule,
    TabViewNav: TabViewNav,
    TabPanel: TabPanel,
    TabView: TabView,
    TabViewModule: TabViewModule,
    TabMenu: TabMenu,
    TabMenuModule: TabMenuModule,
    Terminal: Terminal,
    TerminalModule: TerminalModule,
    TieredMenuSub: TieredMenuSub,
    TieredMenu: TieredMenu,
    TieredMenuModule: TieredMenuModule,
    TOGGLEBUTTON_VALUE_ACCESSOR: TOGGLEBUTTON_VALUE_ACCESSOR,
    ToggleButton: ToggleButton,
    ToggleButtonModule: ToggleButtonModule,
    Toolbar: Toolbar,
    ToolbarModule: ToolbarModule,
    Tooltip: Tooltip,
    TooltipModule: TooltipModule,
    UITreeNode: UITreeNode,
    Tree: Tree,
    TreeModule: TreeModule,
    TreeTableService: TreeTableService,
    TreeTable: TreeTable,
    TTBody: TTBody,
    TTScrollableView: TTScrollableView,
    TTSortableColumn: TTSortableColumn,
    TTSortIcon: TTSortIcon,
    TTResizableColumn: TTResizableColumn,
    TTReorderableColumn: TTReorderableColumn,
    TTSelectableRow: TTSelectableRow,
    TTSelectableRowDblClick: TTSelectableRowDblClick,
    TTContextMenuRow: TTContextMenuRow,
    TTCheckbox: TTCheckbox,
    TTHeaderCheckbox: TTHeaderCheckbox,
    TTEditableColumn: TTEditableColumn,
    TreeTableCellEditor: TreeTableCellEditor,
    TreeTableToggler: TreeTableToggler,
    TreeTableModule: TreeTableModule,
    TRISTATECHECKBOX_VALUE_ACCESSOR: TRISTATECHECKBOX_VALUE_ACCESSOR,
    TriStateCheckbox: TriStateCheckbox,
    TriStateCheckboxModule: TriStateCheckboxModule
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWOverlayModule {
}
AWOverlayModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    OverlayComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                    OverlayPanelModule
                ],
                entryComponents: [
                    OverlayComponent
                ],
                exports: [
                    OverlayComponent,
                    AWCoreComponentModule
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class AWHoverCardModule {
}
AWHoverCardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    HoverCardComponent
                ],
                imports: [
                    CommonModule,
                    AWOverlayModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    HoverCardComponent
                ],
                exports: [
                    HoverCardComponent
                ],
                providers: []
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 * Component module is core module for the common layouts and widgets libraries.
 *
 * todo: There are some things that I still need to resolve - please see and notices \@Duplicates
 * jsdoc I want to keep this there to remind me that I need to refactor this as of now there are
 * not much option with angular.
 *
 */
class AribaComponentsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AribaComponentsModule,
            providers: [
                ModalService,
                ComponentRegistry,
                ErrorManagerService,
                DomUtilsService,
                DataTypeProviderRegistry,
                DataProviders,
                DataFinders,
                AwNameStore,
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerComponents,
                    deps: [ComponentRegistry],
                    multi: true,
                }
            ]
        };
    }
}
AribaComponentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    AribaCoreModule,
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCoreComponentModule,
                    AWBasicNavigatorModule,
                    AWCardModule,
                    AWCheckBoxListModule,
                    AWCheckBoxModule,
                    AWChooserModule,
                    AWConfirmationModule,
                    AWCurrencyModule,
                    AWDateAndTimeModule,
                    AWDialogModule,
                    AWDropdownModule,
                    AWGenericChooserModule,
                    AWHyperlinkModule,
                    AWInputFieldModule,
                    AWOutlineForModule,
                    AWOverlayModule,
                    AWPageNotificationModule,
                    AWPageWrapperModule,
                    AWRadioButtonModule,
                    AWRadioButtonListModule,
                    AWRichTextAreaModule,
                    AWScrollableContainerModule,
                    AWSectionModule,
                    AWStepperModule,
                    AWStringFieldModule,
                    AWTextAreaModule,
                    AWFormTableModule,
                    AWButtonModule,
                    AWHoverCardModule,
                    AWListModule,
                    AWDatatable2Module,
                    WizardProgressModule,
                    ToggleSwitchModule,
                    PanelModule,
                    ButtonModule,
                    ToolbarModule,
                    InputTextModule$1,
                    InputTextareaModule,
                    AutoCompleteModule,
                    DropdownModule,
                    CalendarModule,
                    CheckboxModule,
                    RadioButtonModule,
                    SharedModule,
                    DialogModule$1,
                    MenuModule,
                    TabMenuModule,
                    AccordionModule,
                    EditorModule,
                    DataTableModule,
                    PaginatorModule,
                    OverlayPanelModule,
                    TreeModule
                ],
                declarations: [
                    SpyLifeCycleHooksDirective,
                ],
                bootstrap: [],
                entryComponents: [
                    Checkbox,
                    Dialog
                ],
                exports: [
                    ReactiveFormsModule,
                    FormsModule,
                    SpyLifeCycleHooksDirective,
                    AWCoreComponentModule,
                    AWBasicNavigatorModule,
                    AWCardModule,
                    AWCheckBoxListModule,
                    AWCheckBoxModule,
                    AWChooserModule,
                    AWConfirmationModule,
                    AWCurrencyModule,
                    AWDateAndTimeModule,
                    AWDialogModule,
                    AWDropdownModule,
                    AWGenericChooserModule,
                    AWHyperlinkModule,
                    AWInputFieldModule,
                    AWOutlineForModule,
                    AWOverlayModule,
                    AWPageNotificationModule,
                    AWPageWrapperModule,
                    AWRadioButtonModule,
                    AWRadioButtonListModule,
                    AWRichTextAreaModule,
                    AWScrollableContainerModule,
                    AWSectionModule,
                    AWStepperModule,
                    AWStringFieldModule,
                    AWTextAreaModule,
                    AWFormTableModule,
                    EmbeddedItemDirective,
                    AWButtonModule,
                    AWHoverCardModule,
                    AWListModule,
                    AWDatatable2Module,
                    WizardProgressModule,
                    ToggleSwitchModule,
                    SharedModule,
                    PanelModule,
                    ButtonModule,
                    ToolbarModule,
                    InputTextModule$1,
                    InputTextareaModule,
                    AutoCompleteModule,
                    DropdownModule,
                    CalendarModule,
                    CheckboxModule,
                    RadioButtonModule,
                    DialogModule$1,
                    MenuModule,
                    TabMenuModule,
                    EditorModule,
                    DataTableModule,
                    PaginatorModule,
                    OverlayPanelModule
                ]
            },] }
];
/**
 * @param {?} compRegistry
 * @return {?}
 */
function registerComponents(compRegistry) {
    return compRegistry.initialize.bind(compRegistry, components);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/**
 *
 * This module is used mainly for tests as importing a module with all the components and you
 * use only 1 or two has a big impact on the performance execution. e.g. from executing couple
 * tests under 1 sec can go up to 10sec if you import all the things that you are not using.
 *
 * I havent noticed anything similar in application its only jasmine/karma that needs to init
 * components for every test.
 *
 */
class AribaComponentsTestProviderModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AribaComponentsTestProviderModule,
            providers: [
                ModalService,
                ComponentRegistry,
                ErrorManagerService,
                DomUtilsService,
                DataTypeProviderRegistry,
                DataProviders,
                DataFinders,
                AwNameStore,
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerComponents$1,
                    deps: [ComponentRegistry],
                    multi: true,
                }
            ]
        };
    }
}
AribaComponentsTestProviderModule.decorators = [
    { type: NgModule, args: [{
                imports: []
            },] }
];
/**
 * @param {?} compRegistry
 * @return {?}
 */
function registerComponents$1(compRegistry) {
    return compRegistry.initialize.bind(compRegistry, components);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { ErrorMessagesComponent, ModalContainer, ModalService, ModalComponent, CurrencyFormatPipe, BaseComponent, WidgetSizeColumns, DomUtilsService, EmbeddedItemDirective, EmbededItem, ErrorManagerService, GenericContainerComponent, IncludeComponentDirective, ComponentRegistry, AWCoreComponentModule, BaseFormComponent, DataTypeProviderRegistry, DataProvider, DataProviders, DataFinders, DataFinder, QueryType, FullTextArrayDataFinder, DATA_SOURCE, ArrayDataProvider, NgForSetDirective, AwNameDirective, AwNameStore, FormTableComponent, FormRowComponent, TopZoneComponent, LeftZoneComponent, MiddleZoneComponent, RightZoneComponent, BottomZoneComponent, AWFormTableModule, BasicNavigatorComponent, ButtonComponent, CheckBoxListComponent, CHOOSER_CONTROL_VALUE_ACCESSOR, ChooserComponent, ChooserState, DefaultSelectionState, ChooserSelectionState, CURRENCY_CONTROL_VALUE_ACCESSOR, CurrencyComponent, Money, DateAndTimeComponent, DATETIME_CONTROL_VALUE_ACCESSOR, DialogComponent, DialogHeaderComponent, DialogFooterComponent, ConfirmationComponent, ConfirmationHeaderComponent, ConfirmationFooterComponent, OverlayComponent, DropdownComponent, GCChooserState, GenericChooserComponent, HyperlinkComponent, INPUT_CONTROL_VALUE_ACCESSOR, InputFieldComponent, RadioButtonListComponent, StringComponent, TEXTAREA_CONTROL_VALUE_ACCESSOR, TextAreaComponent, OutlineForComponent, OutlineControlComponent, PageActionsComponent, PageContentComponent, PageFooterComponent, PageHeaderComponent, PageMenuItem, UserNotification, PageNotificationComponent, PageNotification, PageInitialized, PageDestroyed, PageWrapper, PageLifeCycleService, ObjectPageWrapperComponent, SectionComponent, SubSectionComponent, RichTextAreaComponent, EditorType, CheckboxComponent, RadioButtonComponent, StepperComponent, StepComponent, AWInputFieldModule, AWStringFieldModule, AWBasicNavigatorModule, AWButtonModule, AWHyperlinkModule, AWCardModule, AWCheckBoxModule, AWCheckBoxListModule, AWChooserModule, AWDropdownModule, AWCurrencyModule, AWDateAndTimeModule, AWDialogModule, AWGenericChooserModule, AWRadioButtonModule, AWRadioButtonListModule, AWTextAreaModule, AWPageNotificationModule, AWPageWrapperModule, AWRichTextAreaModule, AWSectionModule, AWStepperModule, ScrollableContainerComponent, AWScrollableContainerModule, AWConfirmationModule, ChooserDataSource, isDSChooserInitParams, HoverCardComponent, ListComponent, AWListModule, CardComponent, OutlineState, Datatable2Component, DTColumn2Component, DTHeaderComponent2, DTDetailRowComponent, DetailRowExpansionState, Datatable2State, isDTInitParams, DT2DataSource, DTMultiSelectColumnComponent, AWDatatable2Module, WizardProgressComponent, isOutlineNode, AWOutlineForModule, ToggleSwitchComponent, WizardProgressModule, ToggleSwitchModule, AribaComponentsModule, AribaComponentsTestProviderModule, SpyLifeCycleHooksDirective, registerComponents as ɵp, registerComponents$1 as ɵq, DataSource as ɵa, InfiniteScrollComponent as ɵr, CardZoneTitleComponent as ɵh, CardZoneBottomComponent as ɵg, CardZoneTopComponent as ɵf, AWCardModule as ɵb, CB_LIST_CONTROL_VALUE_ACCESSOR as ɵc, CB_CONTROL_VALUE_ACCESSOR as ɵm, DTDetailRowExpanderComponent as ɵu, DTSingleSelectColumnComponent as ɵv, SetCellMaxWidthDirective as ɵx, DTDraggableRowDirective as ɵw, DTWrapper as ɵt, DD_CONTROL_VALUE_ACCESSOR as ɵd, AWHoverCardModule as ɵz, LB_CONTROL_VALUE_ACCESSOR as ɵo, InitNestingDirective as ɵi, AWOverlayModule as ɵy, SidenavComponent as ɵj, RB_LIST_CONTROL_VALUE_ACCESSOR as ɵe, RAB_CONTROL_VALUE_ACCESSOR as ɵn, EDITOR_CONTROL_VALUE_ACCESSOR as ɵl, SectionActionsComponent as ɵk };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJpYmF1aS1jb21wb25lbnRzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZW1iZWRkZWQtaXRlbS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2dlbmVyaWMtY29udGFpbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Jhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvb24tbmdmb3Itc2V0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RvbS11dGlscy5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvaW5maXRlLXNjcm9sbC9pbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9jb3JlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9hcnJheS1kYXRhLXByb3ZpZGVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycy50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RhdGEvZGF0YS1maW5kZXJzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9sYXlvdXRzL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9idXR0b24vYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLXRpdGxlL2NhcmQtdGl0bGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9oeXBlcmxpbmsvaHlwZXJsaW5rLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRlLWFuZC10aW1lLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWZvb3Rlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtc3RhdGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3RleHQtYXJlYS90ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1ldmVudHMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1saWZlY3ljbGUuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIvb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1hY3Rpb25zL3BhZ2UtYWN0aW9ucy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1jb250ZW50L3BhZ2UtY29udGVudC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwL3N0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3NlY3Rpb24vc2VjdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9hdy1kYXRhdGFibGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RpcmVjdGl2ZXMvZHQtY2VsbC1kaXJlY3RpdmVzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9saXN0L2xpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3dpemFyZC1wcm9ncmVzcy93aXphcmQtcHJvZ3Jlc3MuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvd2l6YXJkLXByb2dyZXNzL3dpemFyZC1wcm9ncmVzcy5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy90b2dnbGUtc3dpdGNoL3RvZ2dsZS1zd2l0Y2guY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdG9nZ2xlLXN3aXRjaC90b2dnbGUtc3dpdGNoLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3NweS1saWZlY3ljbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvYXJpYmEuY29tcG9uZW50Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9hcmliYS5jb21wb25lbnQucHJvdmlkZXIubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBXaGVuIHdlIGhhdmUgYSBjdXN0b20gY29tcG9uZW50IGxpa2UgZHJvcGRvd24sIHJhZGlvYnV0dG9ubGlzdCBhbmRcbiAqIG1hbnkgbW9yZSB3ZSB3YW50IHRvIHByb3ZpZGUgYSBjdXN0b20gY29udGVudCB0byBpdCBsaWtlIHNvOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICpcbiAqIGBgYFxuICogV2hvIGVsc2Ugd291bGQga25vdyBob3cgdG8gcmVuZGVyIGxpc3Qgb2Ygb2JqZWN0cy4uXG4gKlxuICogQnV0IGl0cyBub3QgcG9zc2libGUgaW4gY3VycmVudCBmb3JtLiBpZiBJIGRvIG5vdCBwcm92aWRlIEFuZ3VsYXIgc29tZSBhcyB0aGV5IGNhbGwgaXQgdGhpc1xuICogc3ludGFjdGljIHN1Z2FyICosXG4gKlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biAqbXlTdWdlckRpcmVjdGl2ZT0uLi4uLj5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICogYGBgXG4gKlxuICpcbiAqIHRoZW4gYW5ndWxhciB3aWxsIG5vdCBrbm93ICBpbnNpZGUgaXMgYSB0ZW1wbGF0ZSBhbmQgSSB3b250IGJlIGFibGUgdG8gZ2V0IGhvbGQgb2YgVGVtcGxhdGVSZWZcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50XG4gKlxuICogU28gdGhlIG9ubHkgd2F5IEkgZm91bmQgKGV4cGVjdGluZyBJIGRvIG5vdCB3YW50IHRvIGNoYW5nZSBhbnl0aGluZyBpbiB0ZXJtcyBvZiBiaW5kaW5ncyBhbmQgdGhlXG4gKiBzaWduYXR1cmUgSSB1c2UgaXQuIEkgaGF2ZSB0byB1c2UgaXQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtPiB7e2l0ZW0udXNlck5hbWV9fTwvbmctdGVtcGxhdGU+XG4gKlxuICogICA8YXctZHJvcGRvd25cbiAqXG4gKiBgYGBcbiAqXG4gKiAgVGhpcyB3YXkgaXQgY291bGQgd29yay4gU2luY2UgSSBhbSBpbnNpZGUgbmdGb3IgSSB3YW50IHRvIHJlbmRlciB0aGUgaXRlbSBpbnRvIHRoZSBjb3JyZWN0XG4gKiB2aWV3Q29udGFpbmVyIG9mIG5nRm9yJ3MgY3VycmVudCBpdGVtLlxuICpcbiAqICBUaGlzIHdheSBJIGNhbiBhbHNvIGV4cG9zZSBpdGVtIG91dHNpZGUgdXNpbmcgQW5ndWxhcidzIHNwZWNpYWwgbG9jYWwgdmFyaWFibGUgY2FsbGVkOlxuICogJGltcGxpY2l0LlxuICpcbiAqIFRoaXMgZ2V0cyBldmVuIG1vcmUgY29tcGxleCBpZiB3ZSB0cnkgdG8gcGFzcyB0aGlzIHRlbXBsYXRlIDIgbGV2ZWxzIGRvd24sIGxpa2UgaW4gY2FzZSBvZlxuICogUmFkaW9CdXR0b25MaXN0LiBCdXQgbGF0ZXIgb24gSSBtaWdodCB3YW50IHRvIHJlZmFjdG9yIHRoaXMgaW50byBjdXN0b20gTkcgRk9SXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbmdUZW1wbGF0ZU91dGxldCAod2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tlbWJlZGRlZEl0ZW1dJ30pXG5leHBvcnQgY2xhc3MgRW1iZWRkZWRJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzXG57XG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgd2Ugd2FudCB0byByZW5kZXIgTi1UaW1lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1iZWRkZWRJdGVtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFZhbHVlID0gaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbXBsaWNpdFZhbHVlOiBhbnk7XG4gICAgcHJpdmF0ZSBfdmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fdmlld1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXIuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZW1iZWRkZWRJdGVtKSkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgRW1iZWRlZEl0ZW0odGhpcy5faW1wbGljaXRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5lbWJlZGRlZEl0ZW0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgQW5ndWxhcidzIEVtYmVkZGVkVmlld1JlZi5jb250ZXh0KClcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBFbWJlZGVkSXRlbVxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ6IGFueSlcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCBpcyB1c2VkIGJ5IGluY2x1ZGUtY29tcG9uZW50LmRpcmVjdGl2ZSB0byBkeW5hbWljYWxseSBjcmVhdGUgYW5cbiAqIEhUTUxFbGVtZW50IGFuZCB1c2UgdGhpcyBlbGVtZW50IHRvIHdyYXAgYSBjaGlsZCBjb21wb25lbnQuIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvXG4gKiBtb2RpZnkgYSBjaGlsZCBieSB3cmFwcGluZyBpdCB3aXRoIGEgYm9yZGVyLCBhIGJhY2tncm91bmQsIG9yIGJvbGQgaXRzIHRleHQuXG4gKlxuICogVGhlIHdyYXBwZXIgZWxlbWVudCBpcyBkeW5hbWljYWxseSBjcmVhdGVkLiBJdCdzIGVsZW1lbnQgaXMgc3BlY2lmaWVkIGJ5IHRoZSB0YWdOYW1lIHByb3BlcnR5IGluXG4gKiB0aGUgYmluZGluZ3MgQElucHV0LlxuICpcbiAqICAjIyMgRXhhbXBsZS4gIERpcmVjdGx5IGluIGh0bWxcbiAqXG4gKiAgIGFwcC5odG1sXG4gKiAgICAgIDxhdy1nZW5lcmljLWNvbnRhaW5lciB0YWdOYW1lPVwidGFnTmFtZVwiIGJpbmRpbmdzPVwiYmluZGluZ3NcIj5cbiAqICAgICAgICAgIDxteS1jb21wb25lbnQgLi5iaW5kaW5ncy4uPjwvbXktY29tcG9uZW50PlxuICogICAgICA8L2F3LWdlbmVyaWMtY29udGFpbmVyPlxuICpcbiAqICAgYXBwLmNvbXBvbmVudC50c1xuICpcbiAqICAgICAgIHRhZ05hbWUgPSAoYkJvbGQpID8gJ2gxJyA6ICdzcGFuJztcbiAqICAgICAgIGJpbmRpbmdzID0geyAgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnIH1cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZ2VuZXJpYy1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgc3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrXG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRhZ05hbWUgaWYgbm9uZSBpcyBzcGVjaWZpZWQgaW5zaWRlIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IERlZmF1bHRUYWdOYW1lID0gJ2Rpdic7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kaW5ncyB0byBiZSBhZGRlZCBhcyBhdHRyaWJ1dGVzIHRvIHRoZSB0YWdOYW1lIGVsZW1lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gYmUgY3JlYXRlZCB0aGF0IHdyYXBzIGl0J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhZ05hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByb290IGVsZW1lbnQuIFBvaW50cyB0byA8YXctZ2VuZXJpYy1jb250YWluZXI+XG4gICAgICovXG4gICAgcHJpdmF0ZSBuYXRpdmVFbGVtZW50OiBOb2RlO1xuXG4gICAgcHJpdmF0ZSBjaGlsZEVsZW1lbnQ6IE5vZGU7XG5cblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHJlbmRlcmVyIC0gUmVuZGVyZXIgaXMgdXNlZCB0byBjcmVhdGUgJ3RhZ05hbWUnIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiwgdmVyaWZ5IHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGlucHV0LCB0aGlzIGNvbXBvbmVudCB3b3VsZG4ndCBrbm93IHdoYXQgdG8gZG8gYW5kIHRocm93IGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5iaW5kaW5ncykgJiYgaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbmVyaWNDb250YWluZXJDb21wb25lbnQgaW5wdXQgYmluZGluZ3Mgb3IgdGFnTmFtZSAnICtcbiAgICAgICAgICAgICAgICAnaGF2ZSBub3QgYmVlbiBzZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdGFnTmFtZSBpcyBibGFuaywgdGhlIGdldCBpdCBmcm9tIGJpbmRpbmdzLlxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ05hbWUgPSB0aGlzLmJpbmRpbmdzLmdldCgndGFnTmFtZScpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9IEdlbmVyaWNDb250YWluZXJDb21wb25lbnQuRGVmYXVsdFRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGZpcnN0IGFkZGVkXG4gICAgICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY2hpbGRFbGVtZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5jaGlsZEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblxuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBjb250ZW50IGhhcyBiZWVuIGluaXRpYWxpemVkLiBDcmVhdGUgdGhlIHRhZ05hbWUgZWxlbWVudC4gQXBwbHkgYWxsIHRoZSBiaW5kaW5ncyBvbiB0b1xuICAgICAqIHRoZSBlbGVtZW50IGFzIGF0dHJpYnV0ZS4gRmluYWxseSwgbW92ZSB0aGUgY2hpbGQgZWxlbWVudCwgPG5nLWNvbnRlbnQ+LCB0byBpbnNpZGUgdGhlXG4gICAgICogd3JhcHBlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb1JlbmRlcigpXG4gICAge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmF0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5uYXRpdmVFbGVtZW50LCBlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBiaW5kaW5ncyBhbmQgYWRkIHRoZW0gdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUodGhpcy5iaW5kaW5ncykuZm9yRWFjaCgodiwgaykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgaywgdik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoaXMgZGl2RWxlbWVudC5cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgIH1cblxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RG9DaGVjaywgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBcHBDb25maWcsIEVudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqICBCYXNlIGNvbXBvbmVudCBzaGFyZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgYW1vbmcgYWxsIHRoZSBjb21wb25lbnRzIChsYXlvdXRzLCB3aWRnZXRzKS5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2ssIE9uRGVzdHJveVxue1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBkaXNhYmxlZCBmbGFnIHRvIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogV2VhdGhlciB0aGlzIGNvbXBvbmVudCBpcyB2aXNpYmxlXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZTtcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgIHRoZSBjb21wb25lbnQgaWYgd2UgYXJlIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFibGU/OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGNvbXBvbmVudCBoYXZlIG9wdGlvbiB0byBzZXQgYSBjdXN0b20gd2l0aFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB3aWR0aDogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlcnkgY29tcG9uZW50IGhhdmUgb3B0aW9uIHRvIHNldCBhIGN1c3RvbSB3aXRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoZWlnaHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIG9wdGlvbmFsIGNzcyBjbGFzcyB3aGljaCBjYW4gYmUgdXRpbGl6ZWQgYnkgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdHlsZUNsYXNzOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHBhZGRpbmcgZnJvbSB0aGUgY29tcG9uZW50LiBVc3VhbGx5IHVzZWQgd2hlbiB3ZSBhcmUgbmVzdGluZyBvdGhlciBjb21wb25lbnQgd2l0aFxuICAgICAqIGl0cyBvd24gZ3JpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9taXRQYWRkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBleHRlbnNpb24gc3VwcG9ydCByZWdpc3RlciBoZXJlIGFueSBkeW5hbWljIGZpZWxkIHRoYXQgZG9lcyBub3QgZXhpc3Rpbmcgb24gdGhlXG4gICAgICogY2xhc3MvY29tcG9uZW50XG4gICAgICovXG4gICAgZXh0QmluZGluZ3M6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFByZWZpeCBmb3IgdGhlIGNvcnJlY3QgYXNzZXQgcGF0aFxuICAgICAqL1xuICAgIGFzc2V0Rm9sZGVyOiBzdHJpbmcgPSAnYXNzZXRzJztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY/OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHRoaXMuZXh0QmluZGluZ3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgICB0aGlzLm9taXRQYWRkaW5nID0gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmFzc2V0Rm9sZGVyID0gdGhpcy5lbnYuZ2V0VmFsdWUoQXBwQ29uZmlnLkFzc2V0Rm9sZGVyKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudCwgbm9vcCwgdXVpZH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge2ZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBQaXBlVHJhbnNmb3JtLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIHgtc21hbGwgPSA+IDEyJSAgPSA+IGNvbC0xXG4gKiBzbWFsbCA9ID4gYFxuICogbWVkaXVtID0gPiA1MCUgICA9ID4gY29sLTZcbiAqIGxhcmdlID0gPiA3NSUgICAgPSA+IGNvbC05XG4gKiBsYXJnZSA9ID4gMTAwJSAgID0gPiBjb2wtMTJcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIFdpZGdldFNpemUgPSAneC1zbWFsbCcgfCAnc21hbGwnIHwgJ21lZGl1bScgfCAnbGFyZ2UnIHwgJ3gtbGFyZ2UnO1xuXG5leHBvcnQgZW51bSBXaWRnZXRTaXplQ29sdW1uc1xue1xuICAgIHhzbWFsbCA9IDEsXG4gICAgc21hbGwgPSAzLFxuICAgIG1lZGl1bSA9IDYsXG4gICAgbGFyZ2UgPSA5LFxuICAgIHhsYXJnZSA9IDEyXG59XG5cblxuLyoqXG4gKiAgQmFzZUZvcm1Db21wb25uZXQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGZvciBhZGQgc3BlY2lmaWMgZm9ybSBiZWhhdmlvclxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VGb3JtQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG57XG4gICAgLypcbiAgICAgKiAgU3VwcG9ydGVkIGxheW91dCBjb25zdGFudHMuIEl0IGlzIGV4cGVjdGVkIHRoZXJlIHdpbGwgYmUgbW9yZSBvcHRpb25zIGFzIHdlIGN1cnJlbnRseVxuICAgICAqICBzdXBwb3J0IG9ubHkgdGhlc2UgdHdvIHRoZXJlIHdpbGwgYmUgb3RoZXIgdmFyaWF0aW9ucyBvZiBpdC4gZS5nLiBmb3Igc3RhY2tlZCBpdCB3aWxsIG5vdFxuICAgICAqICBiZSAxIGNvbHVtbnMgbGlrZSBpdCBpcyBub3cgYnV0IG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWFkb25seSBMYXlvdXRTdGFja2VkID0gJ3N0YWNrZWQnO1xuICAgIHN0YXRpYyByZWFkb25seSBMYXlvdXRJbmxpbmUgPSAnaW5saW5lJztcblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IG5hbWUgYXR0cmlidXRlLiBDYW4gYmUgdXNlZCB0byBsb29rdXAgY29tcG9uZW50IGluIGZvcm0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBuYW1lOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCBJZC4gQ2FuIGJlIHVzZWQgdG8gbG9va3VwIGNvbXBvbmVudCBpbiBmb3JtLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyBjdXJyZW50IGVsZW1lbnQgdmlzaWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHBhc3MgaW4gZm9ybUdyb3VwIHdoaWNoIHdpbGwgYmUgdXNlZCB3aXRoIGluIHRoZSBmb3JtXG4gICAgICpcbiAgICAgKiBASW5wdXQoKSAtIHNlZSBnZXR0ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIF9mb3JtR3JvdXA6IEZvcm1Hcm91cDtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyByZXF1aXJlZCBmbGV4IGFyb3VuZCB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqICBhIHRleHQgZGlzcGxheWVkIHdoZW4gdmFsdWUgaXMgZW1wdHkgb3IgTlVMTFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGxhY2VIb2xkZXI6IFN0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZnkgaWYgdGhpcyBjb250cm9sIGlzIHVzZWQgZGlyZWN0bHkgb3IgaWYgaXRzIHBhcnQgb2Ygc29tZSBvdGhlciBjb250cm9sXG4gICAgICogZS5nLiBHZW5lcmljQ2hvb3NlciBhbmQgbWFuYWdlZCBieSB0aGlzIGNvbnRyb2wuXG4gICAgICogTWVhbmluZyBTdGF0ZSBpcyBtYW5hbmdlZCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzU3RhbmRhbG9uZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm0gQ29udHJvbCBmb3IgdGhlIGNvbXBvbmVudC4gSXRzIGVpdGhlciBpbmhlcml0ZWQgc2luY2UgaXQgd2FzIHByZWNyZWF0ZWQgaW4gcGFyZW50XG4gICAgICogY29tcG9uZW50IG9yIGl0cyBjcmVhdGVkIGJhc2VkIG9uIHBhc3NlZCAnbmFtZScgYW5kIHJlZ2lzdGVyZWQgd2l0aCB0aGUgJ2Zvcm1Hcm91cCdcbiAgICAgKlxuICAgICAqIFdoZW4gIGluaXRpYWxpemUgRm9ybUNvbnRyb2wgd2UgZG8gc2V0VmFsdWUgd2l0aCBvbmx5U2VsZjp0cnVlIGZsYWcgYW5kIHdlIGRvIG5vdCBlbWl0IGFueVxuICAgICAqIGV2ZW50IG91dHNpZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGZvcm1Db250cm9sOiBGb3JtQ29udHJvbDtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHRoYXQgY2FuIGJlIGFzc2lnbiB0byB0aGUgY29tcG9uZW50IGluIG9yZGVyIHRvIGZvcm1hdCBpdHMgaW5wdXRcbiAgICAgKi9cbiAgICBmb3JtYXR0ZXI6IFBpcGVUcmFuc2Zvcm07XG5cblxuICAgIHByb3RlY3RlZCBvbk1vZGVsQ2hhbmdlZDogKF86IGFueSkgPT4gdm9pZCA9IG5vb3A7XG4gICAgcHJvdGVjdGVkIG9uTW9kZWxUb3VjaGVkOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcblxuXG4gICAgLyoqXG4gICAgICogU29tZSBvZiB0aGUgQmFzZUZvcm1Db21wb25lbnQgY2FuIHdyYXAgb3RoZXIgY29tcG9uZW50IGFuZCBpbiB0aGVzZSBjYXNlcyB3ZSB3YW50IHRvXG4gICAgICogaW5oZXJpdCBzb21lIG9mIHRoZSBiZWhhdmlvciBmcm9tIHBhcmVudFxuICAgICAqXG4gICAgICogQEluamVjdChFbnZpcm9ubWVudCkgcHVibGljIGVudjogRW52aXJvbm1lbnQgOiBpcyB0ZW0gYSB3b3JrYXJvdW5kIGFzIHdpdGhvdXQgaW5qZWN0XG4gICAgICogb24gdGhpcyBzcGVjaWZpYyBjb21wb25lbnQgaXQgY29tcGxhaW5zIHRoYXQgRW52aXJvbm1lbnQgaXMgdW5yZXNvbHZlZCBzeW1ib2xcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChASW5qZWN0KEVudmlyb25tZW50KSBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUdyb3VwID0gdGhpcy5wYXJlbnRDb250YWluZXIuZm9ybUdyb3VwO1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0luaXRGb3JtKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGF2YWlsYWJsZSBmb3JtR3JvdXAgYW5kIE5hbWUgYW5kIElEXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2hlY2tJbml0Rm9ybSAoKVxuICAgIHtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmVudi5jdXJyZW50Rm9ybSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9kbzogUmlnaHQgbm93IEkganVzdCBuZWVkIHRvIGluaXRpYWxpemUgbmFtZSAsIGJ1dCBpZGVhbGx5IGl0IG5lZWRzIHRvIGJlIGdlbmVyYXRlZFxuICAgICAgICAgKiBudW1iZXIgYmFzZWRvbiBzb21lIHNlbWFudGljcyBhcHAucGFnZS5jb21wb25lbnQgaWYgdGhlcmUgYXJlIG1vcmUgY29tcG9uZW50IG9uIHRoZSBwYWdlXG4gICAgICAgICAqIHRoZW4gYXBwLnBhZ2UuY29tcG9uZW50TnVtYmVyLiBTaW1wbGUgc29sdXRpb24gaXMgdG8gaXMgdG8gZ2V0IEVsZW1lbnRyZWYgYW5kIHF1ZXJ5IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdXVpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB1dWlkKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBkb1JlZ2lzdGVyIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBGb3JtQ29udHJvbFxuICAgIHtcblxuICAgICAgICBsZXQgZkNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtR3JvdXAucmVnaXN0ZXJDb250cm9sKG5hbWUsIG5ldyBGb3JtQ29udHJvbCh2YWx1ZSkpO1xuICAgICAgICAgICAgZkNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICBsZXQgdXBkYXRlZFZhbHVlOiBhbnkgPSBpc1ByZXNlbnQoZkNvbnRyb2wudmFsdWUpID8gZkNvbnRyb2wudmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgIGZDb250cm9sLnBhdGNoVmFsdWUodXBkYXRlZFZhbHVlLCB7b25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZkNvbnRyb2w7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggRm9ybXMgdGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdG8gcmVnaXN0ZXIgY29udHJvbFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgZGVmYXVsdCB2YWx1ZSB0byBiZSBwcmUtc2V0XG4gICAgICovXG4gICAgcmVnaXN0ZXJGb3JtQ29udHJvbCAodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSB0aGlzLmRvUmVnaXN0ZXIodGhpcy5uYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBASW5wdXQoKSBnZXQgZm9ybUdyb3VwICgpOiBGb3JtR3JvdXBcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fZm9ybUdyb3VwKSA/IHRoaXMuX2Zvcm1Hcm91cCA6IHRoaXMuZW52LmN1cnJlbnRGb3JtO1xuICAgIH1cblxuICAgIHNldCBmb3JtR3JvdXAgKHZhbHVlOiBGb3JtR3JvdXApXG4gICAge1xuICAgICAgICB0aGlzLl9mb3JtR3JvdXAgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgd2UgY2FuIHBhc3MgZmllbGQgdHlwZSBhcyBhIGJpbmRpbmcgdG8gdGhlIGNvbXBvbmVudHMuIGUuZy4gSW5wdXRGaWVsZCBuZWVkXG4gICAgICogc3VjaCB0eXBlIHRvIGNvcnJlY3RseSByZW5kZXIgaW5wdXQgdHlwZT10ZXh0LCBudW1iZXJcbiAgICAgKlxuICAgICAqIHRvZG86IGlzIHRoaXMgbmVlZGVkPyBjYW4gd2UgbWF5YmUgcGFzcyB0aGlzIHRvIHRoZSBmb3JtUm93P1xuICAgICAqL1xuICAgIGNhblNldFR5cGUgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIHdyaXRlVmFsdWUgKHZhbHVlOiBhbnkpXG4gICAge1xuXG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZSAoZm46IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZCAoZm46IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RG9tU2FuaXRpemVyfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSBjb21wb25lbnQgcmVuZGVyaW5nIHZhbHVlcyBpbiB0aGUgcmVhZCBvbmx5IG1vZGUuIEp1c3QgbmVlZGVkIHNvbWUgY29tcG9uZW50IHVzZWRcbiAqIHRvIHJlbmRlciBTdHJpbmdzIGluIHJlYWQgb25seSBtb2RlXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICpcbiAqIFVzaW5nIGl0IGluc2lkZSBmb3JtIGNvbnRhaW5lciBhbG9uZyB3aXRoIGxhYmVsXG4gKlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgIHNlbGVjdG9yOiAndXNlckluZm8nICxcbiAqICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgW2VkaXRhYmxlXT1cImZhbHNlXCIgPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbmFtZV09XCJmaWVsZE5hbWVcIiAgW2xhYmVsXT1cImxhYmVsXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiA+PC9hdy1zdHJpbmc+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgICB9KVxuICogICAgICAgICAgZXhwb3J0IGNsYXNzIFVzZXJQcm9maWxlQ29tcG9uZW50XG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgdGV4dCc7XG4gKiAgICAgICAgICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICAgICAgICAgICAgICBmaWVsZE5hbWU6IHN0cmluZyA9ICdmaXJzdE5hbWUnO1xuICogICAgICAgICAgICAgIGxhYmVsOiBzdHJpbmcgPSAnTXkgTmFtZSc7XG4gKiAgICAgICAgICAgICAgcmVxdWlyZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICAgICAgICAgIGVkaXRpbmc6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICAgICAgICAgIGxhYmVsc09uVG9wOiBib29sZWFuID0gZmFsc2U7XG4gKlxuICogICAgICAgICAgfVxuICpcbiAqICBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBodG1sIHRhZ3MuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN0cmluZycsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ3LXN0cmluZy1maWVsZFwiIFtpbm5lckhUTUxdPVwidmFsdWVcIj48L3NwYW4+XG4gICAgYCxcbiAgICBzdHlsZVVybHM6IFsnc3RyaW5nLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU3RyaW5nQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiAgVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIF92YWx1ZTogc3RyaW5nID0gJyc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIHNhbml0aXplcjogRG9tU2FuaXRpemVyLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICB9XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbCh0aGlzLl92YWx1ZSk7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzU3RyaW5nTWFwfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIEEgY2xhc3MgaG9sZGluZyBhIHJlZmVyZW5jZXMgdG8gY29tcG9uZW50cy4gVGhlIG1ldGhvZHMgYXJlIHNlbGYtZXhwbGFuYXRvcnkuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50UmVnaXN0cnlcbntcbiAgICBwcml2YXRlIF9uYW1lVG9UeXBlOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBpbml0aWFsaXplKHJlZmVyZW5jZXM6IGFueSk6IFByb21pc2U8YW55PlxuICAgIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclR5cGVzKHJlZmVyZW5jZXMpO1xuICAgICAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+ID0gbmV3IFByb21pc2UoKHJlc29sdmU6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuXG4gICAgfVxuXG5cbiAgICByZWdpc3RlclR5cGUobmFtZTogc3RyaW5nLCB0eXBlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMubmFtZVRvVHlwZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWVUb1R5cGUuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZWdpc3RlclR5cGVzKHJlZmVyZW5jZXM6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghaXNTdHJpbmdNYXAocmVmZXJlbmNlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHJlZmVyZW5jZXMpLmZvckVhY2goKG5hbWU6IHN0cmluZykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclR5cGUobmFtZSwgcmVmZXJlbmNlc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZ2V0IG5hbWVUb1R5cGUoKTogTWFwPHN0cmluZywgYW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVUb1R5cGU7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbXBvbmVudEZhY3RvcnksXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIENvbXBvbmVudFJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIGlzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1N0cmluZ0NvbXBvbmVudH0gZnJvbSAnLi4vd2lkZ2V0cy9zdHJpbmcvc3RyaW5nLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbXBvbmVudFJlZmVyZW5jZX0gZnJvbSAnLi9jb21wb25lbnQtcmVmZXJlbmNlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG4vKipcbiAqIHRoaXMgaXMgc3BlY2lmaWMgaW1wb3J0IHRvIHdlIGNhbiB1c2UgY29tcG9uZW50cyBhcyBjb21wb25lbnRzW3R5cGVuYW1lXSBhbmQgIGdldCBiYWNrIGFcbiAqIHR5cGUuXG4gKiBJIGNvdWxkIG5vdCBmaW5kIGFueSBiZXR0ZXIgZHluYW1pYyB3YXkgdXAgdG8gbm93XG4gKi9cbi8qKlxuICogIGBJbmNsdWRlQ29tcG9uZW50YCBkaXJlY3RpdmUgZHluYW1pY2FsbHkgaW5zdGFudGlhdGUgYW5kIGluc2VydCBhIGNvbXBvbmVudHMgaW50byB0aGUgc2NyZWVuXG4gKiBiYXNlZCBvbiB0aGUgbmFtZS4gSXQgY2FuIGFjY2VwdHMgYmluZGluZ3MgYXMgd2VsbCB3aGljaCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYm91bmQgYW5kIGFwcGxpZWRcbiAqIHRvIHRoZSBjb21wb25lbnRcbiAqXG4gKiAgIyMjIHVzYWdlOlxuICpcbiAqICBJbnN0ZWFkIG9mIGluc2VydGluZyBjb21wb25lbnQgaW4gdGhlIHdheTpcbiAqXG4gKiAgYGBgXG4gKiAgICA8dGV4dGZpZWxkIHZhbHVlPVwic29tZSB2YWx1ZVwiPlxuICpcbiAqICBgYGBcbiAqXG4gKiAgeW91IGNhbiBkbyBzbyBkeW5hbWljYWxseSBsaWtlIHRoaXM6XG4gKlxuICogYGBgXG4gKiAgPGF3LWluY2x1ZGUtY29tcG9uZW50ICdUZXh0ZmllbGRDb21wb25lbnQnIFtiaW5kaW5nc109YmluZGluZ3MgPjwvYXctaW5jbHVkZS1jb21wb25lbnQ+XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGJ1aWxkaW5nIGJsb2NrIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBVSS5cbiAqXG4gKlxuICogVG9kbzogQ3VycmVudGx5IHRoZSB3YXkgQW5ndWxhciBBUEkgd29yayBhbmQgd2UgdXNlIGl0IHRvIGNyZWF0ZSBwcm9ncmFtYXRpY2FsbHkgY29tcG9uZW50c1xuICogaXMgdG9vIGNvbXBsZXh0IHdlIG5lZWQgdG8gY3JlYXRlIGV2ZXJ5dGhpbmcgMyBkaWZmZXJlbnQgY2FsbHMgdG8gcGxhY2UgYSBjb21wb25lbnQgdG8gdGhlXG4gKiBjb250YWluZXIuIFdoYXQgSSB3YW50IGlzIGlzIHRvIGNyZWF0ZSBzb21lIGtpbmQgb2YgcmVwcmVzZW50YXRpb24gb2YgQ29udGFpbmVyRWxlbWVudCBhbmQgdGhpc1xuICogY2FuIGJlIGFsc28gcGFyZW50IGZvciBvdXIgQmFzZUNvbXBvbmVudCB3aXRoIG1ldGhvZCBhZGQgYW5kIHJlbW92ZSBjb250ZW50LiBUaGVuIHdlIGNvdWxkIGhhdmVcbiAqIHNvbWUgQVdDb250ZW50LlxuICpcbiAqIGUuZy46IHRvIHJlcGxhY2UgYXBwbHlDb250ZW50RWxlbWVudElmQW55IHdoZXJlIHdlIGhhdmUgc2V2ZXJhbCBjYWxscyB0byBjcmVhdGUgYW5kIGFkZFxuICogY29tcG9uZW50IHRvIHRoZSB2aWV3LlxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRhaW5lckVsZW1lbnQgPSBBV0NvbmNyZXRlVGVtcGxhdGUodmlld0NvbnRhaW5lciwgZmFjdG9yeVJlc29sdmVyKVxuICogIGNvbnRhaW5lckVsZW1lbnQuYWRkKCdDbGNrIE1lJylcbiAqIGBgYFxuICpcbiAqIFRvIGFzc2VtYmxlIGRpZmZlcmVudCBjb21wb25lbnRzIHRvZ2V0aGVyIC0gbm90IG9ubHkgYWRkaW5nIHN0cmluZyBjb250ZW50XG4gKlxuICogYGBgdHNcbiAqICBsZXQgY29udGVudCA9IG5ldyBBV0NvbnRlbnQoQnV0dG9uQ29tcG9uZW50LCBiaW5kaW5nc01hcClcbiAqICBjb250ZW50LmFkZCgnQ2xpY2sgTWUnKTtcbiAqICBjb250YWluZXJFbGVtZW50LmFkZChjb250ZW50KVxuICpcbiAqIGBgYFxuICpcbiAqIGFkZCBtb3JlIGNvbXBvbmVudCBoaWVyYXJjaHk6XG4gKlxuICogYGBgdHNcbiAqICBsZXQgY29udGVudCA9IG5ldyBBV0NvbnRlbnQoSG92ZXJDYXJkQ29tcG9ubmV0cywgYmluZGluZ3NNYXApXG4gKiAgY29udGVudC5hZGQoY3JlYXRlTGF5b3V0KCk7XG4gKiAgY29udGFpbmVyRWxlbWVudC5hZGQoY29udGVudClcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5jbHVkZS1jb21wb25lbnQnXG59KVxuZXhwb3J0IGNsYXNzIEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIHN0YXRpYyByZWFkb25seSBOZ0NvbnRlbnQgPSAnbmdjb250ZW50JztcbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdDb250ZW50RWxlbWVudCA9ICduZ2NvbnRlbnRFbGVtZW50JztcblxuICAgIC8qKlxuICAgICAqIEZ1bGwgY29tcG9uZW50IG5hbWUgZS5nLjogRHJvcGRvd25Db21wb25lbnQgd2hpY2ggaXMgZ29pbmcgdG8gYmUgaW5zZXJ0ZWQuIFdlIG5lZWQgdG8gdGFrZVxuICAgICAqIHRoaXMgbmFtZSBhbmQgdHJhbnNsYXRlIGl0IGludG8gYWN0dWFsIFRZUEUuIEluIG9yZGVyIHRvIGRvIHRoaXMgd2UgdXNlIGEgdHJpY2sgd2hlcmUgd2VcbiAgICAgKiBhY2Nlc3MgYW4gSU1QT1JURUQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi4vY29tcG9uZW50cyc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGVuIHlvdSBjYW4gcmV0cmlldmUgYSB0eXBlIGJ5IGp1c3QgY29tcG9uZW50c1s8U3RyaW5nIExpdGVyYWwgPl0gPT4gQ29tcG9uZW50IFRZUEVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGJpbmRpbmdzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGludG8gdGhlIGNvbXBvbmVudCB3aGVuIGluc3RhbnRpYXRlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIGJpbmRpbmdzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjcmVhdGVkIGNvbXBvbmVudCByZWZlcmVuY2UgdXNpbmcgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLiBXZSB1c2UgdGhpcyB0byBhY2Nlc3NcbiAgICAgKiB0aGUgYWN0dWFsIGNvbXBvbmVudCBpbnN0YW5jZSBhbmQgRWxlbWVudCBSZWZlcmVuY2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3VycmVudENvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBJIHVzZSB0aGlzIGZsYWcgdG8gaWRlbnRpZnkgdGhhdCBjb21wb25lbnQgaXMgcmVuZGVyaW5nIGZvciBmaXJzdCB0aW1lIG9yIGl0cyB1cGRhdGVkIGR1cmluZ1xuICAgICAqIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0UmVuZGVySW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTm90IHN1cmUgaWYgd2UgbmVlZCB0aGlzLCBidXQgd2FudCB0byBrZWVwIGl0IGhlcmUgb3IgbWF5YmUgbW92ZSBpdCB0byBzb21lIHNlcnZpY2Ugc28gd2VcbiAgICAgKiBjYW4gY2FjaGUgY3JlYXRlZCBjb21wb25lbnRzIGFuZCBtYXliZSByZXVzZSB0aGVtLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZmVyZW5jZXM6IE1hcDxzdHJpbmcsIENvbXBvbmVudFJlZmVyZW5jZT4gPVxuICAgICAgICBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50UmVmZXJlbmNlPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIGNhY2hlIHRoZSByZXNvbHZlZCBjb21wb25lbnQgcmVmZXJlbmNlIHNvIHdlIGRvbnQgY2FsbCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBldmVyeXRoaW5nIHdlIHdhbnQgdG8gcmVmcmVzaCBhIHNjcmVlblxuICAgICAqL1xuICAgIHJlc29sdmVkQ29tcG9uZW50UmVmOiBDb21wb25lbnRSZWZlcmVuY2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBmYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwdWJsaWMgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KVxuICAgIHtcblxuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIHRoaXMuaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyB0b2RvOiBjaGVjayBpZiB0aGlzIHRoZSByaWdodCBsaWZlY3ljbGUgY2FsbGJhY2ssIHRoaXMgaXMgY2FsbGVkIG9ubHkgb25jZSBhbmQgeW91IHdhbnRcbiAgICAgICAgLy8gdG8gcHJvYmFibHkgbGlzdGVuIGZvciBjaGFuZ2VzLCBhbmQgY2hhbmdlIGRlY3Rpb24gZGVjaWRlIHRoZXJlIGlzIHNvbWUgY2hhbmdlIGFuZCB3ZVxuICAgICAgICAvLyBuZWVkIHRvIHJlLWRyYXcgdGhlIHZpZXdcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZG9SZW5kZXJDb21wb25lbnQoKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ25hbWUnXSkgJiZcbiAgICAgICAgICAgIChjaGFuZ2VzWyduYW1lJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWyduYW1lJ10ucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5kb1JlbmRlckNvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVySW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhbmQgcmVwb3NpdGlvbiBET00gZWxlbWVudCBib3RoIGZvciB3cmFwcGVyIGFuZFxuICAgICAgICAvLyBjb250ZW50XG4gICAgICAgIHRoaXMuY3JlYXRlV3JhcHBlckVsZW1lbnRJZkFueSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGNvbXBvbmVudCBhbmQgd3JhcCB0aGUgY3VycmVudCBvbmUuXG4gICAgICogSnVzdCBsaWtlIHJlYXRlQ29udGVudEVsZW1lbnRJZkFueSgpIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbFxuICAgICAqIGlzIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIChpbnNpZGUgdGhlIG5nQWZ0ZXJWaWV3SW5pdCgpIClcbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVXcmFwcGVyRWxlbWVudElmQW55KCk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGNvbXBvbmVudCBpbnRvIGFjdHVhbCBWaWV3IENvbnRhaW5lci4gVGhlIHByb2Nlc3MgZ29lcyBhcyB0aGlzLlxuICAgICAqICAxLiBXZSByZXRyaWV2ZSBjb21wb25lbnQgVHlwZSBiYXNlZCBvbiB0aGUgY29tcG9uZW50IG5hbWUsIHdoaWNoIGNyZWF0ZXMgY29tcG9uZW50UmVmXG4gICAgICogIDIuIFBsYWNlIHRoZSBjb21wb25lbnQgb250byB0aGUgc2NyZWVuXG4gICAgICogIDMuIFJlYWQgY29tcG9uZW50IG1ldGFkYXRhLCBtYWlubHkgSU5QVVRzIGFuZCBhcHBseSBiaW5kaW5ncyBmb3IgZWFjaCBvZiB0aGVtXG4gICAgICogIDQuIE1hbnVhbGx5IHNwaW4gY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgdGhlIHNjcmVlbi4gTWFpbmx5IGZvciBjYXNlIHdoZXJlIEkgbmVlZCB0b1xuICAgICAqIHJlZHJhdyBhIHNjcmVlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb1JlbmRlckNvbXBvbmVudCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBsYWNlVGhlQ29tcG9uZW50KCk7XG4gICAgICAgIC8vIHRoaXMuY3VycmVudENvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRhY2goKTtcblxuICAgICAgICB0aGlzLmFwcGx5QmluZGluZ3ModGhpcy5jb21wb25lbnRSZWZlcmVuY2UoKSwgdGhpcy5jdXJyZW50Q29tcG9uZW50LCB0aGlzLmJpbmRpbmdzKTtcbiAgICAgICAgLy8gdGhpcy5jdXJyZW50Q29tcG9uZW50LmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgICAvLyBTdGlsbCBub3Qgc3VyZSBhYm91dCB0aGlzIHdoYXQgYWxsIEkgc2hvdWxkIHJlbGVhc2UgaGVyZS5cbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcG9uZW50Lm9uRGVzdHJveSgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzLmJpbmRpbmdzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyB0aGlzLmJpbmRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlcy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdGhpcy5jb21wb25lbnRSZWZlcmVuY2VzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQbGFjZSBhY3R1YWwgY29tcG9uZW50IG9udG8gdGhlIHNjcmVlbiB1c2luZyBWaWV3Q29udGFpbmVyUmVmXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGxhY2VUaGVDb21wb25lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHJlZmVyZW5jZSA9IHRoaXMuY29tcG9uZW50UmVmZXJlbmNlKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVDb21wb25lbnQocmVmZXJlbmNlLnJlc29sdmVkQ29tcEZhY3RvcnkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbnNlcnRpbmcgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gaGF2ZSBhIGNvbnRlbnQgbGlrZSBlLmcuIGh5cGVybGluayBvciBidXR0b25cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgPGJ1dHRvbj4gTVkgTkcgQ09OVEVOVCA8L2J1dHRvbj5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICB0aGlzIG1ldGhvZCBhcHBsaWVzIGFuZCBpbnNlcnQgYSBjaGlsZCBjb250ZW50IGludG8gdGhlIG1haW4gY29tcG9uZW50LiBUaGlzIG1ldGhvZCBpbnNlcnRcbiAgICAgKiBhIHNpbXBsZSBzdHJpbmcuIFdlIGFyZSBub3Qgd3JhcHBpbmcgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggYW5vdGhlciBjb21wb25lbnQgaGVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gbmVlZCB0byBydW4gZGV0ZWN0IGNoYW5nZXMgPyBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKTogYm9vbGVhblxuICAgIHtcblxuICAgICAgICBsZXQgZGV0ZWN0Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgbmdDb250ZW50ID0gdGhpcy5uZ0NvbnRlbnQoKTtcbiAgICAgICAgbGV0IG5nQ29udGVudEVsZW1lbnQgPSB0aGlzLm5nQ29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChuZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICBsZXQgYXdDb250ZW50Q29tcG9uZW50ID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoU3RyaW5nQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGF3Q29udGVudENvbXBvbmVudCwgMCk7XG5cbiAgICAgICAgICAgICg8U3RyaW5nQ29tcG9uZW50PmNvbXBvbmVudC5pbnN0YW5jZSkudmFsdWUgPSBuZ0NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgYXdDb250ZW50Q29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGF3Q29udGVudENvbnRhaW5lci5hcHBlbmRDaGlsZChjb21wb25lbnQubG9jYXRpb24ubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGRldGVjdENoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudChuZ0NvbnRlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbnRlbnQgRWxlbWVudDogJywgbmdDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGV0ZWN0Q2hhbmdlcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmUgYSBORyBDb250ZW50IGZyb20gYmluZGluZyBsaXN0IGFuZCByZW1vdmUgaXQgc28gaXQgaXRzIG5vdCBwcmVwYWdhdGVkIGRvd24gd2hlblxuICAgICAqIGFwcGx5aW5nIG90aGVyIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG5nQ29udGVudCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBjb250ZW50OiBhbnk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29udGVudCA9IHRoaXMuYmluZGluZ3MuZ2V0KEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MuZGVsZXRlKEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cblxuICAgIHByb3RlY3RlZCBuZ0NvbnRlbnRFbGVtZW50KCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IGNvbnRlbnQ6IGFueTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjb250ZW50ID0gdGhpcy5iaW5kaW5ncy5nZXQoSW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZS5OZ0NvbnRlbnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MuZGVsZXRlKEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBjb252ZXJ0IGEgY29tcG9uZW50IG5hbWUgdG8gYWN0dWFsIGEgdHlwZSBhbmQgdGhlbiB1c2UgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogdG8gaW5zdGFudGlhdGUgYSBhIGNvbXBvbmVudCBhbmQgc2F2ZSBpdHMgaW5mb3JtYXRpb24gaW50byBvdXIgY29tcG9uZW50IHJlZmVyZW5jZXMuIFRoZVxuICAgICAqIHJlYXNvbiB3aHkgd2UgaGF2ZSB0aGlzIGNvbXBvbmVudCByZWZlcmVuY2UgaXMgd2UgbmVlZCB0byBzdG9yZSBBbmd1bGFyJ3MgY29tcG9uZW50IG1ldGFkYXRhXG4gICAgICogc28gd2UgY2FuIGl0ZXJhdGUgdGhydSBhbGwgdGhlIGlucHV0cyBhbmQgYmluZCB0aGVtIHRvIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogcmV0dXJucyB7Q29tcG9uZW50UmVmZXJlbmNlfSBhIHJlZmVyZW5jZSByZXByZXNlbnRpbmcgYSBjb21wb2VudCBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVmZXJlbmNlKCk6IENvbXBvbmVudFJlZmVyZW5jZVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRDb21wb25lbnRSZWY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJUeXBlID0gdGhpcy5yZXNvbHZlQ29tcG9uZW50VHlwZSgpO1xuICAgICAgICBsZXQgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+ID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjdXJyVHlwZSk7XG5cbiAgICAgICAgbGV0IGNvbXBvbmVudE1ldGE6IENvbXBvbmVudCA9IHRoaXMucmVzb2x2ZURpcmVjdGl2ZShjb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgbGV0IGNvbXBSZWZlcmVuY2U6IENvbXBvbmVudFJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjb21wb25lbnRNZXRhLFxuICAgICAgICAgICAgcmVzb2x2ZWRDb21wRmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGN1cnJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogdGhpcy5uYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZiA9IGNvbXBSZWZlcmVuY2U7XG4gICAgICAgIHJldHVybiBjb21wUmVmZXJlbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocnUgQ29tcG9uZW50TWV0YWRhdGEgQElucHV0cygpIGFuZCBjaGVjayBpZiB3ZSBoYXZlIGF2YWlsYWJsZSBiaW5kaW5nIGluc2lkZSB0aGVcbiAgICAgKiAndGhpcy5iaW5kaW5ncydcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYXBwbHlCaW5kaW5ncyhjUmVmOiBDb21wb25lbnRSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnRSZWY8YW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55Pik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpbnB1dHM6IHN0cmluZ1tdID0gY1JlZi5tZXRhZGF0YS5pbnB1dHM7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoaW5wdXRzKSB8fCBpbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHdlIGRvIGFueSB0eXBlIGNvbnZlcnNpb24/XG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUoYmluZGluZ3MpLmZvckVhY2goKHYsIGspID0+XG4gICAgICAgIHtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wb25lbnQuaW5zdGFuY2Vba10pKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIGNvbXBvbmVudCBUeXBlIGJhc2VkIG9uIHRoZSBzdHJpbmcgbGl0ZXJhbFxuICAgICAqXG4gICAgICogQHJldHVybnMgY29tcG9uZW50IHR5cGUgdXNlZCBieSBgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyYFxuICAgICAqXG4gICAgICogdG9kbzogcmVuYW1lIHRoZSBtZXRob2Qgc28gaXRzIGNsZWFyIHRoYXQgaXQgcmV0dXJucyBjb21wb25lbnQgdHlwZSBiYXNlZCBvbiBzdHJpbmcuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlc29sdmVDb21wb25lbnRUeXBlKCk6IGFueVxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudFR5cGUgPSB0aGlzLmNvbXBSZWdpc3RyeS5uYW1lVG9UeXBlLmdldCh0aGlzLm5hbWUpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIHRoaXMubmFtZSArICcgY29tcG9uZW50IGRvZXMgbm90IGV4aXN0cy4gQ3JlYXRlIER1bW15IENvbXBvbmVudCBpbnN0ZWFkJyArXG4gICAgICAgICAgICAgICAgJyBvZiB0aHJvd2luZyB0aGlzIGVycm9yJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFR5cGU7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZURpcmVjdGl2ZShjb21wRmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+KTogQ29tcG9uZW50XG4gICAge1xuICAgICAgICBsZXQgY29tcE1ldGE6IENvbXBvbmVudCA9IHtcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29tcEZhY3RvcnkuaW5wdXRzKSAmJiBjb21wRmFjdG9yeS5pbnB1dHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBjb21wRmFjdG9yeS5pbnB1dHMuZm9yRWFjaCgoaW5wdXQ6IHtwcm9wTmFtZTogc3RyaW5nLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZ30pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcE1ldGEuaW5wdXRzLnB1c2goaW5wdXQucHJvcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBGYWN0b3J5Lm91dHB1dHMpICYmIGNvbXBGYWN0b3J5Lm91dHB1dHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBjb21wRmFjdG9yeS5vdXRwdXRzLmZvckVhY2goKG91dHB1dDoge3Byb3BOYW1lOiBzdHJpbmcsIHRlbXBsYXRlTmFtZTogc3RyaW5nfSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wTWV0YS5vdXRwdXRzLnB1c2gob3V0cHV0LnByb3BOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wTWV0YTtcbiAgICB9XG5cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jdXJyZW50Q29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52aWV3Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgZGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VycmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U3RyaW5nV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogRXJyb3IgTWFuYWdlciBpcyBhIHNlcnZpY2UgdXNlZCBieSBGb3JtcyBjb21wb25lbnRzIHRvIG1hcCBlcnJvciBjb2RlcyBpbnRvIG1lYW5pbmdmdWwgbWVzc2FnZXMuXG4gKiBDdXJyZW50bHkgaXQgZG9lcyBub3QgaGF2ZSBtdWNoIGJ1dCBvbmNlIHdlIHBsdWcgaW4gbG9jYWxpemF0aW9uIGl0IHdpbGwgbWFrZSBtb3JlIHNlbnNlXG4gKlxuICpcbiAqIHRvZG86IE9uY2UgbmctdHJhbnNsYXRlIGlzIGltcGxlbWVudGVkIHJlcGxhY2UgdGhpcyB3aXRoIG5nLXRyYW5zbGF0ZSBmdW5jdGlvbmFsaXR5IHNvIHdlIGNhblxuICogZXh0ZXJuYWxpemUgdGhlc2UgbWVzc2FnZXMgaW50byBsb2NhbGUgZmlsZXMuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyU2VydmljZVxue1xuICAgIG1lc3NhZ2VzOiB7W2tleTogc3RyaW5nXTogYW55fTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICAgICAgICAncmVxdWlyZWQnOiAnUmVxdWlyZWQgZmllbGQnLFxuICAgICAgICAgICAgJ21pbmxlbmd0aCc6ICdGaWVsZCBkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoJyxcbiAgICAgICAgICAgICdtYXhsZW5ndGgnOiAnRmllbGQgZG9lcyBub3QgbWVldCBtYXhpbXVtIGxlbmd0aCcsXG4gICAgICAgICAgICAnY3VzdG9tTXNnJzogJyVzJyxcbiAgICAgICAgICAgICdtZXRhdmFsaWQnOiAnJXMnXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBlcnJvck1lc3NhZ2UodmFsaWRhdG9yTmFtZTogc3RyaW5nLCB2YWxpZGF0b3JWYWx1ZT86IGFueSlcbiAgICB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1t2YWxpZGF0b3JOYW1lXTtcbiAgICAgICAgaWYgKFN0cmluZ1dyYXBwZXIuY29udGFpbnMobWVzc2FnZSwgJyVzJykpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHVzZSBuZy10cmFuc2xhdGUgd2l0aCBwcm9wZXIgbWVzc2FnZSBmb3JtYXR0aW5nXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2UobWVzc2FnZSwgJyVzJywgdmFsaWRhdG9yVmFsdWUubXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkluaXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZSc7XG5cbi8qKlxuICogRXJyb3JNZXNzYWdlc0NvbXBvbmVudCBpcyB1c2VkIGJ5IGZvcm0ncyBjb21wb25lbnQgbGlrZSBGb3JtUm93IHRvIHByaW50IGl0cyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqIEl0cyAgYmFzZWQgb24gTW9kZWxEcml2ZW4gKFJlYWN0aXZlIGZvcm1zKSBhbmQgaXQgcmVhZHMgZXJyb3JzIGZyb20gRm9ybUNvbnRyb2xcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhLWVycm9yLW1lc3NhZ2VzJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNtYWxsICpuZ0lmPVwiaGFzTWVzc2FnZSgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidWktZy0xMiB1aS1tZXNzYWdlIHVpLW1lc3NhZ2VzLWVycm9yIHVpLWNvcm5lci1hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGVycm9yTXNnIH19XG4gICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIHN0eWxlVXJsczogWydlcnJvci1tZXNzYWdlcy5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIEVycm9yTWVzc2FnZXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXRcbntcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZm9ybSBGb3JtQ29udHJvbGwgdG8gY2hlY2sgZm9yIEVycm9yc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udHJvbDogRm9ybUNvbnRyb2w7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZXJyTWFuYWdlcjogRXJyb3JNYW5hZ2VyU2VydmljZSlcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgIH1cblxuXG4gICAgaGFzTWVzc2FnZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgbXNnID0gdGhpcy5lcnJvck1zZztcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChtc2cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGEgbWVzc2FnZXMgaWYgYW55IHJlZ2lzdGVyZWQgYnkgYWRkZWQgdmFsaWRhdG9yc1xuICAgICAqXG4gICAgICovXG4gICAgZ2V0IGVycm9yTXNnKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHlOYW1lIGluIHRoaXMuY29udHJvbC5lcnJvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRyb2wuZXJyb3JzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkgJiYgdGhpcy5jb250cm9sLnRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJNYW5hZ2VyLmVycm9yTWVzc2FnZShwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5lcnJvcnNbcHJvcGVydHlOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNob3cgZXJyb3JzPyBXZSBjdXJyZW50bHkgc2hvd3MgZXJyb3JzIGlmIHRoZSBjb250cm9sIGlzIG5vdCB2YWxpZCwgaXQgd2FzIHRvdWNoZWQgYnkgdXNlci5cbiAgICAgKiBNb3N0IG9mIHRoZSB0eXBlIG9uIGJsdXIgZXZlbnQgIGFuZCBhdCBsYXN0IGl0cyBub3QgcHJpc3RpbmUgYW55bW9yZSAoaXRzIGRpcnR5KVxuICAgICAqXG4gICAgICovXG4gICAgc2hvd0Vycm9ycygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udHJvbC52YWxpZCAmJiAhdGhpcy5jb250cm9sLnByaXN0aW5lICYmIHRoaXMuY29udHJvbC50b3VjaGVkO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudEZhY3RvcnksXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIENvbXBvbmVudFJlZixcbiAgICBJbmplY3RhYmxlLFxuICAgIFR5cGUsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBNb2RhbCBzZXJ2aWNlIGlzIHVzZWQgdG8gdG8gY3JlYXRlIG1vZGFsIGRpYWxvZ3MuIEl0IGNyZWF0ZXMgbW9kYWwgZGlhbG9ncyBkeW5hbWljYWxseS5cbiAqIFRoZSBzZXJ2aWNlIGFsc28ga2VlcHMgdHJhY2sgb2YgdGhlIGNyZWF0ZWQgbW9kYWwgZGlhbG9nIGFuZCBjYW4gY2xvc2UgaXQgYnkgY2FsbGluZyB0aGVcbiAqIHNlcnZpY2UncyBjbG9zZSgpXG4gKlxuICogTW9kYWwgc2VydmljZSByZXF1aXJlcyBhIFZpZXdDb250YWluZXIgdG8gaW5zZXJ0IG5ld2x5IGNyZWF0ZWQgbW9kYWxzLiBUaGlzIGlzIHRha2VuIGNhcmVcbiAqIGJ5IHRoZSBNb2RhbENvbXBvbmVudC5cbiAqXG4gKiBVc2FnZTpcbiAqICAgICBBZGQgICA8YXctbW9kYWw+PC9hdy1tb2RhbD4gIGludG8geW91ciBhcHBsaWNhdGlvbiBtYWluIGh0bWwuIEl0IG5lZWRzIHRvIGJlIG9uIGV2ZXJ5XG4gKiAgICAgcGFnZSB3aGVyZSBhIG1vZGFsIGRpYWxvZyB3aWxsIGFwcGVhci5cbiAqXG4gKiAgICAxLiAgUG9wdXAgYSBkaWFsb2cgd2l0aG91dCBjcmVhdGluZyB5b3VyIG93biBjb21wb25lbnQuXG4gKiAgICAgICAgVXNlIHRoZSBleGlzdGluZyBEaWFsb2dDb21wb25lbnQgaW4gd2lkZ2V0cy5cbiAqXG4gKiAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5vcGVuPERpYWxvZ0NvbXBvbmVudD4oRGlhbG9nQ29tcG9uZW50LCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnTXkgUG9wdXAgVGl0bGUnLFxuICogICAgICAgICAgICAgICAgICAgICBib2R5OiAnTXkgUG9wdXAgQm9keSdcbiAqICAgICAgICAgICAgICB9KTtcbiAqXG4gKlxuICogICAyLiAgIENyZWF0aW5nIHlvdXIgb3duIERpYWxvZyBDb21wb25lbnQgdG8gcG9wdXAuXG4gKlxuICogICAgICAgICBsZXQgY29tcG9uZW50UmVmID0gdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxNeURpYWxvZ0NvbXBvbmVudD4oTXlEaWFsb2dDb21wb25lbnQsXG4gKiB7aW5wdXRzfSk7XG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LW15ZGlhbG9nJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZyAob25DbG9zZSk9XCJjbG9zZVBvcHVwKClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjdGl0bGVUZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpIGNsYXNzPVwiZmEgZmEtZW52aXJhXCIgPjwvaT5UaGlzIGlzIG15XG4gKiAgICAgVGl0bGUgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjYm9keVRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+PGkgY2xhc3M9XCJmYSBmYS1lbnZpcmFcIiA+PC9pPlRoaXMgaXMgbXlcbiAqICAgICBCb2R5IDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRpYWxvZz5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15RGlhbG9nQ29tcG9uZW50IGV4dGVuZHMgRGlhbG9nQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY2xvc2VQb3B1cCgpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLmNsb3NlKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgIH1cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1vZGFsU2VydmljZVxue1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgYSBzdGF0aWMgbGlzdCBvZiBvdXRwdXQgcGFyYW1ldGVyIGZyb20gRGlhbG9nLCBDb25maXJtYXRpb24gY29tcG9uZW50c1xuICAgICAqIHRoYXQgbmVlZHMgdG8gYmUgaGFuZGxlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIE9VVFBVVF9QQVJBTUVURVJTOiBzdHJpbmdbXSA9IFsnb25DbG9zZScsICdvbkNvbmZpcm0nLCAnb25DYW5jZWwnXTtcblxuXG4gICAgLyoqXG4gICAgICogQ29udGFpbmVyIGZvciB0aGUgbmV3bHkgY3JlYXRlZCBtb2RhbC4gVGhpcyBpcyBwYXNzZWQgaW4gdGhyb3VnaCB0aGVcbiAgICAgKiByZWdpc3RlclZpZXdDb250YWluZXJSZWYoKS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHZjUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmluZyB0aGUgY3JlYXRlZCBtb2RhbCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGluc3RhbmNlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBESSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gYmUgdXNlZCB0byBjcmVhdGUgbW9kYWwgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNmclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2ZyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBQbGFjZUhvbGRlciBmb3IgbW9kYWwgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmNSZWZcbiAgICAgKi9cbiAgICByZWdpc3RlclZpZXdDb250YWluZXJSZWYodmNSZWY6IFZpZXdDb250YWluZXJSZWYpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnZjUmVmID0gdmNSZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIG1vZGFsIGRpYWxvZyBieSBkeW5hbWljYWxseSBjcmVhdGluZyB0aGUgY29tcG9uZW50IGFuZCBhZGRpbmcgaXQgdG8gdmNSZWYuXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuPFQ+KGNvbXBvbmVudDogVHlwZTxUPiwgcGFyYW1ldGVycz86IGFueSk6IENvbXBvbmVudFJlZjxUPlxuICAgIHtcbiAgICAgICAgY29uc3QgY2Y6IENvbXBvbmVudEZhY3Rvcnk8VD4gPSB0aGlzLmNmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnQpO1xuICAgICAgICBsZXQgY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8VD4gPSB0aGlzLnZjUmVmLmNyZWF0ZUNvbXBvbmVudChjZik7XG5cbiAgICAgICAgLy8gQXV0byBzZXQgdmlzaWJsaXR5IHRvIHRydWUuIFNvIHRoYXQgdGhlIERpYWxvZyB3aWxsIGRpc3BsYXlcbiAgICAgICAgcGFyYW1ldGVycyA9IChwYXJhbWV0ZXJzKSA/IHBhcmFtZXRlcnMgOiB7fTtcbiAgICAgICAgcGFyYW1ldGVyc1sndmlzaWJsZSddID0gdHJ1ZTtcblxuICAgICAgICAvLyBIYW5kbGUgb3V0cHV0IHBhcmFtZXRlcnMuXG4gICAgICAgIE1vZGFsU2VydmljZS5PVVRQVVRfUEFSQU1FVEVSUy5mb3JFYWNoKChwYXJhbSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnNbcGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgKDxhbnk+Y29tcG9uZW50UmVmLmluc3RhbmNlKVtwYXJhbV0uc3Vic2NyaWJlKHBhcmFtZXRlcnNbcGFyYW1dKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1ldGVyc1twYXJhbV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIE9iamVjdC5hc3NpZ24oY29tcG9uZW50UmVmLmluc3RhbmNlLCBwYXJhbWV0ZXJzKTtcblxuICAgICAgICAvLyBoYWQgdG8gY2FzdCBpdCBpbiBvcmRlciB0byBhdm9pZCBhbnkgaW5kZXggRXJyb3JcbiAgICAgICAgLy8gQXR0YWNoIGEgZGVzdHJveSBtZXRob2QgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LlxuICAgICAgICAoPGFueT5jb21wb25lbnRSZWYuaW5zdGFuY2UpWydkZXN0cm95J10gPSAoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBjb21wb25lbnRSZWYuZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTYXZlIHRoZSBpbnN0YW5jZSwgc28gaXQgY2FuIGJlIGRlc3Ryb3llZCBsYXRlci5cbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGNvbXBvbmVudFJlZjtcblxuICAgICAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxpbmcgY2xvc2UoKSB3aWxsIHJlbW92ZSB0aGUgbW9kYWwgZnJvbSB2aWV3LlxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgT25Jbml0LCBWaWV3Q2hpbGQsIFZpZXdDb250YWluZXJSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtNb2RhbFNlcnZpY2V9IGZyb20gJy4uL21vZGFsLnNlcnZpY2UnO1xuXG5cbi8qKlxuICogUGxhY2UgaG9sZGVyIGZvciBhbGwgbW9kYWwgZGlhbG9ncy4gVGhpcyBjb21wb25lbnQgd29ya3Mgd2l0aCB0aGUgbW9kYWxTZXJ2aWNlIGJ5IHByb3ZpZGluZ1xuICogYSBwbGFjZSBob2xkZXIgZm9yIGl0IHRvIGluamVjdCBEaWFsb2cgY29tcG9uZW50IGludG8uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbW9kYWwnLFxuICAgIHRlbXBsYXRlVXJsOiAnbW9kYWwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydtb2RhbC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE1vZGFsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICBAVmlld0NoaWxkKCdtb2RhbCcsIHtyZWFkOiBWaWV3Q29udGFpbmVyUmVmfSlcbiAgICB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSlcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2UucmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKHRoaXMudmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGN1cnJlbmN5IGZvcm1hdHRlciB3aWxsIGlnbm9yZSBudWxsIGFuZCBlbXB0eSBzdHJpbmcgZm9yIHZhbHVlLlxuICogSXNzdWUgOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy84Njk0ICBESSBmYWlscyB3aGVuIGV4dGVuZHMgb3RoZXIgY2xhc3Nlc1xuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2N1cnJlbmN5Rm9ybWF0JyxcbiAgICBwdXJlOiBmYWxzZVxufSlcbmV4cG9ydCBjbGFzcyBDdXJyZW5jeUZvcm1hdFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtXG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGN1cnJlbmN5UGlwZTogQ3VycmVuY3lQaXBlKVxuICAgIHtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgLi4uYXJnczogYW55W10pOiBhbnlcbiAgICB7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgbGV0IGN1cnJlbmN5Q29kZSA9ICdVU0QnLCBzeW1ib2xEaXNwbGF5ID0gdHJ1ZSwgZGlnaXRzID0gJzEuMC0yJztcblxuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY29kZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoY29kZSAmJiBjb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeUNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgY3VycmVuY3lDb2RlLCBzeW1ib2xEaXNwbGF5LCBkaWdpdHMpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSB1dGlsaXR5IGRpcmVjdGl2ZSB0aGF0IGlzIHVzZWQgYnkgTkcgRm9yIGN5Y2xlIGluIHNpdHVhdGlvbiB3aGVyZSB3ZSBuZWVkIHRvIGNhbGwgYVxuICogb3IgZXhlY3V0ZSBzb21lIGxvZ2ljIGFmdGVyIGVhY2ggaXRlcmF0aW9uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW25nRm9yU2V0XSdcbn0pXG5leHBvcnQgY2xhc3MgTmdGb3JTZXREaXJlY3RpdmVcbntcblxuICAgIEBPdXRwdXQoKVxuICAgIG9uSXRlbTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5vbkl0ZW0uZW1pdCgnLS0nKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSBjb252ZW5pZW50IHNlcnZpY2UgdG8gd29yayB3aXRoIHRoZSBkb20uIEFsbCB0aGUgZnV0dXJlIGxvZ2ljIHJlbGF0ZWQgdG8gRE9NIG1hbmlwdWxhdGlvblxuICogb3IgdHJhdmVyc2FsIHNob3VsZCBiZSBwdXQgaW50byB0aGlzIHNlcnZpY2VcbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEb21VdGlsc1NlcnZpY2VcbntcblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdvZXMgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIGJvZHkgYW5kIGNoZWNrcyBpZiB0aGVyZSBpcyBhIGVsZW1lbnQgaWRlbnRpZmllZCBieSBhICdzZWxlY3RvcidcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1BhcmVudCAobmF0aXZlRWxlbWVudDogYW55LCBzZWxlY3Rvcjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNsb3Nlc3QobmF0aXZlRWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBUcmF2ZWxzIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBCT0RZIGFuZCByZXRyaWV2ZSBlbGVtZW50IGlkZW50aWZpZWQgYnkgJ3NlbGVjdG9yJyBvciBOVUxMIGlmXG4gICAgICogbm90IGZvdW5kXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZXN0IChuYXRpdmVFbGVtZW50OiBhbnksIHNlbGVjdG9yOiBzdHJpbmcpOiBhbnlcbiAgICB7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBzZWxlY3Rvci5jaGFyQXQoMCk7XG5cbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBuYXRpdmVFbGVtZW50O1xuXG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudCgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnLicgJiYgcGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoc2VsZWN0b3Iuc3Vic3RyKDEpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnIycgJiYgcGFyZW50Tm9kZS5pZCA9PT0gc2VsZWN0b3Iuc3Vic3RyKDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgdGFnXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBwYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgcGFyZW50Tm9kZS50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFuZ3VsYXIgY29tcG9uZW50IGlzIHJlbmRlcmVkIGFsb25nIHdpdGggTkdDb250ZW50IGl0IGhhcyBpdHMgb3duIF9uZ0NvbnRlbnRfSU5ERVhcbiAgICAgKiB3aGljaCBhbHdheXMgY29ycmVzcG9uZHMgd2l0aCBfbmdob3N0X0lOREVYLCB0aGlzIHdvcmtzIGZpbmUgaWYgd2UgaGF2ZSBhY3R1YWwgY29tcG9uZW50XG4gICAgICogdGhhdCBpcyBhbHJlYWR5IHJlbmRlcmVkLiBJZiB3ZSBhcmUgY3JlYXRpbmcgY29tcG9uZW50IHByb2dyYW1hdGljYWxseSB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICAgKiBpZGVudGlmeSB3aGVyZSB0aGUgYWN0dWFsIG5nLWNvbnRlbnQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBlLmcuIENvbnNpZGVyIGZvbGxvd2luZyBleGFtcGxlOlxuICAgICAqXG4gICAgICpcbiAgICAgKiBCdXR0b24gQ29tcG9uZW50IFRlbXBsYXRlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogIDxzcGFuIGNsYXNzPW15YnV0dG9uVGl0bGU+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZW4geW91IHVzZSBidXR0b24gY29tcG9uZW50IGFzIDxhdy1idXR0b24+Q2xpY2tNZTwvYXctYnV0dG9uPiAgdGhlbiBpdHMgcmVuZGVyZWQgYXNcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhdy1idXR0b24gX25naG9zdF8xMjM+XG4gICAgICogIDxzcGFuIF9uZ2NvbnRlbnRfMTIzIGNsYXNzPW15YnV0dG9uVGl0bGU+Q2xpY2tNZTwvc3Bhbj5cbiAgICAgKiA8L2F3LWJ1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJ1dCB3aXRoIHByb2dyYW1tYXRpYyBBUEkgeW91IGluc3RhbnRpYXRlIEJ1dHRvbiBhbmQgc2luY2UgaXQgY3JlYXRlZCB3aXRob3V0IGEgQ29udGVudCBpdFxuICAgICAqIGxvb2tzIGxpa2UgdGhpcztcbiAgICAgKlxuICAgICAqICBgYGBcbiAgICAgKiA8YXctYnV0dG9uIF9uZ2hvc3RfMTIzPlxuICAgICAqICA8c3BhbiBjbGFzcz1teWJ1dHRvblRpdGxlPjwvc3Bhbj5cbiAgICAgKiA8L2F3LWJ1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZXJlIGRvIHlvdSBwbGFjZSB5b3UgY2hpbGQgKGNvbnRlbnQgY29tcG9uZW50KT8gVGhlcmVmb3JlIHV0aWxpdHkgY3NzIGNsYXNzIHdhcyBjcmVhdGVkXG4gICAgICogdG8gd3JhcCA8bmctY29udGVudD4gdG8gZ2V0IGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gICAgICpcbiAgICAgKiAgYGBgXG4gICAgICogICA8c3BhbiBjbGFzcz1cInUtbmdjb250ZW50XCI+XG4gICAgICogICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICA8L3NwYW4+XG4gICAgICogIGBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydEludG9QYXJlbnROZ0NvbnRlbnQgKHBhcmVudE5hdGl2ZUVsOiBhbnksIGNoaWxkTmF0aXZlRWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IGl0IGFzIGNoaWxkIHRvIHBhcmVudE5hdGl2ZUVsXG4gICAgICAgIGxldCBuZ0NvbnRlbnRQYXJlbnQgPSBwYXJlbnROYXRpdmVFbDtcblxuICAgICAgICBsZXQgZm91bmROZ0NvbnRlbnQgPSBwYXJlbnROYXRpdmVFbC5xdWVyeVNlbGVjdG9yKCcudS1uZ2NvbnRlbnQnKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChmb3VuZE5nQ29udGVudCkpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvdmVyIGEgY2FzZSB3aGVyZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBuZ2NvbnRlbnRzXG4gICAgICAgICAgICBuZ0NvbnRlbnRQYXJlbnQgPSBmb3VuZE5nQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBuZ0NvbnRlbnRQYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGROYXRpdmVFbCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgYnJvd3NlciB3aW5kb3cgd2lkdGggYW5kIGhlaWdodFxuICAgICAqXG4gICAgICovXG4gICAgYnJvd3NlckRpbWVudGlvbnMgKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZXMgZWxlbWVtZW50cyBkaW1lbnNpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBlbGVtZW50RGltZW5zaW9ucyAoZWxlbWVudDogYW55KTogYW55XG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogVW5kZXIgQG9yaWdpbmFsLWxpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50IERyaWZ0eSBDby5cbiAqIGh0dHA6Ly9kcmlmdHkuY29tL1xuICpcbiAqICBNSVQgTGljZW5zZVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKlxuICogQ3JlZGl0IHRvIGRyaWZ0eSBmb3IgdGhpcyBleGNlbGxlbnQgY29tcG9uZW50LiBXZSBoYXZlIGEgc3Ryb25nIG5lZWRzIGZvciBnb29kIGluZmluaXRlXG4gKiBzY3JvbGxpbmcgY29tcG9uZW50IHNvIHRoaXMgaXMgZGVyaXZlZCB3b3JrIGJhc2VkIG9uIHRoaXMgZHJpZnR5IGNvbXBvbmVudCBhcyB3ZSBjYW4gbm90IHJlYWxseVxuICogYnJpbmcgaW4gd2hvbGUgZnJhbWV3b3JrIGFuZCB0aGVpciBjb21wb25lbnQvQVBJLiBJdCB3b3VsZCBiZSB0b28gaGVhdnlcbiAqXG4gKiBDb21wb25lbnQgaXMgdXBkYXRlZCB3aXRoIG5hdGl2ZSBET00gQVBJLiBwbHVzIHNpbXBsaWZpZWQgYnkgcmVtb3ZpbmcgdGhpbmdzXG4gKiB0aGF0IGFyZSBub3QgbmVjZXNzYXJ5IGZvciBvdXIgdXNlY2FzZS4gVXBkYXRlZCBkaXJlY3RpdmUgcHJlZml4IHRvIG1hdGNoIG91ciBndWlkZWxpbmVzXG4gKlxuICpcbiAqXG4gKi9cblxuXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSwgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuXG4vKipcbiAqIFRoZSBJbmZpbml0ZSBTY3JvbGwgYWxsb3dzIHlvdSB0byBwZXJmb3JtIGFuIGFjdGlvbiB3aGVuIHRoZSB1c2VyXG4gKiBzY3JvbGxzIGEgc3BlY2lmaWVkIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbSBvciB0b3Agb2YgdGhlIHBhZ2UuXG4gKlxuICogVGhlIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gdGhlIGBpbmZpbml0ZWAgZXZlbnQgaXMgY2FsbGVkIHdoZW5cbiAqIHRoZSB1c2VyIHNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBkaXN0YW5jZS4gV2hlbiB0aGlzIGV4cHJlc3Npb25cbiAqIGhhcyBmaW5pc2hlZCBpdHMgdGFza3MsIGl0IHNob3VsZCBjYWxsIHRoZSBgY29tcGxldGUoKWAgbWV0aG9kXG4gKiBvbiB0aGUgaW5maW5pdGUgc2Nyb2xsIGluc3RhbmNlLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8ZGl2ICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19IDwvZGl2PlxuICogICA8YXctaW5maW5pdGUtc2Nyb2xsIChvbkxvYWQpPVwiZG9JbmZpbml0ZSgkZXZlbnQpXCI+XG4gKiAgPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFlvdSBjYW4gYWxzbyBzZXQgYSB0aHJlc2hvbGQgdG8gY2hhbmdlIHRoZSBkaXN0YW5jZSB3aGVuIHRoZSBsYXp5IGxvYWQga2lja3NcbiAqIGluLlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxkaXYgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX0gPC9kaXY+XG4gKiAgIDxhdy1pbmZpbml0ZS1zY3JvbGwgKG9uTG9hZCk9XCJkb0luZmluaXRlKCRldmVudClcIiAgW2Rpc3RhbmNlXT1cIicxNSUnXCI+XG4gKiAgPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG4gKlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5maW5pdGUtc2Nyb2xsJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2luZml0ZS1zY3JvbGwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydpbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC5zY3NzJ10sXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgX2xhc3RDaGVjazogbnVtYmVyID0gMDtcbiAgICBfbGFzdFNjcm9sbFRvcDogbnVtYmVyID0gMDtcbiAgICBfc2NMc246IGFueTtcbiAgICBfdGhyOiBzdHJpbmcgPSAnMTAlJztcbiAgICBfdGhyUHg6IG51bWJlciA9IDA7XG4gICAgX3RoclBjOiBudW1iZXIgPSAwLjEwO1xuICAgIF9pbml0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBfY29udGVudDogYW55O1xuICAgIF9kb2NCb2R5OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0ZTogc3RyaW5nID0gU1RBVEVfRU5BQkxFRDtcblxuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBUaGUgdGhyZXNob2xkIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbVxuICAgICAqIG9mIHRoZSBjb250ZW50IHRvIGNhbGwgdGhlIGBvbkxvYWRgIG91dHB1dCBldmVudCB3aGVuIHNjcm9sbGVkLlxuICAgICAqIFRoZSB0aHJlc2hvbGQgdmFsdWUgY2FuIGJlIGVpdGhlciBhIHBlcmNlbnQsIG9yXG4gICAgICogaW4gcGl4ZWxzLiBGb3IgZXhhbXBsZSwgdXNlIHRoZSB2YWx1ZSBvZiBgMTAlYCBmb3IgdGhlIGBpbmZpbml0ZWBcbiAgICAgKiBvdXRwdXQgZXZlbnQgdG8gZ2V0IGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBzY3JvbGxlZCAxMCVcbiAgICAgKiBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFVzZSB0aGUgdmFsdWUgYDEwMHB4YCB3aGVuIHRoZVxuICAgICAqIHNjcm9sbCBpcyB3aXRoaW4gMTAwIHBpeGVscyBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuXG4gICAgICogRGVmYXVsdCBpcyBgMTUlYC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXN0YW5jZSAoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyO1xuICAgIH1cblxuICAgIHNldCBkaXN0YW5jZSAodmFsOiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLl90aHIgPSB2YWw7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RoclB4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RoclBjID0gKHBhcnNlRmxvYXQodmFsKSAvIDEwMCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RoclB4ID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgICAgdGhpcy5fdGhyUGMgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlucHV0IHtib29sZWFufSBJZiB0cnVlLCBXaGV0aGVyIG9yIG5vdCB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGVuYWJsZWQgKHNob3VsZEVuYWJsZTogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIHRoaXMuZW5hYmxlKHNob3VsZEVuYWJsZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAb3V0cHV0IHtldmVudH0gRW1pdHRlZCB3aGVuIHRoZSBzY3JvbGwgcmVhY2hlc1xuICAgICAqIHRoZSB0aHJlc2hvbGQgZGlzdGFuY2UuIEZyb20gd2l0aGluIHlvdXIgaW5maW5pdGUgaGFuZGxlcixcbiAgICAgKiB5b3UgbXVzdCBjYWxsIHRoZSBpbmZpbml0ZSBzY3JvbGwncyBgY29tcGxldGUoKWAgbWV0aG9kIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uTG9hZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgQFZpZXdDaGlsZCgnbG9hZGluUGFuZWwnKVxuICAgIGxvYWRQYW5lbDogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBMYXp5IGxvYWQgY3VycmVudCBudW1iZXJzLiB0ZWxsIHRoZSBhcHAgc3RhcnRpbmcgcG9pbnQgYW5kIHdoYXQgaXMgdGhlIHNpemUgb2YgbG9hZGVkXG4gICAgICogbGlzdFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmZXRjaFNpemU6IG51bWJlciA9IDA7XG5cbiAgICBsb2FkT2Zmc2V0OiBudW1iZXIgPSAwO1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfcmVuZGVyOiBSZW5kZXJlcjIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYpXG4gICAge1xuXG5cbiAgICB9XG5cblxuICAgIG5nT25Jbml0ICgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2hhcy1pbmZpbml0ZS1zY3JvbGwnKTtcblxuICAgIH1cblxuICAgIF9vblNjcm9sbCAoZXY6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdXN0IHRocm90dGxlIHRoZSBjbGFzcyBieSAxMDBtc1xuICAgICAgICBpZiAodGhpcy5fbGFzdENoZWNrICsgMTAwID4gZXYudGltZVN0YW1wKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGNoZWNrIGxlc3MgdGhhbiBldmVyeSBYWG1zXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0Q2hlY2sgPSBldi50aW1lU3RhbXA7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgIGxldCB3aW5IZWlnaHQgPSB0aGlzLmRvbVV0aWxzLmJyb3dzZXJEaW1lbnRpb25zKCkuaGVpZ2h0O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLl9kb2NCb2R5LnNjcm9sbEhlaWdodCwgdGhpcy5fZG9jQm9keS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICB3aW5IZWlnaHQsIHRoaXMuX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0LCB0aGlzLl9jb250ZW50Lm9mZnNldEhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyUGMgPyAoaGVpZ2h0ICogdGhpcy5fdGhyUGMpIDogdGhpcy5fdGhyUHg7XG4gICAgICAgIGxldCBkaXN0YW5jZUZyb21JbmZpbml0ZSA9IHRoaXMuX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0IC0gd2luSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gdGhyZXNob2xkO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoZWlnaHQgKCcgKyBoZWlnaHQgKyAnKSAsIERpc3RhbmNlIGZyb20gYm90dG9tICdcbiAgICAgICAgLy8gKyBkaXN0YW5jZUZyb21JbmZpbml0ZSArICcsICA9PiB0aHJlc2hvbGQgPSAnICtcbiAgICAgICAgLy8gICAgIHRoaXMuZGlzdGFuY2UgKyAnICgnICsgdGhyZXNob2xkICsgJyknKTtcblxuICAgICAgICBpZiAoZGlzdGFuY2VGcm9tSW5maW5pdGUgPCAwICYmIHRoaXMuX2xhc3RTY3JvbGxUb3AgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZU9uTGF6eUxvYWQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RTY3JvbGxUb3AgPiBzY3JvbGxUb3AgJiYgc2Nyb2xsVG9wIDwgd2luSGVpZ2h0XG4gICAgICAgICAgICAmJiB0aGlzLmxvYWRPZmZzZXQgIT09IHRoaXMuZmV0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVPbkxhenlVbkxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9kbzogcmVmYWN0b3IgdG8gb25lIG1ldGhvZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmlyZU9uTGF6eUxvYWQgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9MT0FESU5HICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0xPQURJTkc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5mZXRjaFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sb2FkT2Zmc2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb24gdGhlIG5leHQgcmVjb3JkXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkT2Zmc2V0ICs9IHRoaXMuZmV0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgZmlyZU9uTGF6eVVuTG9hZCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX0xPQURJTkcgJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfTE9BRElORztcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9uIHRoZSBuZXh0IHJlY29yZFxuICAgICAgICAgICAgICAgIHRoaXMubG9hZE9mZnNldCA9IHRoaXMuZmV0Y2hTaXplO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGlzTG9hZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmZldGNoU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxvYWRPZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIHNjcm9sbFRvcCAoKTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCB0aGlzLl9jb250ZW50LnNjcm9sbFRvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgY29tcGxldGUoKWAgd2l0aGluIHRoZSBgaW5maW5pdGVgIG91dHB1dCBldmVudCBoYW5kbGVyIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLiBGb3IgZXhhbXBsZSwgdGhlIGBsb2FkaW5nYFxuICAgICAqIHN0YXRlIGlzIHdoaWxlIHRoZSBhcHAgaXMgcGVyZm9ybWluZyBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLFxuICAgICAqIHN1Y2ggYXMgcmVjZWl2aW5nIG1vcmUgZGF0YSBmcm9tIGFuIEFKQVggcmVxdWVzdCB0byBhZGQgbW9yZSBpdGVtc1xuICAgICAqIHRvIGEgZGF0YSBsaXN0LiBPbmNlIHRoZSBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBVSSB1cGRhdGVkLCB5b3VcbiAgICAgKiB0aGVuIGNhbGwgdGhpcyBtZXRob2QgdG8gc2lnbmlmeSB0aGF0IHRoZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgdGhlIGluZmluaXRlIHNjcm9sbCdzIHN0YXRlIGZyb20gYGxvYWRpbmdgXG4gICAgICogdG8gYGVuYWJsZWRgLlxuICAgICAqL1xuICAgIGNvbXBsZXRlICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfTE9BRElORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRU5BQkxFRDtcblxuICAgICAgICAgICAgLy8gbmVlZCB0byB0cmlnZ2VyIGV4dHJhIGRldGVjdCBjaGFuZ2VzIHRvIHJlcmVuZGVyIGxvYWRpbmcgaWNvblxuICAgICAgICAgICAgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgZW5hYmxlKGZhbHNlKWAgdG8gZGlzYWJsZSB0aGUgaW5maW5pdGUgc2Nyb2xsIGZyb20gYWN0aXZlbHlcbiAgICAgKiB0cnlpbmcgdG8gcmVjZWl2ZSBuZXcgZGF0YSB3aGlsZSBzY3JvbGxpbmcuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxuICAgICAqIHdoZW4gaXQgaXMga25vd24gdGhhdCB0aGVyZSBpcyBubyBtb3JlIGRhdGEgdGhhdCBjYW4gYmUgYWRkZWQsIGFuZFxuICAgICAqIHRoZSBpbmZpbml0ZSBzY3JvbGwgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gc2hvdWxkRW5hYmxlICBJZiB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIGVuYWJsZSAoc2hvdWxkRW5hYmxlOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IChzaG91bGRFbmFibGUgPyBTVEFURV9FTkFCTEVEIDogU1RBVEVfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoc2hvdWxkRW5hYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG5hdGl2ZSB3aW5kb3dzIHNjcm9sbCBldmVudFxuICAgICAqL1xuICAgIF9zZXRMaXN0ZW5lcnMgKHNob3VsZExpc3RlbjogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0KSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTGlzdGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zY0xzbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjTHNuID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY0xzbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NjTHNuKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fc2NMc24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY0xzbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBpc0xvYWRpbmcgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTVEFURV9MT0FESU5HO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RvY0JvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyh0aGlzLnN0YXRlICE9PSBTVEFURV9ESVNBQkxFRCk7XG5cbiAgICAgICAgaWYgKHRoaXMubG9hZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5maXJlT25MYXp5TG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95ICgpXG4gICAge1xuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoZmFsc2UpO1xuICAgIH1cblxufVxuXG5cbmNvbnN0IFNUQVRFX0VOQUJMRUQgPSAnZW5hYmxlZCc7XG5jb25zdCBTVEFURV9ESVNBQkxFRCA9ICdkaXNhYmxlZCc7XG5jb25zdCBTVEFURV9MT0FESU5HID0gJ2xvYWRpbmcnO1xuIiwiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF3TmFtZVN0b3JlIHtcblxuICAgIHByaXZhdGUgc3RvcmU6IE1hcDxzdHJpbmcsIGFueT47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBhZGQobmFtZTogc3RyaW5nLCBlbDogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxpZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgaXMgbm90IHVuaXF1ZSEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5zZXQobmFtZSwgZWwpO1xuICAgIH1cblxuICAgIHJlbW92ZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZGVsZXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGNvbGxpZGVzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuY2xlYXIoKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7XG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIE9uRGVzdHJveVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQXBwQ29uZmlnXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5pbXBvcnQge1xuICAgIEF3TmFtZVN0b3JlXG59IGZyb20gJy4vYXctbmFtZS5zdG9yZSc7XG5cbi8qKlxuICogVGhlICdhd05hbWUnIGRpcmVjdGl2ZSBhdHRhY2hlcyBhIGlkZW50aWZpZXIgdG8gZGVjb3JhdGVkIGVsZW1lbnQgdG8gYWlkIHNlbGVjdG9ycyBmb3IgdGVzdGluZ1xuICogcHVycG9zZXMuIFRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgdHJpZXMgdG8gZ2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciBiYXNlZCBvbiBjb250ZXh0dWFsIGRhdGFcbiAqIGFuZCBpbmhlcmFudCBpbW11dGFibGUgZWxlbWVudCBhdHRyaWJ1dGVzLlxuICpcbiAqICoqR2VuZXJhdGluZyB0aGUgQmFzZSBOYW1lKipcbiAqXG4gKiBUaGUgJ2F3TmFtZScgZGlyZWN0aXZlIGdlbmVyYXRlcyBhIGJhc2UgbmFtZSBmcm9tIGVsZW1lbnQgdGFnIG5hbWUgYW5kIGF0dHJpYnV0ZXMgd2hpY2ggYXJlXG4gKiBzdGF0aWMgYnkgbmF0dXJlLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGF3TmFtZT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGF3bmFtZT1cImJ1dHRvbl9vcmRlclwiPlxuICpcbiAqIElmIHRoZSBlbGVtZW50IGhhcyBhbiAnaWQnLCB0aGF0IHZhbHVlIHRha2VzIHByZWNlZGVudCBhbmQgaXMgdXNlZCBpbnN0ZWFkIG9mIGEgZ2VuZXJhdGVkXG4gKiBuYW1lLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGlkPVwibXlPcmRlckJ1dHRvblwiIGF3TmFtZT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGlkPVwibXlPcmRlckJ1dHRvblwiIGF3bmFtZT1cImJ1dHRvbl9teU9yZGVyQnV0dG9uXCI+XG4gKlxuICpcbiAqICoqUmVwZWF0ZWQgRWxlbWVudHMgYW5kIHRoZSAnZXh0JyBQYXJhbWV0ZXIqKlxuICpcbiAqIFRoZXJlIGFyZSBtYW55IGNhc2VzIHdoZXJlIGVsZW1lbnRzIGFyZSBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgaW4gdGhlIGNvZGUgYXMgbGlzdHMgb3IgdGFibGVzLlxuICogSW4gc3VjaCBjYXNlcywgaXQgbWF5IG5vdCBiZSBlYXN5IHRvIGRpc3Rpbmd1aXNoIGluZGl2aWR1YWwgZWxlbWVudHMgYnkgc3RhbmRhcmQgSFRNTFxuICogYXR0cmlidXRlcywgc28gdGhlICdhd05hbWUnIGRpcmVjdGl2ZSBhbGxvd3MgY3VzdG9tIGV4dGVudGlvbnMgdG8gdGhlIGJhc2UgbmFtZSB0byBiZSBwcm92aWRlZFxuICogdXNpbmcgdGhlICdleHQnIGF0dHJpYnV0ZS5cbiAqXG4gKiAgICBFeGFtcGxlOlxuICogICAgICAgIGZydWl0cyA9IFsnYXBwbGUnLCAnYmFuYW5hJywgJ29yYW5nZSddO1xuICpcbiAqICAgICAgICA8dWw+XG4gKiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgZnJ1aXQgb2YgZnJ1aXRzXCIgYXdOYW1lIGV4dD1cInt7ZnJ1aXR9fVwiPnt7ZnJ1aXR9fTwvbGk+XG4gKiAgICAgICAgPC91bD5cbiAqXG4gKiAgIFJlc3VsdDpcbiAqICAgICAgIDx1bD5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfYXBwbGVcIj5hcHBsZTwvbGk+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX2JhbmFuYVwiPmJhbmFuYTwvbGk+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX29yYW5lXCI+b3JhbmdlPC9saT5cbiAqICAgICAgIDwvdWw+XG4gKlxuICogKipBZGRpbmcgQ29udGV4dCBUaHJvdWdoIEFuY2VzdG9yIEluc3BlY3Rpb24qKlxuICpcbiAqIEluIG9yZGVyIHRvIHByb3ZpZGUgY29udGV4dCB0byB0aGUgZWxlbWVudCBuYW1pbmcsIHRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgbG9vcHMgdGhyb3VnaCB0aGVcbiAqIHBhcmVudCBhbmNlc3RyeSBhbmQgc2VhcmNoZXMgZm9yIGFueSB1bmlxdWUgZWxlbWVudCAnaWQnIHRvIHByZXBlbmQgdG8gdGhlIGJhc2UgbmFtZS5cbiAqXG4gKiAgICAgRXhhbXBsZTpcbiAqICAgICAgICAgPGZvcm0gaWQ9XCJhcHBsaWNhbnRcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICA8L2Zvcm0+XG4gKiAgICAgICAgIDxmb3JtIGlkPVwic3BvdXNlXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxmb3JtIGlkPVwiYXBwbGljYW50XCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd25hbWU9XCJhcHBsaWNhbnRfaW5wdXRfZmlyc3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3bmFtZT1cImFwcGxpY2FudF9pbnB1dF9sYXN0TmFtZVwiPlxuICogICAgICAgICA8L2Zvcm0+XG4gKiAgICAgICAgIDxmb3JtIGlkPVwic3BvdXNlXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd25hbWU9XCJzcG91c2VfaW5wdXRfZmlyc3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3bmFtZT1cInNwb3VzZV9pbnB1dF9sYXN0bmFtZVwiPlxuICogICAgICAgICA8L2Zvcm0+XG4gKlxuICogKipVbmlxdWVuZXNzIENoZWNrKipcbiAqXG4gKiAnYXdOYW1lJyBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXMgaXQgY3JlYXRlcyBieSBhZGRpbmcgdGhlbSB0byBhIG1hcCBzdG9yZS4gV2hlbmV2ZXIgaXRcbiAqIGNyZWF0ZXMgYSBuZXcgbmFtZSBkdXJpbmcgdGhlIGBuZ09uSW5pdGAgcGhhc2UgaXQgY2hlY2tzIGl0IGFnYWluc3QgdGhlIGV4aXN0aW5nIG1hcCxcbiAqIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIGl0IGVuY291bnRlcnMgYSBkdXBsaWNhdGUuIE1vcmVvdmVyIGR1cmluZyB0aGUgZWxlbWVudCBkZXN0cnVjdGlvblxuICogcGhhc2UsIGBuZ09uRGVzdHJveWAsICdhd05hbWUnIHJlbW92ZXMgdGhlIGdlbmVyYXRlZCBuYW1lIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqXG4gKiAqKkluIFByb2R1Y3Rpb24qKlxuICpcbiAqIFVzaW5nICdhd05hbWUnIGFkZHMgYSBzbWFsbCBiaXQgb2YgcmVuZGVyaW5nIG92ZXJoZWFkIGZvciBlYWNoIGVsZW1lbnQgaXQgaXMgdXNlZCBvbi4gSW5cbiAqIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgJ2F3TmFtZScgc2VydmVzIG5vIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGVuZCB1c2VyLCBidXQgbWF5IGhhdmVcbiAqIGEgcGVyZm9ybWFuY2UgaW1wYWN0IG9uIHRoZSBhcHBsaWNhdGlvbi4gQXMgc3VjaCwgJ2F3TmFtZScgdGFrZXMgaW50byBhY2NvdW50IHRoZVxuICogYEFwcENvbmZpZ2Agc2V0dGluZ3MgYW5kIGRpc2FibGVzIG5hbWUgZ2VuZXJhdGlvbiB3aGVuIGBBcHBDb25maWcuaXNQcm9kdWN0aW9uTW9kZSgpYFxuICogaXMgYHRydWVgLlxuICpcbiAqIEluIHlvdXIgYXBwbGljYXRpb24sIHlvdSBjYW4gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgYnkgc2V0dGluZyBgZGV2bW9kZS5lbmFibGVkYCB0b1xuICogYGZhbHNlYCB3aGVuIGNvbmZpZ3VyaW5nIGBBcmliYUNvcmVNb2R1bGVgOlxuICpcbiAqICAgICBBcmliYUNvcmVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgICAgICAgICdkZXZtb2RlLmVuYWJsZWQnOiBmYWxzZVxuICogICAgIH0pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thd05hbWVdJyxcbn0pXG5leHBvcnQgY2xhc3MgQXdOYW1lRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgZXh0OiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIG5hbWU6IHN0cmluZztcblxuICAgIHByaXZhdGUgc2VwYXJhdG9yOiBzdHJpbmcgPSAnXyc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogQXdOYW1lU3RvcmUsXG4gICAgICAgIHByaXZhdGUgY29uZmlnOiBBcHBDb25maWdcbiAgICApIHt9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY3JlYXRlTmFtZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFRvU3RvcmUodGhpcy5uYW1lLCB0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F3bmFtZScsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3JlLnJlbW92ZSh0aGlzLm5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBlbGVtZW50IG5hbWUvaWQgYW5kIHJlZmVyZW5jZSB0byBtYXAgc3RvcmUuIElmIG5hbWUvaWQgYWxyZWFkeVxuICAgICAqIGV4aXN0cyBpbiBzdG9yZSB0aGVuIGl0IHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEVsZW1lbnRUb1N0b3JlKG5hbWU6IHN0cmluZywgZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5hZGQobmFtZSwgZWxlbSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlICsgYC4gXCIke25hbWV9XCIgaXMgYWxyZWFkeSBpbiB1c2UuYCwgZWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG5hbWUvaWQgZm9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICogQHJldHVybiBTdHJpbmcgTmFtZS9JRFxuICAgICAqL1xuICAgIGNyZWF0ZU5hbWUoZWxlbTogRWxlbWVudFJlZikge1xuXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0aGlzLmdldFRhZ05hbWUoZWxlbSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcnJheSBvZiBzdHJpbmcgcGFydHNcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgICAgICAvLyBGaW5kIGFuY2VzdG9yIHRhZyBpZCwgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGNvbnN0IHBhcmVudElEID0gdGhpcy5nZXRBbmNlc3RvcklkKGVsZW0pO1xuICAgICAgICBpZiAocGFyZW50SUQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGFyZW50SUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHRhZyB0eXBlXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IHRoaXMuZ2V0UGFyZW50TmFtZShlbGVtKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0YWduYW1lXG4gICAgICAgIHBhcnRzLnB1c2godGFnTmFtZSk7XG5cbiAgICAgICAgLy8gQ2hvb3NlIGlkIHByb3BlcnR5IGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAoZWxlbS5uYXRpdmVFbGVtZW50LmlkKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVsZW0ubmF0aXZlRWxlbWVudC5pZCk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGJ1aWxkIGV4dGVuc2lvbiBmcm9tIHRhZyBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYSBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZWxlbS5uYXRpdmVFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdmFsdWUgYXR0cmlidXRlIGlmICdvcHRpb24nIHRhZ1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLnNwYWNlc1RvVW5kZXJzY29yZShlbGVtLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGN1c3RvbSBleHRlbnNpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLmV4dCkge1xuICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLnNwYWNlc1RvVW5kZXJzY29yZSh0aGlzLmV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4odGhpcy5zZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0YWcgbmFtZSBmcm9tIGVsZW1lbnQgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0VGFnTmFtZShlbGVtOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBlbGVtLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGVsZW1lbnQgYW5jZXN0cnkgYW5kIHJldHVybiBmaXJzdCBpZCBhdHRyaWJ1dGVcbiAgICAgKiBlbmNvdW50ZXJlZC5cbiAgICAgKiBAcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEFuY2VzdG9ySWQoZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbS5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIGxldCBpZCA9ICcnO1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFpZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgIGlkID0gcGFyZW50LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBuYW1lIGF0dHJpYnV0ZSBmcm9tIHBhcmVudCBpZiBuYW1lIGF0dHJpYnV0ZSBleGlzdHMuXG4gICAgICogQHBhcmFtIGVsZW0gUmVmZXJlbmNlIHRvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRQYXJlbnROYW1lKGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbS5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiAocGFyZW50Lm5hbWUgJiYgIXBhcmVudC5pZCkgPyBwYXJlbnQubmFtZSA6IG51bGw7XG4gICAgfVxuXG4gICAgc3BhY2VzVG9VbmRlcnNjb3JlKHN0cjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKy9nLCAnXycpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtFbWJlZGRlZEl0ZW1EaXJlY3RpdmV9IGZyb20gJy4vZW1iZWRkZWQtaXRlbSc7XG5pbXBvcnQge0dlbmVyaWNDb250YWluZXJDb21wb25lbnR9IGZyb20gJy4vZ2VuZXJpYy1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7SW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZX0gZnJvbSAnLi9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtFcnJvck1lc3NhZ2VzQ29tcG9uZW50fSBmcm9tICcuL2Vycm9yLW1lc3NhZ2VzL2Vycm9yLW1lc3NhZ2VzLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7Q3VycmVuY3lGb3JtYXRQaXBlfSBmcm9tICcuL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlJztcbmltcG9ydCB7TmdGb3JTZXREaXJlY3RpdmV9IGZyb20gJy4vb24tbmdmb3Itc2V0LmRpcmVjdGl2ZSc7XG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50fSBmcm9tICcuL2luZml0ZS1zY3JvbGwvaW5maXRlLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHtBd05hbWVEaXJlY3RpdmV9IGZyb20gJy4vYXctbmFtZS9hdy1uYW1lLmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLFxuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBFcnJvck1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ3VycmVuY3lGb3JtYXRQaXBlLFxuICAgICAgICBOZ0ZvclNldERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxDb21wb25lbnQsXG4gICAgICAgIEF3TmFtZURpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBFbWJlZGRlZEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUsXG4gICAgICAgIEdlbmVyaWNDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgIEVycm9yTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgIE1vZGFsQ29tcG9uZW50LFxuICAgICAgICBDdXJyZW5jeUZvcm1hdFBpcGUsXG4gICAgICAgIE5nRm9yU2V0RGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbENvbXBvbmVudCxcbiAgICAgICAgQXdOYW1lRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NvcmVDb21wb25lbnRNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnQsIG5vb3B9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgbW9kYWwgZGlhbG9ncy4gUHJvdmlkZXMgZGVmYXVsdHMgZnVuY3Rpb25hbGl0eSBmb3IgYWxsIG1vZGFscy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGFsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzdHJveTogKCkgPT4gdm9pZCA9IG5vb3A7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRoYXQgY2xvc2VzIHRoZSBkaWFsb2cgYnkgY2FsbGluZyBkZXN0cm95IG9uIHRoZSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqIE1ldGhvZCBpbmhlcml0ZWQgYnkgYWxsIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjbG9zZU1vZGFsKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNCbGFuaywgaXNQcmVzZW50LCBpc1N0cmluZ01hcCwgaXNUeXBlLCBvYmplY3RUb05hbWV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG5cbi8qKlxuICogRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5IGFnZ3JlZ2F0ZXMgZGlmZmVyZW50IERhdGFQcm92aWRlcnMgcGVyIHR5cGUuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnlcbntcblxuICAgIC8qKlxuICAgICAqIE1hcHMgY2xhc3MgbmFtZSB0byBEYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdHJ5QnlQcm92aWRlcjogTWFwPHN0cmluZywgRGF0YVByb3ZpZGVyPGFueT4+O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3MgTmFtZSAgdG8gYWN0dWFsIHR5cGVcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdHJ5TmFtZVRvQ2xhc3M6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0cnlCeVByb3ZpZGVyID0gbmV3IE1hcDxzdHJpbmcsIERhdGFQcm92aWRlcjxhbnk+PigpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciBldmVyeSBzaW5nbGUgcmVnaXN0ZXJlZCBEYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb24gd2UgYWxzbyBuZWVkIHN0b3JlIGl0cyBwcm90b3R5cGVcbiAgICAgKiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHN1cHBvcnQgc29tZSBraW5kIG9mIGluaGVyaXRhbmNlLiBZb3UgY2FuIHJlZ2lzdGVyIGEgcHJvdmlkZXIgZm9yXG4gICAgICogYSBwYXJlbnQgY2xhc3MgaWYgbmVlZGVkXG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlclByb3ZpZGVyPFQ+KHRhcmdldDogYW55LCBwcm92aWRlcjogRGF0YVByb3ZpZGVyPFQ+KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGFyZ2V0KSB8fCAoIWlzU3RyaW5nTWFwKHRhcmdldCkgJiYgIWlzVHlwZSh0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcgQ2Fubm90IHJlZ2lzdGVyIG5vbi1vYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuYW1lID0gaXNUeXBlKHRhcmdldCkgPyB0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIuc2V0KG5hbWUsIHByb3ZpZGVyKTtcblxuICAgICAgICBsZXQgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlOYW1lVG9DbGFzcy5zZXQobmFtZSwgcHJvdG90eXBlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgYmVzdCBtYXRjaGluZyBwcm92aWRlci4gSWYgbm90IGZvdW5kIHRoZW4gdXNlIG9iamVjdCBwcm90b3R5cGUgdG8gZ2V0IGhvbGQgb2YgaXRzXG4gICAgICogcGFyZW50IGFuZCBzZWUgaWYgdGhlcmUgaXMgYSBwcm92aWRlciByZWdpc3RlcmVkIG9uIHRoaXMgbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIGJlc3RNYXRjaEZvckNsYXNzPFQ+KGNsYXNzTmFtZTogc3RyaW5nKTogRGF0YVByb3ZpZGVyPFQ+XG4gICAge1xuICAgICAgICBsZXQgcmVnaXN0ZXJlZENsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgbGV0IGNsYXNzUHJvdG8gPSB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3MuZ2V0KGNsYXNzTmFtZSk7XG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChyZWdpc3RlcmVkQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4gPSB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlci5nZXQocmVnaXN0ZXJlZENsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIudHlwZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdvIHVwIHRvIHBhcmVudFxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjbGFzc1Byb3RvKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2xhc3NQcm90byk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudE5hbWUgPSBvYmplY3RUb05hbWUoY2xhc3NQcm90byk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgIChpc1ByZXNlbnQocGFyZW50TmFtZSkgJiYgcGFyZW50TmFtZSAhPT0gcmVnaXN0ZXJlZENsYXNzTmFtZSkgPyBwYXJlbnROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgYmVzdE1hdGNoRm9yQ2xhc3MoKSB3aXRoIHRoZSBkaWZmZXJlbmNlIHRvIHBhc3MgYSB0eXBlLiBJZiB5b3Ugd2FudCB0b1xuICAgICAqIHN1cHBvcnQgb2JqZWN0IGluaGVyaXRhbmNlIHlvdSBuZWVkIHRoaXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGJlc3RNYXRjaEZvclR5cGU8VD4odHlwZTogVHlwZTxUPik6IERhdGFQcm92aWRlcjxUPlxuICAgIHtcbiAgICAgICAgbGV0IG5hbWU6IHN0cmluZyA9IG9iamVjdFRvTmFtZSh0eXBlKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3Muc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5iZXN0TWF0Y2hGb3JDbGFzczxUPihuYW1lKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBQcm92aWRlciBpcyBhIGRhdGEgZHJpdmVyIHRoYXQgY2FuIGFjY2VzcyBkYXRhIGFuZCByZXRyaWV2ZSB0aGVtLiBJdCBrbm93cyBob3cgdG8gZ2V0IDFcbiAqIG9yIG1vcmUgcmVjb3JkcywgbWF5YmUgZG8gcGFnaW5nIGFuZCBzb21lIG90aGVyIHRoaW5ncy5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhUHJvdmlkZXI8VD5cbntcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1cnJlbnQgdHlwZSBmb3IgdGhpcyBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICB0eXBlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZmllcyBhbGwgdGhlIGxpc3RlbmVycyBpbiBjYXNlIG9mIGRhdGEgYXJlIGF2YWlsYWJsZSBvciBpZiB0aGV5IGNoYW5nZWQgZHVlIHRvIHNvbWUgdXNlclxuICAgICAqIGludGVyYWN0aW9uICAoc2VhcmNoLCBhZGRpbmcgb3IgcmVtb3ZpbmcpLlxuICAgICAqXG4gICAgICovXG4gICAgZGF0YUNoYW5nZXM6IEJlaGF2aW9yU3ViamVjdDxUW10+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUW10+KFtdKTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZGF0YSBzb3VyY2UgcG9wdWxhdGVkIGJ5IGZldGNoIG9yIHNlYXJjaC4gSlMgYXBwbGljYXRpb24gY2FuIGhvbGQgbGFyZ2UgYW1vdW50IG9mXG4gICAgICogcmVjb3JkcyB3aXRob3V0IGdvaW5nIGJhY2sgdG8gdGhlIFJFU1Qgc2VydmVyLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGNhY2hlIHNlYXJjaCByZXN1bHQgb25cbiAgICAgKiB0aGUgY2xpZW50IHNpdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvZmZTY3JlZW5EYXRhOiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBzaXplIG9mIHRoZSBzb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIGV4cGVjdGVkQ291bnQocGFyYW1zPzogTWFwPHN0cmluZywgYW55Pik6IG51bWJlclxuICAgIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRm9yIHVzZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvIHJldHJpZXZlIGRhdGEgYmFzZWQgb24gc29tZSBjcml0ZXJpYSBlLmcuXG4gICAgICpcbiAgICAgKiAgLSBtYXggbnVtYmVyIG9mIHJlY29yZHNcbiAgICAgKiAgLSBzdXBwb3J0IHBhZ2luZyB3aXRoIG9mZnNldCBhbmQgbGltaXRcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGJ5IGZldGNoXG4gICAgICovXG4gICAgYWJzdHJhY3QgZGF0YUZvclBhcmFtcyhwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBBcnJheTxUPjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGZXRjaGVzIGRhdGEgZnJvbSB1bmRlcmx5aW5nIGRhdGFQcm92aWRlci5cbiAgICAgKlxuICAgICAqIFJlcGxhY2VtZW50IGZvciBkYXRhZm9yUGFyYW1zXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmZXRjaChwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBPYnNlcnZhYmxlPFRbXT47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgbm9uLWFzeW5jIGN1cnJlbnQgc3RhdGUgb2YgZGF0YVxuICAgICAqL1xuICAgIGRhdGEoKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGlzIERhdGFQcm92aWRlciBzdXBwb3J0cyBJTlNFUlQsIFJFTU9WRVxuICAgICAqXG4gICAgICovXG4gICAgY2FuQ1JVRCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGlzIERhdGFQcm92aWRlciBzdXBwb3J0cyBxdWVyeSBjYXBhYmlsaXR5XG4gICAgICpcbiAgICAgKi9cbiAgICBjYW5RdWVyeSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHN1cHBvcnQgaW5zZXJ0aW9uLiBBZnRlciByZWNvcmQgaXMgaW5zZXJ0ZWQgZW1pdCBldmVudCBmb3IgZGF0YUNoYW5nZXMgdG9cbiAgICAgKiBpbmZvcm0gYWxsIHN1YnNjcmliZXJzXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnQob2JqOiBhbnkpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHN1cHBvcnQgcmVjb3JkIHJlbW92YWwuIEFmdGVyIHJlY29yZCBpcyByZW1vdmVkIGVtaXQgZXZlbnQgZm9yIGRhdGFDaGFuZ2VzIHRvXG4gICAgICogaW5mb3JtIGFsbCBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZShvYmo6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdG8gcHJvdmlkZSBhY2Nlc3MgdG8gbG93IGxldmVsIHNlYXJjZyBBUEkuXG4gICAgICpcbiAgICAgKi9cbiAgICBxdWVyeShwYXJhbXM6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkXG4gICAge1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4vZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0ZpZWxkUGF0aCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2YgYXMgb2JzZXJ2YWJsZU9mfSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIEFycmF5cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5RGF0YVByb3ZpZGVyPFQ+IGV4dGVuZHMgRGF0YVByb3ZpZGVyPFQ+XG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgIHZhbHVlczogQXJyYXk8VD4pXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSBBcnJheTtcblxuICAgICAgICB0aGlzLm9mZlNjcmVlbkRhdGEgPSB0aGlzLnZhbHVlcztcbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMudmFsdWVzKTtcbiAgICB9XG5cbiAgICBleHBlY3RlZENvdW50KHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZlNjcmVlbkRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGRhdGFGb3JQYXJhbXMocGFyYW1zPzogTWFwPHN0cmluZywgYW55Pik6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhwYXJhbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmZTY3JlZW5EYXRhO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy5vZmZTY3JlZW5EYXRhO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQocGFyYW1zKSAmJiBwYXJhbXMuaGFzKCdvZmZzZXQnKSAmJiBwYXJhbXMuaGFzKCdsaW1pdCcpKSB7XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gcGFyYW1zLmdldCgnb2Zmc2V0Jyk7XG4gICAgICAgICAgICBsZXQgbGltaXQgPSBwYXJhbXMuZ2V0KCdsaW1pdCcpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiAob2Zmc2V0ICsgbGltaXQpKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBsaW1pdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKG9mZnNldCwgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtcy5oYXMoJ29yZGVyYnknKSAmJiBwYXJhbXMuaGFzKCdzZWxlY3RvcicpKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnQoZGF0YSwgcGFyYW1zLmdldCgnb3JkZXJieScpLCBwYXJhbXMuZ2V0KCdzZWxlY3RvcicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cblxuICAgIGZldGNoKHBhcmFtczogTWFwPHN0cmluZywgYW55Pik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmRhdGFGb3JQYXJhbXMocGFyYW1zKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBzb3J0aW5nIGN1cnJlbnQgZGF0YXNldCBieSBvbmUgY29sdW1uIC8ga2V5XG4gICAgICpcbiAgICAgKiBmb3Igc29ydE9yZGVyaW5nIHBsZWFzZSBzZWUgRGF0YXRhYmxlIGFuZCBpdHMgc29ydE9yZGVyaW5nRm9yTnVtYmVyKClcbiAgICAgKlxuICAgICAqICAgICAgMSAgPSBhc2NlbmRpbmdcbiAgICAgKiAgICAgIC0xID0gZGVzY2VuZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgc29ydChhcnJheVRvU29ydDogYW55W10sIGtleTogc3RyaW5nLCBzb3J0T3JkZXI6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGFycmF5VG9Tb3J0LnNvcnQoKGRhdGExOiBhbnksIGRhdGEyOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZTEgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhMSwga2V5KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTIgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhMiwga2V5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUxID09IG51bGwgJiYgdmFsdWUyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUxICE9IG51bGwgJiYgdmFsdWUyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZTEgPT0gbnVsbCAmJiB2YWx1ZTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZTEgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUxLmxvY2FsZUNvbXBhcmUodmFsdWUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHZhbHVlMSA8IHZhbHVlMikgPyAtMSA6ICh2YWx1ZTEgPiB2YWx1ZTIpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoc29ydE9yZGVyICogcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhUHJvdmlkZXIsIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQXJyYXksIGlzU3RyaW5nfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QXJyYXlEYXRhUHJvdmlkZXJ9IGZyb20gJy4vYXJyYXktZGF0YS1wcm92aWRlcic7XG5cblxuLyoqXG4gKiBQcm92aWRlcyB0b3AgbGV2ZWwgYWNjZXNzb3IgY2xhc3MgaW4gb3JkZXIgdG8gbWFrZSB7QGxpbmsgRGF0YVByb3ZpZGVyfSByZXRyaWV2YWwgcHJvY2VzcyBlYXNpZXIuXG4gKiBVc2luZyB7QGxpbmsgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5fSB3ZSBlaXRoZXIgcmV0cmlldmUgcmVnaXN0ZXJlZCBpbnN0YW5jZSBvZiBjb25jcmV0ZVxuICogcHJvdmlkZXIgb3IgaW5zdGFudGlhdGUgb3VyIGltcGxpY2l0IHByb3ZpZGVyIGZvciBuYXRpdmUgdHlwZXMgc3VjaCBhcyBBcnJheS5cbiAqXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVByb3ZpZGVyc1xue1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZ2lzdHJ5OiBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnkpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nICBEYXRhUHJvdmlkZXIgb3IgY3JlYXRlIG5ldyBvbmUgaW4gY2FzZSBvZiBBcnJheVxuICAgICAqIE1vcmUgcm9vbSB0byByZWdpc3RlciBhbmQgaW5zdGFudGlhdGUgc29tZSBvdGhlciBpbXBsaWNpdCBQcm92aWRlcnNcbiAgICAgKi9cbiAgICBmaW5kKHRhcmdldDogYW55KTogRGF0YVByb3ZpZGVyPGFueT5cbiAgICB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlEYXRhUHJvdmlkZXIodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5iZXN0TWF0Y2hGb3JDbGFzcyh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuYmVzdE1hdGNoRm9yVHlwZSh0YXJnZXQpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIG5ldyBwcm92aWRlciB3aXRoaW4gRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlcjxUPih0YXJnZXQ6IGFueSwgcHJvdmlkZXI6IERhdGFQcm92aWRlcjxUPik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih0YXJnZXQsIHByb3ZpZGVyKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtJbmplY3RhYmxlLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgYXNzZXJ0LFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0FycmF5LFxuICAgIGlzQmxhbmssXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc0pzT2JqZWN0LFxuICAgIGlzUHJlc2VudCxcbiAgICBvYmplY3RUb05hbWUsXG4gICAgb2JqZWN0VmFsdWVzLFxuICAgIHVuaW1wbGVtZW50ZWRcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0FycmF5RGF0YVByb3ZpZGVyfSBmcm9tICcuL2FycmF5LWRhdGEtcHJvdmlkZXInO1xuaW1wb3J0IHtPdXRsaW5lTm9kZX0gZnJvbSAnLi4vLi4vd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogUHJvdmlkZXMgYSByZWdpc3RyeSBvZiBkaWZmZXJlbnQgZGF0YSBGaW5kZXJzIHVzZWQgbW9zdGx5IGJ5IERhdGFTb3VyY2VzLiBBbGwgRmluZGVycyBhcmVcbiAqIHJlZ2lzdGVyZWQgYnkgdGhpcyBjbGFzcyBhcyB3ZSBkb24ndCBoYXZlIGFueSBuZWVkcyByaWdodCBub3cgdG8gZXhwb3NlIHRoaXMgdG8gZGV2ZWxvcGVyLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFGaW5kZXJzXG57XG5cbiAgICBwcml2YXRlIGZpbmRlcnNCeVR5cGU6IE1hcDxEYXRhRmluZGVyLCBUeXBlPERhdGFGaW5kZXI+PiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdEZpbmRlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBEYXRhRmluZGVyIGJhc2VkIG9uIHRoZSBvYmplY3QgdHlwZSBhbmQgcXVlcnlUeXBlLlxuICAgICAqL1xuICAgIGZpbmQoZm9yUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+LCBmb3JUeXBlOiBRdWVyeVR5cGUpOiBEYXRhRmluZGVyXG4gICAge1xuXG4gICAgICAgIGxldCBmaW5kZXJNYXRjaDogVHlwZTxEYXRhRmluZGVyPjtcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLmZvckVhY2goKHY6IFR5cGU8RGF0YUZpbmRlcj4sIGs6IERhdGFGaW5kZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChrLmFjY2VwdHMoZm9yUHJvdmlkZXIsIGZvclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZmluZGVyTWF0Y2ggPSB2O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGZpbmRlck1hdGNoKSkge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSBuZXcgZmluZGVyTWF0Y2goKTtcbiAgICAgICAgICAgIGNvcHkuZm9yRGF0YShmb3JQcm92aWRlcik7XG4gICAgICAgICAgICByZXR1cm4gY29weTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgZmluZGVyXG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlcjxUPihwcm90b3R5cGU6IERhdGFGaW5kZXIsIHR5cGU6IFR5cGU8RGF0YUZpbmRlcj4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmZpbmRlcnNCeVR5cGUuc2V0KHByb3RvdHlwZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0RmluZGVycygpXG4gICAge1xuICAgICAgICAvLyBjcmVhdGUgYSBwcm90b3R5cGUgZm9yIGVhY2hcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChuZXcgRnVsbFRleHRBcnJheURhdGFGaW5kZXIoKSwgRnVsbFRleHRBcnJheURhdGFGaW5kZXIpO1xuICAgICAgICB0aGlzLmZpbmRlcnNCeVR5cGUuc2V0KG5ldyBPdXRsaW5lRnVsbFRleHRBcnJheURhdGFGaW5kZXIoKSxcbiAgICAgICAgICAgIE91dGxpbmVGdWxsVGV4dEFycmF5RGF0YUZpbmRlcik7XG5cbiAgICB9XG59XG5cbi8qKlxuICogV2UgaGF2ZSBkaWZmZXJlbnQgb3B0aW9ucyBob3cgdG8gcXVlcnkgZGF0YS4gRnVsbFRleHQgdXNlcyBhIHN0cmluZyB3aGVyZSBwcmVkaWNhdGUgaXNcbiAqIHVzaW5nIGtleTp2YWx1ZSBwYWlyIHRvIGJ1aWx0IGEgcXVlcnlcbiAqL1xuZXhwb3J0IGVudW0gUXVlcnlUeXBlXG57XG4gICAgRnVsbFRleHQsXG4gICAgRnVsbFRleHRPdXRsaW5lLFxuICAgIFByZWRpY2F0ZSxcbiAgICBGdWxsVGV4dEFuZFByZWRpY2F0ZVxufVxuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtYXRjaGluZyBjYXBhYmlsaXR5IGZvciBnaXZlbiBEYXRhUHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhRmluZGVyXG57XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTG9va3VwIGtleSB0byBhcHBseSB3aGVuIHJ1bm5pbmcgbWF0Y2guIElkZWFsbHkgeW91ciBEUyBzaG91bGQgYmUgYWJsZSB0byBzZXQgbG9va3VwS2V5XG4gICAgICogZWl0aGVyIGdsb2JhbGx5IGZvciBnaXZlbiBkYXRhUHJvdmlkZXIgb3IgbG9jYWxseSBldmVyeSB0aW1lIHlvdSBydW4gc2VhcmNoLiBUaGlzIGlzIGluXG4gICAgICogY2FzZSB5b3UgaGF2ZSBtYW55IGNob29zZXJzIGZvciB0aGUgc2FtZSB0eXBlIGFuZCB5b3Ugd2FudCB0aGVtIHRvIGhhdmUgZGlmZmVyZW50IGxvb2t1cFxuICAgICAqIGtleS5cbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBzZXQgbG9va3VwS2V5KGtleTogc3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIEluIG9yZGVyIHRvIGZpbmQgY29uY3JldGUgRGF0YUZpbmRlciB3ZSBuZWVkIHRvIGtub3cgdGhlIHRhcmdldCB0eXBlIGFuZCB0aGUgcXVlcnkgdHlwZVxuICAgICAqXG4gICAgICovXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0cyBhIERhdGFQcm92aWRlciBmb3IgRGF0YUZpbmRlclxuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgZm9yRGF0YShwcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT4pOiBEYXRhRmluZGVyO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBNYXRjaGluZyBtZXRob2RzIHdoaWNoIGFyZSBlaXRoZXIgYXN5bmMgb3Igc3luY1xuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgaW5zdGFudE1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogVFtdO1xuXG4gICAgYWJzdHJhY3QgaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uc0Zvck1hdGNoOiBhbnlbXSwgcXVlcnk6IGFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IG51bWJlcik6IFRbXTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBRdWVyeSBjYW4gYmUgYSBzaW1wbGUgc3RyaW5nIGxpdGVyYWwgb3IgYSBtYXAgaGF2aW5nIGRpZmZlcmVudCBrZXkgdmFsdWUgcGFpciBhcyBhXG4gICAgICogZmlsdGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBtYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlciA9IC0xKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuICAgIG1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uczogYW55W10sIHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFNpbXBsZSBGdWxsVGV4dCBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBpbmZpeCBzdHJpbmcgbWF0Y2hpbmcgd2hpY2ggd29ya3Mgb24gdG9wIG9mXG4gKiBBcnJheURhdGFQcm92aWRlci5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBGdWxsVGV4dEFycmF5RGF0YUZpbmRlciBleHRlbmRzIERhdGFGaW5kZXJcbntcbiAgICAvKipcbiAgICAgKiAgSWYgbGlzdCB2YWx1ZSBpcyBvYmplY3Qgc2V0IGtleVBhdGggdG8gZ2V0IHRoZSBvYmplY3QgdmFsdWVcbiAgICAgKi9cbiAgICBfa2V5UGF0aDogRmllbGRQYXRoO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBEYXRhUHJvdmlkZXIgdXNlZCB0byBhY2Nlc3MgZGF0YVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuXG4gICAgc2V0IGxvb2t1cEtleShrZXk6IHN0cmluZylcbiAgICB7XG4gICAgICAgIHRoaXMuX2tleVBhdGggPSBpc1ByZXNlbnQoa2V5KSA/IG5ldyBGaWVsZFBhdGgoa2V5KSA6IG51bGw7XG4gICAgfVxuXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZvckRhdGEgaW5zdGFuY2VvZiBBcnJheURhdGFQcm92aWRlciAmJiBmb3JUeXBlID09PSBRdWVyeVR5cGUuRnVsbFRleHQ7XG4gICAgfVxuXG4gICAgZm9yRGF0YShwcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT4pOiBGdWxsVGV4dEFycmF5RGF0YUZpbmRlclxuICAgIHtcbiAgICAgICAgdGhpcy5fcHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zdGFudE1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogVFtdXG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuX3Byb3ZpZGVyKSwgJ01pc3NpbmcgRGF0YVByb3ZpZGVyJyk7XG5cbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLl9wcm92aWRlci5kYXRhRm9yUGFyYW1zKG5ldyBNYXAoKS5zZXQoJ2xpbWl0JywgbWF4KSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KGxpc3QsIHF1ZXJ5LCBtYXgpO1xuICAgIH1cblxuICAgIGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnNGb3JNYXRjaDogYW55W10sIHF1ZXJ5OiBzdHJpbmcsIG1heDogbnVtYmVyKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5fcHJvdmlkZXIpLCAnTWlzc2luZyBEYXRhUHJvdmlkZXInKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25zRm9yTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDogYW55W10gPSBbXTtcbiAgICAgICAgbGV0IHRvTG93ZXJQYXR0ZXJuID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbnNGb3JNYXRjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBzZWxlY3Rpb25zRm9yTWF0Y2hbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGVzKGl0ZW0sIHRvTG93ZXJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IElmIHlvdSBkb250IHN1cHBseSBzZWFyY2ggS2V5IGFuZCB5b3Ugd2FudCBmdWxsdGV4dCBzZWFyY2ggYW5kIHlvdSB1c2UgdGhpc1xuICAgICAqIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYmUgYXdhcmUgdGhhdCBpdCBjYW4gIHBlcmZvcm0gcG9vcmx5IGFzIGl0IGlzIG5haXZlIGltcGxlbWVudGFpb25cbiAgICAgKiB0aGF0IGRvZXMgbm90IGRvIGRlZXAgY29tcGFyZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG1hdGNoZXM8VD4oaXRlbTogYW55LCBwYXR0ZXJuOiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgdmFsID0gKGlzUHJlc2VudCh0aGlzLl9rZXlQYXRoKSkgPyB0aGlzLl9rZXlQYXRoLmdldEZpZWxkVmFsdWUoaXRlbSkgOiBpdGVtO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuY2FsbChpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0pzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNPYmplY3RWYWx1ZShpdGVtLCBwYXR0ZXJuKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmxhbmsocGF0dGVybikgfHxcbiAgICAgICAgICAgICAgICBpc1ByZXNlbnQodmFsKSAmJiB2YWwudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocGF0dGVybikgPiAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YodGhpcy5pbnN0YW50TWF0Y2gocXVlcnksIG1heCkpO1xuICAgIH1cblxuICAgIG1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uczogYW55W10sIHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHRoaXMuaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnMoc2VsZWN0aW9ucywgcXVlcnksIG1heCkpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBoYXNPYmplY3RWYWx1ZShvYmo6IGFueSwgcGF0dGVybjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IG9iamVjdFZhbHVlcyhvYmopO1xuICAgICAgICBsZXQgcGFyZW50T2JqID0gb2JqZWN0VG9OYW1lKG9iaik7XG4gICAgICAgIGxldCBsZW5ndGgyID0gdmFsdWVzLmZpbHRlcigodmFsdWU6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpIHx8IGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0pzT2JqZWN0KHZhbHVlKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YocGF0dGVybikgIT09IC0xO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzSnNPYmplY3QodmFsdWUpICYmIG9iamVjdFRvTmFtZSh2YWx1ZSkgIT09IHBhcmVudE9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc09iamVjdFZhbHVlKHZhbHVlLCBwYXR0ZXJuKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgICAgIHJldHVybiBsZW5ndGgyID4gMDtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBFeHRlbmRzIGJhc2ljIEluZml4IGltcGxlbWVudGF0aW9uIHRvIHdvcmsgb24gdG9wIG9mIE91dGxpbmVOb2Rlcy4gSXQgZmlyc3QgY2hlY2tzIGFsbCB0aGVcbiAqIGNoaWxkcmVuIG9uIGxvd2VzdCBsZXZlbCBhbmQgbW92aW5nIHVwIHRvIHRoZSByb290IGFuZCBtYXJraW5nIG5vZGVzIHRoYXQgY2FuIGJlIHJlbW92ZWQuXG4gKlxuICogIEZvciBzaW1wbGUgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggb3BlcmF0ZXMgb24gbG9jYWwgYXJyYXkgdGhpcyBzaG91bGQgYmUgZ29vZCBlbm91Z2ggd2UgdGhpc1xuICogIGNhbiBuZXZlciBtYXRjaCB3aXRoIHJlYWwgREIgZnVsbCB0ZXh0IHNlYXJjaC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBPdXRsaW5lRnVsbFRleHRBcnJheURhdGFGaW5kZXIgZXh0ZW5kcyBGdWxsVGV4dEFycmF5RGF0YUZpbmRlclxue1xuXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZvckRhdGEgaW5zdGFuY2VvZiBBcnJheURhdGFQcm92aWRlciAmJiBmb3JUeXBlID09PSBRdWVyeVR5cGUuRnVsbFRleHRPdXRsaW5lO1xuICAgIH1cblxuXG4gICAgaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uc0Zvck1hdGNoOiBhbnlbXSwgcXVlcnk6IHN0cmluZywgbWF4OiBudW1iZXIpOiBBcnJheTxUPlxuICAgIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLl9wcm92aWRlciksICdNaXNzaW5nIERhdGFQcm92aWRlcicpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbnNGb3JNYXRjaDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9Mb3dlclBhdHRlcm4gPSBxdWVyeS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGxldCBzb3VyY2VUb1NlYXJjaCA9IHNlbGVjdGlvbnNGb3JNYXRjaC5zbGljZSgpO1xuICAgICAgICB0aGlzLnJvbGx1cChzb3VyY2VUb1NlYXJjaCwgdG9Mb3dlclBhdHRlcm4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFrZShzb3VyY2VUb1NlYXJjaCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdvaW5nIHRocnUgdGhlIHRyZWUgZnJvbSBib3R0b20gdXAgYW5kIG1hcmsgYWxsIHRoYXQgbWF0Y2hlcyBxdWVyeVxuICAgICAqXG4gICAgICovXG4gICAgcm9sbHVwKG5vZGVzOiBPdXRsaW5lTm9kZVtdLCBxdWVyeTogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoaXRlbTogT3V0bGluZU5vZGUpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IGZyb20gYm90dG9tIHVwIGFuZCBjYXB0dXJlIGhvdyBtYW55IG9jY3VycmVuY2VzIGlzIGZvdW5kIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICBsZXQgaGFzQ2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtLmNoaWxkcmVuKSAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbk1hdGNoID0gdGhpcy5yb2xsdXAoaXRlbS5jaGlsZHJlbiwgcXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS52aXNpYmxlID0gaGFzQ2hpbGRyZW5NYXRjaCB8fCB0aGlzLm1hdGNoZXMoaXRlbSwgcXVlcnkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm9kZXMuc29tZSgoaXRlbTogT3V0bGluZU5vZGUpID0+IGl0ZW0udmlzaWJsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG91dCBhbGwgdGhlIG5vZGVzIHRoYXQgYXJlIG1hcmtlZCBhcyB2aXNpYmxlID0gZmFsc2UgYW5kIG1ha2Ugc3VyZSBhbmRcbiAgICAgKiBkb24ndCBtb2RpZnkgb3JpZ2luYWwgbGlzdFxuICAgICAqXG4gICAgICovXG4gICAgc2hha2Uobm9kZXM6IE91dGxpbmVOb2RlW10pOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzXG4gICAgICAgICAgICAuZmlsdGVyKG5vZGUgPT4gbm9kZS52aXNpYmxlKVxuICAgICAgICAgICAgLm1hcChub2RlID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ubm9kZSxcbiAgICAgICAgICAgICAgICBpc0V4cGFuZGVkOiBub2RlLnZpc2libGUsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4gJiYgdGhpcy5zaGFrZShub2RlLmNoaWxkcmVuKVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cblxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtJbmplY3Rpb25Ub2tlbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3VuaW1wbGVtZW50ZWR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcblxuXG5leHBvcnQgY29uc3QgREFUQV9TT1VSQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48RGF0YVNvdXJjZT4oJ0RBVEFfU09VUkNFJyk7XG5cbi8qKlxuICogRGF0YVNvdXJjZSBkZXNjcmliZXMgYmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgaGFuZGxpbmcgc3RyZWFtIG9mIGRhdGEgc3BlY2lmaWMgdG8gY29tcG9uZW50XG4gKlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCBEYXRhU291cmNlIHdpbGwgYmUgZGVmaW5lZCBhcyBjb21wb25lbnQgcHJvdmlkZXIgdXNpbmdcbiAqXG4gKiBAQ29tcG9uZW50cyAoe1xuICogICAgICAuLi5cbiAqICAgICAgcHJvdmlkZXJzOltcbiAqXG4gKiAgICAgICAgICBwcm92aWRlOiBEQVRBX1NPVVJDRSwgdXNlQ2xhc3M6IENob29zZXJEYXRhU291cmNlUGxhaW5BcnJheUV4YW1wbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdXG4gKiAgICAgIF1cbiAqXG4gKiB9KVxuICpcbiAqXG4gKiBzbyBhbGwgdGhlIGRlcGVuZGVuY2llcyAoRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnMpIGFyZSBwcm9wZXJseSBpbmplY3RlZC5cbiAqXG4gKiBEYXRhUHJvdmlkZXIgdXNlcyBvcGVuKCkgbWV0aG9kIHRvIGJyb2FkY2FzdCBjaGFuZ2VzIHRvIGFsbCB0aGUgc3Vic2NyaWJlcnMgaW4gcmVhY3RpdmUgd2F5LlxuICogT3IgeW91IGNhbiB1c2UgaW5zdGFudCgpIG1ldGhvZCB0byByZXRyaWV2ZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgRGF0YVNvdXJjZSAoc3luYylcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhU291cmNlXG57XG4gICAgc3RhdGljIHJlYWRvbmx5IE1heExlbmd0aCA9IDEwO1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhSZWNlbnRTZWxlY3RlZCA9IDU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEVhY2ggRGF0YVNvdXJjZSBoYXZlIGluamVjdGVkIERhdGFQcm92aWRlcnMgYW5kIERhdGFGaW5kZXJzIHRvIHJldHJpZXZlIGNvbmNyZXRlXG4gICAgICogaW1wbGVtZW50YXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkYXRhUHJvdmlkZXJzPzogRGF0YVByb3ZpZGVycywgcHJvdGVjdGVkIGZpbmRlcnM/OiBEYXRhRmluZGVycylcbiAgICB7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gaW5pdGlhbGl6ZSBkYXRhIHNvdXJjZSBhbmQgcGFzcyBzb21lIGFkZGl0aW9uYWwgdmFsdWVzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGluaXQoLi4uYXJnczogYW55W10pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRGF0YVByb3ZpZGVycyB3b3JrcyB3aXRoIHN0cmVhbSBvZiBkYXRhIGFuZCB0aGlzIG9wZW5zIHVwIHRoZSBjaGFubmVsIGluIG9yZGVyIHRvXG4gICAgICogbGlzdGVuIGFuZCByZWFjdCBmb3IgYW55IGNoYW5nZXMgdGhhdCBjb3VsZCBoYXBwZW4gaW5zaWRlIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIGFic3RyYWN0IG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHN1YnNjcmlwdGlvbiB0byBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBjbG9zZSgpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGF0YSBpbnN0YW50bHkgZnJvbSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgaW5zdGFudDxUPigpOiBUW11cbiAgICB7XG5cbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERTSW5pdFBhcmFtc1xue1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdmFsdWVzIG9yIHRoZSBvYmplY3QgdHlwZSBuYW1lIHdlIHdhbnQgdG8gcmVuZGVyXG4gICAgICovXG4gICAgb2JqPzogYW55O1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggZmluZCB3ZSB3YW50IHRvIGxvYWQgRnVsbFRleHQgb3IgUHJlZGljYXRlXG4gICAgICovXG4gICAgcXVlcnlUeXBlOiBRdWVyeVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDYW4gc3BlY2lmeSBsb29rdXAgS2V5IHRvIG5hcnJvdyBkb3duIHRoZSBzZWFyY2ggdG8gc3BlY2lmaWMgZmllbGQuIElmIGxvb2t1cCBrZXkgaXNcbiAgICAgKiBudWxsLCBpdGVtcyBhcmUgYXNzdW1lZCB0byBiZSBzdHJpbmdzXG4gICAgICovXG4gICAgbG9va3VwS2V5Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIENob29zZXIgaXMgc2luZ2xlIG9yIG11bHRpIHNlbGVjdFxuICAgICAqL1xuICAgIG11bHRpc2VsZWN0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIERhdGFQcm92aWRlciBpbnN0ZWFkIGxldHRpbmcgRGF0YVByb3ZpZGVycyB0byBmaW5kIG1hdGNoXG4gICAgICovXG4gICAgZGF0YVByb3ZpZGVyPzogRGF0YVByb3ZpZGVyPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb24gdG8gcGFzcyBjdXN0b20gRGF0YUZpbmRlciBpbnN0ZWFkIGxldHRpbmcgRGF0YUZpbmRlcnMgdG8gZmluZCBtYXRjaFxuICAgICAqL1xuICAgIGRhdGFGaW5kZXI/OiBEYXRhRmluZGVyO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSG9zdEJpbmRpbmd9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFdlIGFyZSB1c2luZyB0aGVzZSBjb21wb25lbnRzIGFzIGEgYmV0dGVyIHdheSBzZWxlY3RvcnMuXG4gKlxuICovXG5cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXRvcCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBUb3Bab25lQ29tcG9uZW50XG57XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJ3VpLWctMTIgdWktZy1ub3BhZCAnO1xufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbGVmdCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBMZWZ0Wm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbWlkZGxlJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIE1pZGRsZVpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1tZC02IHVpLWxnLTQgdWktZy1ub3BhZCc7XG59XG5cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJpZ2h0JyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIFJpZ2h0Wm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xuXG59XG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1ib3R0b20nLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQm90dG9tWm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FzeW5jVmFsaWRhdG9yRm4sIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyLCBTdHJpbmdXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Rm9ybVRhYmxlQ29tcG9uZW50fSBmcm9tICcuLi9mb3JtLXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50LCBXaWRnZXRTaXplQ29sdW1uc30gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuLyoqXG4gKiBVc2VkIGJ5IEZvcm1UYWJsZSB0byBsYXlvdXQgZmllbGRzIGludG8gUm93cy4gRWFjaCBGb3JtVGFibGUgcm93IGlzIHJlYXNvbmFibGUgZm9yIG5vdCBvbmx5IHRvXG4gKiBpbmNsdWRlIGFjdHVhbCBjb21wb25lbnQgc3VjaCBpcyBEcm9wRG93biBvciBJbnB1dEZpZWxkIGJ1dCBtYWlubHkgcHJvdmlkZXMgYSBlbm91Z2ggY29udGV4dCBmb3JcbiAqIHRoZSBjb21wb25lbnQgdG8gc3BlY2lmeSB0aGUgc2l6ZSwgaG93IGl0IHNob3VsZCBsYXlvdXQsIHdoZXRoZXIgd2UgbmVlZCB0byBzaG93IHJlcXVpcmVkIGZsYWcsXG4gKiB0byBzaG93L2hpZGUgbGFiZWxzIGluIGNhc2UgaWYgd2UgaGF2ZSBubyBsYWJlbCBsYXlvdXQgYW5kIG11Y2ggbW9yZS5cbiAqXG4gKiBGb3JtUm93IGNvbXBvbmVudCBhbHNvIHJlZ2lzdGVycyBhbmd1bGFyIHZhbGlkYXRvciBmb3IgdGhlIGN1cnJlbnQgcm93L2ZpZWxkLiBBcyBhbHJlYWR5XG4gKiBtZW50aW9uZWQgV2UgdHJlYXQgb3VyIHdpZGdldHMgd2l0aCBtaW5pbWFsIHJlc3BvbnNpYmlsaXR5IGFzIHBvc3NpYmxlIHRvIHByZXNlbnQgYW5kIHJldHJpdmVcbiAqIGluZm9ybWF0aW9uIHRvL2Zyb20gdXNlciBhbmQgbGV0IHNvbWVib2R5IGVsc2UgdG8gZmlndXJlIG91dCB3aGVyZSBpdCBhcHBlYXIgYW5kIGhvdy5cbiAqXG4gKiB0b2RvOiBNb3ZlIHVuZGVyIEZvcm1UYWJsZVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWZvcm0tcm93JyxcbiAgICB0ZW1wbGF0ZVVybDogJ2Zvcm0tcm93LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZm9ybS1yb3cuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1Sb3dDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vTGFiZWxMYXlvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgcm93IHdpdGggaGlnaGxpZ2h0ZWQgYmFja2dyb3VuZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWdobGlnaHRSb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEZpZWxkIGxhYmVsIHRoYXQgc2hvdWxkIGFwcGVhciBhYm92ZSBvciBuZXh0IHRvIHRoZSBjb250cm9sXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciB2YWxpZGF0b3JzLCBtYXhpbWFsIGxlbmd0aCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heExlbmd0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogIEZvciBpbnB1dHMgdHlwZSBmaWVsZHMgcHJvdmlkZXMgZGVmYXVsdCBhbmd1bGFyIHZhbGlkYXRvcnMsIG1pbmltYWwgbGVuZ3RoIG9mIHRoZSBmaWVsZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluTGVuZ3RoOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciBmb3JtYXR0ZXJzLiBIb3cgdGhlIGlucHV0IGZpZWxkcyBzaG91bGQgYmVcbiAgICAgKiBmb3JtYXR0ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXN0b20gYXN5bmMgdmFsaWRhdG9ycyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBDb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21Bc3luY1ZhbGlkYXRvcnM6IEFzeW5jVmFsaWRhdG9yRm5bXTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tICB2YWxpZGF0b3JzIHdoaWNoIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIENvbnRyb2xcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1c3RvbVZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW107XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgZm9ybSByb3cgdGhhdCB3ZSBhcmUgcmVuZGVyaW5nIGFub3RoZXIgbmVzdGVkIGZvcm0gaW4gdGhpcyByb3cuIHNvIHdlIG5lZWRcbiAgICAgKiB0byBnbyAxMDAlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc05lc3RlZExheW91dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBpcyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmaWVsZC4gQ3VycmVudCB3ZSBzdXBwb3J0IDQgZGlmZmVyZW50IHNpemVzOiB4LXNtYWxsLCBzbWFsbCxcbiAgICAgKiBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2l6ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGb3Igc2luZ2xlIGNvbHVtbiBsYXlvdXQgd2l0aG91dCB6b25lcyB3ZSBuZWVkIHRvIGFwcGx5IGdyaWQgZGlyZWN0bHkgdG8gdGhlIEZvcm1Sb3cgdGFnXG4gICAgICogc28gd2UgZG9uJ3QgbmVlZCB0byBpbnRyb2R1Y2UgZXh0cmEgZGl2IGxldmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAnJztcblxuXG4gICAgcHJpdmF0ZSBfbGFiZWxzT25Ub3A6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAvLyBFdmVudCB0aGlzIGNyZWF0ZXMgQ0kgZGVwZW5kcy4gTmVlZCB0byBoYXZlIGEgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vIEkgbmVlZCB0byByZWZhY3RvciBtb3JlIHBhcmVudCB0byBub3QgdXNlIHRoaXMgY2hpbGQgYW5kIHJlZmFjdG9yIGxheW91dGluZ1xuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtVGFibGVDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEZvcm1UYWJsZUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtJyArIFdpZGdldFNpemVDb2x1bW5zLm1lZGl1bTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IG5vdyB3ZSBqdXN0IGluaXRpYWxpemUgdGhpcyBvbmNlIGFuZCB1c2UgdGhlIHZhbHVlcyB3ZSBkbyBub3QgZXhwZWN0IG5vdyB0byByZWFjdCB0b1xuICAgICAqIGNoYW5nZXNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKG51bGwpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJWYWxpZGF0b3JzKCk7XG5cbiAgICAgICAgdGhpcy5vbWl0UGFkZGluZyA9IHRoaXMucGFyZW50Q29udGFpbmVyLm9taXRQYWRkaW5nO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdCArPSBpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpID8gJyB1aS1nLTEyICcgOiAnJztcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgPSB0aGlzLmhpZ2hsaWdodFJvdyA/IHRoaXMuY2xhc3NMaXN0ICsgJyBoaWdobGlnaHQtcm93ICcgOiB0aGlzLmNsYXNzTGlzdDtcblxuICAgICAgICB0aGlzLmNsYXNzTGlzdCA9IHRoaXMub21pdFBhZGRpbmcgPyB0aGlzLmNsYXNzTGlzdCArICcgdWktZy1ub3BhZCAnIDogdGhpcy5jbGFzc0xpc3Q7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBKdXN0IGEgc2l6ZSBnZXR0ZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBzaXplKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEEgc2l6ZSBzZXR0ZXIgd2UgdHJhbnNsYXRlIGN1c3RvbSBzaXplcyBpbnRvIGFjdHVhbCBib290c3RyYXAgZ3JpZCBzeXN0ZW0uIFdlIHVzZSBtZWRpdW1cbiAgICAgKiByaWdodCBub3cuIGJ1dCB3ZSBzaG91bGQgZXh0ZW5kIHRoaXMgZm9yIG90aGVyIHNjcmVlbiBzaXplc1xuICAgICAqXG4gICAgICogIHRvZG86IHByb3ZpZGUgbWFwcGluZyBhbmQgYWRkIG90aGVyIGdyaWQgY2xhc3NlcyBmb3Igb3RoZXIgc2l6ZXMgeHMsIHNtLCBsZywgeGxcbiAgICAgKlxuICAgICAqICBBbHNvIGNoZWNrIGlmIHRoaXMgaXMgZHluYW1pYyBzaXplIHRoYXQgc2hvdWxkIHZhcnkgYmFzZWQgb24gdGhlIGhvdyBtYW55IG51bWJlciBvZiBjb2x1bW5zXG4gICAgICogd2UgaGF2ZS4gZS5nLiBEYXRlIHdpZGdldHMgaXMgYnkgZGVmYXVsdCBzbWFsbCwgYnV0IGluIDIsIDMgY29sdW1ucyBsYXlvdXQgdGhpcyBzbWFsbCBpcyB0b29cbiAgICAgKiBzbWFsbC5cbiAgICAgKi9cblxuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzaXplKHZhbHVlOiBzdHJpbmcpXG4gICAge1xuXG4gICAgICAgIGxldCBpc0R5blZhbCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChTdHJpbmdXcmFwcGVyLnN0YXJ0c1dpZHRoKHZhbHVlLCAnZC0nKSkge1xuICAgICAgICAgICAgaXNEeW5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMiwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSAmJiAhdGhpcy5pc05lc3RlZExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbGV0IGRTaXplID0gdGhpcy5keW5TaXplKHZhbHVlLCBpc0R5blZhbCk7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtJyArIGRTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNOZXN0ZWRMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSAndWktZy0xMiB1aS1tZC0xMic7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSAmJiB0aGlzLmVkaXRhYmxlICE9PSB0aGlzLnBhcmVudENvbnRhaW5lci5lZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaCBvdXQgb2YgYm94IGFuZ3VsYXIgdmFsaWRhdG9yIGFzIHdlbGwgYXMgY3VzdG9tIG9uZSB0byBjdXJyZW50IEZvcm1Db250cm9sXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RlclZhbGlkYXRvcnMoKVxuICAgIHtcbiAgICAgICAgbGV0IHZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW10gPSBbXTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubWF4TGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWF4TGVuZ3RoKHRoaXMubWF4TGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubWluTGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWluTGVuZ3RoKHRoaXMubWluTGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucmVxdWlyZWQpICYmIHRoaXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMucGF0dGVybih0aGlzLnBhdHRlcm4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VzdG9tVmFsaWRhdG9ycykpIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCh2YWxpZGF0b3JzLCB0aGlzLmN1c3RvbVZhbGlkYXRvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbGlkYXRvcnModmFsaWRhdG9yc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWRhdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbGlkYXRvcnMoVmFsaWRhdG9ycy5jb21wb3NlKHZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpICYmIHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnModGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmN1c3RvbUFzeW5jVmFsaWRhdG9ycykgJiYgdGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMoXG4gICAgICAgICAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmModGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEbyB3ZSBoYXZlIGxhYmVscyBvbiBUT1AsIHRyeSB0byByZWFkIHRoaXMgZnJvbSBQYXJlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBsYWJlbHNPblRvcCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLl9sYWJlbHNPblRvcCkgJiYgaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuICg8Rm9ybVRhYmxlQ29tcG9uZW50PnRoaXMucGFyZW50Q29udGFpbmVyKS5pc0xhYmVsc09uVG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDYW4gcmVmYWN0b3IgYWxsIGludG8gMSBsaW5lIGJ1dCBpdHMgaGFyZCB0byBkZWJ1ZyBzbyB0aGlzIGlzIGp1c3QgZm9yIHJlYWRcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHluU2l6ZSh2YWx1ZTogc3RyaW5nLCBpc0R5blZhbHVlOiBib29sZWFuKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgbm9ybWFsaXplU2l6ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSAmJlxuICAgICAgICAgICAgKDxGb3JtVGFibGVDb21wb25lbnQ+dGhpcy5wYXJlbnRDb250YWluZXIpLmhhc1R3b0NvbHVtbiAmJiBpc0R5blZhbHVlKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGxldCBlbnVtVmFsdWVzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKFdpZGdldFNpemVDb2x1bW5zKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNpemUgPSBlbnVtVmFsdWVzW2VudW1WYWx1ZXMuaW5kZXhPZihub3JtYWxpemVTaXplKSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPGFueT5XaWRnZXRTaXplQ29sdW1ucylbbm9ybWFsaXplU2l6ZV07XG5cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBCb3R0b21ab25lQ29tcG9uZW50LFxuICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgIFRvcFpvbmVDb21wb25lbnRcbn0gZnJvbSAnLi4vZml2ZS16b25lLWxheW91dC5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogRm9ybVRhYmxlIGlzIGEgc3BlY2lmaWMgbGF5b3V0IGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIExhYmVscyBhbmQgaXRzIGNvbnRyb2xzIGluIHR3byBjb2x1bW5zXG4gKiBhbmQgNSBkaWZmZXJlbnQgem9uZXMuXG4gKlxuICogV2Ugc3VwcG9ydCBMRUZULCBNSURETEUsIFJJR0hULCBUT1AsIEJPVFRPTSB6b25lIHdoZXJlIHdlIGNhbiBwbGFjZSBvdXIgY29tcG9uZW50IG9yIHdpZGdldHMuXG4gKiBUaGlzXG4gKiBjb21wb25lbnQgaXMgdXNlZCBhcyBwcmltYXJ5IGxheW91dCB0byB3cmFwIGFsbCB0aGUgY29tbW9uIHVzZSBjYXNlcy4gRS5nLiBXaGVuIHdlIGxheSBvdXRcbiAqIGZpZWxkcyBpbiB0aGUgZm9ybSBJIGRvIG5vdCB3YW50IGNvbnRyb2xzIHRvIGJlIGF3YXJlIG9mIGVycm9yIHZhbGlkYXRpb24sIHNpemUsIGxhYmVscywgYW5kXG4gKiBzb21lIG90aGVyIHRoaW5ncy4gQ29udHJvbCBzdWNoIElOUFVUIGlzIGp1c3QgcmVzcG9uc2libGUgZm9yIHJldHJpZXZlIHVzZXIgdmFsdWUgYnV0IG5vdCBob3cgaXRcbiAqIGFwcGVhciBvbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGlzIHdheSB3ZSBjYW4gYmUgZmxleGlibGUgaG93IHdlIHRyZWF0IHdpZGdldHMgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBzaXR1YXRpb24gZGVwZW5kaW5nXG4gKiB3aGVyZSB0aGV5IGFwcGVhclxuXG4gKiBGb3JtVGFibGUganVzdCBsaWtlIHRoZSByZXN0IG9mIHRoZSBjb21wb25lbnRzIGFyZSB1c2luZyBNb2RlbCBkcml2ZW4gYXBwcm9hY2ggaG93IHRvIHdvcmsgd2l0aFxuICogZGF0YSwgbWVhbiB3ZSBhcmUgdXNpbmcgRm9ybUdyb3VwLCBGb3JtQ29udHJvbCBldGMuIEZvcm1Hcm91cCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIEZvcm1UYWJsZSxcbiAqIG90aGVyd2lzZSBpdHMgYXV0b21hdGljYWxseSBjcmVhdGVkIHdoZW4gdGhlIEZvcm1UYWJsZSBpcyBpbnN0YW50aWF0ZWQuXG4gKlxuICogRm9ybUdyb3VwIGlzIHNhdmVkIGluc29kZSBFbnZpcm9ubWVudCB3aGVyZSB3ZSBhcmUgdXNpbmcgdGhpcyB0byBwYXNzIHRoaXMgYXJvdW5kIHRoZSBwYWdlcyBhbmRcbiAqIGNvbXBvbmVudHMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBTaW1wbGUgTGF5b3V0IGZpZWxkcyBhbmQgaXRzIGNvbnRyb2xcbiAqXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYFxuICogIFx0XHRcdDxhdy1mb3JtLXRhYmxlIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgKG9uU3VibWl0KT0+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIiduYW1lJ1wiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogIFx0XHRcdFx0XHQ8YXctaW5wdXQtZmllbGQgW3R5cGVdPVwiJ3N0cmluZydcIj48L2F3LWlucHV0LWZpZWxkPlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidQcmVmZXJyZWQgQ29sb3JzJ1wiIFtuYW1lXT1cIidteUNvbG9ycydcIj5cbiAqICBcdFx0XHRcdFx0PGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgW2xheW91dF09XCInaW5saW5lJ1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGljaygkZXZlbnQpXCI+XG4gKiAgXHRcdFx0XHRcdDwvYXctY2hlY2tib3gtbGlzdD5cbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidHZW5kZXInXCIgW25hbWVdPVwiJ2dlbmRlcidcIj5cbiAqXG4gKiAgXHRcdFx0XHRcdDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiVmFsdWVzXCIgW3NlbGVjdGlvbl09XCJyYlNlbGVjdGlvblwiPlxuICpcbiAqICBcdFx0XHRcdFx0PC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICpcbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidNeSBiaXJ0aGRhdGUnXCIgW25hbWVdPVwiJ2JpcnRoRGF0ZSdcIiBbc2l6ZV09XCInc21hbGwnXCI+XG4gKlxuICogIFx0XHRcdFx0XHQ8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgW3Nob3dUaW1lXT1cInNob3dUaW1lXCI+XG4gKiAgXHRcdFx0XHRcdDwvYXctZGF0ZS10aW1lPlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHQ8L2F3LWZvcm0tdGFibGU+XG4gKiAgICBgXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgU2hvd1VzZXJJbmZvQ29tcG9uZW50XG4gKiAge1xuICogICAgICAgY2hlY2tCb3hMaXN0VmFsdWVzOiBzdHJpbmdbXSA9IFsnYmx1ZScgLCAncmVkJyAsICd5ZWxsb3cnICwgJ29yYW5nZScgLCAnd2hpdGUnICwgJ3NpbHZlcidcbiAqICAgICAsICdibGFjaycgLCAnR3JlZW4nXG4gKiAgICAgLCAnR3JheScgLCAnTmF2eScgLFxuICogICAgICAgICAgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqICAgICAgc2VsZWN0ZWRWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKiAgICAgIHJiVmFsdWVzOiBzdHJpbmdbXSA9IFsnbWFsZScgLCAnZmVtYWxlJyAsICdvdGhlciddO1xuICogICAgICByYlNlbGVjdGlvbjogc3RyaW5nID0gJ21hbGUnO1xuICogICAgICBlZGl0YWJsZTogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgIHNob3dUaW1lOiBib29sZWFuID0gdHJ1ZTtcbiAqXG4gKiAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgb25DQkNsaWNrIChldmVudCk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIG9uU3VibWl0IChtb2RlbDogYW55KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG1vZGVsKVxuICpcbiAqICAgICAgICAgLy8gd2lsbCBwcmludCB7IG5hbWU6bnVsbCwgbXlDb2xvcnM6WydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ10sIGdlbmRlcjpcbiAqICAgICBtYWxlfVxuICogICAgICB9XG4gKlxuICogIH1cbiAqXG4gKiAgYGBgXG4gKlxuICogIE9yIHlvdSBjYW4gdXNlIHpvbmUgdG8gbGF5b3V0IHRoZXNlIGZpZWxkcyBpbnRvIHR3byBjb2x1bW5zOlxuICpcbiAqICBDdXJyZW50IHpvbmVzIGFyZSBpbXBsZW1lbnQgd2l0aCA8bmctY29udGVudCBTRUxFQ1Q+IHdoaWNoIGlzIGp1c3QgYSBzZWxlY3RvciB0byBzZWFyY2hlcyBmb3JcbiAqICAgICBzcGVjaWZpYyBwYXR0ZXJuLiBJbiBvdXIgY2FzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGV4dHJhIHdyYXBwZXIgY3VzdG9tIGNvbXBvbmVudCB1c2Ugc2ltcGxlXG4gKiAgICAgQ1NTIGNsYXNzXG4gKlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgI21ldGFGb3JtVGFibGUgW2VkaXRhYmxlXT1cImVkaXRpbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFt1c2VGaXZlWm9uZV09XCJpc0ZpdmVab25lTGF5b3V0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25TdWJtaXQpPVwib25TYXZlQWN0aW9uKCRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICA8YXctbGVmdCAgKm5nSWY9XCJjYW5TaG93Wm9uZSgnekxlZnQnKVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInbmFtZSdcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1pbnB1dC1maWVsZCBbdHlwZV09XCInc3RyaW5nJ1wiPjwvYXctaW5wdXQtZmllbGQ+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidQcmVmZXJyZWQgQ29sb3JzJ1wiIFtuYW1lXT1cIidteUNvbG9ycydcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1jaGVja2JveC1saXN0IFtsaXN0XT1cImNoZWNrQm94TGlzdFZhbHVlc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25zXT1cInNlbGVjdGVkVmFsdWVzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xheW91dF09XCInaW5saW5lJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvbkNCQ2xpY2soJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgPC9hdy1sZWZ0PlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICA8YXctcmlnaHQgICpuZ0lmPVwiY2FuU2hvd1pvbmUoJ3pSaWdodCcpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0dlbmRlcidcIiBbbmFtZV09XCInZ2VuZGVyJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiVmFsdWVzXCIgW3NlbGVjdGlvbl09XCJyYlNlbGVjdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ015IGJpcnRoZGF0ZSdcIiBbbmFtZV09XCInYmlydGhEYXRlJ1wiXG4gKiAgICAgW3NpemVdPVwiJ3NtYWxsJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRhdGUtdGltZSBbdmFsdWVdPVwiZGF0ZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gKiAgICAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRhdGUtdGltZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgIDwvPGF3LXJpZ2h0PlxuICogICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogIGBgYFxuICpcbiAqICB0b2RvOiByZW1vdmUgbXkgY3NzIHNlbGVjdG9ycyBmb3Igem9uZXMgYW5kIHJlcGxhY2UgaXQgd2l0aCByZWFsIGNvbXBvbmVudCBldmVuIGp1c3QgYSB0YWdcbiAqICB0b2RvOiB3b3VsZCB3b3JrIGZpbGVcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZm9ybS10YWJsZScsXG4gICAgdGVtcGxhdGVVcmw6ICdmb3JtLXRhYmxlLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZm9ybS10YWJsZS5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1UYWJsZUNvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtVGFibGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHRoZSBmb3JtIGxheW91dCB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbGFiZWxzIHN0YWNrZWQgIG9yIHNpZGUgYnkgc2lkZSBuZXh0IHRvXG4gICAgICogdGhlIGNvbnRyb2xcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxzT25Ub3A/OiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgdGhpcyBhIDQgem9uZSBsYXlvdXRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlRml2ZVpvbmU/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgY2VydGFpbiB1c2VjYXNlIHdlIGRvbnQgd2FudCB0byBzZXQgYXV0b21hdGljYWxseSB0aGlzIHRvIGFsbCBjaGlsZHJlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFiaWxpdHlDaGVjazogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiAgVHJpZ2dlcnMgd2hlbiB0aGUgPGZvcm0+IGlzIHN1Ym1pdHRlZC4gb25TdWJtaXQgd2UgZW1pdCB0aGUgd2hvbGUgZm9ybUNvbnRyb2xsZXIgb2JqZWN0c1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblN1Ym1pdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgcmVwcmVzZW50IGluZGl2aWR1YWwgem9uZXMgYW5kIHdlIHVzZSB0aGVtIHRvIGFkanVzdCBvdXIgY29sdW1uIGdyaWRcbiAgICAgKiBsYXlvdXRcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKExlZnRab25lQ29tcG9uZW50KSBsZWZ0Wm9uZTogTGVmdFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKE1pZGRsZVpvbmVDb21wb25lbnQpIG1pZGRsZVpvbmU6IE1pZGRsZVpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKFJpZ2h0Wm9uZUNvbXBvbmVudCkgcmlnaHRab25lOiBSaWdodFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKFRvcFpvbmVDb21wb25lbnQpIHRvcFpvbmU6IFRvcFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKEJvdHRvbVpvbmVDb21wb25lbnQpIGJvdHRvbVpvbmU6IEJvdHRvbVpvbmVDb21wb25lbnQ7XG5cblxuICAgIEBDb250ZW50Q2hpbGRyZW4oQmFzZUZvcm1Db21wb25lbnQsIHtkZXNjZW5kYW50czogdHJ1ZX0pXG4gICAgZm9ybUZpZWxkczogUXVlcnlMaXN0PEJhc2VGb3JtQ29tcG9uZW50PjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSwge2Rlc2NlbmRhbnRzOiB0cnVlfSlcbiAgICByb3dzOiBRdWVyeUxpc3Q8Rm9ybVJvd0NvbXBvbmVudD47XG5cblxuICAgIC8qKlxuICAgICAqIENhY2hlIGNhbGN1bGF0ZWQgcHJvcGVydGllcyB3aGVuIGluaXQgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc09uZUNvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhhc1R3b0NvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhhc1RocmVlQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBudWxsKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ2VkaXRhYmxlJ10pICYmXG4gICAgICAgICAgICBjaGFuZ2VzWydlZGl0YWJsZSddLnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXNbJ2VkaXRhYmxlJ10uY3VycmVudFZhbHVlKSB7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUZpZWxkcygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBvblN1Ym1pdEZvcm0oZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25TdWJtaXQuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcmUgbGFiZWxzIG9uIHRvcFxuICAgICAqXG4gICAgICovXG4gICAgaXNMYWJlbHNPblRvcCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNPblRvcDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSBjaGlsZCBjb21wb25lbnQgdG8gaW5oZXJpdCBlZGl0YWJpbGl0eVxuICAgICAqXG4gICAgICovXG4gICAgaXNGb3JtRWRpdGFibGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGU7XG4gICAgfVxuXG5cbiAgICBhcHBseUNvbHVtbnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZUZpdmVab25lICYmIHRoaXMuaGFzQW55Wm9uZXMoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lcyBkZXRlY3RlZCBpbiB0aGUgRm9ybVRhYmxlIGJ1dCB1c2VGaXZlWm9uZSBvcHRpb24gaXMgZmFsc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzT25lQ29sdW1uID0gIWlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiYgIWlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpO1xuICAgICAgICB0aGlzLmhhc1R3b0NvbHVtbiA9IGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSAmJiBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmXG4gICAgICAgICAgICAhaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSk7XG5cbiAgICAgICAgdGhpcy5oYXNUaHJlZUNvbHVtbiA9IGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSAmJiBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmXG4gICAgICAgICAgICBpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNUd29Db2x1bW4gJiYgIXRoaXMuaXNUd29ab25lUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTYnO1xuICAgICAgICAgICAgdGhpcy5yaWdodFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy02JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc1RocmVlQ29sdW1uICYmICF0aGlzLmlzVGhyZWVab25lUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTQnO1xuICAgICAgICAgICAgdGhpcy5yaWdodFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy00JztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBoYXNBbnlab25lcygpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgfHwgaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSlcbiAgICAgICAgICAgIHx8IGlzUHJlc2VudCh0aGlzLnRvcFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLmJvdHRvbVpvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSBpbml0aWFsaXplZCB0aGUgY2xhc3NMaXN0LlxuICAgICAqIHRoZVxuICAgICAqXG4gICAgICogVE9ETzogUHJvYmFibHkgc3RyaW5nIGFycmF5IHdvdWxkIGJlIGVhc2llclxuICAgICAqL1xuICAgIGlzVHdvWm9uZVJlYWR5KCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy02JykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy02JykgPiAwO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBhbHJlYWR5IGluaXRpYWxpemVkIHRoZSBjbGFzc0xpc3QuXG4gICAgICogdGhlXG4gICAgICpcbiAgICAgKiBUT0RPOiBQcm9iYWJseSBzdHJpbmcgYXJyYXkgd291bGQgYmUgZWFzaWVyXG4gICAgICovXG4gICAgaXNUaHJlZVpvbmVSZWFkeSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNCcpID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNCcpID4gMDtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gcHJvYmxlbSBzaW5jZSBBbmd1bGFyIDQuMiwgbmdBZnRlckNvbnRlbnRJbml0XG4gICAgICAgIC8vIHdpdGhvdXQgdGhpcyBJIGdldCBlcnJvciB0aGF0IHZhbHVlIHdhcyBjaGFuZ2VkIGFmdGVyIHZpZXcgd2FzIGNoZWNrZWRcbiAgICAgICAgLy8gdG9kbzogcmVmYWN0b3IgIC0gbWFpbmx5IG91ciB6b25lcyBsZWZ0LCByaWdodCBtaWRkbGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Q29sdW1ucygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtRmllbGRzKCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdExheW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdXBkYXRlRm9ybUZpZWxkcygpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJpbGl0eUNoZWNrICYmIGlzUHJlc2VudCh0aGlzLmZvcm1GaWVsZHMpICYmIHRoaXMuZm9ybUZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1GaWVsZHMuZm9yRWFjaCgoaXRlbTogQmFzZUZvcm1Db21wb25lbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXRlbS5lZGl0YWJsZSA9IHRoaXMuZWRpdGFibGU7XG4gICAgICAgICAgICAgICAgLy8gaXRlbS5mb3JtR3JvdXAgPSB0aGlzLmZvcm1Hcm91cDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiBpZiB3ZSBhcmUgMiBvciAzIG9yIDEgY29sdW1uIGxheW91dCB3ZSBuZWVkIHRvIGFkanVzdCB3aWRnZXRzIHdpZHRoIHdpdGhpbiB0aGVcbiAgICAgKiBmb3JtIHJvdy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFkanVzdExheW91dCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucm93cykgJiYgdGhpcy5yb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1RocmVlQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzLmZvckVhY2goKGl0ZW06IEZvcm1Sb3dDb21wb25lbnQpID0+IGl0ZW0uc2l6ZSA9ICdsYXJnZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1UYWJsZUNvbXBvbmVudH0gZnJvbSAnLi9mb3JtLXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4vZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgQm90dG9tWm9uZUNvbXBvbmVudCxcbiAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICBUb3Bab25lQ29tcG9uZW50XG59IGZyb20gJy4uL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRm9ybVRhYmxlQ29tcG9uZW50LFxuICAgICAgICBGb3JtUm93Q29tcG9uZW50LFxuICAgICAgICBUb3Bab25lQ29tcG9uZW50LFxuICAgICAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgICAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgICAgICBCb3R0b21ab25lQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Zvcm1UYWJsZU1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50LCBWYWx1ZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGVjaW1hbFBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZXByZXNlbnQgYSBJbnB1dCBmaWVsZCBhbmQgaXQgY2FuICBhY2NlcHQgZGlmZmVyZW50IHR5cGVzIG9mIHZhbHVlcyBzdWNoIGFzXG4gKiB0ZXh0LCBudW1iZXIuXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICd3cmFwcGVyLWNvbXAnICxcbiAqICAgICAgdGVtcGxhdGU6ICc8YXctaW5wdXQtZmllbGQgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiBbdHlwZV09XCJpbnB1dFR5cGVcIj48L2F3LWlucHV0LWZpZWxkPidcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBUZXN0SW5wdXRDb21wb25lbnRcbiAqICB7XG4gKiAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHRleHQnO1xuICpcbiAqICAgICAgLy8gYnkgZGVmYXVsdCBpbnB1dCB0eXBlIGlzIHRleHQsIHlvdSBjYW4gcGFzcyBzdHJpbmcsIFN0cmluZywgb3IgdGV4dFxuICogICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogIH1cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIHdoZXIgaW5wdXQgZmllbGQgaXMgaW5pdGlhbGl6ZWQgd2l0aCBuZ01vZGVsXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1pbnB1dC1maWVsZCBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFsobmdNb2RlbCldPVwiaW5wdXRUeXBlXCI+PC9hdy1pbnB1dC1maWVsZD4nXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgVGVzdElucHV0Q29tcG9uZW50XG4gKiAge1xuICogICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSB0ZXh0JztcbiAqXG4gKiAgICAgIC8vIGJ5IGRlZmF1bHQgaW5wdXQgdHlwZSBpcyB0ZXh0LCB5b3UgY2FuIHBhc3Mgc3RyaW5nLCBTdHJpbmcsIG9yIHRleHRcbiAqICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICB9XG4gKlxuICogYGBgXG4gKlxuICogIE5vdGU6IGlmIHlvdSBhcmUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIEZvcm1UYWJsZSBwbGVhc2UgcHJvdmlkZSB5b3VyIG93biBGb3JtR3JvdXBcbiAqXG4gKi9cblxuXG5cbmV4cG9ydCBjb25zdCBJTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSW5wdXRGaWVsZENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1pbnB1dC1maWVsZCcsXG4gICAgdGVtcGxhdGVVcmw6ICdpbnB1dC1maWVsZC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2lucHV0LWZpZWxkLmNvbXBvbmVudC5zY3NzJ10sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcblxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0RmllbGRDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRGaWVsZENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgdmFsdWUgdXNlZCB0byBzYXZlIGFuZCByZWFkICB3aGVuIHJlbmRlcmluZyBhbmQgdXBkYXRpbmcgYSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHVzZWQgdG8gZm9ybWF0IHRoZSBudW1iZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwcmVjaXNpb246IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEJpZ0RlY2ltYWwgb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHZhbHVlIGFuZCBsb2NhbGUuXG4gICAgICogSWYgdGhpcyBvYmplY3QgaXMgc2V0LCB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIHRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaWdEZWNpbWFsOiBCaWdEZWNpbWFsO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBjdXN0b20gaWNvbiB0aGF0IGlzIHBsYWNlZCBpbnRvIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgKlxuICAgICAqIFRvZG86IGFkZCBleHRyYSBiaW5kaW5nIHRoYXQgd2lsbCBhbGxvdyBkZXZlbG9wZXIgdG8gdGVsbCBwb3NpdGlvbiwgbGVmdCByaWdodFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWNvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWNpbWFsIHBpcGUgaXMgdXNlZCB0byBmb3JtYXQgb3VyIG51bWJlciBvYmplY3QuXG4gICAgICovXG4gICAgZGVjaW1hbFBpcGU6IERlY2ltYWxQaXBlO1xuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXR0ZWQgZGVjaW1hbCB2YWx1ZS4gVXNlcyBhbmd1bGFyIGRlY2ltYWxQaXBlIHRvIGZvcm1hdCBiYXNlZCBvbiBsb2NhbGUuXG4gICAgICovXG4gICAgZGlzcGxheVZhbHVlOiBzdHJpbmcgPSAnJztcbiAgICAvKipcbiAgICAgKiBKdXN0IHRvIGNsZWFuIHVwIHN1YnNjcmliZXIgd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkXG4gICAgICovXG4gICAgcHJpdmF0ZSB2Y2hTdWJzY3JpYmVyOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZGVjaW1hbFBpcGUgPSBuZXcgRGVjaW1hbFBpcGUoZW52LmxvY2FsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5wdXQgZmllbGQgdHlwZS4gQ3VycmVudGx5IHdlIHN1cHBvcnQgZWl0aGVyIE51bWJlciBvciB0ZXh0XG4gICAgICovXG4gICAgcHJpdmF0ZSBfdHlwZTogc3RyaW5nID0gJ3N0cmluZyc7XG5cbiAgICBnZXQgdHlwZSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogZ2VuZXJhdGVkIHNldHRlciB0byBjaGVjayBmb3IgdmFsdWUgYW5kIG5vcm1hbGl6aW5nIGludG8gZXhwZWN0ZWQgZWl0aGVyIG51bWJlciBvciB0ZXh0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCB0eXBlKHZhbHVlOiBzdHJpbmcpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N0cmluZycgfHwgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3RleHQnO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ251bWJlcic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuYmlnRGVjaW1hbCk7XG5cbiAgICAgICAgdGhpcy52Y2hTdWJzY3JpYmVyID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHZhbCA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmJpZ0RlY2ltYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXROdW1iZXIodGhpcy5iaWdEZWNpbWFsLmFtb3VudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjYW5TZXRUeXBlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG9uS2V5RG93bihlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IGVsLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLmRpc3BsYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkJsdXIoZWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl90eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5iaWdEZWNpbWFsID0gbmV3IEJpZ0RlY2ltYWwoTnVtYmVyKGVsLnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0TnVtYmVyKHRoaXMuYmlnRGVjaW1hbC5hbW91bnQpO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLmRpc3BsYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuZGlzcGxheVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlLCB7b25seVNlbGY6IHRydWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0aGUgbnVtYmVyIG9iamVjdCBhY2NvcmRpbmcgdG8gaXRzIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGZvcm1hdE51bWJlcih2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgcHJlY2lzaW9uIGlzIHByZXNlbnQsIHVzZSBpdCBmb3IgZm9ybWF0IHRoZSBiaWdEZWNpbWFsIHZhbHVlIGZvciBkaXNwbGF5LlxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucHJlY2lzaW9uKSAmJlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9PT0gJ251bWJlcicpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHByZWNpc2lvbiBpcyAyLiBGb3IgZXhhbXBsZSwgMTAuMjMuXG4gICAgICAgICAgICBsZXQgZGlnaXRzID0gJzEuMC0yJztcbiAgICAgICAgICAgIGRpZ2l0cyA9ICcxLjAtJyArIHRoaXMucHJlY2lzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjaW1hbFBpcGUudHJhbnNmb3JtKHZhbHVlLCBkaWdpdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52Y2hTdWJzY3JpYmVyKSkge1xuICAgICAgICAgICAgdGhpcy52Y2hTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQmlnRGVjaW1hbCBvYmplY3QgaXMgcmVwcmVzZW50ZWQgYXMgYSB2YWx1ZSwgbG9jYWxlLCBhbmQgY3VycmVuY3lDb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWdEZWNpbWFsIGltcGxlbWVudHMgVmFsdWVcbntcbiAgICB1bmlxdWVOYW1lOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYW1vdW50OiBudW1iZXIgPSAwLFxuICAgICAgICAgICAgICAgIHB1YmxpYyByZWFkb25seSBsb2NhbGU6IHN0cmluZyA9ICdlbl9VUycpXG4gICAge1xuICAgIH1cblxuXG4gICAgZ2V0VHlwZXMoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIsXG4gICAgICAgICAgICBsb2NhbGU6IFN0cmluZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzTmFtZSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiAnQmlnRGVjaW1hbCc7XG4gICAgfVxuXG4gICAgJHByb3RvKCk6IEJpZ0RlY2ltYWxcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbCgxLCAnZW5fVVMnKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmFtb3VudCArICcsIGxvY2FsZTogJyArIHRoaXMubG9jYWxlO1xuICAgIH1cblxuXG4gICAgY2xvbmUoZGF0YTogeyBhbW91bnQ/OiBudW1iZXIsIGxvY2FsZT86IHN0cmluZyB9ID0ge30pOiBCaWdEZWNpbWFsXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5hbW91bnQpID8gZGF0YS5hbW91bnQgOiB0aGlzLmFtb3VudCxcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmxvY2FsZSkgPyBkYXRhLmxvY2FsZSA6IHRoaXMubG9jYWxlKTtcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtTdHJpbmdDb21wb25lbnR9IGZyb20gJy4vc3RyaW5nLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3RyaW5nQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1N0cmluZ0ZpZWxkTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW5wdXRUZXh0TW9kdWxlfSBmcm9tICdwcmltZW5nL2NvbXBvbmVudHMvaW5wdXR0ZXh0L2lucHV0dGV4dCc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5wdXRGaWVsZENvbXBvbmVudH0gZnJvbSAnLi4vaW5wdXQtZmllbGQvaW5wdXQtZmllbGQuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBJbnB1dEZpZWxkQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIElucHV0RmllbGRDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSW5wdXRGaWVsZENvbXBvbmVudCxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdJbnB1dEZpZWxkTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0FwcENvbmZpZywgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKlxuICogYmFzaWMgbmF2aWdhdGlvbiBiYXIgcHJvdmlkZSBhIG1haW4gYWN0aW9uIGJ1dHRvbnMgZm9yIGl0cyBjb250ZW50IChwYWdlIGxldmVsIGJ1dHRvbnMpLlxuICogVGhpcyBpcyBub3QgdGhlIFRvcCBsZXZlbCBhcHBsaWNhdGlvbiBuYXZpZ2F0aW9uLiBUaGlzIGNvbXBvbmVudCBwcm92aWRlcyBieSBkZWZhdWx0IGFjdGlvbiBPSyxcbiAqIENBTkNFTCBhbmQgeW91IGFyZSBmcmVlIHRvIG1vZGlmeSBob3cgdGhlIE9LIG9yIENBTkNFTCB3aWxsIGJlIGNhbGwgYXMgd2VsbCBhcyBzdWJzY3JpYmUgdG8gdGhlXG4gKiBldmVudC4gT3IgeW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGJ1dHRvbnMgdGVtcGxhdGUgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhpcyBkZWZhdWx0XG4gKiBvbmUuXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIDE6XG4gKlxuICogSW4gb3JkZXIgdG8gdXNlIG5hdmlnYXRpb24gYmFyIGluIGl0cyBiYXNpYyB1c2FnZSB5b3UgY2FuIGRvIGZvbGxvd2luZzpcbiAqIHRoaXMgd2lsbCByZW5kZXIgYnV0dG9ucyBvbiB0aGUgdG9wIGFzIHdlbGwgYXMgb24gdGhlIGJvdHRvbSBhcm91bmQgdGhlIGNvbnRlbnQuXG4gKlxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICAgICA8YXctYmFzaWMtbmF2aWdhdG9yIFticmFuZEltZ109XCInaW1nL2FyaWJhbG9nb2JhbC5wbmcnXCI+XG4gKlxuICogICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gKiAgICAgICAgICAgICAgICA8Zm9ybT5cbiAqICAgICAgICAgICAgICAgICAgICBVc2VyIG5hbWU6IDxpbnB1dCB0eXBlPXRleHQgdmFsdWU9XCJwZXRlci5wYW5cIj5cbiAqICAgICAgICAgICAgICAgIDwvPGZvcm0+PlxuICogICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9hdy1iYXNpYy1uYXZpZ2F0b3I+XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqICBpZiB5b3UgZG8gbm90IHdhbnQgYnV0dG9uIG9uIHRoZSB0b3Agb3IgYm90dG9tIHlvdSBjYW4gc2F5IHRoaSB1c2luZyBiaW5kaW5nIHNob3dUb3Agb3JcbiAqIHNob3dCb3R0b20uXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIDI6XG4gKiAgSW4gdGhpcyBleGFtcGxlIHdlIGFyZSBwcm92aWRpbmcgY3VzdG9tIGJ1dHRvbnMgYXMgd2VsbCBhcyBicmFuayBzZWN0aW9uXG4gKlxuICpcbiAqICBgYGBodG1sXG4gKlxuICpcbiAqICAgICAgPGF3LWJhc2ljLW5hdmlnYXRvciBbYnJhbmRJbWddPVwiJ2ltZy9hcmliYWxvZ29iYWwucG5nJ1wiPlxuICogICAgICAgICAgICA8bmctdGVtcGxhdGUgI2J1dHRvbnM+XG4gKiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJuYXYgbmF2YmFyLW5hdiBmbG9hdC1tZC1yaWdodCBjb2xsYXBzZSBuYXZiYXItdG9nZ2xlYWJsZS14c1wiPlxuICogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIFwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAqIChjbGljayk9XCJvblNhdmVBY3Rpb24oJGV2ZW10KVwiPkNhbmNlbDwvYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gKiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gYWN0aXZlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAqIChjbGljayk9XCJvbkNhbmNlbEFjdGlvbigkZXZlbnQpXCI+IFNhdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAqICAgICAgICAgICAgICAgIDwvdWw+XG4gKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgICAgICAgICA8bmctdGVtcGxhdGUgI2JyYW5kPlxuICogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJicmFuZC10aXRsZVwiPkFyaWJhPC9zcGFuPlxuICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAqICAgICAgICAgICAgICAgIDxmb3JtPlxuICogICAgICAgICAgICAgICAgICAgIFVzZXIgbmFtZTogPGlucHV0IHR5cGU9dGV4dCB2YWx1ZT1cInBldGVyLnBhblwiPlxuICogICAgICAgICAgICAgICAgPC88Zm9ybT4+XG4gKiAgICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L2F3LWJhc2ljLW5hdmlnYXRvcj5cbiAqXG4gKlxuICogYGBgXG5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctYmFzaWMtbmF2aWdhdG9yJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIEJhc2ljTmF2aWdhdG9yQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkIG9uIHRoZSB0b3BcbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgVFJVRVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93VG9wOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkIG9uIHRoZSBib3R0b21cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgVFJVRVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Qm90dG9tOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJyYW5kIHNlY3Rpb24gdGhhdCBpcyBvbiB0aGUgbGVmdCBzaWRlIGFuZCBvbmx5IGluIHRoZSB0b3AgYmFyIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgVFJVRVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93QnJhbmQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcGF0aCB0byBhIGltYWdlLiBJbWFnZXMgYXJlIHNhdmVkIGluc2lkZSBhc3NldHMgZm9sZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBicmFuZEltZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gT0sgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBva0FjdGlvbkxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBDYW5jZWwgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjYW5jZWxBY3Rpb25MYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb250ZXh0IGlzIGFuIG9iamVjdCB3aGljaCBpcyByZW5kZXJlZCBpbnNpZGUgbmF2LWJhciBjb250ZW50LiBTb21ldGltZXMgdGhlcmUgYXJlIHNpdHVhdGlvblxuICAgICAqIHRoYXQgeW91IHdhbnQgdG8gcmVuZGVyIHNvbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgb2JqZWN0IGluc2lkZSBuYXZpZ2F0aW9uIGJhci4gU28geW91IGFyZVxuICAgICAqIGZyZWUgdG8gcGFzcyBhIGNvbnRleHQgb2JqZWN0IGFuZCB0aGVuIGFjY2VzcyBpdCBpbnNpZGUgeW91ciB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICogYGBgSFRNTFxuICAgICAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNicmFuZCBsZXQtaXRlbT5cbiAgICAgKiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJyYW5kLXRpdGxlXCI+e3tpdGVtLmZpcnN0TmFtZX19PC9zcGFuPlxuICAgICAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGV4dDogYW55O1xuXG5cbiAgICBASW5wdXQoKVxuICAgIHNob3dDYW5jZWxCdXR0b246IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV2ZW50RW1pdHRlciB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjbGljayBvbiBkZWZhdWx0IE9LIEFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PS0FjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRXZlbnRFbWl0dGVyIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4geW91IGNsaWNrIG9uIGRlZmF1bHQgQ0FOQ0VMIEFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DYW5jZWxBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBidXR0b25zIHRlbXBsYXRlIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2J1dHRvbnMnKVxuICAgIGJ1dHRvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBicmFuZCB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdicmFuZCcpXG4gICAgYnJhbmRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG5cbiAgICBjb25zdHJ1Y3RvcihlbnY6IEVudmlyb25tZW50LCBhcHBDb25maWc6IEFwcENvbmZpZylcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gdG9kbzogbG9hZCB0aGlzIGZyb20gcmVzb3VyY2UgZmlsZSB1c2luZyBuZ1RyYW5zbGF0ZSBzZXJ2aWNlXG4gICAgICAgIHRoaXMub2tBY3Rpb25MYWJlbCA9ICdPSyc7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uTGFiZWwgPSAnQ2FuY2VsJztcbiAgICAgICAgdGhpcy5icmFuZEltZyA9ICdpbWFnZXMvYXJpYmFsb2dvYmFsLnBuZyc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zaG93Q2FuY2VsQnV0dG9uKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93Q2FuY2VsQnV0dG9uID0gdGhpcy5lZGl0YWJsZSB8fCAodGhpcy5vbkNhbmNlbEFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICYmIHRoaXMub25PS0FjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYnV0dG9uc1RlbXBsYXRlIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzQnV0dG9uVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJ1dHRvbnNUZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBicmFuZFRlbXBsYXRlIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzQnJhbmRUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuYnJhbmRUZW1wbGF0ZSk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQnV0dG9uIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvci4gQnV0dG9uIGNhbiBiZSByZW5kZXJlZCBlaXRoZXIgYXNcbiAqIGEgYnV0dG9uIG9yIGFzIGEgbGluay4gSXQgY291bGQgYmUgc3RhbmRhbG9uZSBvciBiZSBwYXJ0IG9mIGEgZm9ybS5cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgIDxhdy1mb3JtLXRhYmxlID5cbiAqICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0Ftb3VudCdcIiBbbmFtZV09XCInYW1vdW50J1wiIFtzaXplXT1cIidzbWFsbCdcIj5cbiAqXG4gKiAgICAgICAgICAgPGF3LWJ1dHRvbiBbdHlwZV09XCInc3VibWl0J1wiIFtuYW1lXT1cIididXR0b24nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNsaWNrZWQoJGV2ZW50KVwiIFt2YWx1ZV09XCJjb21tYW5kXCJcbiAqICAgICAgICAgICAgICAgICAgICAgW3N0eWxlXT1cIid3YXJuaW5nJ1wiID5CdXR0b248L2F3LWJ1dHRvbj5cbiAqICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgIDwvYXctZm9ybS10YWJsZT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgY29tbWFuZDpib29sZWFuO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgICAgIG9uQ2xpY2tlZCh2YWx1ZTpzdHJpbmcpIHtcbiAqICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAqICAgICAgICAgICAgICAvLyBzdWJtaXQgZm9ybS5cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWJ1dHRvbicsXG4gICAgdGVtcGxhdGVVcmw6ICdidXR0b24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydidXR0b24uY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogQnV0dG9uIHR5cGVzICBbIGJ1dHRvbiB8IHN1Ym1pdCB8IHJlc2V0IF1cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogc3RyaW5nID0gJ2J1dHRvbic7XG5cbiAgICAvKipcbiAgICAgKiBOYW1lIGZvciB0aGlzIGJ1dHRvbi4gQ2FuIGJlIHVzZWQgdG8gbG9va3VwIGNvbXBvbmVudCBpbiBmb3JtLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbmFtZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBzdHlsaW5nIGZvciB0aGlzIGJ1dHRvbi4gU2VlIEJ1dHRvblN0eWxlIGZvciBhbGwgc3VwcG9ydGVkIHN0eWxlcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0eWxlOiBCdXR0b25TdHlsZSA9ICdwcmltYXJ5JztcblxuXG4gICAgLyoqXG4gICAgICogc2l6aW5nIGZvciB0aGlzIGJ1dHRvbi4gW2xhcmdlLCBub3JtYWwsIHNtYWxsXS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNpemU6IEJ1dHRvblNpemUgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHRhcmdldCBvZiB0aGUgYnV0dG9uLiBbX2JsYW5rIHwgX3NlbGYgfCBfcGFyZW50IHwgX3RvcCB8IGZyYW1lbmFtZSBdXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0YXJnZXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIGJlIHNlbmQgdG8gc2VydmVyIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFByaW1lTmcgYnV0dG9uIHNpbXBseSBkb2VzIG5vdCBzdXBwb3J0IGNvbnRlbnQgc28gd2UgbmVlZCB0byBnZXQgYXJvdW5kIGl0XG4gICAgICovXG4gICAgbGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIENTUyBjbGFzcyB0aGF0IHN0eWxlcyB0aGlzIGJ1dHRvbiBiYXNlZCBvbiBpbnB1dCAnc3R5bGUnIGFuZCAnc2l6ZSdcbiAgICAgKi9cbiAgICBidXR0b25DbGFzczogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICAvLyBEZWZhdWx0IGJ1dHRvbiBjbGFzcyBpcyBzZWNvbmRhcnkuXG4gICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAndWktYnV0dG9uLXNlY29uZGFyeSc7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkaXNhYmxlZFxuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgLy8gSG93IHRvIHN0eWxlIHRoaXMgYnV0dG9uLlxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZSA9PT0gJ3ByaW1hcnknKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCAudWktYnV0dG9uIGFuZCAudWktYnV0dG9uLXByaW1hcnkgZ2V0IHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICAgICAgICAgIC8vIC51aS1idXR0b24tcHJpbWFyeSBpcyBuZWNlc3NhcnkgYmVjYXVzZSBidXR0b24gc3R5bGUgY2FuIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGluY2x1ZGVkIGluc2lkZSBvdGhlciB3aWRnZXRzLiBTbyBzcGVjaWZ5IHByaW1hcnlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJ3VpLWJ1dHRvbi1wcmltYXJ5JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICd1aS1idXR0b24tJyArIHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGJ1dHRvbiBjbGFzcyBiYXNlZCBvbiBpbnB1dCBzaXplLlxuICAgICAgICBpZiAodGhpcy5zaXplKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFyZ2UnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyArPSAnIGJ0bi1sZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzICs9ICcgYnRuLW1pZCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgKz0gJyBidG4tc20nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBsaXR0bGUgaGFja3kgaGFja2l0eSBoYWNrIGFzIGN1cnJlbnRseSBwcmltZW5nIGJ1dHRvbiBkaXJlY3RpdmUgZG9lcyBub3Qgd29yayB3aXRoXG4gICAgICogbmdjb250ZW50IHByb2plY3Rpb24gYnV0IGl0IGhhcyBhIGxhYmVsIGJpbmRpbmdzLCB3aGljaCBpcyBub3QgdGhlIHdheSBkZXZlbG9wZXJzIHdvcmsgd2l0aFxuICAgICAqIGJ1dHRvbi4geW91IHdhbnQgdG9cbiAgICAgKlxuICAgICAqIDxidXR0b24+IE1ZIENPTlRFTlQ8L2J1dHRvbiBpbnN0ZWFkIG9mIDxidXR0b24gbGFiZWw9J015Q29udGVudCc+PC9idXR0b24+XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBUb2RvOiBDaGFuZ2UgdGhpcyB1bnRpbCB0aGUgdGltZSBrZWVwIGEgdGVzdCB0aGF0IGNoZWNrIHRoYXQgdGhleSBhcmUgc3RpbGwgdXNpbmcgdWktYnV0dG9uXG4gICAgICogICAgIHRoYXQgd2UgYXJlIGV4cGVjdGluZyBhbmQgcmVwbGFjaW5nXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5lbGVtZW50KSkge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpO1xuICAgICAgICAgICAgbGV0IGJ1dHRvblRpdGxlID0gYnV0dG9uLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgYnV0dG9uLmNoaWxkcmVuWzBdLnRleHRDb250ZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3VpLWJ1dHRvbicsICcnKS5yZXBsYWNlKCd1aS1idG4nLCAnJyk7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd1aS1idXR0b24tdGV4dC1lbXB0eScpO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQoYnV0dG9uVGl0bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEFjdGlvbiBjbGlja2VkLiBDYWxsIHBhcmVudCBhY3Rpb24uXG4gICAgICovXG4gICAgY2xpY2tlZCgkZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoaXNCbGFuayh0aGlzLnZhbHVlKSA/ICRldmVudCA6IHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFN1cHBvcnRlZCBCdXR0b24gU3R5bGVcbiAqL1xuZXhwb3J0IHR5cGUgQnV0dG9uU3R5bGUgPSAnaW5mbycgfCAncHJpbWFyeScgfCAnc2Vjb25kYXJ5JyB8ICd3YXJuaW5nJyB8ICdzdWNjZXNzJyB8ICdkYW5nZXInIHxcbiAgICAnbGluayc7XG5cbi8qKlxuICogU3VwcG9ydGVkIEJ1dHRvbiBTaXplXG4gKi9cbmV4cG9ydCB0eXBlIEJ1dHRvblNpemUgPSAnbGFyZ2UnIHwgJ25vcm1hbCcgfCAnc21hbGwnO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtCdXR0b25Db21wb25lbnR9IGZyb20gJy4vYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQge0J1dHRvbk1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBCdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBCdXR0b25Nb2R1bGUsXG5cbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBCdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQnV0dG9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtCYXNpY05hdmlnYXRvckNvbXBvbmVudH0gZnJvbSAnLi9iYXNpYy1uYXZpZ2F0b3IuY29tcG9uZW50JztcbmltcG9ydCB7VG9vbGJhck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4uL2J1dHRvbi9idXR0b24ubW9kdWxlJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBCYXNpY05hdmlnYXRvckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcblxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBCYXNpY05hdmlnYXRvckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBhdy1jYXJkLXRvcGAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXp0b3AnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkWm9uZVRvcENvbXBvbmVudFxue1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYGF3LWNhcmQtYm90dG9tYCxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd3LWNhcmQtemJvdHRvbSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhcmRab25lQm90dG9tQ29tcG9uZW50XG57XG59XG5cbi8qKlxuICpcbiAqIENhcmQgY29tcG9uZW50IGlzIGEgY29udGFpbmVyIHJlbmRlcmluZyBpdHMgY29udGVudCBpbnNpZGUgMyBkaWZmZXJlbnQgem9uZXMuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICBUSVRMRSAgICAgICAgICAgICAgICAgICAgICAgfCBBQ1RJT04gfFxuICogIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICBUT1AgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICBCT1RUT00gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqXG4gKiAgVGhlcmUgYXJlIDMgem9uZXMgICsgMSBwbGFjZWhvbGRlciBmb3IgdGhlIGFjdGlvbkljb25cbiAqXG4gKiAgQ2FyZHMgY2FuIGJlIHNlbGVjdGFibGUgd2hpY2ggbWVhbnMgd2hlbiB5b3UgY2xpY2sgb24gaXQgdGhlcmUgd2lsbCBiZSByZW5kZXJlZCBhIGJvcmRlciB3aXRoXG4gKiAgYSBjaGVjayBtYXJrIGluc2lkZSBBY3Rpb24gem9uZSAodGhpcyBpcyBkZWZhdWx0IGJlaGF2aW9yKS5cbiAqICBZb3UgY2FuIHVzZSBbc2VsZWN0YWJsZV0gYmluZGluZyB0byBkaXNhYmxlIHRoaXMsIGluIHN1Y2ggY2FzZSBjYXJkIHdpbGwgaGF2ZSBqdXN0IGEgYm9yZGVyXG4gKiAgd2l0aG91dCBhbnkgY2hlY2sgbWFyay5cbiAqXG4gKiAgQ2FyZHMgY2FuIGFsc28gY29udGFpbiBjdXN0b20gQWN0aW9uIHdoaWNoIGlzIHJlbmRlcmVkIGluc2lkZSBBQ1RJT04gem9uZSBhbmQgb24gdGhlXG4gKiAgYXBwbGljYXRpb24gbGV2ZWwgeW91IGNhbiBsaXN0ZW4gZm9yIChjbGljaykgZXZlbnRzIGFzIHdlbGwgYXMgeW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGFjdGlvblxuICogIGljb25cbiAqXG4gKiAgQmVzaWRlcyBBQ1RJT04sIFRJVExFLCBUT1AgYW5kIEJPVFRPTSBjb250ZW50IHpvbmVzIGNhcmRzIHN1cHBvcnQgaG92ZXIgb3ZlcmxheSBlZmZlY3QgYW5kXG4gKiAgd2hlbiBpdHMgYWN0aXZhdGVkIHRoZXJlIGlzIGEgb3ZlcmxheSBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBjYXJkIHdpdGggSWNvbiBpbiB0aGUgbWlkZGxlLlxuICogIFBsZWFzZSBub3RlIHdoZW4gW2hhc0hvdmVyXSBpcyBUUlVFIGFsbCB0aGUgYWN0aW9ucyBhbmQgc2VsZWN0YWJpbGl0eSBhcmUgZGlzYWJsZWQgYXMgdGhlcmUgaXNcbiAqICBvbmx5IG9uZSBhY3Rpb24gd2hpY2ggY2xpY2sgb24gdGhlIGhvdmVyIG92ZXJsYXkuXG4gKlxuICpcbiAqICMjI2V4YW1wbGUgMTpcbiAqICBCYXNpYyBob3ZlciBjYXJkIHdoaWNoIGJ5IGRlZmF1bHQgc3VwcG9ydCBzZWxlY3RhYmxlIG1vZGVcbiAqXG4gKiBgYGBcbiAqICAgICAgICAgIDxhdy1jYXJkICNjYXJkMSBbaGFzQWN0aW9uXT1cImZhbHNlXCIgW3dpZHRoXT1cIicyMDJweCdcIiBbaGVpZ2h0XT1cIicxNTRweCdcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdGl0bGUgW2FsaWduXT1cIidib3R0b20tbGVmdCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhLXN1cHBsaWVyLXRhZ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdGl0bGU+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRvcD5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTmFtZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgSGFpZ2h0IFB1bXBzXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VwcGxpZXJMb2NhdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUGFsbyBBbHRvLCBDQSwgVVNBXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC10b3A+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLWJvdHRvbSBjbGFzcz1cInctY2FyZC16Ym90dG9tXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIHNvbWUgdGV4dCBhYm91dCB0aGUgc3VwcGxpZXIgYW5kIGhpcyBwYXJlbnRzPGJyLz5cbiAqICAgICAgICAgICAgICAgICAgICAgYW5kIHNvbWUgY29udGFjdHNcbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtYm90dG9tPlxuICpcbiAqICAgICAgICAgICAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIyMjZXhhbXBsZSAyOlxuICogICBIb3ZlciBjYXJkIHdpdGggY3VzdG9tIGFjdGlvbi4gd2hlbiB1bnNlbGVjdGVkIGFjdGlvbiB3aWxsIGFwcGVhciBhbmQgdXNlciBjYW4gY2xpY2sgb24gaXQuXG4gKlxuICogYGBgXG4gKiAgICAgICAgICA8YXctY2FyZCAjY2FyZDEgW3NlbGVjdGFibGVdPVwidHJ1ZVwiIFthY3Rpb25JY29uXT1cIidpY29uLXF1ZXN0aW9uLW1hcmsnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgKG9uQWN0aW9uKT1cIm9uQWN0aW9uKDMsICRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdGl0bGUgW2FsaWduXT1cIidib3R0b20tbGVmdCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhLXN1cHBsaWVyLXRhZ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdGl0bGU+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRvcD5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTmFtZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgSGFpZ2h0IFB1bXBzXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VwcGxpZXJMb2NhdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUGFsbyBBbHRvLCBDQSwgVVNBXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC10b3A+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLWJvdHRvbSBjbGFzcz1cInctY2FyZC16Ym90dG9tXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIHNvbWUgdGV4dCBhYm91dCB0aGUgc3VwcGxpZXIgYW5kIGhpcyBwYXJlbnRzPGJyLz5cbiAqICAgICAgICAgICAgICAgICAgICAgYW5kIHNvbWUgY29udGFjdHNcbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtYm90dG9tPlxuICpcbiAqICAgICAgICAgICAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jYXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vY2FyZC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vY2FyZC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIENhcmRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgd2Ugc2hvdWxkIGV4cGxpY2l0bHkgaGlkZSB0aGUgYWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhhc0FjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyBzZWxlY3RhYmxlIG1vZGUgc3VwcG9ydGVkPyBTYXlpbmcgWWVzLCBjYXJkIHdpbGwgaGF2ZSBieSBkZWZhdWx0IGNoZWNrLW1hcmsgaW4gdGhlXG4gICAgICogQUNUSU9OIHpvbmUgd2hlbiBzZWxlY3RlZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbiB0byBwYXNzIGN1c3RvbSBcIkNhcmQgU2VsZWN0ZWRcIiBJY29uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGVkSWNvbjogc3RyaW5nID0gJ2ljb24tYWNjZXB0JztcblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUgZm9yIGFjdGlvbiBpY29uLCB3aGVuIGFwcGxpY2F0aW9uIHdhbnQgdG8gYWRkIGFjdGlvbiB0byB0aGUgY2FyZFxuICAgICAqIGl0IG11c3QgYWxzbyBwcm92aWRlIGEgaWNvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhY3Rpb25JY29uOiBzdHJpbmc7XG5cbiAgICAvKlxuICAgICAqIEVuYWJsZSBhbmQgZGlzYWJsZXMgaG92ZXIgZWZmZWN0IG9uIHRvcCBvZiB0aGUgY2FyZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGFzSG92ZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVmYXVsdCBpY29uIG5hbWUgZm9yIHRoZSBob3ZlciBvdmVybGF5LiBUaGlzIGljb25zIHNob3dzIHVwIGluIHRoZSBtaWRkbGUgb3ZlciB0aGUgY2FyZFxuICAgICAqIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBjZW50ZXJlZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBob3Zlckljb246IHN0cmluZyA9ICdpY29uLWFkZCc7XG5cblxuICAgIC8qKlxuICAgICAqICBTZWxlY3Rpb24gc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjYXJkIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Q6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhY3Rpb24gaWNvbiBpcyBjbGlja2VkLlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25BY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIGhvdmVyIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkhvdmVyQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBxdWVyeSBpcyB1c2VkIHRvIHNhdmUgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIHRvIGJvdHRvbSBzZWN0aW9uIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoQ2FyZFpvbmVCb3R0b21Db21wb25lbnQpXG4gICAgYm90dG9tOiBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgY3VzdG9tIHRlbXBsYXRlIGZvciB0aGUgYm9keSB3aGljaCBpcyB1bmRlciBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgY29udHJvbC5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdib2R5JylcbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBWaWV3Q2hpbGQoJ2hvdmVyRGl2JylcbiAgICBob3ZlckRpdjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIFVzdWFsbHkgd2hlbiB0ZW1wbGF0ZSBpcyBwcm92aWRlZCB3ZSB3YW50IHRvIHVzZSBpdCBhbmQgcmVwbGFjZSBpbnRlcm5hbCBvbmUgYnV0IGluIHRoaXNcbiAgICAgKiBjYXNlIGl0IHdpbGwgYmUgYWx3YXlzIGNvbmRpdGlvbmFsIGFuZCBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgY2FuIHN3aXRjaCBiZXR3ZWVuIGRlZmF1bHRcbiAgICAgKiB0ZW1wbGF0ZSB3aXRoIHpvbmVzIGFuZCBjdXN0b20gb25lIHByb3ZpZGVkIGJ5IGRldmVsb3Blci5cbiAgICAgKlxuICAgICAqL1xuICAgIHVzZUJvZHlUZW1wbGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gc2V0cyBkZWZhdWx0IHZhbHVlXG4gICAgICAgIHRoaXMud2lkdGggPSAnMjAycHgnO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICcxNTRweCc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAvLyBJZiBhcHBsaWNhdGlvbiB3YW50cyB0byB1c2UgYWN0aW9uIGl0IG11c3QgcHJvdmlkZSBhY3Rpb25JY29uXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuYWN0aW9uSWNvbikgJiYgdGhpcy5oYXNBY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcHJvdmlkZSBhY3Rpb24gaWNvbicpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2hvd0JvdHRvbVNlY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJvdHRvbSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBmaXJlcyBzZWxlY3QgYW5kIHVuc2VsZWN0IGV2ZW50LlxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdChldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9ICF0aGlzLnNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy5vblNlbGVjdC5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPbmx5IGZpcmVkIHdoZW4gYWN0aW9uIGlzIHJlbmRlcmVkIGFuZCB1c2VyIGNsaWNrcyBvbiBjdXN0b20gYWN0aW9uSWNvblxuICAgICAqXG4gICAgICovXG4gICAgb25BY3Rpb25DbGljayhldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWN0aW9uICYmICghdGhpcy5zZWxlY3RlZCB8fCAhdGhpcy5zZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy5vbkFjdGlvbi5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkICB3aGVuIGhvdmVyIGVmZmVjdCBpcyBvbiArIHVzZXIgY2xpY2sgb24gdGhlIGNhcmRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSG92ZXIoaXNFbnRlcjogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ob3ZlckRpdikpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJEaXYubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gaXNFbnRlciA/IDAuNSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCByZW5kZXIgaW1wbGljaXQgY2FyZCB0ZW1wbGF0ZSB3aXRoIG91ciB6b25lcyBvclxuICAgICAqIHVzZXIgcHJvdmlkZWQgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dCb2R5VGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJvZHlUZW1wbGF0ZSkgICYmIHRoaXMudXNlQm9keVRlbXBsYXRlO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogTWFwcyBvdXIgaW50ZXJuYWwgYWxpZ25tZW50IHZhbHVlIHRvIHJlYWwgY3NzIHZhbHVlc1xuICpcbiAqL1xuY29uc3QgVkFsaWduTWFwID0ge1xuICAgICd0b3AtbGVmdCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAndG9wLWNlbnRlcic6ICdmbGV4LXN0YXJ0JyxcbiAgICAndG9wLXJpZ2h0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdjZW50ZXItbGVmdCc6ICdjZW50ZXInLFxuICAgICdjZW50ZXItY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2NlbnRlci1yaWdodCc6ICdjZW50ZXInLFxuICAgICdib3R0b20tbGVmdCc6ICdmbGV4LWVuZCcsXG4gICAgJ2JvdHRvbS1jZW50ZXInOiAnZmxleC1lbmQnLFxuICAgICdib3R0b20tcmlnaHQnOiAnZmxleC1lbmQnXG59O1xuXG5cbmNvbnN0IEhBbGlnbk1hcCA9IHtcbiAgICAndG9wLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAndG9wLXJpZ2h0JzogJ2ZsZXgtZW5kJyxcbiAgICAnY2VudGVyLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ2NlbnRlci1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAnY2VudGVyLXJpZ2h0JzogJ2ZsZXgtZW5kJyxcbiAgICAnYm90dG9tLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ2JvdHRvbS1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAnYm90dG9tLXJpZ2h0JzogJ2ZsZXgtZW5kJ1xufTtcblxuXG4vKipcbiAqIFRpdGxlIHpvbmUgcHJvdmlkZXMgYSBjb250ZW50IHBsYWNlaG9sZGVyIGZvciB0aGUgVGl0bGUgQXJlYS4gVGhpcyB6b25lIGlzIGFkZGluZyBhYmlsaXR5XG4gKiB0byBhbGlnbiBpdHMgY29udGVudCBpbnRvIDkgZGlmZmVyZW50IHBvc2l0aW9uLlxuICpcbiAqIFlvdSBjYW4gdXNlIHRoaXMgVGl0bGUgem9uZSB3aXRoaW4gPGF3LWNhcmQ+IGFzOlxuICpcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxhdy1jYXJkICBbd2lkdGhdPVwiJzIwMnB4J1wiIFtoZWlnaHRdPVwiJzE1NHB4J1wiIFtoYXNIb3Zlcl09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0YWJsZV09XCJmYWxzZVwiIFtoYXNBY3Rpb25dPVwiZmFsc2VcIlxuICogICAgICAgICAgICAgICAgICAob25Ib3ZlckFjdGlvbik9XCJvbkFjdGlvbig3LCAkZXZlbnQpXCIgPlxuICpcbiAqICAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdGl0bGUgW2FsaWduXT1cIidib3R0b20tbGVmdCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBQcmVmZXJyZWRcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgPC9hdy1jYXJkPlxuICpcbiAqIGBgYFxuICogRGVmYXVsdCBhbGlnbm1lbnQgaXMgdG9wLWxlZnRcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgYXctY2FyZC10aXRsZWAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXRpdGxlJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFpvbmVUaXRsZUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIHByb3BlcnR5IHdoaWNoIGlzIHVzZWQgdG8gYXBwbHkgZmxleCBwcm9wZXJ0aWVzIGZvciBhbGlnbmluZyBjb250ZW50IHZlcnRpY2FsbHlcbiAgICAgKiBhcyB3ZWxsIGFzIGhvcml6b250YWxseVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbjogQ2FyZFRpdGxlQWxpZ25tZW50ID0gJ3RvcC1sZWZ0JztcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBlbGVtOiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gVkFsaWduTWFwW3RoaXMuYWxpZ25dO1xuICAgICAgICB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IEhBbGlnbk1hcFt0aGlzLmFsaWduXTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBNYWtlIHN1cmUgd2UgZG9udCBhY2NlcHQgYW55IHVuc3VwcG9ydGVkIHZhbHVlcy4gVGhlc2UgdmFsdWVzIG1hcHMgdG8gdGhlIEhBbGlnbk1hcCBhbmRcbiAqIFZBbGlnbk1hcCBpbiBvcmRlciB0byBnZXQgcmVhbCBjc3MgdmFsdWUgZm9yIHRoZSBmbGV4IGFsaWdubWVudFxuICovXG5leHBvcnQgdHlwZSBDYXJkVGl0bGVBbGlnbm1lbnQgPSAndG9wLWxlZnQnIHwgJ3RvcC1jZW50ZXInIHwgJ3RvcC1yaWdodCcgfCAnY2VudGVyLWxlZnQnIHxcbiAgICAnY2VudGVyLWNlbnRlcicgIHwgJ2NlbnRlci1yaWdodCcgfCAnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1jZW50ZXInIHwgJ2JvdHRvbS1yaWdodCc7XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0NhcmRDb21wb25lbnQsIENhcmRab25lQm90dG9tQ29tcG9uZW50LCBDYXJkWm9uZVRvcENvbXBvbmVudH0gZnJvbSAnLi9jYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQge0NhcmRab25lVGl0bGVDb21wb25lbnR9IGZyb20gJy4vY2FyZC10aXRsZS9jYXJkLXRpdGxlLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENhcmRDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVGl0bGVDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVG9wQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2FyZENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVUaXRsZUNvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVUb3BDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lQm90dG9tQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2FyZE1vZHVsZVxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCb29sZWFuLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuXG4vKipcbiAqICBDaGVja2JveFR5cGUgZGVzY3JpYmVzIHdoYXQgdHlwZSBvZiBjaGVja2JveCBpcyB0aGlzOlxuICpcbiAqIC0gRm9ybSB0eXBlOiB0aGF0IGlzIHdyaXRpbmcgYW5kIHJlYWRpbmcgYSB2YWx1ZSBmcm9tL3RvIG1vZGVsIGJvdGggdXNpbmcgRm9ybUdyb3VwIGFzIHdlbGxcbiAqICAgICAgICAgICAgICBhcyBuZ01vZGVsXG4gKiAtIEFjdGlvbiB0eXBlOiAgb25seSBmaXJlcyBhY3Rpb24gYW5kIGRvZXMgbm90IHdyaXRlIHZhbHVlIHRvIG1vZGVsLlxuICpcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIENoZWNrYm94VHlwZSA9ICdmb3JtJyB8ICdhY3Rpb24nO1xuXG4vKipcbiAqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEhUTUwgY2hlY2tib3ggb24gdG9wIG9mIFByaW1lTkcuIFRoZXJlIGFyZSAyIHR5cGVzIG9mXG4gKiB7QGxpbmsgQ2hlY2tib3hDb21wb25lbnR9OiBmb3JtIGFuZCBhY3Rpb24gY2hlY2tib3ggYXMgZGVzY3JpYmVkIGFib3ZlLlxuICpcbiAqXG4gKiBVc2FnZTogQmFzaWMgZXhhbXBsZSBoYXZpbmcgcmVkIGNoZWNrYm94IGNoZWNrZWRcbiAqXG4gKiBgYGBIVE1MXG4gKiAgICAgICAgPGF3LWNoZWNrYm94IFtuYW1lXT1cIidjb2xvcidcIiBbdmFsdWVdPVwiJ3JlZCdcIiBbbGFiZWxdPVwiJ1JlZCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgIDwvYXctY2hlY2tib3g+XG4gKiAgICAgICAgPGF3LWNoZWNrYm94IFtuYW1lXT1cIidjb2xvcidcIiBbdmFsdWVdPVwiJ2JsdWUnXCIgW2xhYmVsXT1cIidCbHVlJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICA8L2F3LWNoZWNrYm94PlxuICpcbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKlxuICpcbiAqICAgY2xhc3MgQ0JCYXNpY1dpdGhOZ01vZGVsQ29tcG9uZW50XG4gKiAgIHtcbiAqXG4gKiAgICAgICBtb2RlbDogc3RyaW5nW10gPSBbJ3JlZCddO1xuICpcbiAqICAgICAgIGNvbnN0cnVjdG9yKClcbiAqICAgICAgIHtcbiAqICAgICAgIH1cbiAqICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzIHBsZWFzZSBzZWUgYSBwbGF5Z3JvdW5kIG9yIHVuaXQgdGVzdC5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBDQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hlY2tib3gnLFxuICAgIHRlbXBsYXRlVXJsOiAnY2hlY2tib3guY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydjaGVja2JveC5jb21wb25lbnQuc2NzcyddLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNoZWNrYm94XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBjaGVja2JveC4gRm9ybSBiYXNlZCB1cGRhdGVzIG1vZGVsIGFuZCBBY3Rpb24gYmFzZWQgb25seSBmaXJlcyBjbGljayBldmVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogQ2hlY2tib3hUeXBlID0gJ2Zvcm0nO1xuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgY2hlY2tib3hcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgY2xpY2sgZXZlbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogUHJpbWVORyBoYXMgdGhpcyB0eXBlIGNhbGxlZCBiaW5hcnkgd2hpY2ggd29ya3Mgb25seSB3aXRoIEJvb2xlYW4gbWVhbmluZyBpdCBkb2VzIG5vdCBhZGQgb3JcbiAgICAgKiByZW1vdmUgdmFsdWVzLlxuICAgICAqXG4gICAgICogSW4gb3VyIGNhc2UgQ2hlY2t0eXBlID0gQWN0aW9uIGlzIGFsd2F5cyBiaW5hcnkgb3Igd2hlbiB0aGlzLnZhbHVlIGlzIGJvb2xlYW5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzQmluYXJ5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbCBmb3IgY2hlY2tib3hcbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLmFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCA/ICdhY3Rpb24nIDogdGhpcy50eXBlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY29udHJvbCBmcm9tIHBhcmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB2YWx1ZSBpcyBib29sZWFuIHdlIGFyZSBkZWFsaW5nIHdpdGggUHJpbWVOZyBCaW5hcnkgY2hlY2tib3hcbiAgICAgICAgLy8gd2hpY2ggb25seSBzZXRzIFRSVUUvRkFMU0UgYW5kIGRvZXMgbm90IGFkZCBvciByZW1vdmUgdmFsdWVzXG4gICAgICAgIHRoaXMuaXNCaW5hcnkgPSBpc0Jvb2xlYW4odGhpcy52YWx1ZSk7XG5cbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ3ZhbHVlJ10pICYmXG4gICAgICAgICAgICAoY2hhbmdlc1sndmFsdWUnXS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXNbJ3ZhbHVlJ10ucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBjaGFuZ2VzWyd2YWx1ZSddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBDaGVja2JveCBpcyBjbGlja2VkIGFuZCBpdCBlaXRoZXIgZmlyZSBhY3Rpb24gb3IgdXBkYXRlcyB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb3JtVHlwZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGwgaWYgd2UgYXJlIHVzaW5nIEZvcm0gQ2hlY2tib3guIFRoaXMgaXMgdXNlZCByZW1vdmUgc29tZSBvZiB0aGUgYmluZGluZ3MgdGhhdCBhcmUgbm90XG4gICAgICogYXBwbGljYWJsZSBmb3IgY2VydGFpbiB0eXBlLlxuICAgICAqXG4gICAgICovXG4gICAgaXNGb3JtVHlwZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnZm9ybSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbCAmJiB0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2hlY2tib3hDb21wb25lbnR9IGZyb20gJy4vY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7Q2hlY2tib3hNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2hlY2tib3hDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGVcbiAgICBdLFxuXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NoZWNrQm94TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqICBDaGVja2JveCBsaXN0IGlzIGEgd3JhcHBlciBjbGFzcyBhcm91bmQgJ0NoZWNrYm94JyBjb21wb25lbnQgdG8gc2ltcGx5IGFzc2VtYmx5IG9mIG11bHRpIGNob2ljZVxuICogY29tcG9uZW50XG4gKlxuICogSW4gQWRkaXRpb24gaXQgYWRkcyBhYmlsaXR5IHRvIHdvcmsgd2l0aCBjb21wbGV4IG9iamVjdC4gUHJpbWVORyBjaGVja2JveGVzIHdvcmsgb25seSB3aXRoXG4gKiBwcmltaXRpdmUgdmFsdWVzLlxuICpcbiAqIEBzZWUge0BsaW5rIGNoZWNrLWJveC9jaGVjay1ib3guY29tcG9uZW50LnRzfVxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqXG4gKiAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgIHNlbGVjdG9yOiAnc2hvd0NoZWNrQm94TGlzdCcgLFxuICogICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICA8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJjaGVja0JveExpc3RWYWx1ZXNcIiBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKlxuICogICAgICAgICAgICBbbmFtZV09XCInbXlDb2xvcnMnXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiAob25TZWxlY3Rpb24pPVwib25DQkNsaWNrXCI+XG4gKiAgICAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICogICAgICAgYFxuICpcbiAqICAgICAgIH0pXG4gKiAgICAgICAgY2xhc3MgTXlTaG93Q0xDb21wb25lbnRcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIGNoZWNrQm94TGlzdFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ3JlZCcgLCAneWVsbG93JyAsICdvcmFuZ2UnICwgJ3doaXRlJyAsXG4gKiAgICAgJ3NpbHZlcicgLCAnYmxhY2snICxcbiAqICAgICAgICAgICAgJ0dyZWVuJyAsICdHcmF5JyAsICdOYXZ5JyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKlxuICogICAgICAgICAgICBzZWxlY3RlZFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqXG4gKlxuICogICAgICAgICAgICBmb3JtR3JvdXA6IEZvcm1Hcm91cCA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICpcbiAqXG4gKiAgICAgICAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNCQ2xpY2sgPSAnICsgZXZlbnQpO1xuICogICAgICAgICAgICB9XG4gKlxuICogICAgICAgIH1cbiAqKlxuICovXG5cblxuXG5cbmV4cG9ydCBjb25zdCBDQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja0JveExpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hlY2tib3gtbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICdjaGVjay1ib3gtbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2NoZWNrLWJveC1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0JfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrQm94TGlzdENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja0JveExpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHZhbHVlcyB1c2VkIHRvIHJlbmRlciBjaGVja2JveGVzLiBFdmVuIHdlIGhhdmUgaGVyZSB0eXBlIGFzIEFOWSB3ZSBpbnRlcm5hbGx5XG4gICAgICogc3VwcG9ydCBvbmx5IHN0cmluZyBhdCB0aGUgbW9tZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogIFNlbGVjdGlvbnMgYXJlIGRlZmF1bHQgQ0hFQ0tFRCB2YWx1ZXMgcGFzc2VkLiBlLmcuIFdoZW4gcmVuZGVyaW5nIGZpZWxkIGZhdm9yaXRlIGNvbG9yczpcbiAgICAgKiBibHVlLCByZWQsIHllbGxvdyB5b3Ugd2lsbCBwYXNzIGluIGhlcmUgYmx1ZSwgcmVkLCB0aGVuIGNoZWNrYm94ZXMgd2l0aCB2YWx1ZSBibHVlLCByZWQgd2lsXG4gICAgICogYmUgcmVuZGVyZWQgYXMgY2hlY2sgYW5kIHllbGxvdyB1bmNoZWNrZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbnM6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgZXZlbnQgd2hlbiBjaGVja2JveCBpcyBzZWxlY3RlZC9jbGlja2VkLiBFbWl0cyBjdXJyZW50IGNsaWNrZWQgY2hlY2tib3hlZC4gbm90IHRoZVxuICAgICAqIGFjdHVhbGwgaW50ZXJuYWwgbW9kZWwgdmFsdWUgaW4gdGhpcyBjYXNlIGFycmF5IG9mIGNob2ljZXNcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogc3BlY2lhbCBleHByZXNzaW9uIHRvIGZvcm1hdCBsYWJlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxGb3JtYXR0ZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsXG4gICAgICovXG4gICAgbW9kZWw6IGFueSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb25zKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuc2VsZWN0aW9ucyk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5zZWxlY3Rpb25zKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnlbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMubW9kZWwuZm9yRWFjaCgoaW5kZXg6IG51bWJlcikgPT4gdXBkYXRlZE1vZGVsLnB1c2godGhpcy5saXN0W2luZGV4XSkpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIGlzIGV4dHJhY3RlZCBpbnRvIHRoaXMgbWV0aG9kIHNvIGluIHRoZSBmdXR1cmUgd2UgY2FuIHBsYXkgbW9yZSBob3cgd2Ugd2FudCB0byBkaXNwbGF5XG4gICAgICogdGhlIHZhbHVlLiBTaW5jZSBJIHdhbnQgdG8gc3VwcG9ydCBmb3JtYXR0ZXJzIGZvciBlYWNoIGNvbXBvbmVudHMgd2UgbWlnaHQgaGF2ZSBhIGNoYW5jZSB0b1xuICAgICAqIGRlY2lkZSBob3cgbGFiZWwgd2lsbCBsb29rIGxpa2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBsYWJlbFZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxhYmVsRm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3JtYXR0ZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgdmVyc2lvbiBvZiBjaGVja2JveGVzIHdlIHN0aWxsIGV4cGVjdCBvbmx5IHByaW1pdGl2ZSB0eXBlcy4gS2VlcCB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBpbiBleHRyYSBtZXRob2Qgc28gd2UgY2FuIHdvcmsgd2l0aCBpdCBldmVuIG5vdyB3ZSBqdXN0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrXG4gICAgICovXG4gICAgdmFsdWUoaXRlbTogYW55KTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBldmVudCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50IGFuZCBjb252ZXJ0IGluZGV4ZWQgbW9kZWwgdG8gb3JpZ2luYWwgb2JqZWN0c1xuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueVtdID0gW107XG5cbiAgICAgICAgdGhpcy5tb2RlbC5mb3JFYWNoKChpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVkTW9kZWwucHVzaCh0aGlzLmxpc3RbaW5kZXhdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggY29tcGxleCBvYmplY3Qgc3RvcmUgb25seSBJTkRFWGVzIG51bWJlciBpbiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbChzb3VyY2VMaXN0OiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNvdXJjZUxpc3QuZm9yRWFjaCgoaXRlbTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxpc3QuZmluZEluZGV4KChlbGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyhpdGVtLCBlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wdXNoKGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vZGVsKSAmJiBpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgbmV3TW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWwobmV3TW9kZWwpO1xuXG4gICAgICAgICAgICAvLyB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaGVja0JveExpc3RDb21wb25lbnR9IGZyb20gJy4uL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENoZWNrQm94TGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlXG4gICAgXSxcblxuXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDaGVja0JveExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaGVja0JveExpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIEh5cGVybGluayBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuIEh5cGVybGluayBzdXBwb3J0cyBhbGwgb2YgdGhlXG4gKiBuYXRpdmUgbGluayBmdW5jdGlvbmFsaXR5LiBJbiBhZGRpdGlvbiwgaXQgc3VwcG9ydHMgbmF2aWdhdGlvbiB0byBjb21wb25lbnRzIHRocm91Z2ggdGhlIGFjdGlvblxuICogYmluZGluZy5cbiAqXG4gKlxuICogZm9yIG1vcmUgaW5mbyBwbGVhc2Ugc2VlIGNsYXNzIERvYyBvZiB0aGU6XG4gKiAgQHNlZSB7QGxpbmsgYnV0dG9uL2J1dHRvbi5jb21wb25lbnQudHN9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgICAgIDxhdy1oeXBlcmxpbmsgIFt0eXBlXT1cIid0ZXh0L2h0bWwnXCIgW25hbWVdPVwiJ2xpbmsnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNsaWNrZWQoJGV2ZW50KVwiIFt2YWx1ZV09XCJjdXN0b21lcklkXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3NpemVdPVwiJ2xhcmdlJ1wiID5teSBsaW5rPC9hdy1oeXBlcmxpbms+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGNvbW1hbmQ6Ym9vbGVhbjtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgICBvbkNsaWNrZWQoY3VzdG9tZXJJZDpzdHJpbmcpIHtcbiAqICAgICAgICAgICBpZiAoY3VzdG9tZXJJZCkge1xuICogICAgICAgICAgICAgIC8vIGRpc3BsYXkgY3VzdG9tZXIgZGV0YWlscyBjb21wb25lbnQuXG4gKiAgICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1oeXBlcmxpbmsnLFxuICAgIHRlbXBsYXRlVXJsOiAnaHlwZXJsaW5rLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnaHlwZXJsaW5rLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgSHlwZXJsaW5rQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogICAgU3BlY2lmaWVzIHRoZSBtZWRpYSB0eXBlIG9mIHRoZSBsaW5rZWQgZG9jdW1lbnQuIE1pbWUgdHlwZVxuICAgICAqICAgIGV4OiBbdGV4dC9odG1sIHwgdGV4dC9jc3YgfCBpbWFnZS9wbmcgfCBhdWRpby8zZ3BwIHwgLi4uLl1cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIHVybCBmb3IgdGhpcyBoeXBlcmxpbmsuIENhbiBiZSB1c2VkIHRvIG5hdmlnYXRlIHRvIGEgY29tcG9uZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaHJlZjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogcmVsIGZvciB0aGlzIGh5cGVybGluay4gU3BlY2lmeSB0aGUgcmVsYXRpb25zaGlwIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50IGFuZCBsaW5rZWQgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBzaXppbmcgZm9yIHRoaXMgbGluay4gW2xhcmdlLCBub3JtYWwsIHNtYWxsXS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNpemU6IExpbmtTaXplID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSB0YXJnZXQgb2YgdGhlIGh5cGVybGluay4gW19ibGFuayB8IF9zZWxmIHwgX3BhcmVudCB8IF90b3AgfCBmcmFtZW5hbWUgXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFyZ2V0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byBiZSBzZW5kIHRvIHNlcnZlciB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgQ1NTIGNsYXNzIHRoYXQgc3R5bGVzIHRoaXMgaHlwZXJsaW5rIGJhc2VkIG9uIGlucHV0ICdzaXplJ1xuICAgICAqL1xuICAgIGxpbmtDbGFzczogc3RyaW5nID0gJ2xpbmsnO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGxpbmsgY2xhc3MgYmFzZWQgb24gaW5wdXQgc2l6ZS5cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsYXJnZScgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstbGcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLW1pZCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1zbSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgSSBoYXZlIGFuIGFjdGlvbiB0YWcsIGFuZCBubyBocmVmLiBXZSBhZGQgZGVmYXVsdCBzdHlsaW5nIGFuZCBiZWhhdmlvci5cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstYmgnO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQWN0aW9uIGNsaWNrZWQuIENhbGwgcGFyZW50IGFjdGlvbi5cbiAgICAgKi9cbiAgICBjbGlja2VkKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdXBwb3J0ZWQgTGluayBTaXplXG4gKi9cbmV4cG9ydCB0eXBlIExpbmtTaXplID0gJ2xhcmdlJyB8ICdub3JtYWwnIHwgJ3NtYWxsJztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SHlwZXJsaW5rQ29tcG9uZW50fSBmcm9tICcuL2h5cGVybGluay5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEh5cGVybGlua0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBIeXBlcmxpbmtDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSHlwZXJsaW5rQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSHlwZXJsaW5rTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge3VuaW1wbGVtZW50ZWR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU2VsZWN0aW9uIFN0YXRlIGZvciB0aGUgY2hvb3NlciBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGNvbXVuaWNhdGUgd2l0aCB0aGUgcGFyZW50IG9iamVjdCB1c2luZyBhXG4gKiBjaG9vc2VyLiBJZiBJIHdvdWxkIGhhdmUgdG8gbWFuYWdlIG9ubHkgc2luZ2xlIHZhbHVlcyB3aXRoIG5vIGFkZGlvbmFsIG1ldGhvZHMgaSB3b3VsZCB1c2VyXG4gKiBlbWl0dGVycyB0byBkbyB0aGUgam9iLCBidXQgaW4gdGhpcyBjYXNlIHdlIG5lZWQgdGhpcyBpbnRlcmZhY2UgKGFic3RyYWN0IGNsYXNzKSBiZXR3ZWVuIGFcbiAqIGNob29zZXIgYW5kIGFjdHVhbCBvYmplY3QuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob29zZXJTZWxlY3Rpb25TdGF0ZVxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0IHNlbGVjdGlvbiBzdGF0ZSBpcyB1c3VhbGx5IHRyaWdnZXJlZCBieSBzZWxlY3RpbmcgYW5kIHVuc2VsZWN0aW5nIGEgaXRlbSAoaW4gY2FzZSBvZlxuICAgICAqIG11bHRpc2VsZWN0KSBhbmQgaXQgc2hvdWxkIHVwZGF0ZSBpdHMgbGlzdCBvZiBvYmplY3RzIHdpdGggZWl0aGVyIHNldHRpbmdzL2FkZGluZyBpdGVtIG9yXG4gICAgICogcmVtb3ZpbmcgaXQuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiAuIE51bGwgaWYgbGFzdCBhY3Rpb24gd2FzIGEgZGVzZWxlY3Rpb24uIFVzdWFsbHkgdXNlZCBieSBDaG9vc2VyXG4gICAgICogb3IgQ2hvb3NlclN0YXRlIHRvIGdldCBjdXVyZW50IHZhbHVlLlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdGhlIGl0ZW0gc2VsZWN0aW9uIGl0ZW1zIGlzIGluIHRoZSBzZWxlY3RlZE9iamVjdHNcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q2hvb3NlclNlbGVjdGlvblN0YXRlfSBmcm9tICcuL2Nob29zZXItc2VsZWN0aW9uLXN0YXRlJztcbmltcG9ydCB7RGF0YVNvdXJjZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcblxuLyoqXG4gKiBDaG9vc2VyU3RhdGUgbWFuYWdlcyBjb21wbGV0ZSBsaWZlY3ljbGUgZm9yIHRoZSBDaG9vc2VyIENvbXBvbmVudC4gSXQga2VlcHMgdHJhY2sgb2YgY3VycmVudFxuICogc2VsZWN0aW9uIGFzIHdlbGwgYXMgaXQgY2FuIGJyb2FkY2FzdCBhbnkgdXBkYXRlcy5cbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hvb3NlclN0YXRlXG57XG5cbiAgICAvKipcbiAgICAgKiAgQ2FsbGJhY2sgdG8gdGhlIHBhcmVudCBvYmplY3QgdG8gc3RvcmUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25TdGF0ZTogQ2hvb3NlclNlbGVjdGlvblN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogdG9kbzogV2UgZG8gbm90IG5lZWRlZCB0aGlzICEhXG4gICAgICovXG4gICAgY3VycmVudEl0ZW06IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogTWF0Y2hpbmcgcGF0dGVybi4gVXNlciBsYXRlc3QgaW5wdXQgdG8gdGhlIGNob29zZXIgaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBwYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIExhc3Qgc3VjY2Vzc2Z1bGwgcGF0dGVybiB0aGF0IHJldHJpZXZlZCBzb21lIGRhdGFcbiAgICAgKi9cbiAgICBsYXN0RnVsbE1hdGNoUGF0dGVybjogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IG1hdGNoZWQgaXRlbXMgdXNpbmcgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG4gICAgICovXG4gICAgbWF0Y2hlczogQXJyYXk8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBtdWx0aXNlbGVjdCBjaG9vc2VyXG4gICAgICovXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW1wbGVtZW50YXRpb24gY2FuIHNldCBsb29rdXAga2V5IHRvIG5hcnJvdyB0aGUgc2VhcmNoLiBJZiB3ZSBhcmUgZGVhbGluZyB3aXRoIG9iamVjdFxuICAgICAqIHlvdSBzaG91bGQgc2V0IHRoaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBLZXk6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogcHJldmlvdXMgZGlzcGxheSB2YWx1ZSBpcyBzZXQgd2hlbiB0aGUgZGlzcGxheSB2YWx1ZSBpcyByZW5kZXJlZCBvbiB0aGUgY2hvb3Nlci4gd2UgY2FjaGVcbiAgICAgKiB0aGUgVUkgdmFsdWUgdG8gY29tcGFyZSB3aXRoIHRoZSBpbmJvdW5kIHZhbHVlIGxhdGVyIGluc3RlYWQgb2YgdGhlIHZhbHVlIGZyb20gdW5kZXJseWluZ1xuICAgICAqIG9iamVjdCBiZWNhdXNlIGJ1c2luZXNzIGxvZ2ljIGxldmVsIGNvZGUgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSB1bmRlcmx5aW5nIG9iamVjdCdzIHZhbHVlXG4gICAgICpcbiAgICAgKiB0b2RvOiBkbyBJIHN0aWxsIG5lZWQgdGhpcz9cbiAgICAgKi9cbiAgICBwcmV2RGlzcGxheVZhbHVlOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGVyZSBhcmUgYW55IHZhbGlkYXRpb24gbGlrZSBlbnRlcmVkIHZhbHVlIGRvZXMgbm90IG11Y2ggd2l0aCB0aGUgc291cmNlIGxpc3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0ludmFsaWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogaW5kaWNhdGVzIHRoYXQgd2Ugc3RhcnRlZCB0byBzb21lIGVkaXRpbmcgZS5nLiBzdGFydGluZyB0byB0eXBlIGluIHNvbWV0aGluZyBpbnRvIHRoZVxuICAgICAqIGZpbHRlciwgb3IgcmVtb3ZpbmcgYWxyZWFkeSBzZWxlY3RlZCBpdGVtc1xuICAgICAqL1xuICAgIGFkZE1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgcmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQ6IG51bWJlciA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBvcHRpb24gaXMgYWN0aXZlIHdlIGRvIG5vdCBzaG93IGFsbCBzZWxlY3RlZCBpdGVtcywgYnV0IG1heCBudW1iZXIgdGhhdCBpc1xuICAgICAqIGRlZmluZWQuIFVzZXIgaXMgYWJsZSB0byB0b2dnbGUgdG8gZXhwYW5kIHRoZSB2aWV3IHRvIHNlZSBhbGwgc2VsZWN0aW9ucyBhbmQgaGlkZSB0aGVtIGFzXG4gICAgICogd2VsbFxuICAgICAqL1xuICAgIHNob3dBbGxSZWNlbnRseVNlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKGNob29zZXJTZWxlY3Rpb25TdGF0ZT86IENob29zZXJTZWxlY3Rpb25TdGF0ZSwgaXNNdWx0aTogYm9vbGVhbiA9IHRydWUpXG4gICAge1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGUgPSBjaG9vc2VyU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMubXVsdGlzZWxlY3QgPSBpc011bHRpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gbmV3IERlZmF1bHRTZWxlY3Rpb25TdGF0ZSh0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJdCB3aWxsIHNlbGVjdCBhbmQgcGVyc2lzdCBhbiBpdGVtIHVzaW5nIENob29zZXJTZWxlY3Rpb25TdGF0ZSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKGl0ZW0sIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0ID0gdGhpcy5zZWxlY3RlZE9iamVjdCgpO1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0cyA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzKCk7XG5cblxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkTW9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHNlbGVjdGVkT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3RlZE9iamVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShpdGVtLCAhTGlzdFdyYXBwZXIuY29udGFpbnNDb21wbGV4KHNlbGVjdGVkT2JqZWN0cywgaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHNlbGVjdGVkT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGVkT2JqZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNlciBzZWxlY3Rpb24gaXMgbGFyZ2Ugd2UgdXNlIHRoaXMgbWV0aG9kIHRvIGNoZWNrIGlmIHdlIG5lZWQgdG8gc2hvdyBhbGwgc2VsZWN0ZWRcbiAgICAgKiBpdGVtcyBvciBvbmx5IE1heFJlY2VudFNlbGVjdGVkXG4gICAgICovXG4gICAgdG9nZ2xlQWxsU2VsZWN0ZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCA9ICF0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZW5kZXJzIHVzZXIncyBzZWxlY3Rpb24gdW5kZXIgdGhlIGlucHV0IGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgcmVjZW50U2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5IDxhbnk+XG4gICAge1xuXG4gICAgICAgIGlmICghdGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlY2VudFNlbGVjdGVkT2JqZWN0czogYW55W10gPSBbXTtcbiAgICAgICAgdGhpcy5yZWNlbnRTZWxlY3RlZERpc3BsYXllZCA9IDA7XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICBsZXQgc2l6ZSA9IHNlbGVjdGVkT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXhDb3VudCA9IERhdGFTb3VyY2UuTWF4UmVjZW50U2VsZWN0ZWQ7XG4gICAgICAgIGlmIChzaXplID4gRGF0YVNvdXJjZS5NYXhSZWNlbnRTZWxlY3RlZCAmJiAhdGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgbWF4Q291bnQgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgbWF4Q291bnQgPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHNpemUgLSAxOyBpID49IDAgJiYgKHRoaXMucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQgPCBtYXhDb3VudCk7IGktLSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHNlbGVjdGVkT2JqZWN0c1tpXTtcbiAgICAgICAgICAgIHJlY2VudFNlbGVjdGVkT2JqZWN0cy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjZW50U2VsZWN0ZWRPYmplY3RzO1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhdGUuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICB9XG5cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHNlbGVjdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlLnNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbiwgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBEdW1teSBpbXBsZW1lbnRhdGlvbiBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRTZWxlY3Rpb25TdGF0ZSBleHRlbmRzIENob29zZXJTZWxlY3Rpb25TdGF0ZVxue1xuICAgIHByaXZhdGUgX3NlbGVjdGVkT2JqZWN0OiBhbnk7XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRPYmplY3RzOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbXVsdGlTZWxlY3Q6IGJvb2xlYW4pXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRPYmplY3QgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdCAmJiAhTGlzdFdyYXBwZXIuY29udGFpbnNDb21wbGV4KHRoaXMuc2VsZWN0ZWRPYmplY3RzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkT2JqZWN0cygpLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlSWZFeGlzdCh0aGlzLnNlbGVjdGVkT2JqZWN0cygpLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRPYmplY3Q7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX3NlbGVjdGVkT2JqZWN0cykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT2JqZWN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZE9iamVjdHM7XG4gICAgfVxuXG4gICAgaXNTZWxlY3RlZChzZWxlY3Rpb246IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBzdXBlci5pc1NlbGVjdGVkKHNlbGVjdGlvbik7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFTb3VyY2UsIERTSW5pdFBhcmFtc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgRGF0YUZpbmRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0Nob29zZXJTdGF0ZX0gZnJvbSAnLi9jaG9vc2VyLXN0YXRlJztcbmltcG9ydCB7YXNzZXJ0LCBpc0FycmF5LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBDb25jcmV0ZSBEYXRhU291cmNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQ2hvb3NlciBjb21wb25lbnQuIFRoZXJlIGFyZSB0d28gd2F5cyBob3cgdG8gdXNlIGl0OlxuICpcbiAqIDEpIFlvdSBjYW4gdXNlIGRlZmF1bHQgRGF0YVNvdXJjZSBpbmplY3RlZCBpbnNpZGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGFuZCBqdXN0IGNhbGxcbiAqIGluaXRpYWxpemUgdG8gY29uZmlndXJlIGl0IHdpdGggY29ycmVjdCBEYXRhUHJvdmlkZXIgYW5kIERhdGFGaW5kZXI6XG4gKlxuICpcbiAqIGBgYFxuICogICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gKiAgICAgICAgICAgICAgIG9iajogdGhpcy5saXN0LFxuICogICAgICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAqICAgICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gKiAgICAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gKiAgICAgICAgICAgfSk7XG4gKlxuICogYGBgXG4gKlxuICogYW5kIHRoZW4geW91IGNhbiB1c2UgaXQgdG8gc2ltcGx5IHJldHJpZXZlIGRhdGEgb3IgcnVuIHF1ZXJpZXMuXG4gKlxuICogMikgWW91IHdpbGwgaW5zdGFudGlhdGUgeW91ciBvd24gRGF0YVNvdXJjZSBhbmQgcGFzcyBpdCBpbnRvIHRoZSBjb21wb25lbnQgdXNpbmcgW2RhdGFTb3VyY2VdXG4gKiBiaW5kaW5nXG4gKlxuICogYGBgXG4gKlxuICogICB0aGlzLmRzID0gbmV3IENob29zZXJEYXRhU291cmNlKHRoaXMuZGF0YSwgdGhpcy5maW5kZXJzKTtcbiAqICAgdGhpcy5kcy5pbml0KHtcbiAqICAgICAgICAgICAgICAgb2JqOiB0aGlzLmxpc3QsXG4gKiAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICogICAgICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAqICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAqICAgICAgICAgICB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hvb3NlckRhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlXG57XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGluZyBkYXRhUHJvdmlkZXJzIGFuZCBmaW5kZXJzXG4gICAgICovXG4gICAgcHJpdmF0ZSBkYXRhUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuICAgIHByaXZhdGUgZGF0YUZpbmRlcjogRGF0YUZpbmRlcjtcblxuXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBvYmplY3QgdG8ga2VlcCBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY2hvb3NlclxuICAgICAqL1xuICAgIHN0YXRlOiBDaG9vc2VyU3RhdGU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRhUHJvdmlkZXJzOiBEYXRhUHJvdmlkZXJzLCBwdWJsaWMgZmluZGVyczogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgICAgICBzdXBlcihkYXRhUHJvdmlkZXJzLCBmaW5kZXJzKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRvIGluaXRpYWxpemUgdGhpcyBEYXRhU291cmNlIHdpdGggY3VycmVudCBEYXRhRmluZGVyIGFuZCBQcm92aWRlciBhcyB3ZWxsIGFzIHN0YXRlIHdlIHVzZVxuICAgICAqIGFuIGludGVyZmFjZSBEU0Nob29zZXJJbml0UGFyYW1zIHRvIGhhdmUgYWxsIGluaXQgdmFsdWVzIHR5cGVkIGNoZWNrZWRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCguLi5hcmdzOiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGFyZ3MpIHx8IGFyZ3MubGVuZ3RoICE9PSAxICYmICFpc0RTQ2hvb3NlckluaXRQYXJhbXMoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBEUyB3aXRoIChEU0Nob29zZXJJbml0UGFyYW1zKScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbml0OiBEU0Nob29zZXJJbml0UGFyYW1zID0gYXJnc1swXTtcblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IGlzUHJlc2VudChpbml0LmRhdGFQcm92aWRlcikgPyBpbml0LmRhdGFQcm92aWRlclxuICAgICAgICAgICAgOiB0aGlzLmRhdGFQcm92aWRlcnMuZmluZChpbml0Lm9iaik7XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YUZpbmRlcikgPyBpbml0LmRhdGFGaW5kZXJcbiAgICAgICAgICAgIDogdGhpcy5maW5kZXJzLmZpbmQodGhpcy5kYXRhUHJvdmlkZXIsIGluaXQucXVlcnlUeXBlKTtcblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuZGF0YVByb3ZpZGVyKSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhRmluZGVyKSxcbiAgICAgICAgICAgICdEYXRhU291cmNlIGluY29ycmVjdGx5IGluaXRpYWxpemVkLiAoRGF0YVByb3ZpZGVyLCBEYXRhRmluZGVyKSBtaXNzaW5nLiAnKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGluaXQuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gaW5pdC5zdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgQ2hvb3NlclN0YXRlKG51bGwsIGluaXQubXVsdGlzZWxlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IGluaXQubG9va3VwS2V5O1xuICAgICAgICB0aGlzLnN0YXRlLmxvb2t1cEtleSA9IGluaXQubG9va3VwS2V5O1xuICAgIH1cblxuXG4gICAgZmluZChwYXR0ZXJuOiBzdHJpbmcsIG1heDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5sYXN0RnVsbE1hdGNoUGF0dGVybiA9IHBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqJykgeyAvLyBxdWVyeSBldmVyeXRoaW5nXG4gICAgICAgICAgICBwYXR0ZXJuID0gJyc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkYXRhRmluZGVyIGhhcyBleHBlY3RlZCBsb29rdXAga2V5XG4gICAgICAgIGxldCBvcmlnS2V5ID0gdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleTtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IHRoaXMuc3RhdGUubG9va3VwS2V5O1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIuZm9yRGF0YSh0aGlzLmRhdGFQcm92aWRlcikubWF0Y2g8YW55PihwYXR0ZXJuLCBtYXgpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChyZXN1bHQ6IGFueVtdKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubWF0Y2hlcyA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlSWZFeGlzdCh0aGlzLnN0YXRlLm1hdGNoZXMsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IG9yaWdLZXk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gbXVsdGlzZWxlY3QgdGhpcyBtZXRob2QgY2hlY2tzIGlmIHdlIG5lZWQgdG8gc2hvdyBTSE9XIE1PUkUgbGFiZWwgdW5kZXIgdGhlIHNlbGVjdGVkXG4gICAgICogaXRlbXMuIFdlIGRvIG5vdCB3YW50IHNob3cgZS5nLiA1MCBzZWxlY3Rpb24gdW5kZXIgdGhlIGNob29zZXIgdGhhdCB3b3VsZCB0YWtlIHVwIHdob2xlXG4gICAgICogcGFnZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dNb3JlU2VsZWN0ZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoID49IERhdGFTb3VyY2UuTWF4UmVjZW50U2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgb3BlbjxUPigpOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGluc3RhbnQ8VD4oKTogVFtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBpdGVtczogYW55W10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHRoaXMuc3RhdGUudXBkYXRlZFNlbGVjdGVkT2JqZWN0cyhpdGVtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuYWRkTW9kZSA9IGZhbHNlO1xuXG4gICAgfVxuXG5cbiAgICBnZXQgbG9va3VwS2V5KCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXk7XG4gICAgfVxufVxuXG4vKiBpcyBcImluaXRcIiB0eXBlIG9mIERTQ2hvb3NlckluaXRQYXJhbXMgaW50ZXJmYWNlID8gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RTQ2hvb3NlckluaXRQYXJhbXMoaW5pdDogRFNDaG9vc2VySW5pdFBhcmFtcyk6IGluaXQgaXMgRFNDaG9vc2VySW5pdFBhcmFtc1xue1xuICAgIHJldHVybiBpc1ByZXNlbnQoaW5pdC5vYmopIHx8IGlzUHJlc2VudChpbml0LnF1ZXJ5VHlwZSk7XG59XG5cbi8qKlxuICogVG8gbWFrZSBpbml0aWFsaXphdGlvbiBlYXNpZXIgd2UgaGF2ZSB0aGlzIGNvbW1vbiBmb3JtYXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRFNDaG9vc2VySW5pdFBhcmFtcyBleHRlbmRzIERTSW5pdFBhcmFtc1xue1xuICAgIC8qKlxuICAgICAqIENob29zZXIgc3RhdGUga2VlcGluZyBpbmZvcm1hdGlvbiB3aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZCAsIHJlc3VsdCBvZiB0aGUgbGFzdCBtYXRjaFxuICAgICAqL1xuICAgIHN0YXRlPzogQ2hvb3NlclN0YXRlO1xufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBdXRvQ29tcGxldGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtEQVRBX1NPVVJDRX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7Q2hvb3NlckRhdGFTb3VyY2V9IGZyb20gJy4vY2hvb3Nlci1kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGUsIERlZmF1bHRTZWxlY3Rpb25TdGF0ZX0gZnJvbSAnLi9jaG9vc2VyLXN0YXRlJztcblxuXG4vKipcbiAqIFR5cGVhaGVhZCBjaG9vc2VyIHRoYXQgc3VwcG9ydHMgYm90aCBzaW5nbGUgYW5kIG11bHRpLXNlbGVjdC4gTm90IGxpa2UgRHJvcGRvd24sIHRoaXMgY2hvb3NlclxuICogcmVxdWlyZXMgbGl0dGxlIGJpdCBkaWZmZXJlbnQgc2V0dXAuIEl0IHJlcXVpcmVzIGF0IG1pbmltdW0gQElucHV0IGRhdGFTb3VyY2Ugb3JcbiAqIGRlc3RpbmF0aW9uQ2xhc3NcbiAqXG4gKlxuICogQnkgZGVmYXVsdCBjaG9vc2VyIGlzIG11bHRpLXNlbGVjdC4gSWYgeW91IHdhbnQgc2luZ2xlIHNlbGVjdCB0aGVuIHlvdSBtdXN0IHByb3ZpZGUgbXVsdGktc2VsZWN0XG4gKiB3aXRoIEBJbnB1dC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIEluIHNpbXBsZSBzY2VuYXJpbyB5b3UgY2FuIHVzZSBDaG9vc2VyIGxpa2Ugc286XG4gKlxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ2Nob29zZXItYXBwJyAsXG4gKiAgICAgIHRlbXBsYXRlOiBgPGF3LWNob29zZXIgIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgbmFtZT1cImNvbG9yXCInXG4gKiAgICAgICAgICAgICAgICAgICAgICBbZGF0YVNvdXJjZV09XCJkc1wiPjwvYXctY2hvb3Nlcj5gXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgTXlDaG9vc2VyQXBwXG4gKiAge1xuICpcbiAqICAgICAgZHM6IENob29zZXJEYXRhU291cmNlO1xuICpcbiAqICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGE6IERhdGFQcm92aWRlcnMsIHByaXZhdGUgZmluZGVyczogRGF0YUZpbmRlcnMpe1xuICogICAgICAgICAgdGhpcy5kcyA9IG5ldyBDaG9vc2VyRGF0YVNvdXJjZSh0aGlzLmRhdGEsIHRoaXMuZmluZGVycyk7XG4gKlxuICogICAgICAgdGhpcy5kcy5pbml0KHtcbiAqICAgICAgICAgICBvYmo6IFsnYmx1ZScsICdyZWQnLCAneWVsbG93J10sIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LCBzdGF0ZTogbnVsbCxcbiAqICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRydWVcbiAqICAgICAgIH0pO1xuICpcbiAqICAgICB9XG4gKiAgfVxuICpcbiAqIGBgYGBcbiAqICBBYm92ZSBleGFtcGxlIHdpbGwgdXNlIHByb3ZpZGVkIGRhdGFTb3VyY2UgYW5kIHJlbmRlciBtdWx0aS1zZWxlY3QgY2hvb3Nlci4gV2l0aCBkZWZhdWx0XG4gKiAgaW1wbGVtZW50YXRpb24gIHNlbGVjdGVkIHZhbHVlcyB3aWxsIGFwcGVhciBhcyBhIHRhZ3MgdW5kZXIgdGhlIGlucHV0IGJveFxuICpcbiAqXG4gKlxuICogKiAjIyMgRXhhbXBsZVxuICpcbiAqICBJbiB0aGlzIGV4YW1wbGUgd2UgcHJvdmlkZSBjdXN0b20gdGVtcGxhdGUgdG8gY2hhbmdlIHRoZSB3YXkgaG93IGNob29zZXIncyBNZW51SXRlbSBhcmVcbiAqICAgICByZW5kZXJlZCBhcyB3ZWxsIGFzIHRlbXBsYXRlIGZvciB0aGUgc2VsZWN0aW9uIGl0ZW0gbG9va3MgbGlrZVxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ2Nob29zZXItYXBwJyAsXG4gKiAgICAgIHRlbXBsYXRlOiBgPGF3LWNob29zZXIgIG5hbWU9XCJjb21tb2RpdHlcIicgW2RhdGFTb3VyY2VdPVwiZHNcIj5cbiAqXG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUgI21lbnVJdGVtIGxldC1pdGVtPlxuICogICAgICAgICAgICAgXHQ8c3Bhbj5cbiAqICAgICAgICAgICAgIFx0XHQ8aSBjbGFzcz1cImZhIGZhLWVudmlyYSBcIiA+PC9pPlxuICogICAgICAgICAgICAgXHRcdHt7aXRlbX19XG4gKiAgICAgICAgICAgICBcdDwvc3Bhbj5cbiAqXG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjc2VsZWN0aW9uSXRlbSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgIFx0PHNwYW4gY2xhc3M9XCJ0YWcgdGFnLWNpcmNsZVwiPlxuICogICAgICAgICAgICAgXHRcdGl0ZW06IHt7aXRlbSB9fVxuICogICAgICAgICAgICAgXHRcdDxpIGNsYXNzPVwiZmEgZmEtY2xvc2VcIiAoY2xpY2spPVwiY2hvb3Nlci5yZW1vdmVWYWx1ZShpdGVtKVwiPjwvaT5cbiAqICAgICAgICAgICAgIFx0PC9zcGFuPlxuICpcbiAqXG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICA8L2F3LWNob29zZXI+XG4gKiAgICAgIGBcbiAqICAgICAgc3R5bGU6IFtgXG4gKiAgICAgICAgICAgICAgLnRhZy1jaXJjbGUge1xuICogICAgICAgICAgICAgIFx0Ym9yZGVyLXJhZGl1czogNnJlbTtcbiAqICAgICAgICAgICAgICBcdGhlaWdodDogN3JlbTtcbiAqICAgICAgICAgICAgICBcdGNvbG9yOiAjZThlZWYxO1xuICogICAgICAgICAgICAgIFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSg1MywgNTYsIDU4LCAwLjY3KTtcbiAqICAgICAgICAgICAgICBcdGxpbmUtaGVpZ2h0OiA2cmVtO1xuICogICAgICAgICAgICAgIH1cbiAqICAgICAgYF1cbiAqICB9KVxuICpcbiAqIGBgYGBcbiAqXG4gKiAgSW4gYWJvdmUgZXhhbXBsZSB3ZSBjaGFuZ2UgaG93IHRoZSBjaG9vc2VyJ3MgbWVudSBpdGVtIGxvb2sgbGlrZSBhcyB3ZWxsIGFzIHdlIGRlZmluZSBjdXN0b21cbiAqICAgICB0ZW1wbGF0ZSBmb3Igc2VsZWN0aW9uIGl0ZW0gdG8gdHVybiBhbGwgc2VsZWN0aW9uIHRvIGNpcmNsZXMgd2l0aCB0ZXh0IGluIHRoZSBtaWRkbGUuXG4gKlxuICpcbiAqXG4gKi9cblxuZXhwb3J0IGNvbnN0IENIT09TRVJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENob29zZXJDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hvb3NlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdjaG9vc2VyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnY2hvb3Nlci5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDSE9PU0VSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hvb3NlckNvbXBvbmVudCl9LFxuICAgICAgICB7cHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX1cbiAgICBdXG5cblxufSlcbmV4cG9ydCBjbGFzcyBDaG9vc2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQge1xuXG4gICAgLyoqXG4gICAgICogTWF4IG51bWJlciBvZiBpdGVtcyByZXR1cm4gYXQgc2luZ2xlIE1hdGNoIHNvIHdlIGRvIG5vdCByZXR1cm4gMTAwMCBpdGVtcyBhdCBzaW5nbGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWF4TGVuZ3RoOiBudW1iZXIgPSAxMDtcblxuXG4gICAgLyoqXG4gICAgICogTWF4IG51bWJlciBvZiBpdGVtcyByZXR1cm4gYXQgc2luZ2xlIE1hdGNoIHNvIHdlIGRvIG5vdCByZXR1cm4gMTAwMCBpdGVtcyBhdCBzaW5nbGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluTGVuRm9yU2VhcmNoOiBudW1iZXIgPSAxO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0ZXIgdXNlZCB0byBmb3JtYXQgZWFjaCBzZWxlY3Rpb24gYW5kIHNlbGVjdGVkIG9iamVjdCBmb3IgZGlzcGxheS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWVUcmFuc2Zvcm1lcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbXVsdGlzZWxlY3RcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0IENob29zZXJEYXRhU291cmNlIHdpbGwgYmUgY3JlYXRlZCBidXQgdGhlcmUgaXMgYSBvcHRpb24gdG8gc2V0XG4gICAgICogY3VzdG9tIG9uZSBvbiBhcHBsaWNhdGlvbiBsZXZlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGF0YVNvdXJjZTogQ2hvb3NlckRhdGFTb3VyY2U7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2Ugd2FudCB0byBjaGFuZ2UgdGhlIHBsYWNlIHdoZXJlIHNlbGVjdGlvbiBpcyByZW5kZXJlZCB1c2UgdGhpcyBhcHBlbmRUbyBwcm9wZXJ0eVxuICAgICAqIGFuZCBpdCB3aWxsIHVzZSBET00gb3BlcmF0aW9uIGFwcGVuZENoaWxkKCkgdG8gbW92ZSBzZWxlY3Rpb25WaWV3IHVuZGVyIGRpZmZlcmVudCBwYXJlbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbkFwcGVuZFRvOiBFbGVtZW50UmVmO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIGRlbGF5OiBudW1iZXIgPSAzMDA7XG5cblxuICAgIC8qKlxuICAgICAqIFRhcmdldCB0eXBlIHRvIHJlbmRlci4gRGF0YSB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgcmVnaXN0ZXJlZCBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc3RpbmF0aW9uQ2xhc3M6IHN0cmluZztcblxuXG4gICAgQElucHV0KClcbiAgICBmaWVsZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgbW9kZWwgdG8gbGlzdGVuIGZvciBJbnB1dCB2YWx1ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgaW50ZXJuYWxDaG9vc2VyTW9kZWw6IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogRW1iZWRkZWQgdGVtcGxhdGUgZGVmaW5lZCBieSB1c2VyLiBJZiB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYW55IHRlbXBsYXRlIHRoZW4gd2hlbiByZW5kZXJpbmdcbiAgICAgKiBhbiBpdGVtIHdlIGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHByaW1pdGl2ZSB0eXBlcyBhbmQgY2FsbCBvbiBlYWNoIGl0ZW0gdG9TdHJpbmcoKSwgaWZcbiAgICAgKiB3ZSBhcmUgZGVhbGluZyB3aXRoIG9iamVjdCwgdGhlbiB3ZSBleHBlY3QgdXNlciB0byBwcm92aWRlIGEgdGVtcGxhdGUgYW5kIHRlbGwgdGhlIGNob29zZXJcbiAgICAgKiBob3cgaXRlbXMgc2hvdWxkcyBiZSBoYW5kbGVkIG9yIGF0IGxlYXN0IHZhbHVlVHJhbnNmb3JtZXIgc28gd2Uga25vdyBob3cgdG8gY29udmVydCB0aGlzXG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBFYWNoIG9iamVjdCBjYW4gcHJvdmlkZSBpdHMgb3duIHRvU3RyaW5nIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbWVudUl0ZW0nKVxuICAgIG1lbnVUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgQENvbnRlbnRDaGlsZCgnc2VsZWN0aW9uSXRlbScpXG4gICAgc2VsZWN0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAVmlld0NoaWxkKCdhdXRvQ29tcHBsZXRlJylcbiAgICBhdXRvQ29tcGxldGVDb21wb25lbnQ6IEF1dG9Db21wbGV0ZTtcblxuICAgIEBWaWV3Q2hpbGQoJ3NlbGVjdGlvblZpZXcnKVxuICAgIHNlbGVjdGlvblZpZXdFbGVtOiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzZWxlY3Rpb24gaXMgPiBtYXggc2VsZWN0aW9uLCB0aGVuIHNob3cgaGlkZSBsaW5rLlxuICAgICAqL1xuICAgIHByaXZhdGUgaGlkZUxpbms6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIGVsZW1lbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KERBVEFfU09VUkNFKSBwcml2YXRlIF9kZWZhdWx0RFM6IENob29zZXJEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMucGxhY2VIb2xkZXIpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLnBsYWNlSG9sZGVyID0gaTE4bi5pbnN0YW50KCdXaWRnZXRzLmNob29zZXIucGxhY2VIb2xkZXInKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2VIb2xkZXIgPSAnU2VhcmNoJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmhpZGVMaW5rID0gaTE4bi5pbnN0YW50KCdXaWRnZXRzLmNob29zZXIuaGlkZVNlbGVjdGlvbicpO1xuICAgICAgICB0aGlzLmhpZGVMaW5rID0gJ0hpZGUnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGF0YVNvdXJjZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5fZGVmYXVsdERTO1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZvcm1Db250cm9sKSAmJiBpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS51cGRhdGVWYWx1ZSh0aGlzLmZvcm1Db250cm9sLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdEludGVybmFsTW9kZWwoKTtcblxuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgU2VhcmNoIGljb24gaW4gY2FzZSBvZiBtdWx0aXNlbGVjdC5cbiAgICAgKiB0b2RvOiBPbmNlIFByaW1lTkcgd2lsbCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvciByZW1vdmUgaXRcbiAgICAgKlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IHRoaXMuZWxlbWVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICcudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuJyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChzZWFyY2hJbnB1dCkpIHtcbiAgICAgICAgICAgIGxldCBpY29uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGljb25FbGVtZW50LmNsYXNzTmFtZSA9ICdzZWFyY2gtaWNvbi1yaWdodCBmYSBmYS1mdyBmYS1zZWFyY2gnO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuYXBwZW5kQ2hpbGQoaWNvbkVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvbkFwcGVuZFRvKSAmJiBpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25WaWV3RWxlbSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtID0gdGhpcy5zZWxlY3Rpb25BcHBlbmRUbyBpbnN0YW5jZW9mIEVsZW1lbnRSZWYgP1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQXBwZW5kVG8ubmF0aXZlRWxlbWVudCA6IHRoaXMuc2VsZWN0aW9uQXBwZW5kVG87XG5cbiAgICAgICAgICAgIHBhcmVudEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rpb25WaWV3RWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lZWQgdG8gY2hhbmdlIGN1cnJlbnQgYmVoYXZpb3Igc2luY2Ugd2Ugd2FudCB0byBzaG93IHNlbGVjdGlvbiB1bmRlciB0aGUgY2hvb3Nlci4gS1xuICAgICAqXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXMuZWxlbWVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICcudWktYXV0b2NvbXBsZXRlIC51aS1hdXRvY29tcGxldGUtdG9rZW4nKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbnMpICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbnMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIHZhbHVlIGlzIGVudGVyZWQgaW50byBzZWFyY2ggYm94LCB3ZSBhc2sgb3VyIERhdGFTb3VyY2UgdG8gbWF0Y2ggdGhpcyBwYXR0ZXJuXG4gICAgICogYWdhaW5zdCBkYXRhIHJlcG9zaXRvcnkuIEl0IHdpbGwgcmV0cmlldmUgYWxsIHBvc3NpYmxlIG1hdGNoZXMgbGltaXRlZCBieSBNYXhMZW4gYW5kIHRoaXNcbiAgICAgKiBpcyBhZ2FpbiBmaWx0ZXJlZCBzbyBpdCBkb2VzIG5vdCBpbmNsdWRlIGFscmVhZHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAgICpcbiAgICAgKiAgdGhlIG1hdGNoZWQgcmVzdWx0ZWQgaXMgc2F2ZWQgaW4gdGhlOiB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubWF0Y2hlc1xuICAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm46IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsZXQgbWF4TGVuID0gdGhpcy5tYXhMZW5ndGggPyB0aGlzLm1heExlbmd0aCA6IENob29zZXJEYXRhU291cmNlLk1heExlbmd0aDtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLmZpbmQocGF0dGVybiwgbWF4TGVuKTtcblxuXG4gICAgICAgIC8vIGZpeDogZm9yIHRlc3RzOiBJbiB2ZXJzaW9uIDQgd2UgbmVlZCB0byBleHBsaWNpdGx5IGZvY3VzIGlucHV0IG90aGVyd2lzZSBhdXRvY29tcGxldGVcbiAgICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGFueSBwb3B1cCBwYW5lbFxuICAgICAgICBpZiAodGhpcy5lbnYuaW5UZXN0ICYmIGlzUHJlc2VudCh0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50LmZvY3VzSW5wdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbnZva2VkIGJ5IERyb3Bkb3duIGJ1dHRvbiBpbiBjYXNlIG9mIHNpbmdsZSBzZWxlY3QgYW5kIGhlcmUgd2Ugd2FudCB0byBpbnZva2UgbWF0Y2hcbiAgICAgKiB0byByZXRyaWV2ZSBhbGwgc3VnZ2VzdGlvbnMgd2l0aG91dCBhbnkgZmlsdGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRyb3Bkb3duQ2xpY2soZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm1hdGNoKCcqJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXRjaCgnKicpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hvb3NlciBzdGF0ZSBpcyB1cGRhdGVkICB3aXRoIHVzZXIgc2VsZWN0aW9uLiBQbGVhc2Ugc2VlIHdyaXRlVmFsdWUuIFdoZW4gZG8gbm90IG5lZWRcbiAgICAgKiBjYWxsIGFueXRoaW5nIGFkZGl0aW9uYWwgYXMgaW50ZXJuYWxDaG9vc2VyTW9kZWwgYW5kIHRoaXMuY2hvb3NlclN0YXRlLnNlbGVjdGVkT2JqZWN0cygpXG4gICAgICogc2hhcmVzIHRoZSBzYW1lIHJlZmVyZW5jZXMgc28gaXRzIGltcG9ydGFudCB0aGF0IHdlIGZpcnN0IHNhdmUgcmVmZXJlbmNlIHRvXG4gICAgICogdGhpcy5jaG9vc2VyU3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkgYW5kIHRoZW4gYmFjayB0byBpbnRlcm5hbENob29zZXJNb2RlbFxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0SXRlbShpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbSk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudC5pbnB1dEVMLm5hdGl2ZUVsZW1lbnQudmFsdWUgPVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUl0ZW0odGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVW5zZWxlY3QgaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlVmFsdWUoaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbSk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KHtvbmx5U2VsZjogdHJ1ZX0pO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG5cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQuZm9jdXNJbnB1dCgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENvbnZlcnQgYSBvYmplY3QgaWYgYW55IGludG8gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogdG9kbzogaW1wbGVtZW50IGJldHRlciB3YXkgaG93IHRvIHdvcmsgd2l0aCBvYmplY3RzXG4gICAgICpcbiAgICAgKi9cbiAgICBkaXNwbGF5SXRlbShpdGVtOiBhbnkpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5jdXJyZW50SXRlbSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnZhbHVlVHJhbnNmb3JtZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVRyYW5zZm9ybWVyKGl0ZW0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZS5sb29rdXBLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVt0aGlzLmRhdGFTb3VyY2UubG9va3VwS2V5XTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIGxhYmVsIHRoYXQgaXMgc2hvd24gdW5kZXIgdGhlIHNlbGVjdGVkIGl0ZW0gd2hlbiB1c2VyIHNlbGVjdGlvbiBpcyA+XG4gICAgICogTWF4UmVjZW50U2VsZWN0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG1vcmVTZWxlY3RTdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IG1vcmVTZWxlY3RlZCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKS5sZW5ndGggLVxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkO1xuICAgICAgICBpZiAobW9yZVNlbGVjdGVkIDwgMiAmJiAhdGhpcy5kYXRhU291cmNlLnN0YXRlLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlLnN0YXRlLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlTGluaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bW9yZVNlbGVjdGVkfSBtb3JlIHNlbGVjdGVkLi4uYDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugb2YgbXVsdGlzZWxlY3QgPSBmYWxzZSBjaGVjayBpZiB3ZSB3YW50IHRvIHNob3cgYSBzZWxlY3RlZCB2YWx1ZSBpbnNpZGUgdGhlIGlucHV0XG4gICAgICogZmllbGRcbiAgICAgKlxuICAgICAqL1xuICAgIHNpbmdsZVZhbHVlU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRhU291cmNlLnN0YXRlICYmIGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuY3VycmVudEl0ZW0pXG4gICAgICAgICAgICAmJiAhdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGU7XG4gICAgfVxuXG4gICAgaGFzTWVudVRlbXBsYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubWVudVRlbXBsYXRlKTtcbiAgICB9XG5cblxuICAgIGhhc1NlbGVjdGlvblRlbXBsYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uVGVtcGxhdGUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKiBBcyB3ZSBhcmUgdXNpbmcgRGF0YVNvdXJjZSBpbnRlcm5hbGx5IGZvciBbKG5nTW9kZWwpXSBjYXNlIHdlIG5lZWQgdG8gZGVmZmVyIERhdGFTb3VyY2VcbiAgICAgKiBpbml0aWFsaXphdGlvbiBvbmNlIHdlIGhhdmUgYSB2YWx1ZSBhbmQgd2Ugb25seSBhY2NlcHQgW11cbiAgICAgKlxuICAgICAqXG4gICAgICogPyBTaG91bGQgd2UgZG8gc29tZSBkZWVwZXIgY29tcGFyaXNpb24/XG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UudXBkYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbFN0YXRlOiBEZWZhdWx0U2VsZWN0aW9uU3RhdGUgPSBuZXcgRGVmYXVsdFNlbGVjdGlvblN0YXRlKHRoaXMubXVsdGlzZWxlY3QpO1xuICAgICAgICAgICAgbGV0IGNoU3RhdGU6IENob29zZXJTdGF0ZSA9IG5ldyBDaG9vc2VyU3RhdGUoc2VsU3RhdGUsIHRoaXMubXVsdGlzZWxlY3QpO1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZShjaFN0YXRlKTtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdEludGVybmFsTW9kZWwoKTtcbiAgICB9XG5cbiAgICBpbml0RGF0YXNvdXJjZShjaG9vc2VyU3RhdGU/OiBDaG9vc2VyU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpLFxuICAgICAgICAgICAgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgZGVzdGluYXRpb25DbGFzcyBvciBjdXN0b20gRGF0YVNvdXJjZScpO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAgICAgICAgICAgIG9iajogdGhpcy5kZXN0aW5hdGlvbkNsYXNzLFxuICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gICAgICAgICAgICBsb29rdXBLZXk6IHRoaXMuZmllbGQsXG4gICAgICAgICAgICBzdGF0ZTogY2hvb3NlclN0YXRlLFxuICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IG5nT25Jbml0IGFuZCBXcml0ZSB2YWx1ZSB0byByZWFkIHN0YXRlIGZyb20gQ2hvb3NlclN0YXRlIGFuZCBzZXQgaXQgdG8gaW50ZXJuYWxcbiAgICAgKiBuZ01vZGVsIHByb3BlcnR5XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRJbnRlcm5hbE1vZGVsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsID0gdGhpcy5kYXRhU291cmNlLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Nob29zZXJDb21wb25lbnR9IGZyb20gJy4vY2hvb3Nlci5jb21wb25lbnQnO1xuaW1wb3J0IHtBdXRvQ29tcGxldGVNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuLi9oeXBlcmxpbmsvaHlwZXJsaW5rLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcblxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2hvb3NlckNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaG9vc2VyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1NlbGVjdEl0ZW19IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogQSBwb3B1cCBsaWtlIGNvbXBvbmVudCByZW5kZXJpbmcgbGlzdCBvZiB2YWx1ZXMgYXMuIEJhc2VkIG9uIFByaW1lTkcgY29tcG9uZW50IGFuZCBvbmUgb2YgdGhlXG4gKiBtYWluIHJlYXNvbiB3aHkgd2UgbmVlZCB0byB3cmFwIHRoaXMgaXMgdG8gZXh0ZW5kIGl0cyBjYXBhYmlsaXRpZXMgdG8gYWNjZXB0IGFsbW9zdCBhbnlcbiAqIGRhdGEgdHlwZSB3aXRob3V0IHVzaW5nIFByaW1lbnMncyBzcGVjaWZpYyBTZWxlY3RJdGVtIHR5cGUuXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnc2hvd0Ryb3BEb3duJyAsXG4gKiAgICAgIHRlbXBsYXRlOiAnPGF3LWRyb3Bkb3duIFtsaXN0XT1cInRlc3RJdGVtU21hbGxcIlxuICogICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCI+PC9hdy1kcm9wZG93bj4nXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgTXlEcm9wQ29tcG9uZW50XG4gKiAge1xuICogICAgICB0ZXN0SXRlbVNtYWxsOiBzdHJpbmdbXSA9IFsndmlldycgLCAnZWRpdCddO1xuICpcbiAqICAgICAgLy8gd2hlbiB5b3Ugc3dpdGNoIGxpc3QgYmluZGluZyB0byByZWZlcnQgdG8gbGFyZ2UgaXRlbSBmaWlsdGVyIGF1dG9tYXRpY2FsbHkgaXMgc2hvd24gYW5kXG4gKiAgICAgbWF4IDEwIGl0ZW1zIGFyZVxuICogICAgICAvLyB2aXNpYmxlXG4gKiAgICAgIHRlc3RJdGVtTGFyZ2U6IHN0cmluZ1tdID0gWyd2aWV3JyAsICdlZGl0JyAsICdmcmFuaycgLCAna29sYXInICwgJ1RoZSBTdW4nICwgJ0RvZycgLFxuICogICAgICdDb21wdXRlcicgLCAnQSBEZXNrJyAsXG4gKiAgICAgICdNeSBDYXInICwgJ1BlbmNpbCcgLCAnVGhpcyBQYWdlJyAsICdZZXN0ZXJkYXknICwgJ01vbmRheScgLCAnVHVlc2RheScgLCAnQk1XIFIxMjAwIEdTJyAsXG4gKiAgICAgJ0N6ZWNoIFJlcHVibGljJyAsXG4gKiAgICAgICdMYXN0IEl0ZW0nXTtcbiAqXG4gKlxuICogICAgICBpdGVtU2VsZWN0ZWQ6IHN0cmluZyA9ICd2aWV3JztcbiAqICAgICAgaXRlbVNlbGVjdGVkTGc6IHN0cmluZyA9ICdNb25kYXknO1xuICpcbiAqICAgICAgbm9zZWxTdHJpbmc6IHN0cmluZyA9ICcobm8gc2VsZWN0aW9uKSc7XG4gKlxuICpcbiAqICAgICAgb25TZWxlY3Rpb24gKGV2ZW50KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgICB0aGlzLml0ZW1TZWxlY3RlZCA9IGV2ZW50O1xuICpcbiAqICAgICAgfVxuICogIH1cbiAqXG4gKiAgYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IGNvbnN0IEREX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEcm9wZG93bkNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kcm9wZG93bicsXG4gICAgdGVtcGxhdGVVcmw6ICdkcm9wZG93bi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2Ryb3Bkb3duLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIEREX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRHJvcGRvd25Db21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4TnVtU2hvd24gPSAxMDtcblxuICAgIC8qKlxuICAgICAqIE9yZGVyZWQgbGlzdCBvZiBpdGVtcyByZW5kZXJlZCBhcyBhIHBvcHVwIG1lbnVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogSXRlbXMgd2hpY2ggd2FzIHNlbGVjdGVkIGFzIGEgZGVmYXVsdCB2YWx1ZSBvciBieSB1c2VkIGluIHRoZSBwb3B1cCBtZW51LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVuZGVyZWQgYXMgZmlyc3QgdmFsdWUgaW4gdGhlIHBvcHVwIHdoaWNoIGxldCB0aGUgdXNlciB0byBtYWtlICdubyBzZWxlY3Rpb24nIGZyb21cbiAgICAgKiBhdmFpbGFibGUgbGlzdCBvZiB2YWx1ZXMuIFdoZW4gdGhpcyBvcHRpb24gaXMgYWN0aXZlIGFuZCB1c2UgbWFrZSB0aGlzIHNlbGVjdGlvbiB3ZSBzYXZlIGFcbiAgICAgKiBOVUxMIHZhbHVlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub1NlbGVjdGlvblN0cmluZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBpbnRlcm5hbCBsaXN0IHRoYXQgaGlkZXMgUHJpbWVORyBzcGVjaWZpY3Mgd2hlcmUgd2UgbmVlZCB0byBkZWFsIHdpdGggc3BlY2lhbFxuICAgICAqIHR5cGU6IFNlbGVjdEl0ZW0uIE91ciBleHBlY3RhdGlvbiBpcyB0aGF0IHlvdSBuZWVkIHRvIGJlIGFibGUgdG8gcGFzcyByZWd1bGFyIHN0cmluZyB2YWx1ZXNcbiAgICAgKiBvciBmdWxsIG9iamVjdCBhbmQgbm90IHRyeWluZyB0byB3cmFwIGl0IGludG8gZXh0cmEgbGF5ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnRlcm5hbExpc3Q6IFNlbGVjdEl0ZW1bXTtcblxuXG4gICAgLyoqXG4gICAgICogRW1iZWRkZWQgdGVtcGxhdGUgZGVmaW5lZCBieSB1c2VyLiBJZiB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYW55IHRlbXBsYXRlIGFuZCB3aGlsZSByZW5kZXJpbmdcbiAgICAgKiBpdGVtIHdlIGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHByaW1pdGl2ZSB0eXBlcyBhbmQgY2FsbCBvbiBlYWNoIGl0ZW0gdG9TdHJpbmcoKSwgaWYgd2VcbiAgICAgKiBhcmUgZGVhbGluZyB3aXRoIG9iamVjdCwgdGhlbiB3ZSBleHBlY3QgdXNlciB0byBwcm92aWRlIGEgdGVtcGxhdGUgYW5kIHRlbGwgdGhlIGRyb3Bkb3duIG9mXG4gICAgICogZWFjaCBpdGVtIHNob3VsZCBiZSBoYW5kbGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdpdGVtVGVtcGxhdGUnKVxuICAgIGl0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWwgdXNlZCBmb3IgZW1iZWRkZWQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBtb2RlbDogU2VsZWN0SXRlbTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2RvOiBQdXQgYmFjayB0aGUgc2Nyb2xsaW5nIG9wdGlvbiBvbmNlIHdlIGRlY2lkZSBzby4gQ3VycmVudGx5IHRoZSByZXF1aXJlbWVudHMgYXJlXG4gICAgICogc2hvdyBvbmx5IDEwIGl0ZW1zIG1heCwgbm8gc2Nyb2xsaW5nLiBGdW5jdGlvbmFsaXR5IGNvbW1lbnRlZCBvdXQgY2FuIHNob3cgc2Nyb2xsYmFyIHdpdGhcbiAgICAgKiBzZWFyY2ggZmlsdGVyLlxuICAgICAqL1xuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSBhIHZhbHVlIHRvIFByaW1lTmcgRm9ybWF0LCB3ZSBhcmUgbm90IHJlYWxseSBiZSB1c2luZyBhIGxhYmVsIGZpZWxkIG9ubHkgYVxuICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSBbXTtcbiAgICAgICAgLy8gaWYgKGlzUHJlc2VudCh0aGlzLm5vU2VsZWN0aW9uU3RyaW5nKSkge1xuICAgICAgICAvLyAgICAgdGhpcy5pbnRlcm5hbExpc3QucHVzaCh7XG4gICAgICAgIC8vICAgICAgICAgbGFiZWw6IHRoaXMubm9TZWxlY3Rpb25TdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpICYmIHRoaXMubGlzdC5sZW5ndGggPj0gRHJvcGRvd25Db21wb25lbnQuTWF4TnVtU2hvd24pIHtcblxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3Quc2xpY2UoMCwgRHJvcGRvd25Db21wb25lbnQuTWF4TnVtU2hvd24pLm1hcCgoaXRlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IGl0ZW0udG9TdHJpbmcoKSwgdmFsdWU6IGl0ZW19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gdGhpcy5saXN0LnNsaWNlKDApLm1hcCgoaXRlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IGl0ZW0udG9TdHJpbmcoKSwgdmFsdWU6IGl0ZW19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGhhc0VtYmVkZGVkVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLml0ZW1UZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdG8gcHJldmVudCBFbXB0eSBpdGVtIHRvIGJlIHJlbmRlcmVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBSZXBvcnQgdGhpcyBvbiBQcmltZU5nXG4gICAgICpcbiAgICAgKi9cbiAgICBpdGVtRXhpc3QoaXRlbTogYW55KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChpdGVtKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZHJvcGRvd24gbGlzdCBpcyBtb3JlIHRoZW4gZGVmaW5lZCBjb25zdGFudCBNYXhOdW1TaG93biAoMTApIGF1dG9tYXRpY2FsbHkgc2hvdyBmaWx0ZXJcbiAgICAgKiBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIHNob3dGaWx0ZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyByZXR1cm4gaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgdGhpcy5saXN0Lmxlbmd0aCA+IERyb3Bkb3duQ29tcG9uZW50Lk1heE51bVNob3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXBkYXRlcyBpbnRlcm5hbCBtb2RlbHMgb2YgY3VycmVudCBzZWxlY3Rpb25zIGFuZCB0cmlnZ2VycyBvblNlbGVjdGlvbiBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgb25JdGVtU2VsZWN0aW9uKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlLnZhbHVlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodmFsdWUudmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KHtvbmx5U2VsZjogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuXG4gICAgZGlzcGxheUl0ZW0oaXRlbTogYW55KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChpdGVtKSA/IGl0ZW0ubGFiZWwgOiAnTm8gU2VsZWN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCFlcXVhbHModmFsdWUsIHRoaXMuc2VsZWN0aW9uKSkge1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtEcm9wZG93bkNvbXBvbmVudH0gZnJvbSAnLi9kcm9wZG93bi5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtEcm9wZG93bk1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEcm9wZG93bkNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRHJvcGRvd25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRHJvcGRvd25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXRHJvcGRvd25Nb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc0JsYW5rLCBpc1ByZXNlbnQsIFZhbHVlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG4vKipcbiAqIExpZ2h0d2VpZ2h0IGFuZCBjb25maWd1cmFibGUgQ3VycmVuY3kgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBuZyBib290c3RyYXAgZGlyZWN0aXZlLiBUaGlzXG4gKiBjb21wb25lbnQgY29tYmluZXMgYW4gaW5wdXQgYW5kIGN1cnJlbmN5IGNvZGUgZHJvcGRvd24uXG4gKlxuICpcbiAqIGZvciBtb3JlIGluZm8gcGxlYXNlIHNlZSBjbGFzcyBEb2Mgb2YgdGhlOlxuICogIEBzZWUge0BsaW5rIGN1cnJlbmN5L2N1cnJlbmN5LmNvbXBvbmVudC50c31cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ2Ftb3VudCcgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgIDxhdy1jdXJyZW5jeSBbbW9uZXldPVwicHJpY2VcIiBbY3VycmVuY2llc109XCJjdXJyZW5jaWVzXCIgW25hbWVdPVwiJ2N1cnJlbmN5J1wiPlxuICogICAgICA8L2F3LWN1cnJlbmN5PlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBhbW91bnQ6IG51bWJlciA9IDEwMDA7XG4gKiAgICAgICAgY3VycmVuY2llczogc3RyaW5nW10gPSBbJ1VTRCcsICdDTlknLCAnQVVEJywgJ0VVUicsICdHQlAnXTtcbiAqICAgICAgICBjdXJyZW5jeUNvZGU6IHN0cmluZyA9IHRoaXMuY3VycmVuY2llc1swXTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5cbmV4cG9ydCBjb25zdCBDVVJSRU5DWV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ3VycmVuY3lDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY3VycmVuY3knLFxuICAgIHRlbXBsYXRlVXJsOiAnY3VycmVuY3kuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydjdXJyZW5jeS5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDVVJSRU5DWV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEN1cnJlbmN5Q29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgQ3VycmVuY3lDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIE1vbmV5IG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB2YWx1ZSwgbG9jYWxlLCBjdXJyZW5jeSBjb2RlLlxuICAgICAqIElmIHRoaXMgb2JqZWN0IGlzIHNldCwgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbW9uZXk6IE1vbmV5O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB1c2VyIHRvIGNoYW5nZSBNb25leSdzIGN1cnJlbmN5IGNvZGUgYW5kIHN0aWxsXG4gICAgICogYWxsb3cgdXNlciB0byBlZGl0IE1vbmV5J3MgYW1vdW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVhZG9ubHlDdXJyZW5jeUNvZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW5jeSB0aGF0J3Mgc2VsZWN0ZWQgZm9yIHRoaXMgY3VycmVuY3kgZmllbGQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW5jeVNlbGVjdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHVzZWQgdG8gZm9ybWF0IHRoZSBtb25leSBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByZWNpc2lvbjogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjdXJyZW5jaWVzIHRoYXQgdGhpcyBjdXJyZW5jeSB3aWRnZXQgc3VwcG9ydC4gVGhlIGZvcm1hdCBmb3IgZWFjaCBlbnRyeSBzaG91bGQgYmVcbiAgICAgKiBbY3VycmVuY3ktY29kZSAtIGRlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIF9jdXJyZW5jaWVzOiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBjdXJyZW5jeSB2YWx1ZS4gVXNlcyBhbmd1bGFyIGN1cnJlbmN5UGlwZSB0byBmb3JtYXQgYmFzZWQgb24gY291bnRyeSBjb2RlLlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbmN5IHBpcGUgaXMgdXNlZCB0byBmb3JtYXQgb3VyIG1vbmV5IG9iamVjdC5cbiAgICAgKi9cbiAgICBjdXJyZW5jeVBpcGU6IEN1cnJlbmN5UGlwZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGN1cnJlbmNpZXMuXG4gICAgICAgIHRoaXMuaW5pdEN1cnJlbmNpZXMoKTtcblxuICAgICAgICB0aGlzLmN1cnJlbmN5UGlwZSA9IG5ldyBDdXJyZW5jeVBpcGUoZW52LmxvY2FsZSk7XG5cbiAgICAgICAgZW52Lm9uTG9jYWxlQ2hhbmdlLnN1YnNjcmliZSgobG9jYWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lQaXBlID0gbmV3IEN1cnJlbmN5UGlwZShsb2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbmV5LmFtb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLm1vbmV5KTtcblxuICAgICAgICB0aGlzLmluaXRDdXJyZW5jaWVzKCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jdXJyZW5jeVNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSB0aGlzLl9jdXJyZW5jaWVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVhZHkgdGhlIG1vbmV5IGZpZWxkIGlmIGl0IGV4aXN0cy4gYW5kIG92ZXJyaWRlIHRoZSBleGlzdGluZyB2YWx1ZXMuXG4gICAgICAgIGlmICh0aGlzLm1vbmV5KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gdGhpcy5tb25leS5jdXJyZW5jeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9uZXkgPSBuZXcgTW9uZXkobnVsbCwgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBpbml0Q3VycmVuY2llcygpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbmNpZXMgfHwgdGhpcy5fY3VycmVuY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbmNpZXMgPSBbJ1VTRCcsICdDTlknLCAnQVVEJywgJ0VVUicsICdHQlAnXTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSB0aGUgcmVhbCB2YWx1ZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBpbiB0aGUgY3VycmVuY3kgd2lkZ2V0LiBUaGVuIGhlIGNhbiBtb2RpZnkgdGhlXG4gICAgICogdmFsdWUgd2l0aG91dCBzZWVpbmcgdGhlIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBvbkZvY3VzKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkpICYmIGlzUHJlc2VudCh0aGlzLm1vbmV5LmFtb3VudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5tb25leS5hbW91bnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIGZvcm1hdHRlZCBjdXJyZW5jeSB2YWx1ZSB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyBhd2F5LlxuICAgICAqIEBwYXJhbSBlbFxuICAgICAqL1xuICAgIG9uQmx1cihlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5tb25leSA9IHRoaXMubW9uZXkuY2xvbmUoe2Ftb3VudDogTnVtYmVyKGVsLnZhbHVlKX0pO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb25leSk7XG4gICAgfVxuXG4gICAgb25TZWxlY3Rpb24oY3VycmVuY3k6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSBjdXJyZW5jeTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2lsbCBjaGVjayB0byBzZWUgaWYgY3VycmVuY3kgaXMgYSB2YWxpZCBudW1iZXIgYmVmb3JlIGZvcm1hdHRpbmcuXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuICAgIHByaXZhdGUgZm9ybWF0Q3VycmVuY3kodmFsOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmICghdmFsIHx8IHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlID0gJ1VTRCc7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbmN5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jdXJyZW5jeVNlbGVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9uZXkgPSB0aGlzLm1vbmV5LmNsb25lKHtjdXJyZW5jeTogdGhpcy5jdXJyZW5jeVNlbGVjdGlvbn0pO1xuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBwcmVjaXNpb24gaXMgMi4gRm9yIGV4YW1wbGUsIDEwLjIzIFVTRC5cbiAgICAgICAgbGV0IGRpZ2l0cyA9ICcxLjAtMic7XG4gICAgICAgIC8vIElmIHByZWNpc2lvbiBpcyBwcmVzZW50LCB1c2UgaXQgZm9yIGZvcm1hdCB0aGUgbW9uZXkgdmFsdWUgZm9yIGRpc3BsYXkuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wcmVjaXNpb24pKSB7XG4gICAgICAgICAgICBkaWdpdHMgPSAnMS4wLScgKyB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVBpcGUudHJhbnNmb3JtKHZhbCwgY29kZSwgJ3N5bWJvbCcsIGRpZ2l0cyk7XG4gICAgfVxuXG4gICAgZ2V0TW9uZXlDdXJyZW5jeSgpOiBzdHJpbmcge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGlzcGxheVZhbHVlKSAmJiB0aGlzLmRpc3BsYXlWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgY3VycmVuY2llcygpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbmNpZXM7XG4gICAgfVxuXG4gICAgc2V0IGN1cnJlbmNpZXModmFsdWU6IGFueVtdKVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbmNpZXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgTW9uZXkpICYmICFlcXVhbHModmFsdWUsIHRoaXMubW9uZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1vbmV5ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkuY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IHRoaXMubW9uZXkuY3VycmVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vbmV5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBNb25leSBvYmplY3QgaXMgcmVwcmVzZW50ZWQgYXMgYSB2YWx1ZSwgbG9jYWxlLCBhbmQgY3VycmVuY3lDb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBNb25leSBpbXBsZW1lbnRzIFZhbHVlXG57XG4gICAgdW5pcXVlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyID0gMCwgcHVibGljIHJlYWRvbmx5IGN1cnJlbmN5OiBzdHJpbmcgPSAnVVNEJyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcgPSAnZW5fVVMnKVxuICAgIHtcbiAgICB9XG5cblxuICAgIGdldFR5cGVzKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFtb3VudDogTnVtYmVyLFxuICAgICAgICAgICAgY3VycmVuY3k6IFN0cmluZyxcbiAgICAgICAgICAgIGxvY2FsZTogU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3NOYW1lKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuICdNb25leSc7XG4gICAgfVxuXG4gICAgJHByb3RvKCk6IE1vbmV5XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IE1vbmV5KDEsICcyMycsICczMycpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50ICsgJywgbG9jYWxlOiAnICsgdGhpcy5sb2NhbGUgKyAnLCBjb2RlOiAgJyArIHRoaXMuY3VycmVuY3k7XG4gICAgfVxuXG5cbiAgICBjbG9uZShkYXRhOiB7IGFtb3VudD86IG51bWJlciwgY3VycmVuY3k/OiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyB9ID0ge30pOiBNb25leVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25leShcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmFtb3VudCkgPyBkYXRhLmFtb3VudCA6IHRoaXMuYW1vdW50LFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuY3VycmVuY3kpID8gZGF0YS5jdXJyZW5jeSA6IHRoaXMuY3VycmVuY3ksXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5sb2NhbGUpID8gZGF0YS5sb2NhbGUgOiB0aGlzLmxvY2FsZVxuICAgICAgICApO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlLCBDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Ryb3Bkb3duTW9kdWxlLCBJbnB1dFRleHRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0N1cnJlbmN5Q29tcG9uZW50fSBmcm9tICcuL2N1cnJlbmN5LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtDdXJyZW5jeVBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ3VycmVuY3lNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc0RhdGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBMaWdodHdlaWdodCBhbmQgY29uZmlndXJhYmxlIERhdGUgYW5kIFRpbWUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwcmltZW5nLiBUaGlzXG4gKiBjb21wb25lbnQgY29tYmluZXMgYm90aCBkYXRlIHBpY2tlciBhcyB3ZWxsIGFzIHRpbWUgcGlja2VyXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXlUaW1lcicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIiAgW25hbWVdPVwiJ2R1ZURhdGUnXCI+XG4gKiAgICA8L2F3LWRhdGUtdGltZT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15VGltbWVyQ29tcG9uZXRcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gKlxuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEZ1bGxZZWFyKDIwMTYgLCAxMCAsIDMpO1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0SG91cnMoMTAgLCAxMCAsIDEwKTtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCB5b3Ugd2lsbCBzZWUgZGF0ZSBmaWVsZCBhbmQgdGltZSBmaWVsZCBpcyBoaWRkZW4gdG8gc2hvdyBib3RoIHlvdSBqdXN0IGRvIGZvbGxvd2luZzpcbiAqXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteVRpbWVyJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgIFtuYW1lXT1cIidiYmRkJ1wiPlxuICogICAgPC9hdy1kYXRlLXRpbWU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVRpbW1lckNvbXBvbmV0XG4gKiAgICB7XG4gKiAgICAgICAgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gKiAgICAgICAgc2hvd1RpbWUgPSB0cnVlO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEZ1bGxZZWFyKDIwMTYgLCAxMCAsIDMpO1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0SG91cnMoMTAgLCAxMCAsIDEwKTtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cblxuXG5leHBvcnQgY29uc3QgREFURVRJTUVfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVBbmRUaW1lQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kYXRlLXRpbWUnLFxuICAgIHRlbXBsYXRlVXJsOiAnZGF0ZS1hbmQtdGltZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2RhdGUtYW5kLXRpbWUuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgREFURVRJTUVfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlQW5kVGltZUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIERhdGVBbmRUaW1lQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHJlYWRvbmx5IE5nVGltZTEyOiBzdHJpbmcgPSAnaGg6bW0gYSc7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5nVGltZTI0OiBzdHJpbmcgPSAnSEgubW0gYSc7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUgdXNlZCB0byBzZXQgdGhlIGRhdGUgYW5kIHRpbWUgcGlja2VyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGF0ZSBmb3JtYXQgcGF0dGVybiB1c2VkIGlmIG5vbmUgaXMgcGFzc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdFBhdHRlcm46IHN0cmluZyA9ICdtbS9kZC95eSc7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgd29ya2Fyb3VuZCBhcyBmb3JtYXR0ZXJzIGluIHRoZSBwcmltZU5HIGFuZCBhbmd1bGFyIGFyZSBkaWZmZXJlbnQgc28gdW50aWwgaXRzXG4gICAgICogZml4ZWQgd2UgbmVlZCB0byBrZWVwIHRoaXMgZXh0cmEgcGF0dGVybi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdFBhdHRlcm5ORzogc3RyaW5nID0gJ01NL2RkL3l5JztcblxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYW5kIGhpZGVzIG5hdmlnYXRpb24gYmFyIHdpdGggeWVhciBhbmQgbW9udGhzIHNlbGVjdGlvbnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dOYXZpZ2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFllYXIgcmFuZ2UgZGlzcGxheWVkIGZvciB0aGUgZHJvcCBkb3duLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgeWVhclJhbmdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhbmQgaGlkZXMgbmF2aWdhdGlvbiBiYXIgd2l0aCB5ZWFyIGFuZCBtb250aHMgc2VsZWN0aW9uc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0ljb246IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IHRpbWVwaWNrZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dUaW1lOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBEYXRlUGlja2VyLiBFdmVuIHdlIGNhbiBoaWRlIGl0LiBpdCBzaG91bGQgYmUgZm9yIG1vc3Qgb2YgdGhlIGNhc2UgYWx3YXlzXG4gICAgICogdHJ1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0RhdGU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHRoZSBkYXRlIHBpY2tlciB3aGF0IGZvcm1hdCBpdCBzaG91bGQgdXNlIHdoZW4gcHJlc2VudGluZyB0aW1lLiBXaGVuIGhvdXJGb3JtYXQgaXMgMTIsXG4gICAgICogaXQgc2hvd3MgdGhlIEFNLCBQTVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBob3VyRm9ybWF0OiBzdHJpbmcgPSAnMjQnO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgZXZlbnQgd2hlbiBzcGVjaWZpYyBkYXRlIGlzIGNsaWNrZWQgaW5zaWRlIERhdGVQaWNrZXJcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRhdGUgdG8gaGlnaGxpZ2h0IG9uIGZpcnN0IG9wZW5pbmcgaWYgdGhlIGZpZWxkIGlzIGJsYW5rLlxuICAgICAqXG4gICAgICovXG4gICAgZGVmYXVsdERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBEYXRldGltZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgRGF0ZUFuZFRpbWUgZm9ybWF0TmFtZSBpcyBub3QgcHJvcGFnYXRlZFxuICAgICAqIHRvIERhdGUgZmllbGQuXG4gICAgICovXG4gICAgZm9ybWF0TmFtZVdpdGhUaW1lOiBzdHJpbmc7XG5cblxuICAgIGkxOG46IGFueTtcbiAgICB0aW1lUGxhY2VIb2xkZXI6IHN0cmluZyA9ICdoaDpzcyc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHRvIGRhdGVUaW1lIHBhdHRlcm4gd2hpY2ggaXMgZGVmaW5lZCBpbiByZXNvdXJjZSBmaWxlc1xuICAgICAgICBpZiAodGhpcy5ob3VyRm9ybWF0ICE9PSAnMTInICYmIHRoaXMuaG91ckZvcm1hdCAhPT0gJzI0Jykge1xuICAgICAgICAgICAgdGhpcy5ob3VyRm9ybWF0ID0gJzI0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZVBsYWNlSG9sZGVyID0gKHRoaXMuaG91ckZvcm1hdCA9PT0gJzEyJykgP1xuICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSgodmFsOiBEYXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbml0VHJhbnNsYXRpb25zKCk7XG5cbiAgICAgICAgdGhpcy5lbnYub25Mb2NhbGVDaGFuZ2Uuc3Vic2NyaWJlKChsb2NhbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0VHJhbnNsYXRpb25zKCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE5lZWQgdG8gcmVmYWN0b3IgdGhpcyBhcyB0aGlzIHJlYWxseSBnZXQgY29tcGxpY2F0ZWQgdHJ5aW5nIHRvIGNvdmVyIHVzZWNhc2Ugd2l0aCB0aW1lXG4gICAgICogYW5kIGRhdGUgYW5kIGV2ZXJ5IGZvcm1hdCB3ZSBoYXZlLiBXZSBzaG91bGQgcHJvYmFibHkgaGF2ZSBzZXBhcmF0ZSBwYXR0ZXJucyBmb3JcbiAgICAgKiBkYXRlcyBvbmx5IGFuZCBkYXRlICsgdGltZVxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdFRyYW5zbGF0aW9ucygpIHtcblxuICAgICAgICB0aGlzLmZvcm1hdE5hbWVXaXRoVGltZSA9IHRoaXMuZm9ybWF0UGF0dGVybjtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBhdHRlcm5ORyA9IHRoaXMuZm9ybWF0UGF0dGVybiArPSAodGhpcy5ob3VyRm9ybWF0ID09PSAnMTInKSA/XG4gICAgICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWUpIHtcbiAgICAgICAgICAgIGxldCB0aW1lU3RhcnRzID0gdGhpcy5mb3JtYXRQYXR0ZXJuLmluZGV4T2YoJ2gnKTtcbiAgICAgICAgICAgIGlmICh0aW1lU3RhcnRzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0TmFtZVdpdGhUaW1lID0gdGhpcy5mb3JtYXRQYXR0ZXJuLnN1YnN0cmluZygwLCB0aW1lU3RhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGF0dGVybk5HICs9ICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicpID9cbiAgICAgICAgICAgICAgICBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMTJ9YCA6IGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUyNH1gO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLmkxOG4gPSB7XG4gICAgICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JyxcbiAgICAgICAgICAgICAgICAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgICAgICAgICBkYXlOYW1lc01pbjogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLFxuICAgICAgICAgICAgICAgICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsXG4gICAgICAgICAgICAgICAgJ05vdicsICdEZWMnXVxuICAgICAgICB9O1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGRhdGVzIGNoYW5nZXMuIEhlcmUgd2UgdXBkYXRlICB0aGlzLnZhbHVlIC0gPiBkYXRlIGFuZCBhbHNvIHVwZGF0ZSB2YWx1ZSBpbnNpZGVcbiAgICAgKiBmb3JtQ29udHJvbGxlclxuICAgICAqXG4gICAgICovXG4gICAgb25EYXRlQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkIHtcblxuICAgICAgICBpZiAoaXNCbGFuayhldmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHNvbWUgZXJyb3IgP1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlzRGF0ZShldmVudCkgPyBldmVudCA6IG5ldyBEYXRlKGV2ZW50KTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMudmFsdWUsIHtvbmx5U2VsZjogZmFsc2UsIGVtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG4iLCJpbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDYWxlbmRhck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RGF0ZUFuZFRpbWVDb21wb25lbnR9IGZyb20gJy4vZGF0ZS1hbmQtdGltZS5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0RhdGVBbmRUaW1lTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGlhbG9nIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGlhbG9nQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2ctaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0hlYWRlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBkaWFsb2cgaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBEaWFsb2dDb21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRpYWxvZy1mb290ZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7RGlhbG9nSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWFsb2cgQ29tcG9uZW50IHRoYXQgcHJvdmlkZXMgdGhlIGxvb2sgYW5kIGZlZWwgZm9yIGEgbW9kYWwgZGlhbG9nLiBUaGlzIGNvbXBvbmVudCBoYXMgdGhyZWVcbiAqIHNlY3Rpb25zOiBoZWFkZXIsIGJvZHksIGFuZCBmb290ZXIuIEl0IGNhbiBiZSB1c2VkIGJ5IGl0c2VsZiBvciBleHRlbmRlZC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgdHlwZXMgb2YgcG9wdXAuXG4gKiAgIDEuICBhIHJlZ3VsYXIgZGlhbG9nIGJveCB0aGF0IGhhcyBoZWFkZXIsIGJvZHkgYW5kIGZvb3Rlci4gSXQncyB0aGUgbW9zdCBjdXN0b21pemFibGUuXG4gKiAgIDIuICBhIGNvbmZpcm1hdGlvbiBib3ggaXMgc2ltaWxhciB0byBhIGRpYWxvZyBib3ggYnV0IGhhcyBhY2NlcHQgYW5kIHJlamVjdCBhY3Rpb24gYnV0dG9ucy5cbiAqICAgMy4gIGEgb3ZlcmxheSwgd2hpY2ggaXMgYSB2ZXJ5IGJhc2ljIHBvcHVwIHdpdGggd2hhdCB5b3UgcHV0IGluc2lkZS5cbiAqICAgICAgIEl0IGRvZXNuJ3QgaGF2ZSBoZWFkZXIgYW5kIGZvb3Rlci5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIGFueSBwb3B1cCBjb21wb25lbnQuXG4gKiAgIDEuICBFaXRoZXIgZGlyZWN0bHkgYnkgdXNpbmcgY29tcG9uZW50LCBhdy1kaWFsb2csIGF3LWNvbmZpcm1hdGlvbiBvciBhdy1vdmVybGF5XG4gKiAgIDIuICBvciB0aGUgTW9kYWxTZXJ2aWNlICBzZXJ2aWNlLm9wZW4oPERpYWxvZ0NvbXBvbmVudD4pLCBzZXJ2aWNlLmNsb3NlKClcbiAqXG4gKiBVc2FnZTpcbiAqICAgIDEuICBVc2luZyBEaWFsb2cgZGlyZWN0bHkgdG8gZGlzcGxheSBhIG1vZGFsIHBvcHVwLiBUaGlzIHVzYWdlIGlzIGEgcXVpY2sgd2F5IHRvIHNob3cgYVxuICogbWVzc2FnZSB0byB0aGUgdXNlci5cbiAqXG4gKiAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5vcGVuPERpYWxvZ0NvbXBvbmVudD4oIERpYWxvZ0NvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ015IFBvcHVwIFRpdGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgYm9keTogJ015IFBvcHVwIEJvZHknXG4gKiAgICAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nIFsodmlzaWJsZSldPVwiZGlzcGxheVwiIFttb2RhbF09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbk9wZW4pPVwib3BlbkFjdGlvbigpXCIgKG9uQ2xvc2UpPVwiY2xvc2VBY3Rpb24oKVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZy1oZWFkZXI+RGlhbG9nIEhlYWRlcjwvYXctZGlhbG9nLWhlYWRlcj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaWFsb2cgQm9keTogQ3JlYXRpbmcgYSBkaWFsb2cgdXNpbmcgdGhlIGRpYWxvZyBjb21wb25lbnRcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2ctZm9vdGVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIFtzdHlsZV09XCIncHJpbWFyeSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNsb3NlKClcIj5PSzwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGlhbG9nPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiAoY2xpY2spPVwib3BlbigpXCI+T3BlbiBEaWFsb2c8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpYWxvZ0FjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbkFjdGlvbigpICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nQWN0aW9uID0gXCJvcGVuXCI7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2cnLFxuICAgIHRlbXBsYXRlVXJsOiAnZGlhbG9nLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZGlhbG9nLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nQ29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXJcbntcbiAgICAvKipcbiAgICAgKiBUaXRsZSBmb3IgdGhlIERpYWxvZy4gIGlmIHRpdGxlIGFuZCAnVGl0bGVUZW1wbGF0ZScgYXJlIGJvdGggc2V0LCB0aXRsZVRlbXBsYXRlIHRha2VzXG4gICAgICogcHJlY2VkZW5jZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5IHNlY3Rpb24gZm9yIERpYWxvZy4gQ2FsbGVyIHNob3VsZCB1c2UgZWl0aGVyIHRoZSBib2R5IHN0cmluZywgb3IgY29udGVudCBwcm9qZWN0aW9uXG4gICAgICogdG8gYWRkIHZhbHVlcyB0byB0aGUgZGlhbG9nLiBJZiBib3RoIGFyZSB1c2VkLCB0aGV5IHdpbGwgYm90aCBzaG93IHVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIHN1cHBvcnQgdHdvIHdheSBkYXRhIGJpbmRpbmcgb24gdmlzaWJsZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhpcyBkaWFsb2cgYmxvY2tzIHRoZSByZXN0IG9mIHRoZSBwYWdlIG9yIG5vdCB3aGVuIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1vZGFsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlcmUncyBhbiB4IGF0IHRoZSB0b3AgcmlnaHQgdGhhdCBtYWtlcyB0aGUgZGlhbG9nIGNsb3NhYmxlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaWFsb2cuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGRpYWxvZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgY29tcG9uZW50LiBVc3VhbGx5IGNvbnRhaW5zIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERpYWxvZ0hlYWRlckNvbXBvbmVudCkgaGVhZGVyOiBEaWFsb2dIZWFkZXJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgZm9vdGVyLiBVc3VhbGx5IGNvbnRhaW5zIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERpYWxvZ0Zvb3RlckNvbXBvbmVudCkgZm9vdGVyOiBEaWFsb2dGb290ZXJDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gMzAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoaXMgZGlhbG9nLlxuICAgICAqL1xuICAgIG9wZW4oKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuXG4gICAgICAgIC8vIHZpc2libGUgaXMgYSAyLXdheSBiaW5kaW5nIHZhcmlhYmxlLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgZGlhbG9nXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG5cbiAgICAgICAgLy8gSW1wb3J0YW50IHRvIG1ha2Ugc3VyZSBjaGFuZ2UgaXMgc2V0IG9uIHBhcmVudCBiaW5kaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YXJpYWJsZSBhbmQgZGlhbG9nIG9wZW4vY2xvc2Ugc3RhdGUgY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBzeW5jIGFuZCB3ZSB3b3VsZG4ndCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgZGlhbG9nIGhhdmUgaGVhZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzSGVhZGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5oZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBkaWFsb2cgaGF2ZSBmb290ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNGb290ZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmZvb3Rlcik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtEaWFsb2dDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0hlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0Zvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nTW9kdWxlfSBmcm9tICdwcmltZW5nL2RpYWxvZyc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dGb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIE1vZGFsQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dGb290ZXJDb21wb25lbnQsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0RpYWxvZ01vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgU2tpcFNlbGYsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgRW52aXJvbm1lbnQsXG4gICAgZXF1YWxzLFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0FycmF5LFxuICAgIGlzQmxhbmssXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1ByZXNlbnQsXG4gICAgTGlzdFdyYXBwZXJcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Nob29zZXJTZWxlY3Rpb25TdGF0ZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZSc7XG5pbXBvcnQge0Nob29zZXJTdGF0ZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLXN0YXRlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Nob29zZXJEYXRhU291cmNlfSBmcm9tICcuLi9jaG9vc2VyL2Nob29zZXItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEQVRBX1NPVVJDRX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5cblxuLyoqXG4gKiBDb252ZW5pZW50IHdyYXBwZXIgY2xhc3MgYXJvdW5kIGNvbnRyb2xzIHN1Y2ggYXMgcmFkaW9idXR0b25zLCBkcm9wZG93biwgY2hlY2tib3hlcyxcbiAqIENob29zZXIuIFRoZSB0eXBlIG9mIHRoZSBjaG9vc2VyIG1heSBiZSBkZXRlcm1pbmVkIGR5bmFtaWNhbGx5IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgaXRlbXMgaW5cbiAqIHRoZSBkYXRhIHNvdXJjZSBsaXN0LCBvciBjYW4gYmUgc3BlY2lmaWVkIGV4cGxpY2l0bHkgdmlhIHRoZSBcInR5cGVcIiBiaW5kaW5nLlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWdlbmVyaWMtY2hvb3NlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdnZW5lcmljLWNob29zZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydnZW5lcmljLWNob29zZXIuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBHZW5lcmljQ2hvb3NlckNvbXBvbmVudCl9LFxuICAgICAgICB7cHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgR2VuZXJpY0Nob29zZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogT3JkZXJlZCBsaXN0IG9mIGl0ZW1zIGFzc2lnbmFibGUgdG8gdGhlIGtleSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdGhpcyBjb250cm9sIGlzIGJlaW5nIGFzc2lnbmVkIHRvLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0OiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgZmllbGQgcGF0aCB0aGlzIGNvbnRyb2wgaXMgYmVpbmcgYXNzaWduZWQgdG8uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBrZXk6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgaW4gcGxhY2Ugb2YgTElTVCBiaW5kaW5nIHRvIHJldHJpZXZlIGEgbGlzdCBiYXNlZCBvbiB0aGUgQ2hvaWNlU291cmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc3RpbmF0aW9uQ2xhc3M6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCB3aGVuIHJldHJpZXZpbmcgY2hvaWNlU291cmNlIGJ5IGRlc3RpbmF0aW9uIGNsYXNzIGFuZCB0aGlzIGFyZSBleHRyYSBwYXJhbXMgdGhhdCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIG5hcnJvdyB0aGUgbWF0Y2hpbmcgb3IgdG8gcGFzcyBwYXJhbWV0ZXJzIGludG8gQ2hvaWNlU291cmNlIHByb3ZpZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjaG9pY2VQcm92aWRlclBhcmFtczogTWFwPHN0cmluZywgYW55PjtcblxuXG4gICAgLyoqXG4gICAgICogIElzIHRoaXMgYSBMaXN0IHByb3BlcnR5LCBvciBhIHRvLW9uZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG11bHRpc2VsZWN0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIHN0eWxlIG9mIGNob29zZXIgdG8gdXNlIChSYWRpbywgQ2hlY2tib3gsIERyb3Bkb3duLCBDaG9vc2VyKVxuICAgICAqICBEZWZhdWx0cyBiYXNlZCBvbiBjYXJkaW5hbGl0eSBvZiB0aGUgbGlzdCBhbmQgd2hldGhlciBpdCdzIG11bHRpU2VsZWN0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBjdXN0b20ga2V5LiBpbiBvcmRlciB0byBtYWtlIHRoaXMgd29yayB3ZSBuZWVkIHRvIGludHJvZHVjZSBjdXN0b20gPHRlbXBsYXRlcz4gZm9yXG4gICAgICogYWxsIHRoaXMgY2hvb3NlciB0eXBlc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheUtleTogc3RyaW5nO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gICogIFNob3VsZCB3ZSBhdHRlbXB0IGEgbWF0Y2ggYXMgdGhleSB0eXBlIChhZ2FpbnN0IHRoZSBmdWxsIGxpc3QpXG4gICAgLy8gICovXG4gICAgLy8gQElucHV0KClcbiAgICAvLyBhbGxvd0Z1bGxNYXRjaE9uSW5wdXQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVuZGVyZWQgYXMgZmlyc3QgdmFsdWUgaW4gdGhlIGRyb3Bkb3duIHdoaWNoIGxldCB0aGUgdXNlciB0byBtYWtlICdubyBzZWxlY3Rpb24nXG4gICAgICogZnJvbSBhdmFpbGFibGUgbGlzdCBvZiB2YWx1ZXMuIFdoZW4gdGhpcyBvcHRpb24gaXMgYWN0aXZlIGFuZCB1c2UgbWFrZSB0aGlzIHNlbGVjdGlvbiB3ZVxuICAgICAqIHNhdmUgYSBOVUxMIHZhbHVlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub1NlbGVjdGlvblN0cmluZzogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmljIENob29zZXIgd29ya3MgZGlyZWN0bHkgd2l0aCBvYmplY3QgYW5kIGl0cyByZWZlcmVuY2VzIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGlzXG4gICAgICoga2V5cGF0aCB0byBiZSBhYmxlIHRvIHNldC9nZXQgdmFsdWUgZnJvbSB0YXJnZXQgb3IgcGFyZW50IG9iamVjdFxuICAgICAqL1xuICAgIGtleVBhdGg6IEZpZWxkUGF0aDtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHVibGljIGRhdGFTb3VyY2U6IENob29zZXJEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMub2JqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSAoPGFueT50aGlzLl92aWV3Q29udGFpbmVyLmluamVjdG9yKS52aWV3LmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlQYXRoID0gbmV3IEZpZWxkUGF0aCh0aGlzLmtleSk7XG4gICAgICAgIGxldCBkZWZhdWx0RGF0YVByb3ZpZGVyID0gbnVsbDtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIGRlZmF1bHREYXRhUHJvdmlkZXIgPSB0aGlzLmRhdGFTb3VyY2UuZGF0YVByb3ZpZGVycy5maW5kKHRoaXMubGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0RGF0YVByb3ZpZGVyID0gdGhpcy5kYXRhU291cmNlLmRhdGFQcm92aWRlcnMuZmluZCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByb2plY3RlZFNpemUgPSBkZWZhdWx0RGF0YVByb3ZpZGVyLmV4cGVjdGVkQ291bnQodGhpcy5jaG9pY2VQcm92aWRlclBhcmFtcyk7XG4gICAgICAgIHRoaXMuaW5pdFR5cGUocHJvamVjdGVkU2l6ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ0Nob29zZXInKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAgICAgICAgICAgICAgICBkYXRhUHJvdmlkZXI6IGRlZmF1bHREYXRhUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gICAgICAgICAgICAgICAgbG9va3VwS2V5OiB0aGlzLmRpc3BsYXlLZXksXG4gICAgICAgICAgICAgICAgc3RhdGU6IG5ldyBDaG9vc2VyU3RhdGUobmV3IEdDQ2hvb3NlclN0YXRlKHRoaXMpLCB0aGlzLm11bHRpc2VsZWN0KSxcbiAgICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGRvIHdlIG5lZWQgdG8gcmVhZCB0aGlzIHZhbHVlIGluIGFzeW5jP1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gZGVmYXVsdERhdGFQcm92aWRlci5kYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMudmFsaWRhdGVSZXF1aXJlZCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5ub1NlbGVjdGlvblN0cmluZyA9IHRoaXMuaTE4bi5pbnN0YW50KCdXaWRnZXRzLmdjaG9vc2VyLm5vU2VsU3RyaW5nJyk7XG4gICAgICAgICAgICB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nID0gJ1NlbGVjdCBhIEl0ZW0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIEBJbnB1dCB0eXBlIGlzIG5vdCBwYXNzZWQgd2UgdHJ5IHRvIGd1ZXNzIGFuZCBzZWxlY3QgdGhlIGJlc3QgdHlwZSBmb3IgY3VycmVudCBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRUeXBlKHByb2plY3RlZFNpemU6IG51bWJlcilcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gKHByb2plY3RlZFNpemUgPD0gMCB8fCBwcm9qZWN0ZWRTaXplID4gOCkgPyAnQ2hvb3NlcicgOiAnQ2hlY2tib3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAocHJvamVjdGVkU2l6ZSA8PSAwIHx8IHByb2plY3RlZFNpemUgPiAyMCkgPyAnQ2hvb3NlcidcbiAgICAgICAgICAgICAgICAgICAgOiAocHJvamVjdGVkU2l6ZSA8IDYpID8gJ1JhZGlvJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnRHJvcGRvd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIGNlcnRhaW4gcHJvcGVydGllcyB3aGljaCBhcmUgcmVxdWlyZWQgYnkgdGhpcyBjb21wb25lbnQuIEFzIGFscmVhZHkgbWVudGlvbmVkXG4gICAgICogYWJvdmUgR2VuZXJpY0Nob29zZXIgd29ya3Mgd2l0aCByZWZlcmVuY2VzIGFuZCB0aGVmb3JlIHR3byBrZXkgcHJvcGVydGllcyBhcmUgb2JqZWN0IGFuZCBrZXlcbiAgICAgKiBzbyB3ZSBjYW4gYWNjZXNzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHZhbGlkYXRlUmVxdWlyZWQoKVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5vYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNvbnRpbnVlIHdpdGhvdXQgYSBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMua2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGEga2V5IGJpbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmxpc3QpICYmIGlzQmxhbmsodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGhhdmluZyBlaXRoZXIgbGlzdCBvZiB2YWx1ZXMgb3IgZGVzdGluYXRpb25DbGFzcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUpICYmXG4gICAgICAgICAgICAodGhpcy50eXBlICE9PSAnUmFkaW8nICYmIHRoaXMudHlwZSAhPT0gJ0NoZWNrYm94JyAmJiB0aGlzLnR5cGUgIT09ICdEcm9wZG93bicgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgIT09ICdDaG9vc2VyJykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgaW5zdGFudGlhdGUgR2VuZXJpY0Nob29zZXIgIC0gaW52YWxpZCB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRpc3BsYXlLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlLZXkgPSAndG9TdHJpbmcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHdoZW4gZGlzcGxheWluZyB2YWx1ZSBib3RoIGZyb20gcHJpbWl0aXZlIHR5cGUgYXMgd2VsbCBjb21wbGV4IG9iamVjdC4gSWYgeW91IHdhbnQgdG9cbiAgICAgKiBjb250cm9sIGhvdyBpdGVtIGlzIGRpc3BsYXllZCB5b3UgY2FuIHByb3ZpZGUgZGlzcGxheSBrZXksIHdoaWNoIGlzIGNhbiBiZSBhICBtZXRob2Qgb3JcbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHlvdSBhcmUgZGlzcGxheWluZy5cbiAgICAgKlxuICAgICAqIFRvZG86IHRoaW5rIGFib3V0IGZvcm1hdHRlcnMgYXMgd2VsbFxuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheVZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kaXNwbGF5S2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkVmFsdWUgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShpdGVtLCB0aGlzLmRpc3BsYXlLZXkpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUuY2FsbChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBSZXRyaWV2ZSBhIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgcGFyZW50L3RhcmdldCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb24oKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlQYXRoLmdldEZpZWxkVmFsdWUodGhpcy5vYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBzZXQgdmFsdWUgYmFjayB0byB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0aW9uKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmtleVBhdGguc2V0RmllbGRWYWx1ZSh0aGlzLm9iamVjdCwgdmFsdWUpO1xuICAgIH1cblxuXG4gICAgb25TZWxlY3Rpb24odmFsdWU6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoKTtcblxuICAgIH1cbn1cblxuLyoqXG4gKiBHZW5lcmljQ2hvb3NlciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2hvb3NlclNlbGVjdGlvblN0YXRlIHdoaWNoIGlzIHVzZWQgd2hlbiBUeXBlID0gQ2hvb3Nlci5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBHQ0Nob29zZXJTdGF0ZSBleHRlbmRzIENob29zZXJTZWxlY3Rpb25TdGF0ZVxue1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBnQ2hvb3NlcjogR2VuZXJpY0Nob29zZXJDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChzZWxlY3RlZCA9PT0gdGhpcy5pc1NlbGVjdGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0KSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBpbXBsZW1lbnQgc21hcnRlciBhbmQgbW9yZSBnZW5lcmljIHdheSBob3cgd2UgdXNlIGl0IGluIGphdmFcbiAgICAgICAgICAgIC8vIFJlbGF0aW9uc2hpcEZpZWxkLmFkZFRvKF9vYmplY3QsIF9rZXlQYXRoLCBzZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgbXVsdGlSZWw6IEFycmF5PGFueT4gPSB0aGlzLmdDaG9vc2VyLmtleVBhdGguZ2V0RmllbGRWYWx1ZSh0aGlzLmdDaG9vc2VyLm9iamVjdCk7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhtdWx0aVJlbCkpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVJlbCA9IFtdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudChtdWx0aVJlbCkgJiYgIWlzQXJyYXkobXVsdGlSZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJIGNhbiBub3Qgc3RvcmUgbXVsdGlzZWxlY3QgdmFsdWUgaW50byBub24tYXJyYXkgb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG11bHRpUmVsLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbiA9IG11bHRpUmVsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QobXVsdGlSZWwsIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICBsZXQgb2JqZWN0cyA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgICAgICAgICByZXR1cm4gKGlzQmxhbmsob2JqZWN0cykgfHwgTGlzdFdyYXBwZXIuaXNFbXB0eShvYmplY3RzKSkgPyBudWxsIDogTGlzdFdyYXBwZXIubGFzdChcbiAgICAgICAgICAgICAgICBvYmplY3RzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb247XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QgJiYgaXNCbGFuayhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QgJiYgaXNBcnJheShzZWxlY3Rpb24pKSA/IHNlbGVjdGlvbiA6IFtzZWxlY3Rpb25dO1xuICAgIH1cblxuICAgIGlzU2VsZWN0ZWQoc2VsZWN0aW9uOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmNvbnRhaW5zQ29tcGxleCh0aGlzLnNlbGVjdGVkT2JqZWN0cygpLCBzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJWYWx1ZSA9IHRoaXMuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhjdXJWYWx1ZSwgc2VsZWN0aW9uKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzIGZvciBSYWRpb0J1dHRvbiBjb21wb25lbnQgcHJvdmlkaW5nIGNvbnZlbmllbnQgd2F5IHRvIHRvIHJlbmRlciBSYWRpb0J1dHRvbiBHcm91cHNcbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKlxuICogYGBgXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdnZW5kZXItc2VsZWN0b3InICxcbiAqICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwicmJMaXN0VmFsdWVzXCIgW2xheW91dF09XCJsYXlvdXRcIlxuICogICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0ZWRWYWx1ZVwiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uLWxpc3Q+XG4gKiAgICAgIGBcbiAqICAgICAgfSlcbiAqICAgICAgZXhwb3J0IGNsYXNzIEdlbmRlclNlbGVjdG9yQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIHJiTGlzdFZhbHVlczogc3RyaW5nW10gPSBbJ21hbGUnICwgJ2ZlbWFsZScgLCAnb3RoZXInXTtcbiAqICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHN0cmluZyA9ICdvdGhlcic7XG4gKiAgICAgICAgICBsYXlvdXQ6IHN0cmluZyA9ICdzdGFja2VkJztcbiAqXG4gKlxuICogICAgICAgICAgZm9ybUdyb3VwOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqXG4gKlxuICogICAgICAgICAgb25DQkNsaWNrIChldmVudCk6IHZvaWRcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb25DQkNsaWNrID0gJyArIGV2ZW50KTtcbiAqICAgICAgICAgIH1cbiAqXG4gKiAgICAgIH1cbiAqXG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBSQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmFkaW9idXR0b24tbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICdyYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3JhZGlvLWJ1dHRvbi1saXN0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIExJc3Qgb2YgdmFsdWVzIHVzZWQgdG8gcmVuZGVyIHRoZSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIHdoaWNoIHJhZGlvIGJ1dHRvbnMgaXMgc2VsZWN0ZWQgd2hlbiByZW5kZXJlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIHNwZWNpYWwgZXhwcmVzc2lvbiB0byBmb3JtYXQgbGFiZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsRm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVzIGFuIGV2ZW50IHdoZW4gcmFkaW8gYnV0dG9uIGlzIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgbW9kZWwgdG8gbGlzdGVuIGZvciByYWRpbyB2YWx1ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgaXMgZXh0cmFjdGVkIGludG8gYSBtZXRob2Qgc28gaW4gdGhlIGZ1dHVyZSB3ZSBjYW4gcGxheSBob3cgd2Ugd2FudCB0byBkaXNwbGF5IHRoZVxuICAgICAqIHZhbHVlLiBTaW5jZSBJIHdhbnQgdG8gc3VwcG9ydCBmb3JtYXR0ZXJzIGZvciBlYWNoIGNvbXBvbmVudHMgd2UgbWlnaHQgaGF2ZSBhIGNoYW5jZSB0b1xuICAgICAqIGRlY2lkZSBob3cgdGhlIGxhYmVsIHdpbGwgbG9vayBsaWtlLlxuICAgICAqXG4gICAgICovXG4gICAgbGFiZWxWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sYWJlbEZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiB0aGlzIHZlcnNpb24gb2YgY2hlY2tib3hlcyB3ZSBzdGlsbCBleHBlY3Qgb25seSBwcmltaXRpdmUgdHlwZXMuIEtlZXAgdGhpcyBmdW5jdGlvbmFsaXR5XG4gICAgICogaW4gZXh0cmEgbWV0aG9kIHNvIHdlIGNhbiB3b3JrIHdpdGggaXQgZXZlbiBub3cgd2UganVzdCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFja1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICB2YWx1ZShpdGVtOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPbiBOR01vZGVsIGNoYW5nZSByZXRyaWV2ZSBhY3R1YWwgcmVjb3JkIGJhc2VkIG9uIHRoZSBJTkRFWCBhbmQgcHJvcGFnYXRlIGl0IHRvIGJvdGhcbiAgICAgKiBuZ01vZGVsIGFzIHdlbGwgYXMgRm9ybUdyb3VwLlxuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueSA9IHRoaXMubGlzdFt0aGlzLm1vZGVsXTtcblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBjb21wbGV4IG9iamVjdCBzdG9yZSBvbmx5IElOREVYIG51bWJlciBpbiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbChzb3VjZUl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubGlzdC5maW5kSW5kZXgoKGVsZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNvdWNlSXRlbSA9PT0gZWxlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBpbmRleCA9PT0gLTEgPyAwIDogaW5kZXg7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueSA9IHRoaXMubGlzdFt0aGlzLm1vZGVsXTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG5ld01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKG5ld01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIEltcGxlbWVudHMgc3RhbmRhcmQgSFRNTCByYWRpbyBidXR0b24gb24gdG9wIG9mIFByaW1lTkcgd2l0aCBhcmliYSBzdHlsaW5nXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiAxLiBCYXNpYyB1c2FnZSB1c2luZyBuZ01vZGVsIHByZS1zZWxlY3RlZCBmaXJzdCByYWRpb1xuICpcbiAqICBgYGB0c1xuICpcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ2RlbW8tY29tcCcsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKiAgICAgIGBcbiAqICAgICAgfSkqXG4gKiAgICAgIGNsYXNzIEJhc2ljV2l0aE5nTW9kZWxDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgbW9kZWw6IHN0cmluZ1tdID0gWydyZWQnXTtcbiAqXG4gKiAgICAgICAgICBjb25zdHJ1Y3RvcigpXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqXG4gKiAgYGBgXG4gKlxuICpcbiAqIDIuIEJhc2ljIHVzYWdlIHdpdGggZm9ybUdyb3VwXG4gKlxuICpcbiAqIGBgYHRzXG4gKiAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICBzZWxlY3RvcjogJ2RlbW8tY29tcCcsXG4gKiAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgIDxkaXYgW2Zvcm1Hcm91cF09XCJlbnYuY3VycmVudEZvcm1cIj5cbiAqICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcjInXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcjInXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICpcbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgYFxuICogICAgICAgfSlcbiAqICAgICAgIGNsYXNzIEJhc2ljV2l0aEZvcm1Hcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxuICogICAgICAge1xuICogICAgICAgICAgIG1vZGVsOiBzdHJpbmcgPSAnYmx1ZSc7XG4gKlxuICogICAgICAgICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgIG5nT25Jbml0KCk6IHZvaWRcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKiAgICAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtLnJlZ2lzdGVyQ29udHJvbCgnY29sb3IyJywgbmV3IEZvcm1Db250cm9sKHRoaXMubW9kZWwpKTtcbiAqICAgICAgICAgICB9XG4gKlxuICpcbiAqICAgICAgICAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgdGhpcy5tb2RlbFNldCA9IGV2ZW50O1xuICogICAgICAgICAgIH1cbiAqXG4gKiAgICAgICB9XG4gKiAgYGBgYFxuICpcbiAqXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IFJBQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmFkaW9idXR0b24nLFxuICAgIHRlbXBsYXRlVXJsOiAncmFkaW8tYnV0dG9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsncmFkaW8tYnV0dG9uLmNvbXBvbmVudC5zY3NzJ10sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUkFCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhZGlvXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBhIHJhZGlvXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGNsaWNrIGV2ZW50IHdpdGggY3VycnJlbnQgc2VsZWN0ZWQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWwgdG8gY29tdW5pY2F0ZSB3aXRoIHByaW1lTmcgUmFkaW9cbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQgKClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5uYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHJhZGlvIGlzIGNsaWNrZWQuIE5vdCB1c2luZyBQcmltZU5HIGNsaWNrIGV2ZW50IGFzIGl0IGlzIGZpcmVkIGJlZm9yZVxuICAgICAqIHRoZSBtb2RlbCBpcyBjaGFuZ2VkLiBUaGVyZWZvcmUgbmVlZCB0byBsaXN0ZW4gb24gKG5nTW9kZWxDaGFuZ2UpXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk1vZGVsQ2hhbmdlIChuZXdWYWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlICh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtSYWRpb0J1dHRvbkNvbXBvbmVudH0gZnJvbSAnLi9yYWRpby1idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7UmFkaW9CdXR0b25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBSYWRpb0J1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSYWRpb0J1dHRvbkNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdSYWRpb0J1dHRvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7UmFkaW9CdXR0b25MaXN0Q29tcG9uZW50fSBmcm9tICcuL3JhZGlvLWJ1dHRvbi1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25Nb2R1bGV9IGZyb20gJy4uL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtHZW5lcmljQ2hvb3NlckNvbXBvbmVudH0gZnJvbSAnLi9nZW5lcmljLWNob29zZXIuY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveExpc3RNb2R1bGV9IGZyb20gJy4uL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hvb3Nlck1vZHVsZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25MaXN0TW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0Ryb3Bkb3duTW9kdWxlfSBmcm9tICcuLi9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveExpc3RNb2R1bGUsXG4gICAgICAgIEFXQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBHZW5lcmljQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgR2VuZXJpY0Nob29zZXJDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFXR2VuZXJpY0Nob29zZXJNb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0VudGl0eSwgaXNCbGFuaywgaXNFbnRpdHksIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T3V0bGluZUZvckNvbXBvbmVudCwgT3V0bGluZU5vZGV9IGZyb20gJy4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcblxuLyoqXG4gKiBPdXRsaW5lU3RhdGUgaXMgdGhlIGtleSBnbHVpbmcgcGFydCBmb3IgdGhlIE91dGxpbmVGb3IgYW5kIE91dGxpbmVDb250cm9sbGVyIGNvbXBvbmVudHMuIEl0XG4gKiBob2xkcyBhbGwgaW1wb3J0YW50IGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudCBvdXRsaW5lIHRyZWUgYW5kIG1hbmFnZXMgZXhwYW5zaW9uIHN0YXRlcyBpbiBmb3JtXG4gKiBvZiBzbyBjYWxsZWQgZXhwYW5zaW9uUGF0aCBhbmQgZXhwYW5zaW9uU3RhdGVzXG4gKlxuICogV2UgbmVlZCB0byBoYXZlIGEgd2F5IGhvdyB0byB3b3JrIHdpdGggZ2VuZXJpYyBkYXRhIHN0cnVjdHVyZSBpbiBvcmRlciBub3QgdG8gaG9sZCBVSSBzcGVjaWZpY1xuICogaW5mb3JtYXRpb24gb24gdGhlIGRvbWFpbiBvYmplY3QgbW9kZWwganVzdCBsaWtlIHdlIGhhZCBpdCBiZWZvcmUsIHdoZXJlIHdlIGhhZCBhbiBpbnRlcmZhY2VcbiAqIGNhbGxlZCBPdXRsaW5lTm9kZSwgd2l0aCBmaWVsZHMgKGV4cGFuZGVkLCBzZWxlY3RlZCwgZXRjLi4gKVxuICpcbiAqXG4gKiBgZXhwYW5zaW9uUGF0aGA6IEhvbGRzIGFuIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBhbmQgZXhwYW5kZWQgbm9kZXMuIFRoaXMgaXMgZmlsbGVkIGJ5XG4gKiBPdXRsaW5lQ29udHJvbGxlci5cbiAqXG4gKlxuICogSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBFbnRpdHkgb3IgYW55dGhpbmcgdGhhdCBoYXMgaWRlbnRpdHkgdGhlbiB3ZSBoYXZlIGVhc2llciBzaXR1YXRpb24gYXMgd2VcbiAqIGNhbiBhc2sgZm9yIElEIGFuZCBpdCBpcyBtb3JlIGVmZmljaWVudCBmb3Igc2VyaWFsaXphdGlvblxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgT3V0bGluZVN0YXRlXG57XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGFuZCBleHBhbmRlZCBub2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZXhwYW5zaW9uUGF0aDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBhbGxvd1NlbGVjdGlvbmAgaXMgZW5hYmxlZCBvbiBPdXRsaW5lQ29udHJvbCBpdCBzYXZlZCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSB0byBiZVxuICAgICAqIGFibGUgbGF0ZXIgb24gYXBwbHkgc29tZSBzdHlsaW5nIGFuZCBicm9hZGNhc3QgdGhpcyBzZWxlY3Rpb24gb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNlbGVjdGVkSXRlbTogYW55O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBNYXBzIG9iamVjdCByZWZlcmVuY2UgdG8gYm9vbGVhbiB2YWx1ZXMsIHdoZXJlIFRSVUUgbWVhbnMgRVhQQU5ERUQsIEZBTFNFIGNvbGxhcHNlZFxuICAgICAqXG4gICAgICovXG4gICAgZXhwYW5zaW9uU3RhdGVzOiBNYXA8YW55LCBib29sZWFuPjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG91dGxpbmUgaXMgcmVuZGVyZWQgZm9yIGZpcnN0IHRpbWUgb3IgcmUtcmVuZGVyZWQgYW5kIHdlIHNldCBkZWZhdWx0IHZhbHVlIGZvciB0aGVcbiAgICAgKiBleHBhbnNpb25TdGF0ZXMuIFRoaXMgd2F5IHdlIGNhbiBwcmV0dHkgZWFzaWx5IGV4ZWN1dGUgQ29sbGFwc2VBbGwsIEV4cGFuZEFsbFxuICAgICAqXG4gICAgICovXG4gICAgaXNFeHBhbmRlZEFsbDogYm9vbGVhbiA9IGZhbHNlOyAvLyBjb2xsYXBzZWRcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSG9sZHMgY3VycmVudCBsZXZlbCBkdXJpbmcgdHJlZSBub2RlIHJlbmRlcmluZyBzbyB3ZSBjYW4gYXBwbHkgY29ycmVjdCBpbmRlbnRhdGlvblxuICAgICAqXG4gICAgICovXG4gICAgY3VycmVudExldmVsOiBudW1iZXIgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZHVyaW5nIGEgdG9nZ2xlIGFjdGlvbiB0byByZWNvcmQgY3VycmVudCBzZWxlY3Rpb24gcGF0aC5cbiAgICAgKlxuICAgICAqL1xuICAgIGN1cnJlbnRQYXRoOiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogR2xvYmFsbHkgc2hhcmVkIHByb3BlcnR5XG4gICAgICovXG4gICAgb3V0bGluZUZvcjogT3V0bGluZUZvckNvbXBvbmVudDtcblxuXG4gICAgY29uc3RydWN0b3IgKClcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvciB0aGUgY29sbGFwc2VBbGwgYW5kIGV4cGFuZEFsbCB3ZSBhcmUgdXNpbmcgc2ltcGxlIG1lY2hhbmlzbSB3aGVyZSB3ZSBjbGVhbiB1cCBhbGxcbiAgICAgKiBzZWxlY3Rpb24gYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgZXhwYW5kIHN0YXRlLCB0aGlzIHdoZXkgaXNFeHBhbmQgbWV0aG9kIHJldHVybnMgdGhlIHNhbWVcbiAgICAgKiBzdGF0ZSBmb3IgYWxsIGl0ZW1zXG4gICAgICovXG4gICAgY29sbGFwc2VBbGwgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vdXRsaW5lRm9yKSAmJlxuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcblxuICAgICAgICAgICAgLy8gZm9yIHRoaXMgY2FzZSB3ZSBjb2xsYXBzZSBhbGwgYnV0IHJvb3Qgbm9kZXNcbiAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IubGlzdC5mb3JFYWNoKChpdGVtOiBPdXRsaW5lTm9kZSkgPT5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZXMoaXRlbS5jaGlsZHJlbiB8fCBbXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzKHRoaXMub3V0bGluZUZvci5saXN0IHx8IFtdLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0V4cGFuZGVkQWxsID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwYW5kQWxsICgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvcikgJiZcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzKHRoaXMub3V0bGluZUZvci5saXN0LCB0cnVlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRXhwYW5kZWRBbGwgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgZ2V0IGV4cGFuc2lvblBhdGggKCk6IGFueVtdXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLl9leHBhbnNpb25QYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5fZXhwYW5zaW9uUGF0aCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25QYXRoO1xuICAgIH1cblxuXG4gICAgc2V0IGV4cGFuc2lvblBhdGggKHZhbHVlOiBhbnlbXSlcbiAgICB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvblBhdGggPSB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLl9leHBhbnNpb25QYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvblBhdGguZm9yRWFjaCgoaXRlbTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKGl0ZW0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHRvZ2dsZUV4cGFuc2lvbiAoY3VycmVudFBhdGg6IGFueVtdLCBjaGlsZHJlbj86IGFueVtdKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNCbGFuayhjdXJyZW50UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXRlbSA9IExpc3RXcmFwcGVyLmxhc3QoY3VycmVudFBhdGgpO1xuICAgICAgICBsZXQgaXRlbUNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9ICF0aGlzLmlzRXhwYW5kZWQoaXRlbSk7XG4gICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUoaXRlbSwgbmV3U3RhdGUpO1xuXG4gICAgICAgIGlmICghbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUxhc3QoY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlcyhpdGVtQ2hpbGRyZW4sIG5ld1N0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uUGF0aChjdXJyZW50UGF0aCk7XG4gICAgfVxuXG4gICAgdXBkYXRlTm9kZXMgKG5vZGVzOiBhbnlbXSwgbmV3U3RhdGU6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChjaGlsZDogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLm91dGxpbmVGb3IuY2hpbGRyZW5Gb3JJdGVtKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoaXRlbXMpICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzKGl0ZW1zLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKGNoaWxkLCBuZXdTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldEV4cGFuc2lvblN0YXRlIChpdGVtOiBhbnksIGlzRXhwYW5kZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBFdmVuIGZvciB0cmVlIG1vZGUgZm9ybWF0IHNhdmUgdGhlIHN0YXRlIHNvIHdlIGNhbiB1c2UgaXQgbGF0ZXIgb24gaW4gY2FzZSBvYmplY3RcbiAgICAgICAgLy8gcmVmZXJlbmNlcyBnZXRzIG1lZXNlZCB1cFxuICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yICYmXG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgKDxPdXRsaW5lTm9kZT5pdGVtKS5pc0V4cGFuZGVkID0gaXNFeHBhbmRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgICAgIGlmIChpc0V4cGFuZGVkID09PSB0aGlzLmlzRXhwYW5kZWRBbGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuc2V0KGtleSwgKGlzRXhwYW5kZWQpID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIGltcHJvdmUgc3RhdGUgcGVyc2lzdGluZyBsZXRzIGNoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gT2JqZWN0IHRoYXQgaGFzIElkZW50aXR5XG4gICAgICogc28gd2UgY2FuIGV4dHJhY3QgYW4gSUQgb3RoZXJ3aXNlIHVzZSBvYmplY3QgdG8gY29tcGFyZSBieSByZWZlcmVuY2VcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpdGVtVG9LZXkgKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzRW50aXR5KGl0ZW0pID8gKDxFbnRpdHk+aXRlbSkuaWRlbnRpdHkoKSA6IGl0ZW07XG4gICAgfVxuXG5cbiAgICBzZXRFeHBhbnNpb25QYXRoIChpdGVtczogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblBhdGggPSBpdGVtcztcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKChub2RlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUobm9kZSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzRXhwYW5kZWQgKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vdXRsaW5lRm9yKSAmJlxuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAoPE91dGxpbmVOb2RlPml0ZW0pLmlzRXhwYW5kZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXhwYW5zaW9uU3RhdGVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNFeHBhbmRlZEFsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGFuc2lvblN0YXRlcy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2FuaW1hdGUsIEFuaW1hdGlvbkJ1aWxkZXIsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlcn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIElkZW50aXR5LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi9vdXRsaW5lLXN0YXRlJztcblxuXG4vKipcbiAqIFRoaXMgaW50ZXJmYWNlIHJlcHJlc2VudCBjb25jcmV0ZSB0cmVlIHN0cnVjdHVyZSBmb3IgdGhlIG91dGxpbmUgdHJlZSBtb2RlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3V0bGluZU5vZGUgZXh0ZW5kcyBJZGVudGl0eVxue1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZS5cbiAgICAgKi9cbiAgICBwYXJlbnQ6IE91dGxpbmVOb2RlO1xuXG4gICAgLyoqXG4gICAgICogTm9kZSdzIGNoaWxkcmVuLiBFdmVuIGl0cyBhIGZpZWxkIGl0IGNhbiBiZSBpbXBsZW1lbnRlZCBsYXppbHkgdXNpbmcgZ2V0dGVyIHdoZXJlIGEgdGFyZ2V0XG4gICAgICogb2JqZWN0IGRvZXMgbm90IGltcGxlbWVudCB0aGlzIGFzIGEgcHVibGljIGZpZWxkIGJ1dCBhIGdldHRlciB3aXRoIGNvbnRyb2wgb3ZlciB0aGVcbiAgICAgKiByZXRyaWV2ZWQgbGlzdFxuICAgICAqL1xuICAgIGNoaWxkcmVuOiBPdXRsaW5lTm9kZVtdO1xuXG4gICAgLyoqXG4gICAgICogRGlmZmVyZW50IHN0YXRlcyBmb3Igb3V0bGluZSBOb2RlXG4gICAgICpcbiAgICAgKiBpc0V4cGFuZGVkOiBib29sZWFuOz0gbW92aW5nIG91dCBhcyB0aGlzIGlzIG1hbmFnZWQgYnkgZXhwYW5zaW9uc3RhdGUuXG4gICAgICovXG4gICAgaXNFeHBhbmRlZDogYm9vbGVhbjtcbiAgICBpc1NlbGVjdGVkOiBib29sZWFuO1xuICAgIGlzTWF0Y2g/OiBib29sZWFuO1xuICAgIHJlYWRvbmx5PzogYm9vbGVhbjtcbiAgICB0eXBlPzogc3RyaW5nO1xuICAgIGRyYWdnYWJsZT86IGJvb2xlYW47XG4gICAgZHJvcHBhYmxlPzogYm9vbGVhbjtcbiAgICB2aXNpYmxlPzogYm9vbGVhbjtcblxufVxuXG5cbi8qKlxuICpcbiAqIENoZWNrcyB0eXBlIGZvciBPdXRsaW5lTm9kZVxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3V0bGluZU5vZGUobm9kZTogYW55KTogbm9kZSBpcyBPdXRsaW5lTm9kZVxue1xuICAgIHJldHVybiBpc1ByZXNlbnQobm9kZSkgJiYgaXNQcmVzZW50KCg8T3V0bGluZU5vZGU+bm9kZSkpXG4gICAgICAgICYmIGlzUHJlc2VudCgoPE91dGxpbmVOb2RlPm5vZGUpLnBhcmVudClcbiAgICAgICAgJiYgaXNQcmVzZW50KCg8T3V0bGluZU5vZGU+bm9kZSkuY2hpbGRyZW4pO1xufVxuXG5cbi8qKlxuICogQ3VycmVudGx5IG91dGxpbmUgc3VwcG9ydHMgb25seSB0d28gbW9kZXMgZnJlZSwgd2hlcmUgYXBwbGljYXRpb24gaXMgcmVzcG9uc2libGUgdG8gcmV0cmlldmVcbiAqIGNoaWxkcmVuIGZvciBlYWNoIG5vZGUgYW5kIHRyZWUgd2l0aCBhYm92ZSBPdXRsaW5lTm9kZSBzdHJ1Y3R1cmVcbiAqL1xuZXhwb3J0IHR5cGUgTW9kZWxGb3JtYXQgPSAnZnJlZScgfCAndHJlZSc7XG5cblxuLyoqXG4gKlxuICogT3V0bGluZUZvckNvbXBvbmVudCBpcyBsaWtlIG5nRm9yLCBidXQgZm9yIGhpZXJhcmNoaWNhbCAob3V0bGluZS90cmVlKSBzdHJ1Y3R1cmVzIC0tIGkuZS4gaW5cbiAqIHRob3NlIGNhc2VzIHdoZXJlIGFuIGl0ZW0gbWF5IGhhdmUgY2hpbGRyZW4uXG4gKlxuICpcbiAqIEl0IHVzZXMgb3V0bGluZSBgPGF3LW91dGxpbmUtY29udHJvbD5gIHRvIHByb3ZpZGUgZXhwYW5kaW5nIGZ1bmN0aW9uYWxpdHksIGluZGVudGF0aW9uXG4gKiBhbmQgb3RoZXIgdGhpbmdzLlxuICpcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCBoYXMgbWluaW1hbCBzdHlsaW5nIHRvIG1ha2Ugc3VyZSBpdCBjYW4gYmUgY2hhbmdlZCBlYXNpbHkuXG4gKlxuICogIyMjIEV4YW1wbGUgcmVuZGVyaW5nIHRyZWUgc2VjdGlvbiwgd2hlcmUgYmFzZWQgb24gdGhlIHR5cGUgd2UgZm9ybWF0IHRoZSBvdXQgcGx1c1xuICogZm9yIHRoZSBtYWluIHJvb3Qgc2VjdGlvbiB3ZSBhbHdheXMgcmVuZGVyIGxpdHRsZSBwb3B1cCBtZW51LlxuICpcbiAqIGBgYFxuICpcbiAqICAgPGF3LW91dGxpbmUtZm9yIFtsaXN0XT1cImxpc3RcIiBbaGFzQ2hpbGRyZW5dPVwiaGFzQ2hpbGRyZW5cIj5cbiAqXG4gKiAgICAgICA8bmctdGVtcGxhdGUgI291dGxpbmUgbGV0LWl0ZW0+XG4gKlxuICogICAgICAgICAgIDxkaXYgY2xhc3M9XCJteS1zZWN0aW9uXCI+XG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvdXRsaW5lXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8YXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cIml0ZW0udHlwZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nU3dpdGNoQ2FzZV09XCIndGV4dCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhcy1wYXJhZ3JhZlwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgbmdTd2l0Y2hEZWZhdWx0PlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3tpdGVtPy5jb250ZW50fX1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICA8L2F3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmlsdGVyc1wiICpuZ0lmPVwiaXRlbS50eXBlID09PSAnc2VjdGlvbidcIiA+XG4gKlxuICogICAgICAgICAgICAgICAgICAgPGF3LWhvdmVyLWNhcmQgW2xpbmtUaXRsZV09XCInRmlsdGVyIEl0ZW1zJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgIDxhdy1saXN0IFtsaXN0XT1cImZpbHRlckl0ZW1zXCIgW2JvcmRlcmxlc3NdPVwidHJ1ZVwiPjwvYXctbGlzdD5cbiAqICAgICAgICAgICAgICAgICAgIDwvYXctaG92ZXItY2FyZD5cbiAqXG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgIDwvZGl2PlxuICogICAgIDwvbmctdGVtcGxhdGU+YFxuICogICA8L2F3LW91dGxpbmUtZm9yPlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBXZSBjYW4gdXNlIGl0IGFsc28gaW4gZW1iZWRkZWQgbW9kZSB3aGVyZSB3ZSB1c2UgdGhlIGBhd091dGxpbmVGb3JgIGRpcmVjdGl2ZVxuICpcbiAqICMjIEV4YW1wbGVcbiAqXG4gKlxuICogYGBgYFxuICogIDx0YWJsZSAgY2xhc3M9XCJ0cmVlLXRhYmxlXCIgPlxuICogICAgICA8dGhlYWQ+XG4gKiAgICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICAgPHRoPk5hbWU8L3RoPlxuICogICAgICAgICAgICAgIDx0aD5UeXBlPC90aD5cbiAqICAgICAgICAgIDwvdHI+XG4gKiAgICAgIDwvdGhlYWQ+XG4gKiAgICAgIDx0Ym9keSAjb29vMiBhd091dGxpbmVGb3IgW2xpc3RdPVwibGlzdFwiXG4gKiAgICAgICAgICAgICBbaGFzQ2hpbGRyZW5dPVwiaGFzQ2hpbGRyZW5cIlxuICogICAgICAgICAgICAgY2xhc3M9XCJvdXRsaW5lLXRhYmxlXCJcbiAqICAgICAgPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1pdGVtPlxuICogICAgICAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiaXRlbS1uYW1lIG91dGxpbmUtYW5pbWF0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pjxhdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAge3tpdGVtPy5jb250ZW50fX1cbiAqICAgICAgICAgICAgICAgICAgICAgIDwvYXctb3V0bGluZS1jb250cm9sPjwvZGl2PlxuICogICAgICAgICAgICAgICAgICA8L3RkPlxuICogICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJpdGVtLXR5cGUgb3V0bGluZS1hbmltYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+e3tpdGVtLnR5cGV9fTwvZGl2PlxuICogICAgICAgICAgICAgICAgICA8L3RkPlxuICogICAgICAgICAgICAgIDwvdHI+XG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICA8L3Rib2R5PlxuICogIDwvdGFibGU+XG4gKlxuICogYGBgXG4gKlxuICogSSB3YXMgdGhpbmtpbmcgbWF5YmUgZm9yIGZpcnN0IHRpbWUgd2UgZG9uJ3QgbmVlZCB0aGUgc2FtZSBhbmltYXRpb24gbGlrZSBleHBhbmRpbmcgYW5kXG4gKiBjb2xsYXBzaW5nLiBNYXliZSB3ZSBuZWVkIGZhZGUtaW4uIEluIHN1Y2ggY2FzZSBJIHdvdWxkIHByb2JhYmx5IGFwcGx5IEBzZWN0aW9uIGFuaW0gb25seVxuICogb24gaXRlbXMgd2hlcmUgbGV2ZWwgPiAwIChpbiB0aGUgdGVtcGxhdGUgSSBrZWVwIGxldmVscykgYW5kIGlmIGxldmVsID09IDAgdGhlbiBJIHdvdWxkXG4gKiBleGVjdXRlIHRoZSBzYW1lIHJlbmRlcmluZyBqdXN0IHdpdGhvdXQgW0BzZWN0aW9uXVxuICpcbiAqXG4gKiBUb2RvOiBUaGluayBhYm91dCBob3cgdG8gZG8gYW5pbWF0aW9uIGZvciB0aGUgdGFibGUgY2FzZS4gTXVzdCBhbHNvIHdyaXRlIHVuaXRlc3QgLSBkdWUgdG9cbiAqIEFyaWJhTGl2ZSBhZ2dyZXNzaXZlIHNjaGVkdWxlIHdlIGFyZSBza2lwcGluZyB0aGVtIGZvciBub3dcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb3V0bGluZS1mb3IsIFthd091dGxpbmVGb3JdJyxcbiAgICB0ZW1wbGF0ZVVybDogJ291dGxpbmUtZm9yLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnb3V0bGluZS1mb3IuY29tcG9uZW50LnNjc3MnXSxcblxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignc2VjdGlvbicsIFtcbiAgICAgICAgICAgIHN0YXRlKCcqJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICdvdmVyZmxvdy15JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcqJyxcbiAgICAgICAgICAgICAgICAnb3BhY2l0eSc6ICcxJ1xuXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzAnLFxuICAgICAgICAgICAgICAgICdvcGFjaXR5JzogJzAnLFxuICAgICAgICAgICAgICAgICdvdmVyZmxvdy15JzogJ2hpZGRlbidcblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgYW5pbWF0ZSgnMjAwbXMgZWFzZS1vdXQnKSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBhbmltYXRlKCcyMDBtcyBlYXNlLWluJykpXG4gICAgICAgIF0pLFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgT3V0bGluZUZvckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgaXRlbXMgdGhhdCBuZWVkcyB0byBiZSByZW5kZXJlZC4gSXQgZG9lcyBub3QgaGF2ZSB0byBpbiBoaWVyYXJjaGljYWwgb3JkZXIgb3Igd2VcbiAgICAgKiBsZWF2ZSBpdCB1cCB0byB0aGUgYXBwbGljYXRpb24gdG8gZGVjaWRlIGFib3V0IHRoZSBzdHJ1Y3R1cmUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0PzogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBjb21wb25lbnQgbm90IHRvIHJlbmRlciBleHBhbnNpb24gY29udHJvbCwgaW4gc3VjaCBjYXNlIHdlIGV4cGFuZEFsbCBhcyBhXG4gICAgICogZGVmYXVsdCBiZWhhdmlvclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93RXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gbWV0aG9kIHByb3ZpZGVkIGJ5IGFwcGxpY2F0aW9uIHRvIHJldHJpZXZlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGN1cnJlbnQgaXRlbS4gSWZcbiAgICAgKiBjaGlsZHJlbiBpcyB1bmRlZmluZWQgdGhlbiwgZGVmYXVsdCAnY2hpbGRyZW4nIGZpZWxkIGlzIHVzZWQgPGN1cnJlbnRJdGVtPi5jaGlsZHJlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hpbGRyZW46ICh2YWx1ZTogYW55KSA9PiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT3B0aW9uIHRvIGNvbmRpdGlvbmFsbHkgcmVuZGVyIG9ubHkgaXRlbXMgdGhhdCBhcmUgc2F0aXNmeWluZyBmaWx0ZXIgY29uZGl0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpbHRlck91dDogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGFsbCB0cmVlIG5vZGVzLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHBhbmRBbGw6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogIE1hbmFnZXMgdGhlIHN0YXRlIGZvciB0aGUgT3V0bGluZSBjb21wb25lbnQuIExhdGVyIG9uIHdlIGNhbiBwcm92aWRlIGVhc2llciB3ZSBob3cgdG9cbiAgICAgKiAgaW5pdGlhbGl6ZSBhbmQgc2V0IHNlbGVjdGlvblBhdGhzIGFuZCBzZWxlY3Rpb25TdGF0ZXMgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RhdGU6IE91dGxpbmVTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0IGluZGVudGF0aW9uIHNpemUgdG8gYmUgdXNlZCBmb3IgZWFjaCBsZXZlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnRhdGlvblBlckxldmVsOiBudW1iZXIgPSAyNTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB0ZW1wbGF0ZSBpcyBvdXRzaWRlIG9mIHRoZSBvdXRsaW5lRm9yXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHRlcm5hbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gY3VycmVudCBvYmplY3QgdXNpbmcgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSWRlbnRpZmllcyBjdXJyZW50IG1vZGVsIG1vZGUuXG4gICAgICpcbiAgICAgKiBXZSByZWNvZ25pemUgdHdvIG1vZGVzOlxuICAgICAqXG4gICAgICogRnJlZSAtIEFwcGxpY2F0aW9uIG5lZWRzIHRvIGltcGxlbWVudCBhIGNoaWxkcmVuIG1ldGhvZCB0byByZXRyaWV2ZSBhIGxpc3Qgb2YgY2hpbGRyZW4gZm9yXG4gICAgICogZWFjaCBub2RlIGFuZCBmb3JtYXQgaXMgcHJldHR5IG11Y2ggdXB0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogVHJlZSAtIHRoaXMgaXMgbW9yZSByZXN0cmljdGl2ZSB3aGVyZSB3ZSBoYXZlIGNvbmNyZXRlIGRhdGEgc3RydWN0dXJlXG4gICAgICogaW50ZXJmYWNlIHRoYXQgbmVlZHMgdG8gYmUgZm9sbGVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBpbnN0ZWFkIG9mIHBhc3NpbmcgZm9ybWF0IGJpbmRpbmcgdHJ5IHRvIGxvb2sgaW50byB0aGUgbGlzdCB0byBzZWUgd2hhdCB0eXBlIHNvXG4gICAgICogd2UgZG9udCBtYWtlIGl0IG1hbmRhdG9yeVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JtYXQ6IE1vZGVsRm9ybWF0ID0gJ2ZyZWUnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgdG8gcHVzaCBjdXJyZW50IHNlbGVjdGVkIEl0ZW0gdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkl0ZW1TZWxlY3RlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBpcyB0cmlnZ2VyZWQgYnkgT3V0bGluZUNvbnRyb2wgd2hlbiBub2RlIGlzIGV4cGFuZGVkIG9yIGNvbGxhcHNlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25FeHBhbmRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wbGF0ZSB0byB1c2Ugb24gYXBwbGljYXRpb24gbGV2ZWwgdG8gcmVuZGVyIGluZGl2aWR1YWwgaXRlbXNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdvdXRsaW5lJylcbiAgICBjb250cm9sVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBWaWV3Q2hpbGQoJ3JlbmRlcmVkSXRlbScpXG4gICAgb3V0bGluZUl0ZW06IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsc1xuICAgICAqXG4gICAgICogY3VycmVudEl0ZW0gYW5kIHBhcmVudEl0ZW0gYXJlIHVzZWQgdG8gY2FwdHVyZSBjdXJyZW50IHByb2Nlc3NlZCBpdGVtIG9mIG5nRm9yLiBUaGlzIGlzXG4gICAgICogc2V0IGJ5IGRpcmVjdGl2ZSBgSW5pdE5lc3RpbmdEaXJlY3RpdmVgXG4gICAgICpcbiAgICAgKiBhbmltYXRpb25JblByb2dyZXNzOiB1c2VkIGJ5IGFuaW1hdGlvbiBlbmdpbmUgdG8gbWFrZSBzdXJlIHdlIGRvbnQgZG8gYW55IGFjdGlvbnMgd2hpbGVcbiAgICAgKiBhbmltYXRpb24gaXMgaW4gdGhlIHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBlbWJlZGRlZDogSW5kaWNhdGVzIHRoYXQgd2UgYXJlIHVzaW5nIGRpcmVjdGl2ZSBzbyBpdCB3aWxsIG5vdCBoYXZlIGRlZmF1bHQgY29tcG9uZW50XG4gICAgICogd3JhcHBlclxuICAgICAqXG4gICAgICovXG4gICAgY3VycmVudEl0ZW06IGFueTtcbiAgICBwYXJlbnRJdGVtOiBhbnk7XG4gICAgYW5pbWF0aW9uSW5Qcm9ncmVzczogYm9vbGVhbjtcbiAgICBlbWJlZGRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRmxhZyB0aGF0IHRlbGxzIHVzIHRoYXQgY29tcG9uZW50IGlzIGZ1bGx5IHJlbmRlcmVkXG4gICAgICpcbiAgICAgKi9cbiAgICB2aWV3SW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBwcml2YXRlIGJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgT3V0bGluZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZS5vdXRsaW5lRm9yKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vdXRsaW5lRm9yID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZEFsbCkge1xuICAgICAgICAgICAgdGhpcy5zaG93RXhwYW5zaW9uQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5pc0V4cGFuZGVkQWxsID0gdGhpcy5leHBhbmRBbGw7XG5cbiAgICAgICAgLy8gaW4gY2FzZSB3ZSB3YW50IHRvIHJlbmRlciBjb250ZW50IG9mIHRyZWUgb3V0c2lkZSBvZiBvdXRsaW5lRm9yXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5leHRlcm5hbFRlbXBsYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sVGVtcGxhdGUgPSB0aGlzLmV4dGVybmFsVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtYmVkZGVkID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdhd291dGxpbmVmb3InKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcbiAgICB9XG5cbiAgICBpc1RyZWVNb2RlbEZvcm1hdCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQgPT09ICd0cmVlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRlbXBsYXRlIGFuZCBPdXRsaW5lQ29udHJvbCB0byBpZGVudGlmeSB3aGljaCBpdGVtIGlzIGV4cGFuZGVkIGFuZCBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQoaXRlbTogYW55LCBjdXJyZW50TGV2ZWw6IG51bWJlciA9IC0xKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA9PT0gMCAmJiB0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIG92ZXJyaWRlL3Jlc2V0IGZvciByb290IG5vZGVzXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICAgICAgKDxPdXRsaW5lTm9kZT5pdGVtKS5pc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRXhwYW5kZWQoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaW5jZSB3ZSBoYXZlIGN1cnJlbnRseSB0d28gd2F5cyBob3cgdG8gcGFzcyBjaGlsZHJlbiBpdGVtcyB3ZSBuZWVkIGhhdmUgdGhpcyBtZXRob2QgdG9cbiAgICAgKiB1bmlmeSB0aGUgd2F5IGhvdyB3ZSBhY2Nlc3MgaXQuIElmIHdlIHBhc3MgYGNoaWxkcmVuYCBiaW5kaW5nIHdlIHVzZSB0aGlzIGluc3RlYWQsIG90aGVyd2lzZVxuICAgICAqIHdlIGV4cGVjdCBjdXJyZW50IG9iamVjdCB0byBoYXZlIGBjaGlsZHJlbmAgZmllbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGNoaWxkcmVuRm9ySXRlbShpdGVtOiBhbnkpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICg8T3V0bGluZU5vZGU+aXRlbSkuY2hpbGRyZW4gfHwgW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNDaGlsZHJlbihpdGVtKSA/IHRoaXMuZG9HZXRDaGlsZHJlbihpdGVtKSA6IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGl0ZW0gaGFzIGEgY2hpbGRyZW4gYW5kIG5lZWRzIHRvIGJlIHJlbmRlcmVkXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNDaGlsZHJlbihpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSAoPE91dGxpbmVOb2RlPml0ZW0pLmNoaWxkcmVuO1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzQmxhbmsodGhpcy5jaGlsZHJlbikgJiYgaXNCbGFuayhpdGVtLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnTWlzc2luZyBbY2hpbGRyZW5dIG1ldGhvZCBiaW5kaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kb0dldENoaWxkcmVuKGl0ZW0pLmxlbmd0aCA+IDA7XG5cbiAgICB9XG5cbiAgICBkb0dldENoaWxkcmVuKGl0ZW06IGFueSk6IGFueVtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtpdGVtXSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgVXNlcyB0aGUgYE91dGxpbmVTdGF0ZWAgdG8gdG9nZ2xlIHN0YXRlIG9mIGN1cnJlbnQgc2VsZWN0aW9uUGF0aC4gVGhlIGBzZWxlY3Rpb25QYXRoYCBpc1xuICAgICAqICBwdXQgdG9nZXRoZXIgaW5zaWRlIGBPdXRsaW5lQ29udHJvbGAgd2hlcmUgd2UgaXRlcmF0ZSBhbGwgdGhlIHdheSB0byB0aGUgcm9vdCBhbmQgYWRkXG4gICAgICogIGVhY2ggaXRlbSB0byB0aGUgYGN1cnJlbnRQYXRoYCBhcnJheS4gVGhpcyB3YXkgd2UgY29sbGVjdCBsaXN0IG9mIGl0ZW0gcmVwcmVzZW50aW5nIGN1cnJlbnRcbiAgICAgKiAgY3VycmVudCBleHBhbnNpb25QYXRoLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gYmFja3VwIHByb2NlZHVyZSBpbiBjYXNlIG9uQW5pbWF0aW9uRG9uZSBmYWlsc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MpIHsgLy8gY2hhbmdlIG9ubHkgaWYgaXRzIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KHRoaXMuc3RhdGUuY3VycmVudFBhdGgpO1xuICAgICAgICB0aGlzLnN0YXRlLnRvZ2dsZUV4cGFuc2lvbih0aGlzLnN0YXRlLmN1cnJlbnRQYXRoLCB0aGlzLmNoaWxkcmVuRm9ySXRlbShjdXJyZW50SXRlbSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmFuaW1hdGVFbWJlZGRlZEl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBhbmltLiBjYWxsYmFjayB0aGF0IHNldHMgYmFjayB0aGUgZmxhZyB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhbmltYXRpb25zXG4gICAgICogd2hlbiBvbmUgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkFuaW1hdGlvbkRvbmUoZXZlbnQ6IEV2ZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBpbmRlbnRhdGlvbiB1c2VkIHRvIHNoaWZ0IHRoZSBuZXN0ZWQgc2VjdGlvbiB0byB0aGUgcmlnaHQgb3IgbGF0ZXIgb24gdG8gdGhlXG4gICAgICogbGVmdCB3aGVuIFJUTCBpcyBzdXBwb3J0ZWRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaW5kZW50YXRpb24oY3VycmVudExldmVsOiBudW1iZXIpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBjdXJyZW50TGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoY3VycmVudExldmVsID09PSAwICYmIHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKVxuICAgICAgICAgICAgPyAwIDogKHRoaXMuaW5kZW50YXRpb25QZXJMZXZlbCAqIGN1cnJlbnRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90IGFsbCByb3dzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQsIHRoZXJlIGNhbiBiZSBhIGNhc2Ugd2hlcmUgeW91IGRvbnQgd2FudCB0byByZW5kZXIgaXRlbXNcbiAgICAgKiB1c2luZyBvdXRsaW5lLiBlLmcuIERhdGF0YWJsZSB3aXRoIGRldGFpbCByb3cuXG4gICAgICovXG4gICAgaXNWaXNpYmxlKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5maWx0ZXJPdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZmlsdGVyT3V0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogU2luY2Ugd2UgY2FuIG5vdCBkaXJlY3RseSBzZXQgYCpuZ1RlbXBsYXRlT3V0bGV0YCBjb250ZXh0IHZhcmlhYmxlcyB0byB0aGUgdHlwZXNjcmlwdCBjbGFzcyB3ZVxuICogdXNlIHRoaXMgZGlyZWN0aXZlIHRvIGRvIHRoZSBKb2JcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2luaXROZXN0aW5nXSdcbn0pXG5leHBvcnQgY2xhc3MgSW5pdE5lc3RpbmdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXRcbntcblxuICAgIEBJbnB1dCgpXG4gICAgc2V0TGV2ZWw6IG51bWJlcjtcblxuXG4gICAgQElucHV0KClcbiAgICBzZXRDdXJycmVudEl0ZW06IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBzZXRQYXJlbnRJdGVtOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgb3V0bGluZTogT3V0bGluZUZvckNvbXBvbmVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2V0TGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmUuc3RhdGUuY3VycmVudExldmVsID0gdGhpcy5zZXRMZXZlbDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNldEN1cnJyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5jdXJyZW50SXRlbSA9IHRoaXMuc2V0Q3VycnJlbnRJdGVtO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dGxpbmUuY3VycmVudEl0ZW1bJyQkcGFyZW50SXRlbSddXG4gICAgICAgICAgICAgICAgICAgID0gKDxPdXRsaW5lTm9kZT50aGlzLnNldEN1cnJyZW50SXRlbSkucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm91dGxpbmUuaXNUcmVlTW9kZWxGb3JtYXQoKSAmJiBpc1ByZXNlbnQodGhpcy5zZXRQYXJlbnRJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lLmN1cnJlbnRJdGVtWyckJHBhcmVudEl0ZW0nXSA9IHRoaXMuc2V0UGFyZW50SXRlbTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdXRsaW5lRm9yQ29tcG9uZW50fSBmcm9tICcuLi9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuaW1wb3J0IHtPdXRsaW5lU3RhdGV9IGZyb20gJy4uL291dGxpbmUtc3RhdGUnO1xuXG5cbi8qKlxuICogT3V0bGluZUNvbnRyb2xDb21wb25lbnQgcmVuZGVycyB0aGUgaW5kZW50YXRpb24sIGFycm93LCBhbmQgdGV4dCBmb3IgYSBub2RlIGluIGFuIG91dGxpbmUuXG4gKiBJdCBzaG91bGQgYmUgdXNlZCBlaXRoZXIgaW4gdGhlIGJvZHkgb2YgYW4gT3V0bGluZUZvciBjb21wb25lbnQsIG9yIGluc2lkZSBkYXRhdGFibGVcbiAqXG4gKlxuICogIyNVc2FnZSBpbnNpZGUgYm9keTpcbiAqXG4gKiAgSGVyZSB5b3UgY2FuIHNlZSB0aGF0IHdlIG5lZWQgdG8gd3JhcCBvdXQgY29udGVudCBpbnNpZGUgbmctdGVtcGxhdGUgd2hpY2ggd2lsbCBwdXNoIHVzXG4gKiAgZ2l2ZSB1cyBjdXJyZW50IGl0ZW0gaXRlbSBhbmQgdGhlbiB3ZSBjYW4gcGxhY2UgT3V0bGluZUNvbnRyb2xDb21wb25lbnQgdG8gY29udHJvbFxuICogIHRoZSB0cmVlLlxuICpcbiAqIGBgYFxuICogIDxhdy1vdXRsaW5lLWZvcjIgI29vbyBbbGlzdF09XCJsaXN0XCIgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCI+XG4gKlxuICogICAgICA8bmctdGVtcGxhdGUgI291dGxpbmUgbGV0LWl0ZW0+XG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPVwibXktc2VjdGlvblwiPlxuICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvdXRsaW5lXCI+XG4gKiAgICAgICAgICAgICAgICAgIDxhdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICA8L2F3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICA8L2Rpdj4qXG4gKiAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2F3LW91dGxpbmUtZm9yMj5cbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW91dGxpbmUtY29udHJvbCcsXG4gICAgdGVtcGxhdGVVcmw6ICdvdXRsaW5lLWNvbnRyb2wuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydvdXRsaW5lLWNvbnRyb2wuY29tcG9uZW50LnNjc3MnXSxcbn0pXG5leHBvcnQgY2xhc3MgT3V0bGluZUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBJZiBUUlVFIGl0IGNoYW5nZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBvdXRsaW5lIG5vZGUgdGV4dCB3aGljaCBjbGljayBpcyB0cmlnZ2VyZWRcbiAgICAgKiAgaXQgc2VsZWN0cyB0aGUgaXRlbSBhbmQgYnJvYWRjYXN0IHRoZSBgb25JdGVtU2VsZWN0ZWRgIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsbG93U2VsZWN0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGFsbG93RWRpdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyBhY3Rpb24gd2hlbiBvdXRsaW5lIGl0ZW0gaXMgZXhwYW5kZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGl0ZW0gdXNlZCBmb3IgdGhpcyBgT3V0bGluZUNvbnRyb2xgXG4gICAgICpcbiAgICAgKi9cbiAgICBpdGVtOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIGluZGVudGF0aW9uIHVzZWQgdG8gc2hpZnQgdGhlIG5lc3RlZCBzZWN0aW9uIHRvIHRoZSBsZWZ0LiBUaGlzIGlzIHVzZWQgZm9yXG4gICAgICogZW1iZWRkZWQgbW9kZSBlLmcuIHRyZWUgdGFibGUgd2hlcmUgd2UgY2Fubm90IGluZGVudCBwYXJlbnRcbiAgICAgKi9cbiAgICBpbmRlbnRhdGlvbjogbnVtYmVyO1xuXG5cbiAgICBpc1Jvb3RJdGVtOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gT3V0bGluZVN0YXRlKSlcbiAgICAgICAgICAgICAgICBwcml2YXRlIG91dGxpbmVTdGF0ZTogT3V0bGluZVN0YXRlLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwYXJlbnRDb250cm9sOiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gT3V0bGluZUZvckNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHVibGljIG91dGxpbmVGb3I6IE91dGxpbmVGb3JDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLnByZXBhcmVDb250cm9sKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdlIGRvbnQgc2hvdyBleHBhbnNpb24gaWNvbnMgd2hlbiB0aGVyZSBubyBjaGlsZHJlblxuICAgICAqXG4gICAgICovXG4gICAgaGFzRXhwYW5zaW9uQ29udHJvbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLmhhc0NoaWxkcmVuKHRoaXMuaXRlbSkgJiYgdGhpcy5vdXRsaW5lRm9yLnNob3dFeHBhbnNpb25Db250cm9sO1xuICAgIH1cblxuXG4gICAgaXNTZWxlY3RlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLnN0YXRlLnNlbGVjdGVkSXRlbSA9PT0gdGhpcy5pdGVtO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVN0eWxlQ2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXhwYW5zaW9uQ29udHJvbCgpIHx8XG4gICAgICAgICAgICAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBpc0JsYW5rKHRoaXMuaXRlbS4kJHBhcmVudEl0ZW0pKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5lbWJlZGRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5pc0V4cGFuZGVkKHRoaXMuaXRlbSkgPyAnaWNvbi1zbGltLWFycm93LWRvd24nXG4gICAgICAgICAgICAgICAgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaXNFeHBhbmRlZCh0aGlzLml0ZW0pXG4gICAgICAgICAgICAgICAgPyAnaWNvbi1zbGltLWFycm93LXJpZ2h0IG91dGxpbmUtaWNvbi1leHBhbmRlZCcgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbmQgZXhwYW5kcyBjdXJyZW50IG5vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmN1cnJlbnRQYXRoID0gW107XG4gICAgICAgIGxldCBjdXJyZW50UGF0aCA9IHRoaXMuaXRlbTtcblxuICAgICAgICB3aGlsZSAoaXNQcmVzZW50KGN1cnJlbnRQYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmN1cnJlbnRQYXRoLnVuc2hpZnQoY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgY3VycmVudFBhdGggPSBjdXJyZW50UGF0aC4kJHBhcmVudEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm91dGxpbmVGb3IudG9nZ2xlRXhwYW5zaW9uKCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgaXRlbTogdGhpcy5pdGVtLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IHRoaXMub3V0bGluZUZvci5zdGF0ZS5pc0V4cGFuZGVkKHRoaXMuaXRlbSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3Rpb24uZW1pdChwYXlsb2FkKTtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLm9uRXhwYW5kQ2hhbmdlLmVtaXQocGF5bG9hZCk7XG5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5zZWxlY3RlZEl0ZW0gPSB0aGlzLml0ZW07XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5vbkl0ZW1TZWxlY3RlZC5lbWl0KHRoaXMuaXRlbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmVwYXJlQ29udHJvbCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm91dGxpbmVGb3IpICYmIGlzUHJlc2VudCh0aGlzLm91dGxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvciA9IHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3I7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvciksICdNaXNzaW5nIG91dGxpbmVGb3IgY29tcG9uZW50Jyk7XG4gICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXZlbCAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gKHRoaXMub3V0bGluZUZvci5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbSA9IHRoaXMub3V0bGluZUZvci5jdXJyZW50SXRlbTtcbiAgICAgICAgdGhpcy5pc1Jvb3RJdGVtID0gaXNCbGFuayh0aGlzLml0ZW0uJCRwYXJlbnRJdGVtKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5pdE5lc3RpbmdEaXJlY3RpdmUsIE91dGxpbmVGb3JDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7T3V0bGluZUNvbnRyb2xDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBPdXRsaW5lRm9yQ29tcG9uZW50LFxuICAgICAgICBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgSW5pdE5lc3RpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE91dGxpbmVGb3JDb21wb25lbnQsXG4gICAgICAgIE91dGxpbmVDb250cm9sQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV091dGxpbmVGb3JNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCB0ZXh0IGFyZWEgY29tcG9uZW50XG5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdteU5vdGUnICxcbiAqICAgICAgICAgIHRlbXBsYXRlOiAnPGF3LXRleHQtYXJlYSBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFthdXRvUmVzaXplXT1cImF1dG9SZXNpemVcIiA+XG4gKiAgICAgICAgICAgICAgPC9hdy10ZXh0LWFyZWE+J1xuICogICAgICB9KVxuICogICAgICBleHBvcnQgY2xhc3MgTXlOb3RlQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHJlYWxseSBsb25nIHRleHQnO1xuICogICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2U7XG4gKiAgICAgIH1cbiAqXG4gKiBgYGBcbiAqICBOb3RlOiBpZiB5b3UgYXJlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBGb3JtVGFibGUgcGxlYXNlIHByb3ZpZGUgeW91ciBvd24gRm9ybUdyb3VwXG4gKi9cblxuZXhwb3J0IGNvbnN0IFRFWFRBUkVBX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10ZXh0LWFyZWEnLFxuICAgIHRlbXBsYXRlVXJsOiAndGV4dC1hcmVhLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsndGV4dC1hcmVhLmNvbXBvbmVudC5zY3NzJ10sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgVEVYVEFSRUFfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYUNvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBUZXh0QXJlYUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIHVzZWQgdG8gc3RvcmUgYW5kIHJlYWQgdXNlciBpbnB1dFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWZpZmllcyB2aXNpYmxlIG51bWJlciBvZiBsaW5lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93czogbnVtYmVyID0gMjtcblxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHZpc2libGUgd2lkdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbHVtbnM6IG51bWJlciA9IDIwO1xuXG5cbiAgICAvKipcbiAgICAgKiB3aGVuIHRoaXMgb3B0aW9uIGlzIFRSVUUgYW5kIHVzZXIgc3RhcnRzIHR5cGluZyBpdCB3aWxsIG1heGltaXplIHRleHRhcmVhJ3Mgd2lkdGggYW5kIGhlaWdodFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXV0b1Jlc2l6ZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICAgICkuc3Vic2NyaWJlKHZhbCA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlLCB7b25seVNlbGY6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbnB1dFRleHRhcmVhTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtUZXh0QXJlYUNvbXBvbmVudH0gZnJvbSAnLi90ZXh0LWFyZWEuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcblxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBUZXh0QXJlYUNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdUZXh0QXJlYU1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgVGVtcGxhdGVSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIFBhZ2UtTm90aWZpY2F0aW9uIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgYSBub3RpZmljYXRpb24gc3lzdGVtIGZvciB0aGUgdXNlciByZWdhcmRpbmdcbiAqIHRoZSBjdXJyZW50IG9iamVjdCBoZSdzIHdvcmtpbmcgb24uIFR5cGljYWwgbm90aWZpY2F0aW9uIGFyZTpcbiAqICAgICAgU3VjY2VzcyAtIHNhdmVkLlxuICogICAgICBXYXJuaW5nIC0gU291cmNpbmcgcmVxdWVzdCByZXF1aXJlcyAzIHN1cHBsaWVycy5cbiAqICAgICAgRXJyb3IgICAtIGNhbm5vdCBjb25uZWN0IHRvIHNlcnZlciwgY2hlY2sgaW50ZXJuZXQgY29ubmVjdGlvbi5cbiAqXG4gKlxuICpcbiAqIFVzYWdlIDE6ICBBcyBwYXJ0IG9mIHBhZ2Ugd3JhcHBlci5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ015UGFnZScgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgIDxhdy1vYmplY3QtcGFnZS13cmFwcGVyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFt0aXRsZV09XCJNeVBhZ2VcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbb2JqZWN0VHlwZV09XCJNeVR5cGVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbbm90aWZpY2F0aW9uXT1cInBhZ2VOb3RpZmljYXRpb25cIj5cbiAqICAgICAgICAgICAgIHBhZ2UgY29udGVudFxuICogICAgICAgICAgYFxuICogICAgICAgPC9hdy1vYmplY3QtcGFnZXItd3JhcHBlcj5cbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKlxuICogICAgICAgIHBhZ2VOb3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5cIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogVXNhZ2UgMjogZGlyZWN0bHkgaW50byB0aGUgcGFnZS5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgPGF3LWhlYWRlcj48L2F3LWhlYWRlcj5cbiAqICAgICAgICBQYWdlIEhlYWRlclxuICpcbiAqICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzTm90aWZpY2F0aW9ucygpXCI+XG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1LW5vcGFkZGluZ1wiPlxuICogICAgICAgICAgICA8YXctcGFnZS1ub3RpZmljYXRpb24gW25vdGlmaWNhdGlvbl09XCJub3RpZmljYXRpb25cIj48L2F3LXBhZ2Utbm90aWZpY2F0aW9uPlxuICogICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgICAgIDxhdy1mb290ZXI+PC9hdy1mb290ZXI+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5pbmdcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2Utbm90aWZpY2F0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsncGFnZS1ub3RpZmljYXRpb24uY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogQW55IGluZm8sIEVycm9yLCBvciBXYXJuIGZvciB0aGlzIHBhZ2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIG5vdGlmaWNhdGlvbkNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBub3RpZmljYXRpb24tJHt0aGlzLm5vdGlmaWNhdGlvbi50eXBlfWA7XG4gICAgfVxuXG4gICAgbm90aWZpY2F0aW9uSWNvbigpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgYXJpYmEtaWNvbiBpY29uLSR7dGhpcy5ub3RpZmljYXRpb24udHlwZX1gO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFBhZ2UgTm90aWZpY2F0aW9uIGFyZSBtZXNzYWdlcyBmb3IgdGhpcyBwYWdlIG9ubHkuIEl0IGRpc3BsYXlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIHBhZ2VcbiAqIHJpZ2h0IHVuZGVyIHBhZ2UgdGl0bGUuIFR5cGljYWwgcGFnZSBub3RpZmljYXRpb25zIGFyZSAnc2F2ZSBjb25maXJtYXRpb24nLFxuICogJ2Vycm9yIGR1cmluZyBzdWJtaXQnLCB3YXJuaW5ncyBvZiBmaWVsZCByZXF1aXJlbWVudHMsIGV0Yy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VOb3RpZmljYXRpb25cbntcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdHlwZTogUGFnZU5vdGlmaWNhdGlvblR5cGUsIHB1YmxpYyB0aXRsZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBkZXNjcmlwdGlvbjogc3RyaW5nLCBwdWJsaWMgY29udGVudFRtcGw/OiBUZW1wbGF0ZVJlZjxhbnk+KVxuICAgIHtcbiAgICB9XG5cbiAgICBoYXNUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udGVudFRtcGwpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcsIHRpdGxlOiAnICsgdGhpcy50aXRsZSArICcsIGRlc2NyaXB0aW9uOiAgJyArIHRoaXMuZGVzY3JpcHRpb247XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlTm90aWZpY2F0aW9uVHlwZSA9ICdzdWNjZXNzJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcic7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BhZ2VOb3RpZmljYXRpb25Db21wb25lbnR9IGZyb20gJy4vcGFnZS1ub3RpZmljYXRpb24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIHBhZ2UgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUGFnZUluaXRpYWxpemVkXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHRpdGxlOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlSW5pdGlhbGl6aWVkKHRpdGxlOiAke3RoaXMudGl0bGV9KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBwYWdlIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlRGVzdHJveWVkXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHRpdGxlOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlRGVzdHJveWVkKHRpdGxlOiAke3RoaXMudGl0bGV9KWA7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlRXZlbnQgPSBQYWdlSW5pdGlhbGl6ZWQgfCBQYWdlRGVzdHJveWVkO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7UGFnZURlc3Ryb3llZCwgUGFnZUV2ZW50LCBQYWdlSW5pdGlhbGl6ZWR9IGZyb20gJy4vcGFnZS1ldmVudHMnO1xuXG4vKipcbiAqIFBhZ2UgTGlmZUN5Y2xlIFNlcnZpY2UgbW9uaXRvcnMgYWxsIHBhZ2UgaW5pdGlhbGl6YXRpb24gYW5kIGRlc3RydWN0aW9ucy5cbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgc2VydmljZSBpcyB0byBoZWxwIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9yIHBhZ2UgbGlmZWN5Y2xlLCBzdWJzY3JpYmVcbiAqIHRvIGxpZmVjeWNsZSBldmVudHMgYW5kIGV4ZWN1dGUgYWN0aW9ucyBzdWNoIGFzIHVzZXIgYW5hbHl0aWNzLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgIDEuICBJbmplY3QgUGFnZUxpZmVDeWNsZVNlcnZpY2UgaW50byB5b3VyIGNvbnN0cnVjdG9yXG4gKlxuICogICAgY29uc3RydWN0b3IocGFnZUxpZmVjeWNsZTpQYWdlTGlmZUN5Y2xlU2VydmljZSkge1xuICogICAgICAgIHBhZ2VMaWZlY3ljbGUucGFnZUV2ZW50cy5zdWJzY3JpYmUoZXZlbnQ6RXZlbnQgPT4ge1xuICogICAgICAgICAgICBpZihldmVudCBpbnN0YW5jZW9mIFBhZ2VJbml0aWFsaXplZCkge1xuICogICAgICAgICAgICB9XG4gKiAgICAgICAgICAgIC8vIFBhZ2VEZXN0cm95ZWRcbiAqXG4gKiAgICAgICAgfSk7XG4gKiAgICAgfVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUxpZmVDeWNsZVNlcnZpY2VcbntcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgZXZlbnQgcXVldWUgd2hlbiBhbGwgcGFnZSBsaWZlY3ljbGUgZXZlbnRzOiBpbml0LCBkZXN0cm95IGFyZSBlbWl0dGVkLlxuICAgICAqIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZXNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGFnZUV2ZW50czogU3ViamVjdDxQYWdlRXZlbnQ+ID0gbmV3IFN1YmplY3Q8UGFnZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFnZSBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gcGFnZVRpdGxlXG4gICAgICovXG4gICAgcHVibGljIG9uUGFnZUluaXQocGFnZVRpdGxlOiBzdHJpbmcpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBhZ2VFdmVudHMubmV4dChuZXcgUGFnZUluaXRpYWxpemVkKHBhZ2VUaXRsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgd2hlbiBwYWdlIGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAqIEBwYXJhbSB0aXRsZVxuICAgICAqL1xuICAgIHB1YmxpYyBvblBhZ2VEZXN0cm95KHBhZ2VUaXRsZTogc3RyaW5nKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlRXZlbnRzLm5leHQobmV3IFBhZ2VEZXN0cm95ZWQocGFnZVRpdGxlKSk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgcGFnZSB0eXBlcyBpbiBhbiBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGVudW0gUGFnZVR5cGUge1xuICAgIEluaXQsICAgICAgICAgLy8gSW5pdCBQYWdlIHR5cGVcbiAgICBMb2dpbiwgICAgICAgIC8vIExvZ2luIFBhZ2VcbiAgICBPYmplY3QsICAgICAgIC8vIE9iamVjdCBkZXRhaWwgcGFnZVxuICAgIExpc3QsICAgICAgICAgLy8gTGlzdCBQYWdlXG4gICAgTWFzdGVyRGV0YWlsLCAvLyBNYXN0ZXJEZXRhaWxcbiAgICBEYXNoYm9hcmQsICAgIC8vIERhc2hib2FyZCBwYWdlXG4gICAgTW9kYWwgICAgICAgICAvLyBNb2RhbCBwYWdlLCBpdCBjYW4gYmUgY29uZmlndXJlZCB0byBiZSBhIHBvcHVwLCBvciBzdGFuZGFsb25lIHBhZ2UuXG59XG5cbi8qKiBQbGFjZWhvbGRlciBub3cuIFRoZSBFcnJvciBNYW5hZ2VyIGhhbmRsZXMgYWxsIHRoZSBlcnJvcnMgb24gdGhlIHBhZ2UuXG4gKiAgSXQgaXMgaW5pdGlhbGl6ZWQgZm9yIGV2ZXJ5IHBhZ2UuIFBhZ2UgZXJyb3JzLCB3YXJuaW5nLCBpbmZvIGdvZXMgdGhyb3VnaFxuICogIHRoZSBlcnJvciBNYW5hZ2VyIGFuZCB0aGUgcmVzdWx0IG1lc3NhZ2UgaXMgZGlzcGxheWVkIG9uIHRoZSBwYWdlIG5vdGlmaWNhdGlvbiBhcmVhLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyXG57XG5cbn1cblxuLyoqXG4gKiAgUGFnZSB3cmFwcGVyIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgcGFnZXMuIFRoZSBpZGVhIGlzIHRoYXQgdGhlcmUgYXJlIGRpZmZlcmVudCBwYWdlIHR5cGVzXG4gKiAgaW4gYW4gQXBwbGljYXRpb24uIEEgTGlzdCBQYWdlIHJlbmRlcnMgYSBsaXN0IG9mIG9iamVjdHMsIGV4OiBjdXN0b21lcnMsIHJlcXVlc3RzLCBQTy4gIEFuZFxuICogIGEgb2JqZWN0IHBhZ2Ugd2lsbCByZW5kZXIgb25lIG9iamVjdCBpbiBkZXRhaWwuXG4gKlxuICogIFRoZXkgc2hhcmUgY29tbW9uIGF0dHJpYnV0ZXMgc3VjaCBhcyBwYWdlIHR5cGUgYW5kIHBhZ2UgaWQuXG4gKlxuICogIEFyaWJhIFBhZ2UgaGF2ZSBhIGxpZmUgY3ljbGUuIFdoZW4gcGFnZSBzdGFydHMgdXAsIGl0J3MgaW5pdGlhbGl6ZWQuIEFuZCB3aGVuIHRoZSBwYWdlIGlzXG4gKiAgZGVzdHJveWVkLCBpdCdsbCBiZSBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhZ2VXcmFwcGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFdoYXQgdHlwZSBvZiBwYWdlIHRoaXMgaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGFnZVR5cGU6IFBhZ2VUeXBlID0gUGFnZVR5cGUuSW5pdDtcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgSWQuIFVzZWQgd2hlbiBwYWdlcyBhcmUgc3RvcmVkIGluIG1hcC5cbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxpbmcgYWxsIHRoZSBlcnJvciBvbiBhIHBhZ2UuXG4gICAgICovXG4gICAgcHVibGljIGVycm9yTWFuYWdlcjogRXJyb3JNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdGhhdCB0aGlzIHBhZ2Ugd3JhcHBlciBoYXMgYmVlbiB3cmFwcGVkIGJ5IGFub3RoZXIgcGFnZSB3cmFwcGVyLlxuICAgICAqIEluIHRoaXMgY2FzZSwgd2Ugd291bGRuJ3QgZGlzcGxheSBoZWFkZXIgYW5kIGZvb3RlciBhbmQgb3RoZXIgcGFnZSB3cmFwcGVyIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBhbHJlYWR5SW5QYWdlV3JhcHBlcjogYm9vbGVhbjtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHBhZ2VUeXBlOiBQYWdlVHlwZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYWdlTGlmZWN5Y2xlU2VydmljZTogUGFnZUxpZmVDeWNsZVNlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICB0aGlzLnBhZ2VUeXBlID0gcGFnZVR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsIHN1YmNsYXNzIG5lZWRzIHRvIGdlbmVyYXRlZCBhIHBhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBJdCBmb2xsb3dzIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICAgKiAgICB0eXBlX3RpdGxlX2lkXG4gICAgICpcbiAgICAgKiAgICBSRlFfU291cmNpbmdSZXF1ZXN0XzEyM1xuICAgICAqL1xuICAgIGFic3RyYWN0IGdlbmVyYXRlUGFnZUlkKCk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5pcXVlIElkIGZvciB0aGlzIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SWQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlkID0gdGhpcy5nZW5lcmF0ZVBhZ2VJZCgpO1xuICAgIH1cblxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtQYWdlTWVudUl0ZW19IGZyb20gJy4uL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqICBUaGlzIGlzIGEgdGVtcG9yYXJ5IGltcGxlbWVudGF0aW9uIGZvciB0aGUgcGFnZSBoZWFkZXIgY29tcG9uZW50LlxuICogIFdoZW4gdGhlIHJlYWwgaW1wbGVtZW50YXRpb24gb2Ygc2lkZSBtZW51IGlzIGRvbmUsIFBhZ2VIZWFkZXJDb21wb25lbnQgd2lsbFxuICogIGJlIHN3YXBlZCB0byB1c2UgaXQuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNpZGVuYXYnLFxuICAgIHRlbXBsYXRlVXJsOiAnc2lkZW5hdi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3NpZGVuYXYuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBTaWRlbmF2Q29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgbWVudSBpdGVtc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXRlbXM6IFBhZ2VNZW51SXRlbVtdO1xuXG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIGJhY2sgbGluayB0aGF0IG5hdmlnYXRlcyB1c2VyIHRvIHRoZSBwcmV2aW91cyBwYWdlIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3c6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIGdldFNpZGVuYXZDbGFzcygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIC8vIE9ubHkgc2hvdyBpZiBJIGhhdmUgaXRlbXNcbiAgICAgICAgcmV0dXJuICh0aGlzLnNob3cgJiYgdGhpcy5pdGVtcykgPyAnc2lkZW5hdiBzaWRlbmF2LWFjdGl2ZScgOiAnc2lkZW5hdic7XG4gICAgfVxuXG4gICAgb3BlbigpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRvZ2dsZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBWaWV3Q2hpbGR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50LCBSb3V0aW5nU2VydmljZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1NpZGVuYXZDb21wb25lbnR9IGZyb20gJy4uL3NpZGVuYXYvc2lkZW5hdi5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogSGVhZGVyIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvciBmb3IgYW4gQXJpYmEgcGFnZS5cbiAqIEhlYWRlciBpbmNsdWRlcyBhIG1lbnUsIHVzZXIgcHJvZmlsZSwgYW5kIGFsZXJ0cy5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgIDxhdy1wYWdlLWhlYWRlciBbc2hvd0JhY2tBY3Rpb25dPVwidHJ1ZVwiIHVzZXJOYW1lPVwiQ2hhZCBOb2xsXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW21lbnVJdGVtc109XCJtZW51SXRlbXNcIiBbbm90aWZpY2F0aW9uc109XCJ1c2VyTm90aWZpY2F0aW9uc1wiPlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItY2VudGVyXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwibmF2YmFyLWJyYW5kXCIgdGFiaW5kZXg9XCIwXCIgaHJlZj1cIi9cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJuYXZiYXItbG9nb1wiIHNyYz1cIi4vaW1hZ2VzL1NBUF9BcmliYV9EQi5wbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD1cIkdvIHRvIGhvbWVwYWdlXCIgZGF0YS1waW4tbm9waW49XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgIDwvYXctcGFnZS1oZWFkZXI+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqICAgICAgbWVudUl0ZW1zOiBQYWdlTWVudUl0ZW1bXSA9IFtuZXcgUGFnZU1lbnVJdGVtKCdpY29uLWhvbWUnLCAnSG9tZScsICcvcGxheS8nKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWdlTWVudUl0ZW0oJ2ljb24tZXhwZW5zZS1yZXBvcnQnLCAnUmVwb3J0cycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5L3BhZ2VoZWFkZXInKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWdlTWVudUl0ZW0oJ2ljb24tc2FsZXMtb3JkZXInLCAnUHVyY2hhc2UgT3JkZXInLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5L3BhZ2VoZWFkZXInKSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQYWdlTWVudUl0ZW0oJ2ljb24tYWNjb3VudCcsICdBY2NvdW50cycsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5L3BhZ2VoZWFkZXInKV07XG4gKlxuICogICAgIHVzZXJOb3RpZmljYXRpb25zOiBVc2VyTm90aWZpY2F0aW9uW10gPSBbXG4gKiAgICAgICBuZXcgVXNlck5vdGlmaWNhdGlvbignaWNvbi1leHBlbnNlLXJlcG9ydCcsICdFeHBlbnNlIHJlcG9ydCBFWFA0NTMgaGFzIGJlZW4gYXBwcm92ZWQuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvJyksXG4gKiAgICAgICAgIG5ldyBVc2VyTm90aWZpY2F0aW9uKCdpY29uLXNhbGVzLW9yZGVyJywgJ1NhbGVzIE9yZGVyIFNPMTIzNCBoYXMgYmVlbiBjcmVhdGVkLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5LycpLFxuICogICAgICAgICAgIG5ldyBVc2VyTm90aWZpY2F0aW9uKCdpY29uLWFjY291bnQnLCAnU3VwcGxpZXIgYWNjb3VudCBTQTEyMzQgaGFzIGJlZW4gdXBkYXRlZC4nLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5LycpXG4gKiAgICAgICAgXTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWhlYWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdwYWdlLWhlYWRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3BhZ2UtaGVhZGVyLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgbWVudSBlbnRyaWVzLiBUaGUgcGFnZSBtZW51IGljb24gd2lsbCBvbmx5IGRpc3BsYXkgd2hlbiB0aGlzIGxpc3QgaXMgbm90IGVtcHR5LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWVudUl0ZW1zOiBQYWdlTWVudUl0ZW1bXTtcblxuICAgIC8qKlxuICAgICAqIGxpc3Qgb2YgdXNlciBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vdGlmaWNhdGlvbnM6IFVzZXJOb3RpZmljYXRpb25bXTtcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB0aGUgdXNlciBub3RpZmljYXRpb24gaWNvbiBiZSBoaWRkZW4uIERlZmF1bHQgaXQgdG8gc2hvdyB0aGUgaWNvbiBldmVuXG4gICAgICogaWYgdGhlcmUncyBubyBub3RpZmljYXRpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRlTm90aWZpY2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5cyB0aGUgYmFjayBsaW5rIHRoYXQgbmF2aWdhdGVzIHVzZXIgdG8gdGhlIHByZXZpb3VzIHBhZ2Ugd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JhY2tBY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbG9nZ2VkIGluIHVzZXIgbmFtZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZXJOYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2lkZW1lbnVcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdzaWRlbWVudScpXG4gICAgc2lkZW5hdjogU2lkZW5hdkNvbXBvbmVudDtcblxuICAgIHNob3dOb3RpZmljYXRpb25QYW5lbDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByb3V0aW5nOiBSb3V0aW5nU2VydmljZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBiYWNrQWN0aW9uKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucm91dGluZy5nb0JhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBpIGhhdmUgYW55IG1lbnUgaXRlbXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNNZW51SXRlbXMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1lbnVJdGVtcyAmJiB0aGlzLm1lbnVJdGVtcy5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHNpZGUgbmF2aWdhdGlvbiBtZW51LlxuICAgICAqL1xuICAgIHNob3dIaWRlTWVudSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNpZGVuYXYudG9nZ2xlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG8gSSBoYXZlIGFueSBub3RpZmljYXRpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzTm90aWZpY2F0aW9ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubm90aWZpY2F0aW9ucykgJiYgdGhpcy5ub3RpZmljYXRpb25zLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xpbmcgd2hlYXRoZXIgbm90aWZpY2F0aW9uIHBhbmVsIGlzIGRpc3BsYXllZCBvciBub3QuXG4gICAgICovXG4gICAgdG9nZ2xlTm90aWZpY2F0aW9uUGFuZWwoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93Tm90aWZpY2F0aW9uUGFuZWwgPSAhdGhpcy5zaG93Tm90aWZpY2F0aW9uUGFuZWw7XG4gICAgfVxufVxuXG4vKipcbiAqIFBhZ2VNZW51SXRlbSByZXByZXNlbnRzIGFuIGl0ZW0gaW4gdGhlIHBhZ2UgbWVudSBzdHJ1Y3R1cmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlTWVudUl0ZW1cbntcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWNvbiAgICAtIEljb24gb2YgdGhpcyBtZW51IGl0ZW0uXG4gICAgICogQHBhcmFtIGxhYmVsICAgLSBsYWJlbCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHBhcmFtIGxpbmsgICAgLSBsaW5rIHRvIHRoZSBkZXN0aW5hdGlvbiB3aGVuIHVzZXIgY2xpY2tzIG9uIGl0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBpY29uOiBzdHJpbmcsIHB1YmxpYyBsYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBsaW5rOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlTWVudUl0ZW06IChsYWJlbCwgJHt0aGlzLmxhYmVsfSlgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBub3RpZmljYXRpb24gZm9yIHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyLlxuICogRXg6ICBQUjIwNDkgaGFzIGJlZW4gYXBwcm92ZWQuXG4gKiAgICAgIE9yZGVyIFBPNTE4IHJlY2VpdmVkLlxuICovXG5leHBvcnQgY2xhc3MgVXNlck5vdGlmaWNhdGlvblxue1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIGljb24gICAtIGFsZXJ0IG5vdGlmaWNhdGlvbiBpY29uXG4gICAgICogQHBhcmFtIGxhYmVsICAtIGFsZXJ0IG5vdGlmaWNhdGlvbiBsYWJlbFxuICAgICAqIEBwYXJhbSBsaW5rICAgLSBsaW5rXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHVibGljIGljb246IHN0cmluZywgcHVibGljIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHVibGljIGxpbms6IHN0cmluZylcbiAgICB7XG5cbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZVVzZXJOb3RpZmljYXRpb246IChsYWJlbCwgJHt0aGlzLmxhYmVsfSlgO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRWxlbWVudFJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBGb290ZXIgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yLlxuICogVGhpcyBmb290ZXIgY29tcG9uZW50IHNlbGYgY29udGFpbmVkLlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgICAgIDxhdy1wYWdlLWZvb3Rlcj5cbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtZm9vdGVyLWxvZ29cIj5cbiAqICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaW1hZ2VzL2FyaWJhX2xvZ29fd2hpdGVfYmtnZC5wbmdcIj5cbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWZvb3Rlci11c2VyLWluZm9cIj5cbiAqICAgICAgICAgICAgICAgICAgIENoYWQgTm9sbCAoY25vbGwpIGxhc3QgdmlzaXQge3tsYXN0X3Zpc2l0ZWQgfCBkYXRlOidNTS9kZC95eXl5IGg6bW1hJyB9fVxuICAqICAgICAgICAgICAgICAgICAgIHwgQnV5ZXIgT3JnYW5pemF0aW9uXG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInBhZ2UtZm9vdGVyLWNvcHlyaWdodFwiICNjb3B5cmlnaHQ+XG4gKiAgICAgICAgICAgICAgICAgICA8cD7DgsKpIDIwMjDDosKAwpMyMDI4IFRoZSBGdXR1cmUsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZDwvcD5cbiAqICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgIDwvYXctcGFnZS1mb290ZXI+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1mb290ZXInLFxuICAgIHRlbXBsYXRlVXJsOiAncGFnZS1mb290ZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydwYWdlLWZvb3Rlci5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VGb290ZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogY29weXJpZ2h0IGNvbnRlbnRcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdjb3B5cmlnaHQnKSBjb3B5cmlnaHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIHNob3cgZGVmYXVsdCBjb3B5cmlnaHQuIElmIGNvcHlyaWdodCBpcyBwYXNzZWQgaW4sIHRoZW4gc2hvdyB0aGUgcGFzc2VkIGluIG9uZS5cbiAgICAgKi9cbiAgICBzaG93RGVmYXVsdENvcHlyaWdodDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93RGVmYXVsdENvcHlyaWdodCA9ICFpc1ByZXNlbnQodGhpcy5jb3B5cmlnaHQpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5wdXQsXG4gICAgT25EZXN0cm95LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi4vLi4vLi4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1BhZ2VUeXBlLCBQYWdlV3JhcHBlcn0gZnJvbSAnLi4vcGFnZS13cmFwcGVyJztcbmltcG9ydCB7UGFnZU5vdGlmaWNhdGlvbn0gZnJvbSAnLi4vLi4vcGFnZS1ub3RpZmljYXRpb24vcGFnZS1ub3RpZmljYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUxpZmVDeWNsZVNlcnZpY2V9IGZyb20gJy4uL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuLi9wYWdlLWZvb3Rlci9wYWdlLWZvb3Rlci5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBPYmplY3QgUGFnZSBXcmFwcGVyIENvbXBvbmVudCByZW5kZXJzIGFueSBvYmplY3QgaW5zdGFuY2UgaW4gZGV0YWlsLiBJdCBoYXMgYSB1bmlmb3JtIGxheW91dCxcbiAqIEhlYWRlciwgUGFnZSB0aXRsZSwgUGFnZSBub3RpZmljYXRpb24sIGFjdGlvbnMsIGNvbnRlbnQsIGFuZCBGb290ZXIuXG4gKlxuICpcbiAqICBVc2FnZTpcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ1JGWFBhZ2UnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8YXctb2JqZWN0LXBhZ2Utd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwicmZ4RW50aXR5LmhlYWRlckluZm8udGl0bGVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbb2JqZWN0VHlwZV09XCJyZnhFbnRpdHkuaGVhZGVySW5mby5ldmVudFR5cGVTdHJpbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbbm90aWZpY2F0aW9uXT1cInBhZ2VOb3RpZmljYXRpb25cIj5cbiAqXG4gKlxuICogICAgICAgICAgIDxhdy1wYWdlLWFjdGlvbnM+XG4gKiAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3R5cGVdPVwiJ3N1Ym1pdCdcIiBbbmFtZV09XCInZWRpdCdcIiBbdmFsdWVdPVwiZWRpdFwiIFtzdHlsZV09XCIncHJpbWFyeSdcIj5cbiAqICAgICAgICAgICAgICAgICAgIEVkaXRcbiAqICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICA8YXctYnV0dG9uIFt0eXBlXT1cIididXR0b24nXCIgW25hbWVdPVwiJ2NhbmNlbCdcIiBbdmFsdWVdPVwiY2FuY2VsXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlXT1cIidzZWNvbmRhcnknXCI+XG4gKiAgICAgICAgICAgICAgICAgIENhbmNlbFxuICogICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtYWN0aW9ucz5cbiAqXG4gKiAgICAgICAgICAgPGF3LXBhZ2UtY29udGVudD5cbiAqICAgICAgICAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiU291cmNpbmcgcmVxdWVzdCBpbmZvXCIgKG9uU3RhdGVDaGFuZ2VkKT1cIm9uU3RhdGVDaGFuZ2UoJGV2ZW50KVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDxtLWNvbnRleHQgW29iamVjdF09XCJyZnhFbnRpdHkuaGVhZGVySW5mb1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcGVyYXRpb25dPVwidGhpcy5lZGl0YWJpbGl0eVN0YXRlLmhlYWRlckluZm9PcFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dD1cIkluc3BlY3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aUdyb3VwPVwiSGVhZGVyR2VuZXJhbFwiXG4gKiAgICAgICAgICAgICAgICAgICA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPG0taW5jbHVkZS1jb21wb25lbnQ+PC9tLWluY2x1ZGUtY29tcG9uZW50PlxuICogICAgICAgICAgICAgICAgICAgPC9tLWNvbnRleHQ+XG4gKlxuICogICAgICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICogICAgICAgICAgIDwvYXctcGFnZS1jb250ZW50PlxuICogICAgICAgPC9hdy1vYmplY3QtcGFnZS13cmFwcGVyPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBSRlhQYWdlXG4gKiAgICB7XG4gKiAgICAgICAvLyBUbyBrZWVwIHRyYWNrIHdoYXQgc2VjdGlvbiBpcyBlZGl0YWJsZSBhbmQgd2hpY2ggcmVhZCBvbmx5XG4gKiAgICAgICBlZGl0YWJpbGl0eVN0YXRlOiBFZGl0YWJpbGl0eVN0YXRlO1xuICpcbiAqICAgICAgIC8vIEN1cnJlbnQgUkZYIGV2ZW50XG4gKiAgICAgICByZnhFbnRpdHk6IFJmeEV2ZW50RW50aXR5O1xuICpcbiAqICAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAqICAgICAgIG5vdGlmaWNhdGlvbjogUGFnZU5vdGlmaWNhdGlvbiA9IG5ldyBQYWdlTm90aWZpY2F0aW9uKFwid2FyblwiLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBvbGljeSBXYXJuaW5nXCIsIFwiVGhpcyByZXF1ZXN0IHJlcXVpcmVzIDMgYmlkcy5cIik7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb2JqZWN0LXBhZ2Utd3JhcHBlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdvYmplY3QtcGFnZS13cmFwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE9iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50IGV4dGVuZHMgUGFnZVdyYXBwZXIgaW1wbGVtZW50cyBPbkRlc3Ryb3lcbntcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIHBhZ2VcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0IGJlaW5nIHJlbmRlcmVkIC0gRXZlbnQsIFdvcmtzcGFjZSwgY29udHJhY3QsIGV0Yy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIGxhYmVsIGZvciB0aGUgb2JqZWN0IHN0YXR1cy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFN0YXR1c0xhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG9iamVjdCdzIHN0YXR1cy4gRm9yIGV4YW1wbGUsIGRyYWZ0LCBwZW5kaW5nIHNlbGVjdGlvbixcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFN0YXR1czogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwuIFNvbWUgb2JqZWN0IGhhcyBzdGF0ZXMuIEZvciBleGFtcGxlOiBSRnhPYmplY3QgaGFzIFJlc29sdmUsIFJldmlldywgR2V0IFF1b3RlLlxuICAgICAqIE9iamVjdCBzdGF0ZXMgd2lsbCBhcHBlYXIgb24gdGhlIHBhZ2Ugd2hlbiB0aGV5IGFyZSBwcmVzZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0U3RhdGVzOiBzdHJpbmdbXTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBTdGVwcGVyIGlzIHVzZWQgdGhpcyBpZGVudGlmaWVzIGN1cnJlbnQgc2V0IHN0YXRlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50U3RhdGU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGlzIGEgY29tcG9uZW50IHR5cGUgdG8gYmUgcmVuZGVyZWQgYXMgYSBwYWdlIEhlYWRlci5cbiAgICAgKlxuICAgICAqIFRoZSAnZGVmYXVsdCcgdmFsdWUgaXMgdGhlIGNvbXBvbmVudC93aWRnZXQvSGVhZGVyQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoZWFkZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0cnVlIGlmIHBhZ2Ugc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBoZWFkZXIuIE5lZWQgdG8gc2V0IHRvIHRydWUgZXZlbiBubyBoZWFkZXJcbiAgICAgKiBvYmplY3QgaXMgcGFzc2VkIGluLiBPdGhlcndpc2UsIGEgZGVmYXVsdCBIZWFkZXIgY29tcG9uZW50IHdpbGwgYmUgYWRkZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRlSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGb290ZXIgQ29tcG9uZW50IGlzIHRoZSBwYWdlIGZvb3Rlci5cbiAgICAgKiBjYW4gYmUgb3ZlcnJpZGVuIGJ1dCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBjb21wb2VuZW50L3dpZGdldC9Gb290ZXJDb21wb25lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb290ZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0cnVlIGlmIHBhZ2Ugc2hvdWxkIG5vdCBpbmNsdWRlIGFueSBmb290ZXIuIE5lZWQgdG8gc2V0IHRvIHRydWUgZXZlbiBubyBmb290ZXJcbiAgICAgKiBvYmplY3QgaXMgcGFzc2VkIGluLiBPdGhlcndpc2UsIGEgZGVmYXVsdCBGb290ZXIgY29tcG9uZW50IHdpbGwgYmUgYWRkZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRlRm9vdGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb25pbmcgb2YgdGhlIHBhZ2UgYWN0aW9ucyAocGFnZSBidXR0b25zKVxuICAgICAqICAgJ3RvcCcgOiAgICBwYWdlIGJ1dHRvbnMgYXJlIHBsYWNlZCBhdCB0aGUgdG9wIG9mIHRoZSBwYWdlLCBiZWxvdyB0aGUgdGl0bGUsIHRvIHRoZSByaWdodC5cbiAgICAgKiAgICdib3R0b20nIDogcGFnZSBidXR0b25zIGFyZSBwbGFjZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgcGFnZSwgYWJvdmUgdGhlIGZvb3Rlci5cbiAgICAgKiAgICdib3RoJyAgIDogcGFnZSBidXR0b25zIGFyZSBwbGFjZWQgYXQgYm90aCB0b3AgYW5kIGJvdHRvbS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGFnZUFjdGlvblBvc2l0aW9uOiBzdHJpbmcgPSAndG9wJztcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmbGFnIGlzIGRyaXZlbiBieSBwYWdlQWN0aW9uUG9zaXRpb24uIFRoZSBkZWZhdWx0IHBvc2l0aW9uIGlzIHRvcC5cbiAgICAgKiBWYWx1ZSBpcyB0cnVlIGZvciBib3RoICd0b3AnIGFuZCAnYm90aCcgb2YgcGFnZUFjdGlvblBvc2l0aW9uLlxuICAgICAqL1xuICAgIGhhc1RvcFBhZ2VBY3Rpb25zOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZmxhZyBpcyBkcml2ZW4gYnkgcGFnZUFjdGlvbiBwb3NpdGlvbi5cbiAgICAgKiBWYWx1ZSBpcyB0cnVlIGZvciBib3RoICdib3R0b20nIGFuZCAnYm90aCcgb2YgcGFnZUFjdGlvblBvc2l0aW9uLlxuICAgICAqL1xuICAgIGhhc0JvdHRvbVBhZ2VBY3Rpb25zOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgcCB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdwYWdlQWN0aW9ucycpXG4gICAgYWN0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQW55IFN1Y2Nlc3MsIEluZm8sIEVycm9yLCBvciBXYXJuIGZvciB0aGlzIHBhZ2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb25zOiBQYWdlTm90aWZpY2F0aW9uW107XG5cblxuICAgIG9iamVjdFN0YXRlSW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgY29tcG9uZW50UmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5LCBwYWdlTGlmZWN5Y2xlU2VydmljZTogUGFnZUxpZmVDeWNsZVNlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIFBhZ2VUeXBlLk9iamVjdCwgY29tcG9uZW50UmVnaXN0cnksIHBhZ2VMaWZlY3ljbGVTZXJ2aWNlKTtcblxuICAgICAgICAvLyBTZXR0aW5nIERlZmF1bHQgaGVhZGVyIGNvbXBvbmVudFxuICAgICAgICB0aGlzLmhlYWRlciA9IFBhZ2VIZWFkZXJDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuZm9vdGVyID0gUGFnZUZvb3RlckNvbXBvbmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSBJZCBmb3IgdGhpcyBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBnZW5lcmF0ZVBhZ2VJZCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm9iamVjdFR5cGUgKyAnXycgKyB0aGlzLnRpdGxlICsgKHRoaXMuaWQpID8gKCdfJyArIHRoaXMuaWQpIDogJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyBteSBwYWdlIGhhdmUgcGFnZSBub3RpZmljYXRpb24/XG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNOb3RpZmljYXRpb25zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5ub3RpZmljYXRpb25zICYmIHRoaXMubm90aWZpY2F0aW9ucy5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICBoYXNPYmplY3RTdGF0ZXMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm9iamVjdFN0YXRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBteSBsb2NhbCBjb21wb25lbnRzXG4gICAgICovXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAvLyBOZXcgQ29tcG9uZW50IHR5cGVzIHRoYXQgYXJlIHVzZWQgaW4gYy1pbmNsdWRlLWNvbXBvbmVudFxuICAgICAgICBpZiAodGhpcy5oZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJUeXBlKHRoaXMuaGVhZGVyLm5hbWUsIHRoaXMuaGVhZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5ldyBDb21wb25lbnQgdHlwZXMgdGhhdCBhcmUgdXNlZCBpbiBjLWluY2x1ZGUtY29tcG9uZW50XG4gICAgICAgIGlmICh0aGlzLmZvb3Rlcikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRSZWdpc3RyeS5yZWdpc3RlclR5cGUodGhpcy5mb290ZXIubmFtZSwgdGhpcy5mb290ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIG5vdGlmeSBzdWJzY3JpYmVycyBvZiB0aGUgcGFnZSBsaWZlY3ljbGUgc2VydmljZSAgKi9cbiAgICAgICAgdGhpcy5wYWdlTGlmZWN5Y2xlU2VydmljZS5vblBhZ2VJbml0KHRoaXMudGl0bGUpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgdGhlIHBhZ2UgYWN0aW9uIHBvc2l0aW9uLlxuICAgICAgICBpZiAodGhpcy5wYWdlQWN0aW9uUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1RvcFBhZ2VBY3Rpb25zID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhhc0JvdHRvbVBhZ2VBY3Rpb25zID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFnZUFjdGlvblBvc2l0aW9uID09PSAnYm90aCcpIHtcblxuICAgICAgICAgICAgdGhpcy5oYXNUb3BQYWdlQWN0aW9ucyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmhhc0JvdHRvbVBhZ2VBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vYmplY3RTdGF0ZXMpICYmIHRoaXMub2JqZWN0U3RhdGVzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgICYmIGlzUHJlc2VudCh0aGlzLmN1cnJlbnRTdGF0ZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5vYmplY3RTdGF0ZUluZGV4ID0gdGhpcy5vYmplY3RTdGF0ZXMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ2N1cnJlbnRTdGF0ZSddKSAmJlxuICAgICAgICAgICAgY2hhbmdlc1snY3VycmVudFN0YXRlJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWydjdXJyZW50U3RhdGUnXS5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAvLyB3ZSBkb250IG5lZWQgdG8gY2hlY2sgaWYgb2JqZWN0U3RhdGVzIGV4aXN0c1xuICAgICAgICAgICAgdGhpcy5vYmplY3RTdGF0ZUluZGV4ID0gdGhpcy5vYmplY3RTdGF0ZXMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMucGFnZUxpZmVjeWNsZVNlcnZpY2Uub25QYWdlRGVzdHJveSh0aGlzLnRpdGxlKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBQYWdlIGFjdGlvbnMgaXMgYSB3cmFwcGVyIGZvciBhbGwgcGFnZSBhY3Rpb25zLCBidXR0b25zLCBsaW5rcywgbWVudXMgdGhhdCBpbnRlcmFjdHMgaXQgd2l0aCB0aGVcbiAqIHBhZ2UuIFRoZSB3cmFwcGVyIHVzZSB0aGUgYWJpbGl0eSB0byBwb3NpdGlvbiBpdCBhcyBuZWVkZWQuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1hY3Rpb25zJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3BhZ2UtYWN0aW9ucy5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3BhZ2UtYWN0aW9ucy5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VBY3Rpb25zQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBQYWdlIGNvbnRlbnQgaXMgYSB3cmFwcGVyIGZvciBwYWdlIGNvbnRlbnQuXG4gKiBDdXJyZW50bHksIGl0J3MgcHJldHR5IGJhcmUsIGJ1dCBhcyB3ZSBhZGQgbW9yZSBpbnRlcmFjdGlvbnMgb24gdGhlIHBhZ2UsIGxpa2UgYSBzaWRlIGJhcixcbiAqIHRoZSBwYWdlIGNvbnRlbnQgYXJlYSB3aWxsIGxpa2VseSBnZXQgYWZmZWN0ZWQuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1jb250ZW50JyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgIHN0eWxlczogWyc6aG9zdCB7d2lkdGg6IDEwMCU7IHBhZGRpbmc6IDAgLjVlbTt9J11cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUNvbnRlbnRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG5cbmNvbnN0IFNURVBQRVJfQ09NUExFVEVEX1NURVBfQ09MT1IgPSAnIzU4Yjk1Nyc7XG5jb25zdCBTVEVQUEVSX0NVUlJFTlRfU1RFUF9DT0xPUiA9ICcjMDA3NkNCJztcbmNvbnN0IFNURVBQRVJfUkVNQUlOSU5HX1NURVBfQ09MT1IgPSAnI0Q3RDdENyc7XG5cbi8qKlxuICogU3RlcHBlciBjb21wb25lbnQgZGlzcGxheXMgYSBsaXN0IG9mIHN0ZXBzIGZvciB1c2VyIHRvIGZvbGxvdy4gSXQgY2FuIGJlIHVzZWQgYXMgYSBjaGVja2xpc3RcbiAqIHRvIGluZGljYXRlIGNvbXBsZXRlZCwgY3VycmVudCBhbmQgcmVtYWluaW5nIGl0ZW1zLiBJdCBjb3VsZCBiZSBhbHNvIGJlIHVzZWQgdG8gaW5kaWNhdGVcbiAqIHRoZSBzdGF0ZSBvZiBhbiBkb2N1bWVudCwgY3JlYXRlZCwgc3VibWl0dGVkLCBhcHByb3ZlZCwgZXRjLi4uXG4gKlxuICpcbiAqIFVzYWdlOlxuICogICAxLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLiBwcm92aWRlIGEgbGlzdCBvZiBzdGVwcyBhbmQgdGhlIGN1cnJlbnQgc3RlcC5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgPGF3LXN0ZXBwZXIgW3N0ZXBzXT1cInN0ZXBzXCIgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCI+PC9hdy1zdGVwcGVyPlxuICpcbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBzdHJpbmdbXSA9IFsnTW9uaXRvcicsICdBZGQgU3VwcGxpZXInLCAnR2V0IFF1b3RlJ107XG4gKiAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBudW1iZXIgPSAxO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICogICAgICAgfVxuICpcbiAqICAgMi4gIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGNvbG9ycy5cbiAqXG4gKiAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RlcHBlciBbc3RlcHNdPVwic3RlcHNcIiBbc3RlcENvbG9yQ3VycmVudF09XCInI2ZmOTkwMCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBDb2xvclJlbWFpbmluZ109XCInI0NDMDAwMCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBDb2xvckNvbXBsZXRlZF09XCInIzk3YTgyMidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LXN0ZXBwZXI+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdGVwcGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3N0ZXBwZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydzdGVwcGVyLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU3RlcHBlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZFxuICAgICAqIEFycmF5IG9mIHN0ZXBzLiBPcmRlciBvZiB0aGUgc3RlcHMgc2hvdWxkIGJlIGluIGFycmF5IG9yZGVyLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcHM6IHN0cmluZ1tdO1xuXG5cbiAgICAvKipcbiAgICAgKiBzcGVjaWZ5IHRoZSBjb2xvcnMgYXNzb2NpYXRlZCB3aXRoIHN0ZXBzIGFib3ZlLiBUaGUgbnVtYmVyIG9mIGNvbG9yc1xuICAgICAqIGFuZCBudW1iZXIgb2Ygc3RlcHMgbXVzdCBtYXRjaC5cbiAgICAgKiBPcHRpb25hbDosIGlmIGVtcHR5LCBkZWZhdWx0IGNvbG9ycyBvciBjb2xvcnMgZnJvbSBzdGVwQ29sb3IgaW5wdXRzIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbG9yczogc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCB2YXJpYWJsZSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRvIHVzZSB0aGUgY29sb3JzIGFycmF5IG9yIG5vdC5cbiAgICAgKi9cbiAgICBiVXNlQ29sb3JBcnJheTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgSW5wdXQgZm9yIGNhbGxlciB0byBvdmVycmlkZSB0aGUgY29sb3Igb2YgY29tcGxldGVkIHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwQ29sb3JDb21wbGV0ZWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIGN1cnJlbnQgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBDb2xvckN1cnJlbnQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIHJlbWFpbmluZyBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcENvbG9yUmVtYWluaW5nOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGVwIHRoYXQncyBvbi4gSWYgbm90IHByb3ZpZGVkIGRlZmF1bHQgdG8gdGhlIGZpcnN0IHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50U3RlcDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZWQgdGhlIHdpZHRoIG9mIGNvbm5lY3RvcnMgYmV0d2VlbiBzdGVwcy4gVGhlIGNhbGN1bGF0aW9ucyBpcyBzb1xuICAgICAqIHRoYXQgdGhlIHN0ZXBzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seS5cbiAgICAgKi9cbiAgICBjb25uZWN0b3JXaWR0aDogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICAvLyBJbml0aWFsIGNvbG9yIGZvciB0aGUgZGlmZmVyZW50IHN0YWdlcyBvZiBzdGVwcy5cbiAgICAgICAgdGhpcy5zdGVwQ29sb3JDb21wbGV0ZWQgPSBTVEVQUEVSX0NPTVBMRVRFRF9TVEVQX0NPTE9SO1xuICAgICAgICB0aGlzLnN0ZXBDb2xvckN1cnJlbnQgPSBTVEVQUEVSX0NVUlJFTlRfU1RFUF9DT0xPUjtcbiAgICAgICAgdGhpcy5zdGVwQ29sb3JSZW1haW5pbmcgPSBTVEVQUEVSX1JFTUFJTklOR19TVEVQX0NPTE9SO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29ubmVjdG9yIHdpZHRoIGJhc2VkIG9uIGhvdyBtYW55IHN0ZXBzXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGVwcykgJiYgdGhpcy5zdGVwcy5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgICAgIC8vICgxMDAlIC0gMjAlIChzaWRlIG1hcmdpbnMpKSAvIChOdW1PZlN0ZXBzIC0xKVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JXaWR0aCA9IE1hdGguY2VpbCg4MCAvICh0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpKSArICclJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhlIGNvbG9yIGFycmF5IGlmIGl0J3MgZGVmaW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jb2xvcnMpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYlVzZUNvbG9yQXJyYXkgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcnMubGVuZ3RoICE9PSB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNpemUgb2YgdGhlIHN0ZXBzIGFuZCBjb2xvcnMgZG9uJ3QgbWF0Y2g6XG4gICAgICAgICAgICAgICAgICAoc3RlcHMubGVuZ3RoID0gJHt0aGlzLnN0ZXBzLmxlbmd0aH0pLCAoY29sb3JzLmxlbmd0aCA9ICR7dGhpcy5jb2xvcnMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0dGluZyB0aGUgY29sb3Igb2YgdGhlIHN0ZXAgZm9yIHRoZSBjdXJyZW50IGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBnZXRTdGVwQ29sb3IoaW5kZXg6IG51bWJlcilcbiAgICB7XG4gICAgICAgIC8vIENvbG9yIEFycmF5IG92ZXJyaWRlcyBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0aGlzLmJVc2VDb2xvckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5jdXJyZW50U3RlcCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JDb21wbGV0ZWQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U3RlcCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JDdXJyZW50O1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvclJlbWFpbmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0b3IgY29sb3JzIGFyZSBkcml2ZW4gYnkgdGhlIHN0ZXAgY29sb3JzLlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yQ29sb3IoaW5kZXg6IG51bWJlcilcbiAgICB7XG4gICAgICAgIC8vIENvbG9yIEFycmF5IG92ZXJyaWRlcyBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0aGlzLmJVc2VDb2xvckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5jdXJyZW50U3RlcCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JDb21wbGV0ZWQ7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yUmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGVwLlxuICAgICAqL1xuICAgIG5leHRTdGVwKClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXArKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmV2aW91cyBzdGVwLlxuICAgICAqL1xuICAgIHByZXZTdGVwKClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAtLTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmt9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCBzdGVwIGNvbXBvbmVudFxuICpcbiAqICAqIFVzYWdlOlxuICogICAgICAgU3RyYWlnaHQgZm9yd2FyZCB0byB1c2UuIEJ1dCBtb3N0bHkgaXQgd291bGQgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBzdGVwcGVyIGNvbXBvbmVudC5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RlcCBbdGl0bGVdPVwic3RlcFwiIFtjb2xvcl09XCJjb2xvclwiPjwvYXctc3RlcD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICovXG5cbiAgICAvLyBEZWZhdWx0IGNvbG9yIGZvciB0aGlzIHN0ZXAuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gJyM1OGI5NTcnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN0ZXAnLFxuICAgIHRlbXBsYXRlVXJsOiAnc3RlcC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3N0ZXAuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBTdGVwQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIG9mIHN0ZXAgaWNvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbG9yOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiB0aXRsZSBhcHBlYXJzIHVuZGVyIHRoZSBzdGVwIGdyYXBoaWNzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNvbG9yKSkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1N0ZXBwZXJDb21wb25lbnR9IGZyb20gJy4vc3RlcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtTdGVwQ29tcG9uZW50fSBmcm9tICcuL3N0ZXAvc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG5cbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU3RlcHBlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7UGFnZUxpZmVDeWNsZVNlcnZpY2V9IGZyb20gJy4vcGFnZS1saWZlY3ljbGUuc2VydmljZSc7XG5pbXBvcnQge09iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50fSBmcm9tICcuL29iamVjdC1wYWdlLXdyYXBwZXIvb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlQWN0aW9uc0NvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWFjdGlvbnMvcGFnZS1hY3Rpb25zLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VDb250ZW50Q29tcG9uZW50fSBmcm9tICcuL3BhZ2UtY29udGVudC9wYWdlLWNvbnRlbnQuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWZvb3Rlci9wYWdlLWZvb3Rlci5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RlcHBlck1vZHVsZX0gZnJvbSAnLi4vc3RlcHBlci9zdGVwcGVyLm1vZHVsZSc7XG5pbXBvcnQge1NpZGVuYXZDb21wb25lbnR9IGZyb20gJy4vc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0FXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZX0gZnJvbSAnLi4vcGFnZS1ub3RpZmljYXRpb24vcGFnZS1ub3RpZmljYXRpb24ubW9kdWxlJztcbmltcG9ydCB7Um91dGVyTW9kdWxlfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFBhZ2VDb250ZW50Q29tcG9uZW50LFxuICAgICAgICBQYWdlRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBTaWRlbmF2Q29tcG9uZW50XG5cbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdTdGVwcGVyTW9kdWxlLFxuICAgICAgICBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBQYWdlRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgUGFnZUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgT2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBQYWdlQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgUGFnZUZvb3RlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgU2lkZW5hdkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbUGFnZUxpZmVDeWNsZVNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIEFXUGFnZVdyYXBwZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBSaWNoVGV4dEFyZWEgY29tcG9uZW50IHJlcHJlc2VudHMgYSB0ZXh0IGVkaXRvciB3aGljaCBhbGxvd3MgdXNlcnMgdG8gZm9ybWF0IHRleHQgaW5wdXQuXG4gKiBUaGUgZWRpdG9yJ3MgdG9vbGJhciBpcyBwcmUtY29uZmlndXJlZCB0byBjb250YWluIGZ1bmN0aW9uYWxpdGllcyB0aGF0IGFyZSBpbiBvdXIgZGVzaWduLlxuICogQHNlZSB7QGxpbmsgZWRpdG9yL2VkaXRvci5jb21wb25lbnQuaHRtbH1cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JmeC1ldmVudCcgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgICAgPCEtLSBCYXNpYyBVc2FnZS4gLS0+XG4gKiAgICAgICAgPGF3LXJpY2h0ZXh0YXJlYSBbbmFtZV09XCInZGVzY3JpcHRpb24nXCIgW3ZhbHVlXT1cImRlc2NyaXB0aW9uXCIgcGxhY2VIb2xkZXI9XCJwdXRcbiAqICAgICAgICBkZXNjcmlwdGlvblwiPlxuICogICAgICAgIDwvYXctcmljaHRleHRhcmVhPlxuICpcbiAqICAgICAgICA8IS0tIEVkaXRvciB3aXRoIEZ1bGwgZnVuY3Rpb25hbGl0eSAtLT5cbiAqICAgICAgPGF3LXJpY2h0ZXh0YXJlYSBbbmFtZV09XCInY29tbWVudCdcIiBbdHlwZV09XCJlZGl0b3JUeXBlXCIgW3ZhbHVlXT1cInZhbHVlXCJcbiAqICAgICAgcGxhY2VIb2xkZXI9XCJob2xkIHRoaXNcIj5cbiAqICAgICAgPC9hdy1yaWNodGV4dGFyZWE+XG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgZWRpdG9yVHlwZTpFZGl0b3JUeXBlID0gRWRpdG9yVHlwZS5GdWxsO1xuICogICAgICAgIHZhbHVlOlN0cmluZztcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIHRleHQgZWRpdG9yLiBUaGV5IGFyZSBwcmVjb25maWd1cmVkIHdpdGhcbiAqIGZ1bmN0aW9uYWxpdHkgYmFzZWQgb24gdHlwZS4gVXNlIGN1c3RvbSB0byBhZGQgeW91ciBvd24gdG9vbGJhciBtZW51LlxuICovXG5leHBvcnQgZW51bSBFZGl0b3JUeXBlIHtcbiAgICBEZWZhdWx0LCAgICAvLyBEZWZhdWx0IEVkaXRvciBzdXBwb3J0cyBNaW5pbWFsIHNldCBvZiBmdW5jdGlvbmFsaXR5XG4gICAgLy8gWyBib2xkIHwgaXRhbGljIHwgdW5kZXJsaW5lIHwgb3JkZXJlZCB8IGJ1bGxldCB8IGFsaWdubWVudF1cbiAgICBGdWxsLCAgICAgICAvLyBUaGUgZnVsbCBsaXN0IG9mIGZ1bmN0aW9uYWxpdHksXG4gICAgVGV4dEZvcm1hdCwgLy8gRnVuY3Rpb25hbGl0aWVzIHRoYXQgYWZmZWN0cyB0ZXh0IGZvcm1hdHRpbmcuXG4gICAgQ3VzdG9tICAgICAvLyBDdXN0b20gdG9vbGJhci5cbn1cblxuXG5leHBvcnQgY29uc3QgRURJVE9SX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSaWNoVGV4dEFyZWFDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmljaHRleHRhcmVhJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3JpY2gtdGV4dC1hcmVhLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsncmljaC10ZXh0LWFyZWEuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgRURJVE9SX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmljaFRleHRBcmVhQ29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgUmljaFRleHRBcmVhQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBlZGl0b3IuICBTZWUgRWRpdG9yVHlwZSBmb3IgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBFZGl0b3JUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHNhdmUgYW5kIHJlYWQgd2hlbiByZW5kZXJpbmcgYW5kIHVwZGF0aW5nIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgZWRpdG9yVHlwZSBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIHRoaXMgY29tcG9uZW50cyB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBFZGl0b3JUeXBlOiBhbnkgPSBFZGl0b3JUeXBlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IEVkaXRvclR5cGUuRGVmYXVsdDtcbiAgICAgICAgdGhpcy5zdHlsZUNsYXNzID0gJ2RlZmF1bHQtZWRpdG9yJztcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICAgICkuc3Vic2NyaWJlKHZhbCA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RWRpdG9yTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge1JpY2hUZXh0QXJlYUNvbXBvbmVudH0gZnJvbSAnLi4vcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSaWNoVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRWRpdG9yTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUmljaFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJpY2hUZXh0QXJlYUNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdSaWNoVGV4dEFyZWFNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QWNjb3JkaW9uVGFifSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuXG4vKipcbiAqIEFsbG93IGRldmVsb3BlciB0byBvdmVycmlkZSBkZWZhdWx0IGFjdGlvbnMuIE11c3QgaGF2ZSB0aGlzIGRlY2xhcmVkIGJlZm9yZSBjbGFzcyB3aGVuIHdlXG4gKiB3YW50IHRvIGhhdmUgdGhpcyBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlIHNhbWUgZmlsZS5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zZWN0aW9uLWFjdGlvbnMnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiBgLFxufSlcbmV4cG9ydCBjbGFzcyBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudFxue1xuXG59XG5cblxuLyoqXG4gKlxuICogU2VjdGlvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGEgc2VjdGlvbiBvZiB0aGUgcGFnZS4gSXQncyBhbiBvdXRsaW5lIGJveCB0aGF0XG4gKiBoYXMgdGhlIGFiaWxpdHkgdG8gZXhwYW5kIGFuZCBoaWRlIGl0cyBjb250ZW50LlxuICpcbiAqIGBgYHRzXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JmeC1kZXRhaWxzJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlNvdXJjaW5nIHJlcXVlc3QgaW5mb1wiIChvbkVkaXQpPVwib25TdGF0ZUNoYW5nZSgkZXZlbnQpXCJcbiAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICA8bS1jb250ZXh0IFtvYmplY3RdPVwicmZ4RW50aXR5LmhlYWRlckluZm9cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFtvcGVyYXRpb25dPVwidGhpcy5lZGl0YWJpbGl0eVN0YXRlLmhlYWRlckluZm9PcFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0PVwiSW5zcGVjdFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdWlHcm91cD1cIkhlYWRlckdlbmVyYWxcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxtLWluY2x1ZGUtY29tcG9uZW50PjwvbS1pbmNsdWRlLWNvbXBvbmVudD5cbiAqICAgICAgICAgICAgICAgPC9tLWNvbnRleHQ+XG4gKiAgICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqXG4gKiAgICAgICAgICAgPGF3LXNlY3Rpb24gI3N1cHBsaWVyU2VjdGlvbiB0aXRsZT1cIlNlbGVjdGVkIHN1cHBsaWVyc1wiIChvbk9wZW4pPVwib25PcGVuKClcIlxuICAgKiAgICAgICAgICAgICAgICBbb3BlbmVkXT1cImZhbHNlXCI+XG4gKiAgICAgICAgICAgICAgIDxzdXBwbGllci1wcm9maWxlLWNhcmQ+PC9zdXBwbGllci1wcm9maWxlLWNhcmQ+XG4gKiAgICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqICAgICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlJGUSBEZXRhaWxzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj1cIlJldmlldyBhbmQgdXBkYXRlIGluZm9ybWF0aW9uIGZvciBzdXBwbGllcnMgdG8gcmVzcG9uZC5cIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlQ2xvc2VdPVwidHJ1ZVwiPlxuICpcbiAqICAgICAgICAgICAgICAgPGF3LXN1YnNlY3Rpb24gdGl0bGU9XCJFdmVudCB0aW1lbGluZVwiPlxuICogICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgW3VzZUZpdmVab25lXT1cImZhbHNlXCIgW2VkaXRhYmxlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInU3RhcnQgRGF0ZSdcIiBbbmFtZV09XCInc3RhcnREYXRlJ1wiIFtzaXplXT1cIidzbWFsbCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtoaWdobGlnaHRSb3ddPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGF0ZS10aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXROYW1lPVwiZGF0ZVRpbWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInN0YXJ0RGF0ZVwiIFt2YWx1ZV09XCJyZnhFbnRpdHkuY3JlYXRlZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2hvd1RpbWVdPVwidHJ1ZVwiPjwvYXctZGF0ZS10aW1lPlxuICogICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKiAgICAgICAgICAgICAgIDwvYXctc3Vic2VjdGlvbj5cbiAqICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICogU2VjdGlvbiBjb21wb25lbnQgYWxzbyBzdXBwb3J0cyBlZGl0YWJpbGl0eSBtb2RlcyBhbmQgaWYgZW5hYmxlZCBpdCB3aWxsIHJlbmRlciBhY3Rpb24gYnV0dG9uc1xuICogaW4gdGhlIGZvb3Rlci4gRGV2ZWxvcGVyIGNhbiBhbHNvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IgYW5kIHByb3ZpZGUgY3VzdG9tIGFjdGlvbnMuXG4gKlxuICpcbiAqIGUuZzpcbiAqXG4gKiBgYGBcbiAqICAgICAgPGF3LXNlY3Rpb24gW3RpdGxlXT1cInRpdGxlXCIgW2VkaXRhYmxlXT1cInRydWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNhbmNlbEFjdGlvbik9XCJzb21lSGFuZGxlcjEoJGV2ZW50KVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2F2ZUFjdGlvbik9XCJzb21lSGFuZGxlcjIoJGV2ZW50KVwiID5cbiAqICAgICAgICAgICAgICBzZWN0aW9uIGNvbnRlbnRcbiAqXG4gKlxuICogICA8L2F3LXNlY3Rpb24+XG4gKlxuICogYGBgXG4gKlxuICogb3IgY3VzdG9tIGFjdGlvbiBidXR0b25zOlxuICpcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogICAgICAgPGF3LXNlY3Rpb24tYWN0aW9ucz5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQnV0dG9uVGVzdDFcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1dHRvblRlc3QyXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICA8L2F3LXNlY3Rpb24tYWN0aW9ucz5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogVGhlcmUgYXJlIHR3byBlZGl0IG1vZGVzXG4gKiAgIyBEZWZhdWx0XG4gKiAgICAgIFJlbmRlcnMgYWN0aW9uIGJ1dHRvbnMgaW4gdGhlIGZvb3RlcnMgYW5kIGVtaXQgYWN0aW9ucyB0byB0aGUgYXBwbGljYXRpb25cbiAqXG4gKiAgIyBFeHRlcm5hbFxuICogICAgIE5vIGFjdGlvbiBidXR0b25zIGFyZSBzaG93biBpbiB0aGUgZm9vdGVyIGFuZCBiZWhhdmlvciBpcyBoYW5kbGVkIGJ5IGFwcGxpY2F0aW9uLiBPbmx5IGV2ZW50XG4gKiAgICAgaXMgZW1pdGVkLlxuICpcbiAqXG4gKiAgZS5nOlxuICpcbiAqICBgYGB0c1xuICpcbiAqICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJVc2VyIEluZm9ybWF0aW9uXCIgKG9uRWRpdCk9XCJvbkFkZFNvbWV0aGluZygkZXZlbnQpXCJcbiAqICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cInRydWVcIiBbZWRpdE1vZGVdPVwiJ2V4dGVybmFsJ1wiID5cbiAqICAgICAgICAgICAgICAgICAgPGRpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgIENvbnRlbnRcbiAqICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKiAgYGBgXG4gKlxuICogTm90ZTogV2hlbiB1c2luZyBlZGl0aW5nIG1vZGUgeW91IGhhdmUgdG8gY2FsbCBhdCB0aGUgZW5kIG9mIHRoZSBlZGl0aW5nIGN5Y2xlIG1ldGhvZFxuICogYGNvbXBsZXRlRWRpdGluZygpYCB0byBjb21taXQgZWRpdGluZyB3aGljaCBjaGFuZ2VzIGludGVybmFsIHN0YXRlIG9mIHRoZSBTZWN0aW9uLlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNlY3Rpb24nLFxuICAgIHRlbXBsYXRlVXJsOiAnc2VjdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3NlY3Rpb24uY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBTZWN0aW9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoaXMgc2VjdGlvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGlzIHNlY3Rpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoaXMgc2VjdGlvbiBiZSBvcGVuZWQgYXQgdGhlIHN0YXJ0LiBEZWZhdWx0IGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9wZW5lZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2VjdGlvbiBjYW4gYmUgY2xvc2VkIG9yIG5vdC5cbiAgICAgKiovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlQ2xvc2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBzZWN0aW9uIGlzIGluIEVkaXRTdGF0ZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBXaGVuIGluIGVkaXRpbmcgc3RhdGUgYW5kIHdlIHNob3cgXCJDYW5jZWwgLyBTYXZlXCIgYnV0dG9uIGRldmVsb3BlciBuZWVkcyB1c2UgdGhpcyBiaW5kaW5nXG4gICAgICogdG8gY29udHJvbCB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0U3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBFZGl0aW5nIG1vZGUuIFRlbGxzIHRoZSBjb21wb25lbnRzIGlmIGl0cyBpdHMgZGVmYXVsdCBiZWhhdmlvciBvciBkcml2ZW4gYnlcbiAgICAgKiBhcHBsaWNhdGlvbiB1c2luZyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIHtAc2VlIEVkaXRNb2RlfVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0TW9kZTogRWRpdE1vZGUgPSAnZGVmYXVsdCc7XG5cblxuICAgIC8qKlxuICAgICAqIERldmVsb3BlciBjYW4gcHJvdmlkZSBjdXN0b20gRWRpdCBhY3Rpb24gaWNvbiB0aGF0IHdpbGwgYXBwZWFyIGluIHRoZSByaWdodCB0b3AgY29ybmVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhY3Rpb25JY29uOiBzdHJpbmcgPSAnaWNvbi1lZGl0JztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBmdWxseSBvcGVuZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBmdWxseSBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFZGl0IHN0YXRlIHRvIGJyb2FkY2FzdCBzdGF0ZSBvZiBjdXJyZW50IHNlY3Rpb25cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkVkaXQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGluIGVkaXRpbmcgc3RhdGUgYW5kIGRlZmF1bHQgYnV0dG9ucyBhcmUgcmVuZGVyZWQgb24gY2xpY2sgYnJvYWRjYXN0IENhbmNlbCBhY3Rpb25cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNhbmNlbEFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW4gZWRpdGluZyBzdGF0ZSBhbmQgZGVmYXVsdCBidXR0b25zIGFyZSByZW5kZXJlZCBvbiBjbGljayBicm9hZGNhc3QgU2F2ZSBhY3Rpb25cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNhdmVBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICBAT3V0cHV0KClcbiAgICBvbkVkaXRpbmdDb21wbGV0ZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCB2YXJpYWJsZSBvbiB3aGV0aGVyIHRoaXMgc2VjdGlvbiBpcyBleHBhbmRlZCBvciBub3QuXG4gICAgICogRGlmZmVycyBmcm9tICdvcGVuZWQnLiBvcGVuZWQgaXMgYW4gaW5wdXQgcGFyYW1ldGVyIGFuZCBpdCBkb2Vzbid0IHRyYWNrXG4gICAgICogY3VycmVudCBzZWN0aW9uIGV4cGFuZGVkIHN0YXRlLlxuICAgICAqL1xuICAgIGV4cGFuZGVkOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgYWNjb3JkaW9uVGFiXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnYWNjb3JkaW9uVGFiJylcbiAgICBwcml2YXRlIGFjY29yZGlvblRhYjogQWNjb3JkaW9uVGFiO1xuXG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHJlZmVyZW5jZSB0byBkZXZlbG9wZXIncyBkZWZpbmVkIGFjdGlvbnMgc28gaWYgd2UgY2FuIGhpZGUgZGVmYXVsdCBvbmVzXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChTZWN0aW9uQWN0aW9uc0NvbXBvbmVudClcbiAgICBjdXN0b21BY3Rpb25zOiBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICAvLyBJZiBJIGhhdmUgbm90IGhlYWRlciwgdGhlbiBJIGNhbid0IGNsb3NlIHRoZSBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFkZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgSSBjYW4ndCBjbG9zZSB0aGUgc2VjdGlvbiwgdGhlbiBpdCBzaG91bGQgZGVmYXVsdCBvcGVuLlxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZXhwYW5kZWQgc3RhdGUuXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0aGlzLm9wZW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb24ndCBkaXNwbGF5IGhlYWRlciBhcmVhIGlmIEkgZG9uJ3QgaGF2ZSB0aXRsZSBhbmQgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzSGVhZGVyRGlzcGxheWVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAoaXNQcmVzZW50KHRoaXMudGl0bGUpIHx8IGlzUHJlc2VudCh0aGlzLmRlc2NyaXB0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3NzIENsYXNzIHRoYXQgY29udHJvbCB0aGUgbG9vayBhbmQgZmVlbCBmb3Igc2VjdGlvbiBjb21wb25lbnQuXG4gICAgICovXG4gICAgYUNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhZGVyRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VjdGlvbi1uby1oZWFkZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIGludHJvZHVjZWQgYnV0dG9ucyBhbmQgZWRpdFN0YXRlIHRoZSBkZWNpc2lvbiBvbiB3aGVuIHRvIGV4aXQgZWRpdGluZyBtb2RlXG4gICAgICogc2hvdWxkIGJlIG9uIHRoZSBkZXZlbG9wZXIgdXNpbmcgdGhpcyBjb21wb25lbnQgdGhlcmVmb3JlIG9ubHkgc3RhcnRFZGl0aW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkVkaXRBY3Rpb24oJGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIC8vIHdoZW4gaW4gZWRpdGluZyBtYWtlIHN1cmUgd2UgZG9udCBzd2l0Y2ggc3RhdGUgYXMgdGhlcmUgY2FuIGJlIHNvbWUgRm9ybSBlcnJvcnNcbiAgICAgICAgLy8gd2hpY2ggbmVlZHMgdG8gYmUgaGFuZGxlZCBieSBkZXZlbG9wZXIgYW5kIG9ubHkgdGhlbiBjaGFuZ2UgdGhlIGVkaXRTdGF0ZVxuICAgICAgICBpZiAoIXRoaXMuZWRpdFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRTdGF0ZSA9ICF0aGlzLmVkaXRTdGF0ZTtcbiAgICAgICAgICAgIGxldCBzdGF0ZTogc3RyaW5nID0gKHRoaXMuZWRpdFN0YXRlKSA/ICdpbkVkaXQnIDogJ25vdEluRWRpdCc7XG5cbiAgICAgICAgICAgIHRoaXMub25FZGl0LmVtaXQoc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSBvcmlnaW5hbCBldmVudCBmcm9tIGJ1YmJsaW5nIHVwLiBCZWNhdXNlIHRoZSBlZGl0IGljb24gaXMgaW5zaWRlXG4gICAgICAgIC8vIHRoZSBoZWFkZXIuIElmIHRoZSBjbGljayBldmVuIGlzIGJ1YmJsZWQgdXAsIHRoaXMgZXZlbnQgd2lsbCBjYXVzZSB0aGUgc2VjdGlvbiB0b1xuICAgICAgICAvLyBleHBhbmQgb3IgY29sbGFwc2UuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoJGV2ZW50LmV2ZW50KSkge1xuICAgICAgICAgICAgJGV2ZW50LmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgJGV2ZW50LmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNEZXNjcmlwdGlvbigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhpcyBzZWN0aW9uLCBpZiBpdCdzIGFscmVhZHkgb3Blbiwgd2lsbCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIG9wZW4oZXZlbnQ/OiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvcmRpb25UYWIudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoaXMgc2VjdGlvbiwgaWYgaXQncyBhbHJlYWR5IGNsb3NlLCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgY2xvc2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvblRhYi50b2dnbGUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFjY29yZGlvbiBpcyBvcGVuZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU2VjdGlvbk9wZW4oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCdvcGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFjY29yZGlvbiBpcyBjbG9zZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU2VjdGlvbkNsb3NlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCdjbG9zZScpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyB1cyBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhcHBsaWNhdGlvbiBkZWZpbmVkIGN1c3RvbSBhY3Rpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNDdXN0b21BY3Rpb25zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jdXN0b21BY3Rpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBlZGl0aW5nIHN0YXRlIGJhY2sgdG8gbm9uLWVkaXRhYmxlXG4gICAgICovXG4gICAgY29tcGxldGVFZGl0aW5nKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZWRpdFN0YXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25FZGl0aW5nQ29tcGxldGUuZW1pdCh0aGlzLmVkaXRTdGF0ZSk7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN1YnNlY3Rpb24nLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cInN1YnNlY3Rpb24tdGl0bGVcIj57e3RpdGxlfX08L2g0PlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgIGAsXG4gICAgc3R5bGVzOiBbJy5zdWJzZWN0aW9uLXRpdGxlIHtjb2xvcjogIzM2MzYzNjsgfSddXG59KVxuZXhwb3J0IGNsYXNzIFN1YlNlY3Rpb25Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIHN1YiBzZWN0aW9uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xufVxuXG5cbi8qKlxuICogRGVmaW5lcyBlZGl0aW5nIG1vZGVzIGZvciB0aGUgU2VjdGlvbnMuIERlZmF1bHQgbWVhbnMgd2Ugc2hvdyBjYW5jZWwgLyBzYXZlIGJ1dHRvbnMgYW5kIGhpZGVcbiAqIGVkaXQgaWNvbnMgd2hlbiBpbiBlZGl0aW5nLiBleHRlcm5hbCBpcyBkcml2ZW4gYnkgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgRWRpdE1vZGUgPSAnZGVmYXVsdCcgfCAnZXh0ZXJuYWwnO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0FyaWJhQ29yZU1vZHVsZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7QWNjb3JkaW9uTW9kdWxlLCBTaGFyZWRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge1NlY3Rpb25BY3Rpb25zQ29tcG9uZW50LCBTZWN0aW9uQ29tcG9uZW50LCBTdWJTZWN0aW9uQ29tcG9uZW50fSBmcm9tICcuL3NlY3Rpb24uY29tcG9uZW50JztcbmltcG9ydCB7QVdIeXBlcmxpbmtNb2R1bGV9IGZyb20gJy4uL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4uL2J1dHRvbi9idXR0b24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTdWJTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFjY29yZGlvbk1vZHVsZSxcbiAgICAgICAgQXJpYmFDb3JlTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIFNoYXJlZE1vZHVsZVxuICAgIF0sXG5cbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU3ViU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU2VjdGlvbkFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFN1YlNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU2VjdGlvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgSW5wdXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZX0gZnJvbSAnLi4vYXctZGF0YXRhYmxlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtCb29sZWFuV3JhcHBlciwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbmV4cG9ydCB0eXBlIERUSEFsaWdubWVudCA9ICdsZWZ0JyB8ICdjZW50ZXInIHwgJ3JpZ2h0JztcblxuXG4vKipcbiAqIERUQ29sdW1uIHJlcHJlc2VudCBzaW5nbGUgY29sdW1uIGluY2x1ZGluZyBoZWFkZXIgYW5kIGl0cyBib2R5LiBFYWNoIGNvbHVtbiBoYXMgaXRzIG93blxuICogcmVuZGVyZXJUZW1wbGF0ZSB3aGljaCBhIGVudHJ5IHRvIHRoaXMgY29tcG9uZW50LlxuICpcbiAqIEtlZXBpbmcgdGhpcyBzZXBhcmF0ZSBmcm9tIHRoZSBkYXRhdGFibGUgd2hlcmUgRFQgaXMgbm90IHJlYWxseSBhd2FyZSB3aGF0IGl0IGlzIHJlbmRlcmluZyxcbiAqIGl0IGFsbG93cyB1cyBtb3JlIGZsZXhpYmlsaXR5IGluIHRlcm1zIG9mIGRpZmZlcmVudCB0eXBlIG9mIGNvbHVtbiBpbmhlcml0aW5nIGZyb20gdGhpc1xuICogb25lLi4gU3VjaCBhczpcbiAqICBEVFJvd0RldGFpbCAgY29sdW1uXG4gKiAgRFRTaW5nbGVTZWxlY3Rpb24gY29sdW1uXG4gKiAgRFRNdWx0aVNlbGVjdGlvbiBjb2x1bW5cbiAqXG4gKiBUaGlzIHdheSB3ZSBkb24ndCBkbyBJRi9USEVOL0VMU0UgaW5zaWRlIHRoZSBkYXRhdGFibGUgYW5kIHRyeWluZyB0byBjcmVhdGUgZGlmZmVyZW50IGNhc2VzLlxuICpcbiAqICBUaGVuIGxhdGVyIG9uIHRoaXMgd2lsbCBsZXQgdXMgY3JlYXRlIGFkZGl0aW9uYWwgbG9naWMgZm9yIHRoZSBwaXZvdGFsIGxheW91dC4gQmVjYXVzZSBEVFxuICogIGRvZXMga25vdyBhbnl0aGluZyBhYm91dCB0aGUgdHlwZSBvZiB0aGUgY29sdW1uIHNvIHdoYXRldmVyIGlzIGFkZGVkIHRvIHRoZSBEVC5jb2x1bW5zIGl0XG4gKiAgd2lsbCBiZSByZW5kZXJlZC5cbiAqXG4gKlxuICogIENvbHVtbnMgY2FuIGJlIGFsc28gZnJvemVuIG1lYW5pbmcgaWYgdGhlIGNvbnRlbnQgb3ZlcmZsb3dzIHRoZXkgZG9udCBzY3JvbGwuIFRvIG1ha2UgdGhlXG4gKiAgY29sdW1uIGZyb3plbiB3ZSBuZWVkIHRvIHVzZSBbZnJvemVuXSBiaW5kaW5nIGFuZCBzZSBpdCB0byBUUlVFIHBsdXMgaXQgcmVxdWlyZXMgYSBbd2lkdGhdXG4gKiAgYmluZGluZyB0byBiZSBzZXQgKGluIHB4KS5cbiAqICBXZSBuZWVkIHRoaXMgdG8gYmUgYWJsZSB0byBwcm9wZXJseSBwb3NpdGlvbiB0aGUgc2Vjb25kIHRhYmxlIHdoaWNoIGlzIGNoYW5nZWQgdG8gYWJzb2x1dGVcbiAqICBwb3NpdGlvbmluZy5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1jb2x1bW4yJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2R0LWNvbHVtbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2R0LWNvbHVtbi5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVENvbHVtbjJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBoZWFkZXIgbGFiZWwuXG4gICAgICpcbiAgICAgKiBPciB5b3UgY2FuIHVzZSBoZWFkZXJUZW1wbGF0ZSB0byBkZWZpbmUgeW91ciBvd24gdGVtcGxhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGZpZWxkIG5hbWUgdG8gcmVhZCBmcm9tIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDZWxsIGFsaWdubWVudC4gSXQgaW5zZXJ0cyByZWd1bGFyIGFsaWduIGF0dHJpYnV0ZSB0byB0aGUgdGFibGUgY2VsbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbjogRFRIQWxpZ25tZW50ID0gJ2xlZnQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZHluYW1pYyBjbGFzcyBiYXNlZCBvbiBkYXRhIGFuZCB0aGVuIGl0cyBhZGRlZCB0byB0aGUgdGFibGUgY2VsbCBURFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElmIGZhbHNlIGFwcGxpZXMgZHQtaXMtaGlkZGVuIHN0eWxlIHRoYXQgaGlkZXMgdGhlIGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogTWFya3MgY29sdW1uIGFzIHNvcnRhYmxlIHdoaWNoIG1lYW5zIHNvcnRpbmcgaWNvbiBpcyBhZGRlZCB0byB0aGUgaGVhZGVyIHdpdGggc3BlY2lhbFxuICAgICAqIHNvcnRpbmcgaGFuZGxpbmdcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNvcnRhYmxlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0aW5nIGRpcmVjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzb3J0T3JkZXJpbmc6IHN0cmluZyA9ICdkZXNjZW5kaW5nJztcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSB0ZW1wbGF0ZSBpZiB3aGV0aGVyIHRvIHJlbmRlciBhIGxhYmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dDb2x1bW5MYWJlbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGljIGNsYXNzIHRoYXQgaXMgYWRkZWQgdG8gdGhlIFRIIGludG8gdGhlIGhlYWRlci4gSXQgZG9lcyBub3QgcmVseSBvbiBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlYWRlclN0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGljIGNsYXNzIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRkIGludG8gdGhlIGJvZHkuIEl0IGRvZXMgbm90IHJlbHkgb24gZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5U3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHRvZ2V0aGVyIHdpdGggY2VsbCBzZWxlY3Rpb25Nb2RlIHRvIHRlbGwgd2hpY2ggY29sdW1uIGlzIHNlbGVjdGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgSEVBREVSIHRlbXBsYXRlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgU3ViSGVhZGVyIHRlbXBsYXRlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxTdWJIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgYm9keSB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxCb2R5OiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGNvbHVtbiBpcyBkYXRhIGNvbHVtbiAgLSBpZiBpdCBpcyByZW5kZXJpbmcgZGF0YSBvciBqdXN0IGEgbGFiZWwgb3Igc29tZVxuICAgICAqIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IHdoZW4gY2FsY3VsYXRpbmcgYSBjb2x1bW4gc3BhbiBhbmQgd2UgbmVlZCB0byBrbm93IHdoaWNoIGNvbHVtbnMgYXJlIG9yXG4gICAgICogd2lsbCBiZSBqdXN0IGZvciBzZWxlY3Rpb24gY29udHJvbHMgYW5kIHdoaWNoIGhvbGRzIGRhdGFcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzRGF0YUNvbHVtbjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGNvbHVtbiB0aGF0IHdpbGwgbm90IHNjcm9sbCBob3Jpem9udGFsbHkgd2l0aCBvdGhlciBjb2x1bW5zLiBDb2x1bW4gaXNcbiAgICAgKiBmcm96ZW4uXG4gICAgICpcbiAgICAgKiBGb3Igc3VjaCBjb2x1bW5zIHRoYXQgYXJlIG1hcmtlZCBhcyBmcm96ZW4gYmluZGluZyBbd2lkdGhdIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1heCBXaWR0aCBmb3IgdGhlIFRELiBFdmVuIFREIGRvZXMgbm90IHN1cHBvcnQgd2UgY2FsY3VsYXRlIHRoZSBjb250ZW50IHdpZHRoXG4gICAgICogZm9yIGVhY2ggY2VsbCBhbmQgdGhlbiBkZWNpZGUgaWYgd2UgbmVlZCB0byBlbmxhcmdlIHRoZSBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBARXhwZXJpbWFudGFsIGJpbmRpbmcgdGhhdCBpcyBjdXJyZW50bHkgd29ya2luZyBpZiB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBpcyBpbmxpbmVcbiAgICAgKiBlbGVtZW50IHdoZXJlIHdlIGNhbiBjb250cm9sIHdoaXRlc3BhY2Ugd3JhcHBpbmcgaW4gb3JkZXIgdG8gZmluZCBvdXQgdGhlIHJlYWwgd2lkdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heFdpZHRoOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1pbldpZHRoIG9uIHRoZSBjZWxsLiBBZ2FpbiBqdXN0IGxpa2UgbWF4V2lkdGggY3NzIHByb3Blcmx5IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICAgKiB0aGUgdGFibGUgc28gdGhlcmUgaXMgYSB3b3JrYXJvdW5kIHdoZXJlIHdlIGNyZWF0ZSBhZGRpdGlvbmFsIHJvdyB0aGF0IHNldHMgcGFkZGluZyByaWdodFxuICAgICAqIGFuZCB0aGlzIHdpbGwgcHJldmVudCB0aGUgY29sdW1uIHRvIGNvbGxhcHNlIHVuZGVyIHNwZWNpZmllZCB3aWR0aFxuICAgICAqXG4gICAgICogdG9kbzogc3RpbGwgVEJEXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtaW5XaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTWFpbiByZW5kZXJpbmcgdGVtcGxhdGUgdXNlZCBieSBkYXRhdGFibGUgdG8gcmVuZGVyIGVhY2ggY29sdW1uLlxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3JlbmRlcmluZ1RlbXBsYXRlJylcbiAgICByZW5kZXJlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGhlYWRlciB0ZW1wbGF0ZS4gSXQgd2lsbCBvdmVycmlkZSBwcm92aWRlZCBsYWJlbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlcicpXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gc3ViSGVhZGVyIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ3N1YkhlYWRlcicpXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gYm9keSB0ZW1wbGF0ZSB0aGF0IHdpbGwgb3ZlcnJpZGUgcmVhZCB2YWx1ZSBmcm9tIHRoZSBba2V5XSBiaW5kaW5nXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4uLlxuICAgICAqL1xuICAgIHNvcnRPcmRlcjogbnVtYmVyO1xuICAgIG1heFdpZHRoUHg6IG51bWJlciA9IDA7XG4gICAgbWluV2lkdGhQeDogbnVtYmVyID0gMDtcbiAgICB3aWR0aFB4OiBudW1iZXIgPSAwO1xuICAgIHdpZGVzdENlbGw6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gRGF0YXRhYmxlIEltcGxlbWVudGF0aW9uc1xuICAgICAqL1xuICAgIGR0OiBBV0RhdGFUYWJsZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmtleSkgJiYgaXNCbGFuayh0aGlzLmxhYmVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGJpbmRpbmc6ICcgK1xuICAgICAgICAgICAgICAgICdba2V5XSBvciBbbGFiZWxdIGJpbmRpbmdzIG11c3QgYmUgdXNlZCBhdCBtaW5pbXVtJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBiZSBhYmxlIHRvIHBvc2l0aW9uIHNlY29uZCBEVCB3ZSByZXF1aXJlIFt3aWR0aF0gdG8gYmUgc2V0IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMuZnJvemVuICYmIGlzQmxhbmsodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBiaW5kaW5nIFt3aWR0aF06ICcgK1xuICAgICAgICAgICAgICAgICd3aGVuIFtmcm96ZW5dPXRydWUgdGhlbiBbd2lkdGhdIGJpbmRpbmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcblxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBuZWVkIHRvIGRlZmZlciB0aGlzIGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gb3RoZXJ3aXNlIEkgZ2V0XG4gICAgICAgIC8vIHZhbHVlIHdhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkIGVycm9yXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgLy8ge1xuXG4gICAgICAgIC8vIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBjZWxsIHNlbGVjdGlvbk1vZGUgaXMgZW5hYmxlZCB0aGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB3ZSBjbGljayBvbiBoZWFkZXIuXG4gICAgICogSXQgZGVsZWdhdGVzIHRoZSBjYWxsIHRvIHRoZSBEVCB3aGVyZSBpdCB0b2dnbGVzIGN1cnJlbnRseSBzZWxlY3RlZCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlSGVhZGVyQ2xpY2soZXZlbnQ6IGFueSwgZWxlbWVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHQub25IZWFkZXJTZWxlY3Rpb25DaGFuZ2UoZWxlbWVudCwgdGhpcyk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUb2RvOiBJbXBsZW1lbnQgb3VyIG93biBzb3J0aW5nIG1lY2hhbmlzbSBvbmNlIHdlIGV4dHJhY3QgdGhlIHNvcnRpbmcgbG9naWMgdG8gaXRzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgc29ydChldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3ModGFyZ2V0Tm9kZSwgJ2R0LXUtc29ydGFibGUnKSB8fFxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHRhcmdldE5vZGUsICdkdC1jb2wtdGl0bGUnKSB8fFxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHRhcmdldE5vZGUsICdkdC1jb2wtc29ydGFibGUtaWNvbicpKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmR0LnNvcnRDb2x1bW4ua2V5ID09PSB0aGlzLmtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyID0gdGhpcy5zb3J0T3JkZXIgKiAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRPcmRlcmluZyA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yTnVtYmVyKHRoaXMuc29ydE9yZGVyKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LnNvcnRDb2x1bW4gPSB0aGlzO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuc29ydEtleSA9IHRoaXMua2V5O1xuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLnNvcnRPcmRlciA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuc29ydE9yZGVyaW5nKTtcblxuICAgICAgICAgICAgdGhpcy5kdC5zb3J0U2luZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kdC51cGRhdGVEYXRhVG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIHN0eWxlIGNsYXNzIGJhc2VkIG9uIGRhdGFcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgZHluYW1pY0JvZHlDbGFzcyhpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgZHluQ2xhc3MgPSBpc1ByZXNlbnQodGhpcy5ib2R5Q2xhc3NGbilcbiAgICAgICAgICAgID8gdGhpcy5ib2R5Q2xhc3NGbi5hcHBseSh0aGlzLmR0LmNvbnRleHQsIFt0aGlzLCBpdGVtXSkgOiAnJztcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYm9keVN0eWxlQ2xhc3MpKSB7XG4gICAgICAgICAgICBkeW5DbGFzcyArPSAnICcgKyB0aGlzLmJvZHlTdHlsZUNsYXNzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIGR5bkNsYXNzICs9ICcgJyArIHRoaXMuc3R5bGVDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkeW5DbGFzcztcbiAgICB9XG5cblxuICAgIGlzUm93U2VsZWN0YWJsZShpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuaXNSb3dTZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHQuaXNSb3dTZWxlY3RhYmxlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlzQ2VsbFNlbGVjdGFibGUoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHQuc2VsZWN0aW9uTW9kZSA9PT0gJ2NlbGwnICYmIHRoaXMuaXNSb3dTZWxlY3RhYmxlKGl0ZW0pICYmIHRoaXMuc2VsZWN0YWJsZTtcblxuICAgIH1cblxuXG4gICAgaXNIZWFkZXJTZWxlY3RhYmxlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LnNlbGVjdGlvbk1vZGUgPT09ICdjZWxsJyAmJiB0aGlzLnNlbGVjdGFibGU7XG5cbiAgICB9XG5cblxuICAgIGdldFNvcnRPcmRlcigpXG4gICAge1xuICAgICAgICBsZXQgb3JkZXIgPSAwO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmtleSA9PT0gdGhpcy5kdC5zb3J0Q29sdW1uLmtleSkge1xuICAgICAgICAgICAgb3JkZXIgPSB0aGlzLmR0LnNvcnRDb2x1bW4uc29ydE9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG5cbiAgICBpc1NvcnRlZCgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZHQuc29ydENvbHVtbikgJiYgdGhpcy5rZXkgPT09IHRoaXMuZHQuc29ydENvbHVtbi5rZXk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSh0YWJsZTogQVdEYXRhVGFibGUpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0ID0gdGFibGU7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LmluaXRpYWxTb3J0S2V5KSAmJiB0aGlzLmR0LmluaXRpYWxTb3J0S2V5ID09PSB0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuZHQuaW5pdGlhbFNvcnRPcmRlcik7XG4gICAgICAgICAgICB0aGlzLmR0LnNvcnRDb2x1bW4gPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5ib2R5VGVtcGxhdGUpICYmIHRoaXMudXNlR2xvYmFsQm9keSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5VGVtcGxhdGUgPSB0aGlzLmR0LmJvZHlUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuaGVhZGVyVGVtcGxhdGUpICYmIHRoaXMudXNlR2xvYmFsSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRlbXBsYXRlID0gdGhpcy5kdC5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3ViSGVhZGVyVGVtcGxhdGUpICYmIHRoaXMudXNlR2xvYmFsU3ViSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YkhlYWRlclRlbXBsYXRlID0gdGhpcy5kdC5zdWJIZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuYm9keUNsYXNzRm4pKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHlDbGFzc0ZuID0gdGhpcy5kdC5ib2R5Q2xhc3NGbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF4V2lkdGhQeCA9IHRoaXMud2lkdGhUb1B4KHRoaXMubWF4V2lkdGgpO1xuICAgICAgICB0aGlzLm1pbldpZHRoUHggPSB0aGlzLndpZHRoVG9QeCh0aGlzLm1pbldpZHRoKTtcbiAgICAgICAgdGhpcy53aWR0aFB4ID0gdGhpcy53aWR0aFRvUHgodGhpcy53aWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHZpZXcgaW5pdCBjeWNsZSBmcm9tIHRoZSBkdC5uZ0FmdGVyVmlld0NoZWNrZWQuXG4gICAgICpcbiAgICAgKiBJbiBjYXNlIHdlIHVzZSBNYXhXaWR0aCBkaXJlY3RpdmUgd2Ugc2V0IG5ldyB3aWR0aCBvbmNlIGZvciBhbGwgY29sdW1zblxuICAgICAqL1xuICAgIHBvc3RJbml0aWFsaXplKG15SW5kZXg6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvbEluZGV4ID0gbXlJbmRleCArIDE7XG4gICAgICAgIGxldCB0YWJsZTtcblxuICAgICAgICBpZiAodGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIHRhYmxlID0gKDxEYXRhdGFibGUyQ29tcG9uZW50PnRoaXMuZHQpLmVsXG4gICAgICAgICAgICAgICAgLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWJvZHktZnJvemVuIHRhYmxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWJsZSA9ICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0aGlzLndpZGVzdENlbGwgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWxsID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgndHIgdGg6bnRoLWNoaWxkKCcgKyBjb2xJbmRleCArICcpLCAnICtcbiAgICAgICAgICAgICAgICAndHIgdGQ6bnRoLWNoaWxkKCcgKyBjb2xJbmRleCArICcpJykuZm9yRWFjaCgobm9kZTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB0aGlzLndpZGVzdENlbGwgKyAncHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFlvdSBlaXRoZXIgdXNlIHRoaXMgYmluZGluZyBkaXJlY3RseSBhbmQgc2F5IGl0cyBkYXRhY29sdW1uIG9yIHdoZW4gdGhlcmUgaXMgYSBba2V5XVxuICAgICAqIGJpZGluZyB3ZSBrbm93IGl0IHJlZmVycyB0byBzb21lIGZpZWxkLlxuICAgICAqXG4gICAgICovXG4gICAgaXNWYWx1ZUNvbHVtbigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGlzUHJlc2VudCh0aGlzLmlzRGF0YUNvbHVtbikgJiYgQm9vbGVhbldyYXBwZXIuaXNUcnVlKHRoaXMuaXNEYXRhQ29sdW1uKSkgfHxcbiAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLmtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBhcmUgaW4gb3V0bGluZSBtb2RlICB3ZSBuZWVkIHRvIGFsc28gaW5kZW5kIGVhY2ggc2VsZWN0aW9uIGNvbnRyb2wgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBpbmRlbnQgLSAxID4gb25seSBvZmZzZXQgd2l0aFxuICAgICAqIGluZGVudFxuICAgICAqL1xuICAgIGluZGVudEZvckNvbnRyb2woY2VsbDogYW55LCBsZXZlbDogbnVtYmVyKTogYW55XG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5pc091dGxpbmUoKSAmJiBsZXZlbCA+IDAgJiYgY2VsbC5vZmZzZXRXaWR0aCA+IDBcbiAgICAgICAgICAgICYmIGlzUHJlc2VudChjZWxsLm5leHRFbGVtZW50U2libGluZykpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgbGV0IG91dGxpbmVOb2RlUGFkZGluZyA9XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShjZWxsLm5leHRFbGVtZW50U2libGluZykucGFkZGluZ0xlZnQpIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIDFzdCBsZXZlbCBpcyBwdXNoZWQgYXMgcm9vdFxuICAgICAgICAgICAgaWYgKHRoaXMuZHQucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsZXZlbCA9PT0gMSkgPyBudWxsIDogKHRoaXMuZHQuaW5kZW50YXRpb25QZXJMZXZlbCAqIGxldmVsKVxuICAgICAgICAgICAgICAgICAgICAtIG91dGxpbmVOb2RlUGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmR0LmluZGVudGF0aW9uUGVyTGV2ZWwgKiBsZXZlbCkgKyBvdXRsaW5lTm9kZVBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEludGVybmFsXG4gICAgICovXG4gICAgcHJpdmF0ZSB3aWR0aFRvUHgod2lkdGg6IHN0cmluZyk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IHB4O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHdpZHRoKSkge1xuICAgICAgICAgICAgaWYgKHdpZHRoLmluZGV4T2YoJyUnKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub25QYyA9IHBhcnNlRmxvYXQod2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgICAgIHB4ID0gbm9uUGMgKiAoPERhdGF0YWJsZTJDb21wb25lbnQ+dGhpcy5kdCkuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBweDtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGRhdGF0YWJsZSBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIERhdGFUYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtaGVhZGVyMicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBEVEhlYWRlckNvbXBvbmVudDJcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZX0gZnJvbSAnLi4vLi4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqXG4gKiBDdXN0b20gY29sdW1uIGltcGxlbWVudGF0aW9uIHRvIHJlbmRlciBkZXRhaWwgcm93IHNwYW5pbmcgaXRzIGNvbHVtbiBhY3Jvc3Mgd2hvbGUgdGFibGUgd2lkdGguXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1kZXRhaWwtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2R0LWRldGFpbC1yb3cuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydkdC1kZXRhaWwtcm93LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERURGV0YWlsUm93Q29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1cnJlbnQgdmlzaWJpbGl0eSBmb3IgY3VycmVudCBkYXRhIHJvdyB1c2luZyBtZXRob2QgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzVmlzaWJsZUZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiB0ZWxscyBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhIGxpbmUgYmV0d2VlbiBpdGVtIHJvdyBhbmQgaXRzIGRldGFpbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Um93TGluZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBqdXN0IHRvIGdldCBhcm91bmQgdGhlIGNoZWNrIGluIHBhcmVudCBjbGFzc1xuICAgICAgICB0aGlzLmtleSA9ICcnO1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgbmVlZCB0byBrZWVwIHNvbWUgbGVhZGluZyBURHNcbiAgICAgKlxuICAgICAqL1xuICAgIHZpc2libGVMZWFkaW5nQ29scygpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0Lm51bWJlck9mQ29sc0JlZm9yZURhdGEgLSAodGhpcy5kdC5oYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKSA/IDEgOiAwKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgd2UgY2FuIHNob3cgZGV0YWlsIHJvdy9jb2x1bW4gdXNpbmcgZWl0aGVyIFtpc1Zpc2libGVdIG9yIFtpc1Zpc2libGVGbl0gYmluZGluZ3MuXG4gICAgICogSGVyZSBjYW4gaG9vayBvbiBhcHBsaWNhdGlvbiBsZXZlbCBjdXN0b20gbWV0aG9kIHRvIGRlY2lkZSBpZiBjdXJyZW50IGl0ZW0gaGFzIGRldGFpbCByb3dcbiAgICAgKiBvciBub3RcbiAgICAgKlxuICAgICAqIE9yIHdlIGNhbiB1c2UgaXNWaXNpYmxlPXRydWUgdG8gdGVsbCBhbGwgcm93IGhhdmUgZGV0YWlsIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd0RldGFpbFJvdyhpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgaXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGU7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pc1Zpc2libGVGbikpIHtcbiAgICAgICAgICAgIGlzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlRm4uYXBwbHkodGhpcy5kdC5jb250ZXh0LCBbdGhpcywgaXRlbV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfVxuXG5cbiAgICBpbml0aWFsaXplKHRhYmxlOiBBV0RhdGFUYWJsZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUodGFibGUpO1xuXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gIXRoaXMuZHQuaXNPdXRsaW5lKCkgfHwgIXRoaXMuZHQucGl2b3RhbExheW91dDtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1kZXRhaWwtY29sdW1uLWV4cGFuZCcsXG4gICAgdGVtcGxhdGVVcmw6ICdkdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZHQtZGV0YWlsLXJvdy1leHBhbmRlci5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIHdlIGRvbnQgd2FudCB0byBzaG93IHRoZSByb3cvY29sdW1uIHVubGVzcyBhcHBsaWNhdGlvbiBzYXlzIHNvXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xcbiAgICAgICAgdGhpcy53aWR0aCA9ICc0NXB4JztcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGp1c3QgdG8gZ2V0IGFyb3VuZCB0aGUgY2hlY2sgaW4gcGFyZW50IGNsYXNzXG4gICAgICAgIHRoaXMua2V5ID0gJyc7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVFeHBhbnNpb24oZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kdC5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS50b2dnbGUoaXRlbSk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVN0eWxlQ2xhc3MoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5pc0V4cGFuZGVkKGl0ZW0pID9cbiAgICAgICAgICAgICdpY29uLXNsaW0tYXJyb3ctZG93bicgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5cbmltcG9ydCB7VGVtcGxhdGVSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTZWxlY3Rpb25Nb2RlfSBmcm9tICcuL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuaW1wb3J0IHtEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSwgRFQyRGF0YVNvdXJjZX0gZnJvbSAnLi9kYXRhdGFibGUyLWRhdGEtc291cmNlJztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuLi9vdXRsaW5lJztcbmltcG9ydCB7RFREZXRhaWxSb3dDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQnO1xuXG5cbmV4cG9ydCBjb25zdCBEcmFnRXZlbnRzOiBzdHJpbmdbXSA9IFsnbW91c2Vkb3duJywgJ2RyYWdzdGFydCcsICdkcmFnb3ZlcicsICdkcmFnZW50ZXInLCAnZHJhZ2xlYXZlJyxcbiAgICAnZHJvcCcsICdkcmFnZW5kJ107XG5cbmV4cG9ydCBlbnVtIERyYWdEaXJlY3Rpb25cbntcbiAgICBOb25lID0gJ25vbmUnLFxuICAgIFVwID0gJ2R0LWRyYWctcm93LXRvcCcsXG4gICAgRG93biA9ICdkdC1kcmFnLXJvdy1ib3R0b20nLFxuICAgIE1pZGRsZSA9ICdkdC1kcmFnLXJvdy1ib3RoJ1xufVxuXG5cbmV4cG9ydCBlbnVtIERyb3BQb3NpdGlvblxue1xuICAgIEJlZm9yZSA9ICdiZWZvcmUnLFxuICAgIEFmdGVyID0gJ2FmdGVyJyxcbiAgICBJbnRvID0gJ2ludG8nXG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdCB0eXBlIHRoYXQgaXMgc2hhcmFibGUgYW1vbmcgZGVwZW5kYW50IERUIG9iamVjdCBzdWNoIGFzIENvbHVtbnMsIERhdGFTb3VyY2VzLFxuICogRGlyZWN0aXZlcyB0byBiZSBhYmxlIHRvIGNvbW11bmljYXRlIGJhY2sgdG8gdGhlIGRhdGF0YWJsZSBtYWlubHkgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFXRGF0YVRhYmxlXG57XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgeW91IHRvIHBhc3MgeW91ciBvd24gZGF0YXNvdXJjZSB0byBvdmVycmlkZSBkZWZhdWx0IG9uZS4gQWxzbyB3aGVuIGRhdGFTb3VyY2UgaXNcbiAgICAgKiB1c2VkIHRoZSBkZXN0aW5hdGlvbkNsYXNzIG9yIGxpc3QgYXJlIGlnbm9yZWRcbiAgICAgKi9cbiAgICBkYXRhU291cmNlOiBEVDJEYXRhU291cmNlO1xuXG4gICAgLyoqXG4gICAgICogTWFuYWdlcyBvdXRsaW5lIHN0YXRlcyBmb3IgRGF0YXRhYmxlcyB1c2luZyBvdXRsaW5lIGNvbnRyb2xcbiAgICAgKi9cbiAgICBvdXRsaW5lU3RhdGU6IE91dGxpbmVTdGF0ZTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB3ZSBoYXZlIGRldGFpbCByb3cgcmVtZW1iZXIgaXRzIGV4cGFuc2lvbiBzdGF0ZVxuICAgICAqL1xuICAgIGRldGFpbFJvd0V4cGFuc2lvblN0YXRlOiBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIFdoYXQgY29sdW1uIGlzIHVzZWQgYXMgZmlyc3QgZm9yIHNvcnRpbmdcbiAgICAgKi9cbiAgICBpbml0aWFsU29ydEtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQWxsb3cgdG8gY2hhbmdlIHNvcnRpbmcgZGlyZWN0aW9uXG4gICAgICovXG4gICAgaW5pdGlhbFNvcnRPcmRlcjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyBEVCBpZiB3ZSBzdXBwb3J0IGNlbGwgc2VsZWN0aW9uIG9yIHJvdyBiYXNlZCBzZWxlY3Rpb24gd2hpY2ggaXMgcmVndWxhciBEVC5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGlvbk1vZGU6IFNlbGVjdGlvbk1vZGU7XG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIG9mIHNpbmdsZSBvciBtdWx0aXNlbGVjdGlvbiBzaG93IGNvbnRyb2xzXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93U2VsZWN0aW9uQ29sdW1uOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgd2Ugd2FudCB0byByZW5kZXIgb25lIHNlbGVjdGlvbiBjb250cm9sIGluIHRoZSBoZWFkZXIgdG8gc2VsZWN0IGFsbCB0aGVcbiAgICAgKiByb3dzLiBBcHBsaWNhYmxlIGZvciBtdWx0aXNlbGVjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgc2hvd1NlbGVjdEFsbDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZ5IGlmIHJvdyBvciBjZWxsIGlzIHNlbGVjdGFibGUgYmFzZWQgb24gZGF0YVxuICAgICAqL1xuICAgIGlzUm93U2VsZWN0YWJsZTogKGl0ZW06IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogRWFjaCBEVENvbHVtbiBoYXZlIGhhdmUgaXRzIG93biB0ZW1wbGF0ZSB0byBwcm92aWRlIGNvbnRlbnQgZm9yIGhlYWRlciwgc3ViaGVhZGVyIGFuZFxuICAgICAqIGJvZHkgYnV0IGlmIHRob3NlIHRlbXBsYXRlIGFyZSBpZGVudGljYWwgdGhlcmUgd291bGQgYmUgdG9vIG11Y2ggZHVwbGljYXRlIGNvZGUgdG8gcmVwbGljYXRlXG4gICAgICogZm9yIGVhY2ggY29sdW1uIHRoZSBzYW1lLiBUaGVyZWZvcmUgd2UgaGF2ZSB0aGVzZSBnbG9iYWwgdGVtcGxhdGVzIHRoYXQgeW91IGNhbiBkZWNsYXJlXG4gICAgICogb24gRFQgbGV2ZWwgKG5vdCB1bmRlciBjb2x1bW5zKSBhbmQgY29udGVudCBvZiB0aGVzZSB0ZW1wbGF0ZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggY29sdW1uXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG1peCB0aGVtIGFzIHdlbGwuIFlvdSBjYW4gaGF2ZSBnbG9iYWwgdGVtcGxhdGVzIGFzIHdlbGwgYXMgdGVtcGxhdGUgb24gdGhlIENvbHVtblxuICAgICAqIGxldmVsIHdoaWNoIHdvdWxkIG92ZXJyaWRlIHRoZSBnbG9iYWwgb25lXG4gICAgICpcbiAgICAgKi9cbiAgICBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIGhlYWRlckZpbHRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZW5kZXIgYSBzdWJIZWFkZXIgdGVtcGxhdGUgaWYgcHJlc2VudFxuICAgICAqXG4gICAgICovXG4gICAgc2hvd1N1YkhlYWRlcjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZ2xvYmFsIHN0eWxlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGJvdW5kIHRvIHRhYmxlIGFuZCByZWFkIGJ5IGVhY2ggY29sdW1uLlxuICAgICAqIFRoZSBzYW1lIHlvdSBjYW4gc2VlIG9uIHRoZSBEVENvbHVtblxuICAgICAqL1xuICAgIGJvZHlDbGFzc0ZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb250ZXh0IGlzIGltcG9ydGFudCB3aGVuIHdlIGV4ZWN1dGUgYW55IGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIGluIGFzIGlucHV0LiBXZSBuZWVkIHRvXG4gICAgICogZ2l2ZSBvcHRpb24gdG8gYmUgZXhlY3V0ZWQgd2l0aGluIHRoZSBjb250ZXh0ICh0aGlzKSBvZiB0aGUgY29kZSB1c2luZyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnRleHQ6IGFueTtcblxuICAgIC8vIE91dGxpbmUgbmVlZGVkIHByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBvdXRsaW5lRm9yIHNlY3Rpb24gb24gdGhlIG5ldyBsaW5lIGFuZCAybmQgbGV2ZWwgY2hpbGQgbWFrZSBpdCByb290IGZvciB0aGlzXG4gICAgICogc2VjdGlvblxuICAgICAqL1xuICAgIHB1c2hSb290U2VjdGlvbk9uTmV3TGluZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gY2hhbmdlIGRlZmF1bHQgaW5kZW50YXRpb24gZm9yIHRoZSBvdXRsaW5lIG5vZGVzXG4gICAgICpcbiAgICAgKi9cbiAgICBpbmRlbnRhdGlvblBlckxldmVsOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFjdGl2ZSBhcHBsaWVzIHNwZWNpYWwgc3R5bGVzIHRvIHRoZSBEVC4gTGF0ZXIgb24gb25jZSBwaXZvdCBpcyBpbXBsZW1lbnRlZCB0aGlzIHdpbGxcbiAgICAgKiBhbHNvIGFkZCBhZGRpdGlvbmFsIGJlaGF2aW9yIHRvIHRoZSBEVFxuICAgICAqXG4gICAgICovXG4gICAgcGl2b3RhbExheW91dDogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBzb3J0aW5nIGlzIGVuYWJsZWQgdGhpcyBpcyBjdXJyZW50IGFjdGl2ZSBjb2x1bW4gYmVpbmcgc29ydGVkLlxuICAgICAqXG4gICAgICogIC0gd2UgZG9udCBzdXBwb3J0IG11bHRpcGxlIGNvbHVtbiBzb3J0aW5nXG4gICAgICovXG4gICAgc29ydENvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGF3LWR0LWRldGFpbC1jb2x1bW4gaWYgcHJlc2VudCBkZXRhaWwgcm93IGlzIHJlbmRlcmVkIGZvciBzcGVjaWZpZWRcbiAgICAgKiBpdGVtc1xuICAgICAqL1xuICAgIHJvd0RldGFpbENvbHVtbjogRFREZXRhaWxSb3dDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBzcGFuaW5nIGNhbGN1bGF0aW9uIG9yIGZvciB0aGUgZGV0YWlsIHJvdyB0byBpZGVudGlmeSBjb3JyZWN0IG51bWJlciBvZiBjb2x1bW5zXG4gICAgICogdG8gc3Bhbiwgd2hlbiB0aGV5IGFyZSBzb21lIG5vbi1kYXRhIGNvbHVtbiAoZXhwYW5zaW9uIGNvbnRyb2wsIHNpbmdsZS9tdWx0aSBzZWxlY3Rpb24pXG4gICAgICovXG4gICAgbnVtYmVyT2ZDb2xzQmVmb3JlRGF0YTogbnVtYmVyO1xuXG5cbiAgICAvKipcbiAgICAgKiAgd2hhdCBpcyB0aGUgaW5kZXggb2YgZmlyc3QgZGF0YSBjb2x1bW5zXG4gICAgICovXG4gICAgc3RhcnRPZkZpcnN0RGF0YUNvbHVtbjogbnVtYmVyO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBpbiBjZWxsIHNlbGVjdGlvbiBtb2RlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNlbGxTZWxlY3Rpb25DaGFuZ2UoY2VsbDogYW55LCBjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIGJ5IGNvbHVtbiB3aGUgaGVhZGVyIGlzIHNlbGVjdGVkLiBDdXJyZW50IHdlIGFzc3VtZSB0aGUgb25seSBvbmUgaGVhZGVyIGNhbiBiZVxuICAgICAqIHNlbGVjdGVkIGF0IHRoZSB0aW1lLlxuICAgICAqXG4gICAgICovXG4gICAgb25IZWFkZXJTZWxlY3Rpb25DaGFuZ2UoY2VsbDogYW55LCBjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCk6IHZvaWQ7XG5cblxuICAgIG9uSGFuZGxlUm93Q2xpY2tlZChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBIYW5kbGVzIHJvdyBzZWxlY3Rpb24gbG9naWMgd2hlcmUgaWYgdGhlIGl0ZW0gaXMgZm91bmQgaW5zaWRlIHRoZSBzZWxlY3RlZCBpdGVtcywgdGhlblxuICAgICAqIGl0cyByZW1vdmVkIG90aGVyd2lzZSBpdHMgYWRkZWQuXG4gICAgICpcbiAgICAgKiBUb2RvOiBTeW5jICYgcmVmYWN0b3IgdGhpcyB3aXRoIGR0Lm9uQ2VsbFNlbGVjdGlvbkNoYW5nZSAtIHByZXR0eSBzaW1pbGFyIGNvZGVcbiAgICAgKlxuICAgICAqIFdlIHdhbnQgdG8gaGF2ZSByb3dUb2dnbGUgYXMgd2VsbCBhcyB3ZSB3aWxsIGhhdmUgcm93U2VsZWN0IG9yIHNvbWV0aGlnbiBzaW1pbGFyIHRvXG4gICAgICogaWRlbnRpZnkgd2UgYXJlIGRlYWxpbmcgd2l0aCBtdWx0aXNlbGVjdCBhbmQgc2luZ2xlIHNlbGVjdGlvblxuICAgICAqL1xuICAgIG9uUm93VG9nZ2xlKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSGFuZGxlcyByb3cgc2luZ2xlIHNlbGVjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgb25Sb3dTZWxlY3QoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGVhbGluZyB3aXRoIG91dGxpbmUgKHRyZWUpIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdoZW4gd2Ugc2VsZWN0IHNvbWUgcm9vdCBpdGVtIGl0XG4gICAgICogd2lsbCBhdXRvbWF0aWNhbGx5IGFsc28gc2VsZWN0IGFsbCBpdHMgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSnVzdCBsaWtlIGZvciBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuIHRoZSBzYW1lIGJlaGF2aW9yIG5lZWRzIHRvIGJlIGFwcGxpZWQgZm9yXG4gICAgICogdG93YXJkcyB1cC5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgb0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDYWxsZWQgYnkgRCZEIHJvdyBkaXJlY3RpdmUgdG8gdXBkYXRlIHRoaXMgVEQgdGhhdCByb3cgcmVvcmRlcmluZyBuZWVkcyB0byBoYXBwZW4uIFdlXG4gICAgICogcmVjZWl2ZSBhbiBJTkRFWCBvZiByb3cgd2UgYXJlIGRyYWdnaW5nIGFuZCBuZXcgZHJvcCBwb3NpdGlvbiwgcGx1cyBpbmZvcm1hdGlvbiBpZiBpdFxuICAgICAqIG5lZWRzIHRvIGJlIGRyb3BwZWQgYmVmb3JlIG5ldyByb3cgcG9zaXRpb24gb3IgYWZ0ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRuRFJvd0Ryb3Aob3JpZ1BvczogbnVtYmVyLCBuZXdQb3M6IG51bWJlciwgZHJvcFBvczogRHJvcFBvc2l0aW9uKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGRldGFpbCByb3cgaXMgY29tYmluZWQgd2l0aCBvdXRsaW5lIGNvbnRyb2wgd2UgbmVlZCBtYWtlIHN1cmUgdGhhdCB3ZSBtYWludGFpbiB0aGVcbiAgICAgKiBjb3JyZWN0IHN0YXRlIGZvciBpdGVtcyB0aGF0IGFyZSBlbGlnaWJsZSBmb3IgZGV0YWlsIHJvd1xuICAgICAqXG4gICAgICogSW4gdGhpcyBzcGVjaWZpYyBjYXNlIHRoZSBkZXRhaWwgcm93IGRvZXMgbm90IGhhdmUgaXRzIG93biBleHBhbmRlciBidXQgdXRpbGl6aW5nIHRoZVxuICAgICAqIG91dGxpbmVDb250cm9sXG4gICAgICovXG4gICAgb25PdXRsaW5lRXhwYW5kQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGZvciBzaW5nbGUgY29sdW1uIHNvcnRpbmdcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgc29ydFNpbmdsZSgpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBkYXRhIGNoYW5nZXMsIGVpdGhlciB0aGV5IGFyZSBsYXppbHkgZmV0Y2hlZCBvciBASW5wdXQgTElTVCBpcyB1cGRhdGVkIHdlIG5lZWRcbiAgICAgKiByZXNvcnQgb3V0IGRhdGEgYmFzZWQgb24gY3VycmVudCBzdGF0ZSBhbmQgdXBkYXRlIGludGVybmFsIGxpc3QgZGF0YVRvUmVuZGVyIHNvIG5ld1xuICAgICAqIGRhdGEgY2FuIHJlLXJlbmRlcmVkICsgdHJpZ2dlcnMgZXZlbnQgdmFsdWVDaGFuZ2VcbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFuZ2UoKTogdm9pZDtcblxuICAgIHVwZGF0ZURhdGFUb1JlbmRlcihkYXRhc291cmNlPzogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IG9yIHVuc2VsZWN0IGFsbCByb3dzLiBVc2VkIGJ5IGhlYWRlciBjaGVja2JveFxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlQWxsQ29sdW1ucyhldmVudDogYW55KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIE1vcmUgbGlrZSB1dGlsaXR5IG1ldGhvZHMgdG8gdHJhbnNsYXRlIHN0cmluZzwtLT5udW1iZXIgdmFsdWUgZm9yIHNvcnRpbmdcbiAgICAgKlxuICAgICAqIEN1cnJlbnRseSB1c2VkIG9ubHkgYnkgRFRDb2x1bW4uIFdlIG1pZ2h0IHdhbnQgdG8gbW92ZSB0aGlzIGl0cyBvd24gY29tcG9uZW50IGZvclxuICAgICAqIGhlYWRlclNvcnQgYW5kIG9yZGVyaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0T3JkZXJpbmdGb3JTdHJpbmcoZGlyZWN0aW9uOiBzdHJpbmcpOiBudW1iZXI7XG5cbiAgICBzb3J0T3JkZXJpbmdGb3JOdW1iZXIoZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmc7XG5cbiAgICB2aXNpYmxlQ29sdW1ucygpOiBEVENvbHVtbjJDb21wb25lbnRbXTtcblxuICAgIGhhc0Zyb3plbkNvbHVtbnMoKTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFBsYWNlaG9sZGVyIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBzaW5nbGUvbXVsdGlzZWxlY3QgZnVuY3Rpb25hbGl0eSB3aGVyZSB3ZSBuZWVkIHRvIHRyYWNrIGlmXG4gICAgICogd2Ugc3VwcG9ydCBzZWxlY3Rpb24gcGx1cyBob3cgbWFueSBjb2x1bW4gaXQgb2NjdXBpZXMgYW5kIGlmIHRoZSBzZWxlY3Rpb24gY29udHJvbHMgYXJlXG4gICAgICogdmlzaWJsZSBvciBoaWRkZW4uXG4gICAgICovXG4gICAgaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCk6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUGxhY2Vob2xkZXIgdG8gaWRlbnRpZnkgaWYgdGhleSBhcmUgbm9uLXZhbHVlIGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBUbyBjb21wYXJlIHRoZSBkYXRhIGlmIHdlIHVzZSBkZWVwIG9iamVjdCBlcXVhbGl0eSBhbmQgdGhpcyBpcyB1c2VkIHdpdGhpbiB0aGlzIGNsYXNzIGFzXG4gICAgICogd2VsbCBhcyBmcm9tIHRoZSBEVENvbHVtbiB0byBjb25kaXRpb25hbGx5IGFkZCBjbGFzcyB3aGljaCBzZWxlY3QgdGhlIGNlbGxcbiAgICAgKlxuICAgICAqIFdlIG1pZ2h0IHdhbnQgdG8gY2hhbmdlIHRvIGNoZWNrIG9ubHkgYSBrZXkgb2YgdGhlIG9iamVjdCBzb21lIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqL1xuICAgIGlzSGVhZGVyU2VsZWN0ZWQoaXRlbTogRFRDb2x1bW4yQ29tcG9uZW50KTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdGhlIHNwZWNpZmljIGNlbGwgaXMgc2VsZWN0ZWQuIFdlIG5lZWQgdHdvIHBvaW50cyB0byBpZGVudGlmeSBpZiBjZWxsIGlzIHNlbGVjdGVkXG4gICAgICogdGhlIGFjdHVhbCBJdGVtIHRoYXQgY291bGQgcmVwcmVzZW50IHdob2xlIHJvdyBhbmQgQ29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0JvZHlDZWxsU2VsZWN0ZWQoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiAgQ2hlY2sgaWYgdGhlIGdpdmVuIGl0ZW0gaXMgYW1vbmcgdGhlIHNlbGVjdGVkIG9uZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGlzUm93U2VsZWN0ZWQoaXRlbTogYW55KTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBbY2hpbGRyZW5dIGJpbmRpbmcgaXMgcHJlc2VudCB0aGVuIGl0IG1lYW5zIHdlIG5lZWQgdG8gcmVuZGVyIGl0IGFzIGEgdHJlZVxuICAgICAqXG4gICAgICovXG4gICAgaXNPdXRsaW5lKCk6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdGhlIGNoZWNrYm94IHRvIGVpdGhlciBzZWxlY3RlZCBhbmQgbm90IHNlbGVjdGVkIGRlcGVuZGVkIG9uIGludGVybmFsIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1RvZ2dsZUFsbENvbHVtblNlbGVjdGVkKCk6IGJvb2xlYW47XG5cbiAgICBpc1RvZ2dsZUFsbENvbHVtbkRpc2FibGVkKCk6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlcyBhcmUgZmllbGQgcGF0aCB1dGlsaXR5IGNsYXNzIHRvIHJldHJpZXZlIGRhdGEgZnJvbSBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFZhbHVlKGRhdGE6IGFueSwgZmllbGQ6IHN0cmluZyk6IGFueTtcblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIGFzc2VydCxcbiAgICBFbnRpdHksXG4gICAgaXNCbGFuayxcbiAgICBpc0VudGl0eSxcbiAgICBpc1ByZXNlbnQsXG4gICAgaXNTdHJpbmcsXG4gICAgTGlzdFdyYXBwZXIsXG4gICAgTWFwV3JhcHBlclxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0RhdGFTb3VyY2UsIERTSW5pdFBhcmFtc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0RhdGFGaW5kZXIsIERhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZSwgRHJvcFBvc2l0aW9ufSBmcm9tICcuL2F3LWRhdGF0YWJsZSc7XG5cblxuLyoqXG4gKiBDb25jcmV0ZSBEYXRhU291cmNlIGltcGxlbWVudGF0aW9uIGZvciBEYXRhdGFibGUgd2hpY2ggZGVmaW5lcyBzdGF0ZSBhbmQgY29sdW1uIGRlZmluaXRpb24gdGhhdFxuICogY2FuIHByb2dyYW1tYXRpY2FsbHkgbW9kaWZ5IHJlbmRlcmVkIGNvbHVtbnMgKGlmIHByb3ZpZGVkKSBhbmQgbWV0aG9kIGZvciBpbnNlcnRpbmcgYW5kXG4gKiBhbmQgZGVsZXRpbmcgcmVjb3JkcztcbiAqXG4gKiBBbGwgb3BlcmF0aW9ucyBkZWFsaW5nIHdpdGggZGF0YSB1c2UgT2JzZXJ2YWJsZTxUPiBhbmQgaW5zdGFudCgpIG1ldGhvZCB0byByZXRyaWV2ZSBjdXJyZW50XG4gKiBzdGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERUMkRhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlXG57XG4gICAgc3RhdGljIHJlYWRvbmx5IE1heExpbWl0ID0gMTAwO1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hpbmcgZGF0YVByb3ZpZGVycyBhbmQgZmluZGVyc1xuICAgICAqL1xuICAgIGRhdGFQcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT47XG4gICAgZGF0YUZpbmRlcjogRGF0YUZpbmRlcjtcblxuICAgIC8qKlxuICAgICAqIEtlZXAgdHJhY2sgb2YgY3VycmVudCBkYXRhdGFibGUgc3RhdGVcbiAgICAgKi9cbiAgICBzdGF0ZTogRGF0YXRhYmxlMlN0YXRlO1xuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgZGVidWdUaW1lOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBvYmplY3QgYmVpbmcgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGVudGl0eTogRW50aXR5RGVmMjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRhUHJvdmlkZXJzPzogRGF0YVByb3ZpZGVycywgcHVibGljIGZpbmRlcnM/OiBEYXRhRmluZGVycylcbiAgICB7XG4gICAgICAgIHN1cGVyKGRhdGFQcm92aWRlcnMsIGZpbmRlcnMpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBEYXRhdGFibGUyU3RhdGUuY3JlYXRlKCk7XG5cbiAgICAgICAgdGhpcy5kZWJ1Z1RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG5cblxuICAgIGluaXQoLi4uYXJnczogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhhcmdzKSB8fCBhcmdzLmxlbmd0aCAhPT0gMSAmJiAhaXNEVEluaXRQYXJhbXMoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBEUyB3aXRoIChEU0Nob29zZXJJbml0UGFyYW1zKScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbml0OiBEVERTSW5pdFBhcmFtcyA9IGFyZ3NbMF07XG5cbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIG9yIGZpbmQgYmVzdCBtYXRjaCBmb3IgZGF0YVByb3ZpZGVyXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YVByb3ZpZGVyKSA/IGluaXQuZGF0YVByb3ZpZGVyXG4gICAgICAgICAgICA6IHRoaXMuZGF0YVByb3ZpZGVycy5maW5kKGluaXQub2JqKTtcblxuICAgICAgICAvLyB1c2UgZXhpc3Rpbmcgb3IgZmluZCBiZXN0IG1hdGNoIGZvciBkYXRhRmluZGVyXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IGlzUHJlc2VudChpbml0LmRhdGFGaW5kZXIpID8gaW5pdC5kYXRhRmluZGVyXG4gICAgICAgICAgICA6IHRoaXMuZmluZGVycy5maW5kKHRoaXMuZGF0YVByb3ZpZGVyLCBpbml0LnF1ZXJ5VHlwZSk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmRhdGFQcm92aWRlcikgJiYgaXNQcmVzZW50KHRoaXMuZGF0YUZpbmRlciksXG4gICAgICAgICAgICAnRGF0YVNvdXJjZSBpbmNvcnJlY3RseSBpbml0aWFsaXplZC4gKERhdGFQcm92aWRlciwgRGF0YUZpbmRlcikgbWlzc2luZy4gJyk7XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IGluaXQubG9va3VwS2V5O1xuICAgICAgICBpZiAoaXNCbGFuayhpbml0LnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBEYXRhdGFibGUyU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpbml0LnN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhc3luYyBmZXRjaCBkYXRhIHJlcXVlc3QgYW5kIHJlc3VsdCBpcyBnaXZlbiBiYWNrIHVzaW5nIGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlc1xuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2god2l0aFBhcmFtcz86IERhdGF0YWJsZTJTdGF0ZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBwYXJhbXMgPSBudWxsO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHdpdGhQYXJhbXMpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBuZXcgTWFwKCkuc2V0KCdvZmZzZXQnLCB3aXRoUGFyYW1zLm9mZnNldClcbiAgICAgICAgICAgICAgICAuc2V0KCdsaW1pdCcsIHdpdGhQYXJhbXMubGltaXQpXG4gICAgICAgICAgICAgICAgLnNldCgnb3JkZXJieScsIHdpdGhQYXJhbXMuc29ydEtleSlcbiAgICAgICAgICAgICAgICAuc2V0KCdzZWxlY3RvcicsIHdpdGhQYXJhbXMuc29ydE9yZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmZldGNoKHBhcmFtcykuc3Vic2NyaWJlKChyZXN1bHQ6IGFueVtdKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAod2l0aFBhcmFtcy5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluY3JEYXRhID0gWy4uLnRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCksIC4uLnJlc3VsdF07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChpbmNyRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgdXNlcyB0aGlzIG1ldGhvZCB0byBvcGVuIHVwIGNvbnRpbnVvdXMgc3RyZWFtIHRvIGxpc3RlbiBmb3IgYW55IGNoYW5nZXMgd2hpY2hcbiAgICAgKiBuZWVkIHRvIGJlIHJlZmxlY3RlZCBvbiB0aGUgVUkuXG4gICAgICpcbiAgICAgKiBEb250IGZvcmdldCB0byB1bnN1YnNjcmliZSB3aGVuIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb3BlbjxUPigpOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJZiBDUlVEIGlzIGVuYWJsZWQgd2UgZGVsZWdhdGUgY2FsbHMgdG8gRGF0YVByb3ZpZGVyIHRoYXQgaXMgcmVzcG9uc2libGUgdG8gdGVsbCB0aGVcbiAgICAgKiBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMgdGhhdCBhcmUgbmV3IGRhdGEuIElmIG5vdCBlbmFibGVkIHdlIGhhdmUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAqIHdoaWNoIHdvcmtzIHdpdGggbG9jYWwgYXJyYXlcbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydChvYmplY3Q6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm92aWRlci5jYW5DUlVEKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmluc2VydChvYmplY3QpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5vZmZTY3JlZW5EYXRhLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQodGhpcy5kYXRhUHJvdmlkZXIub2ZmU2NyZWVuRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFBsZWFzZSBzZWUge0BsaW5rIGluc2VydH0gbWV0aG9kXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmUob2JqZWN0OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kYXRhUHJvdmlkZXIuY2FuQ1JVRCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5yZW1vdmUob2JqZWN0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlSWZFeGlzdCh0aGlzLmRhdGFQcm92aWRlci5vZmZTY3JlZW5EYXRhLCBvYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dCh0aGlzLmRhdGFQcm92aWRlci5vZmZTY3JlZW5EYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIERhdGFGaW5kZXIgd2hpY2ggY2FuIGFjY2VwdCBlaXRoZXIgcGxhaW4gc3RyaW5nIG9yIE1hcC5cbiAgICAgKlxuICAgICAqIFRvIGJlIGFibGUgdG8gcHJvdmlkZSBjb3JyZWN0IGlucHV0IHdlIG5lZWQgdG8gYXNrIERhdGFGaW5kZXIgaWYgaXQgc3VwcG9ydHMgRnVsbFRleHQgbGlrZVxuICAgICAqIHR5cGUgcXVlcnkgb3IgUHJlZGljYXRlLiBJbiBjYXNlIG9mIFByZWRpY2F0ZSB3ZSBidWlsZCB0aGUgTWFwIHdpdGggZGlmZmVyZW50IGtleS92YWx1ZVxuICAgICAqIHBhaXJzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGZpbmQocGF0dGVybj86IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHBhdHRlcm4pIHx8IHBhdHRlcm4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSByZWNlaXZlZCBlbXB0eSBzdHJpbmcgcmV0dXJuIG9yZ2luYWwgbGlzdFxuICAgICAgICAgICAgdGhpcy5mZXRjaCh0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWFyY2hQYXJhbTogYW55ID0gcGF0dGVybjtcbiAgICAgICAgaWYgKHRoaXMuZGF0YUZpbmRlci5hY2NlcHRzKHRoaXMuZGF0YVByb3ZpZGVyLCBRdWVyeVR5cGUuUHJlZGljYXRlKSkge1xuICAgICAgICAgICAgc2VhcmNoUGFyYW0gPSBuZXcgTWFwKCkuc2V0KCdxdWVyeScsIHBhdHRlcm4pLnNldCgnbGltaXQnLCBEVDJEYXRhU291cmNlLk1heExpbWl0KTtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNvcnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoUGFyYW0uc2V0KCdvcmRlcmJ5JywgdGhpcy5zdGF0ZS5zb3J0S2V5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNvcnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoUGFyYW0uc2V0KCdzZWxlY3RvcicsIHRoaXMuc3RhdGUuc29ydE9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFzc2VydChpc1N0cmluZyhwYXR0ZXJuKSwgJ0Nhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdmFsdWUgdG8gRnVsbFRleHQgRmluZGVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubWF0Y2g8YW55PihzZWFyY2hQYXJhbSkuc3Vic2NyaWJlKChyZXN1bHQ6IGFueVtdKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEYXRhIHNvdXJjZSBkZWxlZ2F0ZXMgdGhlIHJlc3BvbnNpYmlsaXR5IHRvIHRoZSBnaXZlbiBkYXRhIHByb3ZpZGVyIHdoaWNoIG5lZWRzIHRvIGltcGxlbWVudFxuICAgICAqIHNwZWNpZmljIHNvcnRpbmcgbWVjaGFuaXNtXG4gICAgICpcbiAgICAgKiBUb2RvOiBFeHRlbmQgdG8gc29ydCBieSBtdWx0aXBsZSBjb2x1bW5zXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0KGtleTogc3RyaW5nLCBzb3J0T3JkZXI6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKSkgfHwgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydEtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0T3JkZXIgPSBzb3J0T3JkZXI7XG4gICAgICAgIHRoaXMuZmV0Y2godGhpcy5zdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQZXJzaXN0IGRiIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVTdGF0ZShvZmZzZXQ6IG51bWJlciwgc29ydEZpZWxkOiBzdHJpbmcsIHNPcmRlcjogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydEtleSA9IHNvcnRGaWVsZDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0T3JkZXIgPSBzT3JkZXI7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIHJlc2h1ZmZsZXMgY3VycmVudCBhcnJheSBiYXNlZCBvbiBuZXcgcm93IEQmRCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgaWYgd2UgbW92ZSBpdGVtIGZyb20gYm90dG9tIG9yIGZyb20gdGhlIHRvcCBhbmQgdGhlbiBhY2NvcmRpbmdseVxuICAgICAqIGhpZ2hsaWdodGluZyBhIHNwYWNlIGJldHdlZW4gcm93cy4gV2UgbmVlZCB0byByZWZsZWN0IHRoaXMgaW4gaGVyZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogVXNlQ2FzZSAxOlxuICAgICAqXG4gICAgICogMS4gWW91IGNhbiBncmFiIGl0ZW0gd2l0aCBpbmRleCAwIGFuZCBtb3ZlIGl0IGRvd24gc28gdGhhdCB5b3UgY2FuIHNlZSBhIGRyb3BwaW5nIGxpbmVcbiAgICAgKiBiZXR3ZWVuIHJvdyB3aXRoIGluZGV4IDIgLSAzXG4gICAgICpcbiAgICAgKiAyLiBJbiB0aGlzIGNhc2Ugc3BsaWNlKCkgc3RhcnRzIGZyb20gcG9zaXRpb24gMiBhbmQgaW5zZXJ0IGFsbCBlbGVtZW50cyBhZnRlciAyXG4gICAgICogICAgICBzcGxpY2Uoc3RhcnQ6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IFRbXTtcbiAgICAgKlxuICAgICAqIDMuIG5vIG5lZWQgdG8gdXBkYXRlIG5ld1Bvc1xuICAgICAqXG4gICAgICogVXNlQ2FzZSAyOlxuICAgICAqXG4gICAgICogMS4gWW91IGNhbiBncmFiIGl0ZW0gd2l0aCBpbmRleCAwIGFuZCBtb3ZlIGFsbCB0aGUgd2F5IGRvd24gb2YgdGhlIERUIGFuZCBub3cgbW92ZSB0aGVcbiAgICAgKiByb3cgdG93YXJkIFRPUCBhbmQgc3BhY2UgYmV0d2VlbiByb3dzIHdpdGggaW5kZXggMiAtIDMgaXMgaGlnaGxpZ2h0ZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiAyLiBIZXJlIGlzIHRoZSBkaWZmZXJlbmNlLCBiZWZvcmUgd2UgaGlnaGxpZ2h0ZWQgcm93ICMyIHdpdGggbGluZSBhdCB0aGUgYm90dG9tLCBub3dcbiAgICAgKiBpdCBzZWVtcyB0aGUgc2FtZSBidXQgaXRzIGhpZ2hsaWdodGVkIHJvdyAjMyB3aXRoIGxpbmUgYXQgdGhlIFRPUC5cbiAgICAgKlxuICAgICAqICogVGhpcyBpcyB0aGUgcmVhc29uIHdoZXkgd2UgbmVlZCB0byBkbyBuZXdQb3MgLT0gMSBvciBuZXdQb3MgKz0gMTsgZGVwZW5kaW5nIG91ciBkaXJlY3Rpb25cbiAgICAgKiB3aGVyZSB3aGVyZSB0aGUgbGluZSBiZXR3ZWVuIHJvd3MgaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqXG4gICAgICogV2UgZG9uJ3QgbmVlZCBhbnkgY29tcGxpY2F0ZWQgY2FsY3VsYXRpb24gdHJ5aW5nIHRvIGZpbmQgb3V0IGlmIHdlIGFyZSBvbiBvbmUgaGFsZiBvZiB0aGUgcm93XG4gICAgICogb3Igc2Vjb25kIGhhbGYgYW5kIGJhc2VkIG9uIHRoaXMgdHJ5IHRvIGFwcGx5IGNlcnRhaW4gc3R5bGUuIFRoaXMgd291bGQgbm90IGdpdmUgc28gbXVjaFxuICAgICAqIHNwYWNlIGlmIHdlIHdhbnQgZHJvcCByb3cgaW50byB0aGUgcm93LiBBbmQgdGhlIGNhbGN1bGF0aW9uIHdpdGggY29vcmRpbmF0ZXMgd291ZGwgYmUgdG9vXG4gICAgICogY29tcGxpY2F0ZWQuXG4gICAgICpcbiAgICAgKiBXZSBzaW1wbHkgcmVtZW1iZXIgdGhlIGRpcmVjdGlvbiB3ZSBhcmUgbW92aW5nIGFuZCBiYXNlZCBvbiB0aGlzIHdlIGFwcGx5IHN0eWxlIHRvXG4gICAgICogdG8gY3JlYXRlIGEgbGluZSBhdCB0aGUgVE9QIGlmIHdlIGFyZSBnb2luZyB1cHdhcmRzIG9yIGJvdHRvbSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHJlb3JkZXJSb3dzKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBhcnJheSA9IHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKS5zbGljZSgpO1xuXG4gICAgICAgIC8vIHRha2Ugc29tZXRoaW5nIGZyb20gdG9wIGFuZCBkcmFnJmRyb3AgdW5kZXJcbiAgICAgICAgaWYgKG5ld1BvcyA+IG9yaWdQb3MgJiYgZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkJlZm9yZSAmJiBuZXdQb3MgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5ld1BvcyAtPSAxO1xuXG4gICAgICAgICAgICAvLyB0YWtlIHNvbWV0aGluZyBmcm9tIGJvdHRvbSBhbmQgZHJhZyZkcm9wIGFib3ZlXG4gICAgICAgIH0gZWxzZSBpZiAobmV3UG9zIDwgb3JpZ1BvcyAmJiBkcm9wUG9zID09PSBEcm9wUG9zaXRpb24uQWZ0ZXIgJiYgbmV3UG9zID49IDApIHtcbiAgICAgICAgICAgIG5ld1BvcyArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXkuc3BsaWNlKG5ld1BvcywgMCwgLi4uYXJyYXkuc3BsaWNlKG9yaWdQb3MsIDEpWzBdKTtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChhcnJheSk7XG4gICAgfVxuXG59XG5cbi8qKlxuICogRW50aXR5IGRlZmluaXRpb24gdG8gYmUgdXNlZCB0byBpbml0aWFsaXplIHByb2dyYW1tYXRpY2FsbHkgY29sdW1uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIEVudGl0eURlZjJcbntcbiAgICBwcm9wZXJ0eUtleXM6IHN0cmluZ1tdO1xuXG4gICAgZGVmYXVsdEZvcm1hdHRlcjogKGtleTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICBkaXNwbGF5U3RyaW5nRm9yS2V5OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcblxuICAgIGRlZmF1bHRBbGlnbm1lbnRGb3JLZXk6IChrZXk6IHN0cmluZykgPT4gc3RyaW5nO1xufVxuXG4vKipcbiAqIEtlZXBzIGN1cnJlbnQgZGF0YXRhYmxlIHN0YXRlIHRoZSBzdGF0ZSB3aGljaCBkcml2ZXJzIHRoZSB3YXkgd2hpbGUgZmV0Y2hpbmcgdGhlIGRhdGEgYXMgd2VsbFxuICogZW5jYXBzdWxhdGUgc2V0IG9mIHByb3BlcnRpZXMgdGhhdCBuZWVkcyB0byBiZSBwZXJzaXN0ZXQgaW4gb3JkZXIgdG8gcmVjb3ZlciBhIHN0YXRlIGFmdGVyIGUuZy5cbiAqIGJyb3dzZXIgcmVmcmVzaFxuICpcbiAqXG4gKiB0b2RvOiBDcmVhdGUgbWV0aG9kcyB0byBjb252ZXJ0IHRoaXMgc3RhdGUgZnJvbSBhbmQgdG8gSlNPTiBmb3IgZWFzaWVyIHNlcmlhbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGF0YWJsZTJTdGF0ZVxue1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQXNjZW5kaW5nID0gMTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERlc2NlbmRpbmcgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgZm9yIHBhZ2luZyBhbmQgZmV0Y2hpbmdcbiAgICAgKi9cbiAgICBvZmZzZXQ6IG51bWJlciA9IDA7XG4gICAgbGltaXQ6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGRlZmF1bHQgdmFsdWUgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciBOIG51bWJlciBvZiByb3dzIGluIG5vbi1mdWxsc2NyZWVuXG4gICAgICogbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheUxpbWl0OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzb3J0aW5nIGZpZWxkXG4gICAgICovXG4gICAgc29ydEtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU29ydGluZyBvcmRlciBvZiB0aGUgc29ydCBmaWVsZC4gRGF0YVRhYmxlIHN1cHBvcnQgc29ydGluZyBmb3IgbXVsdGlwbGUgY29sdW1uIGJ1dCB3ZVxuICAgICAqIGRvbnQgcGVyc2lzdCBpdCBub3cuIE1heWJlIGluIHRoZSBmdXR1cmVcbiAgICAgKi9cbiAgICBzb3J0T3JkZXI6IG51bWJlciA9IERhdGF0YWJsZTJTdGF0ZS5Bc2NlbmRpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgdXNpbmcgZ2xvYmFsIGZpbHRlciBmb3IgY3VycmVudCBkYXRhdGFibGUgdGhlbiBzYXZlIGl0IGhlcmVcbiAgICAgKi9cbiAgICBjdXJyZW50U2VhcmNoUXVlcnk6IHN0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBpZiBhbnkgcHJlc2VsZWN0ZWQgZmlsdGVyXG4gICAgICovXG4gICAgY3VycmVudEZpbHRlcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50IGN1cnJlbnQgc2VsZWN0aW9uIGRlcGVuZGluZyBvbiBzZWxlY3Rpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgc2VsZWN0aW9uIHVzZWQgYm90aCBmb3Igcm93IHNlbGVjdGlvbiBhbmQgY2VsbCBzZWxlY3Rpb24uIFJvdyBzZWxlY3Rpb24gaXMgdXNlZCB3aGVuXG4gICAgICogU2luZ2xlU2VsZWN0IGFuZCBNdWx0aVNlbGVjdCBvbmNlIHdlIGltcGxlbWVudCB0aGlzLlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaGVhZGVyIHNlbGVjdGlvbiBpcyBlbmFibGVkIGl0IGNhcHR1cmVzIGN1cnJlbnRseSBzZWxlY3RlZCBjb2x1bW5cbiAgICAgKi9cbiAgICBoZWFkZXJTZWxlY3Rpb246IERUQ29sdW1uMkNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgSG9sZHMgY3VycmVudCBzdGF0ZSBvZiB0aGUgb3V0bGluZSB0cmVlIGlmIHVzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG91dGxpbmVTdGF0ZT86IE1hcDxhbnksIGJvb2xlYW4+O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgSG9sZHMgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGV0YWlsIHJvd3MgaWYgdXNlZFxuICAgICAqXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5kU3RhdGU/OiBNYXA8YW55LCBib29sZWFuPjtcblxuXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lU3RhdGUgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUob2Zmc2V0OiBudW1iZXIgPSAwLCBsaW1pdDogbnVtYmVyID0gMTUsIGRpc3BsYXlMaW1pdDogbnVtYmVyID0gNSxcbiAgICAgICAgICAgICAgICAgIHNvcnRGaWVsZDogc3RyaW5nID0gJycsIHNPcmRlcjogbnVtYmVyID0gMCwgc2VhcmNoUXVlcnk/OiBzdHJpbmcsIGZpbHRlcj86IGFueSxcbiAgICAgICAgICAgICAgICAgIG91dGxpbmVTdGF0ZTogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKSxcbiAgICAgICAgICAgICAgICAgIGRldGFpbFJvd1N0YXRlOiBNYXA8YW55LCBib29sZWFuPiA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpKTogRGF0YXRhYmxlMlN0YXRlXG4gICAge1xuICAgICAgICBsZXQgcyA9IG5ldyBEYXRhdGFibGUyU3RhdGUoKTtcbiAgICAgICAgcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHMubGltaXQgPSBsaW1pdDtcbiAgICAgICAgcy5kaXNwbGF5TGltaXQgPSBkaXNwbGF5TGltaXQ7XG4gICAgICAgIHMuc29ydEtleSA9IHNvcnRGaWVsZDtcbiAgICAgICAgcy5zb3J0T3JkZXIgPSBzT3JkZXI7XG4gICAgICAgIHMuY3VycmVudFNlYXJjaFF1ZXJ5ID0gc2VhcmNoUXVlcnk7XG4gICAgICAgIHMuY3VycmVudEZpbHRlciA9IGZpbHRlcjtcbiAgICAgICAgcy5vdXRsaW5lU3RhdGUgPSBvdXRsaW5lU3RhdGU7XG4gICAgICAgIHMuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSBkZXRhaWxSb3dTdGF0ZTtcblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBzdGF0aWMgZnJvbUpTT04oZGF0YTogc3RyaW5nKTogRGF0YXRhYmxlMlN0YXRlXG4gICAge1xuICAgICAgICBsZXQgc3RhdGU6IERUU3RhdGVTZXJpYWxpemFibGVIZWxwZXIgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICBsZXQgZHMgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIGRzLm9mZnNldCA9IHN0YXRlLm9mZnNldDtcbiAgICAgICAgZHMubGltaXQgPSBzdGF0ZS5saW1pdDtcbiAgICAgICAgZHMuZGlzcGxheUxpbWl0ID0gc3RhdGUuZGlzcGxheUxpbWl0O1xuICAgICAgICBkcy5zb3J0S2V5ID0gc3RhdGUuc29ydEtleTtcbiAgICAgICAgZHMuc29ydE9yZGVyID0gc3RhdGUuc29ydE9yZGVyO1xuICAgICAgICBkcy5jdXJyZW50U2VhcmNoUXVlcnkgPSBzdGF0ZS5jdXJyZW50U2VhcmNoUXVlcnk7XG4gICAgICAgIGRzLm91dGxpbmVTdGF0ZSA9IE1hcFdyYXBwZXIuY3JlYXRlRnJvbUFueU1hcDxib29sZWFuPihzdGF0ZS5vdXRsaW5lU3RhdGUpO1xuICAgICAgICBkcy5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IE1hcFdyYXBwZXIuY3JlYXRlRnJvbUFueU1hcDxib29sZWFuPihzdGF0ZS5kZXRhaWxSb3dFeHBhbmRTdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIGRzO1xuICAgIH1cblxuXG4gICAgc3RhdGljIHRvSlNPTihkYXRhOiBEYXRhdGFibGUyU3RhdGUpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCB0b0NvbnZlcnQ6IERUU3RhdGVTZXJpYWxpemFibGVIZWxwZXIgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IGRhdGEub2Zmc2V0LFxuICAgICAgICAgICAgbGltaXQ6IGRhdGEubGltaXQsXG4gICAgICAgICAgICBkaXNwbGF5TGltaXQ6IGRhdGEuZGlzcGxheUxpbWl0LFxuICAgICAgICAgICAgc29ydEtleTogZGF0YS5zb3J0S2V5LFxuICAgICAgICAgICAgc29ydE9yZGVyOiBkYXRhLnNvcnRPcmRlcixcbiAgICAgICAgICAgIGN1cnJlbnRTZWFyY2hRdWVyeTogZGF0YS5jdXJyZW50U2VhcmNoUXVlcnksXG4gICAgICAgICAgICBvdXRsaW5lU3RhdGU6IE1hcFdyYXBwZXIudG9BbnlNYXAoZGF0YS5vdXRsaW5lU3RhdGUpLFxuICAgICAgICAgICAgZGV0YWlsUm93RXhwYW5kU3RhdGU6IE1hcFdyYXBwZXIudG9BbnlNYXAoZGF0YS5kZXRhaWxSb3dFeHBhbmRTdGF0ZSlcblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodG9Db252ZXJ0KTtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIFRoaXMgbmVlZHMgdG8gZ28gdG8gRFREYXRhU291cmNlIHRvIGtlZXAgYW5kIG1hbmFnZSB0aGUgc3RhdGUgb2YgdGhlIGRldGFpbCByb3cuIFRoZSBpZGVhIGlzXG4gKiBzaW1wbGUgd2UgaGF2ZSBhIG1hcCBob2xkaW5nIGl0ZW0gcmVmZXJlbmNlIGFzIGEga2V5IGFuZCBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlXG4gKiBkZXRhaWwgcm93IGlzIHZpc2libGVcbiAqXG4gKiBUb2RvOiBtb3ZlIHRoaXMgb3V0IHRvIERTXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZVxue1xuXG4gICAgZXhwYW5zaW9uU3RhdGVzOiBNYXA8YW55LCBib29sZWFuPjtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkdDogQVdEYXRhVGFibGUpXG4gICAge1xuICAgIH1cblxuICAgIGdldCBkZXRhaWxFeHBhbnNpb25FbmFibGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5leHBhbnNpb25TdGF0ZXMpO1xuICAgIH1cblxuICAgIHNldCBkZXRhaWxFeHBhbnNpb25FbmFibGVkKHZhbHVlOiBib29sZWFuKVxuICAgIHtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGUoaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuaXRlbVRvS2V5KGl0ZW0pO1xuICAgICAgICBpZiAoIXRoaXMuaXNFeHBhbmRlZChpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IHRoaXMuZXhwYW5zaW9uU3RhdGVzO1xuICAgIH1cblxuICAgIGlzRXhwYW5kZWQoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuaXRlbVRvS2V5KGl0ZW0pO1xuICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIGNvbGxhcHNlIHBhcmVudCBvZiBwYXJlbnQgd2hpbGUgZGV0YWlsIHJvdyBpcyBleHBhbmRlZFxuICAgICAgICBpZiAodGhpcy5kdC5pc091dGxpbmUoKSAmJiAhdGhpcy5kdC5vdXRsaW5lU3RhdGUuaXNFeHBhbmRlZChrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpc091dGxpbmVFeHBhbmRlZCA9IHRoaXMuZHQuaXNPdXRsaW5lKCkgPyB0aGlzLmR0Lm91dGxpbmVTdGF0ZS5pc0V4cGFuZGVkKGtleSkgOiB0cnVlO1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGtleSkgJiYgdGhpcy5leHBhbnNpb25TdGF0ZXMuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpdGVtVG9LZXkoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gaXNFbnRpdHkoaXRlbSkgPyAoPEVudGl0eT5pdGVtKS5pZGVudGl0eSgpIDogaXRlbTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRFRTdGF0ZVNlcmlhbGl6YWJsZUhlbHBlclxue1xuICAgIG9mZnNldDogbnVtYmVyO1xuICAgIGxpbWl0OiBudW1iZXI7XG4gICAgZGlzcGxheUxpbWl0OiBudW1iZXI7XG4gICAgc29ydEtleTogc3RyaW5nO1xuICAgIHNvcnRPcmRlcjogbnVtYmVyO1xuICAgIGN1cnJlbnRTZWFyY2hRdWVyeTogc3RyaW5nO1xuICAgIGN1cnJlbnRGaWx0ZXI/OiBhbnk7XG4gICAgb3V0bGluZVN0YXRlOiBhbnk7XG4gICAgZGV0YWlsUm93RXhwYW5kU3RhdGU6IGFueTtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEVEluaXRQYXJhbXMoaW5pdDogRFREU0luaXRQYXJhbXMpOiBpbml0IGlzIERURFNJbml0UGFyYW1zXG57XG4gICAgcmV0dXJuIGlzUHJlc2VudChpbml0Lm9iaikgfHwgaXNQcmVzZW50KGluaXQucXVlcnlUeXBlKSB8fCBpc1ByZXNlbnQoaW5pdC5lbnRpdHkpO1xufVxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERURFNJbml0UGFyYW1zIGV4dGVuZHMgRFNJbml0UGFyYW1zXG57XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgZGVmaW5pdGlvbiBmb3IgdGhlIGRhdGFcbiAgICAgKi9cbiAgICBlbnRpdHk/OiBFbnRpdHlEZWYyO1xuXG4gICAgc3RhdGU/OiBEYXRhdGFibGUyU3RhdGU7XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDb2x1bW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBNdWx0aXNlbGVjdGlvbiB3aGVyZSB3ZSBzaG93IGNoZWNrYm94IGNvbnRyb2xcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LW11bHRpLXNlbGVjdC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlVXJsOiAnZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2R0LW11bHRpLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDb2x1bW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBTaW5nbGVTZWxlY3Qgd2hlcmUgd2Ugc2hvdyBjaGVja2JveCBjb250cm9sXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1zaW5nbGUtc2VsZWN0LWNvbHVtbicsXG4gICAgdGVtcGxhdGVVcmw6ICdkdC1zaW5nbGUtc2VsZWN0LWNvbHVtbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiBjb250cm9sXG4gICAgICAgIHRoaXMud2lkdGggPSAnNDVweCc7XG4gICAgfVxuXG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICogIEBvcmlnaW5hbC1saWNlbnNlXG4gKiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgUHJpbWVUZWtcbiAqXG4gKiAgQ3JlZGl0OiBEZXJpdmVkIGFuZCBleHRlbmRlZCBmcm9tIFByaW1lLW5nIGRhdGFibGUgd2hlcmUgd2UgbmVlZGVkIG1vcmUgbW9kdWxhciBzb2x1dGlvbi5cbiAqICBXZSByZXVzZWQgdGhlIGNvcmUgc3RydWN0dXJlIGFuZCBsYXlvdXQgYnV0IGhhZCB0byByZWZhY3RvciBib3RoIGNvZGUgYW5kIHRlbXBsYXRlIHRvIG1hdGNoIG91clxuICogIG5lZWRzLiBNb3JlIGluIHRoZSBkZXNjcmlwdGlvblxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEluamVjdCxcbiAgICBJbmplY3RvcixcbiAgICBJbnB1dCxcbiAgICBOZ1pvbmUsXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYmplY3RVdGlsc30gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL3V0aWxzL29iamVjdHV0aWxzJztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7aXNPdXRsaW5lTm9kZSwgT3V0bGluZVN0YXRlfSBmcm9tICcuLi9vdXRsaW5lL2luZGV4JztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIGFzc2VydCxcbiAgICBCb29sZWFuV3JhcHBlcixcbiAgICBFbnZpcm9ubWVudCxcbiAgICBlcXVhbHMsXG4gICAgRmllbGRQYXRoLFxuICAgIGlzQmxhbmssXG4gICAgaXNQcmVzZW50LFxuICAgIExpc3RXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZSwgRHJvcFBvc2l0aW9ufSBmcm9tICcuL2F3LWRhdGF0YWJsZSc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUSGVhZGVyQ29tcG9uZW50Mn0gZnJvbSAnLi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RURGV0YWlsUm93Q29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93L2R0LWRldGFpbC1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50JztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhdGFibGUyU3RhdGUsIERldGFpbFJvd0V4cGFuc2lvblN0YXRlLCBEVDJEYXRhU291cmNlfSBmcm9tICcuL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtcbiAgICBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL211bHRpLXNlbGVjdC9kdC1tdWx0aS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL3NpbmdsZS1zZWxlY3QvZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7TW9kZWxGb3JtYXR9IGZyb20gJy4uL291dGxpbmUvb3V0bGluZS1mb3IuY29tcG9uZW50JztcblxuXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ211bHRpJyB8ICdzaW5nbGUnIHwgJ2NlbGwnIHwgJ25vbmUnO1xuXG4vKipcbiAqIERUIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgdGhlIGRhdGEgZ3JpZCB0aGF0IHNob3dzIHRhYnVsYXIgZGF0YS4gRXZlbiB0aGUgYmFzaWNcbiAqIHN0cnVjdHVyZSBpcyBiYXNlZCBvbiBQcmltZU5HIGRhdGF0YWJsZSBpdHMgY29tcGxldGVseSByZWZhY3RvcmVkIGludG8gc21hbGxlciBwaWVjZXMgdGhhdFxuICogYWxsb3dzIG1vcmUgZXh0ZW5zaWJpbGl0eSBhbmQgdHJ5aW5nIHRvIHN0YXkgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gZXhpc3RpbmcgQVdMIGltcGxlbWVudGF0aW9uXG4gKlxuICogVGhlcmUgYXJlIDMgbWFpbiBwaWVjZXM6XG4gKlxuICogIFRhYmxlIFdyYXBwZXIgLSBmb2N1c2VzIG9uIHRoZSBvdXRlciBzdHJ1Y3R1cmUuIENvbnRhaW5lciB3aXRoIGJhc2ljIGRhdGFibGUgbGF5b3V0IHBsdXNcbiAqICBjb250YWlucyBhbnkgYWRkaXRpb25hbCBwYW5lbHMgdGhhdCBkYXRhdGFibGUgbmVlZHMgc3VjaCBhcyBvdXIgbmV3IGNvbmNlcHQgaG93IGVkaXRpbmcgd2lsbFxuICogIHdvcmsgLSBzbGlkaW5nIHBhbmVsIGZyb20gdGhlIGJvdHRvbVxuICpcbiAqICBEYXRhdGFibGUgQ29sdW1uIC0gSW5zdGVhZCBvZiByZW5kZXJpbmcgZXZlcnl0aGluZyBpbnNpZGUgRFQgSSBzcGxpdCB0aGUgcGFydCB0aGF0IHJlbmRlcnNcbiAqICBjb2x1bW4gaW50byBzZXBhcmF0ZSBjb21wb25lbnQuIFRoaXMgd2F5IGNvbXBvbmVudCBjb2x1bW4gaGFzIGl0cyBvd24gcmVuZGVyZXIgdGVtcGxhdGUgd2hpY2hcbiAqICBjYW4gcmVuZGVyIGJvdGggaGVhZGVyIGFuZCBkYXRhIGNlbGxzLlxuICogIExhdGVyIG9uIERUQ29sdW1uIGlzIHRoZW4gZXh0ZW5kZWQgdG8gc3VwcG9ydCBvdGhlciBhZGRpdGlvbmFsIGNvbHVtbiB0eXBlc1xuICogIFNpbmdsZVNlbGVjdGlvbkNvbHVtbiwgTXVsdGlTZWxlY3Rpb25Db2x1bW4sIGJvdGggcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBzZWxlY3Rpb24gY29udHJvbHMuXG4gKlxuICogVG8gc3VwcG9ydCBwaXZvdGFsIGxheW91dCB0aGlzIGNhbiBiZSBleHRlbmRlZCBmb3Igb3RoZXIgYWRkaXRpb25hbCBjb2x1bW5zIHRoYXQgaW1wbGVtZW50cyB0aGVpclxuICogb3duIHJlbmRlcmluZyB0ZW1wbGF0ZXNcbiAqXG4gKiBEYXRhdGFibGUgLSBUaGUgbWFpbiBjb21wb25lbnQgdGhhdCBpcyBvbmx5IGZvY3VzIG9uIGhlYWRlciBhbmQgYm9keSByZW5kZXJpbmcgYW5kIGJhc2FlZCBvbiB0aGVcbiAqIGNvbHVtbiB0eXBlIGl0IHdpbGwgcmVuZGVyIHRoZSBjb3JyZWN0IHRlbXBsYXRlXG4gKiBjb2x1bW4gdHlwZSBpdCB3aWxsIHJlbmRlciB0aGUgY29ycmVjdCB0ZW1wbGF0ZVxuICpcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGF0YXRhYmxlMicsXG4gICAgdGVtcGxhdGVVcmw6ICdkYXRhdGFibGUyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnZGF0YXRhYmxlMi5jb21wb25lbnQuc2NzcyddLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBPYmplY3RVdGlscyxcbiAgICAgICAgT3V0bGluZVN0YXRlLFxuICAgICAgICB7cHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBEVDJEYXRhU291cmNlLCBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdfSxcbiAgICBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcblxufSlcbmV4cG9ydCBjbGFzcyBEYXRhdGFibGUyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFXRGF0YVRhYmxlLCBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqICBMaXN0IG9mIGl0ZW1zIHRvIHNob3cgaW4gdGhlIGRhdGF0YWJsZS5cbiAgICAgKlxuICAgICAqICB0b2RvOiBpbXBsZW1lbnQgdGhlIHNhbWUgRGF0YXNvdXJjZSBhbmQgbGF6eSBsb2FkaW5nIGp1c3QgbGlrZSBJIGRpZCBpdCBmb3IgZGF0YXRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGVudGl0eSBmb3Igd2hpY2ggRGF0YVByb3ZpZGVyIHdpbGwgYmUgbG9hZGVkLiBZb3UgY2FuIGVpdGhlciBwYXNzIGxpc3Qgb2YgaXRlbXNcbiAgICAgKiBvciB1c2UgdGhpcyBkZXN0aW5hdGlvbkNsYXNzLiBOb3QgYm90aFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGVzdGluYXRpb25DbGFzczogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IFRhYmxlV3JhcHBlciB0byBhZGQgdXNlciBkZWZpbmVkIGNsYXMgaW50byB0aGUgdGFibGUgdGFnXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhYmxlU3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHlDbGFzc0ZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzUm93U2VsZWN0YWJsZTogKGl0ZW06IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogIEhpZGVzIG9yIHNob3dzIHRhYmxlIGhlYWRpbmcgd2hlcmUgd2UgaGF2ZSBmaWx0ZXJzIGFuZCB0b29scyBtZW51c1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1RhYmxlSGVhZGVyOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBpdm90YWxMYXlvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250ZXh0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluaXRpYWxTb3J0T3JkZXI6IHN0cmluZyA9ICdkZXNjZW5kaW5nJztcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5pdGlhbFNvcnRLZXk6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBEVCBpcyBsb2FkZWQgaW4gdGhlIHBhZ2UgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZ1bGwgc2NyZWVuIChmdWxsIHBhZ2UgbW9kZSksIHRoaXNcbiAgICAgKiBpcyBodGUgbnVtYmVyIG9mIGxpbmVzIHRoYXQgRFQgd2lsbCBzaG93XG4gICAgICpcbiAgICAgKiB0b2RvOiBjb21lIHVwIHdpdGggYmV0dGVyIG5hbWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlSb3dTaXplOiBudW1iZXIgPSAxMDtcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgcGFnaW5nIG9uIGxhenkgbG9hZGluZyB1c2luZyBpbmZpbml0ZSBzY3JvbGxlciB0byBzZXQgaW5pdGlhbCBmZXRjaCBsaW1pdCBzaXplXG4gICAgICpcbiAgICAgKiB0b2RvOiBjb21lIHVwIHdpdGggYmV0dGVyIG5hbWUgISEhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhZ2VTaXplOiBudW1iZXIgPSAxNTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkYXRhU291cmNlOiBEVDJEYXRhU291cmNlO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBtZXNzYWdlIHdoZW4gdGhlcmUgYXJlIG5vIGRhdGEgLlxuICAgICAqXG4gICAgICogdG9kbzogVXNlIGkxOG4gdmFsdWUgYW5kIGNyZWF0ZSByZXNvdXJjZSBmaWxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlbXB0eU1lc3NhZ2U6IHN0cmluZyA9ICdObyByZWNvcmRzIGZvdW5kJztcblxuXG4gICAgLyoqXG4gICAgICogRGV2ZWxvcGVyIGNhbiBwcm92aWRlIGN1c3RvbSB0cmFja0J5IGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGl0ZXJhdGUgb3ZlciB0aGVcbiAgICAgKiByZWNvcmRzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb3dUcmFja0J5OiAoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KSA9PiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUgYWRkcyBjdXN0b20gaG92ZXJpbmcgY2xhc3MgdG8gdGhlIHRib2R5XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb3dIb3ZlcjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIERvIHdlIHNob3cgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgKlxuICAgICAqIFRvZG86IHJlbmFtZSB0byBzaG93TG9hZGluZ1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbG9hZGluZzogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZSA9ICdub25lJztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FuIHByb3ZpZGUgY3VzdG9tIGljb24uIFRoZXNlIGljb25zIGFyZSBub3QgYW5pbWF0ZWQgZGl2cywgd2UgdXNlZCBjc3NcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbiB0byByb3RhdGUgdGhlbS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbG9hZGluZ0ljb246IHN0cmluZyA9ICdpY29uLXN5bmNocm9uaXplJztcblxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBpbmRlbnQgY2FuIGJlIGFkZGVkIHdoZW4gcmVuZGVyaW5nIGRldGFpbCByb3dcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluZGVudERldGFpbFJvdzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluZGVudGF0aW9uUGVyTGV2ZWw6IG51bWJlciA9IDI1O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgU3ViSGVhZGVyIGlzIHVzZWQgdG8gc2hvdyBzdW1tYXJ5IGNvbHVtbnMsIHdoaWNoIGluIG91ciBVWCBpcyBzaG93biBhdCB0aGUgdG9wIGp1c3QgdW5kZXJcbiAgICAgKiAgdGhlIHJlZ3VsYXIgdGFibGUgaGVhZGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKlxuICAgICAqIE5vdCB1c2VkIHdoZW4gW291dGxpbmVGb3JtYXRdPVwiJ3RydWVlJ1wiXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjaGlsZHJlbjogKHZhbHVlOiBhbnkpID0+IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBXZSBtaWdodCBoYXZlIHRoaXMgY29uZGl0aW9uYWwgYXMgdGhpcyBjYW4gYmUgZHluYW1pYyBiYXNlZCBvbiB2YWx1ZSwgc28gdGhlIHNhbWVcbiAgICAgKiBhcyBjaGlsZHJlblxuICAgICAqXG4gICAgICogU2VlIE91dGxpbmVGb3IgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0V4cGFuc2lvbkNvbnRyb2w6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgT3V0bGluZUZvciAtIG9ubHkgdXNlZCBpbiB0aGUgdHJlZSBtb2RlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHBhbmRBbGw6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgT3V0bGluZUZvciAgLSBmb3JtYXQgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb3V0bGluZUZvcm1hdDogTW9kZWxGb3JtYXQgPSAnZnJlZSc7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1c2hSb290U2VjdGlvbk9uTmV3TGluZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBvciBoaWRlIGV4cGFuc2lvbiBjb250cm9sIGZvciByb3cgZGV0YWlsIGNvbHVtbnMuIEV4cGFuc2lvbiBjb250cm9sIG1ha2VzIHNlbnNlIGZvclxuICAgICAqIHNpbXBsZSB0YWJsZSwgd2hlbiB1c2luZyB0aGlzIGluc2lkZSBvdXRsaW5lICh0cmVlIHRhYmxlKSwgaXRzIGRyaXZlbiBieSBvdXRsaW5lIGNvbnRyb2xcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dSb3dEZXRhaWxFeHBhbnNpb25Db250cm9sOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U2VsZWN0aW9uQ29sdW1uOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTZWxlY3RBbGw6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgZ2xvYmFsIHNlYXJjaCB0ZXJtIGlucHV0IGZpZWxkIGluIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dHbG9iYWxTZWFyY2g6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIGZyb3plbiBjb2x1bW4gYXJlIHVzaW5nIHdlIGNhbiBzcGVjaWZ5IG9uIGdsb2JhbCBsZXZlbCB0b3RhbCB3aWR0aCBvZiB0aGUgdGFibGUgdGhlXG4gICAgICogb3ZlcmZsb3dpbmcgY29udGVudCBvciB3aWR0aCBmb3IgZWFjaCBjb2x1bW4uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzY3JvbGxXaWR0aDogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHJvdyByZW9yZGVyaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRuZFJvd0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZXMgZXZlbnQgdGhhdCBzb3J0aW5nIGlzIGVuYWJsZWQgZm9yIGNvbHVtbiBhbmQgd2UgdHJpZ2dlciBzb3J0aW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNvcnQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiBzZWxlY3Rpb24gbW9kZSBpdCB0cmlnZ2VycyBldmVuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblJvd0NsaWNrOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBtdWx0aSBvciBzaW5nbGUgc2VsZWN0aW9uIG1vZGUgaXMgZW5hYmxlZCBpdCB3aWxsIHRyaWdnZXIgZXZlbnQgd2hlbiBjaGVja2JveCBvclxuICAgICAqIHJhZGlvIGJ1dHRvbnMgaXMgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIHRvZG86IGltcGxlbWVudCBTaW5nbGVTZWxlY3Rpb25EVENvbHVtbiwgTXVsdGlTZWxlY3Rpb25EVENvbHVtbiB3aXRoIHRoZWlyIHJlbmRlcmVyc1xuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBjZWxsIGJvZHkgc2VsZWN0aW9uIGNoYW5nZXMgd2UgZmlyZSBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DZWxsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2VsbCBoZWFkZXIgc2VsZWN0aW9uIGNoYW5nZXMgd2UgZmlyZSBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25IZWFkZXJTZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICBAQ29udGVudENoaWxkKERUSGVhZGVyQ29tcG9uZW50MilcbiAgICBoZWFkZXI6IERUSGVhZGVyQ29tcG9uZW50MjtcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXN0b20gdGVtcGxhdGUgdGhhdCBjYW4gYmUgaW1wbGVtZW50ZWQgYnkgYXBwbGljYXRpb24gdG8gc2hvdyB3aGVuIHRoZXJlIGFyZVxuICAgICAqIG5vIGRhdGEgaW4gdGhlIGRhdGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdub0RhdGFUZW1wbCcpXG4gICAgZW1wdHlNZXNzYWdlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2R0SGVhZGVyJylcbiAgICBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2R0U3ViSGVhZGVyJylcbiAgICBzdWJIZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2R0Qm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdoZWFkZXJGaWx0ZXInKVxuICAgIGhlYWRlckZpbHRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0cyB1c2VkIERUQ29sdW1uIGluc2lkZSBkYXRhdGFibGUgYW5kIHRoZW4gdGhleSBhcmUgdXNlZCBpbnNpZGUgdGhlIHRlbXBsYXRlIHRvXG4gICAgICogaXRlcmF0ZSBvdmVyIGFuZCB1c2UgaXRzIHJlbmRlcmVyVGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHdlIHdpbGwgYmUgZGVmaW5pbmcgbmV3IGNvbHVtbnMgaXRzIGltcG9ydGFudCB0aGF0IGl0IGNhbiBhbHNvIG1hdGNoIGFsbCB0aGVcbiAgICAgKiBpbmhlcml0ZWQgb25lcy4gc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgZGVmaW5lIGEgcHJvdmlkZXIgdGhvc2UgdGhvc2UgY29sdW1ucyB0byBwb2ludFxuICAgICAqIHRvIHRoZSBEVENvbHVtbkNvbXBvbmVudFxuICAgICAqXG4gICAgICogZS5nLjpcbiAgICAgKlxuICAgICAqIHtwcm92aWRlOiBEVENvbHVtbkNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGV0YWlsUm93Q29sdW1uKX1cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oRFRDb2x1bW4yQ29tcG9uZW50KVxuICAgIGNvbHNRdWVyeTogUXVlcnlMaXN0PERUQ29sdW1uMkNvbXBvbmVudD47XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoRFREZXRhaWxSb3dDb21wb25lbnQpXG4gICAgcm93RGV0YWlsQ29sdW1uOiBEVERldGFpbFJvd0NvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyB3aGVuIGl0ZW1zIGluIHRoZSBsaXN0IGFyZSB1cGRhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGNsYXNzTGlzdDogc3RyaW5nID0gJ3ctZGF0YXRhYmxlICc7XG5cblxuICAgIC8qKlxuICAgICAqIEZvciBpbnRlcm5hbCB1c2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGF0YXNldCB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLiBTZXQgZnJvbSB0aGUgW2xpc3RdIGJpbmRpbmcgb3IgYnkgbGF6eSBsb2FkIGZyb21cbiAgICAgKiBkYXRhc291cmNlXG4gICAgICovXG4gICAgcHVibGljIGRhdGFUb1JlbmRlcjogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBXZSBjb252ZXJ0IFF1ZXJ5TGlzdDxEVENvbHVtbjJDb21wb25lbnQ+IHRvIHRoaXMgYXJyYXkgZm9yIGVhc2llciBtYW5pcHVsYXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uczogRFRDb2x1bW4yQ29tcG9uZW50W107XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2Vjb25kYXJ5IGxpc3Qgb2YgY29sdW1ucyB3aGljaCBpcyB1c2VkIGluIGNhc2Ugd2UgaGF2ZSBoYXZlIGVuYWJsZWRcbiAgICAgKiBmcm96ZW4gY29sdW1ucy4gQ29sdW1ucyB0aGF0IGFyZSBtYXJrZWQgYXMgZnJvemVuIG5lZWRzIHRvIGJlIHBsYWNlZCBpbnRvIHNlcGFyYXRlIGFycmF5XG4gICAgICogdG8gYmUgcmVuZGVyZWQgd2F5IHRoYW4gcmVndWxhciBjb2x1bW5zIHdoaWNoIGFyZSBzdG9yZWQgaW4gdGhlIGNvbHVtbnMgYXJyYXkuXG4gICAgICovXG4gICAgcHVibGljIGZyb3plbkNvbHVtbnM6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiAgSW5kaWNhdGVzIHRoYXQgY29sdW1ucyB3ZXJlIGluaXRpYWxlZCBBbHNvIHVzZWQgd2hlbiB3ZSBoaWRlIGFuZCBzaG93IGNvbHVtbiB0byB0cmlnZ2VyXG4gICAgICogIGNoYW5nZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW5zQ2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc29ydENvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gY29sc1F1ZXJ5IGFuZCBpdHMgY2hhbmdlcyBzbyB3ZSBjYW4gbGF0ZXIgb24gcmVsZWFzZSB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICovXG4gICAgY29sdW1uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTogRGV0YWlsUm93RXhwYW5zaW9uU3RhdGU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIG51bWJlck9mQ29sc0JlZm9yZURhdGE6IG51bWJlciA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIHN0YXJ0T2ZGaXJzdERhdGFDb2x1bW46IG51bWJlciA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFNlY3Rpb24gZm9yIHByb2dyYW1tYXRpY2FsbHkgaW5zdGFudGlhdGVkIGNvbHVtbnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIGxpc3QgaWYgYWRkaXRpb25hbFxuICAgICAqIHNwYW4gb3IgbG9naWMgaXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogVG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYSBuZXcgY29sdW1uIGludG8gY29sdW1ucyBhcnJheSBsaWtlIGV4cGFuZG8gY29sdW1uIGZvciBkZXRhaWxcbiAgICAgKiByb3csIG9yIFNpbmdsZVNlbGVjdCwgTXVsdGlTZWxlY3QgY29sdW1uIHdoZW4gc2VsZWN0aW9uIGlzIGVuYWJsZWQgd2UgbmVlZCB0byB1c2VcbiAgICAgKiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gaW5zdGFudGlhdGUgYSBuZXcgY29tcG9uZW50LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSByb3dEZXRhaWxFeHBhbmRDb2x1bW46IERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQ7XG4gICAgcHJpdmF0ZSBtdWx0aVNlbGVjdENvbHVtbjogRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudDtcbiAgICBwcml2YXRlIHNpbmdsZVNlbGVjdENvbHVtbjogRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW4gY2FzZSBvZiBvdXRsaW5lIHRhYmxlIHdlIGFyZSBpbmplY3QgT3V0bGluZVN0YXRlIHdoaWNoIGlzIHByb3ZpZGVkIGluIHRoZSBEVCBjb21wb25lbnRcbiAgICAgKiBkZWZpbml0aW9uLiBUaGlzIGlzIHVzZWQgYnkgbmVzdGVkIG91dGxpbmVGb3IgY29tcG9uZW50IGl0IHNldCBpdHNlbGYgYXMgcmVmZXJlbmNlIGFuZFxuICAgICAqIGluaXRpYWxpemUgdGhlIHN0YXRlIHNvIGl0IGNhbiBiZSB1c2VkIGxhdGVyIG9uIGluc2lkZSBPdXRsaW5lQ29udHJvbFxuICAgICAqXG4gICAgICpcbiAgICAgKiBFYWNoIERhdGF0YWJsZSBpcyBwcmUtZGVmYXVsdGVkIHdpdGggaXRzIG93biB2ZXJzaW9uIG9mIERhdGFTb3VyY2Ugc28gYWxsIHRoZSBvYnNlcnZlcnNcbiAgICAgKiBpbnNpZGUgYXJlIHVuaXF1ZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWw6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHJpdmF0ZSBfZGVmYXVsdERTOiBEVDJEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgcHVibGljIGZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBvdXRsaW5lU3RhdGU6IE91dGxpbmVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwdWJsaWMgem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB0aGlzLl9kZWZhdWx0RFM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIGEgc3RhdGUgb3V0IHRvIGFwcGxpY2F0aW9uLiBDYW4gYmUgdXNlIGFzIHR3byB3YXkgYmluZGluZ3NcbiAgICAgKlxuICAgICAqIFsoc3RhdGUpXT1kdFN0YXRlKHMpXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGF0ZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgc2V0IHN0YXRlKHZhbDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlID0gdmFsO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpICYmIGlzUHJlc2VudCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3QgdXNlIGJvdGggYmluZGluZ3MgW2xpc3RdIGFuZCBbZGVzdGluYXRpb25DbGFzc10hJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSA9IG5ldyBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSh0aGlzKTtcblxuICAgICAgICAvLyBpbml0IGRlZmF1bHQgY29sdW1uc1xuICAgICAgICB0aGlzLnJvd0RldGFpbEV4cGFuZENvbHVtbiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpLmluc3RhbmNlO1xuXG5cbiAgICAgICAgdGhpcy5tdWx0aVNlbGVjdENvbHVtbiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpLmluc3RhbmNlO1xuXG4gICAgICAgIHRoaXMuc2luZ2xlU2VsZWN0Q29sdW1uID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpLmluc3RhbmNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZGF0YSBhcmUgbm90IGRlZmVycmVkIGFuZCB3ZSBnZXQgbGlzdCBkaXJlY3RseSB0aGVuIGl0IGNyZWF0ZXMgRFMuIElmXG4gICAgICAgICAqIG5nT25DaGFuZ2VzIGlzIGNhbGxlZCBmaXJzdCB3ZSBwcm9wZXJseSBpbml0IERTIGFuZCBjbGVhbiB0aGlzLmxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSB8fCBpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZSgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNpbmNlIHdlIHdvcmsgd2l0aCByZWZlcmVuY2VzIGxldCdzIHBhc3MgY3JlYXRlZCBtYXAgaW5zaWRlIG91ciBzdGF0ZVxuICAgICAgICB0aGlzLm91dGxpbmVTdGF0ZS5leHBhbnNpb25TdGF0ZXMgPSB0aGlzLnN0YXRlLm91dGxpbmVTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRhdGEgYXJyaXZlcyBsYXRlciBtYXliZSBkdWUgdG8gUkVTVCBBUEkgbGF0ZW5jeSwgaW5pdGlhbGl6ZSBEUyBvbmx5IHdoZW4gd2UgaGF2ZSBhXG4gICAgICogZGF0YSwgb3RoZXJ3aXNlIGlmIGRhdGEgY2hhbmdlZCB0aHJ1IHRoZSBiaW5kaW5ncyBqdXN0IHRyaWdnZXIgZGF0YUNoYW5nZSBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChjaGFuZ2VzWydsaXN0J10gJiYgaXNQcmVzZW50KGNoYW5nZXNbJ2xpc3QnXS5jdXJyZW50VmFsdWUpXG4gICAgICAgICAgICAmJiAhdGhpcy5kYXRhU291cmNlLmluaXRpYWxpemVkKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMubGlzdCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpXG4gICAge1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBpbml0IGEgc3RhdGUgd2hlbiBkZXRhaWwgY29sdW1uIGlzIHByZXNlbnRcbiAgICAgICAgLy8gdG9kbzogbW92ZSB0aGlzIGluaXRpYWxpemF0aW9uIHRvIGRhdGFzb3VyY2VcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkID0gaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKTtcblxuICAgICAgICB0aGlzLmluaXRDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbiA9IHRoaXMuY29sc1F1ZXJ5LmNoYW5nZXMuc3Vic2NyaWJlKF8gPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbml0Q29sdW1ucygpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KClcbiAgICB7XG4gICAgICAgIC8vIGFzc2lnbiBpdCBwcm9ncmFtYXRpY2FsbHkgYXMgd2Ugd2FudCB0byBoYXZlIGEgY29udGV4dCBmb3IgdGhlIGZpbHRlclxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSAmJiBpc1ByZXNlbnQodGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvcikpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IuZmlsdGVyT3V0ID0gdGhpcy5za2lwT3V0bGluZUl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvcikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IuY2hhbmdlRGV0ZWN0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAvLyB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zQ2hhbmdlZCAmJiB0aGlzLmVsLm5hdGl2ZUVsZW1lbnQub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucy5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCwgaW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAgICAgICAgICBjb2wucG9zdEluaXRpYWxpemUoaW5kZXgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCwgaW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAgICAgICAgICBjb2wucG9zdEluaXRpYWxpemUoaW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtleSBlbnRyeSBtZXRob2QgdGhhdCBpbml0aWFsaXplZCBvdXIgY29sdW1ucy4gTGF0ZXIgb24gd2hlbiB3ZSB3aWxsIHN1cHBvcnQgc2VsZWN0aW9uIGFuZFxuICAgICAqIG11bHRpc2VsZWN0aW9uIHdlIHdpbGwgcHJvZ3JhbW1hdGljYWxseSBpbnN0YW50aWF0ZSBTaW5nbGVTZWxlY3Rpb24sIE11bHRpU2VsZWN0aW9uIGNvbHVtblxuICAgICAqIGNvbXBvbmVudHMgYW5kIGFkZCB0aGVtIHRvIHRoZSBsaXN0IHNvIHRoZXkgY2FuIGJlIHJlbmRlcmVkLlxuICAgICAqXG4gICAgICogc28gdGhlIGlkZWEgaGVyZSBpczpcbiAgICAgKlxuICAgICAqIFdoZW4gRFQgY29tcG9uZW50IGluaXRpYWxpemUgYW5kIHdlIGFyZSBpbiBlZGl0aW5nIG1vZGUgYW5kIHdlIHN1cHBvcnQgU2luZ2xlL011bHRpIHNlbGVjdGlvblxuICAgICAqIHdlIHdpbGwgdXNlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBjcmVhdGUgY29tcG9uZW50IGFuZCBhZGQgaXQgYXMgZmlyc3QgaXRlbSB0byB0aGUgbGlzdFxuICAgICAqIGFuZCB0aGVuIGl0IHdpbGwgYmUgcmVuZGVyZWQganVzdCBsaWtlIGFueXRoaWduIGVsc2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0Q29sdW1ucygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGV0YWlsQ29sdW1uRXhwYW5zaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgdGhpcy5tdWx0aVNlbGVjdENvbHVtbi5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2godGhpcy5tdWx0aVNlbGVjdENvbHVtbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgdGhpcy5zaW5nbGVTZWxlY3RDb2x1bW4uaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKHRoaXMuc2luZ2xlU2VsZWN0Q29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgZXhwYW5zaW9uIGNvbHVtbiB3aGVuIGRldGFpbCByb3cgaXMgZW5hYmxlZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCAmJiAhdGhpcy5pc091dGxpbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5yb3dEZXRhaWxFeHBhbmRDb2x1bW4uaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKHRoaXMucm93RGV0YWlsRXhwYW5kQ29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sc1F1ZXJ5XG4gICAgICAgICAgICAuZmlsdGVyKChjb2wxOiBEVENvbHVtbjJDb21wb25lbnQpID0+ICFjb2wxLmZyb3plbilcbiAgICAgICAgICAgIC5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2wuaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbml0RnJvemVuQ29sdW1ucygpO1xuICAgICAgICB0aGlzLmluaXRDb2x1bW5JbmZvKCk7XG4gICAgICAgIHRoaXMuY29sdW1uc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGN1cnJlbnQgY29sdW1uIGlzIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgaXNJbnRlcm5hbENvbHVtbihjb2w6IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBjb2wgaW5zdGFuY2VvZiBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCB8fFxuICAgICAgICAgICAgY29sIGluc3RhbmNlb2YgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCB8fFxuICAgICAgICAgICAgY29sIGluc3RhbmNlb2YgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBuZXcgRGF0YXNvdXJjZSBiYXNlZCBvbiBwYXNzZWQgdmFsdWVzLiBJdCB0cmllcyB0byBpbml0aWFsaXplIERTIGZvciBmaXJzdCB0aW1lXG4gICAgICogaW5zaWRlIHRoZSBuZ0luaXQgYnV0IGluIGNhc2UgRGF0YSBhcnJpdmVzIGxhdGVyIG1heWJlIGR1ZSB0byBzb21lIFJFU1QgQVBJIGNhbGxzIHRoaXNcbiAgICAgKiBjYW4gYmUgdHJpZ2dlcmVkIGFsc28gZnJvbSBuZ09uQ2hhbmdlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXREYXRhc291cmNlKGluaXRpYWxpemU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBEYXRhdGFibGUyU3RhdGUuY3JlYXRlKDAsIHRoaXMucGFnZVNpemUsIHRoaXMuZGlzcGxheVJvd1NpemUsXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsU29ydEtleSwgdGhpcy5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5pbml0aWFsU29ydE9yZGVyKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmxpbWl0ID0gdGhpcy5zdGF0ZS5kaXNwbGF5TGltaXQgPSB0aGlzLmRpc3BsYXlSb3dTaXplO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmluaXRpYWxTb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc29ydEtleSA9IHRoaXMuaW5pdGlhbFNvcnRLZXk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zb3J0T3JkZXIgPSB0aGlzLnNvcnRPcmRlcmluZ0ZvclN0cmluZyh0aGlzLmluaXRpYWxTb3J0T3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRpYWxpemUpIHtcblxuICAgICAgICAgICAgbGV0IHFUeXBlID0gKHRoaXMuaXNPdXRsaW5lKCkgJiYgdGhpcy5vdXRsaW5lRm9ybWF0ID09PSAndHJlZScpID9cbiAgICAgICAgICAgICAgICBRdWVyeVR5cGUuRnVsbFRleHRPdXRsaW5lIDogUXVlcnlUeXBlLkZ1bGxUZXh0O1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICAgICAgb2JqOiBpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSA/IHRoaXMuZGVzdGluYXRpb25DbGFzcyA6IHRoaXMubGlzdCxcbiAgICAgICAgICAgICAgICBxdWVyeVR5cGU6IHFUeXBlLFxuICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIG11bHRpc2VsZWN0OiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLmZldGNoKHRoaXMuc3RhdGUpO1xuXG4gICAgICAgIC8vIHJlc2V0IGxpc3QgdG8gbWFrZSBzdXJlIGl0IGNvbWVzIGZyb20gRGF0YVByb3ZpZGVyLCB3ZSB1c2UgbGlzdCAgdG8gaW5pdGlhbGl6ZVxuICAgICAgICB0aGlzLmxpc3QgPSBudWxsO1xuXG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIEVOVFJZIHBvaW50IGZvciB0aGUgREFUQSBDSEFOR0VTLiBBbGwgYWRkaXRpb24sIGVkaXRzLCBkZWxldGlvbiBlbmRzIHVwXG4gICAgICAgIC8vIGhlcmUuIFdlIGRvbnQgd29yayBkaXJlY3RseSB3aXRoIExJU1QuIEFueSBjaGFuZ2UgaXMgcmVhY3RpdmUgYW5kIGhlcmUgaXMgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLm9wZW4oKS5zdWJzY3JpYmUoKGRhdGE6IGFueVtdKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpc3QoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGV0YWlsUm93IGNvbHVtbiBpcyBwcmVzZW50IHdlIGluaXRpYWxpemUgYSBzdGF0ZSBob2xkaW5nIGluZm9ybWF0aW9uIHdoaWNoIGl0ZW0gaXNcbiAgICAgKiBleHBhbmRlZC5cbiAgICAgKlxuICAgICAqIHRvZG86IFRoaXMgaXMgdGVtcG9yYXJ5IGhlcmUgYW5kIG9uY2Ugd2Ugc3Vwb3J0IGxhenkgbG9hZGluZyBtb3ZlIHRoaXMgdG8gZGF0YXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlIGZvciBvdXRsaW5lIHRyZWUgdGFibGUgd2UgbmVlZCB0byBjb25uZWN0IGEgc3RhdGUgZnJvbSBvdXRsaW5lIHdpdGggYSBzdGF0ZSBpblxuICAgICAqIGhlcmUgYXMgd2UgYXJlIHVzaW5nIG91dGxpbmUgY29udHJvbCB0byBleHBhbmQgYW5kIGNvbGxhcHNlIGl0ZW1zXG4gICAgICovXG4gICAgaW5pdERldGFpbENvbHVtbkV4cGFuc2lvbigpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSkge1xuICAgICAgICAgICAgdGhpcy5yb3dEZXRhaWxDb2x1bW4uaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgPSBpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pICYmXG4gICAgICAgICAgICBCb29sZWFuV3JhcHBlci5pc1RydWUodGhpcy5zaG93Um93RGV0YWlsRXhwYW5zaW9uQ29udHJvbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXhlY3V0ZWQgYWZ0ZXIgd2UgaW5pdGlhbGl6ZSBhbGwgdGhlIGNvbHVtbnMgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIGNvcnJlY3RcbiAgICAgKiBudW1iZXJzIHVzZWQgZm9yIGluZGVudGF0aW9uIHdoaWxlIHJlbmRlcmluZyBzZWxlY3Rpb24gY29sdW1ucyBhcyB3ZWxsIGFzIGRldGFpbCByb3cgY29sdW1ucy5cbiAgICAgKlxuICAgICAqIEhlcmUgd2UgbmVlZCB0byBiZSBhd2FyZSBob3cgbWFueSBjb2x1bW5zIHRvIHNwYW5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRDb2x1bW5JbmZvKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YSA9IDA7XG5cbiAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWNvbC5pc1ZhbHVlQ29sdW1uKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZW50RGV0YWlsUm93KSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGErKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhcnRPZkZpcnN0RGF0YUNvbHVtbiA9IHRoaXMuY29sdW1ucy5sZW5ndGggLSB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNlbGxTZWxlY3Rpb25DaGFuZ2UoY2VsbDogYW55LCBjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSAhPT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvb2t1cEtleSA9IHtcbiAgICAgICAgICAgIGNvbDogY29sdW1uLmtleSB8fCBjb2x1bW4ubGFiZWwsXG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pICYmIHRoaXMuc3RhdGUuc2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBsb29rdXBLZXkpO1xuICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWQgPSBmb3VuZEluZGV4ICE9PSAtMTtcblxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gZm91bmRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0aW9uLCBsb29rdXBLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbbG9va3VwS2V5XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2VsbENoYW5nZS5lbWl0KHRoaXMuc3RhdGUuc2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGVhZGVyU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJTZWxlY3RlZChjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uID0gY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25IZWFkZXJTZWxlY3Rpb24uZW1pdCh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgb25IYW5kbGVSb3dDbGlja2VkKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIHNwZWNpYWwgYWx0IGtleSBtb2RpZmllci4gV2hlbiB1c2VkIHdpdGggcm93cyBpdCBpbmRpY2F0ZXMgdGhlcmUgaXMgYSBEJkQgZW5hYmxlZFxuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICB0aGlzLm9uUm93VG9nZ2xlKGV2ZW50LCBpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHRoaXMub25Sb3dTZWxlY3QoZXZlbnQsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvblJvd1RvZ2dsZShldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgcm93U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJiB0aGlzLnN0YXRlLnNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pO1xuICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWQgPSBmb3VuZEluZGV4ICE9PSAtMTtcblxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gZm91bmRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICByb3dTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvciB0aGUgb3V0bGluZSBnbyB1cCBhbmQgZG93biB0aGUgc3luYyB3aXRoIHRyZWVpdGVtc1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRsaW5lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oaXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbaXRlbV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoaXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblJvd1NlbGVjdGlvbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHJvd1NlbGVjdGVkLFxuICAgICAgICAgICAgaXRlbTogdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvblJvd1NlbGVjdChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IGl0ZW07XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIHRoaXMub25Sb3dTZWxlY3Rpb25DaGFuZ2UuZW1pdChpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBjaGlsZHJlbkZvck5vZGUgPSB0aGlzLmNoaWxkcmVuLmFwcGx5KHRoaXMuY29udGV4dCwgW2N1cnJlbnRJdGVtXSkgfHwgW107XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuRm9yTm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiBpcyBzZWxlY3RlZCBjdXJyZW50bHkgdGhlbiB0b2dnbGUgdG8gb3RoZXIgc3RhdGVcbiAgICAgICAgICAgIGlmICghaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2hlY2tpbmcgYWxsIGZyb20gcm9vdCwgZGVzZWxlY3QgY2hpbGRyZW4gYW5kIGFkZCBhbGxcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oY3VycmVudEl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0aW9uLCAuLi5jaGlsZHJlbkZvck5vZGVdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlYWNoIGNoaWxkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW5Gb3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHNhbWUgZm9yIGNoaWxkcmVuIG9mIGNoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbkZvck5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oY2hpbGQsIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VycmVudEl0ZW0uJCRwYXJlbnRJdGVtO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbkZvck5vZGUgPSB0aGlzLmNoaWxkcmVuLmFwcGx5KHRoaXMuY29udGV4dCwgW3BhcmVudF0pIHx8IFtdO1xuXG4gICAgICAgICAgICBsZXQgYWxsU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW5Gb3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgYWxsU2VsZWN0ZWQgPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBjaGlsZCkgIT09IC0xXG4gICAgICAgICAgICAgICAgICAgICYmIGFsbFNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IHBhcmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW0uJCRwYXJlbnRJdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25EbkRSb3dEcm9wKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0Ryb3BwaW5nIHJvdyAjOiAnLCBvcmlnUG9zICsgJyAnICsgZHJvcFBvcyArICcgcm93ICM6ICcgKyBuZXdQb3MpO1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnJlb3JkZXJSb3dzKG9yaWdQb3MsIG5ld1BvcywgZHJvcFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3V0bGluZUV4cGFuZENoYW5nZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGl0ZW0gPSBldmVudC5pdGVtO1xuXG4gICAgICAgIC8vIFdlIGRvbnQgcmVhbGx5IG5lZWQgdG8gc3RvcmUgYSBzdGF0ZSBmb3JtIG91dGxpbmUgbG9jYWxseSBhcyB3ZSBhcmUgdXNpbmcgdGhlIHNhbWUgb2JqZWN0XG4gICAgICAgIC8vIHJlZmVyZW5jZVxuICAgICAgICAvLyB0aGlzLnN0YXRlLm91dGxpbmVTdGF0ZSA9IHRoaXMub3V0bGluZVN0YXRlLmV4cGFuc2lvblN0YXRlcztcblxuICAgICAgICBpZiAodGhpcy5jYW5Vc2VGb3JEZXRhaWxSb3coaXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUudG9nZ2xlKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRTaW5nbGUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpICYmIGlzUHJlc2VudCh0aGlzLnNvcnRDb2x1bW4pKSB7XG5cbiAgICAgICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5zb3J0Q29sdW1uLmtleSksICdJbnZhbGlkIGNvbHVtbiB0byBzb3J0Jyk7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc29ydCh0aGlzLnNvcnRDb2x1bW4ua2V5LCB0aGlzLnNvcnRDb2x1bW4uc29ydE9yZGVyKTtcblxuICAgICAgICAgICAgdGhpcy5vblNvcnQuZW1pdCh7XG4gICAgICAgICAgICAgICAgZmllbGQ6IHRoaXMuc29ydENvbHVtbi5rZXksXG4gICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMuc29ydENvbHVtbi5zb3J0T3JkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbmdlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNvcnRLZXkgfHwgdGhpcy5zb3J0Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc29ydENvbHVtbiAmJiB0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRDb2x1bW4gPSB0aGlzLmNvbHVtbnMuZmluZChcbiAgICAgICAgICAgICAgICAgICAgY29sID0+IGNvbC5rZXkgPT09IHRoaXMuc3RhdGUuc29ydEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcigpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy5saXN0KTtcbiAgICB9XG5cbiAgICB1cGRhdGVEYXRhVG9SZW5kZXIoZGF0YXNvdXJjZT86IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuZGF0YVRvUmVuZGVyID0gZGF0YXNvdXJjZSB8fCB0aGlzLmxpc3Q7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jaGlsZHJlbikgJiYgaXNQcmVzZW50KHRoaXMuZGF0YVRvUmVuZGVyKVxuICAgICAgICAgICAgJiYgdGhpcy5kYXRhVG9SZW5kZXIubGVuZ3RoID4gMCAmJiBpc091dGxpbmVOb2RlKHRoaXMuZGF0YVRvUmVuZGVyWzBdKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9ybWF0ID0gJ3RyZWUnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgcmVzZXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zb3J0Q29sdW1uID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhVG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBpc0hlYWRlclNlbGVjdGVkKGl0ZW06IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbE1hdGNoZWQgPSBpdGVtLmtleSB8fCBpdGVtLmxhYmVsO1xuICAgICAgICBsZXQgY3VycmVudENvbCA9IHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uLmtleSB8fCB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbi5sYWJlbDtcbiAgICAgICAgcmV0dXJuIGNvbE1hdGNoZWQgPT09IGN1cnJlbnRDb2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzQm9keUNlbGxTZWxlY3RlZChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGxvb2t1cEtleSA9IHtcbiAgICAgICAgICAgIGNvbDogY29sdW1uLmtleSB8fCBjb2x1bW4ubGFiZWwsXG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pICYmXG4gICAgICAgICAgICBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBsb29rdXBLZXkpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiBpc1ByZXNlbnQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbSkgIT09IC0xO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWxzKHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEbyB3ZSBoYXZlIGRhdGEgdG8gcmVuZGVyIFVzZWQgaW5zaWRlIHRlbXBsYXRlIHRvIHRlbGwgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgTm9EYXRhIHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0VtcHR5KClcbiAgICB7XG4gICAgICAgIHJldHVybiBpc0JsYW5rKHRoaXMuZGF0YVRvUmVuZGVyKSB8fCAodGhpcy5kYXRhVG9SZW5kZXIubGVuZ3RoID09PSAwKTtcbiAgICB9XG5cbiAgICBoYXNGcm96ZW5Db2x1bW5zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5mcm96ZW5Db2x1bW5zKSAmJiB0aGlzLmZyb3plbkNvbHVtbnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBoYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmICF0aGlzLnNob3dTZWxlY3Rpb25Db2x1bW47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZSAhPT0gJ25vbmUnICYmIHRoaXMuc2VsZWN0aW9uTW9kZSAhPT0gJ2NlbGwnO1xuICAgIH1cblxuICAgIHZpc2libGVDb2x1bW5zKCk6IERUQ29sdW1uMkNvbXBvbmVudFtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zID8gdGhpcy5jb2x1bW5zLmZpbHRlcihjID0+IGMuaXNWaXNpYmxlKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgc29ydE9yZGVyaW5nRm9yU3RyaW5nKGRpcmVjdGlvbjogc3RyaW5nKTogbnVtYmVyXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09ICdkZXNjZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IGxvZyBiYWQga2V5XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHNvcnRPcmRlcmluZ0Zvck51bWJlcihkaXJlY3Rpb246IG51bWJlcik6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXNjZW5kaW5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZXNjZW5kaW5nJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBsb2cgYmFkIGtleVxuICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVBbGxDb2x1bW5zKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uIHx8IFtdO1xuICAgICAgICBpZiAoc2VsZWN0ZWRPYmplY3QubGVuZ3RoID49IGN1cnJlbnRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4uY3VycmVudEl0ZW1zXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1RvZ2dsZUFsbENvbHVtblNlbGVjdGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcbiAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0ID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24gfHwgW107XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkT2JqZWN0Lmxlbmd0aCA+PSBjdXJyZW50SXRlbXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlzVG9nZ2xlQWxsQ29sdW1uRGlzYWJsZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJdGVtcyA9IHRoaXMuZGF0YVRvUmVuZGVyIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50SXRlbXMubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSB0ZW1wbGF0ZSB0byBkZWNpZGUgaWYgd2UgbmVlZCB0byByZW5kZXIgRGV0YWlsUm93IHRlbXBsYXRlLiBXZSBuZWVkIHRvIGhhdmVcbiAgICAgKiBEZXRhaWxSb3cgQ29udGVudENoaWxkIGFuZCB1c2luZyBEZXRhaWxSb3cgY29tcG9uZW50IFtpc1Zpc2libGVGbl0gZnVuY3Rpb24gYmluZGluZyB3ZVxuICAgICAqIGNoZWNrIGlmIHRoZSBpdGVtIHRoYXQgaXMgYWJvdXQgdG8gYmUgcmVuZGVyZWQgaXMgZWxpZ2libGUgZm9yIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dEZXRhaWxDb2x1bW4oaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pICYmIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuaXNFeHBhbmRlZChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc091dGxpbmUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNoaWxkcmVuKSB8fCB0aGlzLm91dGxpbmVGb3JtYXQgPT09ICd0cmVlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gZGVhbGluZyB3aXRoIGRldGFpbCBjb2x1bW4gKGRldGFpbCByb3cpIGFuZCBvdXRsaW5lIGFsbCB0b2dldGhlciB3ZSBuZWVkIGhhdmUgYVxuICAgICAqIG1lY2hhbmlzbSB0byB0ZWxsIHRvIHRoZSBvdXRsaW5lIFwiZG9uJ3QgcmVuZGVyIHRoZSBuZXh0IGxldmVsIG9mIGl0ZW1zXCIgYW5kIHVzZSBkZXRhaWwgcm93LlxuICAgICAqIFNvIGNlcnRhaW4gaXRlbSB0eXBlIG5lZWRzIHRvIGJlIHNraXBwZWQuXG4gICAgICpcbiAgICAgKiBUaGUgd2F5IHdlIHNraXAgdGhvc2UgaXRlbSBpcyB3ZSB1c2UgaXNWaXNpYmxlRm4gY29uZGl0aW9uIG9mIHRoZSBkZXRhaWwgcm93IGFuZCBsb29rIGFoZWFkXG4gICAgICogaWYgd2Ugc2hvdWxkIHNraXAgbmV4dCBsZXZlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHNraXBPdXRsaW5lSXRlbShpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5Vc2VGb3JEZXRhaWxSb3coaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWYWx1ZShkYXRhOiBhbnksIGZpZWxkOiBzdHJpbmcpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhLCBmaWVsZCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoYXQgd2UgYWxzbyBpbmNsdWRlIHByb2dyYW1tYXRpYyBjb2x1bW4gaWYgcHJlc2VudC4gTW92ZSB0aGVtIHRvIHRoZSBjb3JyZWN0XG4gICAgICogYXJyYXlcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdEZyb3plbkNvbHVtbnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5jb2xzUXVlcnlcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvbDE6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gY29sMS5mcm96ZW4pXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29sLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zLnB1c2goY29sKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvemVuQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBmaW5kIGxhc3QgaW5kZXggb2YgY29sdW1uIHRoYXQgaXMgaW50ZXJuYWwgLyBwcm9ncmFtbWF0aWNcblxuICAgICAgICAgICAgbGV0IGxhc3RJbnggPSB0aGlzLmNvbHVtbnMuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAuZmluZEluZGV4KChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gdGhpcy5pc0ludGVybmFsQ29sdW1uKGNvbCkpO1xuXG4gICAgICAgICAgICBpZiAobGFzdElueCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5jb2x1bW5zLmxlbmd0aCAtIDEgLSBsYXN0SW54O1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcm5hbENvbHMgPSB0aGlzLmNvbHVtbnMuc3BsaWNlKDAsIGlkeCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucyA9IFsuLi5pbnRlcm5hbENvbHMsIC4uLnRoaXMuZnJvemVuQ29sdW1uc107XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGhhc1ZhbGlkQ29scyA9IHRoaXMuY29sdW1uc1xuICAgICAgICAgICAgICAgIC5maW5kSW5kZXgoKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiBpc0JsYW5rKGNvbC53aWR0aCkpID09PSAtMTtcblxuICAgICAgICAgICAgYXNzZXJ0KGhhc1ZhbGlkQ29scyB8fCBpc1ByZXNlbnQodGhpcy5zY3JvbGxXaWR0aCksXG4gICAgICAgICAgICAgICAgJ1doZW4gdXNpbmcgW2Zyb3plbl0gYmluZGluZyB5b3UgbmVlZCBzcGVjaWZ5IFt3aWR0aF0gZm9yIGVhY2ggJyArXG4gICAgICAgICAgICAgICAgJ2NvbHVtbiBvciBbc2Nyb2xsV2lkdGhdIG9uIGRhdGF0YWJsZSEnKTtcblxuXG4gICAgICAgICAgICBhc3NlcnQoaXNCbGFuayh0aGlzLnJvd0RldGFpbENvbHVtbiksXG4gICAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgY29tYmluZSBhdy1kdC1kZXRhaWwtY29sdW1uIHdpdGggZnJvemVuIGNvbHVtbnMhJyk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY3VycmVudCBpbW11dGFibGUgbGlzdCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLiBOZWVkIHRvIHdyYXAgaXQgd2l0aFxuICAgICAqIHNldFRpbWVvdXQgYXMgdGhlIGNoYW5nZSBjYW4gZWFzaWx5IGNvbWUgYWZ0ZXIgdmlldyBjaGVja2VkIGFuZCB0aGlzIHdvdWxkIHJlc3VsdCBzb21lIGVycm9yc1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVMaXN0KG5ld0xpc3Q6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmxpc3QgPSBuZXdMaXN0O1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEYXRhQ2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pICYmXG4gICAgICAgICAgICAoPERURGV0YWlsUm93Q29tcG9uZW50PnRoaXMucm93RGV0YWlsQ29sdW1uKS5zaG93RGV0YWlsUm93KGl0ZW0pO1xuICAgIH1cbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIFBMQVRGT1JNX0lELFxuICAgIFJlbmRlcmVyMixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge29mLCBTdWJqZWN0LCBTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtkZWJvdW5jZVRpbWUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBzd2l0Y2hNYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7aXNQbGF0Zm9ybUJyb3dzZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2luZml0ZS1zY3JvbGwvaW5maXRlLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqIFBsZWFzZSBzZWUgZGF0YXRhYmxlIGZvciBtb3JlIGRldGFpbCBkZXNjcmlwdGlvbi4gQnV0IHRoZSBtYWluIGdvYWwgb2YgdGhpcyB3cmFwcGVyIHRvIHJlbW92ZVxuICogYWxsIHRoZSBjb21tb24gc3Vycm91bmRpbmcgcGFydHMgYXJvdW5kIHRoZSBkYXRhdGFibGUgYW5kIG1ha2Ugc3VyZSBEVCBjYW4gZm9jdXMgb25seSBhY3R1YWxcbiAqIGhlYWRlciBhbmQgYm9keSBzdHJ1Y3R1cmVcbiAqXG4gKiBJdCBpcyBleHBlY3RlZCB0aGF0IHdyYXBwZXIgYWxzbyBwcm92aWRlcyBzb21lIGNvZGUgZm9yIHRoZSBzbGlkaW5nIHVwIHBhbmVsIGNvbnRhaW5pbmdcbiAqIGJ1dHRvbnMgYW5kIG90aGVyIGFjdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZHVyaW5nIGVkaXRpbmdcbiAqXG4gKlxuICogVG9kbzogRXh0cmFjdCB0aGUgZXhwYW5kIGxvZ2ljIG91dCBpbnRvIHNvbWUgZGlyZWN0aXZlIG9yIGNvbXBvbmVudCBvciBqdXN0IGEgY2xhc3NcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtd3JhcHBlcicsXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJsZS13cmFwcGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsndGFibGUtd3JhcHBlci5jb21wb25lbnQuc2NzcyddLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcblxufSlcbmV4cG9ydCBjbGFzcyBEVFdyYXBwZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZFxue1xuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdGhhdCBpcyB1c2VkIGJ5IGZ1bGwgc2NyZWVuIGRpdiBvdmVybGF5IHRvIGNyZWF0ZSBleHBhbmRpbmcgZWZmZWN0IHdoaWNoIG5lZWRzIHRvIGhhdmVcbiAgICAgKiBsaXR0bGUgdGVudDtcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQ29sb3JGcm9tOiBzdHJpbmcgPSAnI2YzZjNmMyc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRoYXQgaXMgdXNlZCB0byBzZXQgYWZ0ZXIgd2UgYXJlIGluIHRoZSBmdWxsIHNjcmVlbiBzbyBvdXIgb3ZlcmxheSBkaXYgaGlkZSBldmVyeXRoaW5nXG4gICAgICogb24gdGhlIHBhZ2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQ29sb3JUbzogc3RyaW5nID0gJyNGRkZGRkYnO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRhYmxlIGhlYWRpbmcgYXJlYSBvZmZlcnMgZGV2ZWxvcGVyIHRvIGNvbXBsZXRlbHkgb3ZlcnJpZGUgdGhlIHRvcCBiYXIgd2hlcmUgd2UgaGF2ZSBmaWx0ZXJzXG4gICAgICogYW5kIG90aGVycyBhY3Rpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGluZ0FyZWEnKVxuICAgIGhlYWRpbmc6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGFibGUgaGVhZGVycyBhbmQgd3JhcHMgdGhlbSB3aXRoaW4gdGhlYWQgdGFnXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyUm93cycpXG4gICAgaGVhZGVyUm93czogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0YWJsZSBib2R5XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keVJvd3MnKVxuICAgIGJvZHlSb3dzOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBoZWFkaW5nIHRlbXBsYXRlLiBXZSBuZWVkIHRvIHJlbW92ZSB0aGlzIGRlcGVuZGVuY3kgb24gcHJpbWVORyBzbyBmYXIgaXQgaXMgdXNpbmdcbiAgICAgKiBwLWZvb3RlclxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2Zvb3RlckFyZWEnKVxuICAgIGZvb3RlcjogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogRGl2IHVzZWQgdG8gbWFrZSB0aGUgZnVsbCBzY3JlZW4gZXhwYW5zaW9uIGVmZmVjdFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2R0RnVsbFNjcmVlbk92ZXJsYXknKVxuICAgIGR0RnVsbFNjcmVlbk92ZXJsYXk6IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBpbmZpdGUgc2Nyb2xsLiBXZSBhcmUgdXNpbmcgdGhpcyB0byB0cmlnZ2VyIGxvYWRpbmcgZmluaXNoIGV2ZW50IHNvIHdlIGNhblxuICAgICAqIGhpZGUgbG9hZGluZyBhbmltYXRpb25cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdpbmZpbml0ZVNjcm9sbCcpXG4gICAgaW5maW5pdGVTY3JvbGw6IEluZmluaXRlU2Nyb2xsQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBkZWJvdW5jZSB0aGUgdHlwaW5nIHdlIG5lZWQgdG8gdXNlIHN1YmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHNlYXJjaFRlcm1zID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU3BlY2lmaWVzIGlmIHdlIGFyZSBpbiB2aWV3aW5nL2VkaXRpbmcgbW9kZSB0aGF0IGNhbiBicm93c2Ugd2hvbGUgZGF0YXNldCBsYXppbHlcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRnVsbFNjcmVlbk1vZGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIGNhbiBzdXBwb3J0IGZ1bGwgc2NyZWVuIG1vZGUgLSBvbmx5IGF2YWlsYWJsZSBmb3IgdGhlIGJyb3dzZXJcbiAgICAgKlxuICAgICAqL1xuICAgIHN1cHBvcnRGdWxsU2NyZWVuOiBib29sZWFuID0gdHJ1ZTtcbiAgICBxdWVyeVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIGxvYWRpbmdTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICAvKipcbiAgICAgKiAgU2F2ZXMgb3JpZ2luYWwgYm91bmRpbmcgcmVjdCBjb29yZGluYXRlcyBiZWZvcmUgd2UgZXhwYW5kIHRoZSBEVCB0byBmdWxsIHNjcmVlblxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkdEJvdW5kaW5nQ2xpZW50UmVjdDogYW55O1xuICAgIC8qKlxuICAgICAqIFJlbWVtYmVycyBvcmlnaW5hbCBzY3JvbGwgcG9zaXRpb24gYmVmb3JlIHdlIHN3aXRjaCB0byBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICovXG4gICAgcHJpdmF0ZSBvcmlnaW5hbFNjcm9sbFBvc2l0aW9uOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGhpc0VsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgICAgICAgICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXRhdGFibGUyQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwdWJsaWMgZHQ6IERhdGF0YWJsZTJDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLnF1ZXJ5U3Vic2NyaXB0aW9uID0gdGhpcy5zZWFyY2hUZXJtcy5waXBlKFxuICAgICAgICAgICAgLy8gd2FpdCAzMDBtcyBhZnRlciBlYWNoIGtleXN0cm9rZSBiZWZvcmUgY29uc2lkZXJpbmcgdGhlIHRlcm1cbiAgICAgICAgICAgIGRlYm91bmNlVGltZSgzMDApLFxuXG4gICAgICAgICAgICAvLyBpZ25vcmUgbmV3IHRlcm0gaWYgc2FtZSBhcyBwcmV2aW91cyB0ZXJtXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKHRlcm06IHN0cmluZykgPT4gb2YodGVybSkpXG4gICAgICAgICkuc3Vic2NyaWJlKCh0ZXJtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGVybSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmluZCh0ZXJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2FkaW5nU3ViID0gdGhpcy5kdC52YWx1ZUNoYW5nZVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZGF0YTogYW55KSA9PiB0aGlzLmxvYWRpbmdGaW5pc2hlZCgpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGNvbHVtbnMgbWFya2VkIGFzIGZyb3plbiBhbmQgcmV0cmlldmUgYSB3aWR0aCBzbyB3ZSBjYW4gdXBkYXRlXG4gICAgICogcGFyZW50IGRpdlxuICAgICAqXG4gICAgICovXG4gICAgY2FsY3VsYXRlRnJvemVuV2lkdGgoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZHQuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmR0LmZyb3plbkNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjb2wubWF4V2lkdGhQeCA+IDApIHtcbiAgICAgICAgICAgICAgICBmV2lkdGggKz0gY29sLndpZGVzdENlbGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZXaWR0aCArPSBwYXJzZUludChjb2wud2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZldpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBoYXZpbmcgdHdvIHNlcGFyYXRlIHRhYmxlcyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHJvd3Mgb2YgdGhlIHRhYmxlcyBhcmUgYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIFRoZXJlZm9yZSB0aGlzIG1ldGhvZCB0YWtlcyBmaXJzdCBjb2x1bW4gZnJvbSBlYWNoIHRhYmxlIHJlYWQgdGhlIGhlaWdodCBvZiB0aGUgcm93cyBhbmQgc2V0XG4gICAgICogdGhlIG1heCBoZWlnaHQgdG8gYm90aCByb3dzLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhbGlnblRhYmxlc0hlaWdodHMoZnJvemVuVmlldzogYW55LCB1bkZyb3plblZpZXc6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQoZnJvemVuVmlldykgJiYgaXNQcmVzZW50KGZyb3plblZpZXcpLFxuICAgICAgICAgICAgJ0NhbnQgYWxpZ24gdGFibGUgdmlld3MgYXMgb25lIG9mIHRoZSB2aWV3IGlzIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIGxldCBmcm96ZW5Sb3dzOiBhbnlbXSA9IGZyb3plblZpZXcucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdHInKTtcbiAgICAgICAgbGV0IHVuRnJvemVuUm93czogYW55W10gPSB1bkZyb3plblZpZXcucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdHInKTtcblxuICAgICAgICBhc3NlcnQoZnJvemVuUm93cy5sZW5ndGggPT09IHVuRnJvemVuUm93cy5sZW5ndGgsXG4gICAgICAgICAgICAnRnJvemVuIENvbHVtbjogVHdvIHRhYmxlcyBkb2VzIG5vdCBtdWNoIScpO1xuXG4gICAgICAgIEFycmF5LmZyb20oZnJvemVuUm93cykuZm9yRWFjaCgoZnJvemVuOiBhbnksIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBoID0gTWF0aC5tYXgoZnJvemVuLm9mZnNldEhlaWdodCwgdW5Gcm96ZW5Sb3dzW2luZGV4XS5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgZnJvemVuLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICAgICAgdW5Gcm96ZW5Sb3dzW2luZGV4XS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdEZ1bGxTY3JlZW4oKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmICh0aGlzLmR0Lmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgbGV0IGZyb3plblZpZXcgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWJvZHktZnJvemVuJyk7XG4gICAgICAgICAgICBsZXQgdW5Gcm96ZW5WaWV3ID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LXVuZnJvemVuJyk7XG5cbiAgICAgICAgICAgIGxldCBmcm96ZW5XaWR0aCA9IHRoaXMuY2FsY3VsYXRlRnJvemVuV2lkdGgoKTtcblxuICAgICAgICAgICAgZnJvemVuVmlldy5zdHlsZS53aWR0aCA9IGZyb3plbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodW5Gcm96ZW5WaWV3KSkge1xuICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgYm9yZGVyIGFuZCBjcmVhdGUgaW5kZW50IGVmZmVjdCBieSBoYXZpbmcgMXB4IHdoaXRlIHNwYWNlXG4gICAgICAgICAgICAgICAgdW5Gcm96ZW5WaWV3LnN0eWxlLmxlZnQgPSAoZnJvemVuV2lkdGggKyAyKSArICdweCc7XG4gICAgICAgICAgICAgICAgdW5Gcm96ZW5WaWV3LnN0eWxlLndpZHRoID0gdW5Gcm96ZW5WaWV3LnBhcmVudEVsZW1lbnQub2Zmc2V0V2lkdGhcbiAgICAgICAgICAgICAgICAgICAgLSBmcm96ZW5WaWV3Lm9mZnNldFdpZHRoICsgJ3B4JztcblxuICAgICAgICAgICAgICAgIHRoaXMuYWxpZ25UYWJsZXNIZWlnaHRzKGZyb3plblZpZXcsIHVuRnJvemVuVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5xdWVyeVN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sb2FkaW5nU3ViKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZVTEwgU0NSRUVOIE1PREUgbWV0aG9kc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGZ1bGxzY3JlZW4gZnVuY3Rpb25hbGl0eSBpcyBlbmFibGVkIHRoaXMgbWV0aG9kIHN3aXRjaGVzIGJldHdlZW4gbm9ybWwgYW5kIGZ1bGwgc2NyZWVuXG4gICAgICogbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbFNjcmVlbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsU2NyZWVuTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUZ1bGxTY3JlZW4oZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuRnVsbFNjcmVlbihldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBwdXNoIHRoaXMgY29tcG9uZW50IHRvIGZ1bGwgc2NyZWVuIG1vZGUgb3IgbWF5YmUgZnVsbCBwYWdlIG1vZGUgd2UgbmVlZCBydW4gZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogIC0gRXhlY3V0ZSBleHBhbmQgdHJhbnNmb3JtYXRpb24sIHdoZXJlIHdlIGhhdmUgYWRkaXRpb25hbCBvdmVybGF5IGRpdiB0aGF0IHdlIHNsb3dseSBleHBhbmRcbiAgICAgKiAgYW5kIHRoaXMgY3JlYXRlcyBpbXByZXNzaW9uIHRoZSBEVCBpcyBleHBhbmRpbmdcbiAgICAgKlxuICAgICAqICAtIGFwcGx5IGZ1bGwtc2NyZWVuIGNsYXNzIG9uIHRvcCBob3N0IGVsZW1lbnQgIC0gaW4gdGhpcyBjYXNlIGl0cyBEYXRhVGFibGUgdG8gc3dpdGNoXG4gICAgICogIHRvIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICpcbiAgICAgKiAgLSBtYWtlIHN1cmUgd2UgYXJlIHNjcm9sbGVkIGFsbCB0aGUgd2F5IHVwXG4gICAgICpcbiAgICAgKiAgLSBoaWRlIGFsbCB0aGUgZWxlbWVudHMgb24gdGhlIHBhZ2Ugc28gdGhlaXIgZGltZW5zaW9uIGRvbid0IGludGVyZmVyZSB3aXRoIHRoaXMgdGFibGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW5GdWxsU2NyZWVuKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmlzRnVsbFNjcmVlbk1vZGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMucnVuRXhwYW5kRWZmZWN0KCk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTY3JvbGxQb3NpdGlvbiA9IHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgd2luZG93LnNjcm9sbCgwLCAwKTtcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuT25EVCh0cnVlKTtcblxuXG4gICAgICAgIC8vIG1hcmsgbXkgZWxlbWVudCBpbiB0aGUgcGF0aCB0aGF0IG5lZWRzIHRvIHN0YXlcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLnRhZ05hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgcGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCd1LWZ1bGwtc2NyZWVuLWVsZW1lbnQnKTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG5cbiAgICAgICAgdGhpcy5kdC5zdGF0ZS5saW1pdCA9IE1hdGgucm91bmQodGhpcy5jYWxjdWxhdGVMaW1pdCgpKTtcbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZldGNoKHRoaXMuZHQuc3RhdGUpO1xuXG4gICAgICAgIC8vIG9uY2UgbG9hZGVkIHNldCBiYWNrIGNvcnJlY3QgcGFnZSBzaXplIHdlIHVzZSB3aGVuIGxvYWRpbmcgZGF0YVxuICAgICAgICB0aGlzLmR0LnN0YXRlLmxpbWl0ID0gdGhpcy5kdC5wYWdlU2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoZSBzYW1lIGxpa2UgYWJvdmUgbWV0aG9kIChvcGVuRnVsbFNjcmVlbikgYnV0IGluIHJldmVyc2Ugb3JkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZUZ1bGxTY3JlZW4oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaXNGdWxsU2NyZWVuTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2hvd05vbkZ1bGxTY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIHRoaXMucnVuQ29sbGFwc2VFZmZlY3QoKTtcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuT25EVChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmxpbWl0ID0gdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmRpc3BsYXlMaW1pdDtcbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc2V0IG9mIHNldCBvZiBjc3MgcHJvcGVydGllcyB0byBtYWtlIHRoZSBEVCBtYWluIGNvbXBvbmVudCBvbiB0aGUgcGFnZSBleHBhbmQgdG9cbiAgICAgKiBmdWxsIHBhZ2UgbW9kZSBhbmQgYmFja1xuICAgICAqXG4gICAgICogV2Ugd2FudCB0byBtYWtlIGl0IHdpdGggbGl0dGxlIGRlbGF5IHRvIGxldCBvdGhlciBhbmltYXRpb24gZmluaXNoXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbFNjcmVlbk9uRFQoZnVsbFNjcmVlbjogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuY2xhc3NMaXN0ICs9ICdkdC1mdWxsLXNjcmVlbic7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuY2xhc3NMaXN0ID0gdGhpcy5kdC5jbGFzc0xpc3QucmVwbGFjZSgnZHQtZnVsbC1zY3JlZW4nLFxuICAgICAgICAgICAgICAgICAgICAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBpbmZpbml0ZSBzY3JvbGwgZXZlbnQgYW5kIHJlcXVlc3QgbmV3IGRhdGEgZnJvbSBkYXRhIHNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgb25MYXp5TG9hZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGV2ZW50LmlzTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5kdC5zdGF0ZS5vZmZzZXQgPSBldmVudC5vZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmV0Y2godGhpcy5kdC5zdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGF0YVByb3ZpZGVyID0gdGhpcy5kdC5kYXRhU291cmNlLmRhdGFQcm92aWRlcjtcbiAgICAgICAgICAgIGxldCBkYXRhID0gZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCk7XG4gICAgICAgICAgICBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChkYXRhLnNsaWNlKDAsIGV2ZW50Lm9mZnNldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmltYXRpb24gZWZmZWN0IHRvIG1ha2UgaXQgZmVlbCBsaWtlIHRoZSBlbGVtZW50IChpbiB0aGlzIGNhc2UgRFQpIGlzIGV4cGFuZGluZ1xuICAgICAqIGZyb20gdGhlIG1pZGRsZSB0byB0aGUgZnVsbCBwYWdlIG1vZGUuXG4gICAgICpcbiAgICAgKiBXZSB0YWtlIHRoZSBkaW1lbnNpb24gb2YgdGhlIHRhYmxlIHRoZW4gaXQgaXMgc2NhbGVkIHNsb3dseSB0byB0aGUgZnVsbCBwYWdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5FeHBhbmRFZmZlY3QoKVxuICAgIHtcbiAgICAgICAgdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5leHBhbmRDb2xvckZyb207XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24odHJ1ZSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmV4cGFuZENvbG9yVG87XG4gICAgICAgIH0sIDMwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgdHJhbnNmb3JtYXRpb24gYW5kIHNjYWxlIHRoZSBoZWxwZXIgZGl2IChvdmVybGF5KSBkb3duIHRvIG1ha2UgaXQgbG9vayBsaWtlXG4gICAgICogaXQgY29sbGFwc2VzXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5Db2xsYXBzZUVmZmVjdCgpXG4gICAge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKGZhbHNlKTtcblxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCwgdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3AsIDAsXG4gICAgICAgICAgICAgICAgMCk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogREZTICAtIHRvIGdvIHRocnUgYWxsIHRoZSBlbGVtZW50IHVuZGVyIEJPRFkgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVOb25GdWxsU2NyZWVuRWxlbWVudChwYXJlbnRFbGVtZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGUgPT09IHBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50RWxlbWVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBwYXJlbnRFbGVtZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMubmVlZFRyYXZlcnNlRG93bihlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZU5vbkZ1bGxTY3JlZW5FbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZHQtZnVsbC1zY3JlZW4nKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgndS1mcy1lbGVtZW50LW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHV0IGFsbCB0aGUgZWxlbWVudCB0aGF0IHdlcmUgcHJldmlvdXNseSByZW1vdmVkIGJ5IGhpZGVOb25GdWxsU2NyZWVuRWxlbWVudCgpIGJhY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIHNob3dOb25GdWxsU2NyZWVuRWxlbWVudCgpOiB2b2lkXG4gICAge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy51LWZzLWVsZW1lbnQtb3V0JykpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZWxlbTogYW55KSA9PiBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3UtZnMtZWxlbWVudC1vdXQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG5lZWRUcmF2ZXJzZURvd24oZWxlbWVudDogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChlbGVtZW50KSAmJiBlbGVtZW50LnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygndS1mdWxsLXNjcmVlbi1lbGVtZW50JykgJiZcbiAgICAgICAgICAgICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZHQtZnVsbC1zY3JlZW4nKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZW50ZXIgZnVsbCBzY3JlZW4gL3BhZ2UgbW9kZSB3aGVuIG5lZWQgdG8gY2FsY3VsYXRlIGhvdyBtYW55IHJvd3MgdG8gbG9hZCBpbml0aWFsbHlcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY3VsYXRlTGltaXQoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgYnJvd3NlckggPSB0aGlzLmRvbVV0aWxzLmJyb3dzZXJEaW1lbnRpb25zKCkuaGVpZ2h0O1xuICAgICAgICBsZXQgcm93SCA9IHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keSB0cjpmaXJzdC1jaGlsZCcpLm9mZnNldEhlaWdodDtcblxuICAgICAgICByZXR1cm4gKGlzUHJlc2VudChyb3dIKSAmJiByb3dIID4gMCkgPyAoYnJvd3NlckggLyByb3dIKSArIDIwIDogNTA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUVsZW1lbnQobDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0OiBudW1iZXIgPSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdzogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gbCArICdweCc7XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IHQgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBASW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgYXBwbHlUcmFuc2Zvcm1hdGlvbihleHBhbmQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgeCwgeSwgdHgsIHR5O1xuICAgICAgICBpZiAoZXhwYW5kKSB7XG4gICAgICAgICAgICB4ID0gd2luZG93LmlubmVyV2lkdGggLyB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoO1xuICAgICAgICAgICAgeSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgdHggPSAod2luZG93LmlubmVyV2lkdGggLyAyIC0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCAvIDJcbiAgICAgICAgICAgICAgICAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCkgLyB4O1xuICAgICAgICAgICAgdHkgPSAod2luZG93LmlubmVySGVpZ2h0IC8gMiAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0IC8gMlxuICAgICAgICAgICAgICAgIC0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3ApIC8geTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IDE7XG4gICAgICAgICAgICB5ID0gMTtcbiAgICAgICAgICAgIHR4ID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0O1xuICAgICAgICAgICAgdHkgPSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9XG4gICAgICAgICAgICAnc2NhbGVYKCcgKyB4ICsgJykgc2NhbGVZKCcgKyB5ICsgJykgdHJhbnNsYXRlM2QoJyArICh0eCkgKyAncHgsICcgKyAodHkpICsgJ3B4LCAwcHgpJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIElORklOSVRFIFNDUk9MTElORyBNRVRIT0RTXG4gICAgICovXG5cbiAgICBwcml2YXRlIGluaXRGdWxsU2NyZWVuKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0RnVsbFNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbG9hZGluZyBpcyBmaW5pc2hlZCBtYXJrIGxvYWRpbmcgaWNvbiBpcyBkb25lIHNvIHdlIGNhbiBoaWRlIGl0LiBJIGFtIHVzaW5nIGxpdHRsZVxuICAgICAqIGRlbGF5IHRvIG1ha2UgdGhlIGFuaW1hdGlvbiB2aXNpYmxlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkaW5nRmluaXNoZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmluZmluaXRlU2Nyb2xsKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluZmluaXRlU2Nyb2xsLmNvbXBsZXRlKCksIDIwMCk7XG5cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25Jbml0LCBSZW5kZXJlcjJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIGFuZCBzZXR0aW5nIHRoZSB3aWRlc3QgY29udGVudCB3aWR0aCBvbnRvXG4gKiBDb2x1bW4gY29tcG9uZW50IGFzIHRoZSB3aWRlc3RDZWxsIHByb3BlcnR5LlxuICpcbiAqIFdlIHVzZSB0aGlzIGRpcmVjdGl2ZSBpbnNpZGUgZHQtY29sdW1uLmNvbXBvbmVudCB0byBzdG9yZSBhIGN1cnJlbnQgd2lkdGggZm9yIGVhY2ggdGQsdGhcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tkdE1heFdpZHRoXSdcbn0pXG5leHBvcnQgY2xhc3MgU2V0Q2VsbE1heFdpZHRoRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0XG57XG5cbiAgICBASW5wdXQoKVxuICAgIGR0TWF4V2lkdGg6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdGQ6IERUQ29sdW1uMkNvbXBvbmVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuXG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDZWxsIE1heCBXaWR0aDogJyArIHRoaXMuZHRNYXhXaWR0aCwgdGhpcy5kdE1heFdpZHRoID4gMCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdE1heFdpZHRoKSAmJiB0aGlzLmR0TWF4V2lkdGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5saW5lRGF0YSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1jb2wtY2VsbC1kYXRhJyk7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGlubGluZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgICAgICAgICAgICAgbGV0IGNlbGxXaWR0aCA9IGlubGluZURhdGEub2Zmc2V0V2lkdGg7IC8vIHRkXG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS53aGl0ZVNwYWNlID0gJ25vcm1hbCc7XG4gICAgICAgICAgICAgICAgaW5saW5lRGF0YS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNJblRocmVzSG9sZChjZWxsV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjZWxsV2lkdGggKz0gdGhpcy50ZFBhZGRpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbFdpZHRoID4gdGhpcy50ZC53aWR0aFB4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsV2lkdGggPCB0aGlzLmR0TWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbCA9IGNlbGxXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbCA/IGNlbGxXaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbFdpZHRoID49IHRoaXMuZHRNYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsID0gKHRoaXMuZHRNYXhXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuZHRNYXhXaWR0aCA6IHRoaXMudGQud2lkZXN0Q2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgdGhlIG5ldyB3aWR0aCB0aGUgc2FtZSBhcyB0aGUgb25lIGFscmVhZHkgc2V0IG9uIHRoZSBjb2x1bW4/IElmIHllcyB0aGVuIHByb2JhYmx5XG4gICAgICogbmV3IGNvbnRlbnQgZG9lcyBub3QgZGlmZmVyIHRoYXQgbXVjaC4gV2Ugc3RpbGwga2VlcCBjZXJ0YWluIHRocmVzaG9sZCBhcyB0aGUgbmV3IGNvbnRlbnRcbiAgICAgKiB3aWR0aCBtaWdodCBkaWZmZXIgMSBvciAyIHBpeGVzIGRlcGVuZGluZyBob3cgc2V0IHRoZSBjc3MuXG4gICAgICpcbiAgICAgKiBUbyBtYWtlIHN1cmUgd2UgcmVzaXplIGNvbHVtbiBvbmx5IGlmIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IGNvdWxkIGJlIG9yaWdpbmFsIHNpemVcbiAgICAgKiBpcyA0MDBweCBidXQgdGhlIG5ldyBvbmUgaXMgNDAxcHggc2luY2Ugc29tZXdoZXJlIGFkZCBzb21lIGV4dHJhIGJvcmRlciB3ZSBoYXZlIHRoaXNcbiAgICAgKiBzYWZlIHRocmVzaG9sZFxuICAgICAqXG4gICAgICovXG4gICAgaXNJblRocmVzSG9sZChuZXdXaWR0aDogbnVtYmVyKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudGQud2lkZXN0Q2VsbCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnRkLndpZGVzdENlbGwgLSBuZXdXaWR0aCkgPiAzICYmIG5ld1dpZHRoID4gdGhpcy50ZC53aWRlc3RDZWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSB0ZFBhZGRpbmcoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBsZXQgY2VsbCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuXG4gICAgICAgIC8vIHBsdXMgZ2l2ZSBpdCBzb21lIGxpdHRsZSBzcGFjZSBhcm91bmQgdGhlIHRleHQgc28gaXQgbm90cyBweCB0byBweCBpbm5lciB3aWR0aCBvZiB0aGUgdGRcbiAgICAgICAgLy8gY3V6IGl0IGNvdWxkIHdyYXBcbiAgICAgICAgY2VsbCArPSA1O1xuXG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5pbXBvcnQge1xuICAgIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksXG4gICAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi4vLi4vLi4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RyYWdEaXJlY3Rpb24sIERyYWdFdmVudHMsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqIERpcmVjdGl2ZSB1c2VkIGluc2lkZSBEVCBpbiBvcmRlciB0byBzdXBwb3J0IHRhYmxlIHJvd3MgcmUtb3JkZXJpbmcuIFRoaXMgbWFuYWdlcyBhbGwgdGhlXG4gKiBEJkQgbmVjZXNzYXJ5IGxvZ2ljIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogW2R0RHJhZ2dhYmxlUm93XSBpcyB1c2VkIGluc2lkZSB0aGUgYHJvd1RlbXBsYXRlYCBsaWtlIHRoaXM6XG4gKlxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiA8bmctdGVtcGxhdGUgI3Jvd1RlbXBsYXRlIGxldC1yb3dEYXRhIGxldC1ldmVuPSdldmVudFwiIGxldC1vZGQ9XCJvZGRcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiXG4gKiAgICAgICAgICAgICAgbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1jb2xzVG9SZW5kZXI9XCJjb2xzVG9SZW5kZXJcIj5cbiAqXG4gKiAgICAgPHRyICNyb3dFbGVtZW50IGR0RHJhZ2dhYmxlUm93IFtkbmRSb3dJbmRleF09XCJyb3dJbmRleFwiXG4gKiAgICAgICAgICBjbGFzcz1cImR0LWJvZHktcm93XCJcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIHdoaWNoIGVuYWJsZWQgb3IgZGlzYWJsZXMgYmFzZWQgb24gdGhlIHVzZWQgRFQgYmluZGluZyBbZG5kUm93RW5hYmxlZF0uIEJ5IGRlZmF1bHQgaXRzIGRpc2FibGVkLlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tkdERyYWdnYWJsZVJvd10nXG59KVxuZXhwb3J0IGNsYXNzIERURHJhZ2dhYmxlUm93RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3lcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgdGhlIGRpcmVjdGl2ZSBpZiB3ZSBlbmFibGUgbWlkZGxlIHJvdyB6b25lIHRvIGNyZWF0ZSBhbiBlZmZlY3QgdGhhdCB3ZSBhcmUgZHJvcHBpbmdcbiAgICAgKiBpbnRvIHRoZSByb3cuIFVzZWQgZm9yIG91dGxpbmUgRFQgbWFpbmx5LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkcm9wSW50b0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgVFIgaW5kZXggbnVtYmVyXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRuZFJvd0luZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgb3VyIGRyYWdnaW5nIGRpcmVjdGlvbiBVUCBhbmQgRE9XTiBpbiBvcmRlciB0byBhc3NpZ24gY29ycmVjdCBzdHlsZVxuICAgICAqIHRoYXQgaGlnaGxpZ2h0cyB0aGUgcm93IGF0IHRoZSB0b3Agb3IgYm90dG9tXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRyYWdEaXI6IERyYWdEaXJlY3Rpb24gPSBEcmFnRGlyZWN0aW9uLk5vbmU7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCB3ZSBkcmFnZ2VkIG91ciByb3cgYW5kIHN0b3BwZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgb3RoZXIgcm93XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluTWlkZGxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEN1cnJlbnQgZHJhZyBZIGNvb3JkaW5hdGVzIHdoaWNoIGlzIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgZHJhZ0RpciB3aGVuIGFzc2luZ2luZyBkcmFnZ2luZ1xuICAgICAqIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHJhZ1k6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBsaXN0ZW5lcnMgaGFuZGxlcnMgaGVyZSAtIHRoZSByZXR1cm4gZnJvbSAuYmluZCh0aGlzKS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGV2ZW50SGFuZGxlcnM6IHsgW25hbWU6IHN0cmluZ106IGFueSB9O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBEYXRhdGFibGUyQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcml2YXRlIGR0OiBEYXRhdGFibGUyQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZG9tVXRpbHM6IERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lKVxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmR0LmRuZFJvd0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5kbmRSb3dFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0dXBzIGxpc3RlbmVycyBhbmQgcmV0dXJucyBoYW5kbGUgdG8gdGhlbSBzbyB3ZSBjYW4gbGF0ZXIgb24gdW5zdWJzY3JpYmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydtb3VzZWRvd24nXSA9IHRoaXMub25Nb3VzZURvd25FdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ21vdXNlZG93biddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnc3RhcnQnXSA9IHRoaXMub25EcmFnU3RhcnRFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdzdGFydCddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnb3ZlciddID0gdGhpcy5vbkRyYWdPdmVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdvdmVyJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdsZWF2ZSddID0gdGhpcy5vbkRyYWdMZWF2ZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2xlYXZlJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2Ryb3AnXSA9IHRoaXMub25Ecm9wRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJvcCddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnZW5kJ10gPSB0aGlzLm9uRHJhZ0VuZEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdlbmQnXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBjcmVhdGVkIGxpc3RlbmVycyBpbnNpZGUgZGVzdHJveSgpIGNhbGxiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWxlYXNlRXZlbnRMaXN0ZW5lcnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgRHJhZ0V2ZW50cy5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ25hbWUnLCB0aGlzLmV2ZW50SGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBpcyBmaXJzdCBldmVudCB3aGVyZSB3ZTpcbiAgICAgKlxuICAgICAqICAtIE1hcmsgZWxlbWVudCBkcmFnZ2FibGUgdG8gZW5hYmxlIEQmRFxuICAgICAqICAtIFNldCBjbGljayBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgbWlkZGxlIG9mIHRoZSBjdXJyZW50IHJvd1xuICAgICAqICAgICAgVGhpcyBpcyBtYWlubHkgbmVlZGVkIHdoZW4gd2UgYXJlIHRyeWluZyB0byBjYWxjdWxhdGUgc29tZXRoaW5nIGZvclxuICAgICAqICAgICAgZHJvcEludG8gcm93IChvdXRsaW5lKVxuICAgICAqXG4gICAgICogZXZlbnQudGFyZ2V0IHVzdWFsbHkgY29udGFpbnMgcmVmZXJlbmNlIHRvIFREIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uTW91c2VEb3duRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChldmVudC5hbHRLZXkgJiYgdGhpcy5kb21VdGlscy5oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCAnLmR0LXJvdy1kcmFnZ2FibGUnKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBlbFRvQmVEcmFnZ2VkID0gdGhpcy5kb21VdGlscy5lbGVtZW50RGltZW5zaW9ucyhldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5kdC5lbnYuc2V0VmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScsIChlbFRvQmVEcmFnZ2VkLmhlaWdodCAvIDIpIC0gZXZlbnQub2Zmc2V0WSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNlY29uZCB0cmlnZ2VyZWQgZXZlbnQgd2hlbiB0aGUgYWN0dWFsIGRyYWdnaW5nIHN0YXJ0cy4gSGVyZSB3ZSBuZWVkIHRvIGRpc2FibGVcbiAgICAgKiBkcmFnZ2VkIHJvdyBhbmQgc2F2ZSBpbmZvcm1hdGlvbiB0aGF0IGFyZSBjb21tb24gdG8gYSB0YWJsZS5cbiAgICAgKlxuICAgICAqIE1hcmtpbmcgcm93IGRpc2FibGVkIHdpdGggdGhlIHN0eWxlIC5kdC1yb3ctZHJhZ2dpbmcgdXNpbmcgc2V0VGltZW91dCBpcyBuZWVkZWQgYXNcbiAgICAgKiBpZiB3ZSB3b3VsZCBnbyB3aXRob3V0IGl0IHRoZW4gRCZEIGZyYW1ld29yayB3b3VsZCBjcmVhdGUgYSBjb3B5IG9mIHJvdyBpbiBkaXNhYmxlZCBzdGF0ZS5cbiAgICAgKiBOb3cgd2UgZ3JhYiBhIHJvdyB3aXRoIGFjdGl2ZSBzdGF0ZSBhbmQgYWZ0ZXIgYSAyMDBtcyBkZWxheSB3ZSBkaXNhYmxlIHRoZSBvcmlnaW5hbCByb3cuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ1N0YXJ0RXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChldmVudC50YXJnZXQuY2xhc3NMaXN0KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdkdC1yb3ctZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcblxuICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnaXNEcmFnZ2luZycsIHRydWUpO1xuICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnZG5kSWQnLCB0aGlzLmRuZFJvd0luZGV4KTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCB0aGlzLmRuZFJvd0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZXZlbnRzIGhhcHBlbnMgYW55dGltZSBhcyB3ZSBkcmFnIG92ZXIgcm93cy4gVGhpcyBldmVudCB0cmlnZ2VyZWQgYWZ0ZXIgY2VydGFpblxuICAgICAqIGRlbGF5LiBJbiBoZXJlIHdlIGNhbGN1bGF0ZSB0aGUgbW91c2UgbW92ZW1lbnQgdG8gaWRlbnRpZnkgaWYgd2UgYXJlIGdvaW5nIFVQIG9yIERPV04uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG1haW5seSBuZWVkZWQgdG8gbWFyayBhIHJvdyB3aXRoIHRoZSBjb3JyZWN0IGxpbmUgb24gVE9QIG9yIEJPVFRPTSB0byB2aXN1YWxseVxuICAgICAqIHNob3cgYSB1c2VyIHdoZXJlIHdlIGFyZS5cbiAgICAgKlxuICAgICAqIE9uY2Ugd2Uga25vdyB0aGUgZGlyZWN0aW9uIGFuZCB0aGUgZHJvcCB0YXJnZXQgaXMgdmFsaWQgd2UgbWFyayB0aGUgcm93IHdpdGggY29ycmVjdCBjbGFzc1xuICAgICAqIHRoYXQgZG9lcyB0aGUgdHJpY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ092ZXJFdmVudChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gICAgICAgIGlmICh0aGlzLmRyYWdZIDwgZXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uRG93bjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdZID4gZXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uVXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBzZXQgYWdhaW4gdW5sZXNzIGl0cyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1kgIT09IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRHJvcFRhcmdldChldmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gdGVzdCB0aGlzIHByZXZlbnREZWZhdWx0KCkgc28gaXQgZG9lcyBub3QgY3JlYXRlIHNvbWUgc2lkZWVmZmVjdFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubWFya1Jvd1dpdGhDbGFzcyhldmVudCwgdGhpcy5kb21VdGlscy5jbG9zZXN0KGV2ZW50LnRhcmdldCwgJ3RyJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBmaW5pc2hpbmcgZXZlbnQganVzdCBiZWZvcmUgRCZEIGlzIGRvbmUuIEl0IHRha2VzIGN1cnJlbnQgaW5mb3JtYXRpb24gYW5kXG4gICAgICogYnJvYWRjYXN0IHRoZW0gdG8gdGhlIERUIHNvIERUIGNhbiBkbyBuZWNlc3Nhcnkgcm93IHJlb3JkZXJpbmdcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyb3BFdmVudChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5jbGVhckNsYXNzZXMoZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQpO1xuICAgICAgICAvLyBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCBvcmlnSW5keCA9IHRoaXMuZHQuZW52LmdldFZhbHVlKCdkbmRJZCcpO1xuICAgICAgICBsZXQgZHJvcFBvczogRHJvcFBvc2l0aW9uID0gdGhpcy5pbk1pZGRsZSA/IERyb3BQb3NpdGlvbi5JbnRvIDogKFxuICAgICAgICAgICAgdGhpcy5kcmFnRGlyID09PSBEcmFnRGlyZWN0aW9uLlVwID8gRHJvcFBvc2l0aW9uLkJlZm9yZSA6IERyb3BQb3NpdGlvbi5BZnRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLmR0Lm9uRG5EUm93RHJvcChvcmlnSW5keCwgdGhpcy5kbmRSb3dJbmRleCwgZHJvcFBvcyk7XG5cbiAgICAgICAgdGhpcy5pbk1pZGRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdZID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSB0aW1lIHdlIGRyYWcgb3ZlciB0aGUgZWxlbWVudCB3ZSBhcHBseSBzb21lIGNsYXNzZXMgdG8gdGhlIGl0LiB0aGlzIG1ldGhvZCBkb2VzIHRoZVxuICAgICAqIG9wcG9zaXRlIHdoaWNoIGlzIHRvIHJlbW92ZSBldmVyeXRoaW5nIHNvIHdlIGFyZSByZWFkeSBmb3IgdGhlIG5leHQgcm93XG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnTGVhdmVFdmVudChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHRyID0gdGhpcy5kb21VdGlscy5jbG9zZXN0KGV2ZW50LnRhcmdldCwgJ3RyJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKHRyKTtcblxuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnZG5kT25Ib2xkSW5kZXgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbGFzdCBldmVudCB3aXRoaW4gRCZEIGZsb3cuIE1haW5seSB1c2VkIHRvIGNsZWFuIHVwIGFsbCB0aGUgcmVzb3VyY2UgdGhhdCBoYXMgbm90XG4gICAgICogYmVlbiBjbGVhbiB1cCBhbHJlYWR5IGluc2lkZSBvbkRyb3BFdmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnRW5kRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdkdC1yb3ctZHJhZ2dpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnaXNEcmFnZ2luZycpO1xuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIENTUyBjbGFzc2VzIHRvIHRoZSByb3cgdG8gY3JlYXRlIGFuIGhpZ2hsaWdodGluZyBlZmZlY3QgdG8gY2FwdHVyZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICogZm9yIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQmFzZWQgb24gdGhlIERyYWcgZGlyZWN0aW9uIHdlIGVpdGhlciBhcHBseVxuICAgICAqIGNzcyBjbGFzcyB0aGF0IGNyZWF0ZXMgYSBsaW5lIG9uIHRvcCBvciBib3R0b20uICBPbmx5IGZvciB0aGUgZHJvcEludG8gZnVuY3Rpb25hbGl0eSB3ZVxuICAgICAqIG5lZWQgdG8gY2FsY3VsYXRlIHNvbWUgbW9yZSB0byBpZGVudGlmeSBpZiB3ZSBhcmUgcmVhbGx5IGluIHRoZSBtaWRkbGUgb2YgdGhlIHJvdy5cbiAgICAgKlxuICAgICAqIERyb3BJbnRvOlxuICAgICAqIC0tLS0tLS0tLVxuICAgICAqXG4gICAgICogSW5pdGlhbGx5IHdlIGNhcHR1cmVkIGEgcG9zaXRpb24gKGluIG1vdXNlZG93bikgdGhlIGRpc3RhbmNlIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHJvdyBhbmRcbiAgICAgKiB0aGlzIHdlIGFyZSB1c2luZyBoZXJlIHdpdGggc29tZSB0aHJlc2hvbGQgb2YgMiBwaXhlcyBzbyB3ZSBkb250IGhhdmUgdG8gYmUgZXhhY3RseSBvbiBwaXhlbFxuICAgICAqIHBlcmZlY3QuXG4gICAgICpcbiAgICAgKiAtIGxldCBjdXJyZW50VHJDZW50ZXIgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGFjdGl2ZVJvdykuaGVpZ2h0IC8gMjtcbiAgICAgKiAgICAgIFJlYWQgY2VudGVyIG9mIGN1cnJlbnQgcm93XG4gICAgICpcbiAgICAgKiAtIGxldCBkcmFnZ2VkVHJDZW50ZXIgPSBldmVudC5vZmZzZXRZICsgdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuICAgICAqICAgICAgUmVhZCBtb3VzZSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjdXJyZW50IHJvdy90ZCBhbmQgYWRkIHRvIGl0IG91ciBkZXZpYXRpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgbWFya1Jvd1dpdGhDbGFzcyhldmVudDogYW55LCBhY3RpdmVSb3c6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgdGhpcy5jbGVhckNsYXNzZXMoYWN0aXZlUm93KTtcblxuICAgICAgICAvLyBDaGVjayBpZiBkcmFnIGl0ZW0gaXMgaW4gdGhlIG1pZGRsZSBvZiBvdGhlciByb3dcbiAgICAgICAgbGV0IGN1cnJlbnRUckNlbnRlciA9IHRoaXMuZG9tVXRpbHMuZWxlbWVudERpbWVuc2lvbnMoYWN0aXZlUm93KS5oZWlnaHQgLyAyO1xuICAgICAgICBsZXQgZHJhZ2dlZFRyQ2VudGVyID0gZXZlbnQub2Zmc2V0WSArIHRoaXMuZHQuZW52LmdldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcblxuICAgICAgICBpZiAodGhpcy5kcm9wSW50b0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5NaWRkbGUgPSBNYXRoLmFicyhjdXJyZW50VHJDZW50ZXIgLSBkcmFnZ2VkVHJDZW50ZXIpIDwgMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmluTWlkZGxlKSB7XG4gICAgICAgICAgICBhY3RpdmVSb3cuY2xhc3NMaXN0LmFkZChEcmFnRGlyZWN0aW9uLk1pZGRsZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjdGl2ZVJvdy5jbGFzc0xpc3QuYWRkKHRoaXMuZHJhZ0Rpcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERyb3AgdGFyZ2V0IG11c3QgYmUgb25seSBhbm90aGVyIFRSIGFuZCBpdCBjYW5ub3QgYmUgdGhlIGVsZW1lbnQgaXRzZWxmIHRoZSBvbmUgd2UgYXJlXG4gICAgICogZHJhZ2dpbmcgYW5kIGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gYWxsb3cgdG8gZHJvcCB0byB0aGUgc2FtZSBwb3NpdGlvbiB3ZSBzdGFydGVkIGZyb21cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXNWYWxpZERyb3BUYXJnZXQoZXZlbnQ6IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBvcmlnSW54ID0gdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIGxldCBzaWJsaW5nUm93ID0gdGhpcy5kbmRSb3dJbmRleCAtIG9yaWdJbng7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdUUicgJiYgdGhpcy5kbmRSb3dJbmRleCAhPT0gb3JpZ0lueCAmJlxuICAgICAgICAgICAgIShzaWJsaW5nUm93ID09PSAxICYmIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5VcCkgJiZcbiAgICAgICAgICAgICEoc2libGluZ1JvdyA9PT0gLTEgJiYgdGhpcy5kcmFnRGlyID09PSBEcmFnRGlyZWN0aW9uLkRvd24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2xlYXJDbGFzc2VzKHRyOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0ci5jbGFzc0xpc3QucmVtb3ZlKCdkdC1kcmFnLXJvdy10b3AnKTtcbiAgICAgICAgdHIuY2xhc3NMaXN0LnJlbW92ZSgnZHQtZHJhZy1yb3ctYm90dG9tJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5yZW1vdmUoJ2R0LWRyYWctcm93LWJvdGgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgcHJpdmF0ZVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnRGlyVG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhZ0Rpcikge1xuICAgICAgICAgICAgY2FzZSBEcmFnRGlyZWN0aW9uLlVwOlxuICAgICAgICAgICAgICAgIHJldHVybiAnVXAnO1xuICAgICAgICAgICAgY2FzZSBEcmFnRGlyZWN0aW9uLkRvd246XG4gICAgICAgICAgICAgICAgcmV0dXJuICdEb3duJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOb3QgU3VyZSc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0FXT3V0bGluZUZvck1vZHVsZX0gZnJvbSAnLi4vb3V0bGluZS9vdXRsaW5lLWZvci5tb2R1bGUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RFRXcmFwcGVyfSBmcm9tICcuL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0lucHV0RmllbGRNb2R1bGV9IGZyb20gJy4uL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLm1vZHVsZSc7XG5pbXBvcnQge0RUSGVhZGVyQ29tcG9uZW50Mn0gZnJvbSAnLi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RURGV0YWlsUm93Q29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93L2R0LWRldGFpbC1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuLi9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7XG4gICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vc2luZ2xlLXNlbGVjdC9kdC1zaW5nbGUtc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge1NldENlbGxNYXhXaWR0aERpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL2R0LWNlbGwtZGlyZWN0aXZlcyc7XG5pbXBvcnQge0RURHJhZ2dhYmxlUm93RGlyZWN0aXZlfSBmcm9tICcuL2RpcmVjdGl2ZXMvZHQtZHJhZ2dhYmxlLXJvdy5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERhdGF0YWJsZTJDb21wb25lbnQsXG4gICAgICAgIERUV3JhcHBlcixcbiAgICAgICAgRFRDb2x1bW4yQ29tcG9uZW50LFxuICAgICAgICBEVEhlYWRlckNvbXBvbmVudDIsXG4gICAgICAgIERURGV0YWlsUm93Q29tcG9uZW50LFxuICAgICAgICBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50LFxuICAgICAgICBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFREcmFnZ2FibGVSb3dEaXJlY3RpdmUsXG4gICAgICAgIFNldENlbGxNYXhXaWR0aERpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdJbnB1dEZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCxcbiAgICAgICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRGF0YXRhYmxlMkNvbXBvbmVudCxcbiAgICAgICAgRFRDb2x1bW4yQ29tcG9uZW50LFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIERUSGVhZGVyQ29tcG9uZW50MixcbiAgICAgICAgRFREZXRhaWxSb3dDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEYXRhdGFibGUyTW9kdWxlXG57XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBjb25maXJtYXRpb24gaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBDb25maXJtYXRpb25Db21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbi1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGNvbmZpcm1hdGlvbiBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIENvbmZpcm1hdGlvbkNvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY29uZmlybWF0aW9uLWZvb3RlcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnRcbntcbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TW9kYWxDb250YWluZXJ9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXInO1xuaW1wb3J0IHtDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLWZvb3Rlci5jb21wb25lbnQnO1xuXG4vKipcbiAqIENvbmZpcm1hdGlvbiBDb21wb25lbnQgaXMgYSBzcGVjaWZpYyB2ZXJzaW9uIG9mIHRoZSBkaWFsb2cgd2hlcmUgaXQgc3VwcG9ydHMgY29uZmlybSBhbmQgY2FuY2VsXG4gKiBmdW5jdGlvbmFsaXR5LiBJdCBiZWhhdmVzIGxpa2UgYSBkaWFsb2csIGlzIG1vZGFsLCBhbmQgbm90IGNsb3NhYmxlIGJ5IGRlZmF1bHQuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxDb25maXJtYXRpb25Db21wb25lbnQ+KSwgc2VydmljZS5jbG9zZSgpXG4gKlxuICogVXNhZ2U6XG4gKiAgICAxLiAgVXNpbmcgTW9kYWxTZXJ2aWNlIGRpcmVjdGx5IHRvIGRpc3BsYXkgYSBtb2RhbCBwb3B1cC4gVGhpcyB1c2FnZSBpcyBhIHF1aWNrIHdheSB0byBzaG93XG4gKiAgICAgICAgYSBjb25maXJtYXRpb24gdG8gdGhlIHVzZXIuXG4gKlxuICogICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxDb25maXJtYXRpb25Db21wb25lbnQ+KENvbmZpcm1hdGlvbkNvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NvbmZpcm1hdGlvbicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGAgQXJlIHlvdSBzdXJlID8gYCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDMwMCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgb25Db25maXJtOiAoKSA9PiB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbigpO1xuICogICAgICAgICAgICAgICAgICAgICAgICB9LFxuICogICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogKCkgPT4ge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbigpO1xuICogICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctY29uZmlybWF0aW9uIFt0aXRsZV09XCInQ29uZmlybWF0aW9uJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyh2aXNpYmxlKV09XCJkaXNwbGF5XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNvbmZpcm0pPVwiY29uZmlybUFjdGlvbigpXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uQ2FuY2VsKT1cImNhbmNlbEFjdGlvbigpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwic2FwLWljb24gaWNvbi1hbGVydFwiPjwvaT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB5b3VyIGhhcmQgZHJpdmU/XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWNvbmZpcm1hdGlvbj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm9wZW4oKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGVuIENvbmZpcm1hdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogYm9vbGVhbiA9IGZhbHNlO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uZmlybUFjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uZmlybUFjdGlvbigpICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbiA9IFwiY29uZmlybWVkXCI7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSBmYWxzZTtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxBY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uID0gXCJjYW5jZWxlZFwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgIH1cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6ICdjb25maXJtYXRpb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydjb25maXJtYXRpb24uY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Db21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lclxue1xuICAgIC8qKlxuICAgICAqIFRpdGxlIGZvciB0aGUgRGlhbG9nLiAgaWYgdGl0bGUgYW5kICdUaXRsZVRlbXBsYXRlJyBhcmUgYm90aCBzZXQsIHRpdGxlVGVtcGxhdGUgdGFrZXNcbiAgICAgKiBwcmVjZWRlbmNlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEJvZHkgc2VjdGlvbiBmb3IgRGlhbG9nLiBDYWxsZXIgc2hvdWxkIHVzZSBlaXRoZXIgdGhlIGJvZHkgc3RyaW5nLCBvciBjb250ZW50IHByb2plY3Rpb25cbiAgICAgKiB0byBhZGQgdmFsdWVzIHRvIHRoZSBkaWFsb2cuIElmIGJvdGggYXJlIHVzZWQsIHRoZXkgd2lsbCBib3RoIHNob3cgdXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBPSyBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbmZpcm1BY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gQ2FuY2VsIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2FuY2VsQWN0aW9uTGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc3VwcG9ydCB0d28gd2F5IGRhdGEgYmluZGluZyBvbiB2aXNpYmxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSdzIGFuIHggYXQgdGhlIHRvcCByaWdodCB0aGF0IG1ha2VzIHRoZSBkaWFsb2cgY2xvc2FibGUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjbG9zYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaWFsb2cuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGRpYWxvZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHVzZXIgY2xpY2tlZCBvbiBjb25maXJtIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNvbmZpcm06IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB1c2VyIGNsaWNrZWQgb24gY2FuY2VsIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNhbmNlbDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgY29tcG9uZW50LiBVc3VhbGx5IGNvbnRhaW5zIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCkgaGVhZGVyOiBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgZm9vdGVyLiBVc3VhbGx5IGNvbnRhaW5zIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudCkgZm9vdGVyOiBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gNDAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgLy8gVG9kbzogaW50ZXJuYXRpb25hbGl6ZS5cbiAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uTGFiZWwgPSAnQ29uZmlybSc7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uTGFiZWwgPSAnQ2FuY2VsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvcGVuIGNvbmZpcm1hdGlvbi5cbiAgICAgKi9cbiAgICBvcGVuKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcblxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSBjb25maXJtYXRpb24uXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG5cbiAgICAgICAgLy8gSW1wb3J0YW50IHRvIG1ha2Ugc3VyZSBjaGFuZ2UgaXMgc2V0IG9uIHBhcmVudCBiaW5kaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YXJpYWJsZSBhbmQgZGlhbG9nIG9wZW4vY2xvc2Ugc3RhdGUgY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBzeW5jIGFuZCB3ZSB3b3VsZG4ndCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBjb25maXJtYXRpb24gaGF2ZSBoZWFkZXIgY29udGVudD9cbiAgICAgKi9cbiAgICBoYXNIZWFkZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmhlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgY29uZmlybWF0aW9uIGhhdmUgZm9vdGVyIGNvbnRlbnQ/XG4gICAgICovXG4gICAgaGFzRm9vdGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5mb290ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpcm0gYWN0aW9uLlxuICAgICAqL1xuICAgIGNvbmZpcm0oKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ29uZmlybS5lbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFjdGlvbi5cbiAgICAgKi9cbiAgICBjYW5jZWwoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ2FuY2VsLmVtaXQoKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50JztcbmltcG9ydCB7TW9kYWxDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC9tb2RhbC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RpYWxvZ01vZHVsZX0gZnJvbSAnLi4vZGlhbG9nL2RpYWxvZy5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ29uZmlybWF0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIENvbnRhaW5lciBwYW5lbCBwcm92aWRpbmcgc2Nyb2xsaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIGl0cyBjaGlsZHJlbi4gWW91IGNhbiBjb25maWd1cmUgdGhpc1xuICogY29udGFpbmVyIHRvIGxldCBpdCB0byBzY3JvbGwgaXRzIGNvbnRlbnQgZWl0aGVyIGhvcml6b250YWxseSwgdmVydGljYWxseSBvciBsZXQgdGhlIGNvbnRlbnRcbiAqIHdyYXAuXG4gKlxuICpcbiAqIFVzYWdlIGlzIHByZXR0eSBzaW1wbGU6XG4gKlxuICogICMjIyBFeGFtcGxlIHVzaW5nIGhvcml6b250YWwgc2Nyb2xsIChkZWZhdWx0IGJlaGF2aW9yKTpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAyPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDM8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNDwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA1PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDY8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA4PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDk8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgIDwvYXctc2Nyb2xsYWJsZT5cbiAqXG4gKiAgYGBgXG4gKlxuICogICMjIyBFeGFtcGxlIHVzaW5nIHZlcnRpY2FsIHNjcm9sbDpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlIFtkaXJlY3Rpb25dPVwiJ3ZlcnRpY2FsJ1wiIFtoZWlnaHRdPVwiJzQwdmgnXCI+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAxPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDI8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA0PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDU8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA3PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDg8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgOTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgPC9hdy1zY3JvbGxhYmxlPlxuICpcbiAqIGBgYFxuICpcbiAqICAjIyMgRXhhbXBsZSBzY3JvbGxpbmcgaXMgZGlzYWJsZWQgYW5kIGNvbnRlbnQgd3JhcHMgYW5kIGNlbnRlcnM6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZSBbZGlyZWN0aW9uXT1cIidub25lJ1wiIFthbGlnbm1lbnRdPVwiJ2NlbnRlcidcIj5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDE8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAzPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDQ8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA2PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDc8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgODwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA5PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICA8L2F3LXNjcm9sbGFibGU+XG4gKiAgYGBgXG4gKlxuICogIyMjIEhlaWdodCBwcm9wZXJ0eTpcbiAqXG4gKiBXaGVuIHVzaW5nIFwiaG9yaXpvbnRhbCBzY3JvbGxpbmdcIiBpdCBzZXQgXCJmbGV4Ym94LWRpcmVjdGlvblwiIHRvIFwicm93XCIgd2hlcmUgaGVpZ2h0XG4gKiBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgY29udGVudC4gVGhlIGhlaWdodCBzaG91bGQgYmUgYWx3YXlzIDEwMCUgd2hlbiB1c2luZ1xuICogdGhpcyBpbiBwYXJlbnQgY29udGFpbmVyLlxuICpcbiAqIElmIFwidmVydGljYWwgc2Nyb2xsaW5nXCIgaXMgdXNlZCB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdDpcbiAqICAgLSB5b3VyIHBhcmVudCBjb250YWluZXIgc2V0cyB0aGUgYm91bmRhcmllcyB3aXRoIGNvcnJlY3RseSBzZXQgd2lkdGggYW5kIGhlaWdodFxuICogICBvdGhlcndpc2UgaXQgd2lsbCB1c2UgMTAwJSBvZiB0aGUgdmlld3BvcnRcbiAqICAgLSBpZiB1c2VkIGFzIHN0YW5kYWxvbmUgeW91IG5lZWQgdG8gbGltaXQgdGhlIGhlaWdodCBvdGhlcndpc2UgaXQgd2lsbCBleHBhbmQgdG8gMTAwJSBvZlxuICogICB0aGUgZG9jdW1lbnRcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2Nyb2xsYWJsZScsXG4gICAgdGVtcGxhdGVVcmw6ICdzY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJ3Njcm9sbGFibGUtY29udGFpbmVyLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBzY3JvbGxpbmcgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluZXIgbWVhbmluZyB0ZWxscyB3aGljaCBvdmVyZmxvdyBheGllcyB3aWxsIGJlXG4gICAgICogZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgXCJob3Jpem9udGFsXCI6IEhlcmUgd2UgbG9jayBvdmVyZmxvdy15IGFuZCBvdmVyZmxvdy14IHNldCB0byBhdXRvLlxuICAgICAqXG4gICAgICogV2hlbiBzY3JvbGxpbmcgZGlyZWN0aW9uIGlzIFwidmVydGljYWxcIiBwbGVhc2UgbWFrZSBzdXJlIHlvdSBtYWludGFpbiBjb3JyZWN0IGhlaWdodCBhbmRcbiAgICAgKiB3aWR0aC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlyZWN0aW9uOiBTY3JvbGxpbmdEaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCc7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyBmbGV4Ym94IGNvbnRhaW5lciBpdGVtcyBzaG91bGQgYmUgYWxpZ25lZC4gRGVmYXVsdCBiZWhhdmlvciBpcyBMRUZUXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsaWdubWVudDogQ29udGFpbmVySXRlbXNBbGlnbm1lbnQgPSAnbGVmdCc7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHByb3BlcnRpZXMgZm9yIGNhbGN1bGF0ZWQgY2xhc3MgbGlzdFxuICAgICAqL1xuXG4gICAgbGF5b3V0Q2xhc3M6IHN0cmluZztcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy53aWR0aCA9ICcxMDAlJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmluaXREZWZhdWx0KCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgd2UgcmUtaW5pdGlhbGl6ZSBkZWZhdWx0IHdoZW4gSW5wdXQgQmluZGluZ3MgY2hhbmdlc1xuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdERlZmF1bHQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGVmYXVsdCB2YWx1ZXMgYW5kIENhbGN1bGF0ZXMgbGF5b3V0IGFuZCBhbGlnbm1lbnQgY2xhc3MuIFRoZSByZWFzb24gZm9yIHVzaW5nXG4gICAgICogdGhlc2UgdXRpbGl0eSBjbGFzc2VzIGlzIHRoYXQgd2UgY2FuIGNoYW5nZSB0aGUgYmVoYXZpb3IgYW55dGltZSBhcyBjb21wYXJlZCB0byB1c2luZ1xuICAgICAqIGRpcmVjdGx5IFtzdHlsZS54eHhdIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICogIyMjIERpcmVjdGlvbiBmbG93IGNsYXNzOlxuICAgICAqICAtIHUtc2Nyb2xsYWJsZS1mPGRpcmVjdGlvbj5cbiAgICAgKlxuICAgICAqICMjIyBBbGlnbm1lbnQgY2xhc3M6XG4gICAgICogIC0gdS1zY3JvbGxhYmxlLWE8YWxpZ25tZW50PlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0RGVmYXVsdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1maCc7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZnYnO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwtcm93Jykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZnYtcm93JztcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZiJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgKz0gJyB1LXNjcm9sbGFibGUtYScgKyB0aGlzLmFsaWdubWVudC5zdWJzdHJpbmcoMCwgMSk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0eWxlQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzICs9IGAgJHt0aGlzLnN0eWxlQ2xhc3N9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkZWZhdWx0IHdpZHRoIGFuZCBoZWlnaHQgdG8gc29tZSB2YWx1ZSBpbiBjYXNlIHNvbWVib2R5IHBhc3NlcyBudWxsXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0hvcml6b250YWxTY3JvbGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LXNjcm9sbGFibGUnKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxXaWR0aCA+IHNjcm9sbENvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzVmVydGljYWxTY3JvbGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LXNjcm9sbGFibGUnKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxIZWlnaHQgPiBzY3JvbGxDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBTY3JvbGxpbmdEaXJlY3Rpb24gaXMgYSBuZXcgdHlwZSB0aGF0IGRyaXZlcyBzY3JvbGxpbmcgYmVoYXZpb3I6XG4gKiAgLSBob3Jpem9udGFsID0+IG92ZXJmbG93LXg6IGF1dG8sIG92ZXJmbG93LXk6aGlkZGVuXG4gKiAgLSB2ZXJ0aWNhbCA9PiBvdmVyZmxvdy14OiBoaWRkZW4sIG92ZXJmbG93LXk6YXV0b1xuICogIC0gdmVydGljYWwtcm93ID0+IG92ZXJmbG93LXg6IGhpZGRlbiwgb3ZlcmZsb3cteTphdXRvOyBmbG93OiByb3cgd3JhcFxuICogIC0gYm90aCA9PiBvdmVyZmxvdy14OiBhdXRvLCBvdmVyZmxvdy15OmF1dG9cbiAqICAtIG5vbmUgPT4gc2V0cyBmbG93LWZsb3cgdG8gcm93IHdyYXBcbiAqL1xuZXhwb3J0IHR5cGUgU2Nyb2xsaW5nRGlyZWN0aW9uID0gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyB8ICd2ZXJ0aWNhbC1yb3cnIHwgJ2JvdGgnIHwgJ25vbmUnO1xuXG5cbi8qKlxuICpcbiAqIENvbnRyb2xzIHRoZSBqdXN0aWZ5LWNvbnRlbnQgcHJvcGVydHk6XG4gKlxuICogLSBsZWZ0ID0+IGZsZXgtc3RhcnRcbiAqIC0gcmlnaHQgPT4gZmxleC1lbmRcbiAqIC0gY2VudGVyID0+IGNlbnRlclxuICogLSBqdXN0aWZ5ID0+IHNwYWNlLWJldHdlZW5cbiAqXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRhaW5lckl0ZW1zQWxpZ25tZW50ID0gJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1Njcm9sbGFibGVDb250YWluZXJDb21wb25lbnR9IGZyb20gJy4vc2Nyb2xsYWJsZS1jb250YWluZXIuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0xpc3Rib3gsIFNlbGVjdEl0ZW19IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0NoZWNrYm94Q29tcG9uZW50fSBmcm9tICcuLi9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQnO1xuXG5cbmV4cG9ydCBjb25zdCBMQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGlzdENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbi8qKlxuICpcbiAqIFRoZSBMaXN0IGNvbXBvbmVudCByZXByZXNlbnQgYSBzdHJ1Y3R1cmUgd2hpY2ggY29udGFpbnMgYSBsaXN0IG9mIHNlbGVjdGFibGUgaXRlbXMuIEl0ZW1zXG4gKiBzZWxlY3Rpb24gY2FuIGJlIGNvbmZpZ3VyZWQgaW4gc2luZ2xlLXNlbGVjdGlvbiwgbXVsdGktc2VsZWN0aW9uIG9yIG11bHRpLXNlbGVjdGlvbiB3aXRoIHZpc2libGVcbiAqIGNoZWNrYm94ZXMgbW9kZS5cbiAqIEluIGFkZGl0aW9uIGl0IGNhbiBkaXNwbGF5IGRhdGEgaW5zaWRlIDMgem9uZXMgTEVGVCwgTUlERExFIGFuZCBSSUdIVCBpbiBvcmRlciB0byBwcm92aWRlXG4gKiBlYXN5IHdheSBmb3IgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGxheW91dCBpdHMgb3duIGN1c3RvbSBjb250ZW50IG9yIGV2ZW4gY2hhbmdlIG91dCBvZiBib3hcbiAqIGJlaGF2aW9yLlxuICpcbiAqXG4gKiAgIyMjIEV4YW1wbGVzXG4gKlxuICogIDEuIFJlbmRlciBzaW1wbGUgc2luZ2xlIHNlbGVjdGlvbiBsaXN0XG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgICAgIDxhdy1saXN0IFtsaXN0XT1cImxpc3RcIj48L2F3LWxpc3Q+XG4gKlxuICogIGBgYFxuICogIDIuIFJlbmRlciBsaXN0IC0gbXVsdGkgc2VsZWN0aW9uIHdpdGggY3VzdG9tIFJJR0hUIGNvbnRlbnQgdG8gc2hvdyBhIENoZWNrTWFyayB3aGVuIGl0ZW1cbiAqICBpcyBzZWxlY3RlZFxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICA8YXctbGlzdCAjYXdsaXN0IFtsaXN0XT1cImxpc3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIjE1MHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjI1MHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uTW9kZV09XCInbXVsdGknXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI3JpZ2h0IGxldC1pdGVtPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb25cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieydpY29uLWFjY2VwdCc6IGF3bGlzdC5wTGlzdEJveC5pc1NlbGVjdGVkKGl0ZW0pLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc6ICFhd2xpc3QucExpc3RCb3guaXNTZWxlY3RlZChpdGVtKX1cIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwvYXctbGlzdD5cbiAqXG4gKiAgYGBgXG4gKlxuICogMy4gUmVuZGVyIGxpc3QgLSBtdWx0aSBzZWxlY3Rpb24gd2l0aCB2aXNpYmxlIGNoZWNrYm94ZXMgYW5kIGN1c3RvbSBNSURETEUgY29udGVudCB0byBjaGFuZ2VcbiAqICB0aGUgd2F5IGl0ZW0gbmFtZSBpcyByZW5kZXJlZFxuICpcbiAqXG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgIDxhdy1saXN0IFtsaXN0XT1cImxpc3RcIiBoZWlnaHQ9XCIxODBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIyMDBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25Nb2RlXT1cIidtdWx0aVdpdGhDaGVja2JveCdcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjbWlkZGxlIGxldC1pdGVtPlxuICogICAgICAgICAgICAgICAgICAgICAgWFgte3tpdGVtLnZhbHVlfX1cbiAqICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgIDwvYXctbGlzdD5cbiAqXG4gKiAgYGBgXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2xpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL2xpc3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgTEJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMaXN0Q29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIExpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBvcHRpb24gdGhhdCB3aWxsIHNob3cgaW4gdGhlIGxpc3QuIFBsZWFzZSBub3QgdGhhdCB0aGlzIGxpc3QgaXMgY3VycmVudCB1c2VkIHRvXG4gICAgICogc2hvdyBsaW1pdGVkIG51bWJlciBvZiBpdGVtcy4gSXQgZG9lcyBub3QgaGF2ZSBhbnkgc2Nyb2xsaW5nIGZlYXR1cmUgYW5kIGxhenkgbG9hZGluZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEl0ZW1zIHdoaWNoIHdhcyBzZWxlY3RlZCBhcyBhIGRlZmF1bHQgdmFsdWVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb246IGFueTtcblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCByZWNvZ25pemVzIDMgbW9kZXM6IHNpbmdsZSwgbXVsdGksIG11bHRpIHdpdGggdmlzaWJsZSBjaGVja2JveGVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlID0gJ3NpbmdsZSc7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHRlciB1c2VkIHRvIGZvcm1hdCBlYWNoIHNlbGVjdGlvbiBmb3IgZGlzcGxheS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWVUcmFuc2Zvcm1lcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiBkZWFsaW5nIHdpdGggb2JqZWN0IHRvIGlkZW50aWZ5IHNwZWNpZmljIGZpZWxkIG9uIHRoZSBvYmplY3QgZm9yY29tcGFyaXNvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZmllbGQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRG9uJ3QgcmVuZGVyIExpc3Rib3ggYm9yZGVyLiBVc2VkIGZvciBlbWJlZGRpbmcgdGhpcyBpbnNpZGUgb3RoZXIgY29tcG9uZW50c1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib3JkZXJsZXNzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB3ZSBkb3VibGUgY2xpY2sgb24gdGhlIGxpc3QgSXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2Ugd2FudCB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yIG9yIExlZnQgem9uZS4gV2UgZXhwb3NlIHRoaXMgbGlzdEJveCBpbiBvcmRlciB0b1xuICAgICAqIGhhdmUgYWNjZXNzIHByaW1lTmcgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdsaXN0Ym94JylcbiAgICBwTGlzdEJveDogTGlzdGJveDtcblxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHRlbXBsYXRlcyB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yLiBUaGUgbGlzdCBpdGVtIGlzIGRpdmlkZWQgaW50byAzIHpvbmVzXG4gICAgICpcbiAgICAgKlxuICAgICAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gICAgICogIHwgICBMICAgfCAgICAgICAgICAgICBNICAgICAgICAgICAgICAgICAgICAgfCAgIFIgICAgfFxuICAgICAqICB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAgICAgKiAgfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gICAgICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdsZWZ0JylcbiAgICBsWm9uZVRlbXBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQENvbnRlbnRDaGlsZCgnbWlkZGxlJylcbiAgICBtWm9uZVRlbXBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQENvbnRlbnRDaGlsZCgncmlnaHQnKVxuICAgIHJab25lVGVtcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbFxuICAgICAqL1xuICAgIGludGVybmFsTGlzdDogU2VsZWN0SXRlbVtdO1xuXG4gICAgbGlzdFN0eWxlOiB7W25hbWU6IHN0cmluZ106IGFueX0gPSB7fTtcblxuICAgIGlzTXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93Q2hlY2tib3g6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJyB8fFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGlXaXRoQ2hlY2tib3gnO1xuICAgICAgICB0aGlzLnNob3dDaGVja2JveCA9IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpV2l0aENoZWNrYm94JztcblxuICAgICAgICAvLyBjYW5ub3QgaGF2ZSBib3RoIGVpdGhlciB3ZSB1c2UgZmllbGQgdG8gZ2V0IGRpc3BsYXkgdmFsdWUgb3IgdmFsdWVUcmFuc2Zvcm1lclxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmllbGQpICYmIGlzUHJlc2VudCh0aGlzLnZhbHVlVHJhbnNmb3JtZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW4gaGF2ZSBlaXRoZXIgW2ZpZWxkXSBvciBbdmFsdWVUcmFuc2Zvcm1lcl0uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdExpc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBbbGlzdF0gYmluZGluZy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsc28gYWRkIG92ZXJmbG93WSB0byBtYWtlIHN1cmUgaXQgY2FuIHNjcm9sbCBhbmQgZG9lcyBub3QgZXhwYW5kIGJhc2VkIG9uIGl0cyBjb250ZW50XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnaGVpZ2h0J10gPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWydvdmVyZmxvdy15J10gPSAnYXV0byc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnd2lkdGgnXSA9IHRoaXMud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ib3JkZXJsZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnYm9yZGVyLWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNpbmNlIHdlIGFyZSB1c2luZyA8YXctY2hlY2tib3g+IHdlIG5lZWQgdG8gaGF2ZSBjdXN0b20gaGFuZGxpbmcgYm90aCB3aGVuIGNsaWNraW5nIG9uIHRoZVxuICAgICAqIGNoZWNrYm94IGFzIHdlbGwgYXMgaXRlbSB0ZXh0LlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpdGVtQ2xpY2tlZChldmVudDogYW55LCBpdGVtOiBhbnksIGNoZWNrYm94OiBDaGVja2JveENvbXBvbmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucExpc3RCb3gub25PcHRpb25DbGljayhldmVudCwgaXRlbSk7XG5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1JpZ2h0VGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnJab25lVGVtcGwpO1xuICAgIH1cblxuICAgIGhhc0xlZnRUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubFpvbmVUZW1wbCk7XG4gICAgfVxuXG5cbiAgICBoYXNNaWRkbGVUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubVpvbmVUZW1wbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VyZWQgYnkgcC1saXN0Ym94IGNvbXBvbmVudCB3aGVuIGl0ZW0gaXMgc2VsZWN0ZWQuIFdoZW4gc3RhdGUgaXMgbWFuYWdlZCBpbnRlcm5hbGx5XG4gICAgICogd2UgYWxzbyB1cGRhdGUgRm9ybUNvbnRyb2wgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkl0ZW1TZWxlY3RlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZXZlbnQudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQoZXZlbnQudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUoZXZlbnQudmFsdWUsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKGV2ZW50LnZhbHVlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIWVxdWFscyh2YWx1ZSwgdGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGV4dGVybmFsIGZvcm0gb2YgdGhlIGxpc3QgaW50byBQcmltZU5HIGV4cGVjdGVkIGZvcm1hdCB3aGVyZSBpdCB1c2VzXG4gICAgICogU2VsZWN0aW9uSXRlbSBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRMaXN0KClcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3QubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogdGhpcy5kaXNwbGF5VmFsdWUoaXRlbSksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgR2VuZXJhdGVzIGxhYmVsIHZhbHVlIGZvciB0aGUgbGlzdCBib3guXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRpc3BsYXlWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFsID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmllbGQpKSB7XG4gICAgICAgICAgICB2YWwgPSBpdGVtW3RoaXMuZmllbGRdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMudmFsdWVUcmFuc2Zvcm1lcikpIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMudmFsdWVUcmFuc2Zvcm1lcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0IHN1cHBvcnQgdGhlc2UgdGhyZWUgc2VsZWN0aW9uIG1vZGVzXG4gKlxuICovXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ3NpbmdsZScgfCAnbXVsdGknIHwgJ211bHRpV2l0aENoZWNrYm94JztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TGlzdGJveE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7TGlzdENvbXBvbmVudH0gZnJvbSAnLi9saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgTGlzdGJveE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZVxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBMaXN0Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0xpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBAYXV0aG9yIGFtYW51bC5jaG93ZGh1cnlcbiAqIENvcHlyaWdodCAyMDE4IFNBUCBBcmliYVxuICpcbiAqIFdpemFyZFByb2dyZXNzQ29tcG9uZW50IGNhbiBiZSB1c2VkIGFzIGEgc3RlcCBwcm9ncmVzc1xuICogaW4gYSBwYWdlIHRoYXQgaGFzIG11bHRpcGxlIHN0ZXBzXG4gKiBgPGF3LXdpemFyZC1wcm9ncmVzc1xuICogIFtzdGVwc109XCJzdGVwc1wiXG4gKiAgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCJcbiAqICAoc3RlcENoYW5nZWQpPVwib25TdGVwQ2hhbmdlZCgkZXZlbnQpXCI+XG4gKiA8L2F3LXdpemFyZC1wcm9ncmVzcz5gXG4gKi9cblxuaW1wb3J0IHtDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RlcFxue1xuICAgIGNvbXBsZXRlOiBib29sZWFuO1xuICAgIGN1cnJlbnQ6IGJvb2xlYW47XG4gICAgdGl0bGU/OiBzdHJpbmc7XG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctd2l6YXJkLXByb2dyZXNzJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vd2l6YXJkLXByb2dyZXNzLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi93aXphcmQtcHJvZ3Jlc3MuY29tcG9uZW50LnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxue1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcHM6IEFycmF5PFN0ZXA+O1xuXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50U3RlcDogbnVtYmVyID0gMDtcblxuICAgIEBPdXRwdXQoKVxuICAgIHN0ZXBDaGFuZ2VkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgdG90YWxTdGVwczogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RlcHMpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50SW5kZXggPSB0aGlzLnN0ZXBzLmluZGV4T2YodGhpcy5zdGVwcy5maWx0ZXIoc3RlcCA9PiBzdGVwLmN1cnJlbnQpWzBdKTtcbiAgICAgICAgICAgIHRoaXMudG90YWxTdGVwcyA9IHRoaXMuc3RlcHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50U3RlcCh+Y3VycmVudEluZGV4ID8gY3VycmVudEluZGV4IDogMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDdXJyZW50U3RlcChpbmRleDogbnVtYmVyID0gMClcbiAgICB7XG4gICAgICAgIHRoaXMuc3RlcHNbaW5kZXhdLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RlcENoYW5nZWQuZW1pdCh7Y3VycmVudDogdGhpcy5jdXJyZW50U3RlcH0pO1xuICAgIH1cblxuICAgIGdvVG9TdGVwKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc3RlcHNbaW5kZXhdLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuc3RlcHMuZmlsdGVyKHN0ZXAgPT4gc3RlcC5jdXJyZW50KVswXSk7XG4gICAgICAgIHRoaXMuc3RlcHNbY3VycmVudEluZGV4XS5jdXJyZW50ID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zZXRDdXJyZW50U3RlcChpbmRleCk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7V2l6YXJkUHJvZ3Jlc3NDb21wb25lbnR9IGZyb20gJy4vd2l6YXJkLXByb2dyZXNzLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBXaXphcmRQcm9ncmVzc0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRQcm9ncmVzc01vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFJlbmRlcnMgYSBUb2dnbGUgU3dpdGNoXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnbXlUb2dnbGVTZWN0aW9uJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogJzxhdy10b2dnbGUgW21vZGVsXT1cImlucHV0VmFsdWVcIiBbbGFiZWxUZXh0XT1cImxhYmVsVGV4dFwiID5cbiAqICAgICAgICAgICAgICA8L2F3LXRvZ2dsZT4nXG4gKiAgICAgIH0pXG4gKiAgICAgIGV4cG9ydCBjbGFzcyBNeU5vdGVDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgaW5wdXRWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuICogICAgICAgICAgbGFiZWxUZXh0OiBzdHJpbmcgPSAnbXkgbGFiZWwnO1xuICogICAgICB9XG4gKlxuICogYGBgXG4gKi9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10b2dnbGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90b2dnbGUtc3dpdGNoLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi90b2dnbGUtc3dpdGNoLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5cbmV4cG9ydCBjbGFzcyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogdG9nZ2xlIG1vZGVsXG4gICAgICovXG4gICAgQElucHV0KCkgbW9kZWw6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBsYWJlbCB0ZXh0XG4gICAgICovXG4gICAgQElucHV0KCkgbGFiZWxUZXh0OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xpY2sgaGFuZGxlciBmb3IgdG9nZ2xlXG4gICAgICovXG4gICAgY2hhbmdlSGFuZGxlcigpXG4gICAge1xuICAgICAgICB0aGlzLm1vZGVsID0gIXRoaXMubW9kZWw7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1RvZ2dsZVN3aXRjaENvbXBvbmVudH0gZnJvbSAnLi90b2dnbGUtc3dpdGNoLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBUb2dnbGVTd2l0Y2hDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgVG9nZ2xlU3dpdGNoQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFRvZ2dsZVN3aXRjaENvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGVTd2l0Y2hNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtNb2RhbENvbnRhaW5lcn0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLWNvbnRhaW5lcic7XG5pbXBvcnQge092ZXJsYXlQYW5lbH0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIE92ZXJsYXkgQ29tcG9uZW50IGlzIGEgc2ltcGxlIHZlcnNpb24gb2YgdGhlIGRpYWxvZyB3aGVyZSB0aGVyZSdzIG9ubHkgY29udGVudC5cbiAqIE92ZXJsYXkgd2lsbCBhcHBlYXIgYXQgdGhlIHBvc2l0aW9uIHdoZXJlIHRoZSBhY3Rpb24gcGVyZm9ybWVkIHRyaWdnZXIgYW4gb3ZlcmxheS5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgdHlwZXMgb2YgcG9wdXAuXG4gKiAgIDEuICBhIHJlZ3VsYXIgZGlhbG9nIGJveCB0aGF0IGhhcyBoZWFkZXIsIGJvZHkgYW5kIGZvb3Rlci4gSXQncyB0aGUgbW9zdCBjdXN0b21pemFibGUuXG4gKiAgIDIuICBhIGNvbmZpcm1hdGlvbiBib3ggaXMgc2ltaWxhciB0byBhIGRpYWxvZyBib3ggYnV0IGhhcyBhY2NlcHQgYW5kIHJlamVjdCBhY3Rpb24gYnV0dG9ucy5cbiAqICAgMy4gIGEgb3ZlcmxheSwgd2hpY2ggaXMgYSB2ZXJ5IGJhc2ljIHBvcHVwIHdpdGggd2hhdCB5b3UgcHV0IGluc2lkZS5cbiAqICAgICAgIEl0IGRvZXNuJ3QgaGF2ZSBoZWFkZXIgYW5kIGZvb3Rlci5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIGFueSBwb3B1cCBjb21wb25lbnQuXG4gKiAgIDEuICBFaXRoZXIgZGlyZWN0bHkgYnkgdXNpbmcgY29tcG9uZW50LCBhdy1kaWFsb2csIGF3LWNvbmZpcm1hdGlvbiBvciBhdy1vdmVybGF5XG4gKiAgIDIuICBvciB0aGUgTW9kYWxTZXJ2aWNlICBzZXJ2aWNlLm9wZW4oPE92ZXJsYXlDb21wb25lbnQ+KSwgc2VydmljZS5jbG9zZSgpXG4gKlxuICogVXNhZ2U6XG4gKiAgICAxLiAgVXNpbmcgTW9kYWxTZXJ2aWNlIGRpcmVjdGx5IHRvIGRpc3BsYXkgYSBtb2RhbCBwb3B1cC4gVGhlIHVzYWdlIGlzIGEgbGl0dGxlIHRyaWNreVxuICogICAgICAgIGJlY2F1c2UgYW5ndWxhciBjdXJyZW50bHkgZG9lc24ndCBzdXBwb3J0IGR5bmFtaWMgY29udGVudCBwcm9qZWN0aW9uLlxuICpcbiAqICAgICAgICAgIGxldCBvdmVybGF5ID0gdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxPdmVybGF5Q29tcG9uZW50PihPdmVybGF5Q29tcG9uZW50LCB7fSk7XG4gKlxuICogICAgICAgICAgICAvLyBBZGQgY29udGVudC4gVGhlcmUncyBub3Qgc3VwcG9ydCBmb3IgZHluYW1pYyBjb250ZW50IHByb2plY3Rpb24geWV0LlxuICogICAgICAgICAgICAvLyBTbyBoYXZlIGFkZCBjb250ZW50IGRpcmVjdGx5LlxuICogICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCB0aGUgYmVzdCB3YXkuXG4gKiAgICAgICAgICBvdmVybGF5Lmluc3RhbmNlLm92ZXJsYXkuZWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLnVpLW92ZXJsYXlwYW5lbC1jb250ZW50XCIpXG4gKiAgICAgICAgICAgICAgIC5pbm5lckhUTUwgPSBgPGltZyBzdHlsZT0nd2lkdGg6MzAwcHg7JyBzcmM9XCJzYWxlcy5wbmdcIiBhbHQ9XCJTYWxlcyBDaGFydFwiIC8+YDtcbiAqXG4gKiAgICAgICAgICAvLyBkZWxheSB0aGUgb3BlbmluZyBhZnRlciBuZyBsaWZlY3ljbGUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgb3ZlcmxheS5pbnN0YW5jZS5vcGVuKGV2ZW50KTsgfSwgMSk7XG4gKlxuICpcbiAqICAgMi4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1vdmVybGF5ICNvdmVybGF5IChvbk9wZW4pPVwib3ZlcmxheUFjdGlvbj0nb3BlbidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNsb3NlKT1cIm92ZXJsYXlBY3Rpb249J2Nsb3NlJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwic2FsZXMucG5nXCIgYWx0PVwiQ2hhcnRcIi8+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1vdmVybGF5PlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiAoY2xpY2spPVwib3ZlcmxheS5vcGVuKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BlbiBPdmVybGF5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15UGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBvdmVybGF5QWN0aW9uOiBzdHJpbmc7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgIG5nT25Jbml0KCkgeyB9XG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1vdmVybGF5JyxcbiAgICB0ZW1wbGF0ZVVybDogJ292ZXJsYXkuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWydvdmVybGF5LmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgT3ZlcmxheUNvbXBvbmVudCBleHRlbmRzIE1vZGFsQ29udGFpbmVyIGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LFxuICAgIEFmdGVyVmlld0luaXRcbntcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGhpZGUgb3ZlcmxheSB3aGVuIG91dHNpZGUgaXMgY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc21pc3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBjbG9zZSBpY29uICd4JyBhdCB0b3Agb2YgcmlnaHQgY29ybmVyLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0Nsb3NlSWNvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgb3ZlcmxheS4gXCJib2R5XCIgb3IgbG9jYWwgbmctdGVtcGxhdGUgdmFyaWFibGUgYXJlIHZhbGlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kVG86IGFueTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gb3ZlcmxheSBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIGp1c3QgYmVmb3JlIG92ZXJsYXkgaXMgY2xvc2VkXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYmVmb3JlQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgb3ZlcmxheSBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBpbnRlcm5hbCBvdmVybGF5IHBhbmVsLlxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoT3ZlcmxheVBhbmVsKVxuICAgIG92ZXJsYXk6IE92ZXJsYXlQYW5lbDtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBwbGFjZSBob2xkZXIgdG8gYmUgb3ZlcnJpZGRlbiBieSBNb2RhbCBTZXJ2aWNlXG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIHBsYWNlIGhvbGRlciB0byBiZSBvdmVycmlkZGVuIGJ5IE1vZGFsIFNlcnZpY2VcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE9wZW4gT3ZlcmxheVxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIG9wZW4oZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5LnNob3coZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5vbk9wZW5lZChudWxsKTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgT3ZlcmxheVxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMuYmVmb3JlQ2xvc2UuZW1pdChudWxsKTtcbiAgICAgICAgdGhpcy5vdmVybGF5LmhpZGUoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIHRvZ2dsZSBvcGVuIGFuZCBjbG9zZS5cbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICB0b2dnbGUoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5LnRvZ2dsZShldmVudCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cblxuXG4gICAgb25PcGVuZWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoZXZlbnQpO1xuICAgIH1cblxuICAgIG9uQ2xvc2VkKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdChldmVudCk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBWaWV3Q2hpbGR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBbmltYXRpb25FdmVudH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdmVybGF5Q29tcG9uZW50fSBmcm9tICcuLi9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50JztcblxuXG4vKipcbiAqIERlZmluZXMgd2hlcmUgdGhlIENhcmQgaXMgcG9zaXRpb25lZC4gSXQgY2FuIGJlIGVpdGhlcjpcbiAqICAgIC0gYWJvdmUgdGhlIHRyaWdnZXJpbmcgbGlua1xuICogICAgLSB1bmRlciB0aGUgdHJpZ2dlcmluZyBsaW5rXG4gKiAgICAtIGNvbXBsZXRlbHkgb24gdG9wIG9mIGl0IC0gY292ZXJpbmcgaXQuIEZvciB0aGlzIGNhc2UgdGhlcmUgaXMgbm9uZSBhcyBubyBzdHlsZSBpcyBhcHBsaWVkXG4gKi9cbmV4cG9ydCBlbnVtIEhDQ2FyZFBvc2l0aW9uXG57XG4gICAgdG9wLFxuICAgIGJvdHRvbSxcbiAgICBub25lXG59XG5cbi8qKlxuICogRGVmaW5lcyB3aGVyZSB0aGUgQ2FyZCBpcyBwb3NpdGlvbmVkIGJ5IGRlZmF1bHQuIE1lYW5pbmcgd2hlcmUgcHJpbWVORyBjb2RlIHB1dCBpdC5cbiAqXG4gKiBXaGVuIHRoZXJlIGlzIGFsbG90IG9mIHNwYWNlIG9uIHRoZSBzaWRlcyA+PSAgKExlZnQgb3IgUmlnaHQpIGlzIHVzZWRcbiAqIChwYWRkZWRMZWZ0LCBwYWRkZWRSaWdodCkgb3RoZXJ3aXNlLiBXaGVuIHRoZXJlIGlzIG5vdCBtdWNoIHNwYWNlIGFuZCBjYXJkIGNvbnRhaW5lclxuICogIGlzIG5vdCBhbGlnbmVkIChsZWZ0LCByaWdodCkgd2l0aCB0aGUgdHJpZ2VyaW5nIGljb24gYnV0IGl0IGlzIHNoaWZ0ZWQgdG8gZml0IGludG8gdGhlIHNjcmVlblxuICovXG5lbnVtIEhDQ2FyZEFsaWdubWVudFxue1xuICAgIGxlZnQsXG4gICAgcGFkZGVkTGVmdCxcbiAgICByaWdodCxcbiAgICBwYWRkZWRSaWdodCxcbiAgICBkZWZhdWx0XG59XG5cbi8qKlxuICogTWFwcyBwb3NpdGlvbiB0byBzdHlsZXMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgQ2FyZCBjb250YWluZXIuIFRoaXMgaXMganVzdCB0byBtYWtlIGl0IGVhc2llclxuICogYXMgd2UgYXJlIHdvcmtpbmcgd2l0aCBlbnVtZXJhdGlvbnMgYW5kIGhhdmUgYWxyZWFkeSBlbnVtIHR5cGUuXG4gKlxuICogdS1oYy1hcnJvdy1iOiBBcnJvdyB3aWxsIGFwcGVhciBhdCB0aGUgYm90dG9tXG4gKiB1LWhjLWFycm93LXQ6IEFycm93IHdpbGwgYXBwZWFyIGF0IHRoZSB0b3BcbiAqXG4gKiB1LWhjLXNoYWRvdy10OiBCb3JkZXIgc2hhZG93IHdpbGwgYXBwZWFyIGF0IHRoZSB0b3BcbiAqIHUtaGMtc2hhZG93LWI6IEJvcmRlciBzaGFkb3cgd2lsbCBhcHBlYXIgYXQgdGhlIGJvdHRvbVxuICovXG5jb25zdCBQb3NpdGlvblRvU3R5bGUgPSB7XG4gICAgdG9wOiAnIHctaGMtcGFuZWwtYXJyb3cgdS1oYy1hcnJvdy1iIHUtaGMtc2hhZG93LXQnLFxuICAgIGJvdHRvbTogJyB3LWhjLXBhbmVsLWFycm93IHUtaGMtYXJyb3ctdCB1LWhjLXNoYWRvdy1iJyxcbiAgICBub25lOiAnJ1xufTtcblxuXG4vKipcbiAqXG4gKiBNYXBzIGFsaWduZWQgQ2FyZCBjb250YWluZXIgdG8gY3VzdG9tIHN0eWxlcyBpbiBvcmRlciB0byBhcHBseSBjb3JyZWN0IGFycm93XG4gKlxuICogLWxsOiBTdGFuZHMgZm9yIExhcmdlIExlZnQgKGxhcmdlOiB0aGVyZSBpcyBwbGVudHkgb2Ygc3BhY2UgYXJvdW5kIClcbiAqIC1scjogU3RhbmRzIGZvciBMYXJnZSByaWdodFxuICogLXNsOiBTdGFuZHMgZm9yIFNtYWxsIGxlZnQgKFNtYWxsIGFuZCByZXNpemVkIHNjcmVlbiB3aGVyZSB3ZSB0cnkgdG8gZml0IGNhcmQgY29udGFpbmVyXG4gKiBzb21ld2hlcmUgaW4gYmV0d2VlbilcbiAqIC1zcjogU3RhbmRzIGZvciBMYXJnZSByaWdodFxuICpcbiAqL1xuY29uc3QgQWxpZ25tZW50VG9TdHlsZSA9IHtcbiAgICBsZWZ0OiAnIHUtaGMtYXJyb3ctbGwnLFxuICAgIHJpZ2h0OiAnIHUtaGMtYXJyb3ctbHInLFxuICAgIHBhZGRlZExlZnQ6ICcgdS1oYy1hcnJvdy1zbCcsXG4gICAgcGFkZGVkUmlnaHQ6ICcgdS1oYy1hcnJvdy1zcicsXG4gICAgZGVmYXVsdDogJyB1LWhjLWFycm93LWxsJyxcbn07XG5cbi8qKlxuICogVGhlIEhvdmVyQ2FyZCBjb21wb25lbnRzIGFkZHMgaG92ZXIgYmVoYXZpb3IgdG8gdGV4dCwgdGhlIHNwZWNpZmllZCBjb250ZW50IGlzIGxvYWRlZFxuICogb24gdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUb2RvOiBleHRlbmRzIHNvIHdlIGNhbiB3cmFwIGFueSBlbGVtZW50IGFuZCBhbnkgZWxlbWVudCBjYW4gYmUgdHJpZ2dlcmluZyB0aGlzLiBOb3Qgb25seVxuICogbGlua1RpdGxlXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICpcbiAqICAgPGF3LWhvdmVyLWNhcmQgW2xpbmtUaXRsZV09XCInRnJhbmsga29sYXInXCI+XG4gKiAgICAgICA8aDM+TXkgQ2FyZCBUaXRsZTwvaDM+XG4gKiAgICAgICA8ZGl2PlxuICpcbiAqICAgICAgICAgICBUaGlzIGlzIG15IGNvbnRlbnRzXG4gKlxuICogICAgICAgPC9kaXY+XG4gKlxuICpcbiAqICAgIDwvYXctaG92ZXItY2FyZD5cbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlcmUgaXMgW2ZvcmNlQ2xvc2VdPXRydWUgd2hpY2ggZm9yY2VzIHRoZSB1c2VyIHRvIHVzZSBYIGNsb3NlIGljb25cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1ob3Zlci1jYXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vaG92ZXItY2FyZC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vaG92ZXItY2FyZC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQ2FyZENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcGFkZGluZyByZXByZXNlbnRpbmcgYSBoZWlnaHQgb2YgdGhlIEFycm93IGZvciB3aGljaCB3ZSBuZWVkIHRvIHZlcnRpY2FsbHkgYWRqdXN0XG4gICAgICogQ2FyZCBjb250YWluZXJcbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQXJyb3dQYWQgPSAxMDtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgc2FmZSB0aHJlc2hvbGQgd2hlcmUgdGhlcmUgbWlnaHQgbm90IGJlIGVub3VnaCBzcGFjZSBhcm91bmQgb3IgQ2FyZCBpcyBhbGlnbmVkIHdpdGhcbiAgICAgKiB0aGUgbGVmdCBvciByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydCBmb3Igd2hpY2ggd2UgbmVlZCB0byBwb3NpdGlvbiB0aGUgQXJyb3cgY2xvc2VyIHRvIHRoZVxuICAgICAqIHNpZGUgb2YgdGhlIGNhcmRcbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgU3BhY2luZ0xpbWl0ID0gNTA7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgbGlua1RpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgd2Uga2VlcCB0aGUgaG92ZXIgY2FyZCBvcGVuIGFuZCBmb3JjZSB1c2VyIHRvIG1hbnVhbGx5IGNsb3NlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcmNlQ2xvc2U6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgY3VycmVudCB3b3JrYXJvdW5kIHVudGlsIHdlIGZpbmQgYmV0dGVyIHNvbHV0aW9uLiBQcmltZU5HIG92ZXJsYXlzIG9wZXJhdGVzIHdpdGhpblxuICAgICAqIGl0cyByZWxhdGl2ZSBlbGVtZW50IHNvIGlmIHRoZSBvdmVybGF5IGlzIHdyYXBwZWQgaW5zaWRlIHNvbWUgb3RoZXIgcmVsYXRpdmUgY29udGFpbmVyXG4gICAgICogdGhlIG92ZXJsYXkgY29udGVudCBpcyBjcm9wZWQgYnkgaXRzIHBhcmVudCBhbmQgY29udGVudCBpcyBub3QgdmlzaWJsZS5cbiAgICAgKlxuICAgICAqIFRoZXkgaGF2ZSBbYXBwZW5kVG9dIGJpbmRpbmcgd2hpY2ggd2UgbmVlZCB0byB1c2UgZm9yIHRoaXMgcHVycG9zZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRDb250ZW50VG9Cb2R5OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBPdmVybGF5Q29tcG9uZW50IHRvIGNhbiBhY2Nlc3MgUHJpbWVORyBjb21wb25lbnQgYXMgd2VsbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ292ZXJsYXknKVxuICAgIGF3T3ZlcmxheTogT3ZlcmxheUNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbnRlcm5hbCBzdHlsZSBjbGFzcyB0byB1c2UgdG8gYXBwbHkgYWRkaXRpb25hbCBzdHlsZXMgd2hlbiBpdCBuZWVkcyB0byBzaG93IGEgQXJyb3cgb24gdGhlXG4gICAgICogY2FyZFxuICAgICAqXG4gICAgICovXG4gICAgYXJyb3dDbGFzczogc3RyaW5nID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHByb3BlcnRpZXMgdG8gcmVmZXJlbmNlcyB0ZW1wbGF0ZSBlbGVtZW50cyBpbiBvcmRlciB0byBjYWxjdWxhdGUgcG9zaXRpb25pbmdcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgdGl0bGVBcmVhUmVjdDogYW55O1xuICAgIHRyaWdSZWN0OiBhbnk7XG4gICAgdHJpZ0ljb25NaWRkbGU6IGFueTtcblxuICAgIG9wZW5pbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGFwcGVuZFRvOiAnYm9keSc7XG5cbiAgICBjdXJycmVudFBvc2l0aW9uOiBIQ0NhcmRQb3NpdGlvbiA9IEhDQ2FyZFBvc2l0aW9uLm5vbmU7XG5cbiAgICBvdmVybGF5T25BbmltYXRpb25TdGFydDogKGV2ZW50OiBBbmltYXRpb25FdmVudCkgPT4gdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZXMgd2hlcmUgd2UgbmVlZCB0byBpbmplY3QgZHluYW1pYyBjb250ZW50IHVzaW5nIHByb2dyYW1tYXRpYyBBUEkgd2UgdXNlIHRoaXMgZXh0cmFcbiAgICAgKiBlbGVtZW50IHdoaWNoIGlzIG91dHNpZGUgb2YgdGhlIDxuZy1jb250ZW50PiBhbmQgaGlkZGVuIGFuZCBvbmNlIHRoZSA8bmctY29udGVudD4gIG9mXG4gICAgICogdGhlIGNvbXBvbmVudCBpcyBzaG93biB3ZSBtb3ZlIHRoaXMgZHluYW1pYyBjb250ZW50IGludG8gaXQuXG4gICAgICpcbiAgICAgKi9cbiAgICBkeW5hbWljQ29udGVudDogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbTogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmxpbmtUaXRsZSksICdZb3UgbXVzdCBwcm92aWRlIFtsaW5rVGl0bGVdIGJpbmRpbmcgIScpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBvcGVuIEhDIHdoZW4gd2Ugc3RhcnQgbmV3IGNvbXBvbmVudFxuICAgICAgICB0aGlzLmVudi5kZWxldGVWYWx1ZSgnaGMtb3BlbicpO1xuXG4gICAgICAgIGlmICghdGhpcy5hcHBlbmRDb250ZW50VG9Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3ZlcmxheU9uQW5pbWF0aW9uU3RhcnQgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5Lm9uQW5pbWF0aW9uU3RhcnQ7XG4gICAgICAgIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkub25BbmltYXRpb25TdGFydCA9IChldmVudDogQW5pbWF0aW9uRXZlbnQpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheU9uQW5pbWF0aW9uU3RhcnQuY2FsbCh0aGlzLmF3T3ZlcmxheS5vdmVybGF5LCBldmVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuY2FyZE9wZW5lZCgpO1xuICAgICAgICAgICAgdGhpcy5vbkFuaW1hdGlvblN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB0aGlzIHNwYW4gaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgICAgICB0aGlzLmR5bmFtaWNDb250ZW50ID0gdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnUtbmdjb250ZW50Jyk7XG4gICAgfVxuXG5cbiAgICBvbkFuaW1hdGlvblN0YXJ0KGV2ZW50OiBBbmltYXRpb25FdmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLm9wZW5pbmcpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGxldCBjbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycnJlbnRQb3NpdGlvbiAhPT0gSENDYXJkUG9zaXRpb24ubm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FyZChjb250YWluZXIsIGNudFJlY3QsIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaW5qZWN0RHluYW1pY0NvbnRlbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkudmlzaWJsZSkge1xuICAgICAgICAgICAgbGV0IG92ZXJsYXlDbnQgPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudFxuICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKCcudWktb3ZlcmxheXBhbmVsLWNvbnRlbnQgLnUtbmdjb250ZW50Jyk7XG5cbiAgICAgICAgICAgIGlmIChpc0JsYW5rKG92ZXJsYXlDbnQpICYmIHRoaXMuZHluYW1pY0NvbnRlbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlDbnQgPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudWktb3ZlcmxheXBhbmVsLWNvbnRlbnQnKTtcbiAgICAgICAgICAgICAgICBvdmVybGF5Q250LnByZXBlbmQodGhpcy5keW5hbWljQ29udGVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljQ29udGVudC5zdHlsZSA9ICdibG9jayc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNDb250ZW50LnN0eWxlID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdCBlbGVtZW50cyBCb3VuZGluZ0NsaWVudFJlY3QgdGhhdCB3ZSB1c2UgZm9yIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0RWxlbWVudHMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHRpdGxlRWxlbSA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LWhjLXRpdGxlJyk7XG4gICAgICAgIGxldCB0cmlnZ2VyRWxlbSA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zYXAtaWNvbicpO1xuICAgICAgICB0aGlzLnRpdGxlQXJlYVJlY3QgPSB0aXRsZUVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudHJpZ1JlY3QgPSB0cmlnZ2VyRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy50cmlnSWNvbk1pZGRsZSA9IHRoaXMudHJpZ1JlY3Qud2lkdGggLyAyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlcyB3aGVuIHVzZXIgbW91c2Ugb3ZlciB0aGUgdHJpZ2dlcmluZyBpY29uIGFuZCBvcGVucyB1cCBvdmVybGF5IGNvbXBvbmVudC4gVG8gbWFrZSBzdXJlXG4gICAgICogb25seSBvbmUgQ2FyZCBpcyBvcGVuZWQgYXQgdGhlIHRpbWUgaXQgdXNlcyBFbnZpcm9ubWVudCB0byBzYXZlIGV4dHJhIGluZm9ybWF0aW9uIGZvciBpdFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuQ2FyZChldmVudDogYW55KTogYW55XG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYXdPdmVybGF5KSAmJiAhdGhpcy5lbnYuaGFzVmFsdWUoJ2hjLW9wZW4nKSkge1xuICAgICAgICAgICAgdGhpcy5hd092ZXJsYXkub3BlbihldmVudCk7XG4gICAgICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIHRoaXMuZW52LnNldFZhbHVlKCdoYy1vcGVuJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZWQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlbmluZyBjeWNsZSB3aGVuIGFsbCBpcyBpbml0aWFsaXplZCBhbmQgdGhlIGNhcmQgaXMgYWJvdXQgdG9cbiAgICAgKiBmYWRlIGluLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZmlyc3Qgc2ltdWxhdGVzIGRpc3BsYXlpbmcgY2FyZCBieSBzZXR0aW5nIGRpc3BsYXk6YmxvY2sgYW5kXG4gICAgICogZG9tSGFuZGxlci5hYnNvbHV0ZVBvc2l0aW9uIHNvIHdlIGNhbiByZWFkIGRpbWVuc2lvbnMgYW5kIHRoZW4gbGF0ZXIgb24gcG9zaXRpb24gdGhlIGNhcmRcbiAgICAgKiBhY2NvcmRpbmdseS5cbiAgICAgKlxuICAgICAqL1xuICAgIGNhcmRPcGVuZWQoZXZlbnQ/OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS5jb250YWluZXI7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LnRhcmdldDtcblxuICAgICAgICB0aGlzLm9wZW5Gb3JBZGp1c3RtZW50cyhjb250YWluZXIpO1xuICAgICAgICB0aGlzLmluamVjdER5bmFtaWNDb250ZW50KCk7XG5cbiAgICAgICAgLy8gcHJlLXJ1biBwb3NpdGlvbmluZyBzbyB3ZSBjYW4gY2FsY3VsYXRlIG5ldyBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbihjb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgIGxldCBjbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmN1cnJyZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uRm9yQ2FyZChjb250YWluZXIsIGNudFJlY3QpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZUNsYXNzKGNvbnRhaW5lciwgY250UmVjdCwgdGhpcy5hd092ZXJsYXkub3ZlcmxheSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZUZvckFkanVzdG1lbnRzKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMub3BlbmluZyA9IHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gY2FyZCBpcyBjbG9zZWQgd2UgbmVlZCB0byByZWxlYXNlIGl0IGFuZCBkZWxldGUgYWxsIHRoZSByZWZlcmVuY2VzIGZyb20gRW52aXJvbm1lbnRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgY2FyZENsb3NlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5lbnYuZGVsZXRlVmFsdWUoJ2hjLW9wZW4nKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICAqIEJlZm9yZSBvdmVybGF5IGlzIGNsb3NlZCB3ZSBoaWRlIGludGVybmFsIGNvbnRlbnQgb3RoZXIgaXQgZG9lcyBsaXR0bGUgc2hha2UuLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBiZWZvcmVDbG9zZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5keW5hbWljQ29udGVudC5zdHlsZSA9ICdub25lJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFwcGxpZXMgc3R5bGUuVE9QIGFuZCBzdHlsZS5MRUZUIHRvIHRoZSBjb250YWluZXIgaW4gb3JkZXIgdG8gcmVwb3NpdGlvbiBpdCBhbmQgYWRkXG4gICAgICogZXh0cmEgYXJyb3cuXG4gICAgICpcbiAgICAgKiBGaXJzdCBiYXNlZCBvbiB0aGUgaW5pdGlhbCBwb3NpdGlvbiB3ZSBhcHBseSBzdHlsZS5UT1AgYW5kIGRlcGVuZGluZyBpZiBpdHMgb24gdGhlXG4gICAgICogdG9wIG9yIGJvdHRvbSB3ZSBhcHBseSBlaXRoZXIgLUhvdmVyQ2FyZENvbXBvbmVudC5BcnJvd1BhZCBvciArSG92ZXJDYXJkQ29tcG9uZW50LkFycm93UGFkLlxuICAgICAqXG4gICAgICogVGhlbiBmb3IgcG9zaXRpb25pbmcgaG9yaXpvbnRhbGx5IHdlIHVzZSB0d28gdHlwZXMuXG4gICAgICogIC0gV2hlbiB0aGVyZSBpcyBhbGxvdCBvZiBzcGFjZSB0aGUgYXJyb3cgaXMgMjUlIGZyb20gdGhlIGVkZ2VcbiAgICAgKlxuICAgICAqICAgIC0tLS0tXi0tLS0tLS0tLS0tLSAgIG9yICAgICAgIC0tLS0tLS0tLS0tXi0tLS1cbiAgICAgKlxuICAgICAqXG4gICAgICogIC0gV2hlbiB0aGVyZSBpcyBsZXNzIG9yIG5vbmUgc3BhY2Ugd2UgaGF2ZSBvbmx5IDEwJSBmYXIgYXdheSBmb3JtIHRoZSBlZGdlXG4gICAgICpcbiAgICAgKiAgICAtLV4tLS0tLS0tLS0tLS0gICBvciAgICAgICAtLS0tLS0tLS0tLV4tLVxuICAgICAqXG4gICAgICogIE9uY2Ugd2UgcGljayB0aGUgY29ycmVjdCBwb3NpdGlvbmluZyAoMjUlLCAxMCUpIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgYW5kIHNoaWZ0IHRoZSBjYXJkXG4gICAgICogIGVpdGhlciB0byB0aGUgbGVmdCBvciByaWdodC5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkanVzdENhcmQoY29udGFpbmVyOiBhbnksIGNvbnRhaW5lclJlY3Q6IGFueSwgbW9kYWxDb250YWluZXI6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBkaWZmID0gKHRoaXMuY3VycnJlbnRQb3NpdGlvbiA9PT0gSENDYXJkUG9zaXRpb24uYm90dG9tKSA/IDEgOiAtMTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IG1vZGFsQ29udGFpbmVyLmRvbUhhbmRsZXIuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGxldCBwb3NXaXRoU2Nyb2xsID0gY29udGFpbmVyUmVjdC50b3AgKyBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSAocG9zV2l0aFNjcm9sbCArIChIb3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQgKiBkaWZmKSkgKyAncHgnO1xuXG4gICAgICAgIGxldCBhbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudEZvckNhcmQoY29udGFpbmVyUmVjdCwgbW9kYWxDb250YWluZXIpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IHRoaXMuY2FsY0xlZnRGb3JBbGlnbm1lbnQoY29udGFpbmVyUmVjdCwgYWxpZ25tZW50KSArICdweCc7XG4gICAgfVxuXG5cbiAgICBhcHBseVN0eWxlQ2xhc3MoY29udGFpbmVyOiBhbnksIGNvbnRhaW5lclJlY3Q6IGFueSwgbW9kYWxDb250YWluZXI6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycnJlbnRQb3NpdGlvbiAhPT0gSENDYXJkUG9zaXRpb24ubm9uZSkge1xuICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50Rm9yQ2FyZChjb250YWluZXJSZWN0LCBtb2RhbENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICg8YW55PlBvc2l0aW9uVG9TdHlsZSlbKDxhbnk+SENDYXJkUG9zaXRpb24pW3RoaXMuY3VycnJlbnRQb3NpdGlvbl1dO1xuICAgICAgICAgICAgdGhpcy5hcnJvd0NsYXNzICs9ICg8YW55PkFsaWdubWVudFRvU3R5bGUpWyg8YW55PkhDQ2FyZEFsaWdubWVudClbYWxpZ25tZW50XV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZXRlY3RzIGlmIHRoZSBjYXJkIGlzIGdvaW5nIHRvIGJlIHNob3duIG9uIHRoZSB0b3Agb2YgdGhlIExpbmsgbGFiZWwgb3IgdW5kZXIuIE9yIGlmXG4gICAgICogaXRzIGNvdmVyaW5nIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgcG9zaXRpb25Gb3JDYXJkKGNvbnRhaW5lcjogYW55LCBib3VuZGluZ1JlY3Q6IGFueSk6IEhDQ2FyZFBvc2l0aW9uXG4gICAge1xuICAgICAgICAvLyBzZWN1cmUgdGhpcyBpbiBjYXNlIG9mIElFIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgICAgbGV0IGJvcmRlcldpZHRoID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLmJvcmRlcldpZHRoO1xuICAgICAgICBsZXQgY250V2lkdGggPSBwYXJzZUZsb2F0KGJvcmRlcldpZHRoIHx8ICcwJyk7XG4gICAgICAgIGxldCBwb3MgPSBIQ0NhcmRQb3NpdGlvbi5ub25lO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdSZWN0LmJvdHRvbSA8IGJvdW5kaW5nUmVjdC50b3ApIHtcbiAgICAgICAgICAgIHBvcyA9IEhDQ2FyZFBvc2l0aW9uLmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyaWdSZWN0LnRvcCA+IChib3VuZGluZ1JlY3QuYm90dG9tIC0gY250V2lkdGgpKSB7XG4gICAgICAgICAgICBwb3MgPSBIQ0NhcmRQb3NpdGlvbi50b3A7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZXRlY3QgaG9yaXpvbnRhbCBhbGlnbm1lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGFsaWdubWVudEZvckNhcmQoYm91bmRpbmdSZWN0OiBhbnksIG1vZGFsQ29udGFpbmVyOiBhbnkpOiBIQ0NhcmRBbGlnbm1lbnRcbiAgICB7XG4gICAgICAgIGxldCBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQubGVmdDtcbiAgICAgICAgbGV0IHZpZXdQb3J0ID0gbW9kYWxDb250YWluZXIuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdSZWN0LmxlZnQudG9GaXhlZCgwKSA9PT0gYm91bmRpbmdSZWN0LmxlZnQudG9GaXhlZCgwKSAmJlxuICAgICAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgPiBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KVxuICAgICAgICB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQubGVmdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kaW5nUmVjdC5sZWZ0IDwgSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnBhZGRlZExlZnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICgodmlld1BvcnQud2lkdGggLSBib3VuZGluZ1JlY3QucmlnaHQpIDwgSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnBhZGRlZFJpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnUmVjdC5yaWdodC50b0ZpeGVkKDApID09PSBib3VuZGluZ1JlY3QucmlnaHQudG9GaXhlZCgwKSB8fFxuICAgICAgICAgICAgKHZpZXdQb3J0LndpZHRoIC0gYm91bmRpbmdSZWN0LnJpZ2h0KSA+IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5yaWdodDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWdubWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR1cm4gb24gdGVtcG9yYXJ5IGRpc3BsYXkgdG8gQkxPQ0sgc28gd2UgY2FuIHJlYWQgZGltZW5zaW9uc1xuICAgICAqXG4gICAgICovXG4gICAgb3BlbkZvckFkanVzdG1lbnRzKGNvbnRhaW5lcjogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIHRoaXMuaW5pdEVsZW1lbnRzKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR1cm4gb2ZmIGRpc3BsYXkgYmFjayBOT05FXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZUZvckFkanVzdG1lbnRzKGNvbnRhaW5lcjogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgIC8vIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDYWxjdWxhdGVzIHBvc2l0aW9uaW5nIGZvciBzdHlsZS5MRUZULiBBcyBhbHJlYWR5IHNhaWQgdGhleSBhcmUgdHdvIHR5cGVzIG9mIHRyaWFuZ2xlcyB0aGF0XG4gICAgICogYXJlIGFwcGxpZXMgZm9yIHRoZXNlIGNhc2U6XG4gICAgICpcbiAgICAgKlxuICAgICAqIGEpIExhcmdlIGxlZnQsIExhcmdlIHJpZ2h0XG4gICAgICpcbiAgICAgKiAgUHJpbWVORyBhbGlnbnMgdGhlIGNhcmQgd2l0aCBlaXRoZXIgdGhlIHJpZ2h0IHNpZGUgb3IgbGVmdCBzaWRlIG9mIHRoZSB0cmlnZ2VyaW5nIGljb25cbiAgICAgKlxuICAgICAqXG4gICAgICogIFYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuICAgICAqICAuLi4uLi5eLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIG9yICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLl4uLi4uLi5cbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqICBiKSBTbWFsbCBsZWZ0ICwgc21hbGwgcmlnaHRcbiAgICAgKlxuICAgICAqICBUaGlzIGlzIGZvciBjYXNlcyB3aGVyZSB0aGVyZSBpcyBub3QgZW5vdWdoIHNwYWNlIGFuZCBQcmltZU5HIHBvc2l0aW9uIHRoZSBjYXJkIG9mZiB0byB0aGVcbiAgICAgKiAgdHJpZ2dlcmluZyBpY29ucywgc28gZXZlbiBwcmltZU5nIGRvZXMgbm90IGhhdmUgc3BhY2UgdG8gYWxpZ24gaXQgd2l0aCB0aGUgVlxuICAgICAqXG4gICAgICpcbiAgICAgKiAgICAgViAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZcbiAgICAgKiAgLi4uLl4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gb3IgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXi4uLi5cbiAgICAgKlxuICAgICAqXG4gICAgICogYylBbGlnbmVkIHdpdGggdGhlIGVkZ2Ugb2YgYnJvd3NlclxuICAgICAqXG4gICAgICogT24gdGhlIHJpZ2h0IHNpZGUgdGhpcyBpcyBwcm9ibGVtIGFzIHdlIGNhbm5vdCBjYWxjdWxhdGUgZnVsbCBmdXR1cmUgd2lkdGggb2YgdGhlIGNhcmQuXG4gICAgICogYnV0IHdlIGFwcGxseSBmb3IgdGhpcyBjYXNlICNiIChhcnJvdyAxMCUgKVxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY0xlZnRGb3JBbGlnbm1lbnQoYm91bmRpbmdSZWN0OiBhbnksIGFsaWdubWVudDogSENDYXJkQWxpZ25tZW50KTogbnVtYmVyXG4gICAge1xuICAgICAgICAvLyB3aWR0aCBmb3Igd2hpY2ggd2UgbmVlZCB0byBzaGlmdCBjYXJkLiAyNSUgb3IgMTAlIG9mIHRoZSBjb250YWluZXIgd2lkdGhcbiAgICAgICAgbGV0IHdMYXJnZVRyaWFuZ2xlID0gYm91bmRpbmdSZWN0LndpZHRoICogMC4yNTtcbiAgICAgICAgbGV0IHdTbWFsbFRyaWFuZ2xlID0gYm91bmRpbmdSZWN0LndpZHRoICogMC4xMDtcblxuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQucmlnaHQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0UmlnaHQgPSBib3VuZGluZ1JlY3QubGVmdCArIHdMYXJnZVRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIGxldCB0cmlnUmlnaHQgPSB0aGlzLnRyaWdSZWN0LnJpZ2h0IC0gdGhpcy50cmlnSWNvbk1pZGRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRSaWdodCAtIChib3VuZGluZ1JlY3QucmlnaHQgLSB0cmlnUmlnaHQpO1xuXG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5wYWRkZWRSaWdodDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRSaWdodFMgPSBib3VuZGluZ1JlY3QubGVmdCArIHdTbWFsbFRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIGxldCB0cmlnUmlnaHRTID0gdGhpcy50cmlnUmVjdC5yaWdodCAtIHRoaXMudHJpZ0ljb25NaWRkbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0UmlnaHRTIC0gKGJvdW5kaW5nUmVjdC5yaWdodCAtIHRyaWdSaWdodFMpO1xuXG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LnBhZGRlZExlZnQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0TGVmdFBhZCA9IGJvdW5kaW5nUmVjdC5sZWZ0IC0gd1NtYWxsVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0TGVmdFBhZCArIHRoaXMudHJpZ0ljb25NaWRkbGU7XG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LmxlZnQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdExlZnQgPSBib3VuZGluZ1JlY3QubGVmdCAtIHdMYXJnZVRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdExlZnQgKyB0aGlzLnRyaWdJY29uTWlkZGxlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudENoZWNrZWQsXG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIERvQ2hlY2ssXG4gICAgRWxlbWVudFJlZixcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBTaW1wbGVDaGFuZ2Vcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudCwgcHJpbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU3B5IGxpZmVjeWNsZSBkaXJlY3RpdmUgaXMgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIHRvIHRyYWNrIGxpZmVjeWNsZSBjYWxsYmFja1xuICpcbiAqICMjI1VzYWdlXG4gKlxuICogYGBgXG4gKiAgIDxteS1kaXJlY3RpdmUgc3B5aG9va3M+PG15LWRpcmVjdGl2ZT5cbiAqXG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbc3B5SG9va3NdJ30pXG5leHBvcnQgY2xhc3MgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCwgRG9DaGVjaywgT25DaGFuZ2VzLFxuICAgIEFmdGVyQ29udGVudEluaXQsIEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWRcbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZilcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCdvbkluaXQnKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCdvbkRlc3Ryb3knKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHtbIHByb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2V9KVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdPbkNoYW5nZXMgPSAnICsgY2hhbmdlcyk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nRG9DaGVjaycpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyQ29udGVudEluaXQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKVxuICAgIHtcblxuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyQ29udGVudENoZWNrZWQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlclZpZXdJbml0Jyk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJWaWV3Q2hlY2tlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9nSXQobXNnOiBzdHJpbmcpXG4gICAge1xuICAgICAgICBsZXQgbGV2ZWwgPSAwO1xuICAgICAgICBsZXQgbWUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHRhZ0JvZHkgPSBtZTtcblxuICAgICAgICB3aGlsZSAoKHRhZ0JvZHkgPSB0YWdCb2R5LnBhcmVudE5vZGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICBpZiAodGFnQm9keS50YWdOYW1lID09PSAnQVBQLVJPT1QnIHx8IGxldmVsID09PSA2KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGVudCA9ICcnO1xuICAgICAgICBsZXQgaW5kZW50TnVtYmVyID0gbGV2ZWw7XG4gICAgICAgIHdoaWxlIChsZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnXFx0JztcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxldCBwYXJhbXMgPSAnJztcbiAgICAgICAgaWYgKGlzUHJlc2VudChtZS5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF0dHI6IEF0dHIgPSBtZS5hdHRyaWJ1dGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWdub3JlKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHBhcmFtcyArPSAnKCcgKyBhdHRyLm5hbWUgKyAnPScgKyBhdHRyLnZhbHVlICsgJyksICAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByaW50KGluZGVudCArIG1lLnRhZ05hbWUgKyAnKCcgKyBpbmRlbnROdW1iZXIgKyAnKTogJyArIG1zZyArICcgPT4gJyArIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpZ25vcmUobmFtZTogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuaW5kZXhPZignX25nJykgPiAtMSB8fFxuICAgICAgICAgICAgbmFtZS5pbmRleE9mKCduZy0nKSA+IC0xIHx8XG4gICAgICAgICAgICBuYW1lLmluZGV4T2YoJ3NweWhvb2tzJykgPiAtMTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge092ZXJsYXlDb21wb25lbnR9IGZyb20gJy4vb3ZlcmxheS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdmVybGF5UGFuZWxNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudCxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXT3ZlcmxheU1vZHVsZVxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIb3ZlckNhcmRDb21wb25lbnR9IGZyb20gJy4vaG92ZXItY2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV092ZXJsYXlNb2R1bGV9IGZyb20gJy4uL292ZXJsYXkvb3ZlcmxheS5tb2R1bGUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEhvdmVyQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0hvdmVyQ2FyZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBUFBfSU5JVElBTElaRVIsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgIEJ1dHRvbk1vZHVsZSxcbiAgICBDYWxlbmRhck1vZHVsZSxcbiAgICBDaGVja2JveCxcbiAgICBDaGVja2JveE1vZHVsZSxcbiAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgRGlhbG9nLFxuICAgIERpYWxvZ01vZHVsZSxcbiAgICBEcm9wZG93bk1vZHVsZSxcbiAgICBFZGl0b3JNb2R1bGUsXG4gICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgTWVudU1vZHVsZSxcbiAgICBPdmVybGF5UGFuZWxNb2R1bGUsXG4gICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgIFBhbmVsTW9kdWxlLFxuICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZSxcbiAgICBUYWJNZW51TW9kdWxlLFxuICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgVHJlZU1vZHVsZVxufSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBcmliYUNvcmVNb2R1bGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZX0gZnJvbSAnLi9zcHktbGlmZWN5Y2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQge0VtYmVkZGVkSXRlbURpcmVjdGl2ZX0gZnJvbSAnLi9jb3JlL2VtYmVkZGVkLWl0ZW0nO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi9lbnRyeS1jb21wb25lbnRzJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUnO1xuaW1wb3J0IHtBV0NoZWNrQm94TGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7QVdDaG9vc2VyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29uZmlybWF0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0N1cnJlbmN5TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlJztcbmltcG9ydCB7QVdEYXRlQW5kVGltZU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0RpYWxvZ01vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQge0FXR2VuZXJpY0Nob29zZXJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9nZW5lcmljLWNob29zZXIvZ2VuZXJpYy1jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0lucHV0RmllbGRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUnO1xuaW1wb3J0IHtBV091dGxpbmVGb3JNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZSc7XG5pbXBvcnQge0FXT3ZlcmxheU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VXcmFwcGVyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2Utd3JhcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JhZGlvLWJ1dHRvbi1saXN0L3JhZGlvLWJ1dHRvbi1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXUmljaFRleHRBcmVhTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlJztcbmltcG9ydCB7QVdIb3ZlckNhcmRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQubW9kdWxlJztcbmltcG9ydCB7XG4gICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlXG59IGZyb20gJy4vd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUnO1xuaW1wb3J0IHtBV1NlY3Rpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zZWN0aW9uL3NlY3Rpb24ubW9kdWxlJztcbmltcG9ydCB7QVdTdGVwcGVyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FXVGV4dEFyZWFNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy90ZXh0LWFyZWEvdGV4dC1hcmVhLm1vZHVsZSc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0Zvcm1UYWJsZU1vZHVsZX0gZnJvbSAnLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS10YWJsZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0xpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9saXN0L2xpc3QubW9kdWxlJztcbmltcG9ydCB7QVdDYXJkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZSc7XG5pbXBvcnQge0FXRGF0YXRhYmxlMk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5tb2R1bGUnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge01vZGFsU2VydmljZX0gZnJvbSAnLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwuc2VydmljZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0Vycm9yTWFuYWdlclNlcnZpY2V9IGZyb20gJy4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHtBd05hbWVTdG9yZX0gZnJvbSAnLi9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZSc7XG5pbXBvcnQge0RhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1dpemFyZFByb2dyZXNzTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvd2l6YXJkLXByb2dyZXNzL3dpemFyZC1wcm9ncmVzcy5tb2R1bGUnO1xuaW1wb3J0IHtUb2dnbGVTd2l0Y2hNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy90b2dnbGUtc3dpdGNoL3RvZ2dsZS1zd2l0Y2gubW9kdWxlJztcblxuLyoqXG4gKiBDb21wb25lbnQgbW9kdWxlIGlzIGNvcmUgbW9kdWxlIGZvciB0aGUgY29tbW9uIGxheW91dHMgYW5kIHdpZGdldHMgbGlicmFyaWVzLlxuICpcbiAqIHRvZG86IFRoZXJlIGFyZSBzb21lIHRoaW5ncyB0aGF0IEkgc3RpbGwgbmVlZCB0byByZXNvbHZlIC0gcGxlYXNlIHNlZSBhbmQgbm90aWNlcyBARHVwbGljYXRlc1xuICoganNkb2MgSSB3YW50IHRvIGtlZXAgdGhpcyB0aGVyZSB0byByZW1pbmQgbWUgdGhhdCBJIG5lZWQgdG8gcmVmYWN0b3IgdGhpcyBhcyBvZiBub3cgdGhlcmUgYXJlXG4gKiBub3QgbXVjaCBvcHRpb24gd2l0aCBhbmd1bGFyLlxuICpcbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEFyaWJhQ29yZU1vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcblxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXQmFzaWNOYXZpZ2F0b3JNb2R1bGUsXG4gICAgICAgIEFXQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveExpc3RNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgIEFXQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdDb25maXJtYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXQ3VycmVuY3lNb2R1bGUsXG4gICAgICAgIEFXRGF0ZUFuZFRpbWVNb2R1bGUsXG4gICAgICAgIEFXRGlhbG9nTW9kdWxlLFxuICAgICAgICBBV0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdJbnB1dEZpZWxkTW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlLFxuICAgICAgICBBV1BhZ2VXcmFwcGVyTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZSxcbiAgICAgICAgQVdSaWNoVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZSxcbiAgICAgICAgQVdTZWN0aW9uTW9kdWxlLFxuICAgICAgICBBV1N0ZXBwZXJNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXRm9ybVRhYmxlTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdIb3ZlckNhcmRNb2R1bGUsXG4gICAgICAgIEFXTGlzdE1vZHVsZSxcbiAgICAgICAgQVdEYXRhdGFibGUyTW9kdWxlLFxuICAgICAgICBXaXphcmRQcm9ncmVzc01vZHVsZSxcbiAgICAgICAgVG9nZ2xlU3dpdGNoTW9kdWxlLFxuXG4gICAgICAgIC8vIFByaW1lTkcgcmVtb3ZlIHdoZW4gYWxsIEFXIGFyZSBpbXBvcnRlZFxuICAgICAgICBQYW5lbE1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dGFyZWFNb2R1bGUsXG4gICAgICAgIEF1dG9Db21wbGV0ZU1vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZSxcbiAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIFNoYXJlZE1vZHVsZSxcbiAgICAgICAgRGlhbG9nTW9kdWxlLFxuICAgICAgICBNZW51TW9kdWxlLFxuICAgICAgICBUYWJNZW51TW9kdWxlLFxuICAgICAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgRGF0YVRhYmxlTW9kdWxlLFxuICAgICAgICBQYWdpbmF0b3JNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZSxcbiAgICAgICAgVHJlZU1vZHVsZVxuXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUsXG4gICAgICAgIC8vIDN0aCBwYXJ0eSBkZWNsYXJhdGlvblxuICAgIF0sXG4gICAgYm9vdHN0cmFwOiBbXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcblxuICAgICAgICAvLyBQcmltZU5HXG4gICAgICAgIENoZWNrYm94LFxuICAgICAgICBEaWFsb2dcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFNweUxpZmVDeWNsZUhvb2tzRGlyZWN0aXZlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXQmFzaWNOYXZpZ2F0b3JNb2R1bGUsXG4gICAgICAgIEFXQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveExpc3RNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgIEFXQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdDb25maXJtYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXQ3VycmVuY3lNb2R1bGUsXG4gICAgICAgIEFXRGF0ZUFuZFRpbWVNb2R1bGUsXG4gICAgICAgIEFXRGlhbG9nTW9kdWxlLFxuICAgICAgICBBV0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdJbnB1dEZpZWxkTW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlLFxuICAgICAgICBBV1BhZ2VXcmFwcGVyTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZSxcbiAgICAgICAgQVdSaWNoVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZSxcbiAgICAgICAgQVdTZWN0aW9uTW9kdWxlLFxuICAgICAgICBBV1N0ZXBwZXJNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXRm9ybVRhYmxlTW9kdWxlLFxuICAgICAgICBFbWJlZGRlZEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0hvdmVyQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdMaXN0TW9kdWxlLFxuICAgICAgICBBV0RhdGF0YWJsZTJNb2R1bGUsXG4gICAgICAgIFdpemFyZFByb2dyZXNzTW9kdWxlLFxuICAgICAgICBUb2dnbGVTd2l0Y2hNb2R1bGUsXG5cbiAgICAgICAgLy8gUHJpbWVOR1xuICAgICAgICBTaGFyZWRNb2R1bGUsXG4gICAgICAgIFBhbmVsTW9kdWxlLFxuICAgICAgICBCdXR0b25Nb2R1bGUsXG4gICAgICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlLFxuICAgICAgICBSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgRGlhbG9nTW9kdWxlLFxuICAgICAgICBNZW51TW9kdWxlLFxuICAgICAgICBUYWJNZW51TW9kdWxlLFxuICAgICAgICBFZGl0b3JNb2R1bGUsXG4gICAgICAgIERhdGFUYWJsZU1vZHVsZSxcbiAgICAgICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgICAgICBPdmVybGF5UGFuZWxNb2R1bGVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFyaWJhQ29tcG9uZW50c01vZHVsZVxue1xuXG5cbiAgICBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzXG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFyaWJhQ29tcG9uZW50c01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1vZGFsU2VydmljZSxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBFcnJvck1hbmFnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBEYXRhRmluZGVycyxcbiAgICAgICAgICAgICAgICBBd05hbWVTdG9yZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcmVnaXN0ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbQ29tcG9uZW50UmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRzKGNvbXBSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnkpOiBGdW5jdGlvblxue1xuICAgIHJldHVybiBjb21wUmVnaXN0cnkuaW5pdGlhbGl6ZS5iaW5kKGNvbXBSZWdpc3RyeSwgY29tcG9uZW50cyk7XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FQUF9JTklUSUFMSVpFUiwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi9lbnRyeS1jb21wb25lbnRzJztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtNb2RhbFNlcnZpY2V9IGZyb20gJy4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZXJyb3ItbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7QXdOYW1lU3RvcmV9IGZyb20gJy4vY29yZS9hdy1uYW1lL2F3LW5hbWUuc3RvcmUnO1xuaW1wb3J0IHtEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG5cbi8qKlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIHVzZWQgbWFpbmx5IGZvciB0ZXN0cyBhcyBpbXBvcnRpbmcgYSBtb2R1bGUgd2l0aCBhbGwgdGhlIGNvbXBvbmVudHMgYW5kIHlvdVxuICogdXNlIG9ubHkgMSBvciB0d28gaGFzIGEgYmlnIGltcGFjdCBvbiB0aGUgcGVyZm9ybWFuY2UgZXhlY3V0aW9uLiBlLmcuIGZyb20gZXhlY3V0aW5nIGNvdXBsZVxuICogdGVzdHMgdW5kZXIgMSBzZWMgY2FuIGdvIHVwIHRvIDEwc2VjIGlmIHlvdSBpbXBvcnQgYWxsIHRoZSB0aGluZ3MgdGhhdCB5b3UgYXJlIG5vdCB1c2luZy5cbiAqXG4gKiBJIGhhdmVudCBub3RpY2VkIGFueXRoaW5nIHNpbWlsYXIgaW4gYXBwbGljYXRpb24gaXRzIG9ubHkgamFzbWluZS9rYXJtYSB0aGF0IG5lZWRzIHRvIGluaXRcbiAqIGNvbXBvbmVudHMgZm9yIGV2ZXJ5IHRlc3QuXG4gKlxuICovXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFyaWJhQ29tcG9uZW50c1Rlc3RQcm92aWRlck1vZHVsZSB7XG5cblxuICAgIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFyaWJhQ29tcG9uZW50c1Rlc3RQcm92aWRlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1vZGFsU2VydmljZSxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBFcnJvck1hbmFnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBEYXRhRmluZGVycyxcbiAgICAgICAgICAgICAgICBBd05hbWVTdG9yZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcmVnaXN0ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbQ29tcG9uZW50UmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRzKGNvbXBSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnkpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuIGNvbXBSZWdpc3RyeS5pbml0aWFsaXplLmJpbmQoY29tcFJlZ2lzdHJ5LCBjb21wb25lbnRzKTtcbn1cblxuXG4iXSwibmFtZXMiOlsib2JzZXJ2YWJsZU9mIiwiSW5wdXRUZXh0TW9kdWxlIiwic3RhdGUiLCJEaWFsb2dNb2R1bGUiLCJyZWdpc3RlckNvbXBvbmVudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0VBOzs7O0lBa0JJLFlBQW9CLGNBQWdDO1FBQWhDLG1CQUFjLEdBQWQsY0FBYyxDQUFrQjtLQUVuRDs7Ozs7SUFaRCxJQUNJLElBQUksQ0FBQyxJQUFTO1FBRWQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7S0FDOUI7Ozs7OztJQWFELFdBQVcsQ0FBQyxPQUFzQjtRQUU5QixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7U0FDMUU7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUU7O1lBQzlCLElBQUksT0FBTyxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxPQUFPLENBQUMsQ0FBQztTQUN0RjtLQUNKOzs7WUFwQ0osU0FBUyxTQUFDLEVBQUMsUUFBUSxFQUFFLGdCQUFnQixFQUFDOzs7O1lBeERuQyxnQkFBZ0I7OzsyQkE4RGYsS0FBSzttQkFHTCxLQUFLOzs7Ozs7QUFtQ1Y7Ozs7SUFFSSxZQUFtQixTQUFjO1FBQWQsY0FBUyxHQUFULFNBQVMsQ0FBSztLQUVoQztDQUNKOzs7Ozs7QUNoSEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCQTs7Ozs7O0lBZ0NJLFlBQW9CLFFBQW1CLEVBQVUsT0FBbUI7UUFBaEQsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFFaEUsSUFBSSxDQUFDLGFBQWEsR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDO0tBQzlDOzs7OztJQUtELFFBQVE7O1FBR0osSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDakQsTUFBTSxJQUFJLEtBQUssQ0FBQyxzREFBc0Q7Z0JBQ2xFLG9CQUFvQixDQUFDLENBQUM7U0FDN0I7O1FBR0QsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDNUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUMsT0FBTyxHQUFHLHlCQUF5QixDQUFDLGNBQWMsQ0FBQzthQUMzRDtTQUNKOztRQUdELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7UUFDbEQsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ25COzs7O0lBRUQsU0FBUztRQUdMLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDNUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLEtBQUssSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLEVBQUU7WUFFaEUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUNoRTtLQUNKOzs7Ozs7O0lBUU8sUUFBUTs7UUFFWixNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDckQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLENBQUM7U0FDckQ7O1FBR0QsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFFNUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUNwQyxDQUFDLENBQUM7O1FBR0gsRUFBRSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7Ozs7MkNBcEZMLEtBQUs7O1lBWnpDLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsc0JBQXNCO2dCQUNoQyxRQUFRLEVBQUUsMkJBQTJCO2FBRXhDOzs7O1lBNUJzRCxTQUFTO1lBQXBDLFVBQVU7Ozt1QkF5Q2pDLEtBQUs7c0JBTUwsS0FBSzs7Ozs7OztBQy9DVjs7Ozs7QUFRQTs7OztJQStESSxZQUFtQixHQUFpQjtRQUFqQixRQUFHLEdBQUgsR0FBRyxDQUFjOzs7Ozt3QkF2RGhCLEtBQUs7Ozs7O3VCQVFOLEtBQUs7Ozs7O3dCQU9ILElBQUk7Ozs7OzJCQTBCWCxLQUFLOzs7OzJCQVlHLFFBQVE7UUFJMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO1FBQzFDLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO0tBQzVCOzs7O0lBR0QsUUFBUTtRQUVKLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQy9EOzs7OztJQUdELFdBQVcsQ0FBQyxPQUFzQjtLQUVqQzs7OztJQUdELFNBQVM7S0FFUjs7OztJQUdELFdBQVc7S0FFVjs7O3VCQWpGQSxLQUFLO3NCQVFMLEtBQUs7dUJBT0wsS0FBSztvQkFPTCxLQUFLO3FCQU1MLEtBQUs7eUJBTUwsS0FBSzswQkFPTCxLQUFLOzs7Ozs7O0FDeERWOztJQWlCSSxTQUFVO0lBQ1YsUUFBUztJQUNULFNBQVU7SUFDVixRQUFTO0lBQ1QsVUFBVzs7b0NBSlgsTUFBTTtvQ0FDTixLQUFLO29DQUNMLE1BQU07b0NBQ04sS0FBSztvQ0FDTCxNQUFNOzs7Ozs7QUFRVix1QkFBd0MsU0FBUSxhQUFhOzs7Ozs7Ozs7OztJQThGekQsWUFBeUMsR0FBZ0IsRUFFbEMsZUFBa0M7UUFFckQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBSjBCLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFFbEMsb0JBQWUsR0FBZixlQUFlLENBQW1COzs7OztzQkFqRXZDLEtBQUs7Ozs7O3dCQWVILEtBQUs7Ozs7MkJBT0gsRUFBRTs7Ozs7Ozs0QkFTQSxJQUFJOzhCQW9CaUIsSUFBSTs4QkFDSixJQUFJO0tBZ0JoRDs7OztJQUdELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFakIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUM7WUFDaEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQztTQUNqRDtRQUVELElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztLQUN4Qjs7Ozs7O0lBT1MsYUFBYTtRQUduQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxHQUFHLElBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQzVDOzs7Ozs7UUFPRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDcEIsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLEVBQUUsQ0FBQztTQUN0QjtRQUVELElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtZQUNsQixJQUFJLENBQUMsRUFBRSxHQUFHLElBQUksRUFBRSxDQUFDO1NBQ3BCO0tBRUo7Ozs7OztJQUVTLFVBQVUsQ0FBRSxJQUFZLEVBQUUsS0FBVTs7UUFHMUMsSUFBSSxRQUFRLENBQWM7UUFFMUIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRTtZQUN4QyxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM3RCxRQUFRLHFCQUFpQixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQSxDQUFDO1NBRTFEO2FBQU07WUFDSCxRQUFRLHFCQUFpQixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQSxDQUFDOztZQUN2RCxJQUFJLFlBQVksR0FBUSxTQUFTLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQzNFLFFBQVEsQ0FBQyxVQUFVLENBQUMsWUFBWSxFQUFFLEVBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFDLENBQUMsQ0FBQztTQUN6RTtRQUNELE9BQU8sUUFBUSxDQUFDO0tBQ25COzs7Ozs7OztJQVNELG1CQUFtQixDQUFFLEtBQVU7UUFFM0IsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFckQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUM5QjtLQUNKOzs7O0lBR0QsSUFBYSxTQUFTO1FBRWxCLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO0tBQzlFOzs7OztJQUVELElBQUksU0FBUyxDQUFFLEtBQWdCO1FBRTNCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO0tBQzNCOzs7Ozs7OztJQVFELFVBQVU7UUFFTixPQUFPLEtBQUssQ0FBQztLQUNoQjs7Ozs7SUFHRCxVQUFVLENBQUUsS0FBVTtLQUdyQjs7Ozs7SUFFRCxnQkFBZ0IsQ0FBRSxFQUFPO1FBRXJCLElBQUksQ0FBQyxjQUFjLEdBQUcsRUFBRSxDQUFDO0tBQzVCOzs7OztJQUVELGlCQUFpQixDQUFFLEVBQU87UUFFdEIsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7S0FDNUI7Ozs7Ozs7O2tDQTFNK0IsU0FBUztpQ0FDVixRQUFROzs7WUF0Q25DLFdBQVcsdUJBMkhELE1BQU0sU0FBQyxXQUFXO1lBRVEsaUJBQWlCLHVCQUQzQyxRQUFRLFlBQUksUUFBUSxZQUFJLE1BQU0sU0FBQyxVQUFVLENBQUMsTUFBTSxpQkFBaUIsQ0FBQzs7O21CQWhGL0UsS0FBSztpQkFPTCxLQUFLO3FCQVFMLEtBQUs7dUJBZUwsS0FBSzswQkFPTCxLQUFLOzJCQVNMLEtBQUs7d0JBa0hMLEtBQUs7Ozs7Ozs7QUM1TVY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9EQSxxQkFBNkIsU0FBUSxpQkFBaUI7Ozs7OztJQVNsRCxZQUFtQixHQUFnQixFQUFVLFNBQXVCLEVBRTlDLGVBQWtDO1FBRXBELEtBQUssQ0FBQyxHQUFHLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFKYixRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQVUsY0FBUyxHQUFULFNBQVMsQ0FBYztRQUU5QyxvQkFBZSxHQUFmLGVBQWUsQ0FBbUI7Ozs7O3NCQUwvQixFQUFFO0tBUzFCOzs7OztJQUdELElBQ0ksS0FBSyxDQUFDLEtBQVU7UUFFaEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUM7S0FDdkI7Ozs7SUFFRCxJQUFJLEtBQUs7UUFFTCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzlEOzs7WUFsQ0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxXQUFXO2dCQUNyQixRQUFRLEVBQUU7O0tBRVQ7O2FBRUo7Ozs7WUFoRE8sV0FBVztZQUZYLFlBQVk7WUFDWixpQkFBaUIsdUJBNERSLFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGlCQUFpQixDQUFDOzs7b0JBUTlFLEtBQUs7Ozs7Ozs7QUN0RVY7Ozs7QUFTQTs7OztJQUlJLFlBQW9CLEdBQWdCO1FBQWhCLFFBQUcsR0FBSCxHQUFHLENBQWE7MkJBRkksSUFBSSxHQUFHLEVBQWU7S0FJN0Q7Ozs7O0lBR0QsVUFBVSxDQUFDLFVBQWU7UUFFdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQzs7UUFDL0IsSUFBSSxPQUFPLEdBQWlCLElBQUksT0FBTyxDQUFDLENBQUMsT0FBWTtZQUVqRCxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDakIsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxPQUFPLENBQUM7S0FFbEI7Ozs7OztJQUdELFlBQVksQ0FBQyxJQUFZLEVBQUUsSUFBUztRQUVoQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3BDO0tBQ0o7Ozs7O0lBR0QsYUFBYSxDQUFDLFVBQWU7UUFFekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUMxQixPQUFPO1NBQ1Y7UUFFRCxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQVk7WUFFekMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDN0MsQ0FBQyxDQUFDO0tBQ047Ozs7SUFHRCxJQUFJLFVBQVU7UUFFVixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7S0FDM0I7OztZQTlDSixVQUFVOzs7O1lBUEgsV0FBVzs7Ozs7OztBQ0RuQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5RkE7Ozs7Ozs7SUF5REksWUFBbUIsYUFBK0IsRUFDL0IsaUJBQ0EsSUFDQTtRQUhBLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixvQkFBZSxHQUFmLGVBQWU7UUFDZixPQUFFLEdBQUYsRUFBRTtRQUNGLGlCQUFZLEdBQVosWUFBWTs7Ozs7O29DQXJCRSxLQUFLOzs7Ozs7bUNBUWxDLElBQUksR0FBRyxFQUE4QjtRQWdCckMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO0tBQzFDOzs7O0lBRUQsUUFBUTtRQUdKLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUM7Ozs7UUFJakMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztLQUM1Qjs7Ozs7SUFHRCxXQUFXLENBQUMsT0FBc0I7UUFFOUIsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQ3pCLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ2xFLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFLENBQUM7WUFDM0IsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7U0FDNUI7S0FDSjs7OztJQUdELGtCQUFrQjtRQUVkLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxLQUFLLENBQUM7S0FDckM7Ozs7SUFHRCxlQUFlOzs7UUFJWCxJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQztRQUNqQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsQ0FBQztLQUNwQzs7OztJQUdELGtCQUFrQjtLQUVqQjs7Ozs7Ozs7SUFRUyx5QkFBeUI7S0FFbEM7Ozs7Ozs7Ozs7SUFVUyxpQkFBaUI7UUFFdkIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7O1FBR3pCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGtCQUFrQixFQUFFLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs7O1FBSXBGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUM7Ozs7OztZQVE1QixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7U0FDbEIsQ0FBQyxDQUFDO0tBQ047Ozs7OztJQU9TLGlCQUFpQjs7UUFFdkIsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDMUMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0tBQzdGOzs7Ozs7Ozs7Ozs7O0lBZVMseUJBQXlCOztRQUcvQixJQUFJLGFBQWEsR0FBRyxLQUFLLENBQUM7O1FBQzFCLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQzs7UUFDakMsSUFBSSxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUMvQyxJQUFJLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBRTs7WUFDdEIsSUFBSSxrQkFBa0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLHVCQUF1QixDQUFDLGVBQWUsQ0FBQyxDQUFDOztZQUN2RixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUUxRSxtQkFBa0IsU0FBUyxDQUFDLFFBQVEsR0FBRSxLQUFLLEdBQUcsU0FBUyxDQUFDOztZQUN4RCxJQUFJLGtCQUFrQixHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztZQUNqRixrQkFBa0IsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUVqRSxhQUFhLEdBQUcsSUFBSSxDQUFDO1NBQ3hCO2FBQU0sSUFBSSxTQUFTLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxDQUV2QztRQUVELE9BQU8sYUFBYSxDQUFDO0tBQ3hCOzs7Ozs7OztJQVNTLFNBQVM7O1FBRWYsSUFBSSxPQUFPLENBQU07UUFDakIsSUFBSSxTQUFTLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUU7WUFDN0UsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMseUJBQXlCLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDN0Q7UUFDRCxPQUFPLE9BQU8sQ0FBQztLQUNsQjs7OztJQUdTLGdCQUFnQjs7UUFFdEIsSUFBSSxPQUFPLENBQU07UUFDakIsSUFBSSxTQUFTLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLHlCQUF5QixDQUFDLGdCQUFnQixDQUFDLENBQUMsRUFBRTtZQUNwRixJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1NBQ3BFO1FBQ0QsT0FBTyxPQUFPLENBQUM7S0FDbEI7Ozs7Ozs7Ozs7SUFVUyxrQkFBa0I7UUFFeEIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEVBQUU7WUFDdEMsT0FBTyxJQUFJLENBQUMsb0JBQW9CLENBQUM7U0FDcEM7O1FBQ0QsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7O1FBQzNDLElBQUksZ0JBQWdCLEdBQTBCLElBQUksQ0FBQyxlQUFlO2FBQzdELHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxDQUFDOztRQUV2QyxJQUFJLGFBQWEsR0FBYyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7UUFDdkUsSUFBSSxhQUFhLEdBQXVCO1lBQ3BDLFFBQVEsRUFBRSxhQUFhO1lBQ3ZCLG1CQUFtQixFQUFFLGdCQUFnQjtZQUNyQyxhQUFhLEVBQUUsUUFBUTtZQUN2QixhQUFhLEVBQUUsSUFBSSxDQUFDLElBQUk7U0FDM0IsQ0FBQztRQUVGLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxhQUFhLENBQUM7UUFDMUMsT0FBTyxhQUFhLENBQUM7S0FDeEI7Ozs7Ozs7OztJQU1TLGFBQWEsQ0FBQyxJQUF3QixFQUN4QixTQUE0QixFQUM1QixRQUEwQjs7UUFFOUMsSUFBSSxNQUFNLEdBQWEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7UUFFNUMsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDeEMsT0FBTztTQUNWOztRQUVELFVBQVUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFHdkMsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNsQyxTQUFTLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUM3QjtTQUNKLENBQUMsQ0FBQztLQUNOOzs7Ozs7OztJQVVTLG9CQUFvQjs7UUFFMUIsSUFBSSxhQUFhLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUVoRSxJQUFJLE9BQU8sQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN4QixNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxJQUFJLEdBQUcsNERBQTREO2dCQUNsRix5QkFBeUIsQ0FBQyxDQUFDO1lBQy9CLE9BQU87U0FDVjtRQUNELE9BQU8sYUFBYSxDQUFDO0tBQ3hCOzs7OztJQUdTLGdCQUFnQixDQUFDLFdBQWtDOztRQUV6RCxJQUFJLFFBQVEsR0FBYztZQUN0QixNQUFNLEVBQUUsRUFBRTtZQUNWLE9BQU8sRUFBRSxFQUFFO1NBQ2QsQ0FBQztRQUVGLElBQUksU0FBUyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxXQUFXLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFFaEUsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUErQztnQkFFdkUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2FBQ3hDLENBQUMsQ0FBQztTQUNOO1FBRUQsSUFBSSxTQUFTLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUVsRSxXQUFXLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE1BQWdEO2dCQUV6RSxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUMsQ0FBQyxDQUFDO1NBQ047UUFDRCxPQUFPLFFBQVEsQ0FBQztLQUNuQjs7OztJQUdELFdBQVc7UUFFUCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUNsQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDaEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFNBQVMsQ0FBQztTQUNyQztRQUVELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQzlCO0tBRUo7Ozs7SUFFTyxPQUFPO1FBRVgsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDbEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztZQUM3QixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDO1NBQ3BDOzs7c0NBM1V1QixXQUFXOzZDQUNKLGtCQUFrQjs7WUFSeEQsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxzQkFBc0I7YUFDbkM7Ozs7WUF6RUcsZ0JBQWdCO1lBUmhCLHdCQUF3QjtZQUh4QixpQkFBaUI7WUFnQmIsaUJBQWlCOzs7bUJBd0ZwQixLQUFLO3VCQU1MLEtBQUs7Ozs7Ozs7QUNsSFY7Ozs7Ozs7OztBQWFBO0lBSUk7UUFFSSxJQUFJLENBQUMsUUFBUSxHQUFHO1lBQ1osVUFBVSxFQUFFLGdCQUFnQjtZQUM1QixXQUFXLEVBQUUsb0NBQW9DO1lBQ2pELFdBQVcsRUFBRSxvQ0FBb0M7WUFDakQsV0FBVyxFQUFFLElBQUk7WUFDakIsV0FBVyxFQUFFLElBQUk7U0FDcEIsQ0FBQztLQUNMOzs7Ozs7SUFHRCxZQUFZLENBQUMsYUFBcUIsRUFBRSxjQUFvQjs7UUFFcEQsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUMzQyxJQUFJLGFBQWEsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxFQUFFOztZQUd2QyxPQUFPLGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbkU7UUFDRCxPQUFPLE9BQU8sQ0FBQztLQUNsQjs7O1lBMUJKLFVBQVU7Ozs7Ozs7OztBQ1pYOzs7Ozs7O0FBd0JBOzs7O0lBVUksWUFBb0IsVUFBK0I7UUFBL0IsZUFBVSxHQUFWLFVBQVUsQ0FBcUI7S0FFbEQ7Ozs7SUFFRCxRQUFRO0tBR1A7Ozs7SUFHRCxVQUFVOztRQUVOLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDeEIsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDekI7Ozs7OztJQU1ELElBQUksUUFBUTtRQUVSLEtBQUssSUFBSSxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUU7WUFDMUMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7Z0JBQzFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsWUFBWSxFQUM1QyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2FBQzFDO1NBQ0o7S0FDSjs7Ozs7Ozs7SUFRRCxVQUFVO1FBRU4sT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUM7S0FDaEY7OztZQTdESixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGtCQUFrQjtnQkFDNUIsUUFBUSxFQUFFOzs7Ozs7O0tBT1Q7O2FBRUo7Ozs7WUFwQk8sbUJBQW1COzs7c0JBMkJ0QixLQUFLOzs7Ozs7O0FDOUJWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOERBOzs7Ozs7SUEwQkksWUFBb0IsR0FBNkI7UUFBN0IsUUFBRyxHQUFILEdBQUcsQ0FBMEI7S0FFaEQ7Ozs7Ozs7SUFPRCx3QkFBd0IsQ0FBQyxLQUF1QjtRQUU1QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztLQUN0Qjs7Ozs7Ozs7O0lBTUQsSUFBSSxDQUFJLFNBQWtCLEVBQUUsVUFBZ0I7O1FBRXhDLE1BQU0sRUFBRSxHQUF3QixJQUFJLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLFNBQVMsQ0FBQyxDQUFDOztRQUM1RSxJQUFJLFlBQVksR0FBb0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDLENBQUM7O1FBR25FLFVBQVUsR0FBRyxDQUFDLFVBQVUsSUFBSSxVQUFVLEdBQUcsRUFBRSxDQUFDO1FBQzVDLFVBQVUsQ0FBQyxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUM7O1FBRzdCLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLO1lBRXpDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUNuQixtQkFBTSxZQUFZLENBQUMsUUFBUSxHQUFFLEtBQUssQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDakUsT0FBTyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDNUI7U0FDSixDQUFDLENBQUM7UUFFSCxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7OztRQUlqRCxtQkFBTSxZQUFZLENBQUMsUUFBUSxHQUFFLFNBQVMsQ0FBQyxHQUFHO1lBRXRDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUMxQixDQUFDOztRQUVGLElBQUksQ0FBQyxRQUFRLEdBQUcsWUFBWSxDQUFDO1FBRTdCLE9BQU8sWUFBWSxDQUFDO0tBQ3ZCOzs7OztJQUtELEtBQUs7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDZixJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQ3hCO0tBQ0o7Ozs7Ozs7aUNBOUU0QyxDQUFDLFNBQVMsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDOztZQVJwRixVQUFVOzs7O1lBM0RQLHdCQUF3Qjs7Ozs7OztBQ0Y1Qjs7OztBQWFBOzs7O0lBTUksWUFBb0IsWUFBMEI7UUFBMUIsaUJBQVksR0FBWixZQUFZLENBQWM7S0FFN0M7Ozs7SUFFRCxRQUFRO1FBRUosSUFBSSxDQUFDLFlBQVksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztLQUNyRTs7O1lBbEJKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsVUFBVTtnQkFDcEIsZ0NBQW1DOzthQUV0Qzs7OztZQVhPLFlBQVk7OzsrQkFlZixTQUFTLFNBQUMsT0FBTyxFQUFFLEVBQUMsSUFBSSxFQUFFLGdCQUFnQixFQUFDOzs7Ozs7O0FDaEJoRDs7OztBQVdBOzs7O0lBR0ksWUFBb0IsWUFBMEI7UUFBMUIsaUJBQVksR0FBWixZQUFZLENBQWM7S0FFN0M7Ozs7OztJQUVELFNBQVMsQ0FBQyxLQUFhLEVBQUUsR0FBRyxJQUFXOztRQUluQyxJQUFJLFlBQVksR0FBRyxLQUFLLENBQXlDOztRQUFqRSxJQUEwQixhQUFhLEdBQUcsSUFBSSxDQUFtQjs7UUFBakUsSUFBZ0QsTUFBTSxHQUFHLE9BQU8sQ0FBQztRQUVqRSxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzlCLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBRUQsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O1lBQ3pCLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNuQixJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDekIsWUFBWSxHQUFHLElBQUksQ0FBQzthQUN2QjtTQUNKO1FBRUQsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUNsRjs7O1lBN0JKLElBQUksU0FBQztnQkFDRixJQUFJLEVBQUUsZ0JBQWdCO2dCQUN0QixJQUFJLEVBQUUsS0FBSzthQUNkOzs7O1lBVk8sWUFBWTs7Ozs7OztBQ0ZwQjs7OztBQVVBO0lBTUk7c0JBRjRCLElBQUksWUFBWSxFQUFPO0tBSWxEOzs7O0lBRUQsUUFBUTtRQUVKLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzFCOzs7WUFoQkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxZQUFZO2FBQ3pCOzs7OztxQkFJSSxNQUFNOzs7Ozs7O0FDWFg7Ozs7O0FBVUE7SUFHSTtLQUVDOzs7Ozs7OztJQU1ELFNBQVMsQ0FBRSxhQUFrQixFQUFFLFFBQWdCO1FBRTNDLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7S0FDM0Q7Ozs7Ozs7OztJQVFELE9BQU8sQ0FBRSxhQUFrQixFQUFFLFFBQWdCOztRQUV6QyxJQUFJLFNBQVMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDOztRQUVuQyxJQUFJLFVBQVUsR0FBRyxhQUFhLENBQUM7UUFHL0IsT0FBTyxTQUFTLEVBQUUsVUFBVSxHQUFHLFVBQVUsQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUNwRCxJQUFJLFNBQVMsS0FBSyxHQUFHLElBQUksVUFBVSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUN4RSxPQUFPLFVBQVUsQ0FBQzthQUNyQjtZQUVELElBQUksU0FBUyxLQUFLLEdBQUcsSUFBSSxVQUFVLENBQUMsRUFBRSxLQUFLLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzNELE9BQU8sVUFBVSxDQUFDO2FBQ3JCOztZQUdELElBQUksVUFBVSxDQUFDLFFBQVEsS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsS0FBSyxRQUFRLEVBQUU7Z0JBQzVFLE9BQU8sVUFBVSxDQUFDO2FBQ3JCO1lBRUQsSUFBSSxVQUFVLENBQUMsUUFBUSxLQUFLLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxLQUFLLE1BQU0sRUFBRTtnQkFDNUQsT0FBTyxJQUFJLENBQUM7YUFDZjtTQUNKO1FBQ0QsT0FBTyxJQUFJLENBQUM7S0FDZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQStDRCx5QkFBeUIsQ0FBRSxjQUFtQixFQUFFLGFBQWtCOztRQUc5RCxJQUFJLGVBQWUsR0FBRyxjQUFjLENBQUM7O1FBRXJDLElBQUksY0FBYyxHQUFHLGNBQWMsQ0FBQyxhQUFhLENBQUMsY0FBYyxDQUFDLENBQUM7UUFDbEUsSUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDLEVBQUU7O1lBRTNCLGVBQWUsR0FBRyxjQUFjLENBQUM7U0FDcEM7UUFDRCxlQUFlLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0tBRTlDOzs7Ozs7O0lBUUQsaUJBQWlCO1FBRWIsT0FBTztZQUNILEtBQUssR0FBRyxNQUFNLENBQUMsVUFBVSxJQUFJLFFBQVEsQ0FBQyxlQUFlLENBQUMsV0FBVzttQkFDMUQsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDakMsTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLElBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQyxZQUFZO21CQUM3RCxRQUFRLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQztTQUNyQyxDQUFDO0tBQ0w7Ozs7Ozs7O0lBUUQsaUJBQWlCLENBQUUsT0FBWTtRQUUzQixJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsRUFBRTtZQUMxQyxPQUFPLE9BQU8sQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1NBQzFDO1FBQ0QsT0FBTyxFQUFDLElBQUksRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBQyxDQUFDO0tBQ2xGOzs7WUExSUosVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNnRVg7Ozs7Ozs7SUFxRkksWUFBcUIsT0FBa0IsRUFBVSxLQUFhLEVBQ3pDLFVBQ0E7UUFGQSxZQUFPLEdBQVAsT0FBTyxDQUFXO1FBQVUsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUN6QyxhQUFRLEdBQVIsUUFBUTtRQUNSLFFBQUcsR0FBSCxHQUFHOzBCQXJGSCxDQUFDOzhCQUNHLENBQUM7b0JBRVgsS0FBSztzQkFDSCxDQUFDO3NCQUNELElBQUk7cUJBQ0osS0FBSzs7OztxQkFRTixhQUFhOzs7Ozs7O3NCQWtERCxJQUFJLFlBQVksRUFBTzs7Ozs7Ozt5QkFjL0IsQ0FBQzswQkFFQSxDQUFDO0tBU3JCOzs7Ozs7Ozs7Ozs7SUEvREQsSUFDSSxRQUFRO1FBRVIsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDO0tBQ3BCOzs7OztJQUVELElBQUksUUFBUSxDQUFFLEdBQVc7UUFFckIsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFDaEIsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1lBQ2hCLElBQUksQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1NBRXpDO2FBQU07WUFDSCxJQUFJLENBQUMsTUFBTSxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztTQUNuQjtLQUNKOzs7Ozs7OztJQU9ELElBQ0ksT0FBTyxDQUFFLFlBQXFCO1FBRTlCLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7S0FDN0I7Ozs7SUFzQ0QsUUFBUTtRQUVKLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUscUJBQXFCLENBQUMsQ0FBQztLQUUvRDs7Ozs7SUFFRCxTQUFTLENBQUUsRUFBTztRQUVkLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxhQUFhLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxjQUFjLEVBQUU7WUFDL0QsT0FBTztTQUNWOztRQUdELElBQUksSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRTs7WUFFdEMsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUMsU0FBUyxDQUFDOztRQUMvQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7O1FBRWpDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxNQUFNLENBQUM7O1FBQ3pELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQzFFLFNBQVMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBRXZFLElBQUksQ0FBQyxNQUFNLEVBQUU7O1lBRVQsT0FBTztTQUNWOztRQUNELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQzs7UUFDckUsSUFBSSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksR0FBRyxTQUFTLEdBQUcsU0FBUyxHQUFHLFNBQVMsQ0FBQzs7OztRQU0xRixJQUFJLG9CQUFvQixHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsRUFBRTtZQUM3RCxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7U0FFekI7YUFBTSxJQUFJLElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxJQUFJLFNBQVMsR0FBRyxTQUFTO2VBQzVELElBQUksQ0FBQyxVQUFVLEtBQUssSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUN2QyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztTQUMzQjtRQUNELElBQUksQ0FBQyxjQUFjLEdBQUcsU0FBUyxDQUFDO1FBQ2hDLE9BQU87S0FDVjs7Ozs7SUFLTyxjQUFjO1FBRWxCLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO1lBRVgsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLGFBQWEsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLGNBQWMsRUFBRTtnQkFDL0QsSUFBSSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUM7Z0JBRTNCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO29CQUNiLE1BQU0sRUFBRSxJQUFJO29CQUNaLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUztvQkFDckIsTUFBTSxFQUFFLElBQUksQ0FBQyxVQUFVO2lCQUMxQixDQUFDLENBQUM7O2dCQUVILElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQzthQUNyQztTQUNKLENBQUMsQ0FBQzs7Ozs7SUFJQyxnQkFBZ0I7UUFFcEIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7WUFFWCxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssYUFBYSxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssY0FBYyxFQUFFO2dCQUMvRCxJQUFJLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQzs7Z0JBRzNCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztnQkFFakMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7b0JBQ2IsTUFBTSxFQUFFLEtBQUs7b0JBQ2IsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTO29CQUNyQixNQUFNLEVBQUUsSUFBSSxDQUFDLFVBQVU7aUJBQzFCLENBQUMsQ0FBQzthQUNOO1NBQ0osQ0FBQyxDQUFDOzs7OztJQUlDLFNBQVM7UUFFYixRQUFRLE1BQU0sQ0FBQyxXQUFXLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUU7Ozs7Ozs7Ozs7Ozs7SUFhM0QsUUFBUTtRQUVKLElBQUksSUFBSSxDQUFDLEtBQUssS0FBSyxhQUFhLEVBQUU7WUFDOUIsT0FBTztTQUNWO1FBRUQsVUFBVSxDQUFDO1lBRVAsSUFBSSxDQUFDLEtBQUssR0FBRyxhQUFhLENBQUM7O1lBRzNCLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUM7U0FDNUIsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUNYOzs7Ozs7Ozs7OztJQVlELE1BQU0sQ0FBRSxZQUFxQjtRQUV6QixJQUFJLENBQUMsS0FBSyxJQUFJLFlBQVksR0FBRyxhQUFhLEdBQUcsY0FBYyxDQUFDLENBQUM7UUFDN0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUNwQzs7Ozs7O0lBS0QsYUFBYSxDQUFFLFlBQXFCO1FBRWhDLElBQUksSUFBSSxDQUFDLEtBQUssRUFBRTtZQUNaLElBQUksWUFBWSxFQUFFO2dCQUNkLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNkLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUM7d0JBRXpCLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ3hDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO3FCQUNsRCxDQUFDLENBQUM7aUJBQ047YUFDSjtpQkFBTTtnQkFFSCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7b0JBQ3hCLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO29CQUNsRCxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztpQkFDdEI7YUFDSjtTQUNKO0tBQ0o7Ozs7SUFHRCxTQUFTO1FBRUwsT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLGFBQWEsQ0FBQztLQUN2Qzs7OztJQUVELGtCQUFrQjtRQUVkLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQztRQUM5QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxlQUFlLENBQUM7UUFFekMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxLQUFLLGNBQWMsQ0FBQyxDQUFDO1FBRWxELElBQUksSUFBSSxDQUFDLFVBQVUsS0FBSyxDQUFDLEVBQUU7WUFDdkIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQ3pCO0tBQ0o7Ozs7O0lBS0QsV0FBVztRQUVQLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDN0I7OztZQTNSSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsc0pBQTJDOzthQUU5Qzs7OztZQTFDRyxTQUFTO1lBRlQsTUFBTTtZQU1GLGVBQWU7WUFYbkIsaUJBQWlCOzs7dUJBOEVoQixLQUFLO3NCQXdCTCxLQUFLO3FCQWFMLE1BQU07d0JBSU4sU0FBUyxTQUFDLGFBQWE7d0JBVXZCLEtBQUs7OztBQTRNVixNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUM7O0FBQ2hDLE1BQU0sY0FBYyxHQUFHLFVBQVUsQ0FBQzs7QUFDbEMsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDOzs7Ozs7QUMxWGhDO0lBT0k7UUFDSSxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7S0FDMUI7Ozs7OztJQUVELEdBQUcsQ0FBQyxJQUFZLEVBQUUsRUFBTztRQUNyQixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1NBQzFDO1FBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7S0FDbkM7Ozs7O0lBRUQsTUFBTSxDQUFDLElBQVk7UUFDZixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2xDOzs7OztJQUVELFFBQVEsQ0FBQyxJQUFZO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDL0I7Ozs7SUFFRCxLQUFLO1FBQ0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztLQUN0Qjs7O1lBMUJKLFVBQVU7Ozs7Ozs7OztBQ0ZYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrSEE7Ozs7OztJQVFJLFlBQ1ksSUFDQSxPQUNBO1FBRkEsT0FBRSxHQUFGLEVBQUU7UUFDRixVQUFLLEdBQUwsS0FBSztRQUNMLFdBQU0sR0FBTixNQUFNO3lCQUxVLEdBQUc7S0FNM0I7Ozs7SUFFSixRQUFRO1FBQ0EsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNyQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDM0MsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDM0Q7Ozs7SUFFTCxXQUFXO1FBQ1AsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ2hDOzs7Ozs7Ozs7SUFPRCxpQkFBaUIsQ0FBQyxJQUFZLEVBQUUsSUFBZ0I7UUFDNUMsSUFBSTtZQUNBLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM5QjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1IsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxHQUFHLE1BQU0sSUFBSSxzQkFBc0IsRUFBRSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDaEYsT0FBTztTQUNWO0tBQ0o7Ozs7Ozs7O0lBUUQsVUFBVSxDQUFDLElBQWdCOztRQUV2QixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDOztRQUd0QyxNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7O1FBR2pCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUMsSUFBSSxRQUFRLEVBQUU7WUFDVixLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3hCOztRQUdELElBQUksT0FBTyxLQUFLLFFBQVEsRUFBRTs7WUFDdEIsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1QyxJQUFJLFVBQVUsRUFBRTtnQkFDWixLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzFCO1NBQ0o7O1FBR0QsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQzs7UUFHcEIsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRTtZQUN2QixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7O1NBR3JDO2FBQU07O1lBRUgsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsRUFBRTtnQkFDekMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3ZDOztZQUdELElBQUksT0FBTyxLQUFLLFFBQVEsRUFBRTtnQkFDdEIsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFDMUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2lCQUNqRTthQUNKO1NBQ0o7O1FBRUQsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1YsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDakQ7UUFFRCxPQUFPLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ3JDOzs7Ozs7SUFNRCxVQUFVLENBQUMsSUFBZ0I7UUFDdkIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUNuRDs7Ozs7OztJQU9ELGFBQWEsQ0FBQyxJQUFnQjs7UUFDMUIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUM7O1FBQzNDLElBQUksRUFBRSxHQUFHLEVBQUUsQ0FBQztRQUNaLE9BQU8sTUFBTSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ2xCLElBQUksTUFBTSxDQUFDLEVBQUUsRUFBRTtnQkFDWCxFQUFFLEdBQUcsTUFBTSxDQUFDLEVBQUUsQ0FBQzthQUNsQjtZQUNELE1BQU0sR0FBRyxNQUFNLENBQUMsVUFBVSxDQUFDO1NBQzlCO1FBQ0QsT0FBTyxFQUFFLENBQUM7S0FDYjs7Ozs7O0lBTUQsYUFBYSxDQUFDLElBQWdCOztRQUMxQixNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztRQUM3QyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksTUFBTSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7S0FDM0Q7Ozs7O0lBRUQsa0JBQWtCLENBQUMsR0FBVztRQUMxQixPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0tBQ25DOzs7WUFySUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxVQUFVO2FBQ3ZCOzs7O1lBaEhHLFVBQVU7WUFXVixXQUFXO1lBSlgsU0FBUzs7O2tCQTRHUixLQUFLOzs7Ozs7O0FDaEdWOzs7WUFhQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLHFCQUFxQjtvQkFDckIseUJBQXlCO29CQUN6Qix5QkFBeUI7b0JBQ3pCLHNCQUFzQjtvQkFDdEIsY0FBYztvQkFDZCxrQkFBa0I7b0JBQ2xCLGlCQUFpQjtvQkFDakIsdUJBQXVCO29CQUN2QixlQUFlO2lCQUNsQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtpQkFDZjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IseUJBQXlCO29CQUN6QixjQUFjO2lCQUNqQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wscUJBQXFCO29CQUNyQix5QkFBeUI7b0JBQ3pCLHlCQUF5QjtvQkFDekIsc0JBQXNCO29CQUN0QixjQUFjO29CQUNkLGtCQUFrQjtvQkFDbEIsaUJBQWlCO29CQUNqQix1QkFBdUI7b0JBQ3ZCLGVBQWU7aUJBQ2xCO2FBQ0o7Ozs7Ozs7QUMzQ0Q7OztBQU1BLG9CQUE0QixTQUFRLGFBQWE7Ozs7SUFTN0MsWUFBbUIsR0FBZ0I7UUFFL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRkksUUFBRyxHQUFILEdBQUcsQ0FBYTs7Ozt1QkFIYixJQUFJO0tBTXpCOzs7Ozs7SUFPRCxVQUFVO1FBRU4sSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQ2xCO0NBQ0o7Ozs7OztBQzdCRDs7O0FBU0E7SUFlSTtRQUVJLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLEdBQUcsRUFBNkIsQ0FBQztRQUMvRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSxHQUFHLEVBQWUsQ0FBQztLQUNyRDs7Ozs7Ozs7Ozs7SUFRRCxnQkFBZ0IsQ0FBSSxNQUFXLEVBQUUsUUFBeUI7UUFFdEQsSUFBSSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRTtZQUM5RCxNQUFNLElBQUksS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7U0FDbEQ7O1FBRUQsSUFBSSxJQUFJLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztRQUN4RixJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQzs7UUFFNUMsSUFBSSxTQUFTLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM5QyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztLQUNqRDs7Ozs7Ozs7O0lBUUQsaUJBQWlCLENBQUksU0FBaUI7O1FBRWxDLElBQUksbUJBQW1CLEdBQUcsU0FBUyxDQUFDOztRQUNwQyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRXpELE9BQU8sU0FBUyxDQUFDLG1CQUFtQixDQUFDLEVBQUU7O1lBQ25DLElBQUksUUFBUSxHQUFvQixJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFFakYsSUFBSSxTQUFTLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ3JCLFFBQVEsQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDO2dCQUMxQixPQUFPLFFBQVEsQ0FBQzthQUNuQjs7WUFHRCxJQUFJLFNBQVMsQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDdkIsVUFBVSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUM7O2dCQUMvQyxJQUFJLFVBQVUsR0FBRyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7Z0JBQzFDLG1CQUFtQjtvQkFDZixDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLEtBQUssbUJBQW1CLElBQUksVUFBVTswQkFDcEUsSUFBSSxDQUFDO2FBQ2xCO2lCQUFNO2dCQUNILE9BQU8sSUFBSSxDQUFDO2FBQ2Y7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2Y7Ozs7Ozs7Ozs7SUFTRCxnQkFBZ0IsQ0FBSSxJQUFhOztRQUU3QixJQUFJLElBQUksR0FBVyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdEMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDekMsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUksSUFBSSxDQUFDLENBQUM7S0FDMUM7OztZQXZGSixVQUFVOzs7Ozs7Ozs7OztBQWdHWDs7Ozs7OzsyQkFZd0MsSUFBSSxlQUFlLENBQU0sRUFBRSxDQUFDOzs7Ozs7OztJQWdCaEUsYUFBYSxDQUFDLE1BQXlCO1FBRW5DLE9BQU8sQ0FBQyxDQUFDLENBQUM7S0FDYjs7Ozs7O0lBMkJELElBQUk7UUFFQSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDdEM7Ozs7OztJQU9ELE9BQU87UUFFSCxPQUFPLEtBQUssQ0FBQztLQUNoQjs7Ozs7O0lBT0QsUUFBUTtRQUVKLE9BQU8sS0FBSyxDQUFDO0tBQ2hCOzs7Ozs7OztJQU9ELE1BQU0sQ0FBQyxHQUFRO0tBRWQ7Ozs7Ozs7O0lBUUQsTUFBTSxDQUFDLEdBQVE7S0FHZDs7Ozs7OztJQU1ELEtBQUssQ0FBQyxNQUEyQjtLQUVoQztDQUNKOzs7Ozs7QUN0TkQ7Ozs7QUFRQSx1QkFBa0MsU0FBUSxZQUFlOzs7O0lBR3JELFlBQXVCLE1BQWdCO1FBRW5DLEtBQUssRUFBRSxDQUFDO1FBRlcsV0FBTSxHQUFOLE1BQU0sQ0FBVTtRQUduQyxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztRQUVsQixJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7UUFDakMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3RDOzs7OztJQUVELGFBQWEsQ0FBQyxNQUF5QjtRQUVuQyxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO0tBQ3BDOzs7OztJQUVELGFBQWEsQ0FBQyxNQUF5QjtRQUVuQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNqQixPQUFPLElBQUksQ0FBQyxhQUFhLENBQUM7U0FDN0I7O1FBQ0QsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztRQUU5QixJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7O1lBQ2xFLElBQUksTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7O1lBQ2xDLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFFaEMsSUFBSSxJQUFJLENBQUMsTUFBTSxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsRUFBRTtnQkFDaEMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLE1BQU0sR0FBRyxLQUFLLENBQUMsQ0FBQzthQUM3QztpQkFBTTtnQkFDSCxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2FBQzFDO1NBQ0o7UUFFRCxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUNsRTtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2Y7Ozs7O0lBR0QsS0FBSyxDQUFDLE1BQXdCO1FBRTFCLE9BQU9BLEVBQVksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7S0FDbkQ7Ozs7Ozs7Ozs7Ozs7SUFXTyxJQUFJLENBQUMsV0FBa0IsRUFBRSxHQUFXLEVBQUUsU0FBaUI7UUFFM0QsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQVUsRUFBRSxLQUFVOztZQUVwQyxJQUFJLE1BQU0sR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQzs7WUFDakQsSUFBSSxNQUFNLEdBQUcsU0FBUyxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7O1lBQ2pELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQztZQUVsQixJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtnQkFDbEMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO2FBQ2Y7aUJBQU0sSUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLE1BQU0sSUFBSSxJQUFJLEVBQUU7Z0JBQ3pDLE1BQU0sR0FBRyxDQUFDLENBQUM7YUFDZDtpQkFBTSxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtnQkFDekMsTUFBTSxHQUFHLENBQUMsQ0FBQzthQUNkO2lCQUFNLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtnQkFDakUsTUFBTSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDekM7aUJBQU07Z0JBQ0gsTUFBTSxHQUFHLENBQUMsTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUMvRDtZQUVELFFBQVEsU0FBUyxHQUFHLE1BQU0sRUFBRTtTQUMvQixDQUFDLENBQUM7O0NBRVY7Ozs7OztBQ3pGRDs7Ozs7OztBQWNBOzs7O0lBSUksWUFBb0IsUUFBa0M7UUFBbEMsYUFBUSxHQUFSLFFBQVEsQ0FBMEI7S0FFckQ7Ozs7Ozs7SUFNRCxJQUFJLENBQUMsTUFBVztRQUVaLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2pCLE9BQU8sSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN4QzthQUFNLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNsRDtRQUVELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNqRDs7Ozs7Ozs7O0lBT0QsUUFBUSxDQUFJLE1BQVcsRUFBRSxRQUF5QjtRQUU5QyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQztLQUNwRDs7O1lBaENKLFVBQVU7Ozs7WUFiVyx3QkFBd0I7Ozs7Ozs7QUNDOUM7Ozs7OztBQXlCQTtJQUtJOzZCQUYyRCxJQUFJLEdBQUcsRUFBRTtRQUloRSxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDdEI7Ozs7Ozs7SUFLRCxJQUFJLENBQUMsV0FBOEIsRUFBRSxPQUFrQjs7UUFHbkQsSUFBSSxXQUFXLENBQW1CO1FBQ2xDLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBbUIsRUFBRSxDQUFhO1lBRTFELElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsT0FBTyxDQUFDLEVBQUU7Z0JBQ2pDLFdBQVcsR0FBRyxDQUFDLENBQUM7Z0JBQ2hCLE9BQU8sSUFBSSxDQUFDO2FBQ2Y7U0FDSixDQUFDLENBQUM7UUFFSCxJQUFJLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRTs7WUFDeEIsSUFBSSxJQUFJLEdBQUcsSUFBSSxXQUFXLEVBQUUsQ0FBQztZQUM3QixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzFCLE9BQU8sSUFBSSxDQUFDO1NBRWY7UUFDRCxPQUFPLElBQUksQ0FBQztLQUNmOzs7Ozs7Ozs7SUFNRCxRQUFRLENBQUksU0FBcUIsRUFBRSxJQUFzQjtRQUVyRCxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDM0M7Ozs7SUFFTyxXQUFXOztRQUdmLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksdUJBQXVCLEVBQUUsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO1FBQy9FLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksOEJBQThCLEVBQUUsRUFDdkQsOEJBQThCLENBQUMsQ0FBQzs7OztZQWpEM0MsVUFBVTs7Ozs7O0lBNERQLFdBQVE7SUFDUixrQkFBZTtJQUNmLFlBQVM7SUFDVCx1QkFBb0I7O29CQUhwQixRQUFRO29CQUNSLGVBQWU7b0JBQ2YsU0FBUztvQkFDVCxvQkFBb0I7Ozs7O0FBT3hCOzs7Ozs7OztJQW9CSSxPQUFPLENBQUMsT0FBMEIsRUFBRSxPQUFrQjtRQUVsRCxPQUFPLEtBQUssQ0FBQztLQUNoQjs7Ozs7Ozs7Ozs7SUEwQkQsS0FBSyxDQUFJLEtBQVUsRUFBRSxNQUFjLENBQUMsQ0FBQztRQUVqQyxPQUFPLGFBQWEsRUFBRSxDQUFDO0tBQzFCOzs7Ozs7OztJQUVELG1CQUFtQixDQUFJLFVBQWlCLEVBQUUsS0FBVSxFQUFFLEdBQVc7UUFFN0QsT0FBTyxhQUFhLEVBQUUsQ0FBQztLQUMxQjtDQUNKOzs7Ozs7QUFRRCw2QkFBcUMsU0FBUSxVQUFVOzs7OztJQVluRCxJQUFJLFNBQVMsQ0FBQyxHQUFXO1FBRXJCLElBQUksQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztLQUM5RDs7Ozs7O0lBRUQsT0FBTyxDQUFDLE9BQTBCLEVBQUUsT0FBa0I7UUFFbEQsT0FBTyxPQUFPLFlBQVksaUJBQWlCLElBQUksT0FBTyxLQUFLLFNBQVMsQ0FBQyxRQUFRLENBQUM7S0FDakY7Ozs7O0lBRUQsT0FBTyxDQUFDLFFBQTJCO1FBRS9CLElBQUksQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO1FBQzFCLE9BQU8sSUFBSSxDQUFDO0tBQ2Y7Ozs7Ozs7SUFFRCxZQUFZLENBQUksS0FBVSxFQUFFLEdBQVc7UUFFbkMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsc0JBQXNCLENBQUMsQ0FBQzs7UUFFMUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDckUsT0FBTyxJQUFJLENBQUMsMEJBQTBCLENBQUksSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztLQUMvRDs7Ozs7Ozs7SUFFRCwwQkFBMEIsQ0FBSSxrQkFBeUIsRUFBRSxLQUFhLEVBQUUsR0FBVztRQUUvRSxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO1FBRTFELElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2hCLE9BQU8sa0JBQWtCLENBQUM7U0FDN0I7O1FBQ0QsSUFBSSxNQUFNLEdBQVUsRUFBRSxDQUFDOztRQUN2QixJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFekMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs7WUFDaEQsSUFBSSxJQUFJLEdBQUcsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDakMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsRUFBRTtnQkFDcEMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEIsSUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJLEdBQUcsRUFBRTtvQkFDdEIsTUFBTTtpQkFDVDthQUNKO1NBQ0o7UUFDRCxPQUFPLE1BQU0sQ0FBQztLQUNqQjs7Ozs7Ozs7Ozs7O0lBU0QsT0FBTyxDQUFJLElBQVMsRUFBRSxPQUFlOztRQUVqQyxJQUFJLEdBQUcsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ2hGLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ2pCLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3hCO2FBQU0sSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDekIsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsQ0FBQztTQUU3QzthQUFNO1lBQ0gsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDO2dCQUNuQixTQUFTLENBQUMsR0FBRyxDQUFDLElBQUksR0FBRyxDQUFDLFFBQVEsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM1RTtLQUNKOzs7Ozs7O0lBR0QsS0FBSyxDQUFJLEtBQVUsRUFBRSxHQUFXO1FBRTVCLE9BQU9BLEVBQVksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQ3REOzs7Ozs7OztJQUVELG1CQUFtQixDQUFJLFVBQWlCLEVBQUUsS0FBVSxFQUFFLEdBQVc7UUFFN0QsT0FBT0EsRUFBWSxDQUFDLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxVQUFVLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7S0FDaEY7Ozs7OztJQUVTLGNBQWMsQ0FBQyxHQUFRLEVBQUUsT0FBZTs7UUFFOUMsSUFBSSxNQUFNLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDOztRQUMvQixJQUFJLFNBQVMsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7O1FBQ2xDLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFVO1lBRW5DLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDbEMsT0FBTyxLQUFLLENBQUM7YUFFaEI7aUJBQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDakQsT0FBTyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBRWpFO2lCQUFNLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsS0FBSyxTQUFTLEVBQUU7Z0JBQy9ELE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUM7YUFDOUM7WUFFRCxPQUFPLEtBQUssQ0FBQztTQUNoQixDQUFDLENBQUMsTUFBTSxDQUFDO1FBQ1YsT0FBTyxPQUFPLEdBQUcsQ0FBQyxDQUFDO0tBQ3RCO0NBQ0o7Ozs7Ozs7OztBQVdELG9DQUE0QyxTQUFRLHVCQUF1Qjs7Ozs7O0lBR3ZFLE9BQU8sQ0FBQyxPQUEwQixFQUFFLE9BQWtCO1FBRWxELE9BQU8sT0FBTyxZQUFZLGlCQUFpQixJQUFJLE9BQU8sS0FBSyxTQUFTLENBQUMsZUFBZSxDQUFDO0tBQ3hGOzs7Ozs7OztJQUdELDBCQUEwQixDQUFJLGtCQUF5QixFQUFFLEtBQWEsRUFBRSxHQUFXO1FBRS9FLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLHNCQUFzQixDQUFDLENBQUM7UUFFMUQsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDaEIsT0FBTyxrQkFBa0IsQ0FBQztTQUM3Qjs7UUFDRCxJQUFJLGNBQWMsR0FBRyxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7O1FBRXpDLElBQUksY0FBYyxHQUFHLGtCQUFrQixDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2hELElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQzVDLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNyQzs7Ozs7Ozs7O0lBUUQsTUFBTSxDQUFDLEtBQW9CLEVBQUUsS0FBYTtRQUV0QyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBaUI7O1lBRzVCLElBQUksZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO1lBQzdCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ3RELGdCQUFnQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQzthQUN4RDtZQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsZ0JBQWdCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDaEUsQ0FBQyxDQUFDO1FBRUgsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBaUIsS0FBSyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDMUQ7Ozs7Ozs7O0lBT0QsS0FBSyxDQUFDLEtBQW9CO1FBRXRCLE9BQU8sS0FBSzthQUNQLE1BQU0sQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQzthQUM1QixHQUFHLENBQUMsSUFBSSx1QkFDRixJQUFJLElBQ1AsVUFBVSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQ3hCLFFBQVEsRUFBRSxJQUFJLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUN0RCxDQUFDLENBQUM7S0FDWDtDQUVKOzs7Ozs7QUNuVkQ7QUFNQSxNQUFhLFdBQVcsR0FBRyxJQUFJLGNBQWMsQ0FBYSxhQUFhLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0J6RTs7Ozs7Ozs7O0lBV0ksWUFBc0IsYUFBNkIsRUFBWSxPQUFxQjtRQUE5RCxrQkFBYSxHQUFiLGFBQWEsQ0FBZ0I7UUFBWSxZQUFPLEdBQVAsT0FBTyxDQUFjO0tBRW5GOzs7Ozs7SUEwQkQsT0FBTztRQUdILE9BQU8sYUFBYSxFQUFFLENBQUM7S0FDMUI7O3VCQXpDMkIsRUFBRTsrQkFDTSxDQUFDOzs7Ozs7Ozs7OztBQ2xDekM7OztBQWVBOzt5QkFFOEMscUJBQXFCOzs7O1lBTmxFLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsUUFBUTtnQkFDbEIsUUFBUSxFQUFFLDJCQUEyQjthQUN4Qzs7O3dCQUdJLFdBQVcsU0FBQyxPQUFPOzs7OztBQVV4Qjs7eUJBRThDLG9CQUFvQjs7OztZQU5qRSxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFNBQVM7Z0JBQ25CLFFBQVEsRUFBRSwyQkFBMkI7YUFDeEM7Ozt3QkFHSSxXQUFXLFNBQUMsT0FBTzs7Ozs7QUFVeEI7O3lCQUU4QyxvQ0FBb0M7Ozs7WUFOakYsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxXQUFXO2dCQUNyQixRQUFRLEVBQUUsMkJBQTJCO2FBQ3hDOzs7d0JBR0ksV0FBVyxTQUFDLE9BQU87Ozs7O0FBV3hCOzt5QkFFOEMsb0JBQW9COzs7O1lBTmpFLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsVUFBVTtnQkFDcEIsUUFBUSxFQUFFLDJCQUEyQjthQUN4Qzs7O3dCQUdJLFdBQVcsU0FBQyxPQUFPOzs7OztBQVd4Qjs7eUJBRThDLG9CQUFvQjs7OztZQU5qRSxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFdBQVc7Z0JBQ3JCLFFBQVEsRUFBRSwyQkFBMkI7YUFDeEM7Ozt3QkFHSSxXQUFXLFNBQUMsT0FBTzs7Ozs7OztBQ25FeEI7Ozs7Ozs7Ozs7OztBQTBCQSxzQkFBOEIsU0FBUSxpQkFBaUI7Ozs7O0lBa0ZuRCxZQUFtQixHQUFnQjs7O0lBSWIsZUFBbUM7UUFFckQsS0FBSyxDQUFDLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQztRQU5iLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFJYixvQkFBZSxHQUFmLGVBQWUsQ0FBb0I7Ozs7OzZCQTlFaEMsS0FBSzs7Ozs7NEJBT04sS0FBSzs7Ozs7O3FCQVFiLEVBQUU7Ozs7OzhCQXdDUSxLQUFLOzs7Ozs7O3lCQWNXLEVBQUU7UUFheEMsSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsQ0FBQyxNQUFNLENBQUM7S0FDNUQ7Ozs7OztJQU9ELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakIsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRWhDLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBRTFCLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUM7UUFDcEQsSUFBSSxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFDckUsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUV6RixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFNBQVMsR0FBRyxjQUFjLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztLQUN4Rjs7Ozs7O0lBT0QsSUFBSSxJQUFJO1FBRUosT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO0tBQ3JCOzs7Ozs7Ozs7Ozs7O0lBZUQsSUFDSSxJQUFJLENBQUMsS0FBYTs7UUFHbEIsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBRXJCLElBQUksYUFBYSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDeEMsUUFBUSxHQUFHLElBQUksQ0FBQztZQUNoQixLQUFLLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUM3QztRQUVELElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsRUFBRTtZQUMxQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs7WUFDbkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7U0FDekM7YUFBTSxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDNUIsSUFBSSxDQUFDLEtBQUssR0FBRyxrQkFBa0IsQ0FBQztTQUNuQztLQUNKOzs7O0lBR0QsU0FBUztRQUVMLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUVsQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRTtZQUNwRixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDO1NBQ2pEO0tBQ0o7Ozs7O0lBS08sa0JBQWtCOztRQUV0QixJQUFJLFVBQVUsR0FBa0IsRUFBRSxDQUFDO1FBRW5DLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUMzQixVQUFVLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7U0FDekQ7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDM0IsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3pEO1FBRUQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDM0MsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDeEM7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDekIsVUFBVSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ3JEO1FBQ0QsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDbEMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDekQ7UUFFRCxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ2pEO2FBQU0sSUFBSSxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDbEU7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsSUFBSSxJQUFJLENBQUMscUJBQXFCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNsRixJQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RFO2FBQU0sSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksSUFBSSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDdkYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxrQkFBa0IsQ0FDL0IsVUFBVSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDO1NBQzVEOzs7Ozs7OztJQVNMLElBQUksV0FBVztRQUVYLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQy9ELE9BQU8sbUJBQXFCLElBQUksQ0FBQyxlQUFlLEdBQUUsYUFBYSxFQUFFLENBQUM7U0FDckU7UUFDRCxPQUFPLEtBQUssQ0FBQztLQUNoQjs7Ozs7Ozs7O0lBUU8sT0FBTyxDQUFDLEtBQWEsRUFBRSxVQUFtQjs7UUFFOUMsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFekQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUMvQixtQkFBcUIsSUFBSSxDQUFDLGVBQWUsR0FBRSxZQUFZLElBQUksVUFBVSxFQUN6RTs7WUFFSSxJQUFJLFVBQVUsR0FBYSxNQUFNLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7WUFDMUQsYUFBYSxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3JFO1FBQ0QsT0FBTyxtQkFBTSxpQkFBaUIsR0FBRSxhQUFhLENBQUMsQ0FBQzs7OztZQXBQdEQsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxhQUFhO2dCQUN2QiwweEJBQXNDO2dCQUV0QyxTQUFTLEVBQUU7b0JBQ1AsRUFBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLGdCQUFnQixDQUFDLEVBQUM7aUJBQ2hGOzthQUNKOzs7O1lBdkJPLFdBQVc7WUFDWCxrQkFBa0IsdUJBNEdULFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGtCQUFrQixDQUFDOzs7NEJBOUUvRSxLQUFLOzJCQU9MLEtBQUs7b0JBUUwsS0FBSzt3QkFNTCxLQUFLO3dCQU1MLEtBQUs7c0JBUUwsS0FBSztvQ0FPTCxLQUFLOytCQU1MLEtBQUs7NkJBT0wsS0FBSzt3QkFlTCxXQUFXLFNBQUMsT0FBTzttQkEwRG5CLEtBQUs7Ozs7Ozs7QUNqS1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEtBLHdCQUFnQyxTQUFRLGlCQUFpQjs7OztJQWtFckQsWUFBbUIsR0FBZ0I7UUFFL0IsS0FBSyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUZGLFFBQUcsR0FBSCxHQUFHLENBQWE7Ozs7OzsyQkF6RFgsS0FBSzs7Ozs7OzJCQVNMLEtBQUs7Ozs7Z0NBTUQsSUFBSTs7Ozs7O3dCQVFGLElBQUksWUFBWSxFQUFFOzs7Ozs0QkE2QnhCLEtBQUs7NEJBQ0wsS0FBSzs4QkFDSCxLQUFLO0tBTTlCOzs7OztJQUdELFdBQVcsQ0FBQyxPQUFzQjtRQUU5QixLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTNCLElBQUksU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUM5QixPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsYUFBYSxLQUFLLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxZQUFZLEVBQUU7WUFFeEUsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7U0FDM0I7S0FDSjs7Ozs7SUFHRCxZQUFZLENBQUMsS0FBVTtRQUVuQixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUM3Qjs7Ozs7OztJQU9ELGFBQWE7UUFFVCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7S0FDM0I7Ozs7Ozs7SUFRRCxjQUFjO1FBRVYsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0tBQ3hCOzs7O0lBR0QsWUFBWTtRQUVSLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRTtZQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLGlFQUFpRSxDQUFDLENBQUM7U0FDdEY7UUFFRCxJQUFJLENBQUMsWUFBWSxHQUFHLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDOUUsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ3JFLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVoQyxJQUFJLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDdkUsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUUvQixJQUFJLElBQUksQ0FBQyxZQUFZLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLEVBQUU7WUFDN0MsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUM7WUFDOUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUM7U0FDbEQ7UUFFRCxJQUFJLElBQUksQ0FBQyxjQUFjLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsRUFBRTtZQUNqRCxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxrQkFBa0IsQ0FBQztZQUM5QyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsSUFBSSxrQkFBa0IsQ0FBQztTQUNsRDtLQUNKOzs7O0lBR08sV0FBVztRQUVmLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO2VBQ25GLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzs7Ozs7Ozs7O0lBU2pFLGNBQWM7UUFFVixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO1lBQ2pELElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDdEQ7Ozs7Ozs7O0lBU0QsZ0JBQWdCO1FBRVosT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQztZQUNqRCxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQ3REOzs7O0lBRUQsa0JBQWtCOzs7O1FBS2QsVUFBVSxDQUFDO1lBRVAsSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3BCLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN2QixDQUFDLENBQUM7S0FDTjs7OztJQUdPLGdCQUFnQjtRQUVwQixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNuRixJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQXVCO2dCQUU1QyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7O2FBRWpDLENBQUMsQ0FBQztTQUNOOzs7Ozs7O0lBUUcsWUFBWTtRQUVoQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzlDLElBQUksSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDckIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFzQixLQUFLLElBQUksQ0FBQyxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUM7YUFDdEU7U0FFSjs7OztZQXBOUixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLDRVQUF3QztnQkFFeEMsU0FBUyxFQUFFO29CQUNQLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxrQkFBa0IsQ0FBQyxFQUFDO2lCQUNsRjs7YUFDSjs7OztZQTdKTyxXQUFXOzs7MEJBc0tkLEtBQUs7MEJBU0wsS0FBSzsrQkFNTCxLQUFLO3VCQVFMLE1BQU07dUJBUU4sWUFBWSxTQUFDLGlCQUFpQjt5QkFFOUIsWUFBWSxTQUFDLG1CQUFtQjt3QkFFaEMsWUFBWSxTQUFDLGtCQUFrQjtzQkFFL0IsWUFBWSxTQUFDLGdCQUFnQjt5QkFFN0IsWUFBWSxTQUFDLG1CQUFtQjt5QkFHaEMsZUFBZSxTQUFDLGlCQUFpQixFQUFFLEVBQUMsV0FBVyxFQUFFLElBQUksRUFBQzttQkFHdEQsZUFBZSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGdCQUFnQixDQUFDLEVBQUUsRUFBQyxXQUFXLEVBQUUsSUFBSSxFQUFDOzs7Ozs7O0FDL041RTs7O1lBZ0JDLFFBQVEsU0FBQztnQkFDTixZQUFZLEVBQUU7b0JBQ1Ysa0JBQWtCO29CQUNsQixnQkFBZ0I7b0JBQ2hCLGdCQUFnQjtvQkFDaEIsaUJBQWlCO29CQUNqQixrQkFBa0I7b0JBQ2xCLG1CQUFtQjtvQkFDbkIsbUJBQW1CO2lCQUN0QjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixXQUFXO29CQUNYLG1CQUFtQjtvQkFDbkIsZUFBZTtvQkFDZixxQkFBcUI7aUJBQ3hCO2dCQUNELGVBQWUsRUFBRTtvQkFDYixrQkFBa0I7b0JBQ2xCLGdCQUFnQjtvQkFDaEIsZ0JBQWdCO29CQUNoQixpQkFBaUI7b0JBQ2pCLGtCQUFrQjtvQkFDbEIsbUJBQW1CO29CQUNuQixtQkFBbUI7aUJBQ3RCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxrQkFBa0I7b0JBQ2xCLGdCQUFnQjtvQkFDaEIsZ0JBQWdCO29CQUNoQixpQkFBaUI7b0JBQ2pCLGtCQUFrQjtvQkFDbEIsbUJBQW1CO29CQUNuQixtQkFBbUI7aUJBQ3RCO2FBQ0o7Ozs7Ozs7Ozs7OztBQ3ZFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMERBLE1BQWEsNEJBQTRCLEdBQVE7SUFDN0MsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0sbUJBQW1CLENBQUM7SUFDbEQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBY0YseUJBQWlDLFNBQVEsaUJBQWlCOzs7OztJQThDdEQsWUFBbUIsR0FBZ0IsRUFFYixlQUFrQztRQUVwRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSmIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUViLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7Ozs7O3FCQXZDM0MsRUFBRTs7Ozs0QkErQlEsRUFBRTs7OztxQkFpQkQsUUFBUTtRQU41QixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksV0FBVyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNsRDs7OztJQU9ELElBQUksSUFBSTtRQUVKLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztLQUNyQjs7Ozs7Ozs7SUFPRCxJQUNJLElBQUksQ0FBQyxLQUFhO1FBRWxCLElBQUksS0FBSyxDQUFDLFdBQVcsRUFBRSxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFLEtBQUssTUFBTSxFQUFFO1lBQ3BFLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1NBQ3ZCO2FBQU0sSUFBSSxLQUFLLENBQUMsV0FBVyxFQUFFLEtBQUssUUFBUSxFQUFFO1lBQ3pDLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDO1NBQ3pCO0tBQ0o7Ozs7SUFFRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pCLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFM0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVk7YUFDN0MsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7YUFDNUIsU0FBUyxDQUFDLEdBQUc7WUFFVixJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztZQUNqQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuQyxDQUFDLENBQUM7UUFFUCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDakU7YUFBTTtZQUNILElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztTQUNsQztLQUNKOzs7O0lBRUQsVUFBVTtRQUVOLE9BQU8sSUFBSSxDQUFDO0tBQ2Y7Ozs7O0lBRUQsU0FBUyxDQUFDLEVBQU87UUFFYixJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQ3pCLElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQztZQUM3QixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUMxQztLQUNKOzs7OztJQUVELE1BQU0sQ0FBQyxFQUFPO1FBRVYsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUN6QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUNuRCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM5RCxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztTQUMxQztLQUNKOzs7OztJQUVELFVBQVUsQ0FBQyxLQUFVO1FBRWpCLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDN0IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFDbkIsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUM7WUFDdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNaLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQzthQUNsQztZQUNELElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO1NBQ3REO0tBQ0o7Ozs7Ozs7SUFNRCxZQUFZLENBQUMsS0FBVTtRQUVuQixJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsT0FBTyxFQUFFLENBQUM7U0FDYjs7UUFHRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ3pCLElBQUksQ0FBQyxLQUFLLEtBQUssUUFBUSxFQUMzQjs7WUFFSSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUM7WUFDckIsTUFBTSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQ2pDLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ3BEO1FBQ0QsT0FBTyxLQUFLLENBQUM7S0FDaEI7Ozs7SUFFRCxXQUFXO1FBRVAsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXBCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3BDO0tBQ0o7OztZQTdLSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIsd3pCQUF5QztnQkFHekMsU0FBUyxFQUFFO29CQUNQLDRCQUE0QjtvQkFFNUIsRUFBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLG1CQUFtQixDQUFDLEVBQUM7aUJBQ25GOzthQUNKOzs7O1lBeEVPLFdBQVc7WUFDWCxpQkFBaUIsdUJBdUhSLFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGdCQUFnQixDQUFDOzs7b0JBdkM3RSxLQUFLO3dCQVFMLEtBQUs7eUJBT0wsS0FBSzttQkFRTCxLQUFLO21CQXNDTCxLQUFLOzs7OztBQW1HVjs7Ozs7SUFJSSxZQUE0QixTQUFpQixDQUFDLEVBQ2xCLFNBQWlCLE9BQU87UUFEeEIsV0FBTSxHQUFOLE1BQU0sQ0FBWTtRQUNsQixXQUFNLEdBQU4sTUFBTTtLQUVqQzs7OztJQUdELFFBQVE7UUFFSixPQUFPO1lBQ0gsTUFBTSxFQUFFLE1BQU07WUFDZCxNQUFNLEVBQUUsTUFBTTtTQUNqQixDQUFDO0tBQ0w7Ozs7SUFFRCxTQUFTO1FBRUwsT0FBTyxZQUFZLENBQUM7S0FDdkI7Ozs7SUFFRCxNQUFNO1FBRUYsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUM7S0FDckM7Ozs7SUFFRCxRQUFRO1FBRUosT0FBTyxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0tBQ25EOzs7OztJQUdELEtBQUssQ0FBQyxPQUE2QyxFQUFFO1FBRWpELE9BQU8sSUFBSSxVQUFVLENBQ2pCLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxFQUNsRCxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzNEO0NBRUo7Ozs7OztBQ3pRRDs7O1lBS0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixlQUFlO2lCQUNsQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixXQUFXO29CQUNYLG1CQUFtQjtpQkFDdEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLGVBQWU7aUJBQ2xCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxlQUFlO2lCQUNsQjtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQ3JCRDs7O1lBT0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixtQkFBbUI7aUJBQ3RCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsbUJBQW1CO29CQUNuQixlQUFlO29CQUNmLG1CQUFtQjtpQkFDdEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLG1CQUFtQjtpQkFDdEI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLG1CQUFtQjtvQkFDbkIsbUJBQW1CO29CQUNuQixtQkFBbUI7b0JBQ25CLFdBQVc7aUJBQ2Q7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUM1QkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUZBLDZCQUFxQyxTQUFRLGFBQWE7Ozs7O0lBeUd0RCxZQUFZLEdBQWdCLEVBQUUsU0FBb0I7UUFFOUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7O3VCQWpHSSxJQUFJOzs7Ozs7OzBCQVVELElBQUk7Ozs7Ozs7eUJBU0wsSUFBSTs7Ozs7OzBCQW1ETyxJQUFJLFlBQVksRUFBTzs7Ozs7OzhCQVFuQixJQUFJLFlBQVksRUFBTzs7UUFzQnZELElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDO1FBQzFCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxRQUFRLENBQUM7UUFDbEMsSUFBSSxDQUFDLFFBQVEsR0FBRyx5QkFBeUIsQ0FBQztLQUM3Qzs7OztJQUVELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUM7bUJBQzNFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztTQUNoRDtLQUNKOzs7Ozs7SUFPRCxpQkFBaUI7UUFFYixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLENBQUM7S0FDMUM7Ozs7OztJQU1ELGdCQUFnQjtRQUVaLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztLQUN4Qzs7O1lBbEpKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsb0JBQW9CO2dCQUM5QixzNERBQTZDOzthQUVoRDs7OztZQWxGa0IsV0FBVztZQUF0QixTQUFTOzs7c0JBNEZaLEtBQUs7eUJBVUwsS0FBSzt3QkFTTCxLQUFLO3VCQU9MLEtBQUs7NEJBUUwsS0FBSztnQ0FRTCxLQUFLO3NCQWdCTCxLQUFLOytCQUlMLEtBQUs7eUJBUUwsTUFBTTs2QkFRTixNQUFNOzhCQU9OLFlBQVksU0FBQyxTQUFTOzRCQU10QixZQUFZLFNBQUMsT0FBTzs7Ozs7OztBQ3pMekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE4Q0EscUJBQTZCLFNBQVEsYUFBYTs7Ozs7SUEyRDlDLFlBQXNCLE9BQW1CLEVBQVMsR0FBZ0I7UUFFOUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRk8sWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFTLFFBQUcsR0FBSCxHQUFHLENBQWE7Ozs7O29CQW5EbkQsUUFBUTs7OztxQkFhRixTQUFTOzs7O29CQU9YLFFBQVE7Ozs7c0JBa0JDLElBQUksWUFBWSxFQUFFOztRQWtCMUMsSUFBSSxDQUFDLFdBQVcsR0FBRyxxQkFBcUIsQ0FBQzs7UUFHekMsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7S0FDekI7Ozs7SUFFRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDOztRQUVqQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdkIsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTs7OztnQkFJMUIsSUFBSSxDQUFDLFdBQVcsR0FBRyxtQkFBbUIsQ0FBQzthQUMxQztpQkFBTTtnQkFDSCxJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO2FBQ2hEO1NBQ0o7O1FBR0QsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1lBRVgsUUFBUSxJQUFJLENBQUMsSUFBSTtnQkFDYixLQUFLLE9BQU87b0JBQ1IsSUFBSSxDQUFDLFdBQVcsSUFBSSxTQUFTLENBQUM7b0JBQzlCLE1BQU07Z0JBQ1YsS0FBSyxRQUFRO29CQUNULElBQUksQ0FBQyxXQUFXLElBQUksVUFBVSxDQUFDO29CQUMvQixNQUFNO2dCQUNWLEtBQUssT0FBTztvQkFDUixJQUFJLENBQUMsV0FBVyxJQUFJLFNBQVMsQ0FBQztvQkFDOUIsTUFBTTthQUNiO1NBQ0o7S0FDSjs7Ozs7Ozs7Ozs7OztJQWNELGVBQWU7UUFFWCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUU7O1lBQ3pCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQzs7WUFDaEUsSUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUMsSUFBSSxFQUFFO2lCQUN6RSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFFcEQsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUNoRCxNQUFNLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQztZQUN4QixNQUFNLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ25DO0tBQ0o7Ozs7OztJQUtELE9BQU8sQ0FBQyxNQUFXO1FBRWYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQy9EOzs7WUEzSUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxXQUFXO2dCQUNyQiw0UEFBb0M7O2FBRXZDOzs7O1lBN0NpQyxVQUFVO1lBQ3BDLFdBQVc7OzttQkFvRGQsS0FBSzttQkFNTCxLQUFLO29CQU9MLEtBQUs7bUJBT0wsS0FBSztxQkFNTCxLQUFLO29CQU1MLEtBQUs7cUJBTUwsTUFBTTs7Ozs7OztBQzNGWDs7O1lBTUMsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixlQUFlO2lCQUNsQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixZQUFZO2lCQUVmO2dCQUNELGVBQWUsRUFBRTtvQkFDYixlQUFlO2lCQUNsQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsZUFBZTtpQkFDbEI7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUN0QkQ7OztZQVFDLFFBQVEsU0FBQztnQkFDTixZQUFZLEVBQUU7b0JBQ1YsdUJBQXVCO2lCQUMxQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixhQUFhO29CQUNiLGNBQWM7b0JBQ2QscUJBQXFCO2lCQUV4QjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsdUJBQXVCO2lCQUMxQjtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQ3pCRDs7O1lBZUMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxhQUFhO2dCQUN2QixJQUFJLEVBQUU7b0JBQ0YsT0FBTyxFQUFFLGFBQWE7aUJBQ3pCO2FBQ0o7O0FBV0Q7OztZQU5DLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixJQUFJLEVBQUU7b0JBQ0YsT0FBTyxFQUFFLGdCQUFnQjtpQkFDNUI7YUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2R0QsbUJBQTJCLFNBQVEsYUFBYTs7OztJQXlHNUMsWUFBbUIsR0FBZ0I7UUFFL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRkksUUFBRyxHQUFILEdBQUcsQ0FBYTs7Ozs7eUJBbEdkLEtBQUs7Ozs7Ozs7MEJBU0osSUFBSTs7Ozs7NEJBT0gsYUFBYTs7Ozt3QkFjaEIsS0FBSzs7Ozs7Ozt5QkFTTCxVQUFVOzs7Ozt3QkFRVixJQUFJOzs7Ozt3QkFRTSxJQUFJLFlBQVksRUFBRTs7Ozs7d0JBT2xCLElBQUksWUFBWSxFQUFFOzs7Ozs2QkFPYixJQUFJLFlBQVksRUFBRTs7Ozs7OzsrQkEwQjFCLEtBQUs7O1FBUTVCLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxNQUFNLEdBQUcsT0FBTyxDQUFDO0tBQ3pCOzs7O0lBRUQsUUFBUTtRQUVKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQzs7UUFHakIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDNUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1NBQ3REO0tBRUo7Ozs7SUFFTSxpQkFBaUI7UUFFcEIsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7Ozs7O0lBT2xDLFlBQVksQ0FBQyxLQUFVO1FBRW5CLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFO1lBQ2xCLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7U0FFM0I7YUFBTTtZQUNILElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNyQztLQUNKOzs7Ozs7OztJQU9ELGFBQWEsQ0FBQyxLQUFVO1FBRXBCLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDeEQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3JDO0tBQ0o7Ozs7Ozs7SUFNRCxPQUFPLENBQUMsT0FBZ0I7UUFFcEIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsT0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7U0FDakU7S0FDSjs7Ozs7Ozs7SUFRRCxnQkFBZ0I7UUFFWixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUssSUFBSSxDQUFDLGVBQWUsQ0FBQztLQUNoRTs7O1lBdkxKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsU0FBUztnQkFDbkIsc3RGQUFvQzs7YUFFdkM7Ozs7WUE5SE8sV0FBVzs7O3dCQXFJZCxLQUFLO3lCQVNMLEtBQUs7MkJBT0wsS0FBSzt5QkFRTCxLQUFLO3VCQU1MLEtBQUs7d0JBU0wsS0FBSzt1QkFRTCxLQUFLO3VCQVFMLE1BQU07dUJBT04sTUFBTTs0QkFPTixNQUFNO3FCQU9OLFlBQVksU0FBQyx1QkFBdUI7MkJBT3BDLFlBQVksU0FBQyxNQUFNO3VCQUluQixTQUFTLFNBQUMsVUFBVTs7Ozs7OztBQ3hPekI7Ozs7QUFTQSxNQUFNLFNBQVMsR0FBRztJQUNkLFVBQVUsRUFBRSxZQUFZO0lBQ3hCLFlBQVksRUFBRSxZQUFZO0lBQzFCLFdBQVcsRUFBRSxZQUFZO0lBQ3pCLGFBQWEsRUFBRSxRQUFRO0lBQ3ZCLGVBQWUsRUFBRSxRQUFRO0lBQ3pCLGNBQWMsRUFBRSxRQUFRO0lBQ3hCLGFBQWEsRUFBRSxVQUFVO0lBQ3pCLGVBQWUsRUFBRSxVQUFVO0lBQzNCLGNBQWMsRUFBRSxVQUFVO0NBQzdCLENBQUM7O0FBR0YsTUFBTSxTQUFTLEdBQUc7SUFDZCxVQUFVLEVBQUUsWUFBWTtJQUN4QixZQUFZLEVBQUUsUUFBUTtJQUN0QixXQUFXLEVBQUUsVUFBVTtJQUN2QixhQUFhLEVBQUUsWUFBWTtJQUMzQixlQUFlLEVBQUUsUUFBUTtJQUN6QixjQUFjLEVBQUUsVUFBVTtJQUMxQixhQUFhLEVBQUUsWUFBWTtJQUMzQixlQUFlLEVBQUUsUUFBUTtJQUN6QixjQUFjLEVBQUUsVUFBVTtDQUM3QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFDRiw0QkFBb0MsU0FBUSxhQUFhOzs7OztJQVdyRCxZQUFtQixHQUFnQixFQUFTLElBQWdCO1FBRXhELEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUZJLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFZOzs7Ozs7cUJBSGhDLFVBQVU7S0FPckM7Ozs7SUFHRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWpCLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNqRSxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsY0FBYyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDeEU7OztZQTlCSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLElBQUksRUFBRTtvQkFDRixPQUFPLEVBQUUsY0FBYztpQkFDMUI7YUFDSjs7OztZQWxFTyxXQUFXO1lBRkEsVUFBVTs7O29CQTRFeEIsS0FBSzs7Ozs7OztBQzVFVjs7O1lBTUMsUUFBUSxTQUFDO2dCQUNOLE9BQU8sRUFBRTtvQkFDTCxZQUFZO2lCQUNmO2dCQUNELFlBQVksRUFBRTtvQkFDVixhQUFhO29CQUNiLHNCQUFzQjtvQkFDdEIsb0JBQW9CO29CQUNwQix1QkFBdUI7aUJBQzFCO2dCQUNELGVBQWUsRUFBRTtvQkFDYixhQUFhO2lCQUNoQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsYUFBYTtvQkFDYixzQkFBc0I7b0JBQ3RCLG9CQUFvQjtvQkFDcEIsdUJBQXVCO2lCQUMxQjtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQ3hCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0RBLE1BQWEseUJBQXlCLEdBQVE7SUFDMUMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0saUJBQWlCLENBQUM7SUFDaEQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBYUYsdUJBQStCLFNBQVEsaUJBQWlCOzs7OztJQWlEcEQsWUFBbUIsR0FBZ0IsRUFFYixlQUFrQztRQUVwRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSmIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUViLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7Ozs7O3FCQTFDM0MsRUFBRTs7Ozs7b0JBUU0sTUFBTTs7Ozs7c0JBZUMsSUFBSSxZQUFZLEVBQUU7Ozs7Ozs7O3dCQVMxQixLQUFLO0tBYXhCOzs7O0lBRUQsUUFBUTtRQUVKLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFcEUsSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDbkIsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBRWpCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDbkIsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztnQkFDcEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDbkM7aUJBQU07O2dCQUVILElBQUksQ0FBQyxXQUFXLHFCQUFpQixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUEsQ0FBQzthQUN2RTtTQUNKOzs7UUFHRCxJQUFJLENBQUMsUUFBUSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FFekM7Ozs7O0lBR0QsV0FBVyxDQUFDLE9BQXNCO1FBRTlCLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFM0IsSUFBSSxTQUFTLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQzFCLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLEtBQUssT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQ3BFLElBQUksQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQVksQ0FBQztTQUM5QztLQUdKOzs7Ozs7O0lBTUQsUUFBUSxDQUFDLEtBQVU7UUFFZixJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUNuQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNoQyxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUN6QztTQUNKO2FBQU07WUFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQjtLQUNKOzs7Ozs7OztJQVNELFVBQVU7UUFFTixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDO0tBQy9COzs7Ozs7O0lBTUQsVUFBVSxDQUFDLEtBQVU7UUFFakIsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLEVBQUU7WUFDM0MsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7WUFFbkIsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO2dCQUNuQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3pDO1NBQ0o7S0FDSjs7O1lBaEpKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsYUFBYTtnQkFDdkIsazBCQUFzQztnQkFHdEMsU0FBUyxFQUFFO29CQUNQLHlCQUF5QjtvQkFDekIsRUFBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLGlCQUFpQixDQUFDLEVBQUM7aUJBQ2pGOzthQUNKOzs7O1lBbkVPLFdBQVc7WUFDWCxpQkFBaUIsdUJBcUhSLFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGlCQUFpQixDQUFDOzs7b0JBMUM5RSxLQUFLO21CQVFMLEtBQUs7b0JBT0wsS0FBSztxQkFRTCxNQUFNOzs7Ozs7O0FDL0dYOzs7WUFPQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGlCQUFpQjtpQkFDcEI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7b0JBQ1osV0FBVztvQkFDWCxtQkFBbUI7b0JBQ25CLGNBQWM7aUJBQ2pCO2dCQUVELGVBQWUsRUFBRTtvQkFDYixpQkFBaUI7aUJBQ3BCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxpQkFBaUI7b0JBQ2pCLG1CQUFtQjtvQkFDbkIsV0FBVztpQkFDZDtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQzNCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlFQSxNQUFhLDhCQUE4QixHQUFRO0lBQy9DLE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLHFCQUFxQixDQUFDO0lBQ3BELEtBQUssRUFBRSxJQUFJO0NBQ2QsQ0FBQztBQWFGLDJCQUFtQyxTQUFRLGlCQUFpQjs7Ozs7O0lBc0N4RCxZQUFtQixHQUFnQixFQUNmLElBRUUsZUFBa0M7UUFFcEQsS0FBSyxDQUFDLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUxiLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFDZixPQUFFLEdBQUYsRUFBRTtRQUVBLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7Ozs7OzJCQWpCdkIsSUFBSSxZQUFZLEVBQU87Ozs7cUJBWTNDLEVBQUU7S0FRZDs7OztJQUVELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFakIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxVQUFVLEdBQUcsRUFBRSxDQUFDO1NBQ3hCO1FBRUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUUxQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUN4Qzs7OztJQUdELGtCQUFrQjs7UUFFZCxJQUFJLFlBQVksR0FBVSxFQUFFLENBQUM7UUFFN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFhLEtBQUssWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUU7WUFDcEMsU0FBUyxFQUFFLElBQUk7WUFDZixxQkFBcUIsRUFBRSxLQUFLO1NBQy9CLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLENBQUM7S0FFM0I7Ozs7Ozs7OztJQVNELFVBQVUsQ0FBQyxJQUFTO1FBRWhCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUNoQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUMxQjs7Ozs7OztJQU9ELEtBQUssQ0FBQyxJQUFTO1FBRVgsT0FBTyxJQUFJLENBQUM7S0FDZjs7Ozs7OztJQU1ELFFBQVEsQ0FBQyxLQUFVOztRQUVmLElBQUksWUFBWSxHQUFVLEVBQUUsQ0FBQztRQUU3QixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQWE7WUFFN0IsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDdkMsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxZQUFZLEVBQUU7WUFDcEMsU0FBUyxFQUFFLElBQUk7WUFDZixxQkFBcUIsRUFBRSxLQUFLO1NBQy9CLENBQUMsQ0FBQztLQUNOOzs7Ozs7O0lBT0QsV0FBVyxDQUFDLFVBQWlCO1FBRXpCLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFTOztZQUV6QixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQVM7Z0JBRXRDLE9BQU8sTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzthQUM3QixDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMxQixDQUFDLENBQUM7S0FDTjs7Ozs7OztJQU9ELFVBQVUsQ0FBQyxLQUFVO1FBRWpCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7O1lBQzNDLElBQUksUUFBUSxHQUFHLEtBQUssQ0FBQztZQUNyQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDOztTQUc5QjtLQUNKOzs7WUFoS0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLDRpQkFBNEM7Z0JBRzVDLFNBQVMsRUFBRTtvQkFDUCw4QkFBOEI7b0JBQzlCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxxQkFBcUIsQ0FBQyxFQUFDO2lCQUNyRjs7YUFDSjs7OztZQXJFTyxXQUFXO1lBVmYsaUJBQWlCO1lBWWIsaUJBQWlCLHVCQTRHUixRQUFRLFlBQUksUUFBUSxZQUFJLE1BQU0sU0FBQyxVQUFVLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7O21CQWxDN0UsS0FBSzt5QkFTTCxLQUFLOzBCQVFMLE1BQU07NkJBTU4sS0FBSzs7Ozs7OztBQy9HVjs7O1lBT0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixxQkFBcUI7aUJBQ3hCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsbUJBQW1CO29CQUNuQixnQkFBZ0I7aUJBQ25CO2dCQUdELE9BQU8sRUFBRTtvQkFDTCxxQkFBcUI7aUJBQ3hCO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7O0FDdkJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOENBLHdCQUFnQyxTQUFRLGFBQWE7Ozs7SUFvRGpELFlBQW1CLEdBQWdCO1FBRS9CLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUZJLFFBQUcsR0FBSCxHQUFHLENBQWE7Ozs7b0JBekJsQixRQUFROzs7O3NCQWtCRyxJQUFJLFlBQVksRUFBRTs7Ozt5QkFLMUIsTUFBTTtLQU16Qjs7OztJQUVELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7O1FBR2pCLElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNYLFFBQVEsSUFBSSxDQUFDLElBQUk7Z0JBQ2IsS0FBSyxPQUFPO29CQUNSLElBQUksQ0FBQyxTQUFTLElBQUksVUFBVSxDQUFDO29CQUM3QixNQUFNO2dCQUNWLEtBQUssUUFBUTtvQkFDVCxJQUFJLENBQUMsU0FBUyxJQUFJLFdBQVcsQ0FBQztvQkFDOUIsTUFBTTtnQkFDVixLQUFLLE9BQU87b0JBQ1IsSUFBSSxDQUFDLFNBQVMsSUFBSSxVQUFVLENBQUM7b0JBQzdCLE1BQU07YUFDYjtTQUNKOztRQUdELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUNsQyxJQUFJLENBQUMsU0FBUyxJQUFJLFVBQVUsQ0FBQztTQUNoQztLQUVKOzs7Ozs7SUFLRCxPQUFPLENBQUMsS0FBVTtRQUVkLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ2IsS0FBSyxFQUFFLEtBQUs7WUFDWixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7U0FDcEIsQ0FBQyxDQUFDO0tBQ047OztZQWxHSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLHdQQUF1Qzs7YUFFMUM7Ozs7WUEzQ08sV0FBVzs7O21CQW1EZCxLQUFLO21CQU1MLEtBQUs7a0JBTUwsS0FBSzttQkFPTCxLQUFLO3FCQU1MLEtBQUs7b0JBTUwsS0FBSztxQkFNTCxNQUFNOzs7Ozs7O0FDMUZYOzs7WUFLQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGtCQUFrQjtpQkFDckI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7aUJBQ2Y7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLGtCQUFrQjtpQkFDckI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLGtCQUFrQjtpQkFDckI7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUNuQkQ7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7SUFVSSxpQkFBaUIsQ0FBQyxTQUFjLEVBQUUsUUFBaUI7S0FFbEQ7Ozs7Ozs7SUFPRCxjQUFjO1FBRVYsT0FBTyxhQUFhLEVBQUUsQ0FBQztLQUMxQjs7Ozs7O0lBT0QsZUFBZTtRQUVYLE9BQU8sYUFBYSxFQUFFLENBQUM7S0FDMUI7Ozs7Ozs7SUFPRCxVQUFVLENBQUMsU0FBYztRQUVyQixPQUFPLGFBQWEsRUFBRSxDQUFDO0tBQzFCO0NBQ0o7Ozs7OztBQ3RERDs7Ozs7O0FBVUE7Ozs7O0lBa0ZJLFlBQVkscUJBQTZDLEVBQUUsVUFBbUIsSUFBSTs7Ozs7eUJBckI3RCxLQUFLOzs7Ozs7dUJBT1AsS0FBSzt1Q0FHVSxDQUFDOzs7Ozs7dUNBUUEsS0FBSztRQU1wQyxJQUFJLENBQUMsY0FBYyxHQUFHLHFCQUFxQixDQUFDO1FBQzVDLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDO1FBRTNCLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUkscUJBQXFCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ3JFO0tBQ0o7Ozs7Ozs7O0lBUUQsc0JBQXNCLENBQUMsSUFBUztRQUU1QixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNmLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1NBQzNCO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDbkIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUN0QzthQUFNOztZQUNILElBQUksY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQzs7WUFDM0MsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBRzdDLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDZCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7b0JBQ2hCLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxFQUFFO3dCQUMzQixJQUFJLENBQUMsaUJBQWlCLENBQUMsY0FBYyxFQUFFLEtBQUssQ0FBQyxDQUFDO3FCQUNqRDtpQkFFSjtnQkFDRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsSUFBSSxFQUFFLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQzthQUNyRjtpQkFBTTtnQkFDSCxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsRUFBRTtvQkFDM0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGNBQWMsRUFBRSxLQUFLLENBQUMsQ0FBQztpQkFDakQ7Z0JBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQzthQUN0QztTQUNKO0tBQ0o7Ozs7OztJQU9ELGlCQUFpQjtRQUViLElBQUksQ0FBQyx1QkFBdUIsR0FBRyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQztLQUNoRTs7Ozs7OztJQVFELElBQUkscUJBQXFCO1FBR3JCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ25CLE9BQU8sRUFBRSxDQUFDO1NBQ2I7O1FBRUQsSUFBSSxxQkFBcUIsR0FBVSxFQUFFLENBQUM7UUFDdEMsSUFBSSxDQUFDLHVCQUF1QixHQUFHLENBQUMsQ0FBQzs7UUFDakMsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDOztRQUM3QyxJQUFJLElBQUksR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDOztRQUNsQyxJQUFJLFFBQVEsR0FBRyxVQUFVLENBQUMsaUJBQWlCLENBQUM7UUFDNUMsSUFBSSxJQUFJLEdBQUcsVUFBVSxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFO1lBQ3RFLFFBQVEsSUFBSSxDQUFDLENBQUM7U0FDakI7UUFDRCxJQUFJLElBQUksQ0FBQyx1QkFBdUIsRUFBRTtZQUM5QixRQUFRLEdBQUcsSUFBSSxDQUFDO1NBQ25CO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLHVCQUF1QixHQUFHLFFBQVEsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFOztZQUM3RSxJQUFJLFNBQVMsR0FBRyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDbkMscUJBQXFCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyx1QkFBdUIsRUFBRSxDQUFDO1NBQ2xDO1FBRUQsT0FBTyxxQkFBcUIsQ0FBQztLQUNoQzs7OztJQUVELGNBQWM7UUFFVixPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsY0FBYyxFQUFFLENBQUM7S0FDL0M7Ozs7SUFHRCxlQUFlO1FBRVgsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLGVBQWUsRUFBRSxDQUFDO0tBQ2hEOzs7Ozs7SUFFRCxpQkFBaUIsQ0FBQyxTQUFjLEVBQUUsUUFBaUI7UUFFL0MsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUN2QixFQUFFO1lBQ0UsSUFBSSxDQUFDLGNBQWMsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLENBQUM7U0FDOUQ7S0FDSjtDQUVKOzs7O0FBTUQsMkJBQW1DLFNBQVEscUJBQXFCOzs7O0lBTTVELFlBQW9CLFdBQW9CO1FBRXBDLEtBQUssRUFBRSxDQUFDO1FBRlEsZ0JBQVcsR0FBWCxXQUFXLENBQVM7S0FHdkM7Ozs7OztJQUVELGlCQUFpQixDQUFDLFNBQWMsRUFBRSxRQUFpQjtRQUUvQyxJQUFJLFFBQVEsRUFBRTtZQUNWLElBQUksQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDO1lBQ2pDLElBQUksSUFBSSxDQUFDLFdBQVcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUNuRSxTQUFTLENBQUMsRUFBRTtnQkFDaEIsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUMxQztTQUNKO2FBQU07WUFDSCxJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7Z0JBQ2xCLFdBQVcsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQ2hFO1NBQ0o7S0FDSjs7OztJQUVELGNBQWM7UUFFVixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7S0FDL0I7Ozs7SUFFRCxlQUFlO1FBRVgsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsQ0FBQztTQUM5QjtRQUNELE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDO0tBQ2hDOzs7OztJQUVELFVBQVUsQ0FBQyxTQUFjO1FBRXJCLE9BQU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztLQUN0QztDQUNKOzs7Ozs7QUM3UEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDQSx1QkFBK0IsU0FBUSxVQUFVOzs7OztJQWdCN0MsWUFBbUIsYUFBNEIsRUFBUyxPQUFvQjtRQUV4RSxLQUFLLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBRmYsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFBUyxZQUFPLEdBQVAsT0FBTyxDQUFhO0tBRzNFOzs7Ozs7Ozs7SUFTRCxJQUFJLENBQUMsR0FBRyxJQUFXO1FBRWYsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUN2RSxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7U0FDM0U7O1FBQ0QsSUFBSSxJQUFJLEdBQXdCLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUV4QyxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVk7Y0FDOUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXhDLElBQUksQ0FBQyxVQUFVLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUMsVUFBVTtjQUN4RCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUUzRCxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUM3RCwwRUFBMEUsQ0FBQyxDQUFDO1FBRWhGLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDM0I7YUFBTTtZQUNILElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUN6RDtRQUVELElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDM0MsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztLQUN6Qzs7Ozs7O0lBR0QsSUFBSSxDQUFDLE9BQWUsRUFBRSxHQUFXO1FBRTdCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUM3QixJQUFJLENBQUMsS0FBSyxDQUFDLG9CQUFvQixHQUFHLE9BQU8sQ0FBQztRQUUxQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ3RCLE9BQU87U0FDVjtRQUNELElBQUksT0FBTyxLQUFLLEdBQUcsRUFBRTs7WUFDakIsT0FBTyxHQUFHLEVBQUUsQ0FBQztTQUNoQjs7UUFJRCxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQztRQUN4QyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztRQUNqRCxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsS0FBSyxDQUFNLE9BQU8sRUFBRSxHQUFHLENBQUM7YUFDOUQsU0FBUyxDQUFDLENBQUMsTUFBYTtZQUVyQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7WUFFNUIsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtnQkFDeEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOztvQkFDMUQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDM0MsV0FBVyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDdkQ7YUFDSjtZQUVELElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLE9BQU8sQ0FBQztTQUN2QyxDQUFDLENBQUM7S0FDVjs7Ozs7Ozs7O0lBU0QsZ0JBQWdCO1FBRVosT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDLE1BQU0sSUFBSSxVQUFVLENBQUMsaUJBQWlCLENBQUM7S0FDOUU7Ozs7O0lBRUQsSUFBSTtRQUVBLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDdkQ7Ozs7SUFFRCxLQUFLO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFDdkIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7S0FDckI7Ozs7O0lBRUQsT0FBTztRQUVILE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUNuQzs7Ozs7SUFFRCxXQUFXLENBQUMsS0FBVTtRQUVsQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDMUIsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7O1lBQ2hCLElBQUksS0FBSyxHQUFVLEtBQUssQ0FBQztZQUN6QixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztTQUNwRTthQUFNO1lBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM1QztRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztLQUU5Qjs7OztJQUdELElBQUksU0FBUztRQUVULE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUM7S0FDcEM7Q0FDSjs7Ozs7QUFHRCwrQkFBc0MsSUFBeUI7SUFFM0QsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Q0FDM0Q7Ozs7OztBQ3RMRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVIQSxNQUFhLDhCQUE4QixHQUFRO0lBQy9DLE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLGdCQUFnQixDQUFDO0lBQy9DLEtBQUssRUFBRSxJQUFJO0NBQ2QsQ0FBQztBQWVGLHNCQUE4QixTQUFRLGlCQUFpQjs7Ozs7OztJQTJHbkQsWUFBbUIsR0FBZ0IsRUFBVSxZQUF3QixFQUM1QixVQUE2QixFQUVoRCxlQUFrQztRQUNwRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSmIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUFVLGlCQUFZLEdBQVosWUFBWSxDQUFZO1FBQzVCLGVBQVUsR0FBVixVQUFVLENBQW1CO1FBRWhELG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7Ozs7eUJBdEdwQyxFQUFFOzs7OzsrQkFRSSxDQUFDOzs7OzsyQkFlSixJQUFJO3FCQW9CWCxHQUFHOzs7OzJCQWtCYyxJQUFJLFlBQVksRUFBRTtRQTRDL0MsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFOztZQUUzQixJQUFJLENBQUMsV0FBVyxHQUFHLFFBQVEsQ0FBQztTQUMvQjs7UUFFRCxJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQztLQUMxQjs7OztJQUVELFFBQVE7UUFDSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFakIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBRTFCLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUNsQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7U0FDekI7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDbEUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN2RDtRQUVELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBR3pCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7U0FDeEQ7YUFBTTtZQUNILElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdEIsSUFBSSxDQUFDLFdBQVcscUJBQWlCLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQSxDQUFDO2FBQ3ZFO1NBQ0o7S0FDSjs7Ozs7OztJQU9ELGVBQWU7UUFDWCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFO1lBQ3BDLE9BQU87U0FDVjs7UUFFRCxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQzNELDhCQUE4QixDQUFDLENBQUM7UUFFcEMsSUFBSSxTQUFTLENBQUMsV0FBVyxDQUFDLEVBQUU7O1lBQ3hCLElBQUksV0FBVyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDakQsV0FBVyxDQUFDLFNBQVMsR0FBRyxzQ0FBc0MsQ0FBQztZQUMvRCxXQUFXLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFOztZQUN4RSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsaUJBQWlCLFlBQVksVUFBVTtnQkFDekQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUM7WUFFbEUsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDaEU7S0FDSjs7Ozs7O0lBTUQsa0JBQWtCO1FBQ2QsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtZQUNwQyxPQUFPO1NBQ1Y7O1FBRUQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQ3pELHlDQUF5QyxDQUFDLENBQUM7UUFDL0MsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDeEMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQVM7Z0JBQ3JCLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQzthQUNqQixDQUFDLENBQUM7U0FDTjtLQUNKOzs7Ozs7Ozs7OztJQVVELEtBQUssQ0FBQyxPQUFlOztRQUNqQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsaUJBQWlCLENBQUMsU0FBUyxDQUFDO1FBQzNFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQzs7O1FBS3RDLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFO1lBQzFELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUMzQztLQUNKOzs7Ozs7Ozs7SUFTRCxlQUFlLENBQUMsS0FBVTtRQUN0QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLFVBQVUsQ0FBQztZQUNQLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDbkIsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUNYOzs7Ozs7Ozs7OztJQVVELFVBQVUsQ0FBQyxJQUFTO1FBQ2hCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ2pELElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxFQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO1FBQ3hFLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLEVBQUMsUUFBUSxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7UUFFL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUVyQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQy9DLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRW5ELElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFFckMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtZQUNwQyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxLQUFLO2dCQUNsRCxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1NBQ25EO0tBQ0o7Ozs7Ozs7O0lBUUQsV0FBVyxDQUFDLElBQVM7UUFDakIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztRQUNyQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBRXRDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUVwRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsRUFBQyxTQUFTLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO1FBRS9DLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFHL0MsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEVBQUU7WUFDdkMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFVBQVUsRUFBRSxDQUFDO1NBQzNDO0tBRUo7Ozs7Ozs7Ozs7SUFTRCxXQUFXLENBQUMsSUFBUztRQUNqQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO1FBRXpDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQ2xDLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1NBRXRDO2FBQU0sSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUM3QyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBRTFDO2FBQU07WUFDSCxPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUMxQjtLQUNKOzs7Ozs7OztJQVFELGdCQUFnQjs7UUFDWixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQyxNQUFNO1lBQzdELElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLHVCQUF1QixDQUFDO1FBQ2xELElBQUksWUFBWSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFO1lBQ3BFLE9BQU8sRUFBRSxDQUFDO1NBQ2I7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFO1lBQy9DLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztTQUN4QjtRQUNELE9BQU8sR0FBRyxZQUFZLG1CQUFtQixDQUFDO0tBQzdDOzs7Ozs7O0lBUUQsbUJBQW1CO1FBQ2YsT0FBTyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUM7ZUFDdEUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7S0FDekM7Ozs7SUFFRCxlQUFlO1FBQ1gsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQ3ZDOzs7O0lBR0Qsb0JBQW9CO1FBQ2hCLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0tBQzVDOzs7Ozs7Ozs7OztJQVdELFVBQVUsQ0FBQyxLQUFVO1FBQ2pCLElBQUksT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2hCLE9BQU87U0FDVjtRQUVELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUM1QixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0QzthQUFNOztZQUNILElBQUksUUFBUSxHQUEwQixJQUFJLHFCQUFxQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQzs7WUFDbEYsSUFBSSxPQUFPLEdBQWlCLElBQUksWUFBWSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDekUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUU3QixJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0QztRQUVELElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0tBQzVCOzs7OztJQUVELGNBQWMsQ0FBQyxZQUEyQjtRQUN0QyxNQUFNLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUNuQywyREFBMkQsQ0FBQyxDQUFDO1FBRWpFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBQ2pCLEdBQUcsRUFBRSxJQUFJLENBQUMsZ0JBQWdCO1lBQzFCLFNBQVMsRUFBRSxTQUFTLENBQUMsUUFBUTtZQUM3QixTQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDckIsS0FBSyxFQUFFLFlBQVk7WUFDbkIsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXO1NBQ2hDLENBQUMsQ0FBQztLQUNOOzs7Ozs7OztJQVFPLGlCQUFpQjtRQUNyQixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRTtZQUNuQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDdkU7YUFBTTtZQUNILElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztTQUN0RTtRQUNELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUM3QixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztTQUN4RDs7OztZQXRaUixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFlBQVk7Z0JBQ3RCLG9pR0FBcUM7Z0JBRXJDLFNBQVMsRUFBRTtvQkFDUCw4QkFBOEI7b0JBQzlCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQyxFQUFDO29CQUM3RSxFQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLGlCQUFpQixFQUFFLElBQUksRUFBRSxDQUFDLGFBQWEsRUFBRSxXQUFXLENBQUMsRUFBQztpQkFDMUY7O2FBR0o7Ozs7WUF2SGUsV0FBVztZQWJ2QixVQUFVO1lBZ0JOLGlCQUFpQix1QkFpT1IsTUFBTSxTQUFDLFdBQVc7WUFuTzNCLGlCQUFpQix1QkFvT1IsUUFBUSxZQUFJLFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0saUJBQWlCLENBQUM7Ozt3QkF0RzlFLEtBQUs7OEJBUUwsS0FBSzsrQkFRTCxLQUFLOzBCQU9MLEtBQUs7eUJBUUwsS0FBSztnQ0FRTCxLQUFLO29CQUlMLEtBQUs7K0JBT0wsS0FBSztvQkFJTCxLQUFLOzBCQU9MLE1BQU07MkJBb0JOLFlBQVksU0FBQyxVQUFVO2dDQUl2QixZQUFZLFNBQUMsZUFBZTtvQ0FHNUIsU0FBUyxTQUFDLGVBQWU7Z0NBR3pCLFNBQVMsU0FBQyxlQUFlOzs7Ozs7O0FDNU85Qjs7O1lBU0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixnQkFBZ0I7aUJBQ25CO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsbUJBQW1CO29CQUNuQixrQkFBa0I7b0JBQ2xCLGlCQUFpQjtvQkFDakIscUJBQXFCO2lCQUV4QjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IsZ0JBQWdCO2lCQUNuQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsZ0JBQWdCO29CQUNoQixtQkFBbUI7b0JBQ25CLFdBQVc7aUJBQ2Q7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUMvQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0VBLE1BQWEseUJBQXlCLEdBQVE7SUFDMUMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0saUJBQWlCLENBQUM7SUFDaEQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBYUYsdUJBQStCLFNBQVEsaUJBQWlCOzs7OztJQXlEcEQsWUFBbUIsR0FBZ0IsRUFFYixlQUFrQztRQUVwRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSmIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUViLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7OzsyQkE5QnZCLElBQUksWUFBWSxFQUFFO0tBaUNsRDs7Ozs7OztJQU9ELFFBQVE7UUFHSixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkIsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2pCLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FFN0M7YUFBTTtZQUNILElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDdEIsSUFBSSxDQUFDLFdBQVcscUJBQWlCLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQSxDQUFDO2FBQ3ZFO1NBQ0o7OztRQUtELElBQUksQ0FBQyxZQUFZLEdBQUcsRUFBRSxDQUFDOzs7Ozs7Ozs7OztRQVl2QixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksaUJBQWlCLENBQUMsV0FBVyxFQUFFO1lBRTNFLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQVM7Z0JBRWhGLE9BQU8sRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUMsQ0FBQzthQUNoRCxDQUFDLENBQUM7U0FDTjthQUFNLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM3QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQVM7Z0JBRWpELE9BQU8sRUFBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUMsQ0FBQzthQUNoRCxDQUFDLENBQUM7U0FDTjtLQUNKOzs7O0lBR0QsbUJBQW1CO1FBRWYsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQ3ZDOzs7Ozs7Ozs7SUFRRCxTQUFTLENBQUMsSUFBUztRQUVmLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQzFCOzs7Ozs7SUFPRCxVQUFVO1FBRU4sT0FBTyxLQUFLLENBQUM7O0tBRWhCOzs7Ozs7OztJQU9ELGVBQWUsQ0FBQyxLQUFVO1FBRXRCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQztRQUM3QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbkMsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUMxQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxFQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO1NBQ2xEO1FBRUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDcEM7Ozs7O0lBRUQsV0FBVyxDQUFDLElBQVM7UUFFakIsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxjQUFjLENBQUM7S0FDeEQ7Ozs7Ozs7SUFNRCxVQUFVLENBQUMsS0FBVTtRQUVqQixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFFaEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7WUFDdkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEM7S0FFSjs7Z0NBM0s2QixFQUFFOztZQWJuQyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGFBQWE7Z0JBQ3ZCLCt5REFBc0M7Z0JBRXRDLFNBQVMsRUFBRTtvQkFDUCx5QkFBeUI7b0JBQ3pCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxpQkFBaUIsQ0FBQyxFQUFDO2lCQUNqRjs7YUFFSjs7OztZQWxFTyxXQUFXO1lBQ1gsaUJBQWlCLHVCQTRIUixRQUFRLFlBQUksUUFBUSxZQUFJLE1BQU0sU0FBQyxVQUFVLENBQUMsTUFBTSxpQkFBaUIsQ0FBQzs7O21CQWxEOUUsS0FBSzt3QkFNTCxLQUFLO2dDQVFMLEtBQUs7MEJBTUwsTUFBTTsyQkFtQk4sWUFBWSxTQUFDLGNBQWM7Ozs7Ozs7QUNoSWhDOzs7WUFRQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGlCQUFpQjtpQkFDcEI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7b0JBQ1osV0FBVztvQkFDWCxtQkFBbUI7b0JBQ25CLGNBQWM7b0JBQ2QscUJBQXFCO2lCQUN4QjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IsaUJBQWlCO2lCQUNwQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsaUJBQWlCO29CQUNqQixtQkFBbUI7b0JBQ25CLFdBQVc7aUJBQ2Q7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUNoREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0EsTUFBYSwrQkFBK0IsR0FBUTtJQUNoRCxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxpQkFBaUIsQ0FBQztJQUNoRCxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUFhRix1QkFBK0IsU0FBUSxpQkFBaUI7Ozs7O0lBK0NwRCxZQUFtQixHQUFnQixFQUViLGVBQWtDO1FBRXBELEtBQUssQ0FBQyxHQUFHLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFKYixRQUFHLEdBQUgsR0FBRyxDQUFhO1FBRWIsb0JBQWUsR0FBZixlQUFlLENBQW1COzs7OztvQ0FuQ3hCLEtBQUs7O1FBd0NqQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFdEIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFakQsR0FBRyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFjO1lBQ3hDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFN0MsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQ25DLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDMUI7U0FDSixDQUFDLENBQUM7S0FDTjs7OztJQUVELFFBQVE7UUFHSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakIsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV0QyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFdEIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7WUFDakMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEQ7O1FBR0QsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDO1NBQ2hEO2FBQU07WUFDSCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksS0FBSyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQztTQUN4RDtRQUVELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzlEOzs7O0lBR08sY0FBYztRQUVsQixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDcEQsSUFBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztTQUMxRDs7Ozs7Ozs7O0lBVUwsT0FBTyxDQUFDLEVBQU87UUFFWCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdkQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsQ0FBQztTQUNwRDtLQUNKOzs7Ozs7SUFNRCxNQUFNLENBQUMsRUFBTztRQUVWLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBQyxDQUFDLENBQUM7UUFDMUQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFM0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbkM7Ozs7O0lBRUQsV0FBVyxDQUFDLFFBQWE7UUFFckIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFFBQVEsQ0FBQztRQUNsQyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUU5RDs7Ozs7O0lBT08sY0FBYyxDQUFDLEdBQVE7UUFFM0IsSUFBSSxDQUFDLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUMxQixPQUFPLEdBQUcsQ0FBQztTQUNkO1FBRUQsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDWixPQUFPLEdBQUcsQ0FBQztTQUNkOztRQUVELElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQztRQUNqQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRTtZQUN4QixJQUFJLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDO1NBQ2pDO1FBRUQsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsaUJBQWlCLEVBQUMsQ0FBQyxDQUFDOztRQUdsRSxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUM7O1FBRXJCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUMzQixNQUFNLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7U0FDcEM7UUFDRCxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDOzs7OztJQUdwRSxnQkFBZ0I7UUFDWixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzlELE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDO1NBQ2pDO1FBQ0QsT0FBTyxFQUFFLENBQUM7S0FDYjs7OztJQUVELElBQ0ksVUFBVTtRQUVWLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztLQUMzQjs7Ozs7SUFFRCxJQUFJLFVBQVUsQ0FBQyxLQUFZO1FBRXZCLElBQUksU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2xCLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1NBQzVCO0tBQ0o7Ozs7Ozs7SUFNRCxVQUFVLENBQUMsS0FBVTtRQUVqQixJQUFJLENBQUMsS0FBSyxZQUFZLEtBQUssS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3hELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQzthQUNoRDtZQUNELElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQzNELElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN6QztLQUNKOzs7WUE5TUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxhQUFhO2dCQUN2QixrNkNBQXNDO2dCQUV0QyxTQUFTLEVBQUU7b0JBQ1AsK0JBQStCO29CQUMvQixFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0saUJBQWlCLENBQUMsRUFBQztpQkFDakY7O2FBRUo7Ozs7WUFwRE8sV0FBVztZQUNYLGlCQUFpQix1QkFvR1IsUUFBUSxZQUFJLFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sZ0JBQWdCLENBQUM7OztvQkExQzdFLEtBQUs7bUNBT0wsS0FBSztnQ0FNTCxLQUFLO3dCQVFMLEtBQUs7eUJBOElMLEtBQUs7Ozs7O0FBaUNWOzs7Ozs7SUFJSSxZQUE0QixTQUFpQixDQUFDLEVBQWtCLFdBQW1CLEtBQUssRUFDNUQsU0FBaUIsT0FBTztRQUR4QixXQUFNLEdBQU4sTUFBTSxDQUFZO1FBQWtCLGFBQVEsR0FBUixRQUFRLENBQWdCO1FBQzVELFdBQU0sR0FBTixNQUFNO0tBRWpDOzs7O0lBR0QsUUFBUTtRQUVKLE9BQU87WUFDSCxNQUFNLEVBQUUsTUFBTTtZQUNkLFFBQVEsRUFBRSxNQUFNO1lBQ2hCLE1BQU0sRUFBRSxNQUFNO1NBQ2pCLENBQUM7S0FDTDs7OztJQUVELFNBQVM7UUFFTCxPQUFPLE9BQU8sQ0FBQztLQUNsQjs7OztJQUVELE1BQU07UUFFRixPQUFPLElBQUksS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7S0FDbkM7Ozs7SUFFRCxRQUFRO1FBRUosT0FBTyxJQUFJLENBQUMsTUFBTSxHQUFHLFlBQVksR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO0tBQ2pGOzs7OztJQUdELEtBQUssQ0FBQyxPQUFnRSxFQUFFO1FBRXBFLE9BQU8sSUFBSSxLQUFLLENBQ1osU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQ2xELFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUN4RCxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FDckQsQ0FBQztLQUNMO0NBRUo7Ozs7OztBQzFSRDs7O1lBU0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixpQkFBaUI7aUJBQ3BCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsbUJBQW1CO29CQUNuQkMsaUJBQWU7b0JBQ2YsY0FBYztvQkFDZCxnQkFBZ0I7b0JBQ2hCLG1CQUFtQjtvQkFDbkIscUJBQXFCO2lCQUN4QjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IsaUJBQWlCO2lCQUNwQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsaUJBQWlCO29CQUNqQixtQkFBbUI7b0JBQ25CLFdBQVc7aUJBQ2Q7Z0JBQ0QsU0FBUyxFQUFFLENBQUMsWUFBWSxDQUFDO2FBQzVCOzs7Ozs7O0FDaENEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0ZBLE1BQWEsK0JBQStCLEdBQVE7SUFDaEQsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0sb0JBQW9CLENBQUM7SUFDbkQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBWUYsMEJBQWtDLFNBQVEsaUJBQWlCOzs7OztJQStGdkQsWUFBbUIsR0FBZ0IsRUFFYixlQUFrQztRQUNwRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSGIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUViLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7Ozs7NkJBaEZoQyxVQUFVOzs7OzsrQkFRUixVQUFVOzs7OzhCQU9WLEtBQUs7Ozs7d0JBYVgsSUFBSTs7Ozt3QkFNSixLQUFLOzs7Ozt3QkFRTCxJQUFJOzs7Ozs7OzBCQVVILElBQUk7Ozs7O3dCQU9NLElBQUksWUFBWSxFQUFROzs7OzsyQkFNbkMsSUFBSSxJQUFJLEVBQUU7K0JBVUosT0FBTztLQU9oQzs7OztJQUVELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakIsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzs7UUFHdEMsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUksRUFBRTtZQUN0RCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztTQUMxQjtRQUVELElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxLQUFLLElBQUk7WUFDNUMsSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRTlFLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBUztZQUMzRSxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztZQUNqQixJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUNuQyxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUV4QixJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFjO1lBQzdDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1NBRTNCLENBQUMsQ0FBQztLQUVOOzs7Ozs7O0lBUU8sZ0JBQWdCO1FBRXBCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQzdDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2hCLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGFBQWEsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEtBQUssSUFBSTtnQkFDbEUsSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxDQUFDO1NBRWpGO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFOztZQUNmLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2pELElBQUksVUFBVSxLQUFLLENBQUMsQ0FBQyxFQUFFO2dCQUNuQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQ3pFO1lBQ0QsSUFBSSxDQUFDLGVBQWUsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEtBQUssSUFBSTtnQkFDN0MsSUFBSSxvQkFBb0IsQ0FBQyxRQUFRLEVBQUUsR0FBRyxJQUFJLG9CQUFvQixDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ2pGO1FBR0QsSUFBSSxDQUFDLElBQUksR0FBRztZQUNSLGNBQWMsRUFBRSxDQUFDO1lBQ2pCLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsUUFBUTtnQkFDdkUsVUFBVSxDQUFDO1lBQ2YsYUFBYSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDO1lBQ2hFLFdBQVcsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQztZQUNoRCxVQUFVLEVBQUUsQ0FBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsUUFBUTtnQkFDakYsV0FBVyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDO1lBQ25ELGVBQWUsRUFBRSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUs7Z0JBQ2xGLEtBQUssRUFBRSxLQUFLLENBQUM7U0FDcEIsQ0FBQzs7Ozs7Ozs7O0lBVU4sWUFBWSxDQUFDLEtBQVU7UUFFbkIsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7O1lBRWhCLE9BQU87U0FDVjtRQUVELElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVyRCxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztRQUMxRSxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbEM7Ozs7Ozs7SUFNRCxVQUFVLENBQUMsS0FBVTtRQUNqQixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3BDO0tBRUo7O2dDQW5Na0MsU0FBUztnQ0FDVCxTQUFTOztZQWIvQyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGNBQWM7Z0JBQ3hCLHloREFBMkM7Z0JBRTNDLFNBQVMsRUFBRTtvQkFDUCwrQkFBK0I7b0JBQy9CLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxvQkFBb0IsQ0FBQyxFQUFDO2lCQUNwRjs7YUFFSjs7OztZQXBGTyxXQUFXO1lBRVgsaUJBQWlCLHVCQW1MUixRQUFRLFlBQUksUUFBUSxZQUFJLE1BQU0sU0FBQyxVQUFVLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7O29CQXZGN0UsS0FBSzs0QkFPTCxLQUFLOzhCQVFMLEtBQUs7NkJBT0wsS0FBSzt3QkFPTCxLQUFLO3VCQU1MLEtBQUs7dUJBTUwsS0FBSzt1QkFRTCxLQUFLO3lCQVVMLEtBQUs7dUJBT0wsTUFBTTs7Ozs7OztBQy9MWDs7O1lBT0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixvQkFBb0I7aUJBQ3ZCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsbUJBQW1CO29CQUNuQixjQUFjO29CQUNkLG1CQUFtQjtpQkFDdEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLG9CQUFvQjtpQkFDdkI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLG9CQUFvQjtvQkFDcEIsbUJBQW1CO29CQUNuQixXQUFXO2lCQUNkO2FBQ0o7Ozs7Ozs7QUNORDs7Ozs7QUFXQTs7O1lBSkMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLFFBQVEsRUFBRSwyQkFBMkI7YUFDeEM7Ozs7Ozs7QUNWRDs7Ozs7QUFXQTs7O1lBSkMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLFFBQVEsRUFBRSwyQkFBMkI7YUFDeEM7Ozs7Ozs7QUNWRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkVBLHFCQUE2QixTQUFRLGNBQWM7Ozs7SUE4RC9DLFlBQW1CLEdBQWdCO1FBRS9CLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUZJLFFBQUcsR0FBSCxHQUFHLENBQWE7Ozs7NkJBM0NBLElBQUksWUFBWSxFQUFFOzs7O3FCQU1wQyxJQUFJOzs7O3dCQU1ELElBQUk7Ozs7dUJBWUssSUFBSSxZQUFZLEVBQUU7Ozs7c0JBTW5CLElBQUksWUFBWSxFQUFFO1FBaUIxQyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQztRQUNqQixJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztLQUN4Qjs7Ozs7SUFLRCxJQUFJO1FBRUEsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7UUFDcEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQzs7UUFHbkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakM7Ozs7O0lBS0QsS0FBSztRQUVELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7Ozs7UUFLcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbEM7Ozs7OztJQU1ELFNBQVM7UUFFTCxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDakM7Ozs7OztJQU1ELFNBQVM7UUFFTCxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDakM7OztZQXJISixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFdBQVc7Z0JBQ3JCLHltQkFBb0M7O2FBRXZDOzs7O1lBM0VPLFdBQVc7OztvQkFrRmQsS0FBSzttQkFPTCxLQUFLOzRCQUtMLE1BQU07b0JBTU4sS0FBSzt1QkFNTCxLQUFLO3VCQU1MLEtBQUs7c0JBTUwsTUFBTTtxQkFNTixNQUFNO3FCQU1OLFlBQVksU0FBQyxxQkFBcUI7cUJBS2xDLFlBQVksU0FBQyxxQkFBcUI7Ozs7Ozs7QUN4SXZDOzs7WUFTQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGVBQWU7b0JBQ2YscUJBQXFCO29CQUNyQixxQkFBcUI7aUJBQ3hCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLHFCQUFxQjtvQkFDckIsWUFBWTtpQkFDZjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IsY0FBYztvQkFDZCxlQUFlO29CQUNmLHFCQUFxQjtvQkFDckIscUJBQXFCO2lCQUN4QjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsZUFBZTtvQkFDZixxQkFBcUI7b0JBQ3JCLHFCQUFxQjtvQkFDckIscUJBQXFCO2lCQUN4QjtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQ2pDRDs7Ozs7Ozs7QUE4Q0EsNkJBQXFDLFNBQVEsaUJBQWlCOzs7Ozs7O0lBaUYxRCxZQUFtQixHQUFnQixFQUFVLGNBQWdDLEVBQ3JDLFVBQTZCLEVBRS9DLGVBQWtDO1FBRXBELEtBQUssQ0FBQyxHQUFHLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFMYixRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQVUsbUJBQWMsR0FBZCxjQUFjLENBQWtCO1FBQ3JDLGVBQVUsR0FBVixVQUFVLENBQW1CO1FBRS9DLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7OzsyQkF6Q2pDLEtBQUs7S0E0QzNCOzs7O0lBR0QsUUFBUTtRQUVKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVqQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxtQkFBTSxJQUFJLENBQUMsY0FBYyxDQUFDLFFBQVEsR0FBRSxJQUFJLENBQUMsT0FBTyxDQUFDO1NBQ2xFO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7O1FBQ3ZDLElBQUksbUJBQW1CLEdBQUcsSUFBSSxDQUFDO1FBRS9CLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN0QixtQkFBbUIsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3ZFO2FBQU07WUFDSCxtQkFBbUIsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDbkY7O1FBRUQsSUFBSSxhQUFhLEdBQUcsbUJBQW1CLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ2pGLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFN0IsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRTtZQUV6QixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztnQkFDakIsWUFBWSxFQUFFLG1CQUFtQjtnQkFDakMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxRQUFRO2dCQUM3QixTQUFTLEVBQUUsSUFBSSxDQUFDLFVBQVU7Z0JBQzFCLEtBQUssRUFBRSxJQUFJLFlBQVksQ0FBQyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDO2dCQUNuRSxXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7YUFDaEMsQ0FBQyxDQUFDO1NBQ047YUFBTTs7WUFHSCxJQUFJLENBQUMsSUFBSSxHQUFHLG1CQUFtQixDQUFDLElBQUksRUFBRSxDQUFDO1NBQzFDO1FBQ0QsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUV4QixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7O1lBRXpCLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxlQUFlLENBQUM7U0FDNUM7S0FDSjs7Ozs7Ozs7SUFPTyxRQUFRLENBQUMsYUFBcUI7UUFFbEMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3BCLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLGFBQWEsSUFBSSxDQUFDLElBQUksYUFBYSxHQUFHLENBQUMsSUFBSSxTQUFTLEdBQUcsVUFBVSxDQUFDO2FBQ2xGO2lCQUFNO2dCQUNILElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxhQUFhLElBQUksQ0FBQyxJQUFJLGFBQWEsR0FBRyxFQUFFLElBQUksU0FBUztzQkFDNUQsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLE9BQU87d0JBQzNCLFVBQVUsQ0FBQzthQUN0QjtTQUNKOzs7Ozs7Ozs7O0lBVUcsZ0JBQWdCO1FBRXBCLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUN0QixNQUFNLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1NBQ25EO1FBRUQsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ25CLE1BQU0sS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7U0FDeEQ7UUFDRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQ3RELE1BQU0sS0FBSyxDQUFDLDBFQUEwRSxDQUFDLENBQUM7U0FDM0Y7UUFFRCxJQUFJLFNBQVMsQ0FDTCxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ2IsSUFBSSxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVLElBQUksSUFBSSxDQUFDLElBQUksS0FBSyxVQUFVO2dCQUMxRSxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxFQUFFO1lBQzlCLE1BQU0sS0FBSyxDQUFDLG1EQUFtRCxDQUFDLENBQUM7U0FDcEU7UUFFRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7U0FDaEM7Ozs7Ozs7Ozs7Ozs7SUFZTCxZQUFZLENBQUMsSUFBUztRQUVsQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDMUIsT0FBTyxJQUFJLENBQUM7U0FDZjs7UUFDRCxJQUFJLFVBQVUsR0FBRyxTQUFTLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDaEUsSUFBSSxVQUFVLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDeEIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2hDO1FBQ0QsT0FBTyxVQUFVLENBQUM7S0FDckI7Ozs7OztJQU9ELElBQUksU0FBUztRQUVULE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ2xEOzs7Ozs7O0lBTUQsSUFBSSxTQUFTLENBQUMsS0FBVTtRQUVwQixJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0tBQ2xEOzs7OztJQUdELFdBQVcsQ0FBQyxLQUFVO1FBRWxCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBRXZCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUMxQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBRWxDOzs7WUFoUEosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLHdvRUFBNkM7Z0JBRTdDLFNBQVMsRUFBRTtvQkFDUCxFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0sdUJBQXVCLENBQUMsRUFBQztvQkFDcEYsRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsQ0FBQyxhQUFhLEVBQUUsV0FBVyxDQUFDLEVBQUM7aUJBQzFGOzthQUVKOzs7O1lBbkNHLFdBQVc7WUFIWCxnQkFBZ0I7WUFlWixpQkFBaUIsdUJBMEdSLE1BQU0sU0FBQyxXQUFXO1lBM0czQixpQkFBaUIsdUJBNEdSLFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGlCQUFpQixDQUFDOzs7bUJBN0U5RSxLQUFLO3FCQU1MLEtBQUs7a0JBT0wsS0FBSzsrQkFRTCxLQUFLO21DQVFMLEtBQUs7MEJBT0wsS0FBSzttQkFPTCxLQUFLO3lCQU9MLEtBQUs7Z0NBY0wsS0FBSzs7Ozs7O0FBdUtWLG9CQUE0QixTQUFRLHFCQUFxQjs7OztJQUdyRCxZQUFvQixRQUFpQztRQUVqRCxLQUFLLEVBQUUsQ0FBQztRQUZRLGFBQVEsR0FBUixRQUFRLENBQXlCO0tBR3BEOzs7Ozs7SUFFRCxpQkFBaUIsQ0FBQyxTQUFjLEVBQUUsUUFBaUI7UUFFL0MsSUFBSSxRQUFRLEtBQUssSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN6QyxPQUFPO1NBQ1Y7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFOztZQUszQixJQUFJLFFBQVEsR0FBZSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNyRixJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDbkIsUUFBUSxHQUFHLEVBQUUsQ0FBQzthQUVqQjtpQkFBTSxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsRUFBRTtnQkFDbEQsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO2FBQzlFO1lBRUQsSUFBSSxRQUFRLEVBQUU7Z0JBQ1YsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDO2FBRXRDO2lCQUFNO2dCQUNILFdBQVcsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQ2xEO1NBRUo7YUFBTTtZQUNILElBQUksQ0FBQyxTQUFTLEVBQUU7Z0JBQ1osU0FBUyxHQUFHLElBQUksQ0FBQzthQUNwQjtZQUNELElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztTQUV2QztLQUNKOzs7O0lBRUQsY0FBYztRQUVWLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUU7O1lBQzNCLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUNyQyxPQUFPLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQy9FLE9BQU8sQ0FBQyxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztLQUNsQzs7OztJQUVELGVBQWU7O1FBRVgsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUM7UUFDeEMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDakQsU0FBUyxHQUFHLEVBQUUsQ0FBQztTQUNsQjtRQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDdEY7Ozs7O0lBRUQsVUFBVSxDQUFDLFNBQWM7UUFFckIsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRTtZQUMzQixPQUFPLFdBQVcsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGVBQWUsRUFBRSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQ3pFOztRQUNELElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNyQyxPQUFPLE1BQU0sQ0FBQyxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUM7S0FDdEM7Q0FDSjs7Ozs7O0FDcFdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQSxNQUFhLDhCQUE4QixHQUFRO0lBQy9DLE9BQU8sRUFBRSxpQkFBaUI7SUFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLHdCQUF3QixDQUFDO0lBQ3ZELEtBQUssRUFBRSxJQUFJO0NBQ2QsQ0FBQztBQWFGLDhCQUFzQyxTQUFRLGlCQUFpQjs7Ozs7SUF1QzNELFlBQW1CLEdBQWdCLEVBRWIsZUFBa0M7UUFFcEQsS0FBSyxDQUFDLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUpiLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFFYixvQkFBZSxHQUFmLGVBQWUsQ0FBbUI7Ozs7OzsyQkFYdkIsSUFBSSxZQUFZLEVBQU87S0FjdkQ7Ozs7SUFFRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWpCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztTQUNsQjtRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDNUM7Ozs7Ozs7OztJQVNELFVBQVUsQ0FBQyxJQUFTO1FBRWhCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTtZQUNoQyxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDcEM7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUMxQjs7Ozs7Ozs7O0lBU0QsS0FBSyxDQUFDLElBQVM7UUFFWCxPQUFPLElBQUksQ0FBQztLQUNmOzs7Ozs7Ozs7SUFTRCxRQUFRLENBQUMsS0FBVTs7UUFFZixJQUFJLFlBQVksR0FBUSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU5QyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ2xDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRTtZQUNwQyxTQUFTLEVBQUUsSUFBSTtZQUNmLHFCQUFxQixFQUFFLEtBQUs7U0FDL0IsQ0FBQyxDQUFDO0tBQ047Ozs7Ozs7SUFPRCxXQUFXLENBQUMsU0FBYzs7UUFFdEIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFTO1lBRXRDLE9BQU8sU0FBUyxLQUFLLElBQUksQ0FBQztTQUM3QixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO0tBQ3pDOzs7O0lBRUQsa0JBQWtCOztRQUVkLElBQUksWUFBWSxHQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRTtZQUNwQyxTQUFTLEVBQUUsSUFBSTtZQUNmLHFCQUFxQixFQUFFLEtBQUs7U0FDL0IsQ0FBQyxDQUFDOztLQUdOOzs7Ozs7O0lBTUQsVUFBVSxDQUFDLEtBQVU7UUFFakIsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssRUFBRTs7WUFDdEIsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDOUI7S0FFSjs7O1lBdkpKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUscUJBQXFCO2dCQUMvQixxWkFBK0M7Z0JBRS9DLFNBQVMsRUFBRTtvQkFDUCw4QkFBOEI7b0JBQzlCLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSx3QkFBd0IsQ0FBQyxFQUFDO2lCQUN4Rjs7YUFFSjs7OztZQTFETyxXQUFXO1lBQ1gsaUJBQWlCLHVCQWtHUixRQUFRLFlBQUksUUFBUSxZQUFJLE1BQU0sU0FBQyxVQUFVLENBQUMsTUFBTSxnQkFBZ0IsQ0FBQzs7O21CQWxDN0UsS0FBSzt3QkFPTCxLQUFLOzZCQU9MLEtBQUs7MEJBU0wsTUFBTTs7Ozs7OztBQ3BHWDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEZBLE1BQWEsMEJBQTBCLEdBQVE7SUFDM0MsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0sb0JBQW9CLENBQUM7SUFDbkQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBYUYsMEJBQWtDLFNBQVEsaUJBQWlCOzs7OztJQWlDdkQsWUFBb0IsR0FBZ0IsRUFFYixlQUFrQztRQUVyRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSlosUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUViLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7Ozs7O3FCQTFCNUMsRUFBRTs7Ozs7d0JBZWUsSUFBSSxZQUFZLEVBQUU7S0FjL0M7Ozs7SUFFRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pCLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3RDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7WUFDcEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FFbkM7YUFBTTtZQUNILElBQUksQ0FBQyxXQUFXLHFCQUFpQixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUEsQ0FBQztTQUN2RTtLQUNKOzs7Ozs7OztJQU9ELGFBQWEsQ0FBRSxNQUFXO1FBRXRCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2hDLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUMsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7U0FDNUQ7UUFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbEM7Ozs7Ozs7SUFNRCxVQUFVLENBQUUsS0FBVTtRQUVsQixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxFQUFDLFNBQVMsRUFBRSxJQUFJLEVBQUMsQ0FBQyxDQUFDO2FBQzVEO1lBRUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbkM7S0FDSjs7O1lBM0ZKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixnaEJBQTBDO2dCQUcxQyxTQUFTLEVBQUU7b0JBQ1AsMEJBQTBCO29CQUMxQixFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0sb0JBQW9CLENBQUMsRUFBQztpQkFDcEY7O2FBQ0o7Ozs7WUFuR08sV0FBVztZQUNYLGlCQUFpQix1QkFxSVAsUUFBUSxZQUFJLFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sZ0JBQWdCLENBQUM7OztvQkExQjlFLEtBQUs7b0JBT0wsS0FBSzt1QkFRTCxNQUFNOzs7Ozs7O0FDcElYOzs7WUFPQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLG9CQUFvQjtpQkFDdkI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7b0JBQ1osV0FBVztvQkFDWCxtQkFBbUI7b0JBQ25CLGlCQUFpQjtpQkFDcEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLG9CQUFvQjtpQkFDdkI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLG9CQUFvQjtvQkFDcEIsbUJBQW1CO29CQUNuQixXQUFXO2lCQUNkO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7O0FDMUJEOzs7WUFPQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLHdCQUF3QjtpQkFDM0I7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7b0JBQ1osV0FBVztvQkFDWCxtQkFBbUI7b0JBQ25CLG1CQUFtQjtpQkFDdEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLHdCQUF3QjtpQkFDM0I7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLHdCQUF3QjtvQkFDeEIsbUJBQW1CO29CQUNuQixXQUFXO2lCQUNkO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7O0FDMUJEOzs7WUFXQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLHVCQUF1QjtpQkFDMUI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7b0JBQ1osV0FBVztvQkFDWCxtQkFBbUI7b0JBQ25CLHFCQUFxQjtvQkFDckIsZ0JBQWdCO29CQUNoQixvQkFBb0I7b0JBQ3BCLGVBQWU7b0JBQ2YsdUJBQXVCO2lCQUMxQjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IsdUJBQXVCO2lCQUMxQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsbUJBQW1CO29CQUNuQixXQUFXO29CQUNYLHVCQUF1QjtpQkFDMUI7YUFDSjs7Ozs7OztBQ3JERDs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7SUFrREk7Ozs7Ozs7NkJBdEJ5QixLQUFLOzs7Ozs7NEJBT1AsQ0FBQyxDQUFDO1FBaUJyQixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7S0FDcEM7Ozs7Ozs7SUFPRCxXQUFXO1FBRVAsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLGlCQUFpQixFQUFFLEVBQUU7O1lBR3JDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsRUFBRTtnQkFFMUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBaUI7b0JBRTNDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsSUFBSSxFQUFFLEVBQUUsS0FBSyxDQUFDLENBQUM7aUJBQ2hELENBQUMsQ0FBQzthQUNOO2lCQUFNO2dCQUNILElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksRUFBRSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3ZEO1NBRUo7YUFBTTtZQUNILElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLENBQUM7U0FDaEM7UUFDRCxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztLQUM5Qjs7OztJQUVELFNBQVM7UUFFTCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUNyQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBRWhEO2FBQU07WUFDSCxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ2hDO1FBQ0QsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7S0FDN0I7Ozs7SUFHRCxJQUFJLGFBQWE7UUFFYixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDLGNBQWMsR0FBRyxFQUFFLENBQUM7U0FDNUI7UUFDRCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7S0FDOUI7Ozs7O0lBR0QsSUFBSSxhQUFhLENBQUUsS0FBWTtRQUUzQixJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztRQUU1QixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDOUIsT0FBTztTQUNWO1FBQ0QsSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFTO1lBRWxDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdEMsQ0FBQyxDQUFDO0tBQ047Ozs7OztJQUdELGVBQWUsQ0FBRSxXQUFrQixFQUFFLFFBQWdCO1FBR2pELElBQUksT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO1lBQ3RCLE9BQU87U0FDVjs7UUFDRCxJQUFJLElBQUksR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOztRQUN6QyxJQUFJLFlBQVksR0FBRyxRQUFRLElBQUksRUFBRSxDQUFDOztRQUNsQyxJQUFJLFFBQVEsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztRQUV2QyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ1gsV0FBVyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNwQyxJQUFJLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxRQUFRLENBQUMsQ0FBQztTQUM1QztRQUVELElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztLQUN0Qzs7Ozs7O0lBRUQsV0FBVyxDQUFFLEtBQVksRUFBRSxRQUFpQjtRQUV4QyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBVTs7WUFFckIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDbkQsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQ3RDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ3JDO1lBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztTQUMzQyxDQUFDLENBQUM7S0FDTjs7Ozs7O0lBRUQsaUJBQWlCLENBQUUsSUFBUyxFQUFFLFVBQW1COzs7UUFJN0MsSUFBSSxJQUFJLENBQUMsVUFBVTtZQUNmLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUNyQyxtQkFBYyxJQUFJLEdBQUUsVUFBVSxHQUFHLFVBQVUsQ0FBQztTQUMvQzthQUFNOztZQUNILElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDL0IsSUFBSSxVQUFVLEtBQUssSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDbkMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDcEM7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsVUFBVSxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsQ0FBQzthQUM5RDtTQUNKO0tBQ0o7Ozs7Ozs7OztJQVFPLFNBQVMsQ0FBRSxJQUFTO1FBRXhCLE9BQU8sUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLG1CQUFTLElBQUksR0FBRSxRQUFRLEVBQUUsR0FBRyxJQUFJLENBQUM7Ozs7OztJQUk3RCxnQkFBZ0IsQ0FBRSxLQUFZO1FBRTFCLElBQUksQ0FBQyxhQUFhLEdBQUcsS0FBSyxDQUFDO1FBRTNCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFTO1lBRXBCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdEMsQ0FBQyxDQUFDO0tBQ047Ozs7O0lBRUQsVUFBVSxDQUFFLElBQVM7UUFFakIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLGlCQUFpQixFQUFFLEVBQUU7WUFDckMsT0FBTyxtQkFBYyxJQUFJLEdBQUUsVUFBVSxDQUFDO1NBQ3pDO2FBQU07O1lBQ0gsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7Z0JBQ2hDLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQzthQUM3QjtZQUNELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDeEM7S0FDSjs7O1lBek1KLFVBQVU7Ozs7Ozs7OztBQ0RYOzs7Ozs7O0FBMERBLHVCQUE4QixJQUFTO0lBRW5DLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLFNBQVMsb0JBQWUsSUFBSSxHQUFFO1dBQ2pELFNBQVMsQ0FBQyxtQkFBYyxJQUFJLEdBQUUsTUFBTSxDQUFDO1dBQ3JDLFNBQVMsQ0FBQyxtQkFBYyxJQUFJLEdBQUUsUUFBUSxDQUFDLENBQUM7Q0FDbEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVJRCx5QkFBaUMsU0FBUSxhQUFhOzs7Ozs7O0lBcUpsRCxZQUFtQixHQUFnQixFQUNmLGdCQUNBLFNBQ0E7UUFFaEIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBTEksUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUNmLG1CQUFjLEdBQWQsY0FBYztRQUNkLFlBQU8sR0FBUCxPQUFPO1FBQ1AsWUFBTyxHQUFQLE9BQU87Ozs7OztvQ0F2SUssSUFBSTs7Ozs7eUJBdUJmLEtBQUs7Ozs7OzttQ0FpQkksRUFBRTt3Q0FrQkksS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBbUJuQixNQUFNOzs7Ozs7OEJBUVEsSUFBSSxZQUFZLEVBQUU7Ozs7Ozs4QkFTbEIsSUFBSSxZQUFZLEVBQUU7d0JBNkJsQyxLQUFLOzs7OzsrQkFNRSxLQUFLO0tBVS9COzs7O0lBRUQsUUFBUTtRQUVKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVqQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1NBQ25DO1FBQ0QsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDaEM7UUFFRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDaEIsSUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztTQUNyQztRQUVELElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7O1FBRzFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQ2xDLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsY0FBYyxDQUFDLENBQUM7UUFFeEUsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1NBQ3ZCO0tBRUo7Ozs7SUFHRCxTQUFTO1FBRUwsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO0tBQ3JCOzs7O0lBRUQsaUJBQWlCO1FBRWIsT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sQ0FBQztLQUNqQzs7Ozs7Ozs7SUFNRCxVQUFVLENBQUMsSUFBUyxFQUFFLGVBQXVCLENBQUMsQ0FBQztRQUUzQyxJQUFJLFlBQVksS0FBSyxDQUFDLElBQUksSUFBSSxDQUFDLHdCQUF3QixFQUFFOztZQUVyRCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFO2dCQUMxQixtQkFBYyxJQUFJLEdBQUUsVUFBVSxHQUFHLElBQUksQ0FBQzthQUN6QztZQUNELE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3RDOzs7Ozs7Ozs7O0lBU0QsZUFBZSxDQUFDLElBQVM7UUFFckIsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUMxQixPQUFPLG1CQUFjLElBQUksR0FBRSxRQUFRLElBQUksRUFBRSxDQUFDO1NBQzdDO2FBQU07WUFDSCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7U0FDakU7S0FDSjs7Ozs7Ozs7SUFRRCxXQUFXLENBQUMsSUFBUztRQUVqQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFOztZQUMxQixJQUFJLFFBQVEsR0FBRyxtQkFBYyxJQUFJLEdBQUUsUUFBUSxDQUFDO1lBQzVDLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1NBRXJEO2FBQU0sSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDekQsTUFBTSxDQUFDLEtBQUssRUFBRSxtQ0FBbUMsQ0FBQyxDQUFDO1NBQ3REO1FBRUQsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7S0FFOUM7Ozs7O0lBRUQsYUFBYSxDQUFDLElBQVM7UUFFbkIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztLQUNwRDs7Ozs7Ozs7OztJQVdELGVBQWU7UUFFWCxJQUFJLElBQUksQ0FBQyxtQkFBbUIsRUFBRTs7WUFFMUIsVUFBVSxDQUFDO2dCQUVQLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFOztvQkFDMUIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLEtBQUssQ0FBQztpQkFDcEM7YUFDSixFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ1IsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDaEIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQztTQUNuQzs7UUFFRCxJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDM0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO1FBRXRGLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUVsQjtLQUNKOzs7Ozs7OztJQVFELGVBQWUsQ0FBQyxLQUFZO1FBRXhCLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLENBQUM7S0FDcEM7Ozs7Ozs7OztJQVFELFdBQVcsQ0FBQyxZQUFvQjtRQUU1QixJQUFJLElBQUksQ0FBQyx3QkFBd0IsSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUFFO1lBQ25ELFlBQVksSUFBSSxDQUFDLENBQUM7U0FDckI7UUFFRCxPQUFPLENBQUMsWUFBWSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsd0JBQXdCO2NBQ3JELENBQUMsSUFBSSxJQUFJLENBQUMsbUJBQW1CLEdBQUcsWUFBWSxDQUFDLENBQUM7S0FDdkQ7Ozs7Ozs7SUFNRCxTQUFTLENBQUMsSUFBUztRQUVmLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUMzQixPQUFPLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNoQztRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2Y7OztZQS9WSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGdDQUFnQztnQkFDMUMsczdHQUF5QztnQkFHekMsVUFBVSxFQUFFO29CQUNSLE9BQU8sQ0FBQyxTQUFTLEVBQUU7d0JBQ2YsS0FBSyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUM7NEJBQ2IsWUFBWSxFQUFFLFFBQVE7NEJBQ3RCLFFBQVEsRUFBRSxHQUFHOzRCQUNiLFNBQVMsRUFBRSxHQUFHO3lCQUVqQixDQUFDLENBQUM7d0JBQ0gsS0FBSyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUM7NEJBQ2hCLFFBQVEsRUFBRSxHQUFHOzRCQUNiLFNBQVMsRUFBRSxHQUFHOzRCQUNkLFlBQVksRUFBRSxRQUFRO3lCQUV6QixDQUFDLENBQUM7d0JBQ0gsVUFBVSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzt3QkFDbEQsVUFBVSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsZUFBZSxDQUFDLENBQUM7cUJBQ3BELENBQUM7aUJBQ0w7O2FBQ0o7Ozs7WUF2TGUsV0FBVztZQUh2QixnQkFBZ0I7WUFFSCxnQkFBZ0I7WUFUN0IsVUFBVTs7O21CQXlNVCxLQUFLO21DQVNMLEtBQUs7dUJBT0wsS0FBSzt3QkFRTCxLQUFLO3dCQVFMLEtBQUs7b0JBU0wsS0FBSztrQ0FRTCxLQUFLOytCQU9MLEtBQUs7c0JBT0wsS0FBSzt1Q0FJTCxLQUFLO3FCQW1CTCxLQUFLOzZCQVFMLE1BQU07NkJBU04sTUFBTTs4QkFNTixZQUFZLFNBQUMsU0FBUzswQkFJdEIsU0FBUyxTQUFDLGNBQWM7Ozs7Ozs7O0FBMk43Qjs7OztJQWVJLFlBQW9CLE9BQTRCO1FBQTVCLFlBQU8sR0FBUCxPQUFPLENBQXFCO0tBRS9DOzs7O0lBR0QsUUFBUTtRQUVKLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMxQixJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztTQUNuRDtRQUdELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUNqQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBRWhELElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxFQUFFO2dCQUNsQyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUM7c0JBQ2xDLG1CQUFjLElBQUksQ0FBQyxlQUFlLEdBQUUsTUFBTSxDQUFDO2FBQ3BEO1NBQ0o7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEVBQUU7WUFDcEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQztTQUNqRTtLQUNKOzs7WUExQ0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxlQUFlO2FBQzVCOzs7O1lBZ0JnQyxtQkFBbUI7Ozt1QkFaL0MsS0FBSzs4QkFJTCxLQUFLOzRCQUlMLEtBQUs7Ozs7Ozs7QUNwaUJWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFEQSw2QkFBcUMsU0FBUSxhQUFhOzs7Ozs7O0lBc0N0RCxZQUFtQixHQUFnQixFQUVmLFlBQTBCLEVBRTFCLGFBQXNDLEVBRXZDLFVBQStCO1FBRTlDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQVJJLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFFZixpQkFBWSxHQUFaLFlBQVksQ0FBYztRQUUxQixrQkFBYSxHQUFiLGFBQWEsQ0FBeUI7UUFFdkMsZUFBVSxHQUFWLFVBQVUsQ0FBcUI7Ozs7Ozs7OEJBbEN4QixLQUFLO3lCQUdWLEtBQUs7Ozs7OztzQkFRRSxJQUFJLFlBQVksRUFBRTswQkFleEIsS0FBSztLQVkxQjs7OztJQUVELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFakIsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO0tBQ3pCOzs7Ozs7O0lBUUQsbUJBQW1CO1FBRWYsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0IsQ0FBQztLQUN6Rjs7OztJQUdELFVBQVU7UUFFTixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFlBQVksS0FBSyxJQUFJLENBQUMsSUFBSSxDQUFDO0tBQzNEOzs7O0lBRUQsbUJBQW1CO1FBRWYsSUFBSSxDQUFDLElBQUksQ0FBQyxtQkFBbUIsRUFBRTthQUMxQixJQUFJLENBQUMsVUFBVSxDQUFDLHdCQUF3QixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQ2pGO1lBQ0ksT0FBTyxFQUFFLENBQUM7U0FDYjtRQUVELElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUU7WUFDMUIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsc0JBQXNCO2tCQUMvRCx1QkFBdUIsQ0FBQztTQUNqQzthQUFNO1lBQ0gsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO2tCQUN0Qyw2Q0FBNkMsR0FBRyx1QkFBdUIsQ0FBQztTQUNqRjtLQUNKOzs7Ozs7O0lBTUQsZUFBZSxDQUFDLEtBQVU7UUFFdEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxHQUFHLEVBQUUsQ0FBQzs7UUFDdkMsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztRQUU1QixPQUFPLFNBQVMsQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3ZELFdBQVcsR0FBRyxXQUFXLENBQUMsWUFBWSxDQUFDO1NBQzFDO1FBRUQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLEVBQUUsQ0FBQzs7UUFDbEMsSUFBSSxPQUFPLEdBQUc7WUFDVixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixRQUFRLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7U0FDeEQsQ0FBQztRQUNGLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzFCLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUU3QyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7S0FDM0I7Ozs7SUFFRCxNQUFNO1FBRUYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNsRDs7OztJQUVPLGNBQWM7UUFFbEIsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUU7WUFDMUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQztTQUNsRDtRQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFLDhCQUE4QixDQUFDLENBQUM7UUFDbkUsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRTs7WUFDMUIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDO1lBQy9DLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyx3QkFBd0IsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO2dCQUN2RCxLQUFLLElBQUksQ0FBQyxDQUFDO2FBQ2Q7WUFFRCxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsbUJBQW1CLEdBQUcsS0FBSyxDQUFDLENBQUM7U0FDcEU7UUFDRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDO1FBQ3hDLElBQUksQ0FBQyxVQUFVLEdBQUcsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7Ozs7WUEvSXpELFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsb0JBQW9CO2dCQUM5Qix5bkVBQTZDOzthQUVoRDs7OztZQTFDZSxXQUFXO1lBR25CLFlBQVksdUJBK0VILFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sWUFBWSxDQUFDO1lBRzNCLHVCQUF1Qix1QkFEN0MsUUFBUSxZQUFJLFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sdUJBQXVCLENBQUM7WUFsRmpGLG1CQUFtQix1QkFvRlYsUUFBUSxZQUFJLFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sbUJBQW1CLENBQUM7Ozs2QkFsQ2hGLEtBQUs7d0JBR0wsS0FBSztxQkFRTCxNQUFNOzs7Ozs7O0FDekVYOzs7WUFPQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLG1CQUFtQjtvQkFDbkIsdUJBQXVCO29CQUN2QixvQkFBb0I7aUJBQ3ZCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gsbUJBQW1CO29CQUNuQixxQkFBcUI7aUJBQ3hCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxtQkFBbUI7b0JBQ25CLHVCQUF1QjtvQkFDdkIsbUJBQW1CO29CQUNuQixXQUFXO2lCQUNkO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7O0FDMUJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQkEsTUFBYSwrQkFBK0IsR0FBUTtJQUNoRCxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxpQkFBaUIsQ0FBQztJQUNoRCxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUFhRix1QkFBK0IsU0FBUSxpQkFBaUI7Ozs7O0lBK0JwRCxZQUFtQixHQUFnQixFQUViLGVBQWtDO1FBRXBELEtBQUssQ0FBQyxHQUFHLEVBQUUsZUFBZSxDQUFDLENBQUM7UUFKYixRQUFHLEdBQUgsR0FBRyxDQUFhO1FBRWIsb0JBQWUsR0FBZixlQUFlLENBQW1COzs7Ozs7cUJBekIzQyxFQUFFOzs7O29CQU9BLENBQUM7Ozs7dUJBT0UsRUFBRTs7OzswQkFPRSxJQUFJO0tBT3pCOzs7O0lBRUQsUUFBUTtRQUdKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDOUIsb0JBQW9CLEVBQUUsQ0FDekIsQ0FBQyxTQUFTLENBQUMsR0FBRztZQUVYLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO1lBQ2pCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ25DLENBQUMsQ0FBQztLQUNOOzs7Ozs7O0lBT0QsVUFBVSxDQUFDLEtBQVU7UUFFakIsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLEtBQUssRUFBRTtZQUN0QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztZQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsRUFBQyxRQUFRLEVBQUUsSUFBSSxFQUFDLENBQUMsQ0FBQztTQUN0RDtLQUVKOzs7WUEzRUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxjQUFjO2dCQUN4QixtbEJBQXVDO2dCQUd2QyxTQUFTLEVBQUU7b0JBQ1AsK0JBQStCO29CQUMvQixFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0saUJBQWlCLENBQUMsRUFBQztpQkFDakY7O2FBQ0o7Ozs7WUE3Q08sV0FBVztZQUNYLGlCQUFpQix1QkE2RVIsUUFBUSxZQUFJLFFBQVEsWUFBSSxNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sZ0JBQWdCLENBQUM7OztvQkF6QjdFLEtBQUs7bUJBT0wsS0FBSztzQkFPTCxLQUFLO3lCQU9MLEtBQUs7Ozs7Ozs7QUM1RVY7OztZQU9DLFFBQVEsU0FBQztnQkFDTixZQUFZLEVBQUU7b0JBQ1YsaUJBQWlCO2lCQUNwQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixXQUFXO29CQUNYLG1CQUFtQjtvQkFDbkIsbUJBQW1CO29CQUNuQixtQkFBbUI7aUJBQ3RCO2dCQUVELGVBQWUsRUFBRTtvQkFDYixpQkFBaUI7aUJBQ3BCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxpQkFBaUI7b0JBQ2pCLG1CQUFtQjtvQkFDbkIsV0FBVztpQkFDZDtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQ2hERDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0VBLCtCQUF1QyxTQUFRLGFBQWE7Ozs7O0lBU3hELFlBQXNCLE9BQW1CLEVBQVMsR0FBZ0I7UUFFOUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRk8sWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFTLFFBQUcsR0FBSCxHQUFHLENBQWE7S0FHakU7Ozs7SUFFRCxpQkFBaUI7UUFFYixPQUFPLGdCQUFnQixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ25EOzs7O0lBRUQsZ0JBQWdCO1FBRVosT0FBTyxtQkFBbUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQztLQUN0RDs7O1lBM0JKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsc0JBQXNCO2dCQUNoQywrbkJBQStDOzthQUVsRDs7OztZQXZFa0IsVUFBVTtZQUNyQixXQUFXOzs7MkJBNkVkLEtBQUs7Ozs7Ozs7QUF5QlY7Ozs7Ozs7SUFFSSxZQUFtQixJQUEwQixFQUFTLEtBQWEsRUFDaEQsYUFBNEIsV0FBOEI7UUFEMUQsU0FBSSxHQUFKLElBQUksQ0FBc0I7UUFBUyxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQ2hELGdCQUFXLEdBQVgsV0FBVztRQUFpQixnQkFBVyxHQUFYLFdBQVcsQ0FBbUI7S0FFNUU7Ozs7SUFFRCxXQUFXO1FBRVAsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQ3RDOzs7O0lBRUQsUUFBUTtRQUVKLE9BQU8sSUFBSSxDQUFDLElBQUksR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO0tBQ3ZGO0NBQ0o7Ozs7OztBQ25HRDs7O1lBSUMsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVix5QkFBeUI7aUJBRTVCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO2lCQUNmO2dCQUNELGVBQWUsRUFBRTtvQkFDYix5QkFBeUI7aUJBQzVCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCx5QkFBeUI7aUJBQzVCO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7Ozs7OztBQ2ZEOzs7O0lBRUksWUFBbUIsS0FBYTtRQUFiLFVBQUssR0FBTCxLQUFLLENBQVE7S0FFL0I7Ozs7SUFFRCxRQUFRO1FBRUosT0FBTywyQkFBMkIsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDO0tBQ25EO0NBQ0o7Ozs7O0FBTUQ7Ozs7SUFFSSxZQUFtQixLQUFhO1FBQWIsVUFBSyxHQUFMLEtBQUssQ0FBUTtLQUUvQjs7OztJQUVELFFBQVE7UUFFSixPQUFPLHdCQUF3QixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUM7S0FDaEQ7Q0FDSjs7Ozs7O0FDOUJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1QkE7Ozs7SUFZSTs7Ozs7MEJBTHdDLElBQUksT0FBTyxFQUFhO0tBUS9EOzs7Ozs7SUFNTSxVQUFVLENBQUMsU0FBaUI7UUFFL0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzs7Ozs7OztJQU9sRCxhQUFhLENBQUMsU0FBaUI7UUFFbEMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQzs7OztZQWpDMUQsVUFBVTs7Ozs7Ozs7O0FDbkJYOztJQU1JLE9BQUk7O0lBQ0osUUFBSzs7SUFDTCxTQUFNOztJQUNOLE9BQUk7O0lBQ0osZUFBWTs7SUFDWixZQUFTOztJQUNULFFBQUs7OztrQkFOTCxJQUFJO2tCQUNKLEtBQUs7a0JBQ0wsTUFBTTtrQkFDTixJQUFJO2tCQUNKLFlBQVk7a0JBQ1osU0FBUztrQkFDVCxLQUFLOzs7Ozs7Ozs7Ozs7QUFzQlQsaUJBQWtDLFNBQVEsYUFBYTs7Ozs7OztJQXlCbkQsWUFBbUIsR0FBZ0IsRUFBRSxRQUFrQixFQUNqQyxpQkFBb0MsRUFDcEMsb0JBQTBDO1FBRTVELEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUpJLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFDYixzQkFBaUIsR0FBakIsaUJBQWlCLENBQW1CO1FBQ3BDLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBc0I7Ozs7O3dCQXJCakMsUUFBUSxDQUFDLElBQUk7UUF3QnhDLElBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO0tBQzVCOzs7Ozs7SUFlTSxLQUFLO1FBRVIsSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFO1lBQ1QsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDO1NBQ2xCO1FBRUQsSUFBSSxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUM7O0NBR3ZDOzs7Ozs7QUM1RkQ7Ozs7OztBQWdCQSxzQkFBOEIsU0FBUSxhQUFhOzs7OztJQWMvQyxZQUFzQixPQUFtQixFQUFTLEdBQWdCO1FBRTlELEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUZPLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFBUyxRQUFHLEdBQUgsR0FBRyxDQUFhO0tBR2pFOzs7O0lBRUQsZUFBZTs7UUFHWCxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLHdCQUF3QixHQUFHLFNBQVMsQ0FBQztLQUMzRTs7OztJQUVELElBQUk7UUFFQSxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztLQUNwQjs7OztJQUVELEtBQUs7UUFFRCxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztLQUNyQjs7OztJQUVELE1BQU07UUFFRixJQUFJLENBQUMsSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztLQUMxQjs7O1lBM0NKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsWUFBWTtnQkFDdEIsMFRBQXFDOzthQUV4Qzs7OztZQWZrQixVQUFVO1lBQ3JCLFdBQVc7OztvQkFvQmQsS0FBSzttQkFNTCxLQUFLOzs7Ozs7O0FDM0JWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1REEseUJBQWlDLFNBQVEsYUFBYTs7Ozs7O0lBNENsRCxZQUFzQixPQUFtQixFQUFTLEdBQWdCLEVBQzlDO1FBRWhCLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUhPLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFBUyxRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQzlDLFlBQU8sR0FBUCxPQUFPOzs7Ozs7Z0NBeEJDLEtBQUs7Ozs7OEJBTVAsS0FBSztxQ0FjRSxLQUFLO0tBUXJDOzs7O0lBRUQsVUFBVTtRQUVOLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7S0FDekI7Ozs7OztJQU1ELFlBQVk7UUFFUixRQUFRLElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0tBQ3hEOzs7OztJQUtELFlBQVk7UUFFUixJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO0tBQ3pCOzs7Ozs7SUFNRCxnQkFBZ0I7UUFFWixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0tBQ3pFOzs7OztJQUtELHVCQUF1QjtRQUVuQixJQUFJLENBQUMscUJBQXFCLEdBQUcsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUM7S0FDNUQ7OztZQTdGSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGdCQUFnQjtnQkFDMUIscXBGQUF5Qzs7YUFFNUM7Ozs7WUF0RGtCLFVBQVU7WUFDckIsV0FBVztZQUFhLGNBQWM7Ozt3QkE0RHpDLEtBQUs7NEJBTUwsS0FBSzsrQkFRTCxLQUFLOzZCQU1MLEtBQUs7dUJBTUwsS0FBSztzQkFNTCxTQUFTLFNBQUMsVUFBVTs7Ozs7QUF3RHpCOzs7Ozs7SUFPSSxZQUFtQixJQUFZLEVBQVMsS0FBYSxFQUNsQztRQURBLFNBQUksR0FBSixJQUFJLENBQVE7UUFBUyxVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQ2xDLFNBQUksR0FBSixJQUFJO0tBRXRCOzs7O0lBRUQsUUFBUTtRQUVKLE9BQU8seUJBQXlCLElBQUksQ0FBQyxLQUFLLEdBQUcsQ0FBQztLQUNqRDtDQUNKOzs7Ozs7QUFPRDs7Ozs7O0lBUUksWUFBbUIsSUFBWSxFQUFTLEtBQWEsRUFDbEM7UUFEQSxTQUFJLEdBQUosSUFBSSxDQUFRO1FBQVMsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUNsQyxTQUFJLEdBQUosSUFBSTtLQUd0Qjs7OztJQUVELFFBQVE7UUFFSixPQUFPLGlDQUFpQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUM7S0FDekQ7Q0FDSjs7Ozs7O0FDOUxEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0EseUJBQWlDLFNBQVEsYUFBYTs7Ozs7SUFhbEQsWUFBc0IsT0FBbUIsRUFBUyxHQUFnQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFGTyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVMsUUFBRyxHQUFILEdBQUcsQ0FBYTs7OztvQ0FGbEMsSUFBSTtLQUtuQzs7OztJQUdELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDcEI7Ozs7SUFFRCxrQkFBa0I7UUFFZCxJQUFJLENBQUMsb0JBQW9CLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQzFEOzs7WUFoQ0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxnQkFBZ0I7Z0JBQzFCLHdzREFBeUM7O2FBRTVDOzs7O1lBdENrRCxVQUFVO1lBQ3JELFdBQVc7Ozt3QkE0Q2QsWUFBWSxTQUFDLFdBQVc7Ozs7Ozs7QUM3QzdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUZBLGdDQUF3QyxTQUFRLFdBQVc7Ozs7Ozs7SUE4R3ZELFlBQXNCLE9BQW1CLEVBQVMsR0FBZ0IsRUFDdEQsaUJBQW9DLEVBQUUsb0JBQTBDO1FBRXhGLEtBQUssQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO1FBSG5ELFlBQU8sR0FBUCxPQUFPLENBQVk7UUFBUyxRQUFHLEdBQUgsR0FBRyxDQUFhOzs7OzswQkF2RDVDLEtBQUs7Ozs7OzBCQWNMLEtBQUs7Ozs7Ozs7O2tDQVVFLEtBQUs7Ozs7O2lDQU9MLElBQUk7Z0NBc0JOLENBQUM7O1FBUXhCLElBQUksQ0FBQyxNQUFNLEdBQUcsbUJBQW1CLENBQUM7UUFDbEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxtQkFBbUIsQ0FBQztLQUNyQzs7Ozs7O0lBTUQsY0FBYztRQUVWLE9BQU8sSUFBSSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO0tBQ2hGOzs7Ozs7SUFNRCxnQkFBZ0I7UUFFWixRQUFRLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO0tBQ2hFOzs7O0lBRUQsZUFBZTtRQUVYLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztLQUN2Qzs7Ozs7SUFLRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDOztRQUdqQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDYixJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN0RTs7UUFHRCxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDYixJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUN0RTs7UUFHRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzs7UUFHakQsSUFBSSxJQUFJLENBQUMsa0JBQWtCLEtBQUssUUFBUSxFQUFFO1lBQ3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7WUFDL0IsSUFBSSxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQztTQUVwQzthQUFNLElBQUksSUFBSSxDQUFDLGtCQUFrQixLQUFLLE1BQU0sRUFBRTtZQUUzQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDO1lBQzlCLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUM7U0FDcEM7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQztlQUN6RCxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFO1lBRWpDLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDeEU7S0FDSjs7Ozs7SUFHRCxXQUFXLENBQUMsT0FBc0I7UUFFOUIsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUUzQixJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDbEMsT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDLFlBQVksS0FBSyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsYUFBYSxFQUFFOztZQUVoRixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1NBQ3hFO0tBRUo7Ozs7SUFFRCxXQUFXO1FBRVAsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDdkQ7OztZQTFNSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHdCQUF3QjtnQkFDbEMsNHRGQUFpRDs7YUFFcEQ7Ozs7WUEvRUcsVUFBVTtZQU1OLFdBQVc7WUFDWCxpQkFBaUI7WUFHakIsb0JBQW9COzs7b0JBNEV2QixLQUFLO3lCQU1MLEtBQUs7Z0NBTUwsS0FBSzsyQkFNTCxLQUFLOzJCQU9MLEtBQUs7MkJBT0wsS0FBSztxQkFTTCxLQUFLO3lCQU9MLEtBQUs7cUJBT0wsS0FBSzt5QkFPTCxLQUFLO2lDQVVMLEtBQUs7OEJBb0JMLFlBQVksU0FBQyxhQUFhOzRCQU0xQixLQUFLOzs7Ozs7O0FDM0xWOzs7O0FBYUEsMEJBQWtDLFNBQVEsYUFBYTs7Ozs7SUFHbkQsWUFBc0IsT0FBbUIsRUFBUyxHQUFnQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFGTyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVMsUUFBRyxHQUFILEdBQUcsQ0FBYTtLQUdqRTs7O1lBWEosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxpQkFBaUI7Z0JBQzNCLGlGQUEwQzs7YUFFN0M7Ozs7WUFaa0IsVUFBVTtZQUNyQixXQUFXOzs7Ozs7O0FDRG5COzs7OztBQWNBLDBCQUFrQyxTQUFRLGFBQWE7Ozs7O0lBR25ELFlBQXNCLE9BQW1CLEVBQVMsR0FBZ0I7UUFFOUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRk8sWUFBTyxHQUFQLE9BQU8sQ0FBWTtRQUFTLFFBQUcsR0FBSCxHQUFHLENBQWE7S0FHakU7OztZQVhKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsaUJBQWlCO2dCQUMzQixRQUFRLEVBQUUsMkJBQTJCO3lCQUM1Qix1Q0FBdUM7YUFDbkQ7Ozs7WUFia0IsVUFBVTtZQUNyQixXQUFXOzs7Ozs7O0FDRG5CO0FBS0EsTUFBTSw0QkFBNEIsR0FBRyxTQUFTLENBQUM7O0FBQy9DLE1BQU0sMEJBQTBCLEdBQUcsU0FBUyxDQUFDOztBQUM3QyxNQUFNLDRCQUE0QixHQUFHLFNBQVMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkMvQyxzQkFBOEIsU0FBUSxhQUFhOzs7O0lBcUQvQyxZQUFtQixHQUFnQjtRQUUvQixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFGSSxRQUFHLEdBQUgsR0FBRyxDQUFhOzs7OzhCQWhDVCxLQUFLOzs7OzJCQXdCVCxDQUFDOztRQVluQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsNEJBQTRCLENBQUM7UUFDdkQsSUFBSSxDQUFDLGdCQUFnQixHQUFHLDBCQUEwQixDQUFDO1FBQ25ELElBQUksQ0FBQyxrQkFBa0IsR0FBRyw0QkFBNEIsQ0FBQztLQUMxRDs7OztJQUVELFFBQVE7O1FBR0osSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTs7WUFHaEQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztTQUN2RTs7OztRQUtELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUV4QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztZQUUzQixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFO2dCQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDO29DQUNJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSx1QkFBdUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO2FBQ3JGO1NBQ0o7S0FDSjs7Ozs7OztJQU9ELFlBQVksQ0FBQyxLQUFhOztRQUd0QixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdCO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUUxQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztTQUVsQzthQUFNLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFFbkMsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7U0FFaEM7YUFBTTtZQUVILE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDO1NBQ2xDO0tBQ0o7Ozs7Ozs7SUFNRCxpQkFBaUIsQ0FBQyxLQUFhOztRQUczQixJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzdCO1FBRUQsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUUxQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztTQUVsQzthQUFNO1lBRUgsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUM7U0FDbEM7S0FDSjs7Ozs7SUFLRCxRQUFRO1FBRUosSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO0tBQ3RCOzs7OztJQUtELFFBQVE7UUFFSixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDdEI7OztZQXZKSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFlBQVk7Z0JBQ3RCLCtxQkFBcUM7O2FBRXhDOzs7O1lBbERPLFdBQVc7OztvQkF5RGQsS0FBSztxQkFTTCxLQUFLO2lDQVdMLEtBQUs7K0JBTUwsS0FBSztpQ0FNTCxLQUFLOzBCQU1MLEtBQUs7Ozs7Ozs7QUNoR1Y7Ozs7Ozs7Ozs7OztBQWlCQSxNQUFNLGFBQWEsR0FBRyxTQUFTLENBQUM7QUFPaEM7Ozs7SUFjSSxZQUFtQixHQUFnQjtRQUFoQixRQUFHLEdBQUgsR0FBRyxDQUFhO0tBRWxDOzs7O0lBRUQsUUFBUTtRQUVKLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLGFBQWEsQ0FBQztTQUM5QjtLQUNKOzs7WUE1QkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxTQUFTO2dCQUNuQiwrUkFBa0M7O2FBRXJDOzs7O1lBdEJPLFdBQVc7OztvQkE0QmQsS0FBSztvQkFNTCxLQUFLOzs7Ozs7O0FDbkNWOzs7WUFNQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGFBQWE7b0JBQ2IsZ0JBQWdCO2lCQUVuQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixxQkFBcUI7aUJBQ3hCO2dCQUNELGVBQWUsRUFBRTtvQkFDYixhQUFhO29CQUNiLGdCQUFnQjtpQkFDbkI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLGFBQWE7b0JBQ2IsZ0JBQWdCO2lCQUNuQjtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQ3pCRDs7O1lBY0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDViwwQkFBMEI7b0JBQzFCLG9CQUFvQjtvQkFDcEIsb0JBQW9CO29CQUNwQixtQkFBbUI7b0JBQ25CLG1CQUFtQjtvQkFDbkIsZ0JBQWdCO2lCQUVuQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixZQUFZO29CQUNaLHFCQUFxQjtvQkFDckIsZUFBZTtvQkFDZix3QkFBd0I7aUJBQzNCO2dCQUNELGVBQWUsRUFBRTtvQkFDYixtQkFBbUI7b0JBQ25CLG9CQUFvQjtvQkFDcEIsb0JBQW9CO29CQUNwQixtQkFBbUI7aUJBQ3RCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCwwQkFBMEI7b0JBQzFCLG9CQUFvQjtvQkFDcEIsb0JBQW9CO29CQUNwQixtQkFBbUI7b0JBQ25CLG1CQUFtQjtvQkFDbkIsZ0JBQWdCO2lCQUNuQjtnQkFDRCxTQUFTLEVBQUUsQ0FBQyxvQkFBb0IsQ0FBQzthQUNwQzs7Ozs7OztBQzlDRDs7SUErQ0ksVUFBTzs7O0lBRVAsT0FBSTs7SUFDSixhQUFVOztJQUNWLFNBQU07OztzQkFKTixPQUFPO3NCQUVQLElBQUk7c0JBQ0osVUFBVTtzQkFDVixNQUFNOztBQUlWLE1BQWEsNkJBQTZCLEdBQVE7SUFDOUMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0scUJBQXFCLENBQUM7SUFDcEQsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDO0FBYUYsMkJBQW1DLFNBQVEsaUJBQWlCOzs7OztJQW1CeEQsWUFBbUIsR0FBZ0IsRUFFYixlQUFrQztRQUNwRCxLQUFLLENBQUMsR0FBRyxFQUFFLGVBQWUsQ0FBQyxDQUFDO1FBSGIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUViLG9CQUFlLEdBQWYsZUFBZSxDQUFtQjs7OztxQkFWM0MsRUFBRTs7OzswQkFLRyxVQUFVO1FBUXhCLElBQUksQ0FBQyxJQUFJLEdBQUcsVUFBVSxDQUFDLE9BQU8sQ0FBQztRQUMvQixJQUFJLENBQUMsVUFBVSxHQUFHLGdCQUFnQixDQUFDO0tBQ3RDOzs7O0lBR0QsUUFBUTtRQUNKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixLQUFLLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXRDLElBQUksQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLElBQUksQ0FDOUIsb0JBQW9CLEVBQUUsQ0FDekIsQ0FBQyxTQUFTLENBQUMsR0FBRztZQUNYLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO1lBQ2pCLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ25DLENBQUMsQ0FBQztLQUNOOzs7Ozs7SUFLRCxVQUFVLENBQUMsS0FBVTtRQUNqQixJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3BDO0tBQ0o7OztZQTNESixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGlCQUFpQjtnQkFDM0Isa3lVQUE0QztnQkFFNUMsU0FBUyxFQUFFO29CQUNQLDZCQUE2QjtvQkFDN0IsRUFBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLFVBQVUsQ0FBQyxNQUFNLHFCQUFxQixDQUFDLEVBQUM7aUJBQ3JGOzthQUVKOzs7O1lBckVPLFdBQVc7WUFDWCxpQkFBaUIsdUJBeUZSLFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGdCQUFnQixDQUFDOzs7bUJBaEI3RSxLQUFLO29CQU1MLEtBQUs7Ozs7Ozs7QUNsRlY7OztZQVFDLFFBQVEsU0FBQztnQkFDTixZQUFZLEVBQUU7b0JBQ1YscUJBQXFCO2lCQUN4QjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixXQUFXO29CQUNYLG1CQUFtQjtvQkFDbkIsWUFBWTtvQkFDWixtQkFBbUI7aUJBQ3RCO2dCQUNELGVBQWUsRUFBRTtvQkFDYixxQkFBcUI7aUJBQ3hCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxxQkFBcUI7b0JBQ3JCLG1CQUFtQjtvQkFDbkIsV0FBVztpQkFDZDtnQkFDRCxTQUFTLEVBQUUsRUFBRTthQUNoQjs7Ozs7OztBQzVCRDs7OztBQXNCQTs7O1lBSkMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLFFBQVEsRUFBRSw0QkFBNEI7YUFDekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtJRCxzQkFBOEIsU0FBUSxhQUFhOzs7OztJQThHL0MsWUFBc0IsT0FBbUIsRUFBUyxHQUFnQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFGTyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQVMsUUFBRyxHQUFILEdBQUcsQ0FBYTs7OztzQkEzRmhELElBQUk7Ozs7OzRCQU1FLEtBQUs7Ozs7Ozs7eUJBU1IsS0FBSzs7Ozs7Ozs7d0JBV0wsU0FBUzs7OzswQkFPVCxXQUFXOzs7O3NCQU1KLElBQUksWUFBWSxFQUFFOzs7O3VCQU1qQixJQUFJLFlBQVksRUFBRTs7OztzQkFNbkIsSUFBSSxZQUFZLEVBQUU7Ozs7OEJBT1YsSUFBSSxZQUFZLEVBQUU7Ozs7NEJBT3BCLElBQUksWUFBWSxFQUFFO2lDQUliLElBQUksWUFBWSxFQUFFO1FBeUJyRCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztLQUN6Qjs7OztJQUVELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7O1FBRWpCLElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsRUFBRTtZQUMzQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztTQUM1Qjs7UUFHRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7U0FDdEI7O1FBSUQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO0tBQy9COzs7Ozs7SUFNTyxpQkFBaUI7UUFFckIsUUFBUSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUU7Ozs7OztJQU1sRSxNQUFNO1FBRUYsSUFBSSxDQUFDLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxFQUFFO1lBQzNCLE9BQU8sbUJBQW1CLENBQUM7U0FDOUI7UUFFRCxPQUFPLEVBQUUsQ0FBQztLQUNiOzs7Ozs7OztJQU9ELFlBQVksQ0FBQyxNQUFXOzs7UUFLcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDakIsSUFBSSxDQUFDLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7O1lBQ2pDLElBQUlDLFFBQUssR0FBVyxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksUUFBUSxHQUFHLFdBQVcsQ0FBQztZQUU5RCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQ0EsUUFBSyxDQUFDLENBQUM7WUFDeEIsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1NBQ2Y7Ozs7UUFLRCxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDekIsTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUMvQixNQUFNLENBQUMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBQ2pDO0tBQ0o7Ozs7SUFFRCxjQUFjO1FBRVYsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQ3RDOzs7Ozs7SUFLRCxJQUFJLENBQUMsS0FBVztRQUdaLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2hCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ25DO0tBQ0o7Ozs7OztJQUtELEtBQUssQ0FBQyxLQUFVO1FBRVosSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsSUFBSSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDbkM7S0FDSjs7Ozs7OztJQU1ELGFBQWEsQ0FBQyxLQUFVO1FBRXBCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzVCOzs7Ozs7O0lBTUQsY0FBYyxDQUFDLEtBQVU7UUFFckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDdEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDOUI7Ozs7Ozs7SUFRRCxnQkFBZ0I7UUFFWixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7S0FDeEM7Ozs7O0lBS0QsZUFBZTtRQUVYLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQy9DOzs7WUEzUEosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxZQUFZO2dCQUN0QixnbUVBQXFDOzthQUV4Qzs7OztZQW5KRyxVQUFVO1lBTU4sV0FBVzs7O29CQW9KZCxLQUFLOzBCQU1MLEtBQUs7cUJBTUwsS0FBSzsyQkFNTCxLQUFLO3dCQVNMLEtBQUs7dUJBV0wsS0FBSzt5QkFPTCxLQUFLO3FCQU1MLE1BQU07c0JBTU4sTUFBTTtxQkFNTixNQUFNOzZCQU9OLE1BQU07MkJBT04sTUFBTTtnQ0FJTixNQUFNOzJCQWFOLFNBQVMsU0FBQyxjQUFjOzRCQU94QixZQUFZLFNBQUMsdUJBQXVCOzs7OztZQThJeEMsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxlQUFlO2dCQUN6QixRQUFRLEVBQUU7OztrQkFHSTt5QkFDTCxzQ0FBc0M7YUFDbEQ7OztvQkFPSSxLQUFLOzs7Ozs7O0FDOVpWOzs7WUFXQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGdCQUFnQjtvQkFDaEIsbUJBQW1CO29CQUNuQix1QkFBdUI7aUJBQzFCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLGVBQWU7b0JBQ2YsZUFBZTtvQkFDZixtQkFBbUI7b0JBQ25CLGlCQUFpQjtvQkFDakIsY0FBYztvQkFDZCxZQUFZO2lCQUNmO2dCQUVELGVBQWUsRUFBRTtvQkFDYixnQkFBZ0I7b0JBQ2hCLG1CQUFtQjtvQkFDbkIsdUJBQXVCO2lCQUMxQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsZ0JBQWdCO29CQUNoQix1QkFBdUI7b0JBQ3ZCLG1CQUFtQjtvQkFDbkIsbUJBQW1CO29CQUNuQixXQUFXO2lCQUNkO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7Ozs7Ozs7QUN4Q0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNEQSx3QkFBZ0MsU0FBUSxhQUFhOzs7OztJQWtNakQsWUFBbUIsR0FBZ0IsRUFDaEI7UUFFZixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFISSxRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQ2hCLGVBQVUsR0FBVixVQUFVOzs7Ozs7cUJBN0tQLE1BQU07Ozs7Ozt5QkFlUCxJQUFJOzs7Ozs0QkFjRixZQUFZOzs7OzsrQkFPUixJQUFJOzs7Ozs7NkJBUU4sS0FBSzs7Ozs7OzBCQXVCUixLQUFLOzs7OzsrQkFPQSxJQUFJOzs7OztrQ0FPRCxJQUFJOzs7Ozs2QkFPVCxJQUFJOzs7Ozs7Ozs0QkFXTCxJQUFJOzs7Ozs7OztzQkFVVixLQUFLOzBCQW9ERixDQUFDOzBCQUNELENBQUM7dUJBQ0osQ0FBQzswQkFDRSxDQUFDO0tBWXJCOzs7O0lBR0QsUUFBUTtRQUVKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVqQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMxQyxNQUFNLElBQUksS0FBSyxDQUFDLDRCQUE0QjtnQkFDeEMsbURBQW1ELENBQUMsQ0FBQztTQUM1RDs7UUFHRCxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNwQyxNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQztnQkFDaEQsZ0VBQWdFLENBQUMsQ0FBQztTQUN6RTtLQUNKOzs7O0lBR0Qsa0JBQWtCO0tBR2pCOzs7O0lBRUQsZUFBZTs7Ozs7O0tBUWQ7Ozs7Ozs7Ozs7SUFRRCxpQkFBaUIsQ0FBQyxLQUFVLEVBQUUsT0FBWTtRQUV0QyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxFQUFFO1lBQzNCLElBQUksQ0FBQyxFQUFFLENBQUMsdUJBQXVCLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBRWxEO2FBQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEI7UUFDRCxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7S0FDMUI7Ozs7Ozs7O0lBT0QsSUFBSSxDQUFDLEtBQVU7UUFFWCxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNoQixPQUFPO1NBQ1Y7O1FBQ0QsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUM5QixJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxlQUFlLENBQUM7WUFDckQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLGNBQWMsQ0FBQztZQUNwRCxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsc0JBQXNCLENBQUMsRUFDaEU7WUFFSSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsS0FBSyxJQUFJLENBQUMsR0FBRyxFQUFFO2dCQUN0RSxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JDLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7YUFFckU7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO2FBRTdCO1lBQ0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQzVDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFdEYsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUN4QjtRQUNELElBQUksQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztLQUNoQzs7Ozs7Ozs7SUFPRCxnQkFBZ0IsQ0FBQyxJQUFTOztRQUV0QixJQUFJLFFBQVEsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztjQUNwQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUVqRSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEVBQUU7WUFDaEMsUUFBUSxJQUFJLEdBQUcsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO1NBRXpDO2FBQU0sSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ25DLFFBQVEsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztTQUNyQztRQUVELE9BQU8sUUFBUSxDQUFDO0tBQ25COzs7OztJQUdELGVBQWUsQ0FBQyxJQUFTO1FBRXJCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDcEMsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QztRQUVELE9BQU8sS0FBSyxDQUFDO0tBQ2hCOzs7OztJQUVELGdCQUFnQixDQUFDLElBQVM7UUFFdEIsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDO0tBRTVGOzs7O0lBR0Qsa0JBQWtCO1FBRWQsT0FBTyxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsS0FBSyxNQUFNLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQztLQUU5RDs7OztJQUdELFlBQVk7O1FBRVIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBRWQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxLQUFLLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEdBQUcsRUFBRTtZQUN0RSxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDO1NBQ3hDO1FBQ0QsT0FBTyxLQUFLLENBQUM7S0FDaEI7Ozs7SUFFRCxRQUFRO1FBRUosSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDaEIsT0FBTyxLQUFLLENBQUM7U0FDaEI7UUFDRCxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDO0tBQy9FOzs7OztJQUVELFVBQVUsQ0FBQyxLQUFrQjtRQUV6QixJQUFJLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQztRQUVoQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDMUUsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7WUFDckIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUN6RSxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDN0I7UUFFRCxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUNsRCxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDO1NBQzVDO1FBRUQsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDdEQsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQztTQUNoRDtRQUVELElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtZQUM1RCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQztTQUN0RDtRQUVELElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUMzQixJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDO1NBQzFDO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDN0M7Ozs7Ozs7O0lBT0QsY0FBYyxDQUFDLE9BQWU7O1FBRTFCLE1BQU0sUUFBUSxHQUFHLE9BQU8sR0FBRyxDQUFDLENBQUM7O1FBQzdCLElBQUksS0FBSyxDQUFDO1FBRVYsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDNUIsS0FBSyxHQUFHLG1CQUFzQixJQUFJLENBQUMsRUFBRSxHQUFFLEVBQUU7aUJBQ3BDLGFBQWEsQ0FBQyxhQUFhLENBQUMsdUJBQXVCLENBQUMsQ0FBQztTQUM3RDthQUFNO1lBQ0gsS0FBSyxHQUFHLG1CQUFzQixJQUFJLENBQUMsRUFBRSxHQUFFLEVBQUUsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ2xGO1FBR0QsSUFBSSxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRTs7WUFDckIsSUFBSSxHQUFHLEdBQUcsS0FBSyxDQUFDLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHLFFBQVEsR0FBRyxLQUFLO2dCQUNsRSxrQkFBa0IsR0FBRyxRQUFRLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBUztnQkFFdkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7YUFDN0MsQ0FBQyxDQUFDO1NBQ047S0FDSjs7Ozs7OztJQVFELGFBQWE7UUFFVCxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxjQUFjLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUM7WUFDNUUsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUMzQjs7Ozs7Ozs7OztJQVFELGdCQUFnQixDQUFDLElBQVMsRUFBRSxLQUFhO1FBRXJDLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQztlQUNyRCxTQUFTLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEVBQ3pDOztZQUVJLElBQUksa0JBQWtCLEdBQ2xCLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7O1lBR3pFLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyx3QkFBd0IsRUFBRTtnQkFDbEMsT0FBTyxDQUFDLEtBQUssS0FBSyxDQUFDLElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsR0FBRyxLQUFLO3NCQUM1RCxrQkFBa0IsQ0FBQzthQUM1QjtpQkFBTTtnQkFDSCxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxtQkFBbUIsR0FBRyxLQUFLLElBQUksa0JBQWtCLENBQUM7YUFDckU7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2Y7Ozs7Ozs7SUFPTyxTQUFTLENBQUMsS0FBYTs7UUFFM0IsSUFBSSxFQUFFLENBQUM7UUFDUCxJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNsQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFOztnQkFDeEIsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQztnQkFDdEMsRUFBRSxHQUFHLEtBQUssR0FBRyxtQkFBc0IsSUFBSSxDQUFDLEVBQUUsR0FBRSxFQUFFLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQzthQUM1RTtpQkFBTTtnQkFDSCxFQUFFLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzFCO1NBQ0o7UUFFRCxPQUFPLEVBQUUsQ0FBQzs7OztZQWpkakIsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxlQUFlO2dCQUN6QixnN1FBQXVDO2dCQUV2QyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsU0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDOzthQUUxQjs7OztZQTFDdUIsV0FBVztZQUUzQixVQUFVOzs7b0JBZ0RiLEtBQUs7a0JBTUwsS0FBSztvQkFRTCxLQUFLOzBCQU9MLEtBQUs7d0JBUUwsS0FBSzt1QkFPTCxLQUFLOzJCQU9MLEtBQUs7OEJBT0wsS0FBSzs0QkFRTCxLQUFLOytCQVFMLEtBQUs7NkJBT0wsS0FBSzt5QkFRTCxLQUFLOzhCQU9MLEtBQUs7aUNBT0wsS0FBSzs0QkFPTCxLQUFLOzJCQVdMLEtBQUs7cUJBVUwsS0FBSzt1QkFVTCxLQUFLO3VCQVdMLEtBQUs7K0JBTUwsU0FBUyxTQUFDLG1CQUFtQjs2QkFNN0IsWUFBWSxTQUFDLFFBQVE7Z0NBTXJCLFlBQVksU0FBQyxXQUFXOzJCQU14QixZQUFZLFNBQUMsTUFBTTs7Ozs7OztBQ3JPeEI7Ozs7O0FBV0E7OztZQUpDLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsUUFBUSxFQUFFLDJCQUEyQjthQUN4Qzs7Ozs7OztBQ1ZEOzs7Ozs7QUFxQkEsMEJBQWtDLFNBQVEsa0JBQWtCOzs7OztJQW9CeEQsWUFBbUIsR0FBZ0IsRUFBUyxVQUFzQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRlIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUFTLGVBQVUsR0FBVixVQUFVLENBQVk7Ozs7OzsyQkFIM0MsSUFBSTtLQU0xQjs7OztJQUdELFFBQVE7O1FBR0osSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFDZCxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDcEI7Ozs7OztJQU9ELGtCQUFrQjtRQUVkLE9BQU8sSUFBSSxDQUFDLEVBQUUsQ0FBQyxzQkFBc0IsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLDJCQUEyQixFQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0tBQzNGOzs7Ozs7Ozs7Ozs7SUFZRCxhQUFhLENBQUMsSUFBUzs7UUFFbkIsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMvQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDN0IsU0FBUyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7U0FDckU7UUFDRCxPQUFPLFNBQVMsQ0FBQztLQUNwQjs7Ozs7SUFHRCxVQUFVLENBQUMsS0FBa0I7UUFFekIsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUV4QixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDO0tBQ25FOzs7WUE1RUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxxQkFBcUI7Z0JBQy9CLHUrQkFBMkM7Z0JBRTNDLGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUM7O2FBRTFCOzs7O1lBbkJPLFdBQVc7WUFDWCxVQUFVOzs7MEJBMEJiLEtBQUs7MEJBU0wsS0FBSzs7Ozs7OztBQ3JDVjs7Ozs7O0FBb0JBLGtDQUEwQyxTQUFRLGtCQUFrQjs7Ozs7SUFHaEUsWUFBbUIsR0FBZ0IsRUFBUyxVQUFzQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRlIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUFTLGVBQVUsR0FBVixVQUFVLENBQVk7O1FBSzlELElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDOztRQUd2QixJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztLQUN2Qjs7OztJQUdELFFBQVE7O1FBR0osSUFBSSxDQUFDLEdBQUcsR0FBRyxFQUFFLENBQUM7UUFFZCxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDcEI7Ozs7OztJQUVELGVBQWUsQ0FBQyxLQUFVLEVBQUUsSUFBUztRQUVqQyxJQUFJLENBQUMsRUFBRSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7S0FDM0I7Ozs7O0lBRUQsbUJBQW1CLENBQUMsSUFBUztRQUV6QixPQUFPLElBQUksQ0FBQyxFQUFFLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNuRCxzQkFBc0IsR0FBRyx1QkFBdUIsQ0FBQztLQUN4RDs7O1lBekNKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsNEJBQTRCO2dCQUN0QywwZ0RBQW9EO2dCQUVwRCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsU0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDOzthQUUxQjs7OztZQWxCTyxXQUFXO1lBQ1gsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1NsQixNQUFhLFVBQVUsR0FBYSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxXQUFXO0lBQy9GLE1BQU0sRUFBRSxTQUFTLENBQUMsQ0FBQzs7O0lBSW5CLE1BQU8sTUFBTTtJQUNiLElBQUssaUJBQWlCO0lBQ3RCLE1BQU8sb0JBQW9CO0lBQzNCLFFBQVMsa0JBQWtCOzs7O0lBTTNCLFFBQVMsUUFBUTtJQUNqQixPQUFRLE9BQU87SUFDZixNQUFPLE1BQU07Ozs7Ozs7QUMzQmpCOzs7Ozs7Ozs7O0FBNkJBLG1CQUEyQixTQUFRLFVBQVU7Ozs7O0lBcUJ6QyxZQUFtQixhQUE2QixFQUFTLE9BQXFCO1FBRTFFLEtBQUssQ0FBQyxhQUFhLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFGZixrQkFBYSxHQUFiLGFBQWEsQ0FBZ0I7UUFBUyxZQUFPLEdBQVAsT0FBTyxDQUFjOzJCQVBoRSxLQUFLO1FBV2YsSUFBSSxDQUFDLEtBQUssR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFdEMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDO0tBQ3pDOzs7OztJQUdELElBQUksQ0FBQyxHQUFHLElBQVc7UUFFZixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNoRSxNQUFNLElBQUksS0FBSyxDQUFDLHNEQUFzRCxDQUFDLENBQUM7U0FDM0U7O1FBQ0QsSUFBSSxJQUFJLEdBQW1CLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7UUFHbkMsSUFBSSxDQUFDLFlBQVksR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZO2NBQzlELElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQzs7UUFHeEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVO2NBQ3hELElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRTNELE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQzdELDBFQUEwRSxDQUFDLENBQUM7UUFFaEYsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMzQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLGVBQWUsRUFBRSxDQUFDO1NBQ3RDO2FBQU07WUFDSCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDM0I7UUFFRCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQztLQUMzQjs7Ozs7OztJQU9ELEtBQUssQ0FBQyxVQUE0Qjs7UUFFOUIsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3ZCLE1BQU0sR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQztpQkFDOUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDO2lCQUM5QixHQUFHLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxPQUFPLENBQUM7aUJBQ2xDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQzlDO1FBRUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBYTtZQUVwRCxJQUFJLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztnQkFDdkIsSUFBSSxRQUFRLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUM7Z0JBQ3hFLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNoRDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDOUM7U0FDSixDQUFDLENBQUM7S0FDTjs7Ozs7Ozs7O0lBU0QsSUFBSTtRQUVBLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDdkQ7Ozs7SUFFRCxLQUFLO1FBRUQsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDekIsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7S0FDMUI7Ozs7Ozs7OztJQVNELE1BQU0sQ0FBQyxNQUFXO1FBRWQsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBRXBDO2FBQU07WUFDSCxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDN0MsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7U0FDdkU7S0FDSjs7Ozs7OztJQU9ELE1BQU0sQ0FBQyxNQUFXO1FBRWQsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxFQUFFO1lBQzdCLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBRXBDO2FBQU07WUFDSCxXQUFXLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ25FLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1NBQ3ZFO0tBQ0o7Ozs7Ozs7Ozs7Ozs7SUFZRCxJQUFJLENBQUMsT0FBYTtRQUVkLElBQUksT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFOztZQUUxQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN2QixPQUFPO1NBQ1Y7O1FBRUQsSUFBSSxXQUFXLEdBQVEsT0FBTyxDQUFDO1FBQy9CLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDakUsV0FBVyxHQUFHLElBQUksR0FBRyxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUVuRixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUMvQixXQUFXLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ2xEO1lBRUQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDL0IsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzthQUNyRDtTQUNKO2FBQU07WUFDSCxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFLGlEQUFpRCxDQUFDLENBQUM7U0FDaEY7UUFFRCxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBTSxXQUFXLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFhO1lBRTVELElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUM5QyxDQUFDLENBQUM7S0FDTjs7Ozs7Ozs7Ozs7O0lBV0QsSUFBSSxDQUFDLEdBQVcsRUFBRSxTQUFpQjtRQUUvQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzVFLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLEdBQUcsQ0FBQztRQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDakMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDMUI7Ozs7Ozs7Ozs7SUFPRCxXQUFXLENBQUMsTUFBYyxFQUFFLFNBQWlCLEVBQUUsTUFBYztRQUV6RCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDM0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO1FBQy9CLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztLQUNqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQ0QsV0FBVyxDQUFDLE9BQWUsRUFBRSxNQUFjLEVBQUUsT0FBcUI7O1FBRTlELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxFQUFFLENBQUM7O1FBRzdDLElBQUksTUFBTSxHQUFHLE9BQU8sSUFBSSxPQUFPLEtBQUssWUFBWSxDQUFDLE1BQU0sSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUM5RSxNQUFNLElBQUksQ0FBQyxDQUFDOztTQUdmO2FBQU0sSUFBSSxNQUFNLEdBQUcsT0FBTyxJQUFJLE9BQU8sS0FBSyxZQUFZLENBQUMsS0FBSyxJQUFJLE1BQU0sSUFBSSxDQUFDLEVBQUU7WUFDMUUsTUFBTSxJQUFJLENBQUMsQ0FBQztTQUNmO1FBRUQsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDN0M7O3lCQXBRMEIsR0FBRzs7Ozs7Ozs7O0FBOFJsQztJQXNFSTs7OztzQkE5RGlCLENBQUM7cUJBQ0YsQ0FBQzs7Ozs7OzRCQU9NLENBQUM7Ozs7O3lCQVdKLGVBQWUsQ0FBQyxTQUFTOzs7O2tDQUtoQixFQUFFO1FBd0MzQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksR0FBRyxFQUFnQixDQUFDO1FBQzVDLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLEdBQUcsRUFBZ0IsQ0FBQztLQUN2RDs7Ozs7Ozs7Ozs7OztJQUVELE9BQU8sTUFBTSxDQUFDLFNBQWlCLENBQUMsRUFBRSxRQUFnQixFQUFFLEVBQUUsZUFBdUIsQ0FBQyxFQUNoRSxZQUFvQixFQUFFLEVBQUUsU0FBaUIsQ0FBQyxFQUFFLFdBQW9CLEVBQUUsTUFBWSxFQUM5RSxlQUFrQyxJQUFJLEdBQUcsRUFBZ0IsRUFDekQsaUJBQW9DLElBQUksR0FBRyxFQUFnQjs7UUFFckUsSUFBSSxDQUFDLEdBQUcsSUFBSSxlQUFlLEVBQUUsQ0FBQztRQUM5QixDQUFDLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNsQixDQUFDLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNoQixDQUFDLENBQUMsWUFBWSxHQUFHLFlBQVksQ0FBQztRQUM5QixDQUFDLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztRQUN0QixDQUFDLENBQUMsU0FBUyxHQUFHLE1BQU0sQ0FBQztRQUNyQixDQUFDLENBQUMsa0JBQWtCLEdBQUcsV0FBVyxDQUFDO1FBQ25DLENBQUMsQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDO1FBQ3pCLENBQUMsQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQzlCLENBQUMsQ0FBQyxvQkFBb0IsR0FBRyxjQUFjLENBQUM7UUFFeEMsT0FBTyxDQUFDLENBQUM7S0FDWjs7Ozs7SUFFRCxPQUFPLFFBQVEsQ0FBQyxJQUFZOztRQUV4QixJQUFJQSxRQUFLLEdBQThCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBQ3hELElBQUksRUFBRSxHQUFHLElBQUksZUFBZSxFQUFFLENBQUM7UUFDL0IsRUFBRSxDQUFDLE1BQU0sR0FBR0EsUUFBSyxDQUFDLE1BQU0sQ0FBQztRQUN6QixFQUFFLENBQUMsS0FBSyxHQUFHQSxRQUFLLENBQUMsS0FBSyxDQUFDO1FBQ3ZCLEVBQUUsQ0FBQyxZQUFZLEdBQUdBLFFBQUssQ0FBQyxZQUFZLENBQUM7UUFDckMsRUFBRSxDQUFDLE9BQU8sR0FBR0EsUUFBSyxDQUFDLE9BQU8sQ0FBQztRQUMzQixFQUFFLENBQUMsU0FBUyxHQUFHQSxRQUFLLENBQUMsU0FBUyxDQUFDO1FBQy9CLEVBQUUsQ0FBQyxrQkFBa0IsR0FBR0EsUUFBSyxDQUFDLGtCQUFrQixDQUFDO1FBQ2pELEVBQUUsQ0FBQyxZQUFZLEdBQUcsVUFBVSxDQUFDLGdCQUFnQixDQUFVQSxRQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDM0UsRUFBRSxDQUFDLG9CQUFvQixHQUFHLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBVUEsUUFBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFFM0YsT0FBTyxFQUFFLENBQUM7S0FDYjs7Ozs7SUFHRCxPQUFPLE1BQU0sQ0FBQyxJQUFxQjs7UUFFL0IsSUFBSSxTQUFTLEdBQThCO1lBQ3ZDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZO1lBQy9CLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDekIsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGtCQUFrQjtZQUMzQyxZQUFZLEVBQUUsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO1lBQ3BELG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDO1NBRXZFLENBQUM7UUFDRixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDcEM7OzRCQTVIa0MsQ0FBQzs2QkFDQSxDQUFDLENBQUM7Ozs7Ozs7O0FBdUkxQzs7OztJQU1JLFlBQW9CLEVBQWU7UUFBZixPQUFFLEdBQUYsRUFBRSxDQUFhO0tBRWxDOzs7O0lBRUQsSUFBSSxzQkFBc0I7UUFFdEIsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0tBQzFDOzs7OztJQUVELElBQUksc0JBQXNCLENBQUMsS0FBYztRQUdyQyxJQUFJLEtBQUssRUFBRTtZQUNQLElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxHQUFHLEVBQWdCLENBQUM7U0FDbEQ7YUFBTTtZQUNILElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxDQUFDO1NBQy9CO0tBQ0o7Ozs7O0lBRUQsTUFBTSxDQUFDLElBQVM7O1FBRVosSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN4QixJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdkM7YUFBTTtZQUNILElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLG9CQUFvQixHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7S0FDeEU7Ozs7O0lBRUQsVUFBVSxDQUFDLElBQVM7O1FBRWhCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBRS9CLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUM5RCxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNqQyxPQUFPLEtBQUssQ0FBQztTQUNoQjs7UUFFRCxJQUFJLGlCQUFpQixHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsU0FBUyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUMxRixPQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztLQUMxRDs7Ozs7SUFFTyxTQUFTLENBQUMsSUFBUztRQUV2QixPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxtQkFBUyxJQUFJLEdBQUUsUUFBUSxFQUFFLEdBQUcsSUFBSSxDQUFDOztDQUVoRTs7Ozs7QUFnQkQsd0JBQStCLElBQW9CO0lBRS9DLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Q0FDckY7Ozs7OztBQ2hoQkQ7Ozs7OztBQW9CQSxrQ0FBMEMsU0FBUSxrQkFBa0I7Ozs7O0lBR2hFLFlBQW1CLEdBQWdCLEVBQVMsVUFBc0I7UUFFOUQsS0FBSyxDQUFDLEdBQUcsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUZSLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFBUyxlQUFVLEdBQVYsVUFBVSxDQUFZOztRQUs5RCxJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztLQUN2Qjs7O1lBakJKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxrcUVBQW9EO2dCQUVwRCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsU0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDOzthQUUxQjs7OztZQWxCTyxXQUFXO1lBQ1gsVUFBVTs7Ozs7OztBQ0ZsQjs7Ozs7O0FBb0JBLG1DQUEyQyxTQUFRLGtCQUFrQjs7Ozs7SUFHakUsWUFBbUIsR0FBZ0IsRUFBUyxVQUFzQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBRlIsUUFBRyxHQUFILEdBQUcsQ0FBYTtRQUFTLGVBQVUsR0FBVixVQUFVLENBQVk7O1FBSzlELElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO0tBQ3ZCOzs7WUFqQkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSw0QkFBNEI7Z0JBQ3RDLGl6REFBcUQ7Z0JBRXJELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxTQUFTLEVBQUUsQ0FBQyxVQUFVLENBQUM7O2FBRTFCOzs7O1lBbEJPLFdBQVc7WUFDWCxVQUFVOzs7Ozs7O0FDT2xCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFHQSx5QkFBaUMsU0FBUSxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTZjbEQsWUFBbUIsR0FBZ0IsRUFBUyxFQUFjLEVBQ2pCLFVBQXlCLEVBQy9DLGdCQUNBLGlCQUNBLGNBQ0EsTUFDQztRQUVoQixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFSSSxRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQVMsT0FBRSxHQUFGLEVBQUUsQ0FBWTtRQUNqQixlQUFVLEdBQVYsVUFBVSxDQUFlO1FBQy9DLG1CQUFjLEdBQWQsY0FBYztRQUNkLG9CQUFlLEdBQWYsZUFBZTtRQUNmLGlCQUFZLEdBQVosWUFBWTtRQUNaLFNBQUksR0FBSixJQUFJO1FBQ0gsYUFBUSxHQUFSLFFBQVE7Ozs7K0JBdGFELElBQUk7Ozs7OzZCQVFOLEtBQUs7Ozs7Z0NBYUgsWUFBWTs7Ozs7Ozs4QkFnQmQsRUFBRTs7Ozs7Ozt3QkFVUixFQUFFOzs7Ozs7NEJBZUUsa0JBQWtCOzs7Ozs7NkJBK0JWLE1BQU07Ozs7Ozs7MkJBU2Ysa0JBQWtCOzs7OytCQU9iLEtBQUs7Ozs7O21DQU9GLEVBQUU7Ozs7Ozs7NkJBU1AsS0FBSzs7Ozt5QkF3QlQsS0FBSzs7Ozs7NkJBUUcsTUFBTTs7Ozt3Q0FNQyxJQUFJOzs7Ozs2Q0FRQyxJQUFJOzs7OzttQ0FPZCxJQUFJOzs7Ozs2QkFRVixJQUFJOzs7O2dDQU9ELElBQUk7Ozs7OzZCQWdCUCxLQUFLOzs7Ozs7c0JBUUYsSUFBSSxZQUFZLEVBQUU7Ozs7OzBCQVFkLElBQUksWUFBWSxFQUFFOzs7Ozs7OztvQ0FVUixJQUFJLFlBQVksRUFBRTs7Ozs7NEJBUTFCLElBQUksWUFBWSxFQUFFOzs7OztpQ0FPYixJQUFJLFlBQVksRUFBRTs7Ozs7OzJCQXVFdEIsSUFBSSxZQUFZLEVBQVM7eUJBSXhDLGNBQWM7Ozs7Ozs4QkFnQ0QsS0FBSzs7OztzQ0F5QkwsQ0FBQzs7OztzQ0FNRCxDQUFDO1FBc0M5QixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7S0FDckM7Ozs7Ozs7O0lBUUQsSUFDSSxLQUFLO1FBRUwsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQztLQUNoQzs7Ozs7SUFFRCxJQUFJLEtBQUssQ0FBQyxHQUFRO1FBRWQsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO0tBQy9COzs7O0lBRUQsUUFBUTtRQUdKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNqQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQzFELE1BQU0sSUFBSSxLQUFLLENBQUMsNkRBQTZELENBQUMsQ0FBQztTQUNsRjtRQUNELElBQUksQ0FBQyx1QkFBdUIsR0FBRyxJQUFJLHVCQUF1QixDQUFDLElBQUksQ0FBQyxDQUFDOztRQUdqRSxJQUFJLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLGVBQWU7YUFDNUMsdUJBQXVCLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUcxRixJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLGVBQWU7YUFDeEMsdUJBQXVCLENBQUMsNEJBQTRCLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQztRQUUxRixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLGVBQWU7YUFDekMsdUJBQXVCLENBQUMsNkJBQTZCLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQzs7Ozs7O1FBTzNGLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDMUQsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBRXpCO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRTtZQUNwQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzlCOztRQUdELElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDO0tBQy9EOzs7Ozs7OztJQU9ELFdBQVcsQ0FBQyxPQUFzQjtRQUU5QixLQUFLLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTNCLElBQUksT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxDQUFDO2VBQ3ZELENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQ25DO1lBRUksSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO1NBRXpCO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRTtZQUNwQyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM1RDtLQUVKOzs7O0lBRUQsa0JBQWtCOzs7UUFLZCxJQUFJLENBQUMsdUJBQXVCLENBQUMsc0JBQXNCLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUV0RixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDbkIsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBRXpELElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNuQixJQUFJLENBQUMsY0FBYyxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQ3RDLENBQUMsQ0FBQztLQUNOOzs7O0lBRUQsZUFBZTs7UUFHWCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDNUUsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzVFO1FBRUQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUc1QztRQUVELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO0tBQzNCOzs7O0lBRUQsa0JBQWtCO1FBRWQsSUFBSSxJQUFJLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLFlBQVksRUFBRTtZQUMzRCxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQztTQUMvQjtRQUVELElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFLEVBQUU7WUFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUF1QixFQUFFLEtBQWEsS0FDOUQsR0FBRyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1NBQ2xDO2FBQU07WUFDSCxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQXVCLEVBQUUsS0FBYSxLQUN4RCxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7U0FDbEM7S0FDSjs7Ozs7Ozs7Ozs7Ozs7SUFjRCxXQUFXO1FBRVAsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbEIsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7UUFFeEIsSUFBSSxJQUFJLENBQUMsdUJBQXVCLENBQUMsc0JBQXNCLEVBQUU7WUFDckQsSUFBSSxDQUFDLHlCQUF5QixFQUFFLENBQUM7U0FDcEM7UUFDRCxJQUFJLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssT0FBTyxFQUFFO1lBQ2pFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDeEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUM7U0FDN0M7YUFBTSxJQUFJLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssUUFBUSxFQUFFO1lBQ3pFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDekMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUM7U0FDOUM7Ozs7UUFLRCxJQUFJLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxzQkFBc0IsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtZQUMxRSxJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzVDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1NBQ2pEO1FBRUQsSUFBSSxDQUFDLFNBQVM7YUFDVCxNQUFNLENBQUMsQ0FBQyxJQUF3QixLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzthQUNsRCxPQUFPLENBQUMsQ0FBQyxHQUF1QjtZQUU3QixHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQzFCLENBQUMsQ0FBQztRQUVQLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQ3pCLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUN0QixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztLQUM5Qjs7Ozs7OztJQU1ELGdCQUFnQixDQUFDLEdBQXVCO1FBRXBDLE9BQU8sR0FBRyxZQUFZLDZCQUE2QjtZQUMvQyxHQUFHLFlBQVksNEJBQTRCO1lBQzNDLEdBQUcsWUFBWSw0QkFBNEIsQ0FBQztLQUVuRDs7Ozs7Ozs7O0lBUUQsY0FBYyxDQUFDLGFBQXNCLElBQUk7UUFFckMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsY0FBYyxFQUNyRSxJQUFJLENBQUMsY0FBYyxFQUFFLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDO1NBQy9FO2FBQU07WUFDSCxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO1lBQ2pFLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRTtnQkFDaEMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztnQkFDekMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO2FBQzVFO1NBQ0o7UUFFRCxJQUFJLFVBQVUsRUFBRTs7WUFFWixJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLE1BQU07Z0JBQzFELFNBQVMsQ0FBQyxlQUFlLEdBQUcsU0FBUyxDQUFDLFFBQVEsQ0FBQztZQUVuRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztnQkFDakIsR0FBRyxFQUFFLFNBQVMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLElBQUk7Z0JBQ3pFLFNBQVMsRUFBRSxLQUFLO2dCQUNoQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7Z0JBQ2pCLFdBQVcsRUFBRSxLQUFLO2FBQ3JCLENBQUMsQ0FBQztTQUNOO1FBQ0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDOztRQUdsQyxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQzs7O1FBSWpCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBVztZQUV6QyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3pCLENBQUMsQ0FBQztLQUNOOzs7Ozs7Ozs7OztJQVdELHlCQUF5QjtRQUVyQixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDakMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDekM7UUFDRCxJQUFJLENBQUMsdUJBQXVCLENBQUMsc0JBQXNCLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDakYsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsNkJBQTZCLENBQUMsQ0FBQztLQUNqRTs7Ozs7Ozs7O0lBU0QsY0FBYztRQUVWLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxDQUFDLENBQUM7UUFFaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUF1QjtZQUV6QyxJQUFJLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxFQUFFO2dCQUN0QixJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQzthQUNqQztTQUNKLENBQUMsQ0FBQztRQUVILElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUMsc0JBQXNCLEVBQUUsQ0FBQztTQUNqQztRQUVELElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUM7S0FDbkY7Ozs7Ozs7OztJQU1ELHFCQUFxQixDQUFDLElBQVMsRUFBRSxNQUEwQixFQUFFLElBQVM7UUFFbEUsSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLE1BQU0sRUFBRTtZQUMvQixPQUFPO1NBQ1Y7O1FBQ0QsSUFBSSxTQUFTLEdBQUc7WUFDWixHQUFHLEVBQUUsTUFBTSxDQUFDLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSztZQUMvQixJQUFJLEVBQUUsSUFBSTtTQUNiLENBQUM7UUFDRixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O1lBRXBFLElBQUksVUFBVSxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQzs7WUFDL0UsSUFBSSxVQUFVLEdBQUcsVUFBVSxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBRW5DLElBQUksVUFBVSxFQUFFO2dCQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUztxQkFDdEMsTUFBTSxDQUFDLENBQUMsR0FBUSxFQUFFLEtBQWEsS0FBSyxLQUFLLEtBQUssVUFBVSxDQUFDLENBQUM7YUFDbEU7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO2FBQy9EO1NBQ0o7YUFBTTtZQUNILElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDdEM7UUFDRCxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ2hEOzs7Ozs7OztJQU1ELHVCQUF1QixDQUFDLElBQVMsRUFBRSxNQUEwQjtRQUV6RCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ3ZDLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUFFO2dCQUMvQixJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7YUFDckM7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDO2FBQ3ZDO1NBQ0o7YUFBTTtZQUNILElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLE1BQU0sQ0FBQztTQUN2QztRQUNELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztLQUMzRDs7Ozs7O0lBRUQsa0JBQWtCLENBQUMsS0FBVSxFQUFFLElBQVM7O1FBR3BDLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNkLE9BQU87U0FDVjtRQUVELElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxPQUFPLEVBQUU7WUFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FFakM7YUFBTSxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssUUFBUSxFQUFFO1lBQ3hDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ2pDO0tBQ0o7Ozs7Ozs7O0lBTUQsV0FBVyxDQUFDLEtBQVUsRUFBRSxJQUFTOztRQUU3QixJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7UUFDdkIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOztZQUNwRSxJQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7O1lBQzFFLElBQUksVUFBVSxHQUFHLFVBQVUsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUVuQyxJQUFJLFVBQVUsRUFBRTtnQkFDWixJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVM7cUJBQ3RDLE1BQU0sQ0FBQyxDQUFDLEdBQVEsRUFBRSxLQUFhLEtBQUssS0FBSyxLQUFLLFVBQVUsQ0FBQyxDQUFDO2dCQUUvRCxXQUFXLEdBQUcsS0FBSyxDQUFDO2FBQ3ZCO2lCQUFNO2dCQUNILElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUMxRDs7WUFHRCxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsRUFBRTtnQkFDbEIsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQztnQkFDMUQsSUFBSSxDQUFDLCtCQUErQixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsQ0FBQzthQUMxRDtTQUNKO2FBQU07WUFDSCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBRTlCLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFO2dCQUNsQixJQUFJLENBQUMsa0NBQWtDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNyRCxJQUFJLENBQUMsK0JBQStCLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3JEO1NBQ0o7UUFFRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDO1lBQzNCLFVBQVUsRUFBRSxXQUFXO1lBQ3ZCLElBQUksRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVM7U0FDN0IsQ0FBQyxDQUFDO1FBRUgsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0tBQzNCOzs7Ozs7OztJQU1ELFdBQVcsQ0FBQyxLQUFVLEVBQUUsSUFBUztRQUU3QixJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFDNUIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDeEM7Ozs7Ozs7O0lBTUQsa0NBQWtDLENBQUMsV0FBZ0IsRUFBRSxVQUFtQjs7UUFFcEUsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBRTdFLElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O1lBRTVCLElBQUksQ0FBQyxVQUFVLEVBQUU7O2dCQUViLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQzNELElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxHQUFHLGVBQWUsQ0FBQyxDQUFDO2FBRXhFO2lCQUFNOztnQkFFSCxLQUFLLElBQUksS0FBSyxJQUFJLGVBQWUsRUFBRTs7b0JBQy9CLElBQUksVUFBVSxHQUFHLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztvQkFDM0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTO3lCQUN0QyxNQUFNLENBQUMsQ0FBQyxHQUFRLEVBQUUsS0FBYSxLQUFLLEtBQUssS0FBSyxVQUFVLENBQUMsQ0FBQztpQkFDbEU7YUFDSjs7WUFHRCxLQUFLLElBQUksS0FBSyxJQUFJLGVBQWUsRUFBRTtnQkFDL0IsSUFBSSxDQUFDLGtDQUFrQyxDQUFDLEtBQUssRUFBRSxVQUFVLENBQUMsQ0FBQzthQUM5RDtTQUNKO0tBQ0o7Ozs7Ozs7O0lBTUQsK0JBQStCLENBQUMsV0FBZ0IsRUFBRSxVQUFtQjs7UUFFakUsSUFBSSxNQUFNLEdBQUcsV0FBVyxDQUFDLFlBQVksQ0FBQztRQUN0QyxJQUFJLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRTs7WUFDbkIsSUFBSSxlQUFlLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDOztZQUV4RSxJQUFJLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDdkIsS0FBSyxJQUFJLEtBQUssSUFBSSxlQUFlLEVBQUU7Z0JBQy9CLFdBQVcsR0FBRyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO3VCQUN2RSxXQUFXLENBQUM7YUFDdEI7WUFFRCxJQUFJLENBQUMsVUFBVSxFQUFFO2dCQUNiLElBQUksV0FBVyxFQUFFO29CQUNiLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDckM7YUFFSjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsV0FBVyxFQUFFOztvQkFDZCxJQUFJLFdBQVcsR0FBRyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQy9ELE1BQU0sQ0FBQyxDQUFDO29CQUNaLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUzt5QkFDdEMsTUFBTSxDQUFDLENBQUMsR0FBUSxFQUFFLEtBQWEsS0FBSyxLQUFLLEtBQUssV0FBVyxDQUFDLENBQUM7aUJBQ25FO2FBQ0o7WUFDRCxJQUFJLENBQUMsK0JBQStCLENBQUMsV0FBVyxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztTQUM5RTtLQUNKOzs7Ozs7Ozs7SUFNRCxZQUFZLENBQUMsT0FBZSxFQUFFLE1BQWMsRUFBRSxPQUFxQjtRQUUvRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEVBQUU7O1lBRTVCLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDekQ7S0FDSjs7Ozs7OztJQU1ELHFCQUFxQixDQUFDLEtBQVU7O1FBRTVCLElBQUksSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUM7Ozs7UUFNdEIsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDL0IsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3QztLQUNKOzs7Ozs7O0lBT0QsVUFBVTtRQUVOLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBRXBELE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO1lBQ2pFLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7WUFFckUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ2IsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRztnQkFDMUIsS0FBSyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUzthQUNuQyxDQUFDLENBQUM7U0FDTjtLQUNKOzs7Ozs7SUFNRCxnQkFBZ0I7UUFFWixJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDdkMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDbEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FDL0IsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUM5QztTQUNKO1FBRUQsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7UUFDMUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3BDOzs7OztJQUVELGtCQUFrQixDQUFDLFVBQWdCO1FBRS9CLElBQUksQ0FBQyxZQUFZLEdBQUcsVUFBVSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUM7UUFFNUMsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDO2VBQ25ELElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxhQUFhLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUMxRTtZQUNJLElBQUksQ0FBQyxhQUFhLEdBQUcsTUFBTSxDQUFDO1NBQy9COztRQUdELElBQUksQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFLENBQUM7S0FDdkM7Ozs7SUFFRCxLQUFLO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7UUFDdkIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7S0FDN0I7Ozs7OztJQUtELGdCQUFnQixDQUFDLElBQXdCO1FBRXJDLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUU7WUFDckMsT0FBTyxLQUFLLENBQUM7U0FDaEI7O1FBRUQsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDOztRQUN4QyxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDO1FBQ3BGLE9BQU8sVUFBVSxLQUFLLFVBQVUsQ0FBQztLQUNwQzs7Ozs7Ozs7O0lBT0Qsa0JBQWtCLENBQUMsTUFBMEIsRUFBRSxJQUFTOztRQUVwRCxJQUFJLFNBQVMsR0FBRztZQUNaLEdBQUcsRUFBRSxNQUFNLENBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLO1lBQy9CLElBQUksRUFBRSxJQUFJO1NBQ2IsQ0FBQztRQUNGLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDO1lBQ2xDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztLQUM1RTs7Ozs7OztJQU1ELGFBQWEsQ0FBQyxJQUFTO1FBRW5CLElBQUksSUFBSSxDQUFDLHNCQUFzQixFQUFFLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFFbEUsSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLE9BQU8sRUFBRTtnQkFDaEMsT0FBTyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFFMUU7aUJBQU0sSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLFFBQVEsRUFBRTtnQkFDeEMsT0FBTyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDN0M7U0FDSjtRQUNELE9BQU8sS0FBSyxDQUFDO0tBQ2hCOzs7Ozs7O0lBT0QsT0FBTztRQUVILE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxJQUFJLENBQUMsWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsQ0FBQztLQUN6RTs7OztJQUVELGdCQUFnQjtRQUVaLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7S0FDekU7Ozs7O0lBS0QsMkJBQTJCO1FBRXZCLE9BQU8sSUFBSSxDQUFDLHNCQUFzQixFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUM7S0FDckU7Ozs7Ozs7SUFPRCxzQkFBc0I7UUFFbEIsT0FBTyxJQUFJLENBQUMsYUFBYSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsYUFBYSxLQUFLLE1BQU0sQ0FBQztLQUN6RTs7OztJQUVELGNBQWM7UUFFVixPQUFPLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUM7S0FDcEU7Ozs7Ozs7SUFNRCxxQkFBcUIsQ0FBQyxTQUFpQjtRQUVuQyxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEtBQUssV0FBVyxFQUFFO1lBQ2pELE9BQU8sQ0FBQyxDQUFDO1NBQ1o7UUFFRCxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEtBQUssWUFBWSxFQUFFO1lBQ2xELE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDYjs7UUFFRCxPQUFPLENBQUMsQ0FBQztLQUNaOzs7OztJQUVELHFCQUFxQixDQUFDLFNBQWlCO1FBRW5DLElBQUksT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLFNBQVMsS0FBSyxDQUFDLEVBQUU7WUFDdkMsT0FBTyxXQUFXLENBQUM7U0FDdEI7UUFFRCxJQUFJLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxTQUFTLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDeEMsT0FBTyxZQUFZLENBQUM7U0FDdkI7O1FBRUQsT0FBTyxXQUFXLENBQUM7S0FDdEI7Ozs7Ozs7SUFNRCxnQkFBZ0IsQ0FBQyxLQUFVOztRQUV2QixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQzs7UUFDM0MsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDO1FBQ2hELElBQUksY0FBYyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsTUFBTSxFQUFFO1lBQzlDLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztTQUM3QjthQUFNO1lBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxZQUFZLENBQUMsQ0FBQztTQUM1QztLQUNKOzs7Ozs7O0lBT0QseUJBQXlCOztRQUVyQixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQzs7UUFDM0MsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDO1FBRWhELE9BQU8sWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksY0FBYyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsTUFBTSxDQUFDO0tBQ2xGOzs7O0lBRUQseUJBQXlCOztRQUVyQixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLEVBQUUsQ0FBQztRQUUzQyxPQUFPLFlBQVksQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDO0tBQ3BDOzs7Ozs7Ozs7O0lBU0QsZ0JBQWdCLENBQUMsSUFBUztRQUV0QixJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hGLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxPQUFPLEtBQUssQ0FBQztLQUNoQjs7Ozs7OztJQU9ELFNBQVM7UUFFTCxPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksSUFBSSxDQUFDLGFBQWEsS0FBSyxNQUFNLENBQUM7S0FDcEU7Ozs7Ozs7Ozs7Ozs7SUFZRCxlQUFlLENBQUMsSUFBUztRQUVyQixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN4Qzs7Ozs7Ozs7O0lBT0QsUUFBUSxDQUFDLElBQVMsRUFBRSxLQUFhO1FBRTdCLE9BQU8sU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDL0M7Ozs7SUFFRCxXQUFXO1FBRVAsS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BCLElBQUksSUFBSSxDQUFDLG1CQUFtQixFQUFFO1lBQzFCLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUMxQztLQUNKOzs7Ozs7O0lBT08saUJBQWlCO1FBRXJCLElBQUksQ0FBQyxTQUFTO2FBQ1QsTUFBTSxDQUFDLENBQUMsSUFBd0IsS0FBSyxJQUFJLENBQUMsTUFBTSxDQUFDO2FBQ2pELE9BQU8sQ0FBQyxDQUFDLEdBQXVCO1lBRTdCLEdBQUcsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7U0FFaEMsQ0FBQyxDQUFDO1FBRVAsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7O1lBRy9CLElBQUksT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFO2lCQUM3QixPQUFPLEVBQUU7aUJBQ1QsU0FBUyxDQUFDLENBQUMsR0FBdUIsS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUV4RSxJQUFJLE9BQU8sS0FBSyxDQUFDLENBQUMsRUFBRTs7Z0JBQ2hCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7O2dCQUM1QyxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUNuRCxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsR0FBRyxZQUFZLEVBQUUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7YUFFakU7O1lBRUQsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU87aUJBQzFCLFNBQVMsQ0FBQyxDQUFDLEdBQXVCLEtBQUssT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBRXZFLE1BQU0sQ0FBQyxZQUFZLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsRUFDOUMsZ0VBQWdFO2dCQUNoRSx1Q0FBdUMsQ0FBQyxDQUFDO1lBRzdDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUNoQyw2REFBNkQsQ0FBQyxDQUFDO1NBRXRFOzs7Ozs7Ozs7SUFRRyxVQUFVLENBQUMsT0FBYztRQUU3QixVQUFVLENBQUM7WUFFUCxJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztZQUNwQixJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztTQUMzQixDQUFDLENBQUM7Ozs7OztJQUdDLGtCQUFrQixDQUFDLElBQVM7UUFFaEMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUNsQyxtQkFBdUIsSUFBSSxDQUFDLGVBQWUsR0FBRSxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7Ozs7WUExd0M1RSxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLDRnTkFBd0M7Z0JBRXhDLFNBQVMsRUFBRTtvQkFDUCxXQUFXO29CQUNYLFlBQVk7b0JBQ1osRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLENBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxFQUFDO2lCQUN0RjtnQkFDRCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07O2FBRWxEOzs7O1lBdEVHLFdBQVc7WUFwQlgsVUFBVTtZQXFDb0MsYUFBYSx1QkFvZ0I5QyxNQUFNLFNBQUMsV0FBVztZQTlpQi9CLGlCQUFpQjtZQUVqQix3QkFBd0I7WUFrQkwsWUFBWTtZQVQvQixNQUFNO1lBRk4sUUFBUTs7O21CQWdHUCxLQUFLOytCQU9MLEtBQUs7OEJBUUwsS0FBSzswQkFNTCxLQUFLOzhCQU9MLEtBQUs7OEJBT0wsS0FBSzs0QkFRTCxLQUFLO3NCQU9MLEtBQUs7K0JBTUwsS0FBSzs2QkFNTCxLQUFLOzZCQVVMLEtBQUs7dUJBVUwsS0FBSzt5QkFPTCxLQUFLOzJCQVFMLEtBQUs7eUJBUUwsS0FBSzt1QkFNTCxLQUFLO3NCQVFMLEtBQUs7NEJBU0wsS0FBSzswQkFTTCxLQUFLOzhCQU9MLEtBQUs7a0NBT0wsS0FBSzs0QkFTTCxLQUFLO3VCQVFMLEtBQUs7bUNBVUwsS0FBSzt3QkFNTCxLQUFLOzRCQVFMLEtBQUs7dUNBTUwsS0FBSzs0Q0FRTCxLQUFLO2tDQU9MLEtBQUs7NEJBUUwsS0FBSzsrQkFPTCxLQUFLOzBCQVFMLEtBQUs7NEJBUUwsS0FBSztxQkFRTCxNQUFNO3lCQVFOLE1BQU07bUNBVU4sTUFBTTsyQkFRTixNQUFNO2dDQU9OLE1BQU07cUJBSU4sWUFBWSxTQUFDLGtCQUFrQjttQ0FRL0IsWUFBWSxTQUFDLGFBQWE7NkJBTzFCLFlBQVksU0FBQyxVQUFVO2dDQU12QixZQUFZLFNBQUMsYUFBYTsyQkFNMUIsWUFBWSxTQUFDLFFBQVE7bUNBT3JCLFlBQVksU0FBQyxjQUFjO3dCQWlCM0IsZUFBZSxTQUFDLGtCQUFrQjs4QkFPbEMsWUFBWSxTQUFDLG9CQUFvQjswQkFTakMsTUFBTTt3QkFJTixXQUFXLFNBQUMsT0FBTztvQkErR25CLEtBQUs7Ozs7Ozs7QUM5a0JWOzs7Ozs7Ozs7Ozs7QUE2Q0EsZUFBdUIsU0FBUSxhQUFhOzs7Ozs7Ozs7SUFrR3hDLFlBQW1CLEdBQWdCLEVBQ2YsUUFDQSxhQUNBLFVBQ3FCLFVBQWtCLEVBRXhDLEVBQXVCO1FBRXRDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQVJJLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFDZixXQUFNLEdBQU4sTUFBTTtRQUNOLGdCQUFXLEdBQVgsV0FBVztRQUNYLGFBQVEsR0FBUixRQUFRO1FBQ2EsZUFBVSxHQUFWLFVBQVUsQ0FBUTtRQUV4QyxPQUFFLEdBQUYsRUFBRSxDQUFxQjs7Ozs7OytCQS9GaEIsU0FBUzs7Ozs7OzZCQVNYLFNBQVM7Ozs7OzJCQXNEbkIsSUFBSSxPQUFPLEVBQVU7Ozs7O2dDQU9oQixLQUFLOzs7OztpQ0FNSyxJQUFJO0tBc0JoQzs7OztJQUdELFFBQVE7UUFFSixLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFFakIsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSTs7UUFFMUMsWUFBWSxDQUFDLEdBQUcsQ0FBQzs7UUFHakIsb0JBQW9CLEVBQUUsRUFFdEIsU0FBUyxDQUFDLENBQUMsSUFBWSxLQUFLLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUN4QyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQVM7WUFFbEIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNqQztTQUNKLENBQUMsQ0FBQztRQUVILElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxXQUFXO2FBQ2hDLFNBQVMsQ0FBQyxDQUFDLElBQVMsS0FBSyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztLQUN6RDs7Ozs7OztJQVFELG9CQUFvQjtRQUVoQixJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFO1lBQzdCLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7O1FBRUQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2YsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBdUI7WUFFbEQsSUFBSSxHQUFHLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRTtnQkFDcEIsTUFBTSxJQUFJLEdBQUcsQ0FBQyxVQUFVLENBQUM7YUFDNUI7aUJBQU07Z0JBQ0gsTUFBTSxJQUFJLFFBQVEsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDakM7U0FFSixDQUFDLENBQUM7UUFDSCxPQUFPLE1BQU0sQ0FBQztLQUNqQjs7Ozs7Ozs7Ozs7O0lBV0Qsa0JBQWtCLENBQUMsVUFBZSxFQUFFLFlBQWlCO1FBRWpELE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxFQUNqRCx3REFBd0QsQ0FBQyxDQUFDOztRQUU5RCxJQUFJLFVBQVUsR0FBVSxVQUFVLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7O1FBQ2hFLElBQUksWUFBWSxHQUFVLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVwRSxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sS0FBSyxZQUFZLENBQUMsTUFBTSxFQUM1QywwQ0FBMEMsQ0FBQyxDQUFDO1FBRWhELEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBVyxFQUFFLEtBQWE7O1lBRXRELElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRSxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDeEUsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztZQUMvQixZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO1NBQy9DLENBQUMsQ0FBQztLQUNOOzs7O0lBRUQsZUFBZTtRQUVYLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztLQUN6Qjs7OztJQUdELGtCQUFrQjtRQUdkLElBQUksSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxFQUFFOztZQUM1QixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsaUJBQWlCLENBQUMsQ0FBQzs7WUFDakYsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUM7O1lBRXJGLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1lBRTlDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLFdBQVcsR0FBRyxJQUFJLENBQUM7WUFDNUMsSUFBSSxTQUFTLENBQUMsWUFBWSxDQUFDLEVBQUU7O2dCQUV6QixZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDO2dCQUNuRCxZQUFZLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsYUFBYSxDQUFDLFdBQVc7c0JBQzNELFVBQVUsQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDO2dCQUVwQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDO2FBQ3JEO1NBQ0o7S0FDSjs7OztJQUVELFdBQVc7UUFFUCxLQUFLLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFcEIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEVBQUU7WUFDbkMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQ3hDO1FBRUQsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDakM7S0FDSjs7Ozs7Ozs7O0lBYUQsZ0JBQWdCLENBQUMsS0FBVTtRQUV2QixJQUFJLElBQUksQ0FBQyxnQkFBZ0IsRUFBRTtZQUN2QixJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQy9CO2FBQU07WUFDSCxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzlCO0tBQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQWlCRCxjQUFjLENBQUMsS0FBVTtRQUVyQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO1FBRTdCLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN2QixJQUFJLENBQUMsc0JBQXNCLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztRQUNqRCxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQixJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUM7O1FBSWhDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQztRQUMzRCxPQUFPLFNBQVMsQ0FBQyxVQUFVLENBQUMsSUFBSSxVQUFVLENBQUMsT0FBTyxLQUFLLE1BQU0sRUFBRTtZQUMzRCxVQUFVLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1lBQ2xELFVBQVUsR0FBRyxVQUFVLENBQUMsVUFBVSxDQUFDO1NBQ3RDO1FBQ0QsSUFBSSxDQUFDLHdCQUF3QixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUU3QyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztRQUN4RCxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQzs7UUFHeEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO0tBQzFDOzs7Ozs7OztJQU9ELGVBQWUsQ0FBQyxLQUFVO1FBRXRCLElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFOUIsSUFBSSxDQUFDLHdCQUF3QixFQUFFLENBQUM7UUFDaEMsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWpDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQztRQUN2RSxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbkQsVUFBVSxDQUFDO1lBRVAsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7U0FDakQsRUFBRSxHQUFHLENBQUMsQ0FBQztLQUNYOzs7Ozs7Ozs7SUFRRCxvQkFBb0IsQ0FBQyxVQUFtQjtRQUVwQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUM7UUFDM0MsVUFBVSxDQUFDO1lBRVAsSUFBSSxVQUFVLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTLElBQUksZ0JBQWdCLENBQUM7Z0JBQ3RDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQzthQUU5QztpQkFBTTtnQkFDSCxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEVBQzFELEVBQUUsQ0FBQyxDQUFDO2dCQUNSLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQzthQUM5QztTQUNKLEVBQUUsR0FBRyxDQUFDLENBQUM7S0FFWDs7Ozs7OztJQU1ELFVBQVUsQ0FBQyxLQUFVO1FBRWpCLElBQUksS0FBSyxDQUFDLE1BQU0sRUFBRTtZQUNkLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQzNDO2FBQU07O1lBQ0gsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDOztZQUNuRCxJQUFJLElBQUksR0FBRyxZQUFZLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQy9DLFlBQVksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1NBQzlEO0tBQ0o7Ozs7Ozs7O0lBUU8sZUFBZTtRQUVuQixJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUVuRixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7UUFDcEYsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztRQUN6RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFL0IsVUFBVSxDQUFDO1lBRVAsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7U0FDckYsRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7OztJQU9KLGlCQUFpQjtRQUVyQixJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7UUFDckIsSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBR2hDLFVBQVUsQ0FBQztZQUVQLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNyQixJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1NBRTVELEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFUixVQUFVLENBQUM7WUFFUCxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxDQUFDLEVBQy9FLENBQUMsQ0FBQyxDQUFDO1NBQ1YsRUFBRSxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7SUFPSix3QkFBd0IsQ0FBQyxhQUFrQjtRQUUvQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLFVBQVUsS0FBSyxhQUFhLEVBQUU7WUFDN0QsT0FBTztTQUNWO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFOztZQUNwRCxJQUFJLE9BQU8sR0FBRyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3hDLElBQUksSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNoQyxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxDQUFDLENBQUM7YUFFMUM7aUJBQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLEVBQUU7Z0JBQ3RELE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7YUFDN0M7U0FDSjs7Ozs7O0lBTUcsd0JBQXdCO1FBRTVCLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDLENBQUM7YUFDckQsT0FBTyxDQUFDLENBQUMsSUFBUyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7SUFPbkUsZ0JBQWdCLENBQUMsT0FBWTtRQUVqQyxPQUFPLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxLQUFLLFFBQVE7WUFDckQsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUM7WUFDbkQsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDOzs7Ozs7O0lBUTlDLGNBQWM7O1FBRWxCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxNQUFNLENBQUM7O1FBQ3hELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxZQUFZLENBQUM7UUFFdkYsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDOzs7Ozs7Ozs7OztJQU8vRCxhQUFhLENBQUMsSUFBWSxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxFQUMxQyxJQUFZLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLEVBQ3pDLElBQVksSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssRUFDM0MsSUFBWSxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTTtRQUU5RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM3RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM1RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQztRQUM5RCxJQUFJLENBQUMsbUJBQW1CLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQzs7Ozs7Ozs7SUFPM0QsbUJBQW1CLENBQUMsTUFBZTs7UUFFdkMsSUFBSSxDQUFDLENBQVk7O1FBQWpCLElBQU8sQ0FBQyxDQUFTOztRQUFqQixJQUFVLEVBQUUsQ0FBSzs7UUFBakIsSUFBYyxFQUFFLENBQUM7UUFDakIsSUFBSSxNQUFNLEVBQUU7WUFDUixDQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDO1lBQ3hELENBQUMsR0FBRyxNQUFNLENBQUMsV0FBVyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7WUFDMUQsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLEtBQUssR0FBRyxDQUFDO2tCQUMzRCxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxJQUFJLENBQUMsQ0FBQztZQUMxQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxHQUFHLENBQUM7a0JBQzdELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO1NBRTVDO2FBQU07WUFDSCxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ04sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNOLEVBQUUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDO1lBQ3BDLEVBQUUsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsR0FBRyxDQUFDO1NBQ3RDO1FBRUQsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsU0FBUztZQUNsRCxTQUFTLEdBQUcsQ0FBQyxHQUFHLFdBQVcsR0FBRyxDQUFDLEdBQUcsZ0JBQWdCLElBQUksRUFBRSxDQUFDLEdBQUcsTUFBTSxJQUFJLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQzs7Ozs7O0lBUXZGLGNBQWM7UUFFbEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUNyQyxJQUFJLENBQUMsaUJBQWlCLEdBQUcsS0FBSyxDQUFDO1lBQy9CLE9BQU87U0FDVjtRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxDQUFDOzs7Ozs7O0lBTzNFLGVBQWU7UUFFbkIsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ2hDLFVBQVUsQ0FBQyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FFekQ7Ozs7WUF4Z0JSLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsMmxKQUEyQztnQkFFM0MsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7O2FBRXhDOzs7O1lBN0JlLFdBQVc7WUFMdkIsU0FBUztZQUxULFVBQVU7WUFpQk4sZUFBZTtZQTZIa0MsTUFBTSx1QkFBOUMsTUFBTSxTQUFDLFdBQVc7WUFuSTNCLG1CQUFtQix1QkFvSVYsTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLG1CQUFtQixDQUFDOzs7OEJBL0Z4RCxLQUFLOzRCQVNMLEtBQUs7c0JBVUwsWUFBWSxTQUFDLGFBQWE7eUJBTzFCLFlBQVksU0FBQyxZQUFZO3VCQU96QixZQUFZLFNBQUMsVUFBVTtxQkFRdkIsWUFBWSxTQUFDLFlBQVk7a0NBT3pCLFNBQVMsU0FBQyxxQkFBcUI7NkJBUS9CLFNBQVMsU0FBQyxnQkFBZ0I7Ozs7Ozs7QUNqSS9COzs7Ozs7Ozs7QUFnQkE7Ozs7OztJQU1JLFlBQW9CLE9BQW1CLEVBQ25CLFFBQ0E7UUFGQSxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLFdBQU0sR0FBTixNQUFNO1FBQ04sT0FBRSxHQUFGLEVBQUU7S0FFckI7Ozs7SUFHRCxRQUFRO0tBR1A7Ozs7SUFFRCxlQUFlOztRQUdYLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRTs7WUFDbkQsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDL0UsSUFBSSxTQUFTLENBQUMsVUFBVSxDQUFDLEVBQUU7Z0JBQ3ZCLFVBQVUsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQztnQkFDdkMsVUFBVSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsY0FBYyxDQUFDOztnQkFDMUMsSUFBSSxTQUFTLEdBQUcsVUFBVSxDQUFDLFdBQVcsQ0FBQztnQkFDdkMsVUFBVSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDO2dCQUN2QyxVQUFVLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUM7Z0JBRXBDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxFQUFFO29CQUNoQyxPQUFPO2lCQUNWO2dCQUVELFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQzlCLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFO29CQUM3QixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFO3dCQUM3QixJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsR0FBRyxTQUFTLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEdBQUcsU0FBUzs0QkFDM0QsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUM7cUJBRTFCO3lCQUFNLElBQUksU0FBUyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7d0JBQ3JDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVU7OEJBQ3BELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUM7cUJBQzlDO2lCQUNKO2FBQ0o7U0FDSjtLQUNKOzs7Ozs7Ozs7Ozs7OztJQWFELGFBQWEsQ0FBQyxRQUFnQjtRQUUxQixJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxHQUFHLENBQUMsRUFBRTtZQUN4QixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQztTQUN2RjtRQUNELE9BQU8sSUFBSSxDQUFDO0tBQ2Y7Ozs7SUFHTyxTQUFTOztRQUViLElBQUksYUFBYSxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUM7O1FBQ2pFLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BELElBQUksSUFBSSxRQUFRLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNsRCxJQUFJLElBQUksUUFBUSxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0RCxJQUFJLElBQUksUUFBUSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7OztRQUlyRCxJQUFJLElBQUksQ0FBQyxDQUFDO1FBRVYsT0FBTyxJQUFJLENBQUM7Ozs7WUFwRm5CLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsY0FBYzthQUMzQjs7OztZQWZpQyxVQUFVO1lBQWlCLFNBQVM7WUFDOUQsa0JBQWtCOzs7eUJBa0JyQixLQUFLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdUNWOzs7Ozs7O0lBNkNJLFlBQW9CLE9BQW1CLEVBRW5CLEVBQXVCLEVBQ3ZCLFVBQ0E7UUFKQSxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBRW5CLE9BQUUsR0FBRixFQUFFLENBQXFCO1FBQ3ZCLGFBQVEsR0FBUixRQUFRO1FBQ1IsV0FBTSxHQUFOLE1BQU07Ozs7Ozs7K0JBdkNDLEtBQUs7Ozs7OzJCQU9WLENBQUM7Ozs7Ozt1QkFPVSxhQUFhLENBQUMsSUFBSTs7Ozs7d0JBTXZCLEtBQUs7Ozs7Ozs7cUJBUVQsQ0FBQztLQWF4Qjs7OztJQUdELFFBQVE7UUFFSixJQUFJLElBQUksQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO1NBQzlCO0tBQ0o7Ozs7SUFHRCxXQUFXO1FBRVAsSUFBSSxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRTtZQUN2QixJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQztTQUNoQztLQUNKOzs7OztJQUtPLG1CQUFtQjtRQUV2QixJQUFJLENBQUMsTUFBTSxDQUFDLGlCQUFpQixDQUFDO1lBRTFCLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNuRSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQ25ELElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUVyQyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUNuRCxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFFckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqRSxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQ2xELElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUVwQyxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbkUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxFQUNuRCxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7WUFFckMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN6RCxJQUFJLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQzlDLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUVoQyxJQUFJLENBQUMsYUFBYSxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQy9ELElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFDakQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBQ3RDLENBQUMsQ0FBQzs7Ozs7O0lBTUMscUJBQXFCO1FBRXpCLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFZO1lBRTVCLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ2xFLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0lBZUMsZ0JBQWdCLENBQUMsS0FBVTtRQUUvQixJQUFJLEtBQUssQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxFQUFFO1lBQzVFLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7O1lBQzVDLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xFLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsRUFBRSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUV2RjthQUFNO1lBQ0gsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztTQUVoRDs7Ozs7Ozs7Ozs7OztJQVlHLGdCQUFnQixDQUFDLEtBQVU7UUFFL0IsVUFBVSxDQUFDO1lBRVAsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtnQkFDbkMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7YUFDakQ7U0FDSixFQUFFLEdBQUcsQ0FBQyxDQUFDO1FBRVIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUN6QyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNoRCxLQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7SUFjakQsZUFBZSxDQUFDLEtBQVU7UUFFOUIsS0FBSyxDQUFDLFlBQVksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDO1FBQ3ZDLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFO1lBQzFCLElBQUksQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQztTQUNyQzthQUFNLElBQUksSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFO1lBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsYUFBYSxDQUFDLEVBQUUsQ0FBQztTQUNuQzs7UUFFRCxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssS0FBSyxDQUFDLEtBQUssRUFBRTtZQUM1QixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7U0FDNUI7UUFFRCxJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsRUFBRTs7WUFFL0IsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3ZCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQzNFOzs7Ozs7Ozs7O0lBU0csV0FBVyxDQUFDLEtBQVU7UUFFMUIsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDOztRQUc5QyxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7O1FBQzdDLElBQUksT0FBTyxHQUFpQixJQUFJLENBQUMsUUFBUSxHQUFHLFlBQVksQ0FBQyxJQUFJLElBQ3pELElBQUksQ0FBQyxPQUFPLEtBQUssYUFBYSxDQUFDLEVBQUUsR0FBRyxZQUFZLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxLQUFLLENBQy9FLENBQUM7UUFDRixJQUFJLENBQUMsRUFBRSxDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUUxRCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQzs7Ozs7Ozs7OztJQVNYLGdCQUFnQixDQUFDLEtBQVU7O1FBRS9CLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDbkQsSUFBSSxDQUFDLFlBQVksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUV0QixJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLENBQUMsQ0FBQzs7Ozs7Ozs7OztJQVN0QyxjQUFjLENBQUMsS0FBVTtRQUU3QixJQUFJLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ25DLEtBQUssQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUM3QyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDdEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkJ2QyxnQkFBZ0IsQ0FBQyxLQUFVLEVBQUUsU0FBYztRQUcvQyxJQUFJLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDOztRQUc3QixJQUFJLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7O1FBQzVFLElBQUksZUFBZSxHQUFHLEtBQUssQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7UUFFOUUsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxlQUFlLEdBQUcsZUFBZSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1NBQ25FO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2YsU0FBUyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBRWpEO2FBQU07WUFDSCxTQUFTLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7U0FDekM7Ozs7Ozs7Ozs7SUFTRyxpQkFBaUIsQ0FBQyxLQUFVOztRQUVoQyxJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7O1FBQzVDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDO1FBRTVDLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsV0FBVyxLQUFLLE9BQU87WUFDOUUsRUFBRSxVQUFVLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssYUFBYSxDQUFDLEVBQUUsQ0FBQztZQUN4RCxFQUFFLFVBQVUsS0FBSyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7SUFRNUQsWUFBWSxDQUFDLEVBQU87UUFFeEIsRUFBRSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUN2QyxFQUFFLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQzFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLGtCQUFrQixDQUFDLENBQUM7Ozs7Ozs7SUFPcEMsZUFBZTtRQUVuQixRQUFRLElBQUksQ0FBQyxPQUFPO1lBQ2hCLEtBQUssYUFBYSxDQUFDLEVBQUU7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDO1lBQ2hCLEtBQUssYUFBYSxDQUFDLElBQUk7Z0JBQ25CLE9BQU8sTUFBTSxDQUFDO1lBQ2xCO2dCQUNJLE9BQU8sVUFBVSxDQUFDO1NBQ3pCOzs7O1lBaFZSLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsa0JBQWtCO2FBQy9COzs7O1lBbkNjLFVBQVU7WUFHakIsbUJBQW1CLHVCQStFVixNQUFNLFNBQUMsVUFBVSxDQUFDLE1BQU0sbUJBQW1CLENBQUM7WUE5RXJELGVBQWU7WUFKK0IsTUFBTTs7OzhCQTZDdkQsS0FBSzswQkFPTCxLQUFLOzs7Ozs7O0FDdERWOzs7WUEwQkMsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixtQkFBbUI7b0JBQ25CLFNBQVM7b0JBQ1Qsa0JBQWtCO29CQUNsQixrQkFBa0I7b0JBQ2xCLG9CQUFvQjtvQkFDcEIsNEJBQTRCO29CQUM1Qiw0QkFBNEI7b0JBQzVCLDZCQUE2QjtvQkFDN0IsdUJBQXVCO29CQUN2Qix3QkFBd0I7aUJBQzNCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLFdBQVc7b0JBQ1gscUJBQXFCO29CQUNyQixnQkFBZ0I7b0JBQ2hCLGtCQUFrQjtvQkFDbEIsbUJBQW1CO29CQUNuQixrQkFBa0I7aUJBQ3JCO2dCQUNELGVBQWUsRUFBRTtvQkFDYiw0QkFBNEI7b0JBQzVCLDRCQUE0QjtvQkFDNUIsNkJBQTZCO2lCQUNoQztnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsbUJBQW1CO29CQUNuQixrQkFBa0I7b0JBQ2xCLGtCQUFrQjtvQkFDbEIsa0JBQWtCO29CQUNsQixvQkFBb0I7aUJBQ3ZCO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7O0FDN0REOzs7OztBQVdBOzs7WUFKQyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHdCQUF3QjtnQkFDbEMsUUFBUSxFQUFFLDJCQUEyQjthQUN4Qzs7Ozs7OztBQ1ZEOzs7OztBQVdBOzs7WUFKQyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHdCQUF3QjtnQkFDbEMsUUFBUSxFQUFFLDJCQUEyQjthQUN4Qzs7Ozs7OztBQ1ZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEZBLDJCQUFtQyxTQUFRLGNBQWM7Ozs7SUFzRnJELFlBQW1CLEdBQWdCO1FBRS9CLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUZJLFFBQUcsR0FBSCxHQUFHLENBQWE7Ozs7NkJBakRBLElBQUksWUFBWSxFQUFFOzs7O3dCQU1qQyxLQUFLOzs7O3VCQVlJLElBQUksWUFBWSxFQUFFOzs7O3NCQU1uQixJQUFJLFlBQVksRUFBRTs7Ozt5QkFNZixJQUFJLFlBQVksRUFBRTs7Ozt3QkFNbkIsSUFBSSxZQUFZLEVBQUU7UUFpQjVDLElBQUksQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFDO1FBQ2pCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDOztRQUVyQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsU0FBUyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxRQUFRLENBQUM7S0FDckM7Ozs7O0lBS0QsSUFBSTtRQUVBLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7UUFFbkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDakM7Ozs7O0lBS0QsS0FBSztRQUVELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7Ozs7UUFLcEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDbEM7Ozs7O0lBS0QsU0FBUztRQUVMLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUNqQzs7Ozs7SUFLRCxTQUFTO1FBRUwsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ2pDOzs7OztJQUtELE9BQU87UUFFSCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ3pCOzs7OztJQUtELE1BQU07UUFFRixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDO0tBQ3hCOzs7WUEvSkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxpQkFBaUI7Z0JBQzNCLCtoQ0FBMEM7O2FBRTdDOzs7O1lBeEZPLFdBQVc7OztvQkErRmQsS0FBSzttQkFPTCxLQUFLO2lDQVFMLEtBQUs7Z0NBUUwsS0FBSzs0QkFPTCxNQUFNO3VCQU1OLEtBQUs7dUJBTUwsS0FBSztzQkFNTCxNQUFNO3FCQU1OLE1BQU07d0JBTU4sTUFBTTt1QkFNTixNQUFNO3FCQU1OLFlBQVksU0FBQywyQkFBMkI7cUJBS3hDLFlBQVksU0FBQywyQkFBMkI7Ozs7Ozs7QUM3SzdDOzs7WUFVQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLHFCQUFxQjtvQkFDckIsMkJBQTJCO29CQUMzQiwyQkFBMkI7aUJBQzlCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO29CQUNaLHFCQUFxQjtvQkFDckIsY0FBYztvQkFDZCxjQUFjO2lCQUNqQjtnQkFDRCxlQUFlLEVBQUU7b0JBQ2IsY0FBYztvQkFDZCxxQkFBcUI7b0JBQ3JCLDJCQUEyQjtvQkFDM0IsMkJBQTJCO2lCQUM5QjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wscUJBQXFCO29CQUNyQiwyQkFBMkI7b0JBQzNCLDJCQUEyQjtpQkFDOUI7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUNsQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9GQSxrQ0FBMEMsU0FBUSxhQUFhOzs7OztJQWdDM0QsWUFBbUIsR0FBZ0IsRUFBUyxVQUFzQjtRQUU5RCxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFGSSxRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQVMsZUFBVSxHQUFWLFVBQVUsQ0FBWTs7Ozs7Ozs7Ozs7eUJBakJsQyxZQUFZOzs7Ozt5QkFPUCxNQUFNO1FBY3ZDLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1FBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO0tBQ3ZCOzs7O0lBRUQsUUFBUTtRQUVKLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztLQUN0Qjs7Ozs7OztJQU9ELFdBQVcsQ0FBQyxPQUFzQjtRQUU5QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7S0FDdEI7Ozs7Ozs7Ozs7Ozs7O0lBZU8sV0FBVztRQUVmLElBQUksQ0FBQyxXQUFXLEdBQUcsaUJBQWlCLENBQUM7UUFDckMsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFVBQVUsRUFBRTtZQUMvQixJQUFJLENBQUMsV0FBVyxHQUFHLGlCQUFpQixDQUFDO1NBRXhDO1FBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLGNBQWMsRUFBRTtZQUNuQyxJQUFJLENBQUMsV0FBVyxHQUFHLHFCQUFxQixDQUFDO1NBRTVDO2FBQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLE1BQU0sRUFBRTtZQUNsQyxJQUFJLENBQUMsV0FBVyxHQUFHLGlCQUFpQixDQUFDO1NBRXhDO2FBQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLE1BQU0sRUFBRTtZQUNsQyxJQUFJLENBQUMsV0FBVyxHQUFHLGlCQUFpQixDQUFDO1NBQ3hDO1FBRUQsSUFBSSxDQUFDLFdBQVcsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFdkUsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQzVCLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7U0FDN0M7O1FBR0QsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO1NBQ3ZCO1FBRUQsSUFBSSxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1NBQ3hCOzs7Ozs7O0lBUUwsbUJBQW1COztRQUVmLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNuRixPQUFPLGVBQWUsQ0FBQyxXQUFXLEdBQUcsZUFBZSxDQUFDLFdBQVcsQ0FBQztLQUNwRTs7Ozs7O0lBT0QsaUJBQWlCOztRQUViLElBQUksZUFBZSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUNuRixPQUFPLGVBQWUsQ0FBQyxZQUFZLEdBQUcsZUFBZSxDQUFDLFlBQVksQ0FBQztLQUN0RTs7O1lBOUhKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsbUtBQWtEOzthQUVyRDs7OztZQWxGTyxXQUFXO1lBREEsVUFBVTs7O3dCQWtHeEIsS0FBSzt3QkFPTCxLQUFLOzs7Ozs7O0FDekdWOzs7WUFLQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLDRCQUE0QjtpQkFDL0I7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7aUJBQ2Y7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLDRCQUE0QjtpQkFDL0I7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLDRCQUE0QjtpQkFDL0I7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUNuQkQ7QUFvQkEsTUFBYSx5QkFBeUIsR0FBUTtJQUMxQyxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsTUFBTSxhQUFhLENBQUM7SUFDNUMsS0FBSyxFQUFFLElBQUk7Q0FDZCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEVGLG1CQUEyQixTQUFRLGlCQUFpQjs7Ozs7SUFxR2hELFlBQW1CLEdBQWdCLEVBRWIsZUFBa0M7UUFFcEQsS0FBSyxDQUFDLEdBQUcsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUpiLFFBQUcsR0FBSCxHQUFHLENBQWE7UUFFYixvQkFBZSxHQUFmLGVBQWUsQ0FBbUI7Ozs7NkJBbEZ6QixRQUFROzs7OzswQkFzQmpCLEtBQUs7Ozs7O3NCQU9DLElBQUksWUFBWSxFQUFFOzs7OzsyQkFPYixJQUFJLFlBQVksRUFBRTt5QkFzQ2hCLEVBQUU7MEJBRWYsS0FBSzs0QkFDSCxLQUFLO0tBUTVCOzs7O0lBRUQsUUFBUTtRQUVKLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUVqQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxhQUFhLEtBQUssT0FBTztZQUM1QyxJQUFJLENBQUMsYUFBYSxLQUFLLG1CQUFtQixDQUFDO1FBQy9DLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGFBQWEsS0FBSyxtQkFBbUIsQ0FBQzs7UUFHL0QsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsRUFBRTtZQUMzRCxNQUFNLElBQUksS0FBSyxDQUFDLG9EQUFvRCxDQUFDLENBQUM7U0FDekU7UUFFRCxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDdEIsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ25CO2FBQU07WUFDSCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7U0FDOUM7O1FBR0QsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3hCLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxHQUFHLE1BQU0sQ0FBQztTQUN6QztRQUVELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2QixJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7U0FDeEM7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDakIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsR0FBRyxhQUFhLENBQUM7U0FDbEQ7UUFFRCxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7WUFDbkIsS0FBSyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUUxQyxJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUM7YUFDM0M7U0FDSjtLQUNKOzs7Ozs7Ozs7Ozs7SUFVRCxXQUFXLENBQUMsS0FBVSxFQUFFLElBQVMsRUFBRSxRQUEyQjtRQUUxRCxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFekMsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO1FBQ3hCLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztLQUMxQjs7Ozs7O0lBTUQsYUFBYTtRQUVULE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztLQUNyQzs7OztJQUVELFlBQVk7UUFFUixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDckM7Ozs7SUFHRCxjQUFjO1FBRVYsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQ3JDOzs7Ozs7Ozs7SUFRRCxjQUFjLENBQUMsS0FBVTtRQUVyQixJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDdEIsT0FBTztTQUNWO1FBRUQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ25DLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNuQixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEVBQUMsU0FBUyxFQUFFLElBQUksRUFBQyxDQUFDLENBQUM7U0FDN0Q7UUFDRCxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNwQzs7Ozs7OztJQU9ELFVBQVUsQ0FBQyxLQUFVO1FBRWpCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztZQUN2QixJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ25CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3BDO1NBQ0o7S0FDSjs7Ozs7O0lBTU8sUUFBUTtRQUVaLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUN0QixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBUztnQkFFeEMsT0FBTyxFQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUMsQ0FBQzthQUN4RCxDQUFDLENBQUM7U0FDTjs7Ozs7Ozs7SUFRRyxZQUFZLENBQUMsSUFBUztRQUUxQixJQUFJLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUNmLE9BQU8sRUFBRSxDQUFDO1NBQ2I7O1FBRUQsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzFCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN2QixHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUUxQjthQUFNLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO1lBQ3pDLEdBQUcsR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDckM7UUFDRCxPQUFPLEdBQUcsQ0FBQzs7OztZQXJRbEIsU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxTQUFTO2dCQUNuQiw4N0RBQW9DO2dCQUVwQyxTQUFTLEVBQUU7b0JBQ1AseUJBQXlCO29CQUN6QixFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUUsVUFBVSxDQUFDLE1BQU0sYUFBYSxDQUFDLEVBQUM7aUJBQzdFOzthQUNKOzs7O1lBcEZPLFdBQVc7WUFFWCxpQkFBaUIsdUJBeUxSLFFBQVEsWUFBSSxRQUFRLFlBQUksTUFBTSxTQUFDLFVBQVUsQ0FBQyxNQUFNLGlCQUFpQixDQUFDOzs7bUJBOUY5RSxLQUFLO3dCQU1MLEtBQUs7NEJBTUwsS0FBSzsrQkFRTCxLQUFLO29CQU1MLEtBQUs7eUJBUUwsS0FBSztxQkFPTCxNQUFNOzBCQU9OLE1BQU07dUJBUU4sU0FBUyxTQUFDLFNBQVM7eUJBaUJuQixZQUFZLFNBQUMsTUFBTTt5QkFHbkIsWUFBWSxTQUFDLFFBQVE7eUJBR3JCLFlBQVksU0FBQyxPQUFPOzs7Ozs7O0FDekx6Qjs7O1lBUUMsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixhQUFhO2lCQUNoQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixtQkFBbUI7b0JBQ25CLFdBQVc7b0JBQ1gsYUFBYTtvQkFDYixnQkFBZ0I7aUJBRW5CO2dCQUNELGVBQWUsRUFBRTtvQkFDYixhQUFhO2lCQUNoQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsYUFBYTtvQkFDYixtQkFBbUI7b0JBQ25CLFdBQVc7aUJBQ2Q7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7O0lDUkc7MkJBUHNCLENBQUM7MkJBR1UsSUFBSSxZQUFZLEVBQU87MEJBRW5DLENBQUM7S0FJckI7Ozs7SUFFRCxRQUFRO1FBRUosSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFOztZQUNaLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNsRixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxZQUFZLEdBQUcsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ3pEO0tBQ0o7Ozs7O0lBRUQsY0FBYyxDQUFDLFFBQWdCLENBQUM7UUFFNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDO1FBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxXQUFXLEVBQUMsQ0FBQyxDQUFDO0tBQ3REOzs7OztJQUVELFFBQVEsQ0FBQyxLQUFhO1FBRWxCLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRTtZQUM3QixPQUFPO1NBQ1Y7O1FBRUQsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xGLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztRQUV6QyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQzlCOzs7WUFoREosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLDZWQUErQzs7YUFFbEQ7Ozs7O29CQUdJLEtBQUs7MEJBR0wsS0FBSzswQkFHTCxNQUFNOzs7Ozs7O0FDaEJYOzs7WUFLQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLHVCQUF1QjtpQkFDMUI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7aUJBQ2Y7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLHVCQUF1QjtpQkFDMUI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLHVCQUF1QjtpQkFDMUI7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUNuQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0NBLDJCQUFtQyxTQUFRLGFBQWE7Ozs7SUFXcEQsWUFBbUIsR0FBZ0I7UUFFL0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRkksUUFBRyxHQUFILEdBQUcsQ0FBYTs7OztxQkFOVCxLQUFLO0tBUzlCOzs7OztJQUtELGFBQWE7UUFFVCxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztLQUM1Qjs7O1lBNUJKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsV0FBVztnQkFDckIsZ1VBQTZDOzthQUVoRDs7OztZQTVCTyxXQUFXOzs7b0JBbUNkLEtBQUs7d0JBSUwsS0FBSzs7Ozs7OztBQ3pDVjs7O1lBS0MsUUFBUSxTQUFDO2dCQUNOLFlBQVksRUFBRTtvQkFDVixxQkFBcUI7aUJBQ3hCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxZQUFZO2lCQUNmO2dCQUNELGVBQWUsRUFBRTtvQkFDYixxQkFBcUI7aUJBQ3hCO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxxQkFBcUI7aUJBQ3hCO2dCQUNELFNBQVMsRUFBRSxFQUFFO2FBQ2hCOzs7Ozs7O0FDbkJEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBFQSxzQkFBOEIsU0FBUSxjQUFjOzs7O0lBNkNoRCxZQUFtQixHQUFnQjtRQUUvQixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7UUFGSSxRQUFHLEdBQUgsR0FBRyxDQUFhOzs7OzJCQXRDWixJQUFJOzs7OzZCQU1GLEtBQUs7Ozs7dUJBV0QsSUFBSSxZQUFZLEVBQUU7Ozs7MkJBT2QsSUFBSSxZQUFZLEVBQUU7Ozs7c0JBTXZCLElBQUksWUFBWSxFQUFFO0tBVzdDOzs7O0lBRUQsUUFBUTtLQUVQOzs7O0lBRUQsa0JBQWtCOztLQUdqQjs7OztJQUVELGVBQWU7O0tBR2Q7Ozs7OztJQU9ELElBQUksQ0FBQyxLQUFVO1FBRVgsVUFBVSxDQUFDO1lBRVAsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN2QixFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ1Q7Ozs7O0lBS0QsS0FBSztRQUVELElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7S0FDdkI7Ozs7OztJQU9ELE1BQU0sQ0FBQyxLQUFVO1FBRWIsVUFBVSxDQUFDO1lBRVAsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDOUIsRUFBRSxDQUFDLENBQUMsQ0FBQztLQUNUOzs7OztJQUdELFFBQVEsQ0FBQyxLQUFVO1FBRWYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDM0I7Ozs7O0lBRUQsUUFBUSxDQUFDLEtBQVU7UUFFZixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUM1Qjs7O1lBbEhKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsWUFBWTtnQkFDdEIsb1FBQXFDOzthQUV4Qzs7OztZQTlETyxXQUFXOzs7MEJBcUVkLEtBQUs7NEJBTUwsS0FBSzt1QkFLTCxLQUFLO3NCQU1MLE1BQU07MEJBT04sTUFBTTtxQkFNTixNQUFNO3NCQU1OLFNBQVMsU0FBQyxZQUFZOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BIM0I7O0lBZUksTUFBRztJQUNILFNBQU07SUFDTixPQUFJOzs4QkFGSixHQUFHOzhCQUNILE1BQU07OEJBQ04sSUFBSTs7O0lBWUosT0FBSTtJQUNKLGFBQVU7SUFDVixRQUFLO0lBQ0wsY0FBVztJQUNYLFVBQU87O2dDQUpQLElBQUk7Z0NBQ0osVUFBVTtnQ0FDVixLQUFLO2dDQUNMLFdBQVc7Z0NBQ1gsT0FBTzs7Ozs7Ozs7Ozs7QUFhWCxNQUFNLGVBQWUsR0FBRztJQUNwQixHQUFHLEVBQUUsOENBQThDO0lBQ25ELE1BQU0sRUFBRSw4Q0FBOEM7SUFDdEQsSUFBSSxFQUFFLEVBQUU7Q0FDWCxDQUFDOzs7Ozs7Ozs7Ozs7QUFjRixNQUFNLGdCQUFnQixHQUFHO0lBQ3JCLElBQUksRUFBRSxnQkFBZ0I7SUFDdEIsS0FBSyxFQUFFLGdCQUFnQjtJQUN2QixVQUFVLEVBQUUsZ0JBQWdCO0lBQzVCLFdBQVcsRUFBRSxnQkFBZ0I7SUFDN0IsT0FBTyxFQUFFLGdCQUFnQjtDQUM1QixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0Ysd0JBQWdDLFNBQVEsYUFBYTs7Ozs7O0lBb0ZqRCxZQUFzQixJQUFnQixFQUFTLEdBQWdCLEVBQzNDO1FBRWhCLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUhPLFNBQUksR0FBSixJQUFJLENBQVk7UUFBUyxRQUFHLEdBQUgsR0FBRyxDQUFhO1FBQzNDLE9BQUUsR0FBRixFQUFFOzs7OzswQkExREEsSUFBSTs7Ozs7Ozs7OzttQ0FhSyxJQUFJOzs7Ozs7OzBCQWVkLEVBQUU7dUJBV0osS0FBSztnQ0FJVyxjQUFjLENBQUMsSUFBSTtLQWtCckQ7Ozs7SUFFRCxRQUFRO1FBRUosS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBRWpCLE1BQU0sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLHdDQUF3QyxDQUFDLENBQUM7O1FBRzVFLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRWhDLElBQUksQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7U0FDeEI7UUFFRCxJQUFJLENBQUMsdUJBQXVCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUM7UUFDdkUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxLQUFxQjtZQUU1RCxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBRWpFLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztZQUNsQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDaEMsQ0FBQzs7UUFHRixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUMvRTs7Ozs7SUFHRCxnQkFBZ0IsQ0FBQyxLQUFxQjtRQUVsQyxJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUU7O1lBQ2QsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDOztZQUNqRCxJQUFJLE9BQU8sR0FBRyxTQUFTLENBQUMscUJBQXFCLEVBQUUsQ0FBQztZQUNoRCxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsS0FBSyxjQUFjLENBQUMsSUFBSSxFQUFFO2dCQUMvQyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUUvRDtpQkFBTTtnQkFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQzthQUN4QjtZQUVELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1NBQ3hCO0tBQ0o7Ozs7SUFHRCxvQkFBb0I7UUFFaEIsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7O1lBQ2hDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYTtpQkFDbkMsYUFBYSxDQUFDLHVDQUF1QyxDQUFDLENBQUM7WUFFNUQsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDaEUsVUFBVSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO2dCQUMvRSxVQUFVLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDeEMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLEdBQUcsT0FBTyxDQUFDO2FBQ3ZDO1NBQ0o7YUFBTTtZQUNILElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQztTQUN0QztLQUNKOzs7Ozs7SUFNRCxZQUFZOztRQUVSLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQzs7UUFDckUsSUFBSSxXQUFXLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3JFLElBQUksQ0FBQyxhQUFhLEdBQUcsU0FBUyxDQUFDLHFCQUFxQixFQUFFLENBQUM7UUFDdkQsSUFBSSxDQUFDLFFBQVEsR0FBRyxXQUFXLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUNwRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQztLQUNqRDs7Ozs7Ozs7OztJQVVELFFBQVEsQ0FBQyxLQUFVO1FBRWYsSUFBSSxTQUFTLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDNUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdEM7S0FDSjs7Ozs7Ozs7Ozs7OztJQWFELFVBQVUsQ0FBQyxLQUFXOztRQUVsQixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7O1FBQ2pELElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztRQUUzQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLG9CQUFvQixFQUFFLENBQUM7O1FBRzVCLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7O1FBQ3RFLElBQUksT0FBTyxHQUFHLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO1FBQ2hELElBQUksQ0FBQyxnQkFBZ0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUVqRSxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVqRSxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDcEMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7S0FDdkI7Ozs7Ozs7OztJQVNELFVBQVUsQ0FBQyxLQUFVO1FBRWpCLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ25DOzs7Ozs7Ozs7SUFTRCxXQUFXLENBQUMsS0FBVTtRQUVsQixJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7S0FDdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXdCRCxVQUFVLENBQUMsU0FBYyxFQUFFLGFBQWtCLEVBQUUsY0FBbUI7O1FBRTlELElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLGdCQUFnQixLQUFLLGNBQWMsQ0FBQyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDOztRQUN0RSxJQUFJLFNBQVMsR0FBRyxjQUFjLENBQUMsVUFBVSxDQUFDLGtCQUFrQixFQUFFLENBQUM7O1FBQy9ELElBQUksYUFBYSxHQUFHLGFBQWEsQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDO1FBQ2xELFNBQVMsQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLENBQUMsYUFBYSxJQUFJLGtCQUFrQixDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7O1FBRXBGLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDckUsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGFBQWEsRUFBRSxTQUFTLENBQUMsR0FBRyxJQUFJLENBQUM7S0FDckY7Ozs7Ozs7SUFHRCxlQUFlLENBQUMsU0FBYyxFQUFFLGFBQWtCLEVBQUUsY0FBbUI7UUFHbkUsSUFBSSxJQUFJLENBQUMsZ0JBQWdCLEtBQUssY0FBYyxDQUFDLElBQUksRUFBRTs7WUFDL0MsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUVyRSxJQUFJLENBQUMsVUFBVSxHQUFHLG1CQUFNLGVBQWUsR0FBRSxtQkFBTSxjQUFjLEdBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQztZQUN2RixJQUFJLENBQUMsVUFBVSxJQUFJLG1CQUFNLGdCQUFnQixHQUFFLG1CQUFNLGVBQWUsR0FBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO1NBRWpGO2FBQU07WUFDSCxJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztTQUN4QjtLQUNKOzs7Ozs7Ozs7O0lBUUQsZUFBZSxDQUFDLFNBQWMsRUFBRSxZQUFpQjs7UUFHN0MsSUFBSSxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsV0FBVyxDQUFDOztRQUMxRCxJQUFJLFFBQVEsR0FBRyxVQUFVLENBQUMsV0FBVyxJQUFJLEdBQUcsQ0FBQyxDQUFDOztRQUM5QyxJQUFJLEdBQUcsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDO1FBRTlCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDLEdBQUcsRUFBRTtZQUN6QyxHQUFHLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztTQUMvQjthQUFNLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUksWUFBWSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUMsRUFBRTtZQUM3RCxHQUFHLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQztTQUM1QjtRQUVELE9BQU8sR0FBRyxDQUFDO0tBQ2Q7Ozs7Ozs7OztJQVFPLGdCQUFnQixDQUFDLFlBQWlCLEVBQUUsY0FBbUI7O1FBRTNELElBQUksU0FBUyxHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUM7O1FBQ3JDLElBQUksUUFBUSxHQUFHLGNBQWMsQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUM7UUFFdkQsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssWUFBWSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQzlELFlBQVksQ0FBQyxJQUFJLEdBQUcsa0JBQWtCLENBQUMsWUFBWSxFQUN2RDtZQUNJLFNBQVMsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDO1NBRXBDO2FBQU0sSUFBSSxZQUFZLENBQUMsSUFBSSxHQUFHLGtCQUFrQixDQUFDLFlBQVksRUFBRTtZQUM1RCxTQUFTLEdBQUcsZUFBZSxDQUFDLFVBQVUsQ0FBQztTQUUxQzthQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxLQUFLLElBQUksa0JBQWtCLENBQUMsWUFBWSxFQUFFO1lBQ2hGLFNBQVMsR0FBRyxlQUFlLENBQUMsV0FBVyxDQUFDO1NBRTNDO2FBQU0sSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssWUFBWSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO1lBQ3ZFLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxZQUFZLENBQUMsS0FBSyxJQUFJLGtCQUFrQixDQUFDLFlBQVksRUFDM0U7WUFDSSxTQUFTLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQztTQUVyQzthQUFNO1lBQ0gsU0FBUyxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUM7U0FDdkM7UUFDRCxPQUFPLFNBQVMsQ0FBQzs7Ozs7Ozs7O0lBUXJCLGtCQUFrQixDQUFDLFNBQWM7UUFFN0IsU0FBUyxDQUFDLEtBQUssQ0FBQyxVQUFVLEdBQUcsUUFBUSxDQUFDO1FBQ3RDLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUVsQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7S0FDdkI7Ozs7Ozs7O0lBUUQsbUJBQW1CLENBQUMsU0FBYztRQUU5QixTQUFTLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7O0tBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFzQ08sb0JBQW9CLENBQUMsWUFBaUIsRUFBRSxTQUEwQjs7UUFHdEUsSUFBSSxjQUFjLEdBQUcsWUFBWSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7O1FBQy9DLElBQUksY0FBYyxHQUFHLFlBQVksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBRS9DLFFBQVEsU0FBUztZQUNiLEtBQUssZUFBZSxDQUFDLEtBQUs7O2dCQUN0QixJQUFJLFVBQVUsR0FBRyxZQUFZLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQzs7Z0JBQ3BELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7Z0JBQzFELE9BQU8sVUFBVSxJQUFJLFlBQVksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDLENBQUM7WUFFekQsS0FBSyxlQUFlLENBQUMsV0FBVzs7Z0JBQzVCLElBQUksV0FBVyxHQUFHLFlBQVksQ0FBQyxJQUFJLEdBQUcsY0FBYyxDQUFDOztnQkFDckQsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztnQkFDM0QsT0FBTyxXQUFXLElBQUksWUFBWSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsQ0FBQztZQUczRCxLQUFLLGVBQWUsQ0FBQyxVQUFVOztnQkFDM0IsSUFBSSxZQUFZLEdBQUcsWUFBWSxDQUFDLElBQUksR0FBRyxjQUFjLENBQUM7Z0JBQ3RELE9BQU8sWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7WUFFOUMsS0FBSyxlQUFlLENBQUMsSUFBSSxDQUFDO1lBQzFCOztnQkFDSSxJQUFJLFNBQVMsR0FBRyxZQUFZLENBQUMsSUFBSSxHQUFHLGNBQWMsQ0FBQztnQkFDbkQsT0FBTyxTQUFTLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQztTQUM5Qzs7Ozs7Ozs7OEJBaGE2QixFQUFFOzs7Ozs7O2tDQVFFLEVBQUU7O1lBckIzQyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLGVBQWU7Z0JBQ3pCLHFrREFBMEM7O2FBRTdDOzs7O1lBekdxQyxVQUFVO1lBRWhDLFdBQVc7WUFGbkIsaUJBQWlCOzs7d0JBNkhwQixLQUFLO3lCQU9MLEtBQUs7a0NBYUwsS0FBSzt3QkFNTCxTQUFTLFNBQUMsU0FBUzs7Ozs7Ozs7Ozs7O0FDdkp4Qjs7Ozs7Ozs7OztBQTJCQTs7OztJQUlJLFlBQW9CLFVBQXNCO1FBQXRCLGVBQVUsR0FBVixVQUFVLENBQVk7S0FFekM7Ozs7SUFHRCxRQUFRO1FBRUosSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQztLQUN4Qjs7OztJQUVELFdBQVc7UUFFUCxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQzNCOzs7OztJQUdELFdBQVcsQ0FBQyxPQUE0QztRQUVwRCxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxDQUFDO0tBQzFDOzs7O0lBRUQsU0FBUztRQUVMLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDM0I7Ozs7SUFFRCxrQkFBa0I7UUFFZCxJQUFJLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7S0FDcEM7Ozs7SUFFRCxxQkFBcUI7UUFHakIsSUFBSSxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO0tBQ3ZDOzs7O0lBRUQsZUFBZTtRQUVYLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUMsQ0FBQztLQUNqQzs7OztJQUVELGtCQUFrQjtRQUVkLElBQUksQ0FBQyxLQUFLLENBQUMsb0JBQW9CLENBQUMsQ0FBQztLQUNwQzs7Ozs7SUFFTyxLQUFLLENBQUMsR0FBVzs7UUFFckIsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDOztRQUNkLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDOztRQUN2QyxJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFakIsT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBVSxLQUFLLElBQUksRUFBRTtZQUMzQyxLQUFLLEVBQUUsQ0FBQztZQUNSLElBQUksT0FBTyxDQUFDLE9BQU8sS0FBSyxVQUFVLElBQUksS0FBSyxLQUFLLENBQUMsRUFBRTtnQkFDL0MsTUFBTTthQUNUO1NBQ0o7O1FBQ0QsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDOztRQUNoQixJQUFJLFlBQVksR0FBRyxLQUFLLENBQUM7UUFDekIsT0FBTyxLQUFLLEdBQUcsQ0FBQyxFQUFFO1lBQ2QsTUFBTSxJQUFJLElBQUksQ0FBQztZQUNmLEtBQUssRUFBRSxDQUFDO1NBQ1g7O1FBR0QsSUFBSSxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQ2hCLElBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRTtZQUMxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7O2dCQUMzQyxJQUFJLElBQUksR0FBUyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdkMsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRTtvQkFDdEMsU0FBUztpQkFDWjtnQkFHRCxNQUFNLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDO2FBQ3pEO1NBQ0o7UUFDRCxLQUFLLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHLFlBQVksR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLE1BQU0sR0FBRyxNQUFNLENBQUMsQ0FBQzs7Ozs7O0lBRzVFLE1BQU0sQ0FBQyxJQUFZO1FBRXZCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDeEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQzs7OztZQTNGekMsU0FBUyxTQUFDLEVBQUMsUUFBUSxFQUFFLFlBQVksRUFBQzs7OztZQW5CL0IsVUFBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1BkOzs7WUFNQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFO29CQUNWLGdCQUFnQjtpQkFDbkI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLFlBQVk7b0JBQ1oscUJBQXFCO29CQUNyQixrQkFBa0I7aUJBQ3JCO2dCQUNELGVBQWUsRUFBRTtvQkFDYixnQkFBZ0I7aUJBQ25CO2dCQUNELE9BQU8sRUFBRTtvQkFDTCxnQkFBZ0I7b0JBQ2hCLHFCQUFxQjtpQkFDeEI7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUN2QkQ7OztZQU9DLFFBQVEsU0FBQztnQkFDTixZQUFZLEVBQUU7b0JBQ1Ysa0JBQWtCO2lCQUNyQjtnQkFDRCxPQUFPLEVBQUU7b0JBQ0wsWUFBWTtvQkFDWixlQUFlO29CQUNmLG1CQUFtQjtpQkFDdEI7Z0JBQ0QsZUFBZSxFQUFFO29CQUNiLGtCQUFrQjtpQkFDckI7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLGtCQUFrQjtpQkFDckI7Z0JBQ0QsU0FBUyxFQUFFLEVBQUU7YUFDaEI7Ozs7Ozs7QUN2QkQ7Ozs7Ozs7O0FBME5BOzs7O0lBSUksT0FBTyxPQUFPO1FBRVYsT0FBTztZQUNILFFBQVEsRUFBRSxxQkFBcUI7WUFDL0IsU0FBUyxFQUFFO2dCQUNQLFlBQVk7Z0JBQ1osaUJBQWlCO2dCQUNqQixtQkFBbUI7Z0JBQ25CLGVBQWU7Z0JBQ2Ysd0JBQXdCO2dCQUN4QixhQUFhO2dCQUNiLFdBQVc7Z0JBQ1gsV0FBVztnQkFDWDtvQkFDSSxPQUFPLEVBQUUsZUFBZTtvQkFDeEIsVUFBVSxFQUFFLGtCQUFrQjtvQkFDOUIsSUFBSSxFQUFFLENBQUMsaUJBQWlCLENBQUM7b0JBQ3pCLEtBQUssRUFBRSxJQUFJO2lCQUNkO2FBQ0o7U0FDSixDQUFDO0tBQ0w7OztZQWhLSixRQUFRLFNBQUM7Z0JBQ04sT0FBTyxFQUFFO29CQUNMLGVBQWU7b0JBQ2YsWUFBWTtvQkFDWixXQUFXO29CQUNYLG1CQUFtQjtvQkFFbkIscUJBQXFCO29CQUNyQixzQkFBc0I7b0JBQ3RCLFlBQVk7b0JBQ1osb0JBQW9CO29CQUNwQixnQkFBZ0I7b0JBQ2hCLGVBQWU7b0JBQ2Ysb0JBQW9CO29CQUNwQixnQkFBZ0I7b0JBQ2hCLG1CQUFtQjtvQkFDbkIsY0FBYztvQkFDZCxnQkFBZ0I7b0JBQ2hCLHNCQUFzQjtvQkFDdEIsaUJBQWlCO29CQUNqQixrQkFBa0I7b0JBQ2xCLGtCQUFrQjtvQkFDbEIsZUFBZTtvQkFDZix3QkFBd0I7b0JBQ3hCLG1CQUFtQjtvQkFDbkIsbUJBQW1CO29CQUNuQix1QkFBdUI7b0JBQ3ZCLG9CQUFvQjtvQkFDcEIsMkJBQTJCO29CQUMzQixlQUFlO29CQUNmLGVBQWU7b0JBQ2YsbUJBQW1CO29CQUNuQixnQkFBZ0I7b0JBQ2hCLGlCQUFpQjtvQkFDakIsY0FBYztvQkFDZCxpQkFBaUI7b0JBQ2pCLFlBQVk7b0JBQ1osa0JBQWtCO29CQUNsQixvQkFBb0I7b0JBQ3BCLGtCQUFrQjtvQkFHbEIsV0FBVztvQkFDWCxZQUFZO29CQUNaLGFBQWE7b0JBQ2JELGlCQUFlO29CQUNmLG1CQUFtQjtvQkFDbkIsa0JBQWtCO29CQUNsQixjQUFjO29CQUNkLGNBQWM7b0JBQ2QsY0FBYztvQkFDZCxpQkFBaUI7b0JBQ2pCLFlBQVk7b0JBQ1pFLGNBQVk7b0JBQ1osVUFBVTtvQkFDVixhQUFhO29CQUNiLGVBQWU7b0JBQ2YsWUFBWTtvQkFDWixlQUFlO29CQUNmLGVBQWU7b0JBQ2Ysa0JBQWtCO29CQUNsQixVQUFVO2lCQUViO2dCQUNELFlBQVksRUFBRTtvQkFDViwwQkFBMEI7aUJBRTdCO2dCQUNELFNBQVMsRUFBRSxFQUFFO2dCQUNiLGVBQWUsRUFBRTtvQkFHYixRQUFRO29CQUNSLE1BQU07aUJBQ1Q7Z0JBQ0QsT0FBTyxFQUFFO29CQUNMLG1CQUFtQjtvQkFDbkIsV0FBVztvQkFDWCwwQkFBMEI7b0JBQzFCLHFCQUFxQjtvQkFDckIsc0JBQXNCO29CQUN0QixZQUFZO29CQUNaLG9CQUFvQjtvQkFDcEIsZ0JBQWdCO29CQUNoQixlQUFlO29CQUNmLG9CQUFvQjtvQkFDcEIsZ0JBQWdCO29CQUNoQixtQkFBbUI7b0JBQ25CLGNBQWM7b0JBQ2QsZ0JBQWdCO29CQUNoQixzQkFBc0I7b0JBQ3RCLGlCQUFpQjtvQkFDakIsa0JBQWtCO29CQUNsQixrQkFBa0I7b0JBQ2xCLGVBQWU7b0JBQ2Ysd0JBQXdCO29CQUN4QixtQkFBbUI7b0JBQ25CLG1CQUFtQjtvQkFDbkIsdUJBQXVCO29CQUN2QixvQkFBb0I7b0JBQ3BCLDJCQUEyQjtvQkFDM0IsZUFBZTtvQkFDZixlQUFlO29CQUNmLG1CQUFtQjtvQkFDbkIsZ0JBQWdCO29CQUNoQixpQkFBaUI7b0JBQ2pCLHFCQUFxQjtvQkFDckIsY0FBYztvQkFDZCxpQkFBaUI7b0JBQ2pCLFlBQVk7b0JBQ1osa0JBQWtCO29CQUNsQixvQkFBb0I7b0JBQ3BCLGtCQUFrQjtvQkFHbEIsWUFBWTtvQkFDWixXQUFXO29CQUNYLFlBQVk7b0JBQ1osYUFBYTtvQkFDYkYsaUJBQWU7b0JBQ2YsbUJBQW1CO29CQUNuQixrQkFBa0I7b0JBQ2xCLGNBQWM7b0JBQ2QsY0FBYztvQkFDZCxjQUFjO29CQUNkLGlCQUFpQjtvQkFDakJFLGNBQVk7b0JBQ1osVUFBVTtvQkFDVixhQUFhO29CQUNiLFlBQVk7b0JBQ1osZUFBZTtvQkFDZixlQUFlO29CQUNmLGtCQUFrQjtpQkFDckI7YUFDSjs7Ozs7O0FBNkJELDRCQUFtQyxZQUErQjtJQUU5RCxPQUFPLFlBQVksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQztDQUNqRTs7Ozs7O0FDelBEOzs7Ozs7Ozs7O0FBeUJBOzs7O0lBR0ksT0FBTyxPQUFPO1FBQ1YsT0FBTztZQUNILFFBQVEsRUFBRSxpQ0FBaUM7WUFDM0MsU0FBUyxFQUFFO2dCQUNQLFlBQVk7Z0JBQ1osaUJBQWlCO2dCQUNqQixtQkFBbUI7Z0JBQ25CLGVBQWU7Z0JBQ2Ysd0JBQXdCO2dCQUN4QixhQUFhO2dCQUNiLFdBQVc7Z0JBQ1gsV0FBVztnQkFDWDtvQkFDSSxPQUFPLEVBQUUsZUFBZTtvQkFDeEIsVUFBVSxFQUFFQyxvQkFBa0I7b0JBQzlCLElBQUksRUFBRSxDQUFDLGlCQUFpQixDQUFDO29CQUN6QixLQUFLLEVBQUUsSUFBSTtpQkFDZDthQUNKO1NBQ0osQ0FBQztLQUNMOzs7WUExQkosUUFBUSxTQUFDO2dCQUNOLE9BQU8sRUFBRSxFQUFFO2FBQ2Q7Ozs7OztBQTJCRCw4QkFBbUMsWUFBK0I7SUFDOUQsT0FBTyxZQUFZLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUM7Q0FDakU7Ozs7Ozs7Ozs7Ozs7OyJ9