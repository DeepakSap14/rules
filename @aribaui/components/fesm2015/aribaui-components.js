import { Directive, Input, ViewContainerRef, Component, ElementRef, Renderer2, forwardRef, Inject, Optional, SkipSelf, Injectable, ChangeDetectorRef, ComponentFactoryResolver, ViewChild, Pipe, EventEmitter, Output, NgZone, NgModule, InjectionToken, HostBinding, ContentChild, ContentChildren, ViewEncapsulation, ChangeDetectionStrategy, Injector, PLATFORM_ID, APP_INITIALIZER } from '@angular/core';
import { isPresent, isBlank, MapWrapper, AppConfig, Environment, noop, uuid, isStringMap, assert, StringWrapper, isType, objectToName, FieldPath, isArray, isString, isFunction, isJsObject, objectValues, unimplemented, ListWrapper, isBoolean, equals, isDate, isEntity, RoutingService, AribaCoreModule, BooleanWrapper, print } from '@aribaui/core';
import { FormControl, FormGroup, Validators, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';
import { DomSanitizer } from '@angular/platform-browser';
import { CurrencyPipe, CommonModule, DecimalPipe, isPlatformBrowser } from '@angular/common';
import { BehaviorSubject, of, Subject } from 'rxjs';
import { InputTextModule } from 'primeng/components/inputtext/inputtext';
import { distinctUntilChanged, debounceTime, switchMap } from 'rxjs/operators';
import { ButtonModule, ToolbarModule, CheckboxModule, AutoComplete, AutoCompleteModule, DropdownModule, InputTextModule as InputTextModule$1, CalendarModule, DialogModule, RadioButtonModule, InputTextareaModule, EditorModule, AccordionTab, AccordionModule, SharedModule, DomHandler, Listbox, ListboxModule, OverlayPanel, TreeDragDropService, ConfirmationService, Header, Footer, PrimeTemplate, Column, Row, HeaderColumnGroup, FooterColumnGroup, Accordion, AUTOCOMPLETE_VALUE_ACCESSOR, BlockUI, BlockUIModule, Breadcrumb, BreadcrumbModule, ButtonDirective, Button, Captcha, CaptchaModule, CALENDAR_VALUE_ACCESSOR, Calendar, Card, CardModule, Carousel, CarouselModule, UIChart, ChartModule, CHECKBOX_VALUE_ACCESSOR, Checkbox, CHIPS_VALUE_ACCESSOR, Chips, ChipsModule, CodeHighlighter, CodeHighlighterModule, COLORPICKER_VALUE_ACCESSOR, ColorPicker, ColorPickerModule, ConfirmDialog, ConfirmDialogModule, ContextMenuSub, ContextMenu, ContextMenuModule, DataGrid, DataGridModule, DataList, DataListModule, DataScroller, DataScrollerModule, DTRadioButton, DTCheckbox, ColumnHeaders, ColumnFooters, TableBody, ScrollableView, DataTable, DataTableModule, DeferredLoader, DeferModule, Dialog, Draggable, Droppable, DragDropModule, DROPDOWN_VALUE_ACCESSOR, Dropdown, EDITOR_VALUE_ACCESSOR, Editor, Fieldset, FieldsetModule, FileUpload, FileUploadModule, Galleria, GalleriaModule, GMap, GMapModule, Growl, GrowlModule, InplaceDisplay, InplaceContent, Inplace, InplaceModule, INPUTMASK_VALUE_ACCESSOR, InputMask, InputMaskModule, INPUTSWITCH_VALUE_ACCESSOR, InputSwitch, InputSwitchModule, InputText, InputTextarea, KEYFILTER_VALIDATOR, KeyFilter, KeyFilterModule, Lightbox, LightboxModule, LISTBOX_VALUE_ACCESSOR, MegaMenu, MegaMenuModule, MenuItemContent, Menu, MenuModule, MenubarSub, Menubar, MenubarModule, Messages, MessagesModule, UIMessage, MessageModule, MULTISELECT_VALUE_ACCESSOR, MultiSelect, MultiSelectModule, OrderList, OrderListModule, OrganizationChartNode, OrganizationChart, OrganizationChartModule, OverlayPanelModule, Paginator, PaginatorModule, Panel, PanelModule, BasePanelMenuItem, PanelMenuSub, PanelMenu, PanelMenuModule, Password, PasswordModule, PickList, PickListModule, ProgressBar, ProgressBarModule, ProgressSpinner, ProgressSpinnerModule, RADIO_VALUE_ACCESSOR, RadioButton, RATING_VALUE_ACCESSOR, Rating, RatingModule, Schedule, ScheduleModule, ScrollPanel, ScrollPanelModule, SELECTBUTTON_VALUE_ACCESSOR, SelectButton, SelectButtonModule, SlideMenuSub, SlideMenu, SlideMenuModule, SLIDER_VALUE_ACCESSOR, Slider, SliderModule, Sidebar, SidebarModule, SPINNER_VALUE_ACCESSOR, Spinner, SpinnerModule, SplitButton, SplitButtonModule, Steps, StepsModule, TabViewNav, TabPanel, TabView, TabViewModule, TabMenu, TabMenuModule, Terminal, TerminalModule, TieredMenuSub, TieredMenu, TieredMenuModule, TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButton, ToggleButtonModule, Toolbar, Tooltip, TooltipModule, UITreeNode, Tree, TreeModule, TreeTableService, TreeTable, TTBody, TTScrollableView, TTSortableColumn, TTSortIcon, TTResizableColumn, TTReorderableColumn, TTSelectableRow, TTSelectableRowDblClick, TTContextMenuRow, TTCheckbox, TTHeaderCheckbox, TTEditableColumn, TreeTableCellEditor, TreeTableToggler, TreeTableModule, TRISTATECHECKBOX_VALUE_ACCESSOR, TriStateCheckbox, TriStateCheckboxModule } from 'primeng/primeng';
import { animate, AnimationBuilder, state, style, transition, trigger } from '@angular/animations';
import { RouterModule } from '@angular/router';
import { ObjectUtils } from 'primeng/components/utils/objectutils';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * When we have a custom component like dropdown, radiobuttonlist and
 * many more we want to provide a custom content to it like so:
 *
 * ```
 *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
 *      {{item.userName}}
 *
 *   <aw-dropdown
 *
 * ```
 * Who else would know how to render list of objects..
 *
 * But its not possible in current form. if I do not provide Angular some as they call it this
 * syntactic sugar *,
 *
 *
 * ```
 *  <aw-dropdown *mySugerDirective=.....>
 *      {{item.userName}}
 *
 *   <aw-dropdown
 * ```
 *
 *
 * then angular will not know  inside is a template and I wont be able to get hold of TemplateRef
 * inside the component
 *
 * So the only way I found (expecting I do not want to change anything in terms of bindings and the
 * signature I use it. I have to use it like this:
 *
 * ```
 *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
 *      <ng-template let-item> {{item.userName}}</ng-template>
 *
 *   <aw-dropdown
 *
 * ```
 *
 *  This way it could work. Since I am inside ngFor I want to render the item into the correct
 * viewContainer of ngFor's current item.
 *
 *  This way I can also expose item outside using Angular's special local variable called:
 * $implicit.
 *
 * This gets even more complex if we try to pass this template 2 levels down, like in case of
 * RadioButtonList. But later on I might want to refactor this into custom NG FOR
 *
 * @deprecated in favor of ngTemplateOutlet (will be removed in the next version)
 *
 */
class EmbeddedItemDirective {
    /**
     * @param {?} _viewContainer
     */
    constructor(_viewContainer) {
        this._viewContainer = _viewContainer;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    set item(item) {
        this._implicitValue = item;
    }
    /**
     *
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (isPresent(this._viewRef)) {
            this._viewContainer.remove(this._viewContainer.indexOf(this._viewRef));
        }
        if (isPresent(this.embeddedItem)) {
            let /** @type {?} */ context = new EmbededItem(this._implicitValue);
            this._viewRef = this._viewContainer.createEmbeddedView(this.embeddedItem, context);
        }
    }
}
EmbeddedItemDirective.decorators = [
    { type: Directive, args: [{ selector: '[embeddedItem]' },] },
];
/** @nocollapse */
EmbeddedItemDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
EmbeddedItemDirective.propDecorators = {
    embeddedItem: [{ type: Input }],
    item: [{ type: Input }]
};
/**
 * Wrapper class around Angular's EmbeddedViewRef.context()
 *
 */
class EmbededItem {
    /**
     * @param {?} $implicit
     */
    constructor($implicit) {
        this.$implicit = $implicit;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * GenericContainerComponent is used by include-component.directive to dynamically create an
 * HTMLElement and use this element to wrap a child component. This is very useful when we want to
 * modify a child by wrapping it with a border, a background, or bold its text.
 *
 * The wrapper element is dynamically created. It's element is specified by the tagName property in
 * the bindings \@Input.
 *
 *  ### Example.  Directly in html
 *
 *   app.html
 *      <aw-generic-container tagName="tagName" bindings="bindings">
 *          <my-component ..bindings..></my-component>
 *      </aw-generic-container>
 *
 *   app.component.ts
 *
 *       tagName = (bBold) ? 'h1' : 'span';
 *       bindings = {  style: 'background-color: red' }
 *
 */
class GenericContainerComponent {
    /**
     * param renderer - Renderer is used to create 'tagName' element.
     * @param {?} renderer
     * @param {?} element
     */
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.nativeElement = element.nativeElement;
    }
    /**
     * During the initialization, verify that at least one input has been set.
     * @return {?}
     */
    ngOnInit() {
        // If there's no input, this component wouldn't know what to do and throw exception.
        if (isBlank(this.bindings) && isBlank(this.tagName)) {
            throw new Error('GenericContainerComponent input bindings or tagName ' +
                'have not been set.');
        }
        // If the tagName is blank, the get it from bindings.
        if (isBlank(this.tagName)) {
            this.tagName = this.bindings.get('tagName');
            if (isBlank(this.tagName)) {
                this.tagName = GenericContainerComponent.DefaultTagName;
            }
        }
        // Save first added
        this.childElement = this.nativeElement.firstChild;
        this.doRender();
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        if (isPresent(this.childElement) &&
            this.childElement.parentNode !== this.nativeElement.firstChild) {
            this.nativeElement.firstChild.appendChild(this.childElement);
        }
    }
    /**
     * After content has been initialized. Create the tagName element. Apply all the bindings on to
     * the element as attribute. Finally, move the child element, <ng-content>, to inside the
     * wrapper component.
     * @return {?}
     */
    doRender() {
        const /** @type {?} */ el = this.renderer.createElement(this.tagName);
        if (isPresent(this.nativeElement)) {
            this.renderer.appendChild(this.nativeElement, el);
        }
        // Loop through all the bindings and add them to the element.
        MapWrapper.iterable(this.bindings).forEach((v, k) => {
            this.renderer.setStyle(el, k, v);
        });
        // Attach the component to this divElement.
        el.appendChild(this.childElement);
    }
}
/**
 * Default tagName if none is specified inside bindings.
 *
 */
GenericContainerComponent.DefaultTagName = 'div';
GenericContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-generic-container',
                template: '<ng-content></ng-content>',
                styles: []
            },] },
];
/** @nocollapse */
GenericContainerComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
GenericContainerComponent.propDecorators = {
    bindings: [{ type: Input }],
    tagName: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  Base component shares common functionality among all the components (layouts, widgets).
 *
 * @abstract
 */
class BaseComponent {
    /**
     * @param {?=} env
     */
    constructor(env) {
        this.env = env;
        /**
         * Adds disabled flag to the component
         *
         */
        this.disabled = false;
        /**
         * Weather this component is visible
         * Default is false;
         */
        this.visible = false;
        /**
         * Tell  the component if we are in editing mode.
         *
         */
        this.editable = true;
        /**
         * Removes padding from the component. Usually used when we are nesting other component with
         * its own grid.
         */
        this.omitPadding = false;
        /**
         * Prefix for the correct asset path
         */
        this.assetFolder = 'assets';
        this.extBindings = new Map();
        this.omitPadding = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.assetFolder = this.env.getValue(AppConfig.AssetFolder);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
}
BaseComponent.propDecorators = {
    disabled: [{ type: Input }],
    visible: [{ type: Input }],
    editable: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    styleClass: [{ type: Input }],
    omitPadding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const WidgetSizeColumns = {
    xsmall: 1,
    small: 3,
    medium: 6,
    large: 9,
    xlarge: 12,
};
WidgetSizeColumns[WidgetSizeColumns.xsmall] = "xsmall";
WidgetSizeColumns[WidgetSizeColumns.small] = "small";
WidgetSizeColumns[WidgetSizeColumns.medium] = "medium";
WidgetSizeColumns[WidgetSizeColumns.large] = "large";
WidgetSizeColumns[WidgetSizeColumns.xlarge] = "xlarge";
/**
 *  BaseFormComponnet extends BaseComponent for add specific form behavior
 *
 * @abstract
 */
class BaseFormComponent extends BaseComponent {
    /**
     * Some of the BaseFormComponent can wrap other component and in these cases we want to
     * inherit some of the behavior from parent
     *
     * \@Inject(Environment) public env: Environment : is tem a workaround as without inject
     * on this specific component it complains that Environment is unresolved symbol
     *
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * Is current element visible
         */
        this.hidden = false;
        /**
         * Renders required flex around the component
         *
         */
        this.required = false;
        /**
         *  a text displayed when value is empty or NULL
         */
        this.placeHolder = '';
        /**
         * Identify if this control is used directly or if its part of some other control
         * e.g. GenericChooser and managed by this control.
         * Meaning State is mananged outside of this component
         *
         */
        this.isStandalone = true;
        this.onModelChanged = noop;
        this.onModelTouched = noop;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isPresent(this.parentContainer)) {
            this.formGroup = this.parentContainer.formGroup;
            this.editable = this.parentContainer.editable;
        }
        this.checkInitForm();
    }
    /**
     * Make sure that we have available formGroup and Name and ID
     *
     * @return {?}
     */
    checkInitForm() {
        if (isBlank(this.env.currentForm)) {
            this.env.currentForm = new FormGroup({});
        }
        /**
                 * Todo: Right now I just need to initialize name , but ideally it needs to be generated
                 * number basedon some semantics app.page.component if there are more component on the page
                 * then app.page.componentNumber. Simple solution is to is to get Elementref and query it.
                 */
        if (isBlank(this.name)) {
            this.name = uuid();
        }
        if (isBlank(this.id)) {
            this.id = uuid();
        }
    }
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    doRegister(name, value) {
        let /** @type {?} */ fControl;
        if (isBlank(this.formGroup.controls[name])) {
            this.formGroup.registerControl(name, new FormControl(value));
            fControl = /** @type {?} */ (this.formGroup.controls[name]);
        }
        else {
            fControl = /** @type {?} */ (this.formGroup.controls[name]);
            let /** @type {?} */ updatedValue = isPresent(fControl.value) ? fControl.value : value;
            fControl.patchValue(updatedValue, { onlySelf: true, emitEvent: false });
        }
        return fControl;
    }
    /**
     * When we are dealing with Forms this is a helper method to register control
     *
     *
     * @param {?} value default value to be pre-set
     * @return {?}
     */
    registerFormControl(value) {
        this.formControl = this.doRegister(this.name, value);
        if (this.disabled) {
            this.formControl.disable();
        }
    }
    /**
     * @return {?}
     */
    get formGroup() {
        return isPresent(this._formGroup) ? this._formGroup : this.env.currentForm;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set formGroup(value) {
        this._formGroup = value;
    }
    /**
     * Indicates if we can pass field type as a binding to the components. e.g. InputField need
     * such type to correctly render input type=text, number
     *
     * todo: is this needed? can we maybe pass this to the formRow?
     * @return {?}
     */
    canSetType() {
        return false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChanged = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
}
/*
     *  Supported layout constants. It is expected there will be more options as we currently
     *  support only these two there will be other variations of it. e.g. for stacked it will not
     *  be 1 columns like it is now but multiple columns
     *
     */
BaseFormComponent.LayoutStacked = 'stacked';
BaseFormComponent.LayoutInline = 'inline';
/** @nocollapse */
BaseFormComponent.ctorParameters = () => [
    { type: Environment, decorators: [{ type: Inject, args: [Environment,] }] },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
BaseFormComponent.propDecorators = {
    name: [{ type: Input }],
    id: [{ type: Input }],
    hidden: [{ type: Input }],
    required: [{ type: Input }],
    placeHolder: [{ type: Input }],
    isStandalone: [{ type: Input }],
    formGroup: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Simple component rendering values in the read only mode. Just needed some component used
 * to render Strings in read only mode
 *
 *
 *  ### Example
 *
 * Using it inside form container along with label
 *
 *
 *  ```
 * \@Component({
 *              selector: 'userInfo' ,
 *              template: `
 *                      <aw-form-table [editable]="false" >
 *                          <aw-form-row [name]="fieldName"  [label]="label">
 *                                 <aw-string [value]="inputValue" ></aw-string>
 *                           </aw-form-row>
 *                      </aw-form-table>
 *
 *                  `
 *          })
 *          export class UserProfileComponent
 *          {
 *              inputValue: string = 'Some text';
 *              inputType: string = 'string';
 *              fieldName: string = 'firstName';
 *              label: string = 'My Name';
 *              required: boolean = true;
 *              editing: boolean = true;
 *              labelsOnTop: boolean = false;
 *
 *          }
 *
 *  ```
 *
 * You can also pass html tags.
 *
 */
class StringComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} sanitizer
     * @param {?} parentContainer
     */
    constructor(env, sanitizer, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.sanitizer = sanitizer;
        this.parentContainer = parentContainer;
        /**
         *  Value to be interpolated
         *
         */
        this._value = '';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        this._value = value;
    }
    /**
     * @return {?}
     */
    get value() {
        return this.sanitizer.bypassSecurityTrustHtml(this._value);
    }
}
StringComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-string',
                template: `
        <span class="w-string-field" [innerHTML]="value"></span>
    `,
                styles: [`.w-string-field{display:inline-block}`]
            },] },
];
/** @nocollapse */
StringComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomSanitizer },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
StringComponent.propDecorators = {
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A class holding a references to components. The methods are self-explanatory.
 *
 */
class ComponentRegistry {
    /**
     * @param {?} env
     */
    constructor(env) {
        this.env = env;
        this._nameToType = new Map();
    }
    /**
     * @param {?} references
     * @return {?}
     */
    initialize(references) {
        this.registerTypes(references);
        let /** @type {?} */ promise = new Promise((resolve) => {
            resolve(true);
        });
        return promise;
    }
    /**
     * @param {?} name
     * @param {?} type
     * @return {?}
     */
    registerType(name, type) {
        if (!this.nameToType.has(name)) {
            this._nameToType.set(name, type);
        }
    }
    /**
     * @param {?} references
     * @return {?}
     */
    registerTypes(references) {
        if (!isStringMap(references)) {
            return;
        }
        Object.keys(references).forEach((name) => {
            this.registerType(name, references[name]);
        });
    }
    /**
     * @return {?}
     */
    get nameToType() {
        return this._nameToType;
    }
}
ComponentRegistry.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ComponentRegistry.ctorParameters = () => [
    { type: Environment }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  `IncludeComponent` directive dynamically instantiate and insert a components into the screen
 * based on the name. It can accepts bindings as well which will be automatically bound and applied
 * to the component
 *
 *  ### usage:
 *
 *  Instead of inserting component in the way:
 *
 *  ```
 *    <textfield value="some value">
 *
 *  ```
 *
 *  you can do so dynamically like this:
 *
 * ```
 *  <aw-include-component 'TextfieldComponent' [bindings]=bindings ></aw-include-component>
 * ```
 *
 * This is the main building block to dynamically generated UI.
 *
 *
 * Todo: Currently the way Angular API work and we use it to create programatically components
 * is too complext we need to create everything 3 different calls to place a component to the
 * container. What I want is is to create some kind of representation of ContainerElement and this
 * can be also parent for our BaseComponent with method add and remove content. Then we could have
 * some AWContent.
 *
 * e.g.: to replace applyContentElementIfAny where we have several calls to create and add
 * component to the view.
 *
 * ```ts
 *  let containerElement = AWConcreteTemplate(viewContainer, factoryResolver)
 *  containerElement.add('Clck Me')
 * ```
 *
 * To assemble different components together - not only adding string content
 *
 * ```ts
 *  let content = new AWContent(ButtonComponent, bindingsMap)
 *  content.add('Click Me');
 *  containerElement.add(content)
 *
 * ```
 *
 * add more component hierarchy:
 *
 * ```ts
 *  let content = new AWContent(HoverCardComponnets, bindingsMap)
 *  content.add(createLayout();
 *  containerElement.add(content)
 *
 * ```
 *
 *
 *
 *
 */
class IncludeComponentDirective {
    /**
     * @param {?} viewContainer
     * @param {?} factoryResolver
     * @param {?} cd
     * @param {?} compRegistry
     */
    constructor(viewContainer, factoryResolver, cd, compRegistry) {
        this.viewContainer = viewContainer;
        this.factoryResolver = factoryResolver;
        this.cd = cd;
        this.compRegistry = compRegistry;
        /**
         * I use this flag to identify that component is rendering for first time or its updated during
         * change detection
         *
         */
        this.initRenderInProgress = false;
        /**
         * Not sure if we need this, but want to keep it here or maybe move it to some service so we
         * can cache created components and maybe reuse them.
         *
         */
        this.componentReferences = new Map();
        this.bindings = new Map();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initRenderInProgress = true;
        // todo: check if this the right lifecycle callback, this is called only once and you want
        // to probably listen for changes, and change dection decide there is some change and we
        // need to re-draw the view
        this.viewContainer.clear();
        this.doRenderComponent();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (isPresent(changes['name']) &&
            (changes['name'].currentValue !== changes['name'].previousValue)) {
            this.viewContainer.clear();
            this.doRenderComponent();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.initRenderInProgress = false;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // check to see if we need to render and reposition DOM element both for wrapper and
        // content
        this.createWrapperElementIfAny();
        this.createContentElementIfAny();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * Handles a case where we need to resolve additional component and wrap the current one.
     * Just like reateContentElementIfAny() this method needs to be executed after all
     * is created and initialized (inside the ngAfterViewInit() )
     *
     * @return {?}
     */
    createWrapperElementIfAny() {
    }
    /**
     * Renders a component into actual View Container. The process goes as this.
     *  1. We retrieve component Type based on the component name, which creates componentRef
     *  2. Place the component onto the screen
     *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
     *  4. Manually spin change detection to update the screen. Mainly for case where I need to
     * redraw a screen
     * @return {?}
     */
    doRenderComponent() {
        this.placeTheComponent();
        // this.currentComponent.changeDetectorRef.detach();
        this.applyBindings(this.componentReference(), this.currentComponent, this.bindings);
        // this.currentComponent.changeDetectorRef.detectChanges();
        // Still not sure about this what all I should release here.
        this.currentComponent.onDestroy(() => {
            // this.bindings.clear();
            // this.bindings = undefined;
            //
            // this.componentReferences.clear();
            // this.componentReferences = undefined;
            this.destroy();
        });
    }
    /**
     * Place actual component onto the screen using ViewContainerRef
     *
     * @return {?}
     */
    placeTheComponent() {
        let /** @type {?} */ reference = this.componentReference();
        this.currentComponent = this.viewContainer.createComponent(reference.resolvedCompFactory);
    }
    /**
     * When inserting Component that needs to have a content like e.g. hyperlink or button
     *
     * ```
     *   <button> MY NG CONTENT </button>
     *
     * ```
     *  this method applies and insert a child content into the main component. This method insert
     * a simple string. We are not wrapping existing component with another component here.
     *
     * @return {?} need to run detect changes ? default is false
     */
    createContentElementIfAny() {
        let /** @type {?} */ detectChanges = false;
        let /** @type {?} */ ngContent = this.ngContent();
        let /** @type {?} */ ngContentElement = this.ngContentElement();
        if (isPresent(ngContent)) {
            let /** @type {?} */ awContentComponent = this.factoryResolver.resolveComponentFactory(StringComponent);
            let /** @type {?} */ component = this.viewContainer.createComponent(awContentComponent, 0);
            (/** @type {?} */ (component.instance)).value = ngContent;
            let /** @type {?} */ awContentContainer = this.currentComponent.location.nativeElement.firstChild;
            awContentContainer.appendChild(component.location.nativeElement);
            detectChanges = true;
        }
        else if (isPresent(ngContentElement)) ;
        return detectChanges;
    }
    /**
     *
     * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
     * applying other bindings.
     *
     * @return {?}
     */
    ngContent() {
        let /** @type {?} */ content;
        if (isPresent(content = this.bindings.get(IncludeComponentDirective.NgContent))) {
            this.bindings.delete(IncludeComponentDirective.NgContent);
        }
        return content;
    }
    /**
     * @return {?}
     */
    ngContentElement() {
        let /** @type {?} */ content;
        if (isPresent(content = this.bindings.get(IncludeComponentDirective.NgContentElement))) {
            this.bindings.delete(IncludeComponentDirective.NgContentElement);
        }
        return content;
    }
    /**
     * We need to convert a component name to actual a type and then use ComponentFactoryResolver
     * to instantiate a a component and save its information into our component references. The
     * reason why we have this component reference is we need to store Angular's component metadata
     * so we can iterate thru all the inputs and bind them to the context.
     *
     * returns {ComponentReference} a reference representing a compoent currently being rendered
     * @return {?}
     */
    componentReference() {
        if (isPresent(this.resolvedComponentRef)) {
            return this.resolvedComponentRef;
        }
        let /** @type {?} */ currType = this.resolveComponentType();
        let /** @type {?} */ componentFactory = this.factoryResolver
            .resolveComponentFactory(currType);
        let /** @type {?} */ componentMeta = this.resolveDirective(componentFactory);
        let /** @type {?} */ compReference = {
            metadata: componentMeta,
            resolvedCompFactory: componentFactory,
            componentType: currType,
            componentName: this.name
        };
        this.resolvedComponentRef = compReference;
        return compReference;
    }
    /**
     * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
     * 'this.bindings'
     * @param {?} cRef
     * @param {?} component
     * @param {?} bindings
     * @return {?}
     */
    applyBindings(cRef, component, bindings) {
        let /** @type {?} */ inputs = cRef.metadata.inputs;
        if (isBlank(inputs) || inputs.length === 0) {
            return;
        }
        // should we do any type conversion?
        MapWrapper.iterable(bindings).forEach((v, k) => {
            if (isPresent(component.instance[k])) {
                component.instance[k] = v;
            }
        });
    }
    /**
     * Resolves a component Type based on the string literal
     *
     * @return {?} component type used by `ComponentFactoryResolver`
     *
     * todo: rename the method so its clear that it returns component type based on string.
     */
    resolveComponentType() {
        let /** @type {?} */ componentType = this.compRegistry.nameToType.get(this.name);
        if (isBlank(componentType)) {
            assert(false, this.name + ' component does not exists. Create Dummy Component instead' +
                ' of throwing this error');
            return;
        }
        return componentType;
    }
    /**
     * @param {?} compFactory
     * @return {?}
     */
    resolveDirective(compFactory) {
        let /** @type {?} */ compMeta = {
            inputs: [],
            outputs: []
        };
        if (isPresent(compFactory.inputs) && compFactory.inputs.length > 0) {
            compFactory.inputs.forEach((input) => {
                compMeta.inputs.push(input.propName);
            });
        }
        if (isPresent(compFactory.outputs) && compFactory.outputs.length > 0) {
            compFactory.outputs.forEach((output) => {
                compMeta.outputs.push(output.propName);
            });
        }
        return compMeta;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (isPresent(this.currentComponent)) {
            this.currentComponent.destroy();
            this.currentComponent = undefined;
        }
        if (isPresent(this.viewContainer)) {
            this.viewContainer.clear();
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        if (isPresent(this.currentComponent)) {
            this.currentComponent = null;
            this.resolvedComponentRef = null;
        }
    }
}
IncludeComponentDirective.NgContent = 'ngcontent';
IncludeComponentDirective.NgContentElement = 'ngcontentElement';
IncludeComponentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'aw-include-component'
            },] },
];
/** @nocollapse */
IncludeComponentDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef },
    { type: ComponentRegistry }
];
IncludeComponentDirective.propDecorators = {
    name: [{ type: Input }],
    bindings: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Error Manager is a service used by Forms components to map error codes into meaningful messages.
 * Currently it does not have much but once we plug in localization it will make more sense
 *
 *
 * todo: Once ng-translate is implemented replace this with ng-translate functionality so we can
 * externalize these messages into locale files.
 *
 */
class ErrorManagerService {
    constructor() {
        this.messages = {
            'required': 'Required field',
            'minlength': 'Field does not meet minimum length',
            'maxlength': 'Field does not meet maximum length',
            'customMsg': '%s',
            'metavalid': '%s'
        };
    }
    /**
     * @param {?} validatorName
     * @param {?=} validatorValue
     * @return {?}
     */
    errorMessage(validatorName, validatorValue) {
        let /** @type {?} */ message = this.messages[validatorName];
        if (StringWrapper.contains(message, '%s')) {
            // todo: use ng-translate with proper message formatting
            return StringWrapper.replace(message, '%s', validatorValue.msg);
        }
        return message;
    }
}
ErrorManagerService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ErrorManagerService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * ErrorMessagesComponent is used by form's component like FormRow to print its validation errors.
 * Its  based on ModelDriven (Reactive forms) and it reads errors from FormControl
 *
 *
 *
 */
class ErrorMessagesComponent {
    /**
     * @param {?} errManager
     */
    constructor(errManager) {
        this.errManager = errManager;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    hasMessage() {
        let /** @type {?} */ msg = this.errorMsg;
        return isPresent(msg);
    }
    /**
     * Retrieve a messages if any registered by added validators
     *
     * @return {?}
     */
    get errorMsg() {
        for (let /** @type {?} */ propertyName in this.control.errors) {
            if (this.control.errors.hasOwnProperty(propertyName) && this.control.touched) {
                return this.errManager.errorMessage(propertyName, this.control.errors[propertyName]);
            }
        }
    }
    /**
     *
     * Show errors? We currently shows errors if the control is not valid, it was touched by user.
     * Most of the type on blur event  and at last its not pristine anymore (its dirty)
     *
     * @return {?}
     */
    showErrors() {
        return !this.control.valid && !this.control.pristine && this.control.touched;
    }
}
ErrorMessagesComponent.decorators = [
    { type: Component, args: [{
                selector: 'a-error-messages',
                template: `
            <div class="ui-g">
                    <small *ngIf="hasMessage()"
                        class="ui-g-12 ui-message ui-messages-error ui-corner-all">
                        {{ errorMsg }}
                    </small>
            </div>
    `,
                styles: [``]
            },] },
];
/** @nocollapse */
ErrorMessagesComponent.ctorParameters = () => [
    { type: ErrorManagerService }
];
ErrorMessagesComponent.propDecorators = {
    control: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Modal service is used to to create modal dialogs. It creates modal dialogs dynamically.
 * The service also keeps track of the created modal dialog and can close it by calling the
 * service's close()
 *
 * Modal service requires a ViewContainer to insert newly created modals. This is taken care
 * by the ModalComponent.
 *
 * Usage:
 *     Add   <aw-modal></aw-modal>  into your application main html. It needs to be on every
 *     page where a modal dialog will appear.
 *
 *    1.  Popup a dialog without creating your own component.
 *        Use the existing DialogComponent in widgets.
 *
 *             this.modalService.open<DialogComponent>(DialogComponent, {
 *                     title: 'My Popup Title',
 *                     body: 'My Popup Body'
 *              });
 *
 *
 *   2.   Creating your own Dialog Component to popup.
 *
 *         let componentRef = this.modalService.open<MyDialogComponent>(MyDialogComponent,
 * {inputs});
 *
 * \@Component({
 *                selector: 'aw-mydialog' ,
 *                           template: `
 *                                         <aw-dialog (onClose)="closePopup()">
 *                                              <ng-template #titleTemplate>
 *                                                 <span><i class="fa fa-envira" ></i>This is my
 *     Title </span>
 *                                              </ng-template>
 *                                              <ng-template #bodyTemplate>
 *                                                 <span><i class="fa fa-envira" ></i>This is my
 *     Body </span>
 *                                              </ng-template>
 *                                        </aw-dialog>
 *                                     `
 *         })
 *         export class MyDialogComponent extends DialogComponent implements OnInit {
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     closePopup() {
 *                            this.modalService.close();
 *                      }
 *         }
 */
class ModalService {
    /**
     * DI ComponentFactoryResolver to be used to create modal component.
     *
     * @param {?} cfr
     */
    constructor(cfr) {
        this.cfr = cfr;
    }
    /**
     *  PlaceHolder for modal to be inserted.
     *
     * @param {?} vcRef
     * @return {?}
     */
    registerViewContainerRef(vcRef) {
        this.vcRef = vcRef;
    }
    /**
     * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
     *
     * @template T
     * @param {?} component
     * @param {?=} parameters
     * @return {?}
     */
    open(component, parameters) {
        const /** @type {?} */ cf = this.cfr.resolveComponentFactory(component);
        let /** @type {?} */ componentRef = this.vcRef.createComponent(cf);
        // Auto set visiblity to true. So that the Dialog will display
        parameters = (parameters) ? parameters : {};
        parameters['visible'] = true;
        // Handle output parameters.
        ModalService.OUTPUT_PARAMETERS.forEach((param) => {
            if (parameters[param]) {
                (/** @type {?} */ (componentRef.instance))[param].subscribe(parameters[param]);
                delete parameters[param];
            }
        });
        Object.assign(componentRef.instance, parameters);
        // had to cast it in order to avoid any index Error
        // Attach a destroy method to the newly created component.
        (/** @type {?} */ (componentRef.instance))['destroy'] = () => {
            componentRef.destroy();
        };
        // Save the instance, so it can be destroyed later.
        this.instance = componentRef;
        return componentRef;
    }
    /**
     * Calling close() will remove the modal from view.
     * @return {?}
     */
    close() {
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
    }
}
/**
 * This is a static list of output parameter from Dialog, Confirmation components
 * that needs to be handled.
 *
 */
ModalService.OUTPUT_PARAMETERS = ['onClose', 'onConfirm', 'onCancel'];
ModalService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ModalService.ctorParameters = () => [
    { type: ComponentFactoryResolver }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Place holder for all modal dialogs. This component works with the modalService by providing
 * a place holder for it to inject Dialog component into.
 */
class ModalComponent {
    /**
     * @param {?} modalService
     */
    constructor(modalService) {
        this.modalService = modalService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.modalService.registerViewContainerRef(this.viewContainerRef);
    }
}
ModalComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-modal',
                template: `<div #modal></div>
`,
                styles: [``]
            },] },
];
/** @nocollapse */
ModalComponent.ctorParameters = () => [
    { type: ModalService }
];
ModalComponent.propDecorators = {
    viewContainerRef: [{ type: ViewChild, args: ['modal', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This currency formatter will ignore null and empty string for value.
 * Issue : https://github.com/angular/angular/issues/8694  DI fails when extends other classes
 */
class CurrencyFormatPipe {
    /**
     * @param {?} currencyPipe
     */
    constructor(currencyPipe) {
        this.currencyPipe = currencyPipe;
    }
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    transform(value, ...args) {
        // Default values
        let /** @type {?} */ currencyCode = 'USD', /** @type {?} */ symbolDisplay = true, /** @type {?} */ digits = '1.0-2';
        if (!value || value.length === 0) {
            return value;
        }
        if (args && args.length > 0) {
            let /** @type {?} */ code = args[0];
            if (code && code.length > 0) {
                currencyCode = code;
            }
        }
        return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
    }
}
CurrencyFormatPipe.decorators = [
    { type: Pipe, args: [{
                name: 'currencyFormat',
                pure: false
            },] },
];
/** @nocollapse */
CurrencyFormatPipe.ctorParameters = () => [
    { type: CurrencyPipe }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Simple utility directive that is used by NG For cycle in situation where we need to call a
 * or execute some logic after each iteration
 */
class NgForSetDirective {
    constructor() {
        this.onItem = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.onItem.emit('--');
    }
}
NgForSetDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngForSet]'
            },] },
];
/** @nocollapse */
NgForSetDirective.ctorParameters = () => [];
NgForSetDirective.propDecorators = {
    onItem: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Simple convenient service to work with the dom. All the future logic related to DOM manipulation
 * or traversal should be put into this service
 *
 */
class DomUtilsService {
    constructor() {
    }
    /**
     * goes all the way up to the body and checks if there is a element identified by a 'selector'
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    hasParent(nativeElement, selector) {
        return isPresent(this.closest(nativeElement, selector));
    }
    /**
     *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
     * not found
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    closest(nativeElement, selector) {
        let /** @type {?} */ firstChar = selector.charAt(0);
        let /** @type {?} */ parentNode = nativeElement;
        while (isPresent((parentNode = parentNode.parentNode))) {
            if (firstChar === '.' && parentNode.classList.contains(selector.substr(1))) {
                return parentNode;
            }
            if (firstChar === '#' && parentNode.id === selector.substr(1)) {
                return parentNode;
            }
            // If selector is a tag
            if (parentNode.nodeType === 1 && parentNode.tagName.toLowerCase() === selector) {
                return parentNode;
            }
            if (parentNode.nodeType === 1 && parentNode.tagName === 'BODY') {
                return null;
            }
        }
        return null;
    }
    /**
     * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
     * which always corresponds with _nghost_INDEX, this works fine if we have actual component
     * that is already rendered. If we are creating component programatically there is no way to
     * identify where the actual ng-content is placed within the component
     *
     * e.g. Consider following example:
     *
     *
     * Button Component Template:
     *
     * ```
     *  <span class=mybuttonTitle><ng-content></ng-content></span>
     * ```
     *
     * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
     *
     * ```
     * <aw-button _nghost_123>
     *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
     * </aw-button>
     * ```
     *
     * But with programmatic API you instantiate Button and since it created without a Content it
     * looks like this;
     *
     *  ```
     * <aw-button _nghost_123>
     *  <span class=mybuttonTitle></span>
     * </aw-button>
     * ```
     *
     * Where do you place you child (content component)? Therefore utility css class was created
     * to wrap <ng-content> to get around this limitation.
     *
     *  ```
     *   <span class="u-ngcontent">
     *      <ng-content></ng-content>
     *   </span>
     *  ````
     *
     *
     *
     *
     * @param {?} parentNativeEl
     * @param {?} childNativeEl
     * @return {?}
     */
    insertIntoParentNgContent(parentNativeEl, childNativeEl) {
        // default behavior is to insert it as child to parentNativeEl
        let /** @type {?} */ ngContentParent = parentNativeEl;
        let /** @type {?} */ foundNgContent = parentNativeEl.querySelector('.u-ngcontent');
        if (isPresent(foundNgContent)) {
            // we don't cover a case where there could be multiple ngcontents
            ngContentParent = foundNgContent;
        }
        ngContentParent.appendChild(childNativeEl);
    }
    /**
     *
     * Retrieves current browser window width and height
     *
     * @return {?}
     */
    browserDimentions() {
        return {
            width: (window.innerWidth || document.documentElement.clientWidth
                || document.body.clientWidth),
            height: (window.innerHeight || document.documentElement.clientHeight
                || document.body.clientHeight)
        };
    }
    /**
     *
     * Retrieves elemements dimensions
     *
     * @param {?} element
     * @return {?}
     */
    elementDimensions(element) {
        if (isPresent(element.getBoundingClientRect)) {
            return element.getBoundingClientRect();
        }
        return { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0, width: 0, height: 0 };
    }
}
DomUtilsService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DomUtilsService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The Infinite Scroll allows you to perform an action when the user
 * scrolls a specified distance from the bottom or top of the page.
 *
 * The expression assigned to the `infinite` event is called when
 * the user scrolls to the specified distance. When this expression
 * has finished its tasks, it should call the `complete()` method
 * on the infinite scroll instance.
 *
 * ## Usage
 *
 * ```html
 *
 *  <div  *ngFor="let item of items">{{item}} </div>
 *   <aw-infinite-scroll (onLoad)="doInfinite($event)">
 *  </aw-infinite-scroll>
 *
 * ```
 *
 *
 * You can also set a threshold to change the distance when the lazy load kicks
 * in.
 * ## Usage
 *
 * ```html
 *
 *  <div  *ngFor="let item of items">{{item}} </div>
 *   <aw-infinite-scroll (onLoad)="doInfinite($event)"  [distance]="'15%'">
 *  </aw-infinite-scroll>
 *
 * ```
 */
class InfiniteScrollComponent {
    /**
     * @param {?} _render
     * @param {?} _zone
     * @param {?} domUtils
     * @param {?} _cd
     */
    constructor(_render, _zone, domUtils, _cd) {
        this._render = _render;
        this._zone = _zone;
        this.domUtils = domUtils;
        this._cd = _cd;
        this._lastCheck = 0;
        this._lastScrollTop = 0;
        this._thr = '10%';
        this._thrPx = 0;
        this._thrPc = 0.10;
        this._init = false;
        /**
         * \@internal
         */
        this.state = STATE_ENABLED;
        /**
         * \@output {event} Emitted when the scroll reaches
         * the threshold distance. From within your infinite handler,
         * you must call the infinite scroll's `complete()` method when
         * your async operation has completed.
         */
        this.onLoad = new EventEmitter();
        /**
         *
         * Lazy load current numbers. tell the app starting point and what is the size of loaded
         * list
         *
         */
        this.fetchSize = 0;
        this.loadOffset = 0;
    }
    /**
     * \@input {string} The threshold distance from the bottom
     * of the content to call the `onLoad` output event when scrolled.
     * The threshold value can be either a percent, or
     * in pixels. For example, use the value of `10%` for the `infinite`
     * output event to get called when the user has scrolled 10%
     * from the bottom of the page. Use the value `100px` when the
     * scroll is within 100 pixels from the bottom of the page.
     * Default is `15%`.
     * @return {?}
     */
    get distance() {
        return this._thr;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set distance(val) {
        this._thr = val;
        if (val.indexOf('%') > -1) {
            this._thrPx = 0;
            this._thrPc = (parseFloat(val) / 100);
        }
        else {
            this._thrPx = parseFloat(val);
            this._thrPc = 0;
        }
    }
    /**
     * \@input {boolean} If true, Whether or not the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     * @param {?} shouldEnable
     * @return {?}
     */
    set enabled(shouldEnable) {
        this.enable(shouldEnable);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._render.addClass(document.body, 'has-infinite-scroll');
    }
    /**
     * @param {?} ev
     * @return {?}
     */
    _onScroll(ev) {
        if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
            return;
        }
        // must throttle the class by 100ms
        if (this._lastCheck + 100 > ev.timeStamp) {
            // no need to check less than every XXms
            return;
        }
        this._lastCheck = ev.timeStamp;
        let /** @type {?} */ scrollTop = this.scrollTop();
        let /** @type {?} */ winHeight = this.domUtils.browserDimentions().height;
        const /** @type {?} */ height = Math.max(this._docBody.scrollHeight, this._docBody.offsetHeight, winHeight, this._content.scrollHeight, this._content.offsetHeight);
        if (!height) {
            // if there is no height of this element then do nothing
            return;
        }
        const /** @type {?} */ threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
        let /** @type {?} */ distanceFromInfinite = this._content.scrollHeight - winHeight - scrollTop - threshold;
        // console.log('Document height (' + height + ') , Distance from bottom '
        // + distanceFromInfinite + ',  => threshold = ' +
        //     this.distance + ' (' + threshold + ')');
        if (distanceFromInfinite < 0 && this._lastScrollTop < scrollTop) {
            this.fireOnLazyLoad();
        }
        else if (this._lastScrollTop > scrollTop && scrollTop < winHeight
            && this.loadOffset !== this.fetchSize) {
            this.fireOnLazyUnLoad();
        }
        this._lastScrollTop = scrollTop;
        return;
    }
    /**
     * Todo: refactor to one method
     * @return {?}
     */
    fireOnLazyLoad() {
        this._zone.run(() => {
            if (this.state !== STATE_LOADING && this.state !== STATE_DISABLED) {
                this.state = STATE_LOADING;
                this.onLoad.emit({
                    isLoad: true,
                    limit: this.fetchSize,
                    offset: this.loadOffset
                });
                // start on the next record
                this.loadOffset += this.fetchSize;
            }
        });
    }
    /**
     * @return {?}
     */
    fireOnLazyUnLoad() {
        this._zone.run(() => {
            if (this.state !== STATE_LOADING && this.state !== STATE_DISABLED) {
                this.state = STATE_LOADING;
                // start on the next record
                this.loadOffset = this.fetchSize;
                this.onLoad.emit({
                    isLoad: false,
                    limit: this.fetchSize,
                    offset: this.loadOffset
                });
            }
        });
    }
    /**
     * @return {?}
     */
    scrollTop() {
        return (window.pageYOffset || this._content.scrollTop);
    }
    /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     * @return {?}
     */
    complete() {
        if (this.state !== STATE_LOADING) {
            return;
        }
        setTimeout(() => {
            this.state = STATE_ENABLED;
            // need to trigger extra detect changes to rerender loading icon
            this._cd.detectChanges();
        }, 100);
    }
    /**
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     * @param {?} shouldEnable  If the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     * @return {?}
     */
    enable(shouldEnable) {
        this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
        this._setListeners(shouldEnable);
    }
    /**
     * Subscribes to native windows scroll event
     * @param {?} shouldListen
     * @return {?}
     */
    _setListeners(shouldListen) {
        if (this._init) {
            if (shouldListen) {
                if (!this._scLsn) {
                    this._zone.runOutsideAngular(() => {
                        this._scLsn = this._onScroll.bind(this);
                        window.addEventListener('scroll', this._scLsn);
                    });
                }
            }
            else {
                if (isPresent(this._scLsn)) {
                    window.removeEventListener('scroll', this._scLsn);
                    this._scLsn = null;
                }
            }
        }
    }
    /**
     * @return {?}
     */
    isLoading() {
        return this.state === STATE_LOADING;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this._init = true;
        this._docBody = document.body;
        this._content = document.documentElement;
        this._setListeners(this.state !== STATE_DISABLED);
        if (this.loadOffset === 0) {
            this.fireOnLazyLoad();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._setListeners(false);
    }
}
InfiniteScrollComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-infinite-scroll',
                template: `<div class="w-infinite-loader-panel" *ngIf="isLoading()">
    <span class="sap-icon icon-synchronize u-spin-icon"></span>
</div>
`,
                styles: [`.w-infinite-loader-panel{display:flex;align-items:center;justify-content:center;background-color:#fff;width:100%;height:100px;z-index:300;bottom:100px}.w-infinite-loader-panel span{color:#4a4a4a;font-size:2em}`],
            },] },
];
/** @nocollapse */
InfiniteScrollComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: NgZone },
    { type: DomUtilsService },
    { type: ChangeDetectorRef }
];
InfiniteScrollComponent.propDecorators = {
    distance: [{ type: Input }],
    enabled: [{ type: Input }],
    onLoad: [{ type: Output }],
    loadPanel: [{ type: ViewChild, args: ['loadinPanel',] }],
    fetchSize: [{ type: Input }]
};
const /** @type {?} */ STATE_ENABLED = 'enabled';
const /** @type {?} */ STATE_DISABLED = 'disabled';
const /** @type {?} */ STATE_LOADING = 'loading';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AwNameStore {
    constructor() {
        this.store = new Map();
    }
    /**
     * @param {?} name
     * @param {?} el
     * @return {?}
     */
    add(name, el) {
        if (this.collides(name)) {
            throw new Error('Name is not unique!');
        }
        return this.store.set(name, el);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    remove(name) {
        return this.store.delete(name);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    collides(name) {
        return this.store.has(name);
    }
    /**
     * @return {?}
     */
    clear() {
        this.store.clear();
    }
}
AwNameStore.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AwNameStore.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The 'awName' directive attaches a identifier to decorated element to aid selectors for testing
 * purposes. The 'awName' directive tries to generate a unique identifier based on contextual data
 * and inherant immutable element attributes.
 *
 * **Generating the Base Name**
 *
 * The 'awName' directive generates a base name from element tag name and attributes which are
 * static by nature.
 *
 *     Example:
 *         <button name="order" awName>
 *
 *     Result:
 *         <button name="order" awname="button_order">
 *
 * If the element has an 'id', that value takes precedent and is used instead of a generated
 * name.
 *
 *     Example:
 *         <button name="order" id="myOrderButton" awName>
 *
 *     Result:
 *         <button name="order" id="myOrderButton" awname="button_myOrderButton">
 *
 *
 * **Repeated Elements and the 'ext' Parameter**
 *
 * There are many cases where elements are generated dynamically in the code as lists or tables.
 * In such cases, it may not be easy to distinguish individual elements by standard HTML
 * attributes, so the 'awName' directive allows custom extentions to the base name to be provided
 * using the 'ext' attribute.
 *
 *    Example:
 *        fruits = ['apple', 'banana', 'orange'];
 *
 *        <ul>
 *            <li *ngFor="let fruit of fruits" awName ext="{{fruit}}">{{fruit}}</li>
 *        </ul>
 *
 *   Result:
 *       <ul>
 *           <li awname="li_apple">apple</li>
 *           <li awname="li_banana">banana</li>
 *           <li awname="li_orane">orange</li>
 *       </ul>
 *
 * **Adding Context Through Ancestor Inspection**
 *
 * In order to provide context to the element naming, the 'awName' directive loops through the
 * parent ancestry and searches for any unique element 'id' to prepend to the base name.
 *
 *     Example:
 *         <form id="applicant">
 *            <input type="text" name="firstName" awName>
 *            <input type="text" name="lastName" awName>
 *         </form>
 *         <form id="spouse">
 *            <input type="text" name="firstName" awName>
 *            <input type="text" name="lastName" awName>
 *         </form>
 *
 *     Result:
 *         <form id="applicant">
 *            <input type="text" name="firstName" awname="applicant_input_firstName">
 *            <input type="text" name="lastName" awname="applicant_input_lastName">
 *         </form>
 *         <form id="spouse">
 *            <input type="text" name="firstName" awname="spouse_input_firstName">
 *            <input type="text" name="lastName" awname="spouse_input_lastname">
 *         </form>
 *
 * **Uniqueness Check**
 *
 * 'awName' keeps track of the names it creates by adding them to a map store. Whenever it
 * creates a new name during the `ngOnInit` phase it checks it against the existing map,
 * and will throw an error if it encounters a duplicate. Moreover during the element destruction
 * phase, `ngOnDestroy`, 'awName' removes the generated name from the store.
 *
 *
 * **In Production**
 *
 * Using 'awName' adds a small bit of rendering overhead for each element it is used on. In
 * a production environment, 'awName' serves no functionality to the end user, but may have
 * a performance impact on the application. As such, 'awName' takes into account the
 * `AppConfig` settings and disables name generation when `AppConfig.isProductionMode()`
 * is `true`.
 *
 * In your application, you can turn on production mode by setting `devmode.enabled` to
 * `false` when configuring `AribaCoreModule`:
 *
 *     AribaCoreModule.forRoot({
 *         'devmode.enabled': false
 *     })
 *
 */
class AwNameDirective {
    /**
     * @param {?} el
     * @param {?} store
     * @param {?} config
     */
    constructor(el, store, config) {
        this.el = el;
        this.store = store;
        this.config = config;
        this.separator = '_';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.config.isProductionMode()) {
            this.name = this.createName(this.el);
            this.addElementToStore(this.name, this.el);
            this.el.nativeElement.setAttribute('awname', this.name);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.store.remove(this.name);
    }
    /**
     * Add element name/id and reference to map store. If name/id already
     * exists in store then it throws an error.
     *
     * @param {?} name
     * @param {?} elem
     * @return {?}
     */
    addElementToStore(name, elem) {
        try {
            this.store.add(name, elem);
        }
        catch (/** @type {?} */ e) {
            console.error(e.message + `. "${name}" is already in use.`, elem.nativeElement);
            return;
        }
    }
    /**
     * Generate name/id for element.
     *
     * param elem Reference to element
     * @param {?} elem
     * @return {?} String Name/ID
     */
    createName(elem) {
        const /** @type {?} */ tagName = this.getTagName(elem);
        // Initialize array of string parts
        const /** @type {?} */ parts = [];
        // Find ancestor tag id, if there is one
        const /** @type {?} */ parentID = this.getAncestorId(elem);
        if (parentID) {
            parts.push(parentID);
        }
        // Check the tag type
        if (tagName === 'option') {
            const /** @type {?} */ parentName = this.getParentName(elem);
            if (parentName) {
                parts.push(parentName);
            }
        }
        // Get tagname
        parts.push(tagName);
        // Choose id property if it exists
        if (elem.nativeElement.id) {
            parts.push(elem.nativeElement.id);
            // Otherwise build extension from tag properties
        }
        else {
            // check for a name attribute
            if (elem.nativeElement.hasAttribute('name')) {
                parts.push(elem.nativeElement.name);
            }
            // check for value attribute if 'option' tag
            if (tagName === 'option') {
                if (elem.nativeElement.hasAttribute('value')) {
                    parts.push(this.spacesToUnderscore(elem.nativeElement.value));
                }
            }
        }
        // Add custom extension if it exists
        if (this.ext) {
            parts.push(this.spacesToUnderscore(this.ext));
        }
        return parts.join(this.separator);
    }
    /**
     * Get tag name from element reference.
     * @param {?} elem Reference to element
     * @return {?}
     */
    getTagName(elem) {
        return elem.nativeElement.tagName.toLowerCase();
    }
    /**
     * Traverse element ancestry and return first id attribute
     * encountered.
     * @param {?} elem Reference to element
     * @return {?}
     */
    getAncestorId(elem) {
        let /** @type {?} */ parent = elem.nativeElement.parentNode;
        let /** @type {?} */ id = '';
        while (parent && !id) {
            if (parent.id) {
                id = parent.id;
            }
            parent = parent.parentNode;
        }
        return id;
    }
    /**
     * Get name attribute from parent if name attribute exists.
     * @param {?} elem Reference to element
     * @return {?}
     */
    getParentName(elem) {
        const /** @type {?} */ parent = elem.nativeElement.parentNode;
        return (parent.name && !parent.id) ? parent.name : null;
    }
    /**
     * @param {?} str
     * @return {?}
     */
    spacesToUnderscore(str) {
        return str.replace(/\s+/g, '_');
    }
}
AwNameDirective.decorators = [
    { type: Directive, args: [{
                selector: '[awName]',
            },] },
];
/** @nocollapse */
AwNameDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: AwNameStore },
    { type: AppConfig }
];
AwNameDirective.propDecorators = {
    ext: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWCoreComponentModule {
}
AWCoreComponentModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    EmbeddedItemDirective,
                    IncludeComponentDirective,
                    GenericContainerComponent,
                    ErrorMessagesComponent,
                    ModalComponent,
                    CurrencyFormatPipe,
                    NgForSetDirective,
                    InfiniteScrollComponent,
                    AwNameDirective
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    GenericContainerComponent,
                    ModalComponent
                ],
                exports: [
                    EmbeddedItemDirective,
                    IncludeComponentDirective,
                    GenericContainerComponent,
                    ErrorMessagesComponent,
                    ModalComponent,
                    CurrencyFormatPipe,
                    NgForSetDirective,
                    InfiniteScrollComponent,
                    AwNameDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Parent class for all modal dialogs. Provides defaults functionality for all modals.
 */
class ModalContainer extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Override function.
         */
        this.destroy = noop;
    }
    /**
     * function that closes the dialog by calling destroy on the component reference.
     * Method inherited by all its children.
     * @return {?}
     */
    closeModal() {
        this.destroy();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DataTypeProviderRegistry aggregates different DataProviders per type.
 */
class DataTypeProviderRegistry {
    constructor() {
        this.registryByProvider = new Map();
        this.registryNameToClass = new Map();
    }
    /**
     * For every single registered DataProvider implementation we also need store its prototype
     * in order to be able to support some kind of inheritance. You can register a provider for
     * a parent class if needed
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    registerProvider(target, provider) {
        if (isBlank(target) || (!isStringMap(target) && !isType(target))) {
            throw new Error(' Cannot register non-object');
        }
        let /** @type {?} */ name = isType(target) ? target.prototype.constructor.name : target.constructor.name;
        this.registryByProvider.set(name, provider);
        let /** @type {?} */ prototype = Object.getPrototypeOf(target);
        this.registryNameToClass.set(name, prototype);
    }
    /**
     * Search for best matching provider. If not found then use object prototype to get hold of its
     * parent and see if there is a provider registered on this level
     *
     * @template T
     * @param {?} className
     * @return {?}
     */
    bestMatchForClass(className) {
        let /** @type {?} */ registeredClassName = className;
        let /** @type {?} */ classProto = this.registryNameToClass.get(className);
        while (isPresent(registeredClassName)) {
            let /** @type {?} */ provider = this.registryByProvider.get(registeredClassName);
            if (isPresent(provider)) {
                provider.type = className;
                return provider;
            }
            // Go up to parent
            if (isPresent(classProto)) {
                classProto = Object.getPrototypeOf(classProto);
                let /** @type {?} */ parentName = objectToName(classProto);
                registeredClassName =
                    (isPresent(parentName) && parentName !== registeredClassName) ? parentName
                        : null;
            }
            else {
                return null;
            }
        }
        return null;
    }
    /**
     * The same as bestMatchForClass() with the difference to pass a type. If you want to
     * support object inheritance you need this.
     *
     *
     * @template T
     * @param {?} type
     * @return {?}
     */
    bestMatchForType(type) {
        let /** @type {?} */ name = objectToName(type);
        this.registryNameToClass.set(name, type);
        return this.bestMatchForClass(name);
    }
}
DataTypeProviderRegistry.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DataTypeProviderRegistry.ctorParameters = () => [];
/**
 * Provider is a data driver that can access data and retrieve them. It knows how to get 1
 * or more records, maybe do paging and some other things.
 *
 * @abstract
 * @template T
 */
class DataProvider {
    constructor() {
        /**
         * Notifies all the listeners in case of data are available or if they changed due to some user
         * interaction  (search, adding or removing).
         *
         */
        this.dataChanges = new BehaviorSubject([]);
    }
    /**
     *  Return size of the source
     *
     * @param {?=} params
     * @return {?}
     */
    expectedCount(params) {
        return -1;
    }
    /**
     *
     * Returns non-async current state of data
     * @return {?}
     */
    data() {
        return this.dataChanges.getValue();
    }
    /**
     * Tells if this DataProvider supports INSERT, REMOVE
     *
     * @return {?}
     */
    canCRUD() {
        return false;
    }
    /**
     * Tells if this DataProvider supports query capability
     *
     * @return {?}
     */
    canQuery() {
        return false;
    }
    /**
     * Implement to support insertion. After record is inserted emit event for dataChanges to
     * inform all subscribers
     *
     * @param {?} obj
     * @return {?}
     */
    insert(obj) {
    }
    /**
     * Implement to support record removal. After record is removed emit event for dataChanges to
     * inform all subscribers.
     *
     * @param {?} obj
     * @return {?}
     */
    remove(obj) {
    }
    /**
     * Implement to provide access to low level searcg API.
     *
     * @param {?} params
     * @return {?}
     */
    query(params) {
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default implementation for Arrays.
 * @template T
 */
class ArrayDataProvider extends DataProvider {
    /**
     * @param {?} values
     */
    constructor(values) {
        super();
        this.values = values;
        this.type = Array;
        this.offScreenData = this.values;
        this.dataChanges.next(this.values);
    }
    /**
     * @param {?=} params
     * @return {?}
     */
    expectedCount(params) {
        return this.offScreenData.length;
    }
    /**
     * @param {?=} params
     * @return {?}
     */
    dataForParams(params) {
        if (isBlank(params)) {
            return this.offScreenData;
        }
        let /** @type {?} */ data = this.offScreenData;
        if (isPresent(params) && params.has('offset') && params.has('limit')) {
            let /** @type {?} */ offset = params.get('offset');
            let /** @type {?} */ limit = params.get('limit');
            if (data.length > (offset + limit)) {
                data = data.slice(offset, offset + limit);
            }
            else {
                data = data.slice(offset, data.length);
            }
        }
        if (params.has('orderby') && params.has('selector')) {
            this.sort(data, params.get('orderby'), params.get('selector'));
        }
        return data;
    }
    /**
     * @param {?} params
     * @return {?}
     */
    fetch(params) {
        return of(this.dataForParams(params));
    }
    /**
     * Provides default implementation for sorting current dataset by one column / key
     *
     * for sortOrdering please see Datatable and its sortOrderingForNumber()
     *
     *      1  = ascending
     *      -1 = descending
     * @param {?} arrayToSort
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    sort(arrayToSort, key, sortOrder) {
        arrayToSort.sort((data1, data2) => {
            let /** @type {?} */ value1 = FieldPath.getFieldValue(data1, key);
            let /** @type {?} */ value2 = FieldPath.getFieldValue(data2, key);
            let /** @type {?} */ result = null;
            if (value1 == null && value2 != null) {
                result = -1;
            }
            else if (value1 != null && value2 == null) {
                result = 1;
            }
            else if (value1 == null && value2 == null) {
                result = 0;
            }
            else if (typeof value1 === 'string' && typeof value2 === 'string') {
                result = value1.localeCompare(value2);
            }
            else {
                result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
            }
            return (sortOrder * result);
        });
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides top level accessor class in order to make {\@link DataProvider} retrieval process easier.
 * Using {\@link DataTypeProviderRegistry} we either retrieve registered instance of concrete
 * provider or instantiate our implicit provider for native types such as Array.
 *
 *
 */
class DataProviders {
    /**
     * @param {?} registry
     */
    constructor(registry) {
        this.registry = registry;
    }
    /**
     * Finds the best matching  DataProvider or create new one in case of Array
     * More room to register and instantiate some other implicit Providers
     * @param {?} target
     * @return {?}
     */
    find(target) {
        if (isArray(target)) {
            return new ArrayDataProvider(target);
        }
        else if (isString(target)) {
            return this.registry.bestMatchForClass(target);
        }
        return this.registry.bestMatchForType(target);
    }
    /**
     * Registers new provider within DataTypeProviderRegistry
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    register(target, provider) {
        this.registry.registerProvider(target, provider);
    }
}
DataProviders.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DataProviders.ctorParameters = () => [
    { type: DataTypeProviderRegistry }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Provides a registry of different data Finders used mostly by DataSources. All Finders are
 * registered by this class as we don't have any needs right now to expose this to developer.
 *
 */
class DataFinders {
    constructor() {
        this.findersByType = new Map();
        this.initFinders();
    }
    /**
     * Finds the best matching DataFinder based on the object type and queryType.
     * @param {?} forProvider
     * @param {?} forType
     * @return {?}
     */
    find(forProvider, forType) {
        let /** @type {?} */ finderMatch;
        this.findersByType.forEach((v, k) => {
            if (k.accepts(forProvider, forType)) {
                finderMatch = v;
                return true;
            }
        });
        if (isPresent(finderMatch)) {
            let /** @type {?} */ copy = new finderMatch();
            copy.forData(forProvider);
            return copy;
        }
        return null;
    }
    /**
     * Registers new finder
     *
     * @template T
     * @param {?} prototype
     * @param {?} type
     * @return {?}
     */
    register(prototype, type) {
        this.findersByType.set(prototype, type);
    }
    /**
     * @return {?}
     */
    initFinders() {
        // create a prototype for each
        this.findersByType.set(new FullTextArrayDataFinder(), FullTextArrayDataFinder);
        this.findersByType.set(new OutlineFullTextArrayDataFinder(), OutlineFullTextArrayDataFinder);
    }
}
DataFinders.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DataFinders.ctorParameters = () => [];
/** @enum {number} */
const QueryType = {
    FullText: 0,
    FullTextOutline: 1,
    Predicate: 2,
    FullTextAndPredicate: 3,
};
QueryType[QueryType.FullText] = "FullText";
QueryType[QueryType.FullTextOutline] = "FullTextOutline";
QueryType[QueryType.Predicate] = "Predicate";
QueryType[QueryType.FullTextAndPredicate] = "FullTextAndPredicate";
/**
 * This class provides matching capability for given DataProvider.
 * @abstract
 */
class DataFinder {
    /**
     * In order to find concrete DataFinder we need to know the target type and the query type
     *
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    accepts(forData, forType) {
        return false;
    }
    /**
     *
     * Query can be a simple string literal or a map having different key value pair as a
     * filter
     *
     * @template T
     * @param {?} query
     * @param {?=} max
     * @return {?}
     */
    match(query, max = -1) {
        return unimplemented();
    }
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    matchWithSelections(selections, query, max) {
        return unimplemented();
    }
}
/**
 * Simple FullText implementation based on infix string matching which works on top of
 * ArrayDataProvider.
 *
 */
class FullTextArrayDataFinder extends DataFinder {
    /**
     * @param {?} key
     * @return {?}
     */
    set lookupKey(key) {
        this._keyPath = isPresent(key) ? new FieldPath(key) : null;
    }
    /**
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    accepts(forData, forType) {
        return forData instanceof ArrayDataProvider && forType === QueryType.FullText;
    }
    /**
     * @param {?} provider
     * @return {?}
     */
    forData(provider) {
        this._provider = provider;
        return this;
    }
    /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    instantMatch(query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        let /** @type {?} */ list = this._provider.dataForParams(new Map().set('limit', max));
        return this.instantMatchWithSelections(list, query, max);
    }
    /**
     * @template T
     * @param {?} selectionsForMatch
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    instantMatchWithSelections(selectionsForMatch, query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        if (isBlank(query)) {
            return selectionsForMatch;
        }
        let /** @type {?} */ result = [];
        let /** @type {?} */ toLowerPattern = query.toLowerCase();
        for (let /** @type {?} */ i = 0; i < selectionsForMatch.length; i++) {
            let /** @type {?} */ item = selectionsForMatch[i];
            if (this.matches(item, toLowerPattern)) {
                result.push(item);
                if (result.length >= max) {
                    break;
                }
            }
        }
        return result;
    }
    /**
     *
     * Warning: If you dont supply search Key and you want fulltext search and you use this
     * default implementation be aware that it can  perform poorly as it is naive implementaion
     * that does not do deep compare.
     *
     * @template T
     * @param {?} item
     * @param {?} pattern
     * @return {?}
     */
    matches(item, pattern) {
        let /** @type {?} */ val = (isPresent(this._keyPath)) ? this._keyPath.getFieldValue(item) : item;
        if (isFunction(val)) {
            val = val.call(item);
        }
        else if (isJsObject(item)) {
            return this.hasObjectValue(item, pattern);
        }
        else {
            return isBlank(pattern) ||
                isPresent(val) && val.toString().toLowerCase().indexOf(pattern) > -1;
        }
    }
    /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    match(query, max) {
        return of(this.instantMatch(query, max));
    }
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    matchWithSelections(selections, query, max) {
        return of(this.instantMatchWithSelections(selections, query, max));
    }
    /**
     * @param {?} obj
     * @param {?} pattern
     * @return {?}
     */
    hasObjectValue(obj, pattern) {
        let /** @type {?} */ values = objectValues(obj);
        let /** @type {?} */ parentObj = objectToName(obj);
        let /** @type {?} */ length2 = values.filter((value) => {
            if (isBlank(value) || isArray(value)) {
                return false;
            }
            else if (!isJsObject(value) && !isFunction(value)) {
                return value.toString().toLowerCase().indexOf(pattern) !== -1;
            }
            else if (isJsObject(value) && objectToName(value) !== parentObj) {
                return this.hasObjectValue(value, pattern);
            }
            return false;
        }).length;
        return length2 > 0;
    }
}
/**
 * Extends basic Infix implementation to work on top of OutlineNodes. It first checks all the
 * children on lowest level and moving up to the root and marking nodes that can be removed.
 *
 *  For simple data structure which operates on local array this should be good enough we this
 *  can never match with real DB full text search.
 *
 */
class OutlineFullTextArrayDataFinder extends FullTextArrayDataFinder {
    /**
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    accepts(forData, forType) {
        return forData instanceof ArrayDataProvider && forType === QueryType.FullTextOutline;
    }
    /**
     * @template T
     * @param {?} selectionsForMatch
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    instantMatchWithSelections(selectionsForMatch, query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        if (isBlank(query)) {
            return selectionsForMatch;
        }
        let /** @type {?} */ toLowerPattern = query.toLowerCase();
        let /** @type {?} */ sourceToSearch = selectionsForMatch.slice();
        this.rollup(sourceToSearch, toLowerPattern);
        return this.shake(sourceToSearch);
    }
    /**
     *
     * Going thru the tree from bottom up and mark all that matches query
     *
     * @param {?} nodes
     * @param {?} query
     * @return {?}
     */
    rollup(nodes, query) {
        nodes.forEach((item) => {
            // start from bottom up and capture how many occurrences is found for future use
            let /** @type {?} */ hasChildrenMatch = false;
            if (isPresent(item.children) && item.children.length > 0) {
                hasChildrenMatch = this.rollup(item.children, query);
            }
            item.visible = hasChildrenMatch || this.matches(item, query);
        });
        return nodes.some((item) => item.visible);
    }
    /**
     * Filter out all the nodes that are marked as visible = false and make sure and
     * don't modify original list
     *
     * @param {?} nodes
     * @return {?}
     */
    shake(nodes) {
        return nodes
            .filter(node => node.visible)
            .map(node => (Object.assign({}, node, { isExpanded: node.visible, children: node.children && this.shake(node.children) })));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ DATA_SOURCE = new InjectionToken('DATA_SOURCE');
/**
 * DataSource describes basic functionality for handling stream of data specific to component
 *
 * It is expected that DataSource will be defined as component provider using
 *
 * \@Components ({
 *      ...
 *      providers:[
 *
 *          provide: DATA_SOURCE, useClass: ChooserDataSourcePlainArrayExample,
 * deps: [DataProviders, DataFinders]
 *      ]
 *
 * })
 *
 *
 * so all the dependencies (DataProviders, DataFinders) are properly injected.
 *
 * DataProvider uses open() method to broadcast changes to all the subscribers in reactive way.
 * Or you can use instant() method to retrieve current state of this DataSource (sync)
 *
 * @abstract
 */
class DataSource {
    /**
     *
     * Each DataSource have injected DataProviders and DataFinders to retrieve concrete
     * implementation
     *
     * @param {?=} dataProviders
     * @param {?=} finders
     */
    constructor(dataProviders, finders) {
        this.dataProviders = dataProviders;
        this.finders = finders;
    }
    /**
     * Returns a data instantly from the internal state of DataProvider
     * @template T
     * @return {?}
     */
    instant() {
        return unimplemented();
    }
}
DataSource.MaxLength = 10;
DataSource.MaxRecentSelected = 5;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class TopZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad ';
    }
}
TopZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-top',
                template: '<ng-content></ng-content>'
            },] },
];
TopZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class LeftZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
}
LeftZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-left',
                template: '<ng-content></ng-content>'
            },] },
];
LeftZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class MiddleZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-md-6 ui-lg-4 ui-g-nopad';
    }
}
MiddleZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-middle',
                template: '<ng-content></ng-content>'
            },] },
];
MiddleZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class RightZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
}
RightZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-right',
                template: '<ng-content></ng-content>'
            },] },
];
RightZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
class BottomZoneComponent {
    constructor() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
}
BottomZoneComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-bottom',
                template: '<ng-content></ng-content>'
            },] },
];
BottomZoneComponent.propDecorators = {
    classList: [{ type: HostBinding, args: ['class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Used by FormTable to layout fields into Rows. Each FormTable row is reasonable for not only to
 * include actual component such is DropDown or InputField but mainly provides a enough context for
 * the component to specify the size, how it should layout, whether we need to show required flag,
 * to show/hide labels in case if we have no label layout and much more.
 *
 * FormRow component also registers angular validator for the current row/field. As already
 * mentioned We treat our widgets with minimal responsibility as possible to present and retrive
 * information to/from user and let somebody else to figure out where it appear and how.
 *
 * todo: Move under FormTable
 */
class FormRowComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, 
    // Event this creates CI depends. Need to have a reference to parent
    // I need to refactor more parent to not use this child and refactor layouting
    parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Hides the label
         *
         */
        this.noLabelLayout = false;
        /**
         * Renders row with highlighted background
         *
         */
        this.highlightRow = false;
        /**
         *
         *  Field label that should appear above or next to the control
         *
         */
        this.label = '';
        /**
         *
         * For single column layout without zones we need to apply grid directly to the FormRow tag
         * so we don't need to introduce extra div level
         *
         */
        this.classList = '';
        this._size = 'ui-g-12 ui-md-' + WidgetSizeColumns.medium;
    }
    /**
     * Right now we just initialize this once and use the values we do not expect now to react to
     * changes
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(null);
        this.registerValidators();
        this.omitPadding = this.parentContainer.omitPadding;
        this.classList += isPresent(this.parentContainer) ? ' ui-g-12 ' : '';
        this.classList = this.highlightRow ? this.classList + ' highlight-row ' : this.classList;
        this.classList = this.omitPadding ? this.classList + ' ui-g-nopad ' : this.classList;
    }
    /**
     * Just a size getter
     *
     * @return {?}
     */
    get size() {
        return this._size;
    }
    /**
     *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
     * right now. but we should extend this for other screen sizes
     *
     *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
     *
     *  Also check if this is dynamic size that should vary based on the how many number of columns
     * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
     * small.
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        let /** @type {?} */ isDynVal = false;
        if (StringWrapper.startsWidth(value, 'd-')) {
            isDynVal = true;
            value = value.substr(2, value.length - 1);
        }
        if (isPresent(value)) {
            this._size = value;
            let /** @type {?} */ dSize = this.dynSize(value, isDynVal);
            this._size = 'ui-g-12 ui-md-' + dSize;
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
        if (isPresent(this.parentContainer) && this.editable !== this.parentContainer.editable) {
            this.editable = this.parentContainer.editable;
        }
    }
    /**
     * Push out of box angular validator as well as custom one to current FormControl
     * @return {?}
     */
    registerValidators() {
        let /** @type {?} */ validators = [];
        if (isPresent(this.maxLength)) {
            validators.push(Validators.maxLength(this.maxLength));
        }
        if (isPresent(this.minLength)) {
            validators.push(Validators.minLength(this.minLength));
        }
        if (isPresent(this.required) && this.required) {
            validators.push(Validators.required);
        }
        if (isPresent(this.pattern)) {
            validators.push(Validators.pattern(this.pattern));
        }
        if (isPresent(this.customValidators)) {
            ListWrapper.addAll(validators, this.customValidators);
        }
        if (validators.length === 1) {
            this.formControl.setValidators(validators[0]);
        }
        else if (validators.length > 1) {
            this.formControl.setValidators(Validators.compose(validators));
        }
        if (isPresent(this.customAsyncValidators) && this.customAsyncValidators.length === 1) {
            this.formControl.setAsyncValidators(this.customAsyncValidators[0]);
        }
        else if (isPresent(this.customAsyncValidators) && this.customAsyncValidators.length > 1) {
            this.formControl.setAsyncValidators(Validators.composeAsync(this.customAsyncValidators));
        }
    }
    /**
     *
     * Do we have labels on TOP, try to read this from Parent
     *
     * @return {?}
     */
    get labelsOnTop() {
        if (isBlank(this._labelsOnTop) && isPresent(this.parentContainer)) {
            return (/** @type {?} */ (this.parentContainer)).isLabelsOnTop();
        }
        return false;
    }
    /**
     *
     * Can refactor all into 1 line but its hard to debug so this is just for read
     *
     * @param {?} value
     * @param {?} isDynValue
     * @return {?}
     */
    dynSize(value, isDynValue) {
        let /** @type {?} */ normalizeSize = value.toLowerCase().replace('-', '');
        if (isPresent(this.parentContainer) &&
            (/** @type {?} */ (this.parentContainer)).hasTwoColumn && isDynValue) {
            let /** @type {?} */ enumValues = Object.keys(WidgetSizeColumns);
            normalizeSize = enumValues[enumValues.indexOf(normalizeSize) + 1];
        }
        return (/** @type {?} */ (WidgetSizeColumns))[normalizeSize];
    }
}
FormRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-form-row',
                template: `<div *ngIf="!hidden"
     class="w-form-row ui-g"
     [class.highlight-row]="highlightRow"
     [class.required]="required"
     [class.label-on-top]="labelsOnTop"
     [class.label-on-side]="!labelsOnTop"
     [class.has-danger]="!formControl.valid && !formControl.pristine "
     [ngClass]="styleClass">

    <div class="control-label ui-g-12 ui-g-nopad"
         *ngIf="!noLabelLayout"
         [class.ui-md-3]="!labelsOnTop">
        <label [class.sr-only]="noLabelLayout">{{label}}</label>
    </div>

    <div class="control-value ui-g-nopad" [ngClass]="size"
         [class.read-only]="!editable">
        <ng-content></ng-content>
        <a-error-messages [control]="formControl"></a-error-messages>
    </div>
</div>
`,
                styles: [`.required label:after{content:"*";color:red}/deep/ .highlight-row{background-color:#f7f8fa}.w-form-row.highlight-row{background-color:#f7f8fa}.w-form-row.label-on-top{padding-bottom:13px}.w-form-row.label-on-top .control-label,.w-form-row.label-on-top .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-top .control-label{padding-bottom:12px}.w-form-row.label-on-side .control-label,.w-form-row.label-on-side .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-side .control-label ::ng-deep .w-string-field,.w-form-row.label-on-side .control-value ::ng-deep .w-string-field{line-height:36px}.w-form-row.label-on-side .control-label ::ng-deep .sap-icon,.w-form-row.label-on-side .control-value ::ng-deep .sap-icon{line-height:26px}.w-form-row.label-on-side .control-label label,.w-form-row.label-on-side .control-value label{line-height:36px}.w-form-row.label-on-side .control-label .fa,.w-form-row.label-on-side .control-value .fa{line-height:18px}.control-label{color:#636363}.u-validation-error{border-color:red}`],
                providers: [
                    { provide: BaseFormComponent, useExisting: forwardRef(() => FormRowComponent) }
                ]
            },] },
];
/** @nocollapse */
FormRowComponent.ctorParameters = () => [
    { type: Environment },
    { type: FormTableComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormTableComponent),] }] }
];
FormRowComponent.propDecorators = {
    noLabelLayout: [{ type: Input }],
    highlightRow: [{ type: Input }],
    label: [{ type: Input }],
    maxLength: [{ type: Input }],
    minLength: [{ type: Input }],
    pattern: [{ type: Input }],
    customAsyncValidators: [{ type: Input }],
    customValidators: [{ type: Input }],
    classList: [{ type: HostBinding, args: ['class',] }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * FormTable is a specific layout component for rendering Labels and its controls in two columns
 * and 5 different zones.
 *
 * We support LEFT, MIDDLE, RIGHT, TOP, BOTTOM zone where we can place our component or widgets.
 * This
 * component is used as primary layout to wrap all the common use cases. E.g. When we lay out
 * fields in the form I do not want controls to be aware of error validation, size, labels, and
 * some other things. Control such INPUT is just responsible for retrieve user value but not how it
 * appear on the page.
 *
 * This way we can be flexible how we treat widgets for different kinds of situation depending
 * where they appear
 * FormTable just like the rest of the components are using Model driven approach how to work with
 * data, mean we are using FormGroup, FormControl etc. FormGroup can be passed into the FormTable,
 * otherwise its automatically created when the FormTable is instantiated.
 *
 * FormGroup is saved insode Environment where we are using this to pass this around the pages and
 * components.
 *
 * ### Example
 *
 * Simple Layout fields and its control
 *
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: `
 *  			<aw-form-table [formGroup]="formGroup" (onSubmit)=>
 *  				<aw-form-row [label]="'name'" [name]="'name'">
 *  					<aw-input-field [type]="'string'"></aw-input-field>
 *  				</aw-form-row>
 *
 *  				<aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
 *  					<aw-checkbox-list [list]="checkBoxListValues"
 *  					                 [selections]="selectedValues"
 *  					                 [layout]="'inline'"
 *  					                 (onSelection)="onCBClick($event)">
 *  					</aw-checkbox-list>
 *  				</aw-form-row>
 *  				<aw-form-row [label]="'Gender'" [name]="'gender'">
 *
 *  					<aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
 *
 *  					</aw-radiobutton-list>
 *
 *  				</aw-form-row>
 *  				<aw-form-row [label]="'My birthdate'" [name]="'birthDate'" [size]="'small'">
 *
 *  					<aw-date-time [value]="date" [editable]="editable" [showTime]="showTime">
 *  					</aw-date-time>
 *  				</aw-form-row>
 *  			</aw-form-table>
 *    `
 *  })
 *  export class ShowUserInfoComponent
 *  {
 *       checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' , 'silver'
 *     , 'black' , 'Green'
 *     , 'Gray' , 'Navy' ,
 *          'Olive' , 'Aqua' , 'Purple'];
 *      selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
 *      rbValues: string[] = ['male' , 'female' , 'other'];
 *      rbSelection: string = 'male';
 *      editable: boolean = true;
 *      showTime: boolean = true;
 *
 *      formGroup: FormGroup = new FormGroup({});
 *
 *
 *      onCBClick (event): void
 *      {
 *          console.log('onCBClick = ' + event);
 *      }
 *
 *      onSubmit (model: any): void
 *      {
 *         console.log(model)
 *
 *         // will print { name:null, myColors:['blue' , 'Olive' , 'Aqua' , 'Purple'], gender:
 *     male}
 *      }
 *
 *  }
 *
 *  ```
 *
 *  Or you can use zone to layout these fields into two columns:
 *
 *  Current zones are implement with <ng-content SELECT> which is just a selector to searches for
 *     specific pattern. In our case instead of creating extra wrapper custom component use simple
 *     CSS class
 *
 *
 *  ```
 *            <aw-form-table #metaFormTable [editable]="editing"
 *                          [useFiveZone]="isFiveZoneLayout"
 *                          (onSubmit)="onSaveAction($event)">
 *
 *                <aw-left  *ngIf="canShowZone('zLeft')">
 *
 *                        <aw-form-row [label]="'name'" [name]="'name'">
 *                            <aw-input-field [type]="'string'"></aw-input-field>
 *                        </aw-form-row>
 *
 *                        <aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
 *                            <aw-checkbox-list [list]="checkBoxListValues"
 *                                             [selections]="selectedValues"
 *                                             [layout]="'inline'"
 *                                             (onSelection)="onCBClick($event)">
 *                            </aw-checkbox-list>
 *                        </aw-form-row>
 *                </aw-left>
 *
 *
 *                <aw-right  *ngIf="canShowZone('zRight')">
 *                        <aw-form-row [label]="'Gender'" [name]="'gender'">
 *                                <aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
 *                                </aw-radiobutton-list>
 *                        </aw-form-row>
 *
 *                        <aw-form-row [label]="'My birthdate'" [name]="'birthDate'"
 *     [size]="'small'">
 *                            <aw-date-time [value]="date" [editable]="editable"
 *     [showTime]="showTime">
 *                            </aw-date-time>
 *                        </aw-form-row>
 *                </<aw-right>
 *            </aw-form-table>
 *
 *  ```
 *
 *  todo: remove my css selectors for zones and replace it with real component even just a tag
 *  todo: would work file
 *
 */
class FormTableComponent extends BaseFormComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env, null);
        this.env = env;
        /**
         * Used for the form layout to see if we need to render labels stacked  or side by side next to
         * the control
         *
         */
        this.labelsOnTop = false;
        /**
         *
         * Is this a 4 zone layout
         *
         */
        this.useFiveZone = false;
        /**
         * For certain usecase we dont want to set automatically this to all children
         */
        this.editabilityCheck = true;
        /**
         *  Triggers when the <form> is submitted. onSubmit we emit the whole formController objects
         *
         *
         */
        this.onSubmit = new EventEmitter();
        /**
         * Cache calculated properties when init this component
         *
         */
        this.hasOneColumn = false;
        this.hasTwoColumn = false;
        this.hasThreeColumn = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (isPresent(changes['editable']) &&
            changes['editable'].previousValue !== changes['editable'].currentValue) {
            this.updateFormFields();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSubmitForm(event) {
        this.onSubmit.emit(event);
    }
    /**
     *
     * Are labels on top
     *
     * @return {?}
     */
    isLabelsOnTop() {
        return this.labelsOnTop;
    }
    /**
     *
     * Used by child component to inherit editability
     *
     * @return {?}
     */
    isFormEditable() {
        return this.editable;
    }
    /**
     * @return {?}
     */
    applyColumns() {
        if (!this.useFiveZone && this.hasAnyZones()) {
            throw new Error('Zones detected in the FormTable but useFiveZone option is false');
        }
        this.hasOneColumn = !isPresent(this.rightZone) && !isPresent(this.middleZone);
        this.hasTwoColumn = isPresent(this.leftZone) && isPresent(this.rightZone) &&
            !isPresent(this.middleZone);
        this.hasThreeColumn = isPresent(this.leftZone) && isPresent(this.rightZone) &&
            isPresent(this.middleZone);
        if (this.hasTwoColumn && !this.isTwoZoneReady()) {
            this.leftZone.classList += ' ui-md-6 ui-lg-6';
            this.rightZone.classList += ' ui-md-6 ui-lg-6';
        }
        if (this.hasThreeColumn && !this.isThreeZoneReady()) {
            this.leftZone.classList += ' ui-md-6 ui-lg-4';
            this.rightZone.classList += ' ui-md-6 ui-lg-4';
        }
    }
    /**
     * @return {?}
     */
    hasAnyZones() {
        return isPresent(this.leftZone) || isPresent(this.rightZone) || isPresent(this.middleZone)
            || isPresent(this.topZone) || isPresent(this.bottomZone);
    }
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    isTwoZoneReady() {
        return this.leftZone.classList.indexOf('ui-lg-6') > 0 &&
            this.leftZone.classList.indexOf('ui-lg-6') > 0;
    }
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    isThreeZoneReady() {
        return this.leftZone.classList.indexOf('ui-lg-4') > 0 &&
            this.leftZone.classList.indexOf('ui-lg-4') > 0;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // problem since Angular 4.2, ngAfterContentInit
        // without this I get error that value was changed after view was checked
        // todo: refactor  - mainly our zones left, right middle
        setTimeout(() => {
            this.applyColumns();
            this.updateFormFields();
            this.adjustLayout();
        });
    }
    /**
     * @return {?}
     */
    updateFormFields() {
        if (this.editabilityCheck && isPresent(this.formFields) && this.formFields.length > 0) {
            this.formFields.forEach((item) => {
                item.editable = this.editable;
                // item.formGroup = this.formGroup;
            });
        }
    }
    /**
     * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
     * form row.
     * @return {?}
     */
    adjustLayout() {
        if (isPresent(this.rows) && this.rows.length > 0) {
            if (this.hasThreeColumn) {
                this.rows.forEach((item) => item.size = 'large');
            }
        }
    }
}
FormTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-form-table',
                template: `<form class="w-form-table ui-g ui-fluid" [formGroup]="formGroup"
      [ngClass]="styleClass"
      (ngSubmit)="onSubmitForm(formGroup.value)" novalidate>

    <div class="ui-g-12 ui-g-nopad">

        <div class="ui-g">
            <ng-content></ng-content>
        </div>

    </div>
</form>

`,
                styles: [`.page-container>form{margin-top:1em}.w-form-table button{float:right}`],
                providers: [
                    { provide: BaseFormComponent, useExisting: forwardRef(() => FormTableComponent) }
                ]
            },] },
];
/** @nocollapse */
FormTableComponent.ctorParameters = () => [
    { type: Environment }
];
FormTableComponent.propDecorators = {
    labelsOnTop: [{ type: Input }],
    useFiveZone: [{ type: Input }],
    editabilityCheck: [{ type: Input }],
    onSubmit: [{ type: Output }],
    leftZone: [{ type: ContentChild, args: [LeftZoneComponent,] }],
    middleZone: [{ type: ContentChild, args: [MiddleZoneComponent,] }],
    rightZone: [{ type: ContentChild, args: [RightZoneComponent,] }],
    topZone: [{ type: ContentChild, args: [TopZoneComponent,] }],
    bottomZone: [{ type: ContentChild, args: [BottomZoneComponent,] }],
    formFields: [{ type: ContentChildren, args: [BaseFormComponent, { descendants: true },] }],
    rows: [{ type: ContentChildren, args: [forwardRef(() => FormRowComponent), { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWFormTableModule {
}
AWFormTableModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    FormTableComponent,
                    FormRowComponent,
                    TopZoneComponent,
                    LeftZoneComponent,
                    RightZoneComponent,
                    MiddleZoneComponent,
                    BottomZoneComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    FormTableComponent,
                    FormRowComponent,
                    TopZoneComponent,
                    LeftZoneComponent,
                    RightZoneComponent,
                    MiddleZoneComponent,
                    BottomZoneComponent
                ],
                exports: [
                    FormTableComponent,
                    FormRowComponent,
                    TopZoneComponent,
                    LeftZoneComponent,
                    RightZoneComponent,
                    MiddleZoneComponent,
                    BottomZoneComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This component represent a Input field and it can  accept different types of values such as
 * text, number.
 *
 *
 *
 * ### Example
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: '<aw-input-field [value]="inputValue" [type]="inputType"></aw-input-field>'
 *  })
 *  export class TestInputComponent
 *  {
 *      inputValue: string = 'Some text';
 *
 *      // by default input type is text, you can pass string, String, or text
 *      inputType: string = 'string';
 *  }
 *
 * ```
 *
 *
 *
 * ### Example wher input field is initialized with ngModel
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: '<aw-input-field [value]="inputValue" [(ngModel)]="inputType"></aw-input-field>'
 *  })
 *  export class TestInputComponent
 *  {
 *      inputValue: string = 'Some text';
 *
 *      // by default input type is text, you can pass string, String, or text
 *      inputType: string = 'string';
 *  }
 *
 * ```
 *
 *  Note: if you are using this outside of FormTable please provide your own FormGroup
 *
 */
const /** @type {?} */ INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => InputFieldComponent),
    multi: true
};
class InputFieldComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value used to save and read  when rendering and updating a component
         *
         */
        this.value = '';
        /**
         * The formatted decimal value. Uses angular decimalPipe to format based on locale.
         */
        this.displayValue = '';
        /**
         * Input field type. Currently we support either Number or text
         */
        this._type = 'string';
        this.decimalPipe = new DecimalPipe(env.locale);
    }
    /**
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     *
     * generated setter to check for value and normalizing into expected either number or text
     *
     * @param {?} value
     * @return {?}
     */
    set type(value) {
        if (value.toLowerCase() === 'string' || value.toLowerCase() === 'text') {
            this._type = 'text';
        }
        else if (value.toLowerCase() === 'number') {
            this._type = 'number';
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.bigDecimal);
        this.vchSubscriber = this.formControl.valueChanges
            .pipe(distinctUntilChanged())
            .subscribe(val => {
            this.value = val;
            this.onModelChanged(this.value);
        });
        if (this.bigDecimal) {
            this.displayValue = this.formatNumber(this.bigDecimal.amount);
        }
        else {
            this.displayValue = this.value;
        }
    }
    /**
     * @return {?}
     */
    canSetType() {
        return true;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    onKeyDown(el) {
        if (this._type === 'number') {
            this.displayValue = el.value;
            this.onModelChanged(this.displayValue);
        }
    }
    /**
     * @param {?} el
     * @return {?}
     */
    onBlur(el) {
        if (this._type === 'number') {
            this.bigDecimal = new BigDecimal(Number(el.value));
            this.displayValue = this.formatNumber(this.bigDecimal.amount);
            this.onModelChanged(this.displayValue);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.displayValue) {
            this.value = value;
            this.displayValue = '';
            if (this.value) {
                this.displayValue = this.value;
            }
            this.formControl.setValue(value, { onlySelf: true });
        }
    }
    /**
     * Format the number object according to its precision.
     *
     * @param {?} value
     * @return {?}
     */
    formatNumber(value) {
        if (!value) {
            return '';
        }
        // If precision is present, use it for format the bigDecimal value for display.
        if (isPresent(this.precision) &&
            this._type === 'number') {
            // The default precision is 2. For example, 10.23.
            let /** @type {?} */ digits = '1.0-2';
            digits = '1.0-' + this.precision;
            return this.decimalPipe.transform(value, digits);
        }
        return value;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (isPresent(this.vchSubscriber)) {
            this.vchSubscriber.unsubscribe();
        }
    }
}
InputFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-input-field',
                template: `<div *ngIf="editable" [formGroup]="formGroup" class="w-input-wrapper">

    <input pInputText
           #inputFieldValue
           [attr.name]="name"
           [attr.type]="type"
           class="w-input-field"
           [ngClass]="styleClass"
           [class.has-icon]="icon"
           placeholder="{{placeHolder}}"
           [class.u-validation-error]="!(formControl.valid || (formControl.pristine))"
           formControlName="{{name}}"
           (keydown)="onKeyDown(inputFieldValue)"
           (blur)="onBlur(inputFieldValue)"
           [value]="displayValue">
    <span *ngIf="icon" class="sap-icon" [ngClass]="icon"></span>
</div>


<ng-template [ngIf]="!editable">
    <aw-string [value]="displayValue"></aw-string>
</ng-template>
`,
                styles: [`.w-input-wrapper{position:relative}.w-input-field{padding-right:35px}.w-input-field~span{top:13px;position:absolute;right:15px}`],
                providers: [
                    INPUT_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => InputFieldComponent) }
                ]
            },] },
];
/** @nocollapse */
InputFieldComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
InputFieldComponent.propDecorators = {
    value: [{ type: Input }],
    precision: [{ type: Input }],
    bigDecimal: [{ type: Input }],
    icon: [{ type: Input }],
    type: [{ type: Input }]
};
/**
 * BigDecimal object is represented as a value, locale, and currencyCode
 */
class BigDecimal {
    /**
     * @param {?=} amount
     * @param {?=} locale
     */
    constructor(amount = 0, locale = 'en_US') {
        this.amount = amount;
        this.locale = locale;
    }
    /**
     * @return {?}
     */
    getTypes() {
        return {
            amount: Number,
            locale: String
        };
    }
    /**
     * @return {?}
     */
    className() {
        return 'BigDecimal';
    }
    /**
     * @return {?}
     */
    $proto() {
        return new BigDecimal(1, 'en_US');
    }
    /**
     * @return {?}
     */
    toString() {
        return this.amount + ', locale: ' + this.locale;
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    clone(data = {}) {
        return new BigDecimal(isPresent(data.amount) ? data.amount : this.amount, isPresent(data.locale) ? data.locale : this.locale);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWStringFieldModule {
}
AWStringFieldModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    StringComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                entryComponents: [
                    StringComponent
                ],
                exports: [
                    StringComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWInputFieldModule {
}
AWInputFieldModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    InputFieldComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    InputFieldComponent
                ],
                exports: [
                    InputFieldComponent,
                    AWStringFieldModule,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * basic navigation bar provide a main action buttons for its content (page level buttons).
 * This is not the Top level application navigation. This component provides by default action OK,
 * CANCEL and you are free to modify how the OK or CANCEL will be call as well as subscribe to the
 * event. Or you can provide your own buttons template which will be used instead of this default
 * one.
 *
 *
 *
 *
 *
 * ### Example 1:
 *
 * In order to use navigation bar in its basic usage you can do following:
 * this will render buttons on the top as well as on the bottom around the content.
 *
 *
 *  ```html
 *
 *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
 *
 *            <div class="container">
 *                <form>
 *                    User name: <input type=text value="peter.pan">
 *                </<form>>
 *            </div>
 *      </aw-basic-navigator>
 *
 *
 * ```
 *
 *  if you do not want button on the top or bottom you can say thi using binding showTop or
 * showBottom.
 *
 *
 * ### Example 2:
 *  In this example we are providing custom buttons as well as brank section
 *
 *
 *  ```html
 *
 *
 *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
 *            <ng-template #buttons>
 *                <ul class="nav navbar-nav float-md-right collapse navbar-toggleable-xs">
 *                    <li class="nav-item ">
 *                        <button class="btn btn-secondary" type="button"
 * (click)="onSaveAction($evemt)">Cancel</button>
 *                    </li>
 *                    <li class="nav-item active">
 *                        <button class="btn btn-primary" type="button"
 * (click)="onCancelAction($event)"> Save
 *                        </button>
 *                    </li>
 *                </ul>
 *            </ng-template>
 *
 *            <ng-template #brand>
 *                <span class="brand-title">Ariba</span>
 *            </ng-template>
 *
 *
 *            <div class="container">
 *                <form>
 *                    User name: <input type=text value="peter.pan">
 *                </<form>>
 *            </div>
 *      </aw-basic-navigator>
 *
 *
 * ```
 *
 */
class BasicNavigatorComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} appConfig
     */
    constructor(env, appConfig) {
        super(env);
        /**
         * Indicates that buttons will be rendered on the top
         *
         * Default value is TRUE
         *
         */
        this.showTop = true;
        /**
         * Indicates that buttons will be rendered on the bottom
         *
         * Default value is TRUE
         *
         */
        this.showBottom = true;
        /**
         * Indicates that brand section that is on the left side and only in the top bar is visible
         *
         * Default value is TRUE
         *
         */
        this.showBrand = true;
        /**
         *
         * EventEmitter that is triggered when you click on default OK Action
         *
         */
        this.onOKAction = new EventEmitter();
        /**
         *
         * EventEmitter that is triggered when you click on default CANCEL Action
         *
         */
        this.onCancelAction = new EventEmitter();
        // todo: load this from resource file using ngTranslate service
        this.okActionLabel = 'OK';
        this.cancelActionLabel = 'Cancel';
        this.brandImg = 'images/aribalogobal.png';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.showCancelButton)) {
            this.showCancelButton = this.editable || (this.onCancelAction.observers.length > 0
                && this.onOKAction.observers.length > 0);
        }
    }
    /**
     * Returns if buttonsTemplate is available
     *
     * @return {?}
     */
    hasButtonTemplate() {
        return isPresent(this.buttonsTemplate);
    }
    /**
     * Returns if brandTemplate is available
     *
     * @return {?}
     */
    hasBrandTemplate() {
        return isPresent(this.brandTemplate);
    }
}
BasicNavigatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-basic-navigator',
                template: `<p-toolbar *ngIf="showTop" [class]="'w-basic-navigator'">
    <div class="ui-toolbar-group-left">

        <a class="nav-brand" href="#" *ngIf="showBrand">
            <ng-template [ngIf]="!hasBrandTemplate()">
                <img src="{{assetFolder}}/{{brandImg}}" height="30" alt="">
                <span class="nav-brand-title">Ariba</span>
            </ng-template>

            <ng-template [embeddedItem]="brandTemplate" [item]="context"
                         *ngIf="hasBrandTemplate()"></ng-template>
        </a>

    </div>

    <div class="ui-toolbar-group-right">
        <ng-template [ngIf]="!hasButtonTemplate()">

            <aw-button *ngIf="showCancelButton" [style]="'secondary'"
                       (action)="onCancelAction.emit($event)">
                {{cancelActionLabel}}
            </aw-button>

            <aw-button (action)="onOKAction.emit($event)">
                {{okActionLabel}}
            </aw-button>


        </ng-template>
        <ng-template [embeddedItem]="buttonsTemplate" [item]="context"
                     *ngIf="hasButtonTemplate()"></ng-template>
    </div>

</p-toolbar>

<ng-content></ng-content>

<p-toolbar *ngIf="showBottom">

    <div class="ui-toolbar-group-right">
        <ng-template [ngIf]="!hasButtonTemplate()">

            <aw-button *ngIf="showCancelButton" [style]="'secondary'"
                       (action)="onCancelAction.emit($event)">
                {{cancelActionLabel}}
            </aw-button>

            <aw-button (action)="onOKAction.emit($event)">
                {{okActionLabel}}
            </aw-button>
        </ng-template>
        <ng-template [embeddedItem]="buttonsTemplate" [item]="context"
                     *ngIf="hasButtonTemplate()"></ng-template>
    </div>

</p-toolbar>



`,
                styles: [`a.nav-brand{vertical-align:middle;line-height:inherit;text-decoration:none;color:#2d353c}a.nav-brand:focus,a.nav-brand:hover{text-decoration:none}a.nav-brand span{vertical-align:middle}.nav-brand img{display:inline-block;vertical-align:middle;padding:3px}`]
            },] },
];
/** @nocollapse */
BasicNavigatorComponent.ctorParameters = () => [
    { type: Environment },
    { type: AppConfig }
];
BasicNavigatorComponent.propDecorators = {
    showTop: [{ type: Input }],
    showBottom: [{ type: Input }],
    showBrand: [{ type: Input }],
    brandImg: [{ type: Input }],
    okActionLabel: [{ type: Input }],
    cancelActionLabel: [{ type: Input }],
    context: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    onOKAction: [{ type: Output }],
    onCancelAction: [{ type: Output }],
    buttonsTemplate: [{ type: ContentChild, args: ['buttons',] }],
    brandTemplate: [{ type: ContentChild, args: ['brand',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Button component that implements consistent styling, behavior. Button can be rendered either as
 * a button or as a link. It could be standalone or be part of a form.
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *   <aw-form-table >
 *       <aw-form-row [label]="'Amount'" [name]="'amount'" [size]="'small'">
 *
 *           <aw-button [type]="'submit'" [name]="'button'"
 *                     (action)="onClicked($event)" [value]="command"
 *                     [style]="'warning'" >Button</aw-button>
 *       </aw-form-row>
 *   </aw-form-table>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        command:boolean;
 *
 *        constructor ()
 *        {
 *        }
 *
 *        onClicked(value:string) {
 *           if (value) {
 *              // submit form.
 *           }
 *        }
 *    }
 */
class ButtonComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
        /**
         * Button types  [ button | submit | reset ]
         *
         */
        this.type = 'button';
        /**
         * styling for this button. See ButtonStyle for all supported styles.
         */
        this.style = 'primary';
        /**
         * sizing for this button. [large, normal, small].
         */
        this.size = 'normal';
        /**
         * Event fired when user select a item
         */
        this.action = new EventEmitter();
        // Default button class is secondary.
        this.buttonClass = 'ui-button-secondary';
        // Default disabled
        this.disabled = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // How to style this button.
        if (isPresent(this.style)) {
            if (this.style === 'primary') {
                // Default .ui-button and .ui-button-primary get the same style.
                // .ui-button-primary is necessary because button style can be overridden
                // when included inside other widgets. So specify primary
                this.buttonClass = 'ui-button-primary';
            }
            else {
                this.buttonClass = 'ui-button-' + this.style;
            }
        }
        // Determine the button class based on input size.
        if (this.size) {
            switch (this.size) {
                case 'large':
                    this.buttonClass += ' btn-lg';
                    break;
                case 'normal':
                    this.buttonClass += ' btn-mid';
                    break;
                case 'small':
                    this.buttonClass += ' btn-sm';
                    break;
            }
        }
    }
    /**
     * This is little hacky hackity hack as currently primeng button directive does not work with
     * ngcontent projection but it has a label bindings, which is not the way developers work with
     * button. you want to
     *
     * <button> MY CONTENT</button instead of <button label='MyContent'></button>
     *
     *
     * \@Todo: Change this until the time keep a test that check that they are still using ui-button
     *     that we are expecting and replacing
     * @return {?}
     */
    ngAfterViewInit() {
        if (isPresent(this.element)) {
            let /** @type {?} */ button = this.element.nativeElement.querySelector('button');
            let /** @type {?} */ buttonTitle = button.children[0];
            button.children[0].textContent = this.element.nativeElement.textContent.trim()
                .replace('ui-button', '').replace('ui-btn', '');
            button.classList.remove('ui-button-text-empty');
            button.textContent = '';
            button.appendChild(buttonTitle);
        }
    }
    /**
     *  Action clicked. Call parent action.
     * @param {?} $event
     * @return {?}
     */
    clicked($event) {
        this.action.emit(isBlank(this.value) ? $event : this.value);
    }
}
ButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-button',
                template: `<button
    pButton
    [attr.type]="type"
    [attr.name]="name"
    [ngClass]="buttonClass"
    [disabled]="disabled"
    [attr.value]="value"
    (click)="clicked($event)">

    <ng-content></ng-content>
</button>
`,
                styles: [`.ui-button-link{color:#337ab7;font-weight:400;border-radius:0;background-color:transparent}.ui-button-link,.ui-button-link.active,.ui-button-link:active,.ui-button-link:focus,.ui-button-link:hover,.ui-button-link[disabled]{border-color:transparent}.ui-button-link:focus,.ui-button-link:hover{color:#337ab7;-webkit-text-decoration:#337ab7;text-decoration:#337ab7;background-color:transparent}.ui-button-link[disabled]:focus,.ui-button-link[disabled]:hover{color:#2399e5;text-decoration:none}.ui-button{margin-right:5px}.btn-mid{height:36px;padding:5px 10px}.btn-lg{height:42px;font-size:16px;padding:5px 12px}.btn-sm{height:30px;font-size:12px;padding:5px 10px}`]
            },] },
];
/** @nocollapse */
ButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
ButtonComponent.propDecorators = {
    type: [{ type: Input }],
    name: [{ type: Input }],
    style: [{ type: Input }],
    size: [{ type: Input }],
    target: [{ type: Input }],
    value: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWButtonModule {
}
AWButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ButtonComponent
                ],
                imports: [
                    CommonModule,
                    ButtonModule,
                ],
                entryComponents: [
                    ButtonComponent
                ],
                exports: [
                    ButtonComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWBasicNavigatorModule {
}
AWBasicNavigatorModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    BasicNavigatorComponent
                ],
                imports: [
                    CommonModule,
                    ToolbarModule,
                    AWButtonModule,
                    AWCoreComponentModule
                ],
                exports: [
                    BasicNavigatorComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class CardZoneTopComponent {
}
CardZoneTopComponent.decorators = [
    { type: Directive, args: [{
                selector: `aw-card-top`,
                host: {
                    'class': 'w-card-ztop'
                }
            },] },
];
class CardZoneBottomComponent {
}
CardZoneBottomComponent.decorators = [
    { type: Directive, args: [{
                selector: `aw-card-bottom`,
                host: {
                    'class': 'w-card-zbottom'
                }
            },] },
];
/**
 *
 * Card component is a container rendering its content inside 3 different zones.
 *
 *  ------------------------------------------
 *  |   TITLE                       | ACTION |
 *  |-----------------------------------------
 *  |                                        |
 *  |   TOP                                  |
 *  |                                        |
 *  ------------------------------------------
 *  |                                        |
 *  |   BOTTOM                               |
 *  |                                        |
 *  |                                        |
 *  ------------------------------------------
 *
 *
 *  There are 3 zones  + 1 placeholder for the actionIcon
 *
 *  Cards can be selectable which means when you click on it there will be rendered a border with
 *  a check mark inside Action zone (this is default behavior).
 *  You can use [selectable] binding to disable this, in such case card will have just a border
 *  without any check mark.
 *
 *  Cards can also contain custom Action which is rendered inside ACTION zone and on the
 *  application level you can listen for (click) events as well as you can provide your own action
 *  icon
 *
 *  Besides ACTION, TITLE, TOP and BOTTOM content zones cards support hover overlay effect and
 *  when its activated there is a overlay displayed on top of the card with Icon in the middle.
 *  Please note when [hasHover] is TRUE all the actions and selectability are disabled as there is
 *  only one action which click on the hover overlay.
 *
 *
 * ###example 1:
 *  Basic hover card which by default support selectable mode
 *
 * ```
 *          <aw-card #card1 [hasAction]="false" [width]="'202px'" [height]="'154px'">
 *
 *                 <aw-card-title [align]="'bottom-left'">
 *                     <span class="a-supplier-tag">
 *                         Preferred
 *                     </span>
 *                 </aw-card-title>
 *
 *                 <aw-card-top>
 *                     <div class="supplierName">
 *                         Haight Pumps
 *                     </div>
 *                     <div class="supplierLocation">
 *                         Palo Alto, CA, USA
 *                     </div>
 *                 </aw-card-top>
 *
 *                 <aw-card-bottom class="w-card-zbottom">
 *                     some text about the supplier and his parents<br/>
 *                     and some contacts
 *                 </aw-card-bottom>
 *
 *             </aw-card>
 *
 * ```
 *
 *  ###example 2:
 *   Hover card with custom action. when unselected action will appear and user can click on it.
 *
 * ```
 *          <aw-card #card1 [selectable]="true" [actionIcon]="'icon-question-mark'"
 *                     (onAction)="onAction(3, $event)">
 *
 *                 <aw-card-title [align]="'bottom-left'">
 *                     <span class="a-supplier-tag">
 *                         Preferred
 *                     </span>
 *                 </aw-card-title>
 *
 *                 <aw-card-top>
 *                     <div class="supplierName">
 *                         Haight Pumps
 *                     </div>
 *                     <div class="supplierLocation">
 *                         Palo Alto, CA, USA
 *                     </div>
 *                 </aw-card-top>
 *
 *                 <aw-card-bottom class="w-card-zbottom">
 *                     some text about the supplier and his parents<br/>
 *                     and some contacts
 *                 </aw-card-bottom>
 *
 *             </aw-card>
 *
 * ```
 *
 *
 *
 */
class CardComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Tells if we should explicitly hide the action
         *
         */
        this.hasAction = false;
        /**
         *
         * Is selectable mode supported? Saying Yes, card will have by default check-mark in the
         * ACTION zone when selected
         *
         */
        this.selectable = true;
        /**
         * Option to pass custom "Card Selected" Icon
         *
         */
        this.selectedIcon = 'icon-accept';
        /*
             * Enable and disables hover effect on top of the card
             */
        this.hasHover = false;
        /**
         *
         * Default icon name for the hover overlay. This icons shows up in the middle over the card
         * vertically and horizontally centered
         *
         */
        this.hoverIcon = 'icon-add';
        /**
         *  Selection state
         *
         */
        this.selected = true;
        /**
         * Fired when the card is selected.
         *
         */
        this.onSelect = new EventEmitter();
        /**
         * Fired when action icon is clicked.
         *
         */
        this.onAction = new EventEmitter();
        /**
         * Fired when the user clicks on the hover overlay.
         *
         */
        this.onHoverAction = new EventEmitter();
        /**
         * Usually when template is provided we want to use it and replace internal one but in this
         * case it will be always conditional and application developer can switch between default
         * template with zones and custom one provided by developer.
         *
         */
        this.useBodyTemplate = false;
        // sets default value
        this.width = '202px';
        this.height = '154px';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // If application wants to use action it must provide actionIcon
        if (isBlank(this.actionIcon) && this.hasAction) {
            throw new Error('You need to provide action icon');
        }
    }
    /**
     * @return {?}
     */
    showBottomSection() {
        return isPresent(this.bottom);
    }
    /**
     * fires select and unselect event.
     * @param {?} event
     * @return {?}
     */
    toggleSelect(event) {
        if (!this.selectable) {
            event.preventDefault();
            event.stopPropagation();
        }
        else {
            this.selected = !this.selected;
            this.onSelect.emit(this.selected);
        }
    }
    /**
     *
     * Only fired when action is rendered and user clicks on custom actionIcon
     *
     * @param {?} event
     * @return {?}
     */
    onActionClick(event) {
        if (this.hasAction && (!this.selected || !this.selectable)) {
            this.onAction.emit(this.selected);
        }
    }
    /**
     * Triggered  when hover effect is on + user click on the card
     *
     * @param {?} isEnter
     * @return {?}
     */
    onHover(isEnter) {
        if (isPresent(this.hoverDiv)) {
            this.hoverDiv.nativeElement.style.opacity = isEnter ? 0.5 : 0;
        }
    }
    /**
     *
     * Used to decide if we should render implicit card template with our zones or
     * user provided template
     *
     * @return {?}
     */
    showBodyTemplate() {
        return isPresent(this.bodyTemplate) && this.useBodyTemplate;
    }
}
CardComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-card',
                template: `<div class="w-card" [style.width]="width" [style.height]="height"
     [class.u-is-hover]="hasHover"
     (mouseenter)="onHover(true)"
     (mouseleave)="onHover(false)"
     [class.u-card-selected]="selected"
     [class.u-card-unselected]="!selected"
     [ngClass]="styleClass"
>

    <div class="card-body ui-g"  *ngIf="!showBodyTemplate()">
        <!-- Hover element that is triggered by mouseenter, mouseleave events-->
        <div #hoverDiv *ngIf="hasHover" class="u-card-hover" (click)="onHoverAction.emit($event)">
            <span [style.width]="'100%'" class="sap-icon" [ngClass]="hoverIcon"></span>
        </div>
        <!-- HEADER HAVING TITLE AND ICONS/ACTIONS-->
        <div class="ui-g-12 ui-g-nopad w-card-header">
            <div class="w-card-ztitle ui-g-nopad" (click)="toggleSelect($event)"
                 [class.u-card-pointer]="selectable"
                 [ngClass]="{'ui-g-9': hasAction || selectable, 'ui-g-11': !hasAction && !selectable}">
                <ng-content select="aw-card-title"></ng-content>
            </div>

            <div *ngIf="hasAction || selectable" class="w-card-zaction ui-g-nopad ui-g-3">

                <span *ngIf="selected && selectable" class="sap-icon selection"
                      [class.u-card-pointer]="selectable"
                      [class.u-card-action-bg]="selected"
                      (click)="toggleSelect($event)"
                      [ngClass]="selectedIcon"></span>


                <span *ngIf="hasAction && (!selected || !selectable) "
                      class="sap-icon action"
                      [class.u-card-pointer]="true"
                      (click)="onActionClick($event)"
                      [ngClass]="actionIcon"
                ></span>
            </div>
        </div>

        <!--TOP CARD SECTION-->
        <div class="w-card-ztop ui-g-nopad ui-g-12 "
             (click)="toggleSelect($event)"
             [class.u-card-pointer]="selectable">
            <ng-content select="aw-card-top"></ng-content>
        </div>

        <div class="ui-g-12 ui-g-nopad w-card-line-divider  " *ngIf="showBottomSection()"></div>
        <!--BOTTOM CARD SECTION-->
        <div *ngIf="showBottomSection()" class="ui-g-12 ui-g-nopad w-card-zbottom"
             [class.u-card-pointer]="selectable"
             (click)="toggleSelect($event)">
            <ng-content select="aw-card-bottom"></ng-content>
        </div>
    </div>

    <div *ngIf="showBodyTemplate()" class="w-card-user-cnt" >
        <ng-container *ngTemplateOutlet="bodyTemplate">
        </ng-container>
    </div>

</div>
`,
                styles: [`.w-card{border:2px solid #0076cb;display:inline-block;overflow:hidden;color:#636363;box-sizing:border-box}.w-card-header{position:relative;height:30px;padding-left:1em}.w-card-ztitle{height:100%;padding-top:3px}.w-card-ztitle ::ng-deep .w-card-title{height:100%;width:100%;display:flex}.w-card-ztitle ::ng-deep .w-card-title>*{flex:0 1}.w-card-zaction{height:100%;display:inline-block;text-align:right}.w-card-zaction .sap-icon{width:29px;height:29px;text-align:center;display:inline-block;font-size:1.5em;line-height:1.4em}.w-card-zaction .sap-icon.selection{color:#fff}.w-card-zaction .sap-icon.action{color:#969696}.w-card-zbottom,.w-card-ztop{padding:1em}.w-card-line-divider{border-top:1px solid #d6d6d6;margin:0 14px}.w-card-user-cnt{width:100%;height:100%;position:relative;background-color:#eee}.u-card-hover{position:absolute;height:100%;width:100%;opacity:0;transition:.5s ease;background-color:#0076cb;z-index:100}.u-card-hover .sap-icon{text-align:center;display:inline-block;font-size:4em;color:#fff;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.u-card-action-bg{background:#0076cb}.u-is-hover{position:relative}.u-card-selected{border-color:#0076cb}.u-card-unselected{border-color:#d7d7d7}.u-card-hover,.u-card-pointer{cursor:pointer}`]
            },] },
];
/** @nocollapse */
CardComponent.ctorParameters = () => [
    { type: Environment }
];
CardComponent.propDecorators = {
    hasAction: [{ type: Input }],
    selectable: [{ type: Input }],
    selectedIcon: [{ type: Input }],
    actionIcon: [{ type: Input }],
    hasHover: [{ type: Input }],
    hoverIcon: [{ type: Input }],
    selected: [{ type: Input }],
    onSelect: [{ type: Output }],
    onAction: [{ type: Output }],
    onHoverAction: [{ type: Output }],
    bottom: [{ type: ContentChild, args: [CardZoneBottomComponent,] }],
    bodyTemplate: [{ type: ContentChild, args: ['body',] }],
    hoverDiv: [{ type: ViewChild, args: ['hoverDiv',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Maps our internal alignment value to real css values
 *
 */
const /** @type {?} */ VAlignMap = {
    'top-left': 'flex-start',
    'top-center': 'flex-start',
    'top-right': 'flex-start',
    'center-left': 'center',
    'center-center': 'center',
    'center-right': 'center',
    'bottom-left': 'flex-end',
    'bottom-center': 'flex-end',
    'bottom-right': 'flex-end'
};
const /** @type {?} */ HAlignMap = {
    'top-left': 'flex-start',
    'top-center': 'center',
    'top-right': 'flex-end',
    'center-left': 'flex-start',
    'center-center': 'center',
    'center-right': 'flex-end',
    'bottom-left': 'flex-start',
    'bottom-center': 'center',
    'bottom-right': 'flex-end'
};
/**
 * Title zone provides a content placeholder for the Title Area. This zone is adding ability
 * to align its content into 9 different position.
 *
 * You can use this Title zone within <aw-card> as:
 *
 *
 * ```html
 *
 *  <aw-card  [width]="'202px'" [height]="'154px'" [hasHover]="true"
 *                       [selectable]="false" [hasAction]="false"
 *                  (onHoverAction)="onAction(7, $event)" >
 *
 *                  <aw-card-title [align]="'bottom-left'">
 *                      <span class="a-supplier-tag">
 *                          Preferred
 *                      </span>
 *                  </aw-card-title>
 *
 *   </aw-card>
 *
 * ```
 * Default alignment is top-left
 *
 *
 *
 *
 */
class CardZoneTitleComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} elem
     */
    constructor(env, elem) {
        super(env);
        this.env = env;
        this.elem = elem;
        /**
         * Special property which is used to apply flex properties for aligning content vertically
         * as well as horizontally
         *
         */
        this.align = 'top-left';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.elem.nativeElement.style.alignItems = VAlignMap[this.align];
        this.elem.nativeElement.style.justifyContent = HAlignMap[this.align];
    }
}
CardZoneTitleComponent.decorators = [
    { type: Directive, args: [{
                selector: `aw-card-title`,
                host: {
                    'class': 'w-card-title'
                }
            },] },
];
/** @nocollapse */
CardZoneTitleComponent.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef }
];
CardZoneTitleComponent.propDecorators = {
    align: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWCardModule {
}
AWCardModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    CardComponent,
                    CardZoneTitleComponent,
                    CardZoneTopComponent,
                    CardZoneBottomComponent
                ],
                entryComponents: [
                    CardComponent
                ],
                exports: [
                    CardComponent,
                    CardZoneTitleComponent,
                    CardZoneTopComponent,
                    CardZoneBottomComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Implements standard HTML checkbox on top of PrimeNG. There are 2 types of
 * {\@link CheckboxComponent}: form and action checkbox as described above.
 *
 *
 * Usage: Basic example having red checkbox checked
 *
 * ```HTML
 *        <aw-checkbox [name]="'color'" [value]="'red'" [label]="'Red'"
 *                                        [(ngModel)]="model">
 *        </aw-checkbox>
 *        <aw-checkbox [name]="'color'" [value]="'blue'" [label]="'Blue'"
 *                                        [(ngModel)]="model">
 *       </aw-checkbox>
 *
 * ```
 *
 * ```ts
 *
 *
 *   class CBBasicWithNgModelComponent
 *   {
 *
 *       model: string[] = ['red'];
 *
 *       constructor()
 *       {
 *       }
 *   }
 *
 * ```
 *
 * For more examples please see a playground or unit test.
 *
 */
const /** @type {?} */ CB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckboxComponent),
    multi: true
};
class CheckboxComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value associated with this checkbox
         *
         */
        this.value = '';
        /**
         * Type of checkbox. Form based updates model and Action based only fires click events
         *
         */
        this.type = 'form';
        /**
         * Trigger click event.
         *
         */
        this.action = new EventEmitter();
        /**
         * PrimeNG has this type called binary which works only with Boolean meaning it does not add or
         * remove values.
         *
         * In our case Checktype = Action is always binary or when this.value is boolean
         *
         */
        this.isBinary = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.model = this.value;
        this.type = this.action.observers.length > 0 ? 'action' : this.type;
        if (this.isFormType()) {
            super.ngOnInit();
            if (this.isStandalone) {
                super.registerFormControl(this.value);
                this.model = this.formControl.value;
                this.onModelChanged(this.model);
            }
            else {
                // get control from parent
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
        // When value is boolean we are dealing with PrimeNg Binary checkbox
        // which only sets TRUE/FALSE and does not add or remove values
        this.isBinary = isBoolean(this.value);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (isPresent(changes['value']) &&
            (changes['value'].currentValue !== changes['value'].previousValue)) {
            this.model = changes['value'].currentValue;
        }
    }
    /**
     * Called when Checkbox is clicked and it either fire action or updates the model.
     *
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        if (this.isFormType()) {
            this.onModelChanged(this.model);
            if (this.isStandalone) {
                this.formControl.setValue(this.model);
            }
        }
        else {
            this.action.emit(event);
        }
    }
    /**
     *
     * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
     * applicable for certain type.
     *
     * @return {?}
     */
    isFormType() {
        return this.type === 'form';
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.model && this.isFormType()) {
            this.model = value;
            if (this.isStandalone) {
                this.onModelChanged(this.model);
                this.formControl.setValue(this.model);
            }
        }
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-checkbox',
                template: `<span class="w-checkbox">

    <ng-template [ngIf]="editable && isFormType()">
        <p-checkbox [name]="name" [value]="value" [label]="label"
                    [(ngModel)]="model"
                    [binary]="isBinary"
                    (onChange)="onChange($event)"
                    [disabled]="disabled"
                    [class.u-validation-error]="!(formControl.valid || (formControl.pristine))"
        >
        </p-checkbox>
    </ng-template>


    <ng-template [ngIf]="!isFormType()">
        <p-checkbox [binary]="isBinary"
                    [label]="label"
                    [(ngModel)]="model"
                    (onChange)="onChange($event)"
                    [disabled]="disabled">
        </p-checkbox>

    </ng-template>
</span>
`,
                styles: [`/deep/ .ui-chkbox .ui-chkbox-box{width:22px;height:22px}/deep/ .ui-chkbox .pi{font-family:"SAP icon fonts";color:#199de0;cursor:pointer;font-size:1.07em;line-height:1.42em}/deep/ .ui-chkbox .pi.pi-check:before{content:'\\e05b'}`],
                providers: [
                    CB_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => CheckboxComponent) }
                ]
            },] },
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
CheckboxComponent.propDecorators = {
    value: [{ type: Input }],
    type: [{ type: Input }],
    label: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWCheckBoxModule {
}
AWCheckBoxModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CheckboxComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CheckboxModule
                ],
                entryComponents: [
                    CheckboxComponent
                ],
                exports: [
                    CheckboxComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  Checkbox list is a wrapper class around 'Checkbox' component to simply assembly of multi choice
 * component
 *
 * In Addition it adds ability to work with complex object. PrimeNG checkboxes work only with
 * primitive values.
 *
 * @see {\@link check-box/check-box.component.ts}
 *
 *
 * ### Example
 *
 *
 * \@Component({
 *       selector: 'showCheckBoxList' ,
 *       template: `
 *           <aw-checkbox-list [list]="checkBoxListValues" [selections]="selectedValues"
 *
 *            [name]="'myColors'" [formGroup]="formGroup" (onSelection)="onCBClick">
 *           </aw-checkbox-list>
 *       `
 *
 *       })
 *        class MyShowCLComponent
 *        {
 *            checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' ,
 *     'silver' , 'black' ,
 *            'Green' , 'Gray' , 'Navy' , 'Olive' , 'Aqua' , 'Purple'];
 *
 *            selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
 *
 *
 *            formGroup: FormGroup = new FormGroup({});
 *
 *
 *            onCBClick (event): void
 *            {
 *                console.log('onCBClick = ' + event);
 *            }
 *
 *        }
 * *
 */
const /** @type {?} */ CB_LIST_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CheckBoxListComponent),
    multi: true
};
class CheckBoxListComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} cd
     * @param {?} parentContainer
     */
    constructor(env, cd, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.cd = cd;
        this.parentContainer = parentContainer;
        /**
         * Fires event when checkbox is selected/clicked. Emits current clicked checkboxed. not the
         * actuall internal model value in this case array of choices
         *
         */
        this.onSelection = new EventEmitter();
        /**
         * Internal model
         */
        this.model = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.selections)) {
            this.selections = [];
        }
        this.registerFormControl(this.selections);
        this.updateModel(this.selections);
        this.onModelChanged(this.selections);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ updatedModel = [];
        this.model.forEach((index) => updatedModel.push(this.list[index]));
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
        this.cd.detectChanges();
    }
    /**
     * Label is extracted into this method so in the future we can play more how we want to display
     * the value. Since I want to support formatters for each components we might have a chance to
     * decide how label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    labelValue(item) {
        if (isPresent(this.labelFormatter)) {
            return this.labelFormatter(item);
        }
        return item.toString();
    }
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     * @param {?} item
     * @return {?}
     */
    value(item) {
        return item;
    }
    /**
     * Delegate event outside of this component and convert indexed model to original objects
     *
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        let /** @type {?} */ updatedModel = [];
        this.model.forEach((index) => {
            updatedModel.push(this.list[index]);
        });
        this.onSelection.emit(updatedModel);
        this.onModelChanged(updatedModel);
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
    }
    /**
     * Since we might be dealing with complex object store only INDEXes number in the model.
     *
     * @param {?} sourceList
     * @return {?}
     */
    updateModel(sourceList) {
        sourceList.forEach((item) => {
            let /** @type {?} */ index = this.list.findIndex((elem) => {
                return equals(item, elem);
            });
            this.model.push(index);
        });
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (isPresent(this.model) && isPresent(value)) {
            let /** @type {?} */ newModel = value;
            this.updateModel(newModel);
            // this.cd.markForCheck();
        }
    }
}
CheckBoxListComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-checkbox-list',
                template: `<div *ngFor="let item of list; let i = index" class="ui-g">

    <!-- in the future we should be able to to support inline and stack-->
    <div class="ui-g-12">
        <aw-checkbox [(ngModel)]="model"
                     (ngModelChange)="onChange($event)"
                     [editable]="editable"
                     [isStandalone]="false"
                     [name]="name"
                     [value]="i"
                     [label]="labelValue(item)">

        </aw-checkbox>
    </div>

</div>

`,
                styles: [``],
                providers: [
                    CB_LIST_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => CheckBoxListComponent) }
                ]
            },] },
];
/** @nocollapse */
CheckBoxListComponent.ctorParameters = () => [
    { type: Environment },
    { type: ChangeDetectorRef },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
CheckBoxListComponent.propDecorators = {
    list: [{ type: Input }],
    selections: [{ type: Input }],
    onSelection: [{ type: Output }],
    labelFormatter: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWCheckBoxListModule {
}
AWCheckBoxListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CheckBoxListComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCheckBoxModule
                ],
                exports: [
                    CheckBoxListComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Hyperlink component that implements consistent styling, behavior. Hyperlink supports all of the
 * native link functionality. In addition, it supports navigation to components through the action
 * binding.
 *
 *
 * for more info please see class Doc of the:
 * @see {\@link button/button.component.ts}
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *           <aw-hyperlink  [type]="'text/html'" [name]="'link'"
 *                        (action)="onClicked($event)" [value]="customerId"
 *                        [size]="'large'" >my link</aw-hyperlink>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        command:boolean;
 *
 *        constructor ()
 *        {
 *        }
 *
 *        onClicked(customerId:string) {
 *           if (customerId) {
 *              // display customer details component.
 *           }
 *        }
 *    }
 */
class HyperlinkComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * sizing for this link. [large, normal, small].
         */
        this.size = 'normal';
        /**
         * Event fired when user select a item
         */
        this.action = new EventEmitter();
        /**
         * Internal CSS class that styles this hyperlink based on input 'size'
         */
        this.linkClass = 'link';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // Determine the link class based on input size.
        if (this.size) {
            switch (this.size) {
                case 'large':
                    this.linkClass += ' link-lg';
                    break;
                case 'normal':
                    this.linkClass += ' link-mid';
                    break;
                case 'small':
                    this.linkClass += ' link-sm';
                    break;
            }
        }
        // If I have an action tag, and no href. We add default styling and behavior.
        if (this.action.observers.length > 0) {
            this.linkClass += ' link-bh';
        }
    }
    /**
     *  Action clicked. Call parent action.
     * @param {?} event
     * @return {?}
     */
    clicked(event) {
        this.action.emit({
            event: event,
            value: this.value
        });
    }
}
HyperlinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-hyperlink',
                template: `<a [attr.type]="type"
   [attr.href]="href"
   [attr.rel]="rel"
   [attr.target]="target"
   [ngClass]="linkClass"
   [class.disabled]="disabled"
   (click)="clicked($event)">

    <ng-content></ng-content>
</a>
`,
                styles: [`.link{color:#0275d8;cursor:pointer}.link.link-bh{color:#0275d8}.link.link-bh:hover{text-decoration:underline;cursor:pointer}.link-sm{font-size:.875em}.link-mid{font-size:1em}.link-lg{font-size:1.25em}.link.disabled{pointer-events:none;cursor:default;color:#ddd}`]
            },] },
];
/** @nocollapse */
HyperlinkComponent.ctorParameters = () => [
    { type: Environment }
];
HyperlinkComponent.propDecorators = {
    type: [{ type: Input }],
    href: [{ type: Input }],
    rel: [{ type: Input }],
    size: [{ type: Input }],
    target: [{ type: Input }],
    value: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWHyperlinkModule {
}
AWHyperlinkModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    HyperlinkComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    HyperlinkComponent
                ],
                exports: [
                    HyperlinkComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Selection State for the chooser in order to be able to comunicate with the parent object using a
 * chooser. If I would have to manage only single values with no addional methods i would user
 * emitters to do the job, but in this case we need this interface (abstract class) between a
 * chooser and actual object.
 *
 *
 * @abstract
 */
class ChooserSelectionState {
    /**
     *
     * Set selection state is usually triggered by selecting and unselecting a item (in case of
     * multiselect) and it should update its list of objects with either settings/adding item or
     * removing it.
     *
     *
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
    }
    /**
     * The most recent selection . Null if last action was a deselection. Usually used by Chooser
     * or ChooserState to get cuurent value.
     *
     * @return {?}
     */
    selectedObject() {
        return unimplemented();
    }
    /**
     * The most recent selections.
     *
     * @return {?}
     */
    selectedObjects() {
        return unimplemented();
    }
    /**
     *
     * Check if the item selection items is in the selectedObjects
     * @param {?} selection
     * @return {?}
     */
    isSelected(selection) {
        return unimplemented();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
 * selection as well as it can broadcast any updates.
 *
 *
 */
class ChooserState {
    /**
     * @param {?=} chooserSelectionState
     * @param {?=} isMulti
     */
    constructor(chooserSelectionState, isMulti = true) {
        /**
         * Indicates if there are any validation like entered value does not much with the source list.
         *
         */
        this.isInvalid = false;
        /**
         *
         * indicates that we started to some editing e.g. starting to type in something into the
         * filter, or removing already selected items
         */
        this.addMode = false;
        this.recentSelectedDisplayed = 0;
        /**
         * When this option is active we do not show all selected items, but max number that is
         * defined. User is able to toggle to expand the view to see all selections and hide them as
         * well
         */
        this.showAllRecentlySelected = false;
        this.selectionState = chooserSelectionState;
        this.multiselect = isMulti;
        if (isBlank(this.selectionState)) {
            this.selectionState = new DefaultSelectionState(this.multiselect);
        }
    }
    /**
     *
     * It will select and persist an item using ChooserSelectionState provider.
     *
     * @param {?} item
     * @return {?}
     */
    updatedSelectedObjects(item) {
        if (isBlank(item)) {
            item = this.currentItem;
        }
        if (!this.multiselect) {
            this.setSelectionState(item, true);
        }
        else {
            let /** @type {?} */ selectedObject = this.selectedObject();
            let /** @type {?} */ selectedObjects = this.selectedObjects();
            if (this.addMode) {
                if (this.isInvalid) {
                    if (isPresent(selectedObject)) {
                        this.setSelectionState(selectedObject, false);
                    }
                }
                this.setSelectionState(item, !ListWrapper.containsComplex(selectedObjects, item));
            }
            else {
                if (isPresent(selectedObject)) {
                    this.setSelectionState(selectedObject, false);
                }
                this.setSelectionState(item, true);
            }
        }
    }
    /**
     * When user selection is large we use this method to check if we need to show all selected
     * items or only MaxRecentSelected
     * @return {?}
     */
    toggleAllSelected() {
        this.showAllRecentlySelected = !this.showAllRecentlySelected;
    }
    /**
     *
     * Renders user's selection under the input field
     *
     * @return {?}
     */
    get recentSelectedObjects() {
        if (!this.multiselect) {
            return [];
        }
        let /** @type {?} */ recentSelectedObjects = [];
        this.recentSelectedDisplayed = 0;
        let /** @type {?} */ selectedObjects = this.selectedObjects();
        let /** @type {?} */ size = selectedObjects.length;
        let /** @type {?} */ maxCount = DataSource.MaxRecentSelected;
        if (size > DataSource.MaxRecentSelected && !this.showAllRecentlySelected) {
            maxCount -= 1;
        }
        if (this.showAllRecentlySelected) {
            maxCount = size;
        }
        for (let /** @type {?} */ i = size - 1; i >= 0 && (this.recentSelectedDisplayed < maxCount); i--) {
            let /** @type {?} */ selection = selectedObjects[i];
            recentSelectedObjects.push(selection);
            this.recentSelectedDisplayed++;
        }
        return recentSelectedObjects;
    }
    /**
     * @return {?}
     */
    selectedObject() {
        return this.selectionState.selectedObject();
    }
    /**
     * @return {?}
     */
    selectedObjects() {
        return this.selectionState.selectedObjects();
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
        if (isPresent(selection)) {
            this.selectionState.setSelectionState(selection, selected);
        }
    }
}
/**
 * Dummy implementation ChooserSelectionState
 */
class DefaultSelectionState extends ChooserSelectionState {
    /**
     * @param {?} multiSelect
     */
    constructor(multiSelect) {
        super();
        this.multiSelect = multiSelect;
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
        if (selected) {
            this._selectedObject = selection;
            if (this.multiSelect && !ListWrapper.containsComplex(this.selectedObjects(), selection)) {
                this.selectedObjects().push(selection);
            }
        }
        else {
            if (this.multiSelect) {
                ListWrapper.removeIfExist(this.selectedObjects(), selection);
            }
        }
    }
    /**
     * @return {?}
     */
    selectedObject() {
        return this._selectedObject;
    }
    /**
     * @return {?}
     */
    selectedObjects() {
        if (isBlank(this._selectedObjects)) {
            this._selectedObjects = [];
        }
        return this._selectedObjects;
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    isSelected(selection) {
        return super.isSelected(selection);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
 *
 * 1) You can use default DataSource injected inside component constructor and just call
 * initialize to configure it with correct DataProvider and DataFinder:
 *
 *
 * ```
 *   this.dataSource.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 * and then you can use it to simply retrieve data or run queries.
 *
 * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
 * binding
 *
 * ```
 *
 *   this.ds = new ChooserDataSource(this.data, this.finders);
 *   this.ds.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 *
 */
class ChooserDataSource extends DataSource {
    /**
     * @param {?} dataProviders
     * @param {?} finders
     */
    constructor(dataProviders, finders) {
        super(dataProviders, finders);
        this.dataProviders = dataProviders;
        this.finders = finders;
    }
    /**
     * To initialize this DataSource with current DataFinder and Provider as well as state we use
     * an interface DSChooserInitParams to have all init values typed checked
     *
     *
     * @param {...?} args
     * @return {?}
     */
    init(...args) {
        if (isBlank(args) || args.length !== 1 && !isDSChooserInitParams(args[0])) {
            throw new Error('You need to initialize DS with (DSChooserInitParams)');
        }
        let /** @type {?} */ init = args[0];
        this.dataProvider = isPresent(init.dataProvider) ? init.dataProvider
            : this.dataProviders.find(init.obj);
        this.dataFinder = isPresent(init.dataFinder) ? init.dataFinder
            : this.finders.find(this.dataProvider, init.queryType);
        assert(isPresent(this.dataProvider) && isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
        if (isPresent(init.state)) {
            this.state = init.state;
        }
        else {
            this.state = new ChooserState(null, init.multiselect);
        }
        this.dataFinder.lookupKey = init.lookupKey;
        this.state.lookupKey = init.lookupKey;
    }
    /**
     * @param {?} pattern
     * @param {?} max
     * @return {?}
     */
    find(pattern, max) {
        this.state.pattern = pattern;
        this.state.lastFullMatchPattern = pattern;
        if (pattern.length === 0) {
            return;
        }
        if (pattern === '*') {
            // query everything
            pattern = '';
        }
        // make sure we dataFinder has expected lookup key
        let /** @type {?} */ origKey = this.dataFinder.lookupKey;
        this.dataFinder.lookupKey = this.state.lookupKey;
        this.dataFinder.forData(this.dataProvider).match(pattern, max)
            .subscribe((result) => {
            this.state.matches = result;
            if (this.state.multiselect) {
                for (let /** @type {?} */ i = 0; i < this.state.selectedObjects().length; i++) {
                    let /** @type {?} */ item = this.state.selectedObjects()[i];
                    ListWrapper.removeIfExist(this.state.matches, item);
                }
            }
            this.dataFinder.lookupKey = origKey;
        });
    }
    /**
     *
     * When multiselect this method checks if we need to show SHOW MORE label under the selected
     * items. We do not want show e.g. 50 selection under the chooser that would take up whole
     * page.
     *
     * @return {?}
     */
    showMoreSelected() {
        return this.state.selectedObjects().length >= DataSource.MaxRecentSelected;
    }
    /**
     * @template T
     * @return {?}
     */
    open() {
        return this.dataProvider.dataChanges.asObservable();
    }
    /**
     * @return {?}
     */
    close() {
        this.dataProvider = null;
        this.dataFinder = null;
        this.state = null;
    }
    /**
     * @template T
     * @return {?}
     */
    instant() {
        return this.dataProvider.data();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    updateValue(value) {
        this.state.addMode = true;
        if (isArray(value)) {
            let /** @type {?} */ items = value;
            items.forEach((item) => this.state.updatedSelectedObjects(item));
        }
        else {
            this.state.updatedSelectedObjects(value);
        }
        this.state.addMode = false;
    }
    /**
     * @return {?}
     */
    get lookupKey() {
        return this.dataFinder.lookupKey;
    }
}
/**
 * @param {?} init
 * @return {?}
 */
function isDSChooserInitParams(init) {
    return isPresent(init.obj) || isPresent(init.queryType);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Typeahead chooser that supports both single and multi-select. Not like Dropdown, this chooser
 * requires little bit different setup. It requires at minimum \@Input dataSource or
 * destinationClass
 *
 *
 * By default chooser is multi-select. If you want single select then you must provide multi-select
 * with \@Input.
 *
 * ### Example
 *
 * In simple scenario you can use Chooser like so:
 *
 *
 * ```
 * \@Component({
 *      selector: 'chooser-app' ,
 *      template: `<aw-chooser  [formGroup]="formGroup" name="color"'
 *                      [dataSource]="ds"></aw-chooser>`
 *  })
 *  export class MyChooserApp
 *  {
 *
 *      ds: ChooserDataSource;
 *
 *     constructor(private data: DataProviders, private finders: DataFinders){
 *          this.ds = new ChooserDataSource(this.data, this.finders);
 *
 *       this.ds.init({
 *           obj: ['blue', 'red', 'yellow'], queryType: QueryType.FullText, state: null,
 *            multiselect: true
 *       });
 *
 *     }
 *  }
 *
 * ````
 *  Above example will use provided dataSource and render multi-select chooser. With default
 *  implementation  selected values will appear as a tags under the input box
 *
 *
 *
 * * ### Example
 *
 *  In this example we provide custom template to change the way how chooser's MenuItem are
 *     rendered as well as template for the selection item looks like
 *
 * ```
 * \@Component({
 *      selector: 'chooser-app' ,
 *      template: `<aw-chooser  name="commodity"' [dataSource]="ds">
 *
 *          <ng-template #menuItem let-item>
 *             	<span>
 *             		<i class="fa fa-envira " ></i>
 *             		{{item}}
 *             	</span>
 *
 *          </ng-template>
 *
 *          <ng-template #selectionItem let-item>
 *             	<span class="tag tag-circle">
 *             		item: {{item }}
 *             		<i class="fa fa-close" (click)="chooser.removeValue(item)"></i>
 *             	</span>
 *
 *
 *          </ng-template>
 *
 *
 *          </aw-chooser>
 *      `
 *      style: [`
 *              .tag-circle {
 *              	border-radius: 6rem;
 *              	height: 7rem;
 *              	color: #e8eef1;
 *              	background-color: rgba(53, 56, 58, 0.67);
 *              	line-height: 6rem;
 *              }
 *      `]
 *  })
 *
 * ````
 *
 *  In above example we change how the chooser's menu item look like as well as we define custom
 *     template for selection item to turn all selection to circles with text in the middle.
 *
 *
 *
 */
const /** @type {?} */ CHOOSER_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ChooserComponent),
    multi: true
};
class ChooserComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} elemementRef
     * @param {?} _defaultDS
     * @param {?} parentContainer
     */
    constructor(env, elemementRef, _defaultDS, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.elemementRef = elemementRef;
        this._defaultDS = _defaultDS;
        this.parentContainer = parentContainer;
        /**
         * Max number of items return at single Match so we do not return 1000 items at single time.
         *
         */
        this.maxLength = 10;
        /**
         * Max number of items return at single Match so we do not return 1000 items at single time.
         *
         */
        this.minLenForSearch = 1;
        /**
         * Is this multiselect
         *
         */
        this.multiselect = true;
        this.delay = 300;
        /**
         * Event fired when user select a item
         */
        this.onSelection = new EventEmitter();
        if (isBlank(this.placeHolder)) {
            // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
            this.placeHolder = 'Search';
        }
        // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
        this.hideLink = 'Hide';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.dataSource)) {
            this.dataSource = this._defaultDS;
            this.initDatasource();
        }
        if (isPresent(this.formControl) && isPresent(this.formControl.value)) {
            this.dataSource.updateValue(this.formControl.value);
        }
        this.initInternalModel();
        if (this.isStandalone) {
            super.registerFormControl(this.internalChooserModel);
        }
        else {
            if (isPresent(this.name)) {
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
    }
    /**
     * Add Search icon in case of multiselect.
     * todo: Once PrimeNG will provide a template to override default behavior remove it
     *
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.dataSource.state.multiselect) {
            return;
        }
        let /** @type {?} */ searchInput = this.elemementRef.nativeElement.querySelector('.ui-autocomplete-input-token');
        if (isPresent(searchInput)) {
            let /** @type {?} */ iconElement = document.createElement('span');
            iconElement.className = 'search-icon-right fa fa-fw fa-search';
            searchInput.appendChild(iconElement);
        }
        if (isPresent(this.selectionAppendTo) && isPresent(this.selectionViewElem)) {
            let /** @type {?} */ parentElem = this.selectionAppendTo instanceof ElementRef ?
                this.selectionAppendTo.nativeElement : this.selectionAppendTo;
            parentElem.appendChild(this.selectionViewElem.nativeElement);
        }
    }
    /**
     * Need to change current behavior since we want to show selection under the chooser. K
     *
     * @return {?}
     */
    ngAfterViewChecked() {
        if (!this.dataSource.state.multiselect) {
            return;
        }
        let /** @type {?} */ tokens = this.elemementRef.nativeElement.querySelectorAll('.ui-autocomplete .ui-autocomplete-token');
        if (isPresent(tokens) && tokens.length > 0) {
            tokens.forEach((item) => {
                item.remove();
            });
        }
    }
    /**
     *
     * When value is entered into search box, we ask our DataSource to match this pattern
     * against data repository. It will retrieve all possible matches limited by MaxLen and this
     * is again filtered so it does not include already selected items.
     *
     *  the matched resulted is saved in the: this.dataSource.state.matches
     * @param {?} pattern
     * @return {?}
     */
    match(pattern) {
        let /** @type {?} */ maxLen = this.maxLength ? this.maxLength : ChooserDataSource.MaxLength;
        this.dataSource.find(pattern, maxLen);
        // fix: for tests: In version 4 we need to explicitly focus input otherwise autocomplete
        // doesn't give us any popup panel
        if (this.env.inTest && isPresent(this.autoCompleteComponent)) {
            this.autoCompleteComponent.focusInput();
        }
    }
    /**
     *
     * Invoked by Dropdown button in case of single select and here we want to invoke match
     * to retrieve all suggestions without any filter
     *
     * @param {?} event
     * @return {?}
     */
    onDropdownClick(event) {
        this.match('*');
        setTimeout(() => {
            this.match('*');
        }, 100);
    }
    /**
     *
     * Chooser state is updated  with user selection. Please see writeValue. When do not need
     * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
     * shares the same references so its important that we first save reference to
     * this.chooserState.selectedObjects() and then back to internalChooserModel
     *
     * @param {?} item
     * @return {?}
     */
    selectItem(item) {
        this.onSelection.emit(this.internalChooserModel);
        this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
        this.formControl.markAsDirty({ onlySelf: true });
        this.dataSource.state.addMode = true;
        this.onModelChanged(this.internalChooserModel);
        this.dataSource.state.updatedSelectedObjects(item);
        this.dataSource.state.addMode = true;
        if (!this.dataSource.state.multiselect) {
            this.autoCompleteComponent.inputEL.nativeElement.value =
                this.displayItem(this.internalChooserModel);
        }
    }
    /**
     *
     * Unselect item
     *
     * @param {?} item
     * @return {?}
     */
    removeValue(item) {
        this.dataSource.state.addMode = true;
        this.dataSource.state.updatedSelectedObjects(item);
        this.dataSource.state.addMode = false;
        this.internalChooserModel = this.dataSource.state.selectedObjects();
        this.onSelection.emit(this.internalChooserModel);
        this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
        this.formControl.markAsDirty({ onlySelf: true });
        this.onModelChanged(this.internalChooserModel);
        if (isPresent(this.autoCompleteComponent)) {
            this.autoCompleteComponent.focusInput();
        }
    }
    /**
     *
     * Convert a object if any into the string representation
     *
     * todo: implement better way how to work with objects
     *
     * @param {?} item
     * @return {?}
     */
    displayItem(item) {
        if (isBlank(item)) {
            return null;
        }
        this.dataSource.state.currentItem = item;
        if (isPresent(this.valueTransformer)) {
            return this.valueTransformer(item);
        }
        else if (isPresent(this.dataSource.lookupKey)) {
            return item[this.dataSource.lookupKey];
        }
        else {
            return item.toString();
        }
    }
    /**
     *
     * Returns a label that is shown under the selected item when user selection is >
     * MaxRecentSelected
     *
     * @return {?}
     */
    moreSelectString() {
        let /** @type {?} */ moreSelected = this.dataSource.state.selectedObjects().length -
            this.dataSource.state.recentSelectedDisplayed;
        if (moreSelected < 2 && !this.dataSource.state.showAllRecentlySelected) {
            return '';
        }
        if (this.dataSource.state.showAllRecentlySelected) {
            return this.hideLink;
        }
        return `${moreSelected} more selected...`;
    }
    /**
     * In case of multiselect = false check if we want to show a selected value inside the input
     * field
     *
     * @return {?}
     */
    singleValueSelected() {
        return !this.dataSource.state && isPresent(this.dataSource.state.currentItem)
            && !this.dataSource.state.addMode;
    }
    /**
     * @return {?}
     */
    hasMenuTemplate() {
        return isPresent(this.menuTemplate);
    }
    /**
     * @return {?}
     */
    hasSelectionTemplate() {
        return isPresent(this.selectionTemplate);
    }
    /**
     * Internal. Please see ControlValueAccessor
     * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
     * initialization once we have a value and we only accept []
     *
     *
     * ? Should we do some deeper comparision?
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (isBlank(value)) {
            return;
        }
        if (isPresent(this.dataSource)) {
            this.dataSource.updateValue(value);
        }
        else {
            let /** @type {?} */ selState = new DefaultSelectionState(this.multiselect);
            let /** @type {?} */ chState = new ChooserState(selState, this.multiselect);
            this.initDatasource(chState);
            this.dataSource.updateValue(value);
        }
        this.initInternalModel();
    }
    /**
     * @param {?=} chooserState
     * @return {?}
     */
    initDatasource(chooserState) {
        assert(isPresent(this.destinationClass), 'You need to provide destinationClass or custom DataSource');
        this.dataSource.init({
            obj: this.destinationClass,
            queryType: QueryType.FullText,
            lookupKey: this.field,
            state: chooserState,
            multiselect: this.multiselect
        });
    }
    /**
     *
     * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
     * ngModel property
     *
     * @return {?}
     */
    initInternalModel() {
        if (this.dataSource.state.multiselect) {
            this.internalChooserModel = this.dataSource.state.selectedObjects();
        }
        else {
            this.internalChooserModel = this.dataSource.state.selectedObject();
        }
        if (isPresent(this.formControl)) {
            this.formControl.setValue(this.internalChooserModel);
        }
    }
}
ChooserComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-chooser',
                template: `<div class="w-chooser ">

    <p-autoComplete #autoCompplete [(ngModel)]="internalChooserModel"
                    [suggestions]="dataSource.state.matches"
                    [multiple]="dataSource.state.multiselect"
                    [dropdown]="!dataSource.state.multiselect"
                    [minLength]="minLenForSearch"
                    [placeholder]="placeHolder"
                    [delay]="delay"
                    [disabled]="disabled"
                    (onDropdownClick)="onDropdownClick($event)"
                    (completeMethod)="match($event.query)"
                    (onSelect)="selectItem($event)"
                    (onUnselect)="removeValue($event)">


        <ng-template let-internalChooserModel pTemplate="item">
            <ng-template [ngIf]="!hasMenuTemplate()">
                {{ displayItem(internalChooserModel) }}
            </ng-template>
            <ng-template [embeddedItem]="menuTemplate" [item]="internalChooserModel"
                         *ngIf="hasMenuTemplate()"></ng-template>
        </ng-template>
    </p-autoComplete>

    <!--
        Wrap whole selection with one extra element so we can move it around

         see: selectionAppendTo
    -->
    <span #selectionView>
        <div class="w-chooser-selections"
             *ngIf="multiselect && dataSource.state.recentSelectedObjects.length > 0">

        <ng-template [ngIf]="!hasSelectionTemplate()">

            <!-- no selection template render it as it is from CORE-->
            <ul class="ui-autocomplete-multiple-container ui-widget ui-state-default "
                [ngClass]="{'ui-state-disabled':disabled,'ui-state-focus':autoCompleteComponent.focus}">

                <li #token *ngFor="let item of dataSource.state.recentSelectedObjects"
                    class="ui-autocomplete-token ui-state-highlight ui-corner-all" tabindex="0"
                    (keyup.delete)="removeValue(item)"
                    (keyup.backspace)="removeValue(item)">
					<span class="ui-autocomplete-token-icon sap-icon icon-decline"
                          (click)="removeValue(item)"></span>
                    <span class="ui-autocomplete-token-label">{{ displayItem(item) }}</span>
                </li>
            </ul>
        </ng-template>

            <!--Yes there is selection template let's iterate and push each item to be rendered-->
        <ng-template ngFor [ngForOf]="dataSource.state.recentSelectedObjects" let-item>
            <ng-template [embeddedItem]="selectionTemplate" [item]="item"
                         *ngIf="hasSelectionTemplate()"></ng-template>
        </ng-template>

        <ng-template [ngIf]="dataSource.showMoreSelected()">
			<span class="more-selected">
				<aw-hyperlink [size]="'small'" (action)="dataSource.state.toggleAllSelected()">
					{{moreSelectString()}}
				</aw-hyperlink>
			</span>
        </ng-template>
    </div>
    </span>


</div>

`,
                styles: [`/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-input,/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-multiple-container{width:100%}/deep/ .w-chooser .ui-autocomplete-multiple{line-height:normal}/deep/ .w-chooser .ui-autocomplete-input{width:100%}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button{right:0;position:absolute;border:0;width:30px;background:0 0}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi{font-family:"SAP icon fonts";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button input{padding-right:30px}/deep/ .w-chooser .ui-autocomplete-input-token{padding:0;margin:0;vertical-align:baseline;width:inherit}/deep/ .w-chooser .ui-autocomplete-input-token .fa{font-family:"SAP icon fonts";color:#767676;cursor:pointer;font-size:1.2em}/deep/ .w-chooser .ui-autocomplete-input-token .fa-search:before{content:'\\e00d'}/deep/ .w-chooser .ui-autocomplete-input-token input{width:inherit;padding-right:25px}/deep/ .w-chooser .ui-autocomplete-input-token span{position:absolute;right:5px;top:0;padding-top:.6em}/deep/ .w-chooser .ui-autocomplete-dropdown{height:36px}/deep/ .w-chooser .ui-autocomplete-panel .ui-autocomplete-list-item{padding:.65em 2em .65em .64em;margin:0}/deep/ body .ui-autocomplete.ui-autocomplete-multiple .ui-autocomplete-multiple-container{padding:.4em .5em .4em 1em}.w-chooser-selections{margin-top:2px}.w-chooser-selections ul{margin:0;padding:0}.w-chooser-selections .ui-autocomplete-multiple-container{border:0}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token{font-size:.85em;letter-spacing:.1px;font-weight:400;padding:0;background:#e0f2ff;margin-right:5px;margin-bottom:5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-label{padding:4px 21px 4px 5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-icon{font-size:.78em;padding-right:.28em}.w-chooser-selections .ui-autocomplete-multiple-container .sap-icon{line-height:inherit}.w-chooser-selections .more-selected{display:inline-block}`],
                providers: [
                    CHOOSER_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => ChooserComponent) },
                    { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                ]
            },] },
];
/** @nocollapse */
ChooserComponent.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef },
    { type: ChooserDataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
ChooserComponent.propDecorators = {
    maxLength: [{ type: Input }],
    minLenForSearch: [{ type: Input }],
    valueTransformer: [{ type: Input }],
    multiselect: [{ type: Input }],
    dataSource: [{ type: Input }],
    selectionAppendTo: [{ type: Input }],
    delay: [{ type: Input }],
    destinationClass: [{ type: Input }],
    field: [{ type: Input }],
    onSelection: [{ type: Output }],
    menuTemplate: [{ type: ContentChild, args: ['menuItem',] }],
    selectionTemplate: [{ type: ContentChild, args: ['selectionItem',] }],
    autoCompleteComponent: [{ type: ViewChild, args: ['autoCompplete',] }],
    selectionViewElem: [{ type: ViewChild, args: ['selectionView',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWChooserModule {
}
AWChooserModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ChooserComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AutoCompleteModule,
                    AWHyperlinkModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    ChooserComponent
                ],
                exports: [
                    ChooserComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A popup like component rendering list of values as. Based on PrimeNG component and one of the
 * main reason why we need to wrap this is to extend its capabilities to accept almost any
 * data type without using Primens's specific SelectItem type.
 *
 *
 * ### Example
 *
 * ```
 * \@Component({
 *      selector: 'showDropDown' ,
 *      template: '<aw-dropdown [list]="testItemSmall"
 *     (onSelection)="onSelection($event)"></aw-dropdown>'
 *  })
 *  export class MyDropComponent
 *  {
 *      testItemSmall: string[] = ['view' , 'edit'];
 *
 *      // when you switch list binding to refert to large item fiilter automatically is shown and
 *     max 10 items are
 *      // visible
 *      testItemLarge: string[] = ['view' , 'edit' , 'frank' , 'kolar' , 'The Sun' , 'Dog' ,
 *     'Computer' , 'A Desk' ,
 *      'My Car' , 'Pencil' , 'This Page' , 'Yesterday' , 'Monday' , 'Tuesday' , 'BMW R1200 GS' ,
 *     'Czech Republic' ,
 *      'Last Item'];
 *
 *
 *      itemSelected: string = 'view';
 *      itemSelectedLg: string = 'Monday';
 *
 *      noselString: string = '(no selection)';
 *
 *
 *      onSelection (event): void
 *      {
 *          this.itemSelected = event;
 *
 *      }
 *  }
 *
 *  ```
 *
 */
const /** @type {?} */ DD_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DropdownComponent),
    multi: true
};
class DropdownComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Event fired when user select a item
         */
        this.onSelection = new EventEmitter();
    }
    /**
     * Todo: Put back the scrolling option once we decide so. Currently the requirements are
     * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
     * search filter.
     * @return {?}
     */
    ngOnInit() {
        if (this.isStandalone) {
            super.ngOnInit();
            super.registerFormControl(this.selection);
        }
        else {
            if (isPresent(this.name)) {
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
        // transform a value to PrimeNg Format, we are not really be using a label field only a
        // value.
        this.internalList = [];
        // if (isPresent(this.noSelectionString)) {
        //     this.internalList.push({
        //         label: this.noSelectionString,
        //         value: null
        //     });
        //
        //     if (isBlank(this.selection)) {
        //         this.selection = this.noSelectionString;
        //     }
        // }
        if (isPresent(this.list) && this.list.length >= DropdownComponent.MaxNumShown) {
            this.internalList = this.list.slice(0, DropdownComponent.MaxNumShown).map((item) => {
                return { label: item.toString(), value: item };
            });
        }
        else if (isPresent(this.list)) {
            this.internalList = this.list.slice(0).map((item) => {
                return { label: item.toString(), value: item };
            });
        }
    }
    /**
     * @return {?}
     */
    hasEmbeddedTemplate() {
        return isPresent(this.itemTemplate);
    }
    /**
     * Check to prevent Empty item to be rendered
     *
     * todo: Report this on PrimeNg
     *
     * @param {?} item
     * @return {?}
     */
    itemExist(item) {
        return isPresent(item);
    }
    /**
     * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
     * input field
     * @return {?}
     */
    showFilter() {
        return false;
        // return isPresent(this.list) && this.list.length > DropdownComponent.MaxNumShown;
    }
    /**
     *
     * Updates internal models of current selections and triggers onSelection event
     *
     * @param {?} value
     * @return {?}
     */
    onItemSelection(value) {
        this.selection = value.value;
        this.onSelection.emit(value.value);
        if (this.isStandalone) {
            this.formControl.setValue(this.selection);
            this.formControl.markAsDirty({ onlySelf: true });
        }
        this.onModelChanged(value.value);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    displayItem(item) {
        return isPresent(item) ? item.label : 'No Selection';
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!equals(value, this.selection)) {
            this.selection = value;
            this.formControl.setValue(value);
        }
    }
}
DropdownComponent.MaxNumShown = 10;
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dropdown',
                template: `<div class="w-dropdown" [formGroup]="formGroup">

    <ng-template [ngIf]="isStandalone">
        <p-dropdown [options]="internalList"
                    [formControlName]="name"
                    [placeholder]="noSelectionString"
                    [autoWidth]="false"
                    [filter]="showFilter()"
                    (onChange)="onItemSelection($event)">

            <ng-template let-item pTemplate="item">
                <ng-template [ngIf]="!hasEmbeddedTemplate() && itemExist(item)">
                    {{item.label }}
                </ng-template>

                <ng-template [embeddedItem]="itemTemplate" [item]="item"
                             *ngIf="hasEmbeddedTemplate() && itemExist(item)">

                </ng-template>
            </ng-template>


        </p-dropdown>
    </ng-template>
</div>


<!-- no formControl Name here. ngModel cannot have formGroup around -->
<ng-template [ngIf]="!isStandalone">
    <div class="w-dropdown">
        <p-dropdown [options]="internalList"
                    [(ngModel)]="selection"
                    [placeholder]="noSelectionString"
                    [autoWidth]="false"
                    [filter]="showFilter()"
                    (onChange)="onItemSelection($event)">

            <ng-template let-item pTemplate="item">

                <ng-template [ngIf]="!hasEmbeddedTemplate() && itemExist(item)">
                    {{item.label }}
                </ng-template>
                <ng-template [embeddedItem]="itemTemplate" [item]="item"
                             *ngIf="hasEmbeddedTemplate() && itemExist(item)">
                </ng-template>
            </ng-template>
        </p-dropdown>
    </div>
</ng-template>
`,
                styles: [`/deep/ .ui-dropdown-panel .ui-dropdown-items-wrapper{max-height:none!important}/deep/ .ui-dropdown-panel .ui-dropdown-item{padding:.65em 2em .65em .64em;margin:0}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container{width:100%}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container .fa{top:1.2em}/deep/ .ui-dropdown-panel .ui-dropdown-list{padding:1em 0}/deep/ .w-dropdown:not(.ng-dirty) label{color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger.ui-corner-right{border-left:none;color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger .pi{font-family:"SAP icon fonts";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-dropdown .ui-dropdown-trigger .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-dropdown .ui-dropdown-label{padding-right:2.4em}`],
                providers: [
                    DD_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => DropdownComponent) }
                ]
            },] },
];
/** @nocollapse */
DropdownComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
DropdownComponent.propDecorators = {
    list: [{ type: Input }],
    selection: [{ type: Input }],
    noSelectionString: [{ type: Input }],
    onSelection: [{ type: Output }],
    itemTemplate: [{ type: ContentChild, args: ['itemTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWDropdownModule {
}
AWDropdownModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DropdownComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DropdownModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    DropdownComponent
                ],
                exports: [
                    DropdownComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Lightweight and configurable Currency component based on the ng bootstrap directive. This
 * component combines an input and currency code dropdown.
 *
 *
 * for more info please see class Doc of the:
 * @see {\@link currency/currency.component.ts}
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'amount' ,
 *    template: `
 *
 *      <aw-currency [money]="price" [currencies]="currencies" [name]="'currency'">
 *      </aw-currency>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        amount: number = 1000;
 *        currencies: string[] = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
 *        currencyCode: string = this.currencies[0];
 *
 *        constructor ()
 *        {
 *        }
 *    }
 */
const /** @type {?} */ CURRENCY_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => CurrencyComponent),
    multi: true
};
class CurrencyComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Disable user to change Money's currency code and still
         * allow user to edit Money's amount.
         */
        this.readonlyCurrencyCode = false;
        // Initialize currencies.
        this.initCurrencies();
        this.currencyPipe = new CurrencyPipe(env.locale);
        env.onLocaleChange.subscribe((locale) => {
            this.currencyPipe = new CurrencyPipe(locale);
            if (isPresent(this.money)) {
                this.displayValue = this.formatCurrency(this.money.amount);
            }
        });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.money);
        this.initCurrencies();
        if (isBlank(this.currencySelection)) {
            this.currencySelection = this._currencies[0];
        }
        // ready the money field if it exists. and override the existing values.
        if (this.money) {
            this.currencySelection = this.money.currency;
        }
        else {
            this.money = new Money(null, this.currencySelection);
        }
        this.displayValue = this.formatCurrency(this.money.amount);
    }
    /**
     * @return {?}
     */
    initCurrencies() {
        if (!this._currencies || this._currencies.length === 0) {
            this._currencies = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
        }
    }
    /**
     * Display the real value when the user clicks in the currency widget. Then he can modify the
     * value without seeing the formatting.
     *
     * @param {?} el
     * @return {?}
     */
    onFocus(el) {
        if (isPresent(this.money) && isPresent(this.money.amount)) {
            this.displayValue = this.money.amount.toString();
        }
    }
    /**
     * display the formatted currency value when the user navigates away.
     * @param {?} el
     * @return {?}
     */
    onBlur(el) {
        this.money = this.money.clone({ amount: Number(el.value) });
        this.displayValue = this.formatCurrency(this.money.amount);
        this.onModelChanged(this.money);
    }
    /**
     * @param {?} currency
     * @return {?}
     */
    onSelection(currency) {
        this.currencySelection = currency;
        this.displayValue = this.formatCurrency(this.money.amount);
    }
    /**
     * Function will check to see if currency is a valid number before formatting.
     * @param {?} val
     * @return {?}
     */
    formatCurrency(val) {
        if (!val || val.length === 0) {
            return val;
        }
        if (isNaN(val)) {
            return val;
        }
        let /** @type {?} */ code = 'USD';
        if (this.currencySelection) {
            code = this.currencySelection;
        }
        this.money = this.money.clone({ currency: this.currencySelection });
        // By default, the precision is 2. For example, 10.23 USD.
        let /** @type {?} */ digits = '1.0-2';
        // If precision is present, use it for format the money value for display.
        if (isPresent(this.precision)) {
            digits = '1.0-' + this.precision;
        }
        return this.currencyPipe.transform(val, code, 'symbol', digits);
    }
    /**
     * @return {?}
     */
    getMoneyCurrency() {
        if (isPresent(this.displayValue) && this.displayValue.length > 0) {
            return this.currencySelection;
        }
        return '';
    }
    /**
     * @return {?}
     */
    get currencies() {
        return this._currencies;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set currencies(value) {
        if (isPresent(value)) {
            this._currencies = value;
        }
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if ((value instanceof Money) && !equals(value, this.money)) {
            this.money = value;
            if (isPresent(this.money.currency)) {
                this.currencySelection = this.money.currency;
            }
            this.displayValue = this.formatCurrency(this.money.amount);
            this.formControl.setValue(this.money);
        }
    }
}
CurrencyComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-currency',
                template: `<ng-template [ngIf]="editable">
    <div class="w-currency-field ui-fluid" [formGroup]="formGroup">
        <div class="ui-g ">
            <div class="ui-g-8 ui-g-nopad ">
                <input #currencyInput
                       pInputText
                       type="text" class="w-text-field currency-format"
                       [attr.name]="name"
                       [attr.placeholder]="placeHolder"
                       [value]="displayValue"
                       (focus)="onFocus(currencyInput)"
                       (blur)="onBlur(currencyInput)"
                       [disabled]="disabled">
            </div>
            <div class="ui-g-4 ui-g-nopad w-cc-field">
                <aw-dropdown *ngIf="!readonlyCurrencyCode"
                             [isStandalone]="false" [list]="currencies"
                             [selection]="money.currency"
                             (onSelection)="onSelection($event)"
                             [disabled]="disabled">

                </aw-dropdown>
                <div *ngIf="readonlyCurrencyCode" class="w-cc-readonly-field">{{money.currency}}</div>
            </div>
        </div>
    </div>
</ng-template>

<!-- currency:'USD':true -->

<ng-template [ngIf]="!editable">
    <aw-string value="{{displayValue}} {{ getMoneyCurrency() }}"></aw-string>
</ng-template>
`,
                styles: [`.w-currency-field [readonly],.w-currency-type-field [readonly]{background-color:#fff}.w-currency-field input,.w-currency-type-field input{min-width:80px}.w-currency-field i.fa,.w-currency-type-field i.fa{cursor:pointer}.w-currency-field{margin-top:0}.w-currency-field /deep/ .ui-dropdown{min-width:80px}.w-cc-field{display:flex;align-items:center}.w-cc-readonly-field{padding-left:5px;color:#969696}.no-gutter>[class*=ui-g-]{padding-right:0;padding-left:0}`],
                providers: [
                    CURRENCY_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => CurrencyComponent) }
                ]
            },] },
];
/** @nocollapse */
CurrencyComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
CurrencyComponent.propDecorators = {
    money: [{ type: Input }],
    readonlyCurrencyCode: [{ type: Input }],
    currencySelection: [{ type: Input }],
    precision: [{ type: Input }],
    currencies: [{ type: Input }]
};
/**
 * Money object is represented as a value, locale, and currencyCode
 */
class Money {
    /**
     * @param {?=} amount
     * @param {?=} currency
     * @param {?=} locale
     */
    constructor(amount = 0, currency = 'USD', locale = 'en_US') {
        this.amount = amount;
        this.currency = currency;
        this.locale = locale;
    }
    /**
     * @return {?}
     */
    getTypes() {
        return {
            amount: Number,
            currency: String,
            locale: String
        };
    }
    /**
     * @return {?}
     */
    className() {
        return 'Money';
    }
    /**
     * @return {?}
     */
    $proto() {
        return new Money(1, '23', '33');
    }
    /**
     * @return {?}
     */
    toString() {
        return this.amount + ', locale: ' + this.locale + ', code:  ' + this.currency;
    }
    /**
     * @param {?=} data
     * @return {?}
     */
    clone(data = {}) {
        return new Money(isPresent(data.amount) ? data.amount : this.amount, isPresent(data.currency) ? data.currency : this.currency, isPresent(data.locale) ? data.locale : this.locale);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWCurrencyModule {
}
AWCurrencyModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CurrencyComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule$1,
                    DropdownModule,
                    AWDropdownModule,
                    AWStringFieldModule,
                    AWCoreComponentModule
                ],
                entryComponents: [
                    CurrencyComponent
                ],
                exports: [
                    CurrencyComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: [CurrencyPipe]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Lightweight and configurable Date and Time component based on the primeng. This
 * component combines both date picker as well as time picker
 *
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'myTimer' ,
 *    template: `
 *    <aw-date-time [value]="date" [editable]="editable"  [name]="'dueDate'">
 *    </aw-date-time>
 *
 *    `
 *    })
 *    export class MyTimmerComponet
 *    {
 *
 *        date: Date = new Date();
 *
 *
 *        constructor ()
 *        {
 *            this.date.setFullYear(2016 , 10 , 3);
 *            this.date.setHours(10 , 10 , 10);
 *        }
 *    }
 *
 * ```
 *
 * By default you will see date field and time field is hidden to show both you just do following:
 *
 *  ```
 *
 * \@Component({
 *    selector: 'myTimer' ,
 *    template: `
 *
 *    <aw-date-time [value]="date"  [showTime]="showTime" [editable]="editable"  [name]="'bbdd'">
 *    </aw-date-time>
 *
 *    `
 *    })
 *    export class MyTimmerComponet
 *    {
 *        date: Date = new Date();
 *        showTime = true;
 *
 *        constructor ()
 *        {
 *            this.date.setFullYear(2016 , 10 , 3);
 *            this.date.setHours(10 , 10 , 10);
 *        }
 *    }
 *
 * ```
 *
 *
 *
 */
const /** @type {?} */ DATETIME_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => DateAndTimeComponent),
    multi: true
};
class DateAndTimeComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Default date format pattern used if none is passed
         *
         */
        this.formatPattern = 'mm/dd/yy';
        /**
         * Special workaround as formatters in the primeNG and angular are different so until its
         * fixed we need to keep this extra pattern.
         */
        this.formatPatternNG = 'MM/dd/yy';
        /**
         * Shows and hides navigation bar with year and months selections
         */
        this.showNavigation = false;
        /**
         * Shows and hides navigation bar with year and months selections
         */
        this.showIcon = true;
        /**
         * Whether to show timepicker
         */
        this.showTime = false;
        /**
         * Whether to show DatePicker. Even we can hide it. it should be for most of the case always
         * true
         */
        this.showDate = true;
        /**
         *
         * Tells the date picker what format it should use when presenting time. When hourFormat is 12,
         * it shows the AM, PM
         *
         */
        this.hourFormat = '24';
        /**
         * Triggers event when specific date is clicked inside DatePicker
         *
         */
        this.onChange = new EventEmitter();
        /**
         * Set the date to highlight on first opening if the field is blank.
         *
         */
        this.defaultDate = new Date();
        this.timePlaceHolder = 'hh:ss';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.value);
        // default to dateTime pattern which is defined in resource files
        if (this.hourFormat !== '12' && this.hourFormat !== '24') {
            this.hourFormat = '24';
        }
        this.timePlaceHolder = (this.hourFormat === '12') ?
            ` ${DateAndTimeComponent.NgTime12}` : ` ${DateAndTimeComponent.NgTime24}`;
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe((val) => {
            this.value = val;
            this.onModelChanged(this.value);
        });
        this.initTranslations();
        this.env.onLocaleChange.subscribe((locale) => {
            this.initTranslations();
        });
    }
    /**
     * Need to refactor this as this really get complicated trying to cover usecase with time
     * and date and every format we have. We should probably have separate patterns for
     * dates only and date + time
     * @return {?}
     */
    initTranslations() {
        this.formatNameWithTime = this.formatPattern;
        if (!this.showDate) {
            this.formatPatternNG = this.formatPattern += (this.hourFormat === '12') ?
                ` ${DateAndTimeComponent.NgTime12}` : ` ${DateAndTimeComponent.NgTime24}`;
        }
        if (this.showTime) {
            let /** @type {?} */ timeStarts = this.formatPattern.indexOf('h');
            if (timeStarts !== -1) {
                this.formatNameWithTime = this.formatPattern.substring(0, timeStarts);
            }
            this.formatPatternNG += (this.hourFormat === '12') ?
                ` ${DateAndTimeComponent.NgTime12}` : ` ${DateAndTimeComponent.NgTime24}`;
        }
        this.i18n = {
            firstDayOfWeek: 0,
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
                'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
                'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                'Nov', 'Dec']
        };
    }
    /**
     * Fired when dates changes. Here we update  this.value - > date and also update value inside
     * formController
     *
     * @param {?} event
     * @return {?}
     */
    onDateChange(event) {
        if (isBlank(event)) {
            // throw some error ?
            return;
        }
        this.value = isDate(event) ? event : new Date(event);
        this.formControl.setValue(this.value, { onlySelf: false, emitEvent: true });
        this.onModelChanged(this.value);
        this.onChange.emit(this.value);
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value);
        }
    }
}
DateAndTimeComponent.NgTime12 = 'hh:mm a';
DateAndTimeComponent.NgTime24 = 'HH.mm a';
DateAndTimeComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-date-time',
                template: `<ng-template [ngIf]="editable">

    <div class="w-datetime " [class.has-time]="showTime" [formGroup]="formGroup">

        <p-calendar formControlName="{{name}}"
                    [defaultDate]="defaultDate"
                    [showIcon]="showIcon"
                    dateFormat="{{showTime ? formatNameWithTime : formatPattern}}"
                    [yearNavigator]="showNavigation"
                    [monthNavigator]="showNavigation"
                    [yearRange]="yearRange"
                    placeholder="{{showTime ? formatNameWithTime.toUpperCase() : formatPattern.toUpperCase()}}"
                    (onSelect)="onDateChange($event)"
                    [timeOnly]="!showDate"
                    [readonlyInput]="true"
                    [locale]="i18n">
        </p-calendar>

        <p-calendar *ngIf="showTime"
                    icon="icon-history"
                    formControlName="{{name}}"
                    [hourFormat]="hourFormat"
                    [defaultDate]="defaultDate"
                    [showIcon]="showIcon"
                    [timeOnly]="showTime"
                    [showTime]="showTime"
                    [placeholder]="timePlaceHolder"
                    (onSelect)="onDateChange($event)"
                    [locale]="i18n">
        </p-calendar>

    </div>
</ng-template>

<ng-template [ngIf]="!editable">
    <aw-string value="{{value | date: formatPatternNG}}"></aw-string>
</ng-template>
`,
                styles: [`/deep/ .w-datetime .ui-calendar button{border:0;width:0}/deep/ .w-datetime .ui-calendar.ui-calendar-w-btn .ui-inputtext{width:100%}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left{font-family:"SAP icon fonts";color:#199de0;cursor:pointer;font-size:1.4em}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.pi-calendar:before{content:'\\e0e0'}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.icon-history:before{content:'\\e02d'}/deep/ .ui-datepicker{width:24.28em;line-height:25px;padding:0;border-color:#979797;box-shadow:none}/deep/ .ui-datepicker .ui-datepicker-header{padding:.92em 0;font-weight:400;color:#000;font-size:1em}/deep/ .ui-datepicker .ui-datepicker-next,/deep/ .ui-datepicker .ui-datepicker-prev{top:1em}/deep/ .ui-datepicker .ui-datepicker-prev{left:.2em}/deep/ .ui-datepicker .ui-datepicker-next{right:.2em}/deep/ .ui-datepicker table{font-size:1em;margin:0 0 1.5em}/deep/ .ui-datepicker th{font-weight:400;background-color:#ececec;color:#363636;padding:.786em 1.07em}/deep/ .ui-datepicker td{padding:.1em}/deep/ .ui-datepicker td a{text-align:center;width:2.7em;height:2.7em;line-height:2.7em;padding:0;border-radius:50%}/deep/ .ui-datepicker td a.ui-state-default{border-color:transparent}/deep/ .ui-datepicker td a.ui-state-active{background-color:#199de0;color:#fff}/deep/ .ui-datepicker .pi{font-size:1em}/deep/ .ui-datepicker .pi.pi-chevron-left:before{content:'\\e1ee'}/deep/ .ui-datepicker .pi.pi-chevron-right:before{content:'\\e1ed'}/deep/ .ui-datepicker .ui-datepicker-calendar td:not(.ui-state-disabled) a:hover{border-color:transparent;background-color:rgba(25,157,224,.7);opacity:.75;color:#363636}/deep/ .ui-datepicker-timeonly{width:100%}/deep/ .ui-timepicker{font-size:1.14em;color:#767676;font-weight:400}/deep/ .ui-timepicker .pi{font-size:1em}/deep/ .ui-timepicker .pi.pi-chevron-up:before{content:'\\e1f0'}/deep/ .ui-timepicker .pi.pi-chevron-down:before{content:'\\e1ef'}/deep/ .ui-timepicker>div{margin-left:0}/deep/ .ui-timepicker .ui-separator{width:.1em;min-width:.1em}/deep/ .ui-timepicker .ui-separator .pi{font-size:0}/deep/ .ui-datepicker-trigger{background-color:transparent}/deep/ .ui-datepicker-trigger.ui-button:enabled:hover,/deep/ .ui-datepicker-trigger.ui-button:focus{background-color:transparent}/deep/ .has-time{display:flex;flex-wrap:nowrap}/deep/ .has-time p-calendar:first-child{width:55%;margin-right:14px}/deep/ .has-time p-calendar:last-child{width:45%}/deep/ .has-time p-calendar:last-child .ui-datepicker{padding:0}/deep/ .has-time .ui-button-icon-left{line-height:18px}`],
                providers: [
                    DATETIME_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => DateAndTimeComponent) }
                ]
            },] },
];
/** @nocollapse */
DateAndTimeComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
DateAndTimeComponent.propDecorators = {
    value: [{ type: Input }],
    formatPattern: [{ type: Input }],
    formatPatternNG: [{ type: Input }],
    showNavigation: [{ type: Input }],
    yearRange: [{ type: Input }],
    showIcon: [{ type: Input }],
    showTime: [{ type: Input }],
    showDate: [{ type: Input }],
    hourFormat: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWDateAndTimeModule {
}
AWDateAndTimeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DateAndTimeComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CalendarModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    DateAndTimeComponent
                ],
                exports: [
                    DateAndTimeComponent,
                    ReactiveFormsModule,
                    FormsModule
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An dialog header area.
 *
 * See {\@link DialogComponent} for more explanation.
 */
class DialogHeaderComponent {
}
DialogHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dialog-header',
                template: '<ng-content></ng-content>'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An dialog header area.
 *
 * See {\@link DialogComponent} for more explanation.
 */
class DialogFooterComponent {
}
DialogFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dialog-footer',
                template: '<ng-content></ng-content>'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Dialog Component that provides the look and feel for a modal dialog. This component has three
 * sections: header, body, and footer. It can be used by itself or extended.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<DialogComponent>), service.close()
 *
 * Usage:
 *    1.  Using Dialog directly to display a modal popup. This usage is a quick way to show a
 * message to the user.
 *
 *             this.modalService.open<DialogComponent>( DialogComponent, {
 *                     title: 'My Popup Title',
 *                     body: 'My Popup Body'
 *              });
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                              <aw-dialog [(visible)]="display" [modal]="true"
 *                                        (onOpen)="openAction()" (onClose)="closeAction()">
 *
 *                                    <aw-dialog-header>Dialog Header</aw-dialog-header>
 *
 *                                     Dialog Body: Creating a dialog using the dialog component
 *
 *                                    <aw-dialog-footer>
 *                                      <aw-button [size]="'small'" [style]="'primary'"
 *                                                 (click)="close()">OK</aw-button>
 *                                    </aw-dialog-footer>
 *                              </aw-dialog>
 *
 *                          <aw-button [size]="'small'" (click)="open()">Open Dialog</aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     display: boolean = false;
 *
 *                     dialogAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     open() {
 *                        this.display = true;
 *                     }
 *
 *                     openAction()  {
 *                        this.dialogAction = "open";
 *                      }
 *       }
 *
 *
 */
class DialogComponent extends ModalContainer {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * support two way data binding on visible property.
         */
        this.visibleChange = new EventEmitter();
        /**
         * whether this dialog blocks the rest of the page or not when displayed.
         */
        this.modal = true;
        /**
         * Whether there's an x at the top right that makes the dialog closable.
         */
        this.closable = true;
        /**
         * Event fired when dialog is closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event fired when the dialog is opened.
         */
        this.onOpen = new EventEmitter();
        this.width = 300;
        this.height = 'auto';
    }
    /**
     * Open this dialog.
     * @return {?}
     */
    open() {
        this.visible = true;
        this.onOpen.emit();
        // visible is a 2-way binding variable.
        this.visibleChange.emit(true);
    }
    /**
     * close the dialog
     * @return {?}
     */
    close() {
        this.visible = false;
        this.onClose.emit();
        // Important to make sure change is set on parent binding.
        // Otherwise, the variable and dialog open/close state can be out
        // of sync and we wouldn't trigger change detection.
        this.visibleChange.emit(false);
    }
    /**
     * Does this dialog have header.
     *
     * @return {?}
     */
    hasHeader() {
        return isPresent(this.header);
    }
    /**
     * Does this dialog have footer.
     *
     * @return {?}
     */
    hasFooter() {
        return isPresent(this.footer);
    }
}
DialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dialog',
                template: `<p-dialog [header]="title" [(visible)]="visible"
          [modal]="modal" [closable]="closable" [width]="width" [height]="height"
          [styleClass]="styleClass" [appendTo]="appendTo" (onShow)="open()" (onHide)="close()">

    <p-header *ngIf="hasHeader()">
        <ng-content select="aw-dialog-header"></ng-content>
    </p-header>

    {{body}}
    <ng-content></ng-content>

    <p-footer *ngIf="hasFooter()">
        <div class="dialog-footer-separator"></div>
        <ng-content select="aw-dialog-footer"></ng-content>
    </p-footer>
</p-dialog>
`,
                styles: [`::ng-deep .ui-dialog .ui-dialog-titlebar{background-color:#f2f2f2;padding:15px 20px}::ng-deep .ui-dialog .ui-dialog-titlebar .ui-dialog-titlebar-icon:hover{border-color:transparent}::ng-deep .ui-widget-header{font-weight:400;font-size:16px}::ng-deep .ui-dialog .ui-dialog-content{padding:15px 20px;line-height:1.3em}::ng-deep .ui-dialog .ui-widget-content{border:none}::ng-deep .ui-dialog.ui-widget-content{border:none;box-shadow:0 2px 10px 0 rgba(0,0,0,.3)}::ng-deep .ui-dialog .dialog-footer-separator{border-top:1px solid #d7d7d7;height:14px}::ng-deep .ui-dialog .ui-dialog-footer{padding:0 20px 15px}`]
            },] },
];
/** @nocollapse */
DialogComponent.ctorParameters = () => [
    { type: Environment }
];
DialogComponent.propDecorators = {
    title: [{ type: Input }],
    body: [{ type: Input }],
    visibleChange: [{ type: Output }],
    modal: [{ type: Input }],
    closable: [{ type: Input }],
    appendTo: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    header: [{ type: ContentChild, args: [DialogHeaderComponent,] }],
    footer: [{ type: ContentChild, args: [DialogFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWDialogModule {
}
AWDialogModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DialogComponent,
                    DialogHeaderComponent,
                    DialogFooterComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                    DialogModule
                ],
                entryComponents: [
                    ModalComponent,
                    DialogComponent,
                    DialogHeaderComponent,
                    DialogFooterComponent
                ],
                exports: [
                    DialogComponent,
                    DialogHeaderComponent,
                    DialogFooterComponent,
                    AWCoreComponentModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Convenient wrapper class around controls such as radiobuttons, dropdown, checkboxes,
 * Chooser. The type of the chooser may be determined dynamically based on the number of items in
 * the data source list, or can be specified explicitly via the "type" binding.
 *
 *
 *
 */
class GenericChooserComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} _viewContainer
     * @param {?} dataSource
     * @param {?} parentContainer
     */
    constructor(env, _viewContainer, dataSource, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this._viewContainer = _viewContainer;
        this.dataSource = dataSource;
        this.parentContainer = parentContainer;
        /**
         *  Is this a List property, or a to-one.
         */
        this.multiselect = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.object)) {
            this.object = (/** @type {?} */ (this._viewContainer.injector)).view.context;
        }
        this.keyPath = new FieldPath(this.key);
        let /** @type {?} */ defaultDataProvider = null;
        if (isPresent(this.list)) {
            defaultDataProvider = this.dataSource.dataProviders.find(this.list);
        }
        else {
            defaultDataProvider = this.dataSource.dataProviders.find(this.destinationClass);
        }
        let /** @type {?} */ projectedSize = defaultDataProvider.expectedCount(this.choiceProviderParams);
        this.initType(projectedSize);
        if (this.type === 'Chooser') {
            this.dataSource.init({
                dataProvider: defaultDataProvider,
                queryType: QueryType.FullText,
                lookupKey: this.displayKey,
                state: new ChooserState(new GCChooserState(this), this.multiselect),
                multiselect: this.multiselect
            });
        }
        else {
            // do we need to read this value in async?
            this.list = defaultDataProvider.data();
        }
        super.registerFormControl(this.selection);
        this.validateRequired();
        if (isBlank(this.selection)) {
            // this.noSelectionString = this.i18n.instant('Widgets.gchooser.noSelString');
            this.noSelectionString = 'Select a Item';
        }
    }
    /**
     *
     * When \@Input type is not passed we try to guess and select the best type for current data
     *
     * @param {?} projectedSize
     * @return {?}
     */
    initType(projectedSize) {
        if (isBlank(this.type)) {
            if (this.multiselect) {
                this.type = (projectedSize <= 0 || projectedSize > 8) ? 'Chooser' : 'Checkbox';
            }
            else {
                this.type = (projectedSize <= 0 || projectedSize > 20) ? 'Chooser'
                    : (projectedSize < 6) ? 'Radio' :
                        'Dropdown';
            }
        }
    }
    /**
     * There are certain properties which are required by this component. As already mentioned
     * above GenericChooser works with references and thefore two key properties are object and key
     * so we can access an object
     *
     *
     * @return {?}
     */
    validateRequired() {
        if (isBlank(this.object)) {
            throw Error('Cannot continue without a object');
        }
        if (isBlank(this.key)) {
            throw Error('Cannot continue without a key binding');
        }
        if (isBlank(this.list) && isBlank(this.destinationClass)) {
            throw Error('Cannot continue without having either list of values or destinationClass');
        }
        if (isPresent(this.type) &&
            (this.type !== 'Radio' && this.type !== 'Checkbox' && this.type !== 'Dropdown' &&
                this.type !== 'Chooser')) {
            throw Error('Cannot instantiate GenericChooser  - invalid type');
        }
        if (isBlank(this.displayKey)) {
            this.displayKey = 'toString';
        }
    }
    /**
     *
     * Used when displaying value both from primitive type as well complex object. If you want to
     * control how item is displayed you can provide display key, which is can be a  method or
     * property of the object you are displaying.
     *
     * Todo: think about formatters as well
     *
     * @param {?} item
     * @return {?}
     */
    displayValue(item) {
        if (isBlank(this.displayKey)) {
            return item;
        }
        let /** @type {?} */ fieldValue = FieldPath.getFieldValue(item, this.displayKey);
        if (isFunction(fieldValue)) {
            return fieldValue.call(item);
        }
        return fieldValue;
    }
    /**
     *  Retrieve a current value from the parent/target object
     *
     * @return {?}
     */
    get selection() {
        return this.keyPath.getFieldValue(this.object);
    }
    /**
     *  set value back to the object
     *
     * @param {?} value
     * @return {?}
     */
    set selection(value) {
        this.keyPath.setFieldValue(this.object, value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onSelection(value) {
        this.selection = value;
        this.formControl.setValue(this.selection);
        this.formControl.markAsDirty();
    }
}
GenericChooserComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-generic-chooser',
                template: `<ng-container [ngSwitch]="type">

    <ng-template [ngSwitchCase]="'Checkbox'">
        <aw-checkbox-list [list]="list"
                          [editable]="editable"
                          [selections]="selection"
                          [name]="name"
                          [disabled]="disabled"
                          [labelFormatter]="displayValue"
                          (onSelection)="onSelection($event)">
        </aw-checkbox-list>
    </ng-template>


    <ng-template [ngSwitchCase]="'Radio'">
        <aw-radiobutton-list [list]="list"
                             [selection]="selection"
                             [editable]="editable"
                             [name]="name"
                             [disabled]="disabled"
                             [labelFormatter]="displayValue"
                             (onSelection)="onSelection($event)">
        </aw-radiobutton-list>
    </ng-template>

    <ng-template [ngSwitchCase]="'Dropdown'">
        <aw-dropdown [list]="list"
                     [isStandalone]="false"
                     [editable]="editable"
                     [noSelectionString]="noSelectionString"
                     [selection]="selection"
                     [disabled]="disabled"
                     [name]="name"
                     (onSelection)="onSelection($event)">
            <ng-template #itemTemplate let-item>

                <!-- todo: allow to pass a PIPE to do some additional formatting -->
                {{ displayValue(item.value) }}
            </ng-template>
        </aw-dropdown>
    </ng-template>


    <ng-template [ngSwitchCase]="'Chooser'">
        <aw-chooser #chooser
                    [editable]="editable"
                    [isStandalone]="false"
                    [name]="name"
                    [multiselect]="multiselect"
                    [dataSource]="dataSource"
                    [valueTransformer]="displayValue"
                    [disabled]="disabled">

        </aw-chooser>

    </ng-template>

</ng-container>
`,
                styles: [``],
                providers: [
                    { provide: BaseFormComponent, useExisting: forwardRef(() => GenericChooserComponent) },
                    { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                ]
            },] },
];
/** @nocollapse */
GenericChooserComponent.ctorParameters = () => [
    { type: Environment },
    { type: ViewContainerRef },
    { type: ChooserDataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
GenericChooserComponent.propDecorators = {
    list: [{ type: Input }],
    object: [{ type: Input }],
    key: [{ type: Input }],
    destinationClass: [{ type: Input }],
    choiceProviderParams: [{ type: Input }],
    multiselect: [{ type: Input }],
    type: [{ type: Input }],
    displayKey: [{ type: Input }],
    noSelectionString: [{ type: Input }]
};
/**
 * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
 *
 */
class GCChooserState extends ChooserSelectionState {
    /**
     * @param {?} gChooser
     */
    constructor(gChooser) {
        super();
        this.gChooser = gChooser;
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    setSelectionState(selection, selected) {
        if (selected === this.isSelected(selection)) {
            return;
        }
        if (this.gChooser.multiselect) {
            // Check if we can implement smarter and more generic way how we use it in java
            // RelationshipField.addTo(_object, _keyPath, selection);
            let /** @type {?} */ multiRel = this.gChooser.keyPath.getFieldValue(this.gChooser.object);
            if (isBlank(multiRel)) {
                multiRel = [];
            }
            else if (isPresent(multiRel) && !isArray(multiRel)) {
                throw new Error('I can not store multiselect value into non-array object');
            }
            if (selected) {
                multiRel.push(selection);
                this.gChooser.selection = multiRel;
            }
            else {
                ListWrapper.removeIfExist(multiRel, selection);
            }
        }
        else {
            if (!selection) {
                selection = null;
            }
            this.gChooser.selection = selection;
        }
    }
    /**
     * @return {?}
     */
    selectedObject() {
        if (this.gChooser.multiselect) {
            let /** @type {?} */ objects = this.selectedObjects();
            return (isBlank(objects) || ListWrapper.isEmpty(objects)) ? null : ListWrapper.last(objects);
        }
        return this.gChooser.selection;
    }
    /**
     * @return {?}
     */
    selectedObjects() {
        let /** @type {?} */ selection = this.gChooser.selection;
        if (this.gChooser.multiselect && isBlank(selection)) {
            selection = [];
        }
        return (this.gChooser.multiselect && isArray(selection)) ? selection : [selection];
    }
    /**
     * @param {?} selection
     * @return {?}
     */
    isSelected(selection) {
        if (this.gChooser.multiselect) {
            return ListWrapper.containsComplex(this.selectedObjects(), selection);
        }
        let /** @type {?} */ curValue = this.selectedObject();
        return equals(curValue, selection);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Wrapper class for RadioButton component providing convenient way to to render RadioButton Groups
 *
 *
 * ### Example
 *
 *
 * ```
 * \@Component({
 *          selector: 'gender-selector' ,
 *          template: `
 *              <aw-radiobutton-list [list]="rbListValues" [layout]="layout"
 *     [selection]="selectedValue" [name]="'name'">
 *               </aw-radiobutton-list>
 *      `
 *      })
 *      export class GenderSelectorComponent
 *      {
 *          rbListValues: string[] = ['male' , 'female' , 'other'];
 *          selectedValue: string = 'other';
 *          layout: string = 'stacked';
 *
 *
 *          formGroup: FormGroup = new FormGroup({});
 *
 *
 *          onCBClick (event): void
 *          {
 *              console.log('onCBClick = ' + event);
 *          }
 *
 *      }
 *
 * ```
 */
const /** @type {?} */ RB_LIST_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RadioButtonListComponent),
    multi: true
};
class RadioButtonListComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * Fires an event when radio button is selected
         *
         */
        this.onSelection = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isPresent(this.selection)) {
            this.model = 0;
        }
        this.updateModel(this.selection);
        this.onModelChanged(this.selection);
        this.registerFormControl(this.selection);
    }
    /**
     * Label is extracted into a method so in the future we can play how we want to display the
     * value. Since I want to support formatters for each components we might have a chance to
     * decide how the label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    labelValue(item) {
        if (isPresent(this.labelFormatter)) {
            return this.labelFormatter(item);
        }
        return item.toString();
    }
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     *
     *
     * @param {?} item
     * @return {?}
     */
    value(item) {
        return item;
    }
    /**
     *
     * On NGModel change retrieve actual record based on the INDEX and propagate it to both
     * ngModel as well as FormGroup.
     *
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        let /** @type {?} */ updatedModel = this.list[this.model];
        this.onSelection.emit(updatedModel);
        this.onModelChanged(updatedModel);
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
    }
    /**
     * Since we might be dealing with complex object store only INDEX number in the model.
     *
     * @param {?} souceItem
     * @return {?}
     */
    updateModel(souceItem) {
        let /** @type {?} */ index = this.list.findIndex((elem) => {
            return souceItem === elem;
        });
        this.model = index === -1 ? 0 : index;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        let /** @type {?} */ updatedModel = this.list[this.model];
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
        // this.cd.detectChanges();
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            let /** @type {?} */ newModel = value;
            this.updateModel(newModel);
        }
    }
}
RadioButtonListComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-radiobutton-list',
                template: `<div *ngFor="let item of list;  let i = index" class="ui-g">

    <div class="ui-g-12">
        <aw-radiobutton
            [(ngModel)]="model"
            (ngModelChange)="onChange($event)"
            [isStandalone]="false"
            [name]="name"
            [value]="i"
            [label]="labelValue(item)">
        </aw-radiobutton>
    </div>

</div>
`,
                styles: [``],
                providers: [
                    RB_LIST_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => RadioButtonListComponent) }
                ]
            },] },
];
/** @nocollapse */
RadioButtonListComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
RadioButtonListComponent.propDecorators = {
    list: [{ type: Input }],
    selection: [{ type: Input }],
    labelFormatter: [{ type: Input }],
    onSelection: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Implements standard HTML radio button on top of PrimeNG with ariba styling
 *
 * ### Example
 *
 * 1. Basic usage using ngModel pre-selected first radio
 *
 *  ```ts
 *
 * \@Component({
 *          selector: 'demo-comp',
 *          template: `
 *              <aw-radiobutton [name]="'color'" [value]="'red'" [label]="'Red'"
 *                             [(ngModel)]="model">
 *             </aw-radiobutton>
 *              <aw-radiobutton [name]="'color'" [value]="'blue'" [label]="'Blue'"
 *                      [(ngModel)]="model">
 *              </aw-radiobutton>
 *      `
 *      })*
 *      class BasicWithNgModelComponent
 *      {
 *          model: string[] = ['red'];
 *
 *          constructor()
 *          {
 *          }
 *      }
 *
 *  ```
 *
 *
 * 2. Basic usage with formGroup
 *
 *
 * ```ts
 * \@Component({
 *           selector: 'demo-comp',
 *           template: `
 *          <div [formGroup]="env.currentForm">
 *               <aw-radiobutton [name]="'color2'" [value]="'red'" [label]="'Red'"
 *               (onChange)="onChange($event)">
 *               </aw-radiobutton>
 *               <aw-radiobutton [name]="'color2'" [value]="'blue'" [label]="'Blue'"
 *               (onChange)="onChange($event)">
 *               </aw-radiobutton>
 *
 *       </div>
 *       `
 *       })
 *       class BasicWithFormGroupComponent implements OnInit
 *       {
 *           model: string = 'blue';
 *
 *           constructor(public env: Environment)
 *           {
 *           }
 *
 *           ngOnInit(): void
 *           {
 *               this.env.currentForm = new FormGroup({});
 *               this.env.currentForm.registerControl('color2', new FormControl(this.model));
 *           }
 *
 *
 *           onChange(event: any): void
 *           {
 *               this.modelSet = event;
 *           }
 *
 *       }
 *  ````
 *
 *
 *
 *
 */
const /** @type {?} */ RAB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RadioButtonComponent),
    multi: true
};
class RadioButtonComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value associated with this radio
         *
         */
        this.value = '';
        /**
         * Trigger click event with currrent selected value
         *
         */
        this.onChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (this.isStandalone) {
            super.registerFormControl(this.value);
            this.model = this.formControl.value;
            this.onModelChanged(this.model);
        }
        else {
            this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
        }
    }
    /**
     * Called when radio is clicked. Not using PrimeNG click event as it is fired before
     * the model is changed. Therefore need to listen on (ngModelChange)
     *
     * @param {?} newVal
     * @return {?}
     */
    onModelChange(newVal) {
        this.onModelChanged(this.model);
        if (this.isStandalone) {
            this.formControl.setValue(this.model, { emitEvent: true });
        }
        this.onChange.emit(this.model);
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.model) {
            this.model = value;
            if (this.isStandalone) {
                this.formControl.setValue(this.model, { emitEvent: true });
            }
            this.onModelChanged(this.model);
        }
    }
}
RadioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-radiobutton',
                template: `<span class="w-radiobutton">

    <ng-template [ngIf]="editable ">
        <p-radioButton [name]="name"
                       [value]="value"
                       [label]="label"
                       [(ngModel)]="model"
                       [disabled]="disabled"
                       (ngModelChange)="onModelChange($event)"
                       [class.u-validation-error]="!(formControl.valid || (formControl.pristine))">
        </p-radioButton>
    </ng-template>
</span>
`,
                styles: [`/deep/ .w-radiobutton .ui-radiobutton-box{width:23px;height:23px;line-height:23px}/deep/ .w-radiobutton .ui-radiobutton-icon{font-size:1.5em;line-height:1em}`],
                providers: [
                    RAB_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => RadioButtonComponent) }
                ]
            },] },
];
/** @nocollapse */
RadioButtonComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
RadioButtonComponent.propDecorators = {
    value: [{ type: Input }],
    label: [{ type: Input }],
    onChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWRadioButtonModule {
}
AWRadioButtonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RadioButtonComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    RadioButtonModule
                ],
                entryComponents: [
                    RadioButtonComponent
                ],
                exports: [
                    RadioButtonComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWRadioButtonListModule {
}
AWRadioButtonListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RadioButtonListComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWRadioButtonModule
                ],
                entryComponents: [
                    RadioButtonListComponent
                ],
                exports: [
                    RadioButtonListComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWGenericChooserModule {
}
AWGenericChooserModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    GenericChooserComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCoreComponentModule,
                    AWDropdownModule,
                    AWCheckBoxListModule,
                    AWChooserModule,
                    AWRadioButtonListModule
                ],
                entryComponents: [
                    GenericChooserComponent
                ],
                exports: [
                    ReactiveFormsModule,
                    FormsModule,
                    GenericChooserComponent
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * OutlineState is the key gluing part for the OutlineFor and OutlineController components. It
 * holds all important information for the current outline tree and manages expansion states in form
 * of so called expansionPath and expansionStates
 *
 * We need to have a way how to work with generic data structure in order not to hold UI specific
 * information on the domain object model just like we had it before, where we had an interface
 * called OutlineNode, with fields (expanded, selected, etc.. )
 *
 *
 * `expansionPath`: Holds an array of currently selected and expanded nodes. This is filled by
 * OutlineController.
 *
 *
 * If we are dealing with Entity or anything that has identity then we have easier situation as we
 * can ask for ID and it is more efficient for serialization
 */
class OutlineState {
    constructor() {
        /**
         *
         * When outline is rendered for first time or re-rendered and we set default value for the
         * expansionStates. This way we can pretty easily execute CollapseAll, ExpandAll
         *
         */
        this.isExpandedAll = false;
        /**
         *
         * Holds current level during tree node rendering so we can apply correct indentation
         *
         */
        this.currentLevel = -1;
        this.expansionStates = new Map();
    }
    /**
     * For the collapseAll and expandAll we are using simple mechanism where we clean up all
     * selection and then set the global expand state, this whey isExpand method returns the same
     * state for all items
     * @return {?}
     */
    collapseAll() {
        if (isPresent(this.outlineFor) &&
            this.outlineFor.isTreeModelFormat()) {
            // for this case we collapse all but root nodes
            if (this.outlineFor.pushRootSectionOnNewLine) {
                this.outlineFor.list.forEach((item) => {
                    this.updateNodes(item.children || [], false);
                });
            }
            else {
                this.updateNodes(this.outlineFor.list || [], false);
            }
        }
        else {
            this.expansionStates.clear();
        }
        this.isExpandedAll = false;
    }
    /**
     * @return {?}
     */
    expandAll() {
        if (isPresent(this.outlineFor) &&
            this.outlineFor.isTreeModelFormat()) {
            this.updateNodes(this.outlineFor.list, true);
        }
        else {
            this.expansionStates.clear();
        }
        this.isExpandedAll = true;
    }
    /**
     * @return {?}
     */
    get expansionPath() {
        if (isBlank(this._expansionPath)) {
            this._expansionPath = [];
        }
        return this._expansionPath;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expansionPath(value) {
        this._expansionPath = value;
        if (isBlank(this._expansionPath)) {
            return;
        }
        this._expansionPath.forEach((item) => {
            this.setExpansionState(item, true);
        });
    }
    /**
     * @param {?} currentPath
     * @param {?=} children
     * @return {?}
     */
    toggleExpansion(currentPath, children) {
        if (isBlank(currentPath)) {
            return;
        }
        let /** @type {?} */ item = ListWrapper.last(currentPath);
        let /** @type {?} */ itemChildren = children || [];
        let /** @type {?} */ newState = !this.isExpanded(item);
        this.setExpansionState(item, newState);
        if (!newState) {
            ListWrapper.removeLast(currentPath);
            this.updateNodes(itemChildren, newState);
        }
        this.setExpansionPath(currentPath);
    }
    /**
     * @param {?} nodes
     * @param {?} newState
     * @return {?}
     */
    updateNodes(nodes, newState) {
        nodes.forEach((child) => {
            let /** @type {?} */ items = this.outlineFor.childrenForItem(child);
            if (isPresent(items) && items.length > 0) {
                this.updateNodes(items, newState);
            }
            this.setExpansionState(child, newState);
        });
    }
    /**
     * @param {?} item
     * @param {?} isExpanded
     * @return {?}
     */
    setExpansionState(item, isExpanded) {
        // Even for tree mode format save the state so we can use it later on in case object
        // references gets meesed up
        if (this.outlineFor &&
            this.outlineFor.isTreeModelFormat()) {
            (/** @type {?} */ (item)).isExpanded = isExpanded;
        }
        else {
            let /** @type {?} */ key = this.itemToKey(item);
            if (isExpanded === this.isExpandedAll) {
                this.expansionStates.delete(key);
            }
            else {
                this.expansionStates.set(key, (isExpanded) ? true : false);
            }
        }
    }
    /**
     * To improve state persisting lets check if we are dealing with an Object that has Identity
     * so we can extract an ID otherwise use object to compare by reference
     *
     *
     * @param {?} item
     * @return {?}
     */
    itemToKey(item) {
        return isEntity(item) ? (/** @type {?} */ (item)).identity() : item;
    }
    /**
     * @param {?} items
     * @return {?}
     */
    setExpansionPath(items) {
        this.expansionPath = items;
        items.forEach((node) => {
            this.setExpansionState(node, true);
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isExpanded(item) {
        if (isPresent(this.outlineFor) &&
            this.outlineFor.isTreeModelFormat()) {
            return (/** @type {?} */ (item)).isExpanded;
        }
        else {
            let /** @type {?} */ key = this.itemToKey(item);
            if (!this.expansionStates.has(key)) {
                return this.isExpandedAll;
            }
            return this.expansionStates.get(key);
        }
    }
}
OutlineState.decorators = [
    { type: Injectable },
];
/** @nocollapse */
OutlineState.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Checks type for OutlineNode
 *
 * @param {?} node
 * @return {?}
 */
function isOutlineNode(node) {
    return isPresent(node) && isPresent((/** @type {?} */ (node)))
        && isPresent((/** @type {?} */ (node)).parent)
        && isPresent((/** @type {?} */ (node)).children);
}
/**
 *
 * OutlineForComponent is like ngFor, but for hierarchical (outline/tree) structures -- i.e. in
 * those cases where an item may have children.
 *
 *
 * It uses outline `<aw-outline-control>` to provide expanding functionality, indentation
 * and other things.
 *
 *
 * This component has minimal styling to make sure it can be changed easily.
 *
 * ### Example rendering tree section, where based on the type we format the out plus
 * for the main root section we always render little popup menu.
 *
 * ```
 *
 *   <aw-outline-for [list]="list" [hasChildren]="hasChildren">
 *
 *       <ng-template #outline let-item>
 *
 *           <div class="my-section">
 *               <div class="outline">
 *                   <aw-outline-control>
 *                       <ng-container [ngSwitch]="item.type">
 *                           <ng-template [ngSwitchCase]="'text'">
 *                               <div class="as-paragraf">
 *                                   {{item?.content}}
 *                               </div>
 *                           </ng-template>
 *
 *
 *                           <ng-template ngSwitchDefault>
 *                               {{item?.content}}
 *                           </ng-template>
 *
 *
 *                       </ng-container>
 *
 *
 *                   </aw-outline-control>
 *               </div>
 *
 *               <div class="filters" *ngIf="item.type === 'section'" >
 *
 *                   <aw-hover-card [linkTitle]="'Filter Items'">
 *                       <aw-list [list]="filterItems" [borderless]="true"></aw-list>
 *                   </aw-hover-card>
 *
 *               </div>
 *           </div>
 *     </ng-template>`
 *   </aw-outline-for>
 *
 * ```
 *
 *
 * We can use it also in embedded mode where we use the `awOutlineFor` directive
 *
 * ## Example
 *
 *
 * ````
 *  <table  class="tree-table" >
 *      <thead>
 *          <tr>
 *              <th>Name</th>
 *              <th>Type</th>
 *          </tr>
 *      </thead>
 *      <tbody #ooo2 awOutlineFor [list]="list"
 *             [hasChildren]="hasChildren"
 *             class="outline-table"
 *      >
 *          <ng-template #outline let-item>
 *              <tr>
 *                  <td class="item-name outline-animation">
 *                      <div><aw-outline-control>
 *                          {{item?.content}}
 *                      </aw-outline-control></div>
 *                  </td>
 *                  <td class="item-type outline-animation">
 *                      <div>{{item.type}}</div>
 *                  </td>
 *              </tr>
 *          </ng-template>
 *      </tbody>
 *  </table>
 *
 * ```
 *
 * I was thinking maybe for first time we don't need the same animation like expanding and
 * collapsing. Maybe we need fade-in. In such case I would probably apply \@section anim only
 * on items where level > 0 (in the template I keep levels) and if level == 0 then I would
 * execute the same rendering just without [\@section]
 *
 *
 * Todo: Think about how to do animation for the table case. Must also write unitest - due to
 * AribaLive aggressive schedule we are skipping them for now
 *
 */
class OutlineForComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} _viewContainer
     * @param {?} builder
     * @param {?} element
     */
    constructor(env, _viewContainer, builder, element) {
        super(env);
        this.env = env;
        this._viewContainer = _viewContainer;
        this.builder = builder;
        this.element = element;
        /**
         * Tells the component not to render expansion control, in such case we expandAll as a
         * default behavior
         *
         */
        this.showExpansionControl = true;
        /**
         * Opens all tree nodes.
         *
         */
        this.expandAll = false;
        /**
         *
         * Set indentation size to be used for each level
         *
         */
        this.indentationPerLevel = 25;
        this.pushRootSectionOnNewLine = false;
        /**
         *
         * Identifies current model mode.
         *
         * We recognize two modes:
         *
         * Free - Application needs to implement a children method to retrieve a list of children for
         * each node and format is pretty much upt to the application
         *
         * Tree - this is more restrictive where we have concrete data structure
         * interface that needs to be folled
         *
         * todo: instead of passing format binding try to look into the list to see what type so
         * we dont make it mandatory
         *
         */
        this.format = 'free';
        /**
         *
         * Used when in selection mode to push current selected Item to the application
         *
         */
        this.onItemSelected = new EventEmitter();
        /**
         *
         * This event is triggered by OutlineControl when node is expanded or collapsed
         *
         */
        this.onExpandChange = new EventEmitter();
        this.embedded = false;
        /**
         * Flag that tells us that component is fully rendered
         *
         */
        this.viewInitialized = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.state)) {
            this.state = new OutlineState();
        }
        if (isBlank(this.state.outlineFor)) {
            this.state.outlineFor = this;
        }
        if (this.expandAll) {
            this.showExpansionControl = false;
        }
        this.state.isExpandedAll = this.expandAll;
        // in case we want to render content of tree outside of outlineFor
        if (isPresent(this.externalTemplate)) {
            this.controlTemplate = this.externalTemplate;
        }
        this.embedded = this.element.nativeElement.hasAttribute('awoutlinefor');
        if (isBlank(this.context)) {
            this.context = this;
        }
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @return {?}
     */
    isTreeModelFormat() {
        return this.format === 'tree';
    }
    /**
     * Used by template and OutlineControl to identify which item is expanded and collapsed
     *
     * @param {?} item
     * @param {?=} currentLevel
     * @return {?}
     */
    isExpanded(item, currentLevel = -1) {
        if (currentLevel === 0 && this.pushRootSectionOnNewLine) {
            // always override/reset for root nodes
            if (this.isTreeModelFormat()) {
                (/** @type {?} */ (item)).isExpanded = true;
            }
            return true;
        }
        return this.state.isExpanded(item);
    }
    /**
     *
     * Since we have currently two ways how to pass children items we need have this method to
     * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
     * we expect current object to have `children` field
     *
     * @param {?} item
     * @return {?}
     */
    childrenForItem(item) {
        if (this.isTreeModelFormat()) {
            return (/** @type {?} */ (item)).children || [];
        }
        else {
            return this.hasChildren(item) ? this.doGetChildren(item) : [];
        }
    }
    /**
     *
     * Check if the current item has a children and needs to be rendered
     *
     * @param {?} item
     * @return {?}
     */
    hasChildren(item) {
        if (this.isTreeModelFormat()) {
            let /** @type {?} */ children = (/** @type {?} */ (item)).children;
            return isPresent(children) && children.length > 0;
        }
        else if (isBlank(this.children) && isBlank(item.children)) {
            assert(false, 'Missing [children] method binding');
        }
        return this.doGetChildren(item).length > 0;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    doGetChildren(item) {
        return this.children.apply(this.context, [item]);
    }
    /**
     *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
     *  put together inside `OutlineControl` where we iterate all the way to the root and add
     *  each item to the `currentPath` array. This way we collect list of item representing current
     *  current expansionPath.
     *
     *
     * @return {?}
     */
    toggleExpansion() {
        if (this.animationInProgress) {
            // backup procedure in case onAnimationDone fails
            setTimeout(() => {
                if (this.animationInProgress) {
                    // change only if its fails
                    this.animationInProgress = false;
                }
            }, 200);
            return;
        }
        if (!this.embedded) {
            this.animationInProgress = true;
        }
        let /** @type {?} */ currentItem = ListWrapper.last(this.state.currentPath);
        this.state.toggleExpansion(this.state.currentPath, this.childrenForItem(currentItem));
        if (this.embedded) ;
    }
    /**
     * Angular anim. callback that sets back the flag to make sure we don't trigger animations
     * when one is in progress.
     *
     * @param {?} event
     * @return {?}
     */
    onAnimationDone(event) {
        this.animationInProgress = false;
    }
    /**
     * Calculated indentation used to shift the nested section to the right or later on to the
     * left when RTL is supported
     *
     *
     * @param {?} currentLevel
     * @return {?}
     */
    indentation(currentLevel) {
        if (this.pushRootSectionOnNewLine && currentLevel > 0) {
            currentLevel -= 1;
        }
        return (currentLevel === 0 && this.pushRootSectionOnNewLine)
            ? 0 : (this.indentationPerLevel * currentLevel);
    }
    /**
     * Not all rows are visible by default, there can be a case where you dont want to render items
     * using outline. e.g. Datatable with detail row.
     * @param {?} item
     * @return {?}
     */
    isVisible(item) {
        if (isPresent(this.filterOut)) {
            return !this.filterOut(item);
        }
        return true;
    }
}
OutlineForComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-outline-for, [awOutlineFor]',
                template: `<!--
    Starts with the list, where nestingLevel is -1.
    call template outlineItems to iterate and render each item
-->
<ng-container [ngIf]="list" *ngTemplateOutlet="outlineItems;
            context:{ $implicit: list, nestingLevel: 0, parentItem: null, expanded: true}">
</ng-container>

<!--
    Main Entry point for the recursion. this is called by the block above as well as byt the inner
    piece that calls this template recursively again when an item has children
-->
<ng-template #outlineItems let-children let-nestingLevel="nestingLevel"
             let-parent="parentItem" let-expanded="expanded">

    <ng-template ngFor let-item [ngForOf]="children" let-rowIndex="index">

        <ng-container *ngTemplateOutlet="outlineItem;
            context:{ $implicit: item, nestingLevel: nestingLevel, parentItem: parent,
            expanded: expanded, rowIndex:rowIndex}">
        </ng-container>

        <!--

            Recursion piece:

            For non embedded case when even if its not expanded we need to iterate children
            as we want to apply animation that should go with ngIf which inside the outineItem
            template

            Dont recurse/ render items that are not visible.
        -->

        <ng-template [ngIf]="hasChildren(item) && (isExpanded(item, nestingLevel) || !embedded) && isVisible(item)">
            <ng-container *ngTemplateOutlet="outlineItems;
                        context:{ $implicit: childrenForItem(item),
                                nestingLevel: nestingLevel+1,
                                expanded: isExpanded(item, nestingLevel),
                                parentItem:item }">
            </ng-container>
        </ng-template>
    </ng-template>
</ng-template>


<!--
    Renders actual outline node and applies animation while expanding and collapsing

    [@section]="expanded || isExpanded(item) ? 'visible' : 'hidden'"
-->
<ng-template #outlineItem let-item let-nestingLevel="nestingLevel" let-parent="parentItem"
             let-rowIndex="rowIndex"
             let-expanded="expanded">

    <div class="w-outline-item"
         *ngIf="!embedded && expanded"
         [style.padding-left.px]="indentation(nestingLevel)"
         initNesting [setLevel]="nestingLevel" [setParentItem]="parent"
         [setCurrrentItem]="item"
         [@section]
         (@section.done)="onAnimationDone($event)">

        <ng-container *ngTemplateOutlet="controlTemplate;
                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex }">
        </ng-container>
    </div>

    <!--
        When outline control is used as embedded meaning its inside e..g datatable we
        cannot have any tags around it.

        Todo: Refactor this in the way so we can do animation when table lines are
        expanded. Since its embedded we can not have any wrapping element around, the template
        is fully responsible
    -->
    <ng-template [ngIf]="embedded && expanded"
                 initNesting [setLevel]="nestingLevel" [setParentItem]="parent"
                 [setCurrrentItem]="item"
    >
        <ng-container #renderedItem *ngTemplateOutlet="controlTemplate;
                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex  }">
        </ng-container>
    </ng-template>

</ng-template>


`,
                styles: [`.is-outline-animation>div,::ng-deep .w-outline-item{overflow:hidden}`],
                animations: [
                    trigger('section', [
                        state('*', style({
                            'overflow-y': 'hidden',
                            'height': '*',
                            'opacity': '1'
                        })),
                        state('void', style({
                            'height': '0',
                            'opacity': '0',
                            'overflow-y': 'hidden'
                        })),
                        transition('* => void', animate('200ms ease-out')),
                        transition('void => *', animate('200ms ease-in'))
                    ]),
                ]
            },] },
];
/** @nocollapse */
OutlineForComponent.ctorParameters = () => [
    { type: Environment },
    { type: ViewContainerRef },
    { type: AnimationBuilder },
    { type: ElementRef }
];
OutlineForComponent.propDecorators = {
    list: [{ type: Input }],
    showExpansionControl: [{ type: Input }],
    children: [{ type: Input }],
    filterOut: [{ type: Input }],
    expandAll: [{ type: Input }],
    state: [{ type: Input }],
    indentationPerLevel: [{ type: Input }],
    externalTemplate: [{ type: Input }],
    context: [{ type: Input }],
    pushRootSectionOnNewLine: [{ type: Input }],
    format: [{ type: Input }],
    onItemSelected: [{ type: Output }],
    onExpandChange: [{ type: Output }],
    controlTemplate: [{ type: ContentChild, args: ['outline',] }],
    outlineItem: [{ type: ViewChild, args: ['renderedItem',] }]
};
/**
 *
 * Since we can not directly set `*ngTemplateOutlet` context variables to the typescript class we
 * use this directive to do the Job
 *
 */
class InitNestingDirective {
    /**
     * @param {?} outline
     */
    constructor(outline) {
        this.outline = outline;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isPresent(this.setLevel)) {
            this.outline.state.currentLevel = this.setLevel;
        }
        if (isPresent(this.setCurrrentItem)) {
            this.outline.currentItem = this.setCurrrentItem;
            if (this.outline.isTreeModelFormat()) {
                this.outline.currentItem['$$parentItem']
                    = (/** @type {?} */ (this.setCurrrentItem)).parent;
            }
        }
        if (!this.outline.isTreeModelFormat() && isPresent(this.setParentItem)) {
            this.outline.currentItem['$$parentItem'] = this.setParentItem;
        }
    }
}
InitNestingDirective.decorators = [
    { type: Directive, args: [{
                selector: '[initNesting]'
            },] },
];
/** @nocollapse */
InitNestingDirective.ctorParameters = () => [
    { type: OutlineForComponent }
];
InitNestingDirective.propDecorators = {
    setLevel: [{ type: Input }],
    setCurrrentItem: [{ type: Input }],
    setParentItem: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * OutlineControlComponent renders the indentation, arrow, and text for a node in an outline.
 * It should be used either in the body of an OutlineFor component, or inside datatable
 *
 *
 * ##Usage inside body:
 *
 *  Here you can see that we need to wrap out content inside ng-template which will push us
 *  give us current item item and then we can place OutlineControlComponent to control
 *  the tree.
 *
 * ```
 *  <aw-outline-for2 #ooo [list]="list" [hasChildren]="hasChildren">
 *
 *      <ng-template #outline let-item>
 *          <div class="my-section">
 *              <div class="outline">
 *                  <aw-outline-control>
 *                      {{item?.content}}
 *                  </aw-outline-control>
 *              </div>*
 *          </div>
 *      </ng-template>
 *  </aw-outline-for2>
 *
 *
 * ```
 *
 * We can
 *
 *
 */
class OutlineControlComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} outlineState
     * @param {?} parentControl
     * @param {?} outlineFor
     */
    constructor(env, outlineState, parentControl, outlineFor) {
        super(env);
        this.env = env;
        this.outlineState = outlineState;
        this.parentControl = parentControl;
        this.outlineFor = outlineFor;
        /**
         *
         *  If TRUE it changes the behavior of the outline node text which click is triggered
         *  it selects the item and broadcast the `onItemSelected` event
         *
         */
        this.allowSelection = false;
        this.allowEdit = false;
        /**
         *
         * Triggers action when outline item is expanded
         *
         */
        this.action = new EventEmitter();
        this.isRootItem = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.prepareControl();
    }
    /**
     *
     * We dont show expansion icons when there no children
     *
     * @return {?}
     */
    hasExpansionControl() {
        return this.outlineFor.hasChildren(this.item) && this.outlineFor.showExpansionControl;
    }
    /**
     * @return {?}
     */
    isSelected() {
        return this.outlineFor.state.selectedItem === this.item;
    }
    /**
     * @return {?}
     */
    calculateStyleClass() {
        if (!this.hasExpansionControl() ||
            (this.outlineFor.pushRootSectionOnNewLine && isBlank(this.item.$$parentItem))) {
            return '';
        }
        if (this.outlineFor.embedded) {
            return this.outlineFor.isExpanded(this.item) ? 'icon-slim-arrow-down'
                : 'icon-slim-arrow-right';
        }
        else {
            return this.outlineFor.isExpanded(this.item)
                ? 'icon-slim-arrow-right outline-icon-expanded' : 'icon-slim-arrow-right';
        }
    }
    /**
     * Collapses and expands current node
     *
     * @param {?} event
     * @return {?}
     */
    toggleExpansion(event) {
        this.outlineFor.state.currentPath = [];
        let /** @type {?} */ currentPath = this.item;
        while (isPresent(currentPath)) {
            this.outlineFor.state.currentPath.unshift(currentPath);
            currentPath = currentPath.$$parentItem;
        }
        this.outlineFor.toggleExpansion();
        let /** @type {?} */ payload = {
            item: this.item,
            expanded: this.outlineFor.state.isExpanded(this.item)
        };
        this.action.emit(payload);
        this.outlineFor.onExpandChange.emit(payload);
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    select() {
        this.outlineFor.state.selectedItem = this.item;
        this.outlineFor.onItemSelected.emit(this.item);
    }
    /**
     * @return {?}
     */
    prepareControl() {
        if (isBlank(this.outlineFor) && isPresent(this.outlineState)) {
            this.outlineFor = this.outlineState.outlineFor;
        }
        assert(isPresent(this.outlineFor), 'Missing outlineFor component');
        if (this.outlineFor.embedded) {
            let /** @type {?} */ level = this.outlineFor.state.currentLevel;
            if (this.outlineFor.pushRootSectionOnNewLine && level > 0) {
                level -= 1;
            }
            this.indentation = (this.outlineFor.indentationPerLevel * level);
        }
        this.item = this.outlineFor.currentItem;
        this.isRootItem = isBlank(this.item.$$parentItem);
    }
}
OutlineControlComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-outline-control',
                template: `<!--
    Control is just the two flex box items for displaying expand/collapse icon and content

    Since we animate only standalone/non-embedded case now then we need to also animate the icon
    so we use only icon-slim-arrow-right and do tranformation on top of this to make it rotate.

    If embedded case we use both icons icon-slim-arrow-right / icon-slim-arrow-down
-->
<div class="w-outline-control"
     [ngClass]="{'outline-u-unselectable-text': outlineFor.pushRootSectionOnNewLine && !item.$$parentItem}">
    <div class="outline-icon sap-icon"
         *ngIf="!outlineFor.pushRootSectionOnNewLine || !isRootItem"
         (click)="toggleExpansion($event)"
         [style.margin-left.px]="indentation"
         [ngClass]="calculateStyleClass()">
    </div>

    <ng-container *ngIf="allowSelection; then withSelection else withoutSelection">
    </ng-container>
</div>

<!--
 We support two case for the content

 Selection: When you click on the content it will add extra class so you can style currently
 selected item as well as broadcast event outside so developer can hook in some custom logic

 If we dont support selection: Then clicking on the content is just like clicking on expandable
 icon, it toggles the state
-->

<ng-template #withSelection>
     <span class="outline-content outline-content-selected" *ngIf="!allowEdit && isSelected()">
        <ng-container *ngTemplateOutlet="ngContent"></ng-container>
    </span>
    <span class="outline-content" *ngIf="!allowEdit && !isSelected()" (click)="select()">
        <ng-container *ngTemplateOutlet="ngContent"></ng-container>
    </span>

</ng-template>


<ng-template #withoutSelection>
    <span *ngIf="!allowEdit" class="outline-content" (click)="toggleExpansion($event)">
        <ng-container *ngTemplateOutlet="ngContent"></ng-container>
    </span>
    <span *ngIf="allowEdit" class="outline-content">
        <ng-container *ngTemplateOutlet="ngContent"></ng-container>
    </span>
</ng-template>


<ng-template #ngContent>
    <ng-content></ng-content>
</ng-template>

`,
                styles: [`.w-outline-control{overflow:hidden;display:flex;flex-wrap:nowrap;cursor:pointer}.w-outline-control .outline-icon{flex:0 0 15px;color:#ababab;font-size:14px;font-weight:700;min-width:11px;align-self:center;transition:-webkit-transform 50ms ease-in;transition:transform 50ms ease-in;transition:transform 50ms ease-in,-webkit-transform 50ms ease-in;-webkit-transform-origin:25% 65%;transform-origin:25% 65%;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.w-outline-control .outline-icon.outline-icon-expanded{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.w-outline-control .outline-content{flex:1 1 auto;flex-wrap:wrap;padding:0 4px}.w-outline-control .outline-content.outline-content-selected{cursor:default;font-weight:700}.outline-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;cursor:auto}`],
            },] },
];
/** @nocollapse */
OutlineControlComponent.ctorParameters = () => [
    { type: Environment },
    { type: OutlineState, decorators: [{ type: Optional }, { type: Inject, args: [forwardRef(() => OutlineState),] }] },
    { type: OutlineControlComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => OutlineControlComponent),] }] },
    { type: OutlineForComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => OutlineForComponent),] }] }
];
OutlineControlComponent.propDecorators = {
    title: [{ type: Input }],
    allowSelection: [{ type: Input }],
    allowEdit: [{ type: Input }],
    action: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWOutlineForModule {
}
AWOutlineForModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    OutlineForComponent,
                    OutlineControlComponent,
                    InitNestingDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCoreComponentModule
                ],
                exports: [
                    OutlineForComponent,
                    OutlineControlComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Renders html text area component
 *
 * ### Example
 *
 * ```typescript
 *
 * \@Component({
 *          selector: 'myNote' ,
 *          template: '<aw-text-area [value]="inputValue" [autoResize]="autoResize" >
 *              </aw-text-area>'
 *      })
 *      export class MyNoteComponent
 *      {
 *          inputValue: string = 'Some really long text';
 *          autoResize: false;
 *      }
 *
 * ```
 *  Note: if you are using this outside of FormTable please provide your own FormGroup
 */
const /** @type {?} */ TEXTAREA_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => TextAreaComponent),
    multi: true
};
class TextAreaComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         *
         * A value used to store and read user input
         *
         */
        this.value = '';
        /**
         * Spefifies visible number of lines
         */
        this.rows = 2;
        /**
         * Specifies visible width
         */
        this.columns = 20;
        /**
         * when this option is TRUE and user starts typing it will maximize textarea's width and height
         */
        this.autoResize = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.value);
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(val => {
            this.value = val;
            this.onModelChanged(this.value);
        });
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value, { onlySelf: true });
        }
    }
}
TextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-text-area',
                template: `<div *ngIf="editable" [formGroup]="formGroup">

	<textarea
        pInputTextarea
        [attr.name]="name"
        class="w-text-area"
        [class.u-validation-error]="!(formControl.valid || (formControl.pristine))"
        [class.disabled]="disabled"
        formControlName="{{name}}"
        [rows]="rows"
        [cols]="columns"
        [autoResize]="autoResize"
        [attr.placeholder]="placeHolder"

    ></textarea>

</div>


<ng-template [ngIf]="!editable">
    <aw-string [value]="value"></aw-string>
</ng-template>
`,
                styles: [``],
                providers: [
                    TEXTAREA_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => TextAreaComponent) }
                ]
            },] },
];
/** @nocollapse */
TextAreaComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
TextAreaComponent.propDecorators = {
    value: [{ type: Input }],
    rows: [{ type: Input }],
    columns: [{ type: Input }],
    autoResize: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWTextAreaModule {
}
AWTextAreaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    TextAreaComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextareaModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    TextAreaComponent
                ],
                exports: [
                    TextAreaComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Page-Notification component that implements a notification system for the user regarding
 * the current object he's working on. Typical notification are:
 *      Success - saved.
 *      Warning - Sourcing request requires 3 suppliers.
 *      Error   - cannot connect to server, check internet connection.
 *
 *
 *
 * Usage 1:  As part of page wrapper.
 *
 * \@Component({
 *    selector: 'MyPage' ,
 *    template: `
 *       <aw-object-page-wrapper
 *                        [title]="MyPage"
 *                        [objectType]="MyType"
 *                        [notification]="pageNotification">
 *             page content
 *          `
 *       </aw-object-pager-wrapper>
 *    })
 *    export class MyPage
 *    {
 *
 *        pageNotification: PageNotification = new PageNotification("warn",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *    }
 *
 * Usage 2: directly into the page.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *      <aw-header></aw-header>
 *        Page Header
 *
 *        <ng-template [ngIf]="hasNotifications()">
 *          <div class="ui-g-12 u-nopadding">
 *            <aw-page-notification [notification]="notification"></aw-page-notification>
 *          </div>
 *        </ng-template>
 *
 *      <aw-footer></aw-footer>
 *    `
 *    })
 *    export class MyPage
 *    {
 *
 *        notification: PageNotification = new PageNotification("warning",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *    }
 *
 */
class PageNotificationComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
    /**
     * @return {?}
     */
    notificationClass() {
        return `notification-${this.notification.type}`;
    }
    /**
     * @return {?}
     */
    notificationIcon() {
        return `ariba-icon icon-${this.notification.type}`;
    }
}
PageNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-notification',
                template: `<div class="page-notification">
    <div [class]="notificationClass()">
        <i [class]="notificationIcon()"></i>
        <span class="content">
              <span class="title">{{notification.title}}</span>
              <span class="description">
                    <ng-template *ngIf="notification.hasTemplate(); else description"
                                 [ngTemplateOutlet]="notification.contentTmpl">
                    </ng-template>
                    <ng-template #description>{{notification.description}}</ng-template>
              </span>
      </span>
    </div>
</div>
`,
                styles: [`.page-notification{margin:0 0 5px}.notification-error,.notification-info,.notification-success,.notification-warning{padding:9px 8px}.notification-error i,.notification-info i,.notification-success i,.notification-warning i{font-size:24px;margin:10px}.notification-success i{color:#58b957}.notification-info i{color:#199de0}.notification-warning i{color:#f90}.notification-error i{color:#c00}.notification-success{background-color:#f1f9f1;border:1px solid rgba(88,185,87,.5)}.notification-info{background-color:#edf8fd;border:1px solid rgba(25,157,224,.5)}.notification-warning{background-color:#fff8dd;border:1px solid rgba(255,153,0,.5)}.notification-error{background-color:#ffebeb;border:1px solid rgba(204,0,0,.5)}.icon-error:before{content:"\\EA9D"}.icon-warning:before{content:"\\EA9C"}.content{vertical-align:super}.title{font-weight:700;margin-right:10px}`]
            },] },
];
/** @nocollapse */
PageNotificationComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
PageNotificationComponent.propDecorators = {
    notification: [{ type: Input }]
};
/**
 * Page Notification are messages for this page only. It displays in the center of the page
 * right under page title. Typical page notifications are 'save confirmation',
 * 'error during submit', warnings of field requirements, etc.
 */
class PageNotification {
    /**
     * @param {?} type
     * @param {?} title
     * @param {?} description
     * @param {?=} contentTmpl
     */
    constructor(type, title, description, contentTmpl) {
        this.type = type;
        this.title = title;
        this.description = description;
        this.contentTmpl = contentTmpl;
    }
    /**
     * @return {?}
     */
    hasTemplate() {
        return isPresent(this.contentTmpl);
    }
    /**
     * @return {?}
     */
    toString() {
        return this.type + ', title: ' + this.title + ', description:  ' + this.description;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWPageNotificationModule {
}
AWPageNotificationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    PageNotificationComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    PageNotificationComponent
                ],
                exports: [
                    PageNotificationComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Represents an event triggered when a page has been initialized.
 *
 */
class PageInitialized {
    /**
     * @param {?} title
     */
    constructor(title) {
        this.title = title;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageInitializied(title: ${this.title})`;
    }
}
/**
 * Represents an event triggered when a page has been destroyed.
 *
 */
class PageDestroyed {
    /**
     * @param {?} title
     */
    constructor(title) {
        this.title = title;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageDestroyed(title: ${this.title})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Page LifeCycle Service monitors all page initialization and destructions.
 * The purpose of this service is to help the application monitor page lifecycle, subscribe
 * to lifecycle events and execute actions such as user analytics.
 *
 * Usage:
 *
 *    1.  Inject PageLifeCycleService into your constructor
 *
 *    constructor(pageLifecycle:PageLifeCycleService) {
 *        pageLifecycle.pageEvents.subscribe(event:Event => {
 *            if(event instanceof PageInitialized) {
 *            }
 *            // PageDestroyed
 *
 *        });
 *     }
 */
class PageLifeCycleService {
    /**
     *
     */
    constructor() {
        /**
         * Page event queue when all page lifecycle events: init, destroy are emitted.
         * Listeners can subscribe to these events.
         */
        this.pageEvents = new Subject();
    }
    /**
     * Called when page is initialized.
     * @param {?} pageTitle
     * @return {?}
     */
    onPageInit(pageTitle) {
        this.pageEvents.next(new PageInitialized(pageTitle));
    }
    /**
     * Call when page has been destroyed
     * @param {?} pageTitle
     * @return {?}
     */
    onPageDestroy(pageTitle) {
        this.pageEvents.next(new PageDestroyed(pageTitle));
    }
}
PageLifeCycleService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
PageLifeCycleService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const PageType = {
    Init: 0,
    // Init Page type
    Login: 1,
    // Login Page
    Object: 2,
    // Object detail page
    List: 3,
    // List Page
    MasterDetail: 4,
    // MasterDetail
    Dashboard: 5,
    // Dashboard page
    Modal: 6,
};
PageType[PageType.Init] = "Init";
PageType[PageType.Login] = "Login";
PageType[PageType.Object] = "Object";
PageType[PageType.List] = "List";
PageType[PageType.MasterDetail] = "MasterDetail";
PageType[PageType.Dashboard] = "Dashboard";
PageType[PageType.Modal] = "Modal";
/**
 *  Page wrapper is the base class for all pages. The idea is that there are different page types
 *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
 *  a object page will render one object in detail.
 *
 *  They share common attributes such as page type and page id.
 *
 *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
 *  destroyed, it'll be complete.
 * @abstract
 */
class PageWrapper extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} pageType
     * @param {?} componentRegistry
     * @param {?} pageLifecycleService
     */
    constructor(env, pageType, componentRegistry, pageLifecycleService) {
        super(env);
        this.env = env;
        this.componentRegistry = componentRegistry;
        this.pageLifecycleService = pageLifecycleService;
        /**
         * What type of page this is.
         *
         */
        this.pageType = PageType.Init;
        this.pageType = pageType;
    }
    /**
     * Get the unique Id for this page.
     *
     * @return {?}
     */
    getId() {
        if (this.id) {
            return this.id;
        }
        this.id = this.generatePageId();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  This is a temporary implementation for the page header component.
 *  When the real implementation of side menu is done, PageHeaderComponent will
 *  be swaped to use it.
 *
 */
class SidenavComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
    /**
     * @return {?}
     */
    getSidenavClass() {
        // Only show if I have items
        return (this.show && this.items) ? 'sidenav sidenav-active' : 'sidenav';
    }
    /**
     * @return {?}
     */
    open() {
        this.show = true;
    }
    /**
     * @return {?}
     */
    close() {
        this.show = false;
    }
    /**
     * @return {?}
     */
    toggle() {
        this.show = !this.show;
    }
}
SidenavComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-sidenav',
                template: `<div [ngClass]="getSidenavClass()">
    <div class="sidenav-content">
        <a *ngFor="let item of items" [routerLink]="item.link">
            <span class="sidenav-icon"><i [ngClass]="'sap-icon ' + item.icon"></i></span>
            {{item.label}}
        </a>
    </div>
</div>
`,
                styles: [`.sidenav{height:100%;width:0;position:fixed;z-index:1;top:50px;left:0;background-color:#363636;overflow-x:hidden;padding-top:20px;transition:.5s}.sidenav-active{width:250px}.sidenav a{padding:8px 8px 8px 32px;text-decoration:none;font-size:16px;color:#fff;display:block;transition:.3s}.sidenav a:hover{background-color:#111}.sidenav-icon{font-size:30px;color:#ccc;margin-right:10px}`]
            },] },
];
/** @nocollapse */
SidenavComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
SidenavComponent.propDecorators = {
    items: [{ type: Input }],
    show: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Header component that implements consistent styling, behavior for an Ariba page.
 * Header includes a menu, user profile, and alerts.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *                <aw-page-header [showBackAction]="true" userName="Chad Noll"
 *                                 [menuItems]="menuItems" [notifications]="userNotifications">
 *                     <div class="page-header-center">
 *                           <a class="navbar-brand" tabindex="0" href="/">
 *                               <img class="navbar-logo" src="./images/SAP_Ariba_DB.png"
 *                                   alt="Go to homepage" data-pin-nopin="true">
 *                          </a>
 *                     </div>
 *                </aw-page-header>
 *
 *    `
 *    })
 *    export class MyPage
 *    {
 *      menuItems: PageMenuItem[] = [new PageMenuItem('icon-home', 'Home', '/play/'),
 *                                  new PageMenuItem('icon-expense-report', 'Reports',
 *                                                     '/play/pageheader'),
 *                                  new PageMenuItem('icon-sales-order', 'Purchase Order',
 *                                                       '/play/pageheader'),
 *                                  new PageMenuItem('icon-account', 'Accounts',
 *                                                     '/play/pageheader')];
 *
 *     userNotifications: UserNotification[] = [
 *       new UserNotification('icon-expense-report', 'Expense report EXP453 has been approved.',
 *                             '/play/'),
 *         new UserNotification('icon-sales-order', 'Sales Order SO1234 has been created.',
 *                             '/play/'),
 *           new UserNotification('icon-account', 'Supplier account SA1234 has been updated.',
 *                               '/play/')
 *        ];
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
class PageHeaderComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     * @param {?} routing
     */
    constructor(element, env, routing) {
        super(env);
        this.element = element;
        this.env = env;
        this.routing = routing;
        /**
         * Should the user notification icon be hidden. Default it to show the icon even
         * if there's no notifications.
         *
         */
        this.hideNotification = false;
        /**
         * displays the back link that navigates user to the previous page when clicked.
         */
        this.showBackAction = false;
        this.showNotificationPanel = false;
    }
    /**
     * @return {?}
     */
    backAction() {
        this.routing.goBack();
    }
    /**
     * Do i have any menu items.
     *
     * @return {?}
     */
    hasMenuItems() {
        return (this.menuItems && this.menuItems.length > 0);
    }
    /**
     * Toggle the side navigation menu.
     * @return {?}
     */
    showHideMenu() {
        this.sidenav.toggle();
    }
    /**
     * Do I have any notifications.
     *
     * @return {?}
     */
    hasNotifications() {
        return isPresent(this.notifications) && this.notifications.length > 0;
    }
    /**
     * toggling wheather notification panel is displayed or not.
     * @return {?}
     */
    toggleNotificationPanel() {
        this.showNotificationPanel = !this.showNotificationPanel;
    }
}
PageHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-header',
                template: `<nav class="navbar page-header" role="navigation">

    <div class="ui-g">
        <div class="ui-g-12 ui-md-4 navbar-left">

        <span *ngIf="hasMenuItems()">
            <a (click)="showHideMenu()">
                <i class="sap-icon icon-paging"></i>
            </a>

            <!-- Side menu -->
            <aw-sidenav #sidemenu [items]="menuItems"></aw-sidenav>
        </span>
            <!-- End Hamburger menu. -->

            <!--  back action -->
            <span class="back-action">
            <a (click)="backAction()">
                <i *ngIf="showBackAction" class="sap-icon icon-arrow-left" role="button"></i>
            </a>
        </span>

        </div>

        <div class="ui-g-12 ui-md-4 navbar-center">

            <!-- central section.  Application can add Ariba-logo, search box, etc -->
            <ng-content select=".page-header-center"></ng-content>
        </div>

        <div class="ui-g-12 ui-md-4 navbar-right">
        <span *ngIf="userName">
            <img id="userProfilePicture" class="profile-logo" aria-hidden="true"
                 [title]="userName" src="{{assetFolder}}/images/default_image_small.png">
            <span class="profile-user" title="{{userName}}">{{userName}}</span>
        </span>

            <span *ngIf="!hideNotification" class="notification-container">

            <i #notificationIcon class="ariba-icon icon-notification"
               (click)="toggleNotificationPanel()"></i>
            <span *ngIf="hasNotifications()" class="notification-badge" aria-hidden="true">{{notifications.length}}</span>

                <!-- Originally I was using p-overlay-panel, however, it doesn't position correctly under the notification icon.
                     The positioning logic in prime ng needs some more investigation. So for now, use a div instead-->
            <div *ngIf="showNotificationPanel" class="notification-panel">

                <div class="notification-header">
                     Notifications
                </div>

                <ul class="notification-content">
                    <li *ngFor="let noti of notifications" class="notification-item">
                        <a [routerLink]="noti.link">
                            <span class="notification-item-icon"><i
                                [ngClass]="'sap-icon ' + noti.icon"></i></span>
                            {{noti.label}}
                        </a>
                    </li>
                </ul>
            </div>
        </span>
        </div>


    </div>
</nav>
`,
                styles: [`.page-header i{font-size:32px}.page-header .icon-paging{font-size:30px;position:relative;top:2px}.back-action{display:inline-block;margin-left:15px}.back-action i{position:relative;top:3px}.navbar{background:#000;color:#fff}.navbar-left{padding-left:15px;height:50px}.navbar-center{text-align:center;height:50px}.navbar-right{text-align:right;height:50px}.profile-logo{width:30px;height:30px;position:relative;top:2px}.profile-user{vertical-align:super;margin-right:30px}.icon-notification:before{content:"\\eA14"}.navbar #sidebar-menu-icon{position:relative;top:.5em}.notification-container{position:relative;margin-right:20px;display:inline-block}.notification-badge{display:inline-block;padding:2px 5px;font-size:12px;font-weight:700;color:#fff;background-color:#c00;border-radius:10px;position:absolute;top:0;left:16px}.notification-panel{position:absolute;right:-27px;top:45px;width:350px;color:#767676;box-shadow:0 2px 10px 0 rgba(0,0,0,.13);background-color:#fff;overflow:hidden;transition:all .3s ease-in-out}.notification-panel .notification-header{background-color:#f3f3f3;font-size:16px;height:50px;line-height:50px;text-align:center}.notification-panel .notification-content{padding:0;margin:0}.notification-panel .notification-item{height:50px;border-top:1px solid #d7d7d7;padding:15px 10px;white-space:nowrap;text-overflow:ellipsis}.notification-panel .notification-item a{color:#767676;text-decoration:none;line-height:35px}.notification-panel .notification-item:hover{background-color:#f7f8fa}.notification-panel .notification-item-icon{margin-right:15px;color:#767676;display:inline-block;margin-top:10px;vertical-align:middle}`]
            },] },
];
/** @nocollapse */
PageHeaderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment },
    { type: RoutingService }
];
PageHeaderComponent.propDecorators = {
    menuItems: [{ type: Input }],
    notifications: [{ type: Input }],
    hideNotification: [{ type: Input }],
    showBackAction: [{ type: Input }],
    userName: [{ type: Input }],
    sidenav: [{ type: ViewChild, args: ['sidemenu',] }]
};
/**
 * PageMenuItem represents an item in the page menu structure.
 */
class PageMenuItem {
    /**
     * @param {?} icon    - Icon of this menu item.
     * @param {?} label   - label of this item.
     * @param {?} link    - link to the destination when user clicks on it.
     */
    constructor(icon, label, link) {
        this.icon = icon;
        this.label = label;
        this.link = link;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageMenuItem: (label, ${this.label})`;
    }
}
/**
 * notification for the current logged in user.
 * Ex:  PR2049 has been approved.
 *      Order PO518 received.
 */
class UserNotification {
    /**
     * @param {?} icon   - alert notification icon
     * @param {?} label  - alert notification label
     * @param {?} link   - link
     */
    constructor(icon, label, link) {
        this.icon = icon;
        this.label = label;
        this.link = link;
    }
    /**
     * @return {?}
     */
    toString() {
        return `PageUserNotification: (label, ${this.label})`;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Footer component that implements consistent styling, behavior.
 * This footer component self contained.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *          <aw-page-footer>
 *               <div class="page-footer-logo">
 *                   <img src="images/ariba_logo_white_bkgd.png">
 *               </div>
 *               <div class="page-footer-user-info">
 *                   Chad Noll (cnoll) last visit {{last_visited | date:'MM/dd/yyyy h:mma' }}
 *                   | Buyer Organization
 *               </div>
 *               <span class="page-footer-copyright" #copyright>
 *                   <p>© 2020–2028 The Future, Inc. All rights reserved</p>
 *               </span>
 *           </aw-page-footer>
 *    `
 *    })
 *    export class MyPage
 *    {
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
class PageFooterComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
        /**
         * show default copyright. If copyright is passed in, then show the passed in one.
         */
        this.showDefaultCopyright = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.showDefaultCopyright = !isPresent(this.copyright);
    }
}
PageFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-footer',
                template: `<div class="page-footer">
    <div class="ui-g">
        <div class="ui-g-12 ui-md-8">

            <ng-content select=".page-footer-logo"></ng-content>

            <div class="user-info">
                <ng-content select=".page-footer-user-info"></ng-content>
            </div>

            <ul class="footer-links">
                <li role="presentation"><a href="http://www.ariba.com/legal/ariba_tou.cfm">Terms of
                    Use</a></li>
                <li role="presentation"><a
                    href="http://www.ariba.com/legal/ariba_security_policy.cfm">Security
                    Disclosure</a></li>
                <li role="presentation"><a
                    href="http://www.ariba.com/legal/ariba_privacy_statement.cfm">Privacy
                    Statement</a></li>
                <li role="presentation"><a
                    href="http://www.ariba.com/legal/ariba-privacy-statement">Cookie Statement</a>
                </li>
                <li role="presentation"><a
                    href="http://www.ariba.com/legal/ariba-privacy-statement">Participant
                    Statement</a></li>
            </ul>
        </div>

        <div class="ui-g-12 ui-md-4">
            <div class="u-bottom-align"></div>
            <div class="u-hright copyright">
                <ng-content select=".page-footer-copyright"></ng-content>
            </div>

            <!-- Default Copyright -->
            <div *ngIf="showDefaultCopyright" class="u-hright copyright">
                <p>© 1996–2017 Ariba, Inc. All rights reserved</p>
            </div>

        </div>
    </div>
</div>
`,
                styles: [`.page-footer{background:#fff;padding:15px 0 0;font-size:11px;border-top:1px solid #d7d7d7}.page-footer .user-info{color:#ccc}.page-footer .ui-g{margin:0 auto}.page-footer .copyright{color:#ccc}.footer-links{list-style:none;margin:0 -15px;padding:0;font-size:10px}.footer-links li{float:left}.footer-links:after,.footer-links:before{content:" ";display:table}.footer-links:after{clear:both}.footer-links>li,.footer-links>li>a{position:relative;display:block}.footer-links>li>a{padding:10px 15px;color:#199de0}`]
            },] },
];
/** @nocollapse */
PageFooterComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
PageFooterComponent.propDecorators = {
    copyright: [{ type: ContentChild, args: ['copyright',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Object Page Wrapper Component renders any object instance in detail. It has a uniform layout,
 * Header, Page title, Page notification, actions, content, and Footer.
 *
 *
 *  Usage:
 *
 * \@Component({
 *    selector: 'RFXPage' ,
 *    template: `
 *       <aw-object-page-wrapper
 *                        [title]="rfxEntity.headerInfo.title"
 *                        [objectType]="rfxEntity.headerInfo.eventTypeString"
 *                        [notification]="pageNotification">
 *
 *
 *           <aw-page-actions>
 *               <aw-button [type]="'submit'" [name]="'edit'" [value]="edit" [style]="'primary'">
 *                   Edit
 *                </aw-button>
 *               <aw-button [type]="'button'" [name]="'cancel'" [value]="cancel"
 *                                                         [style]="'secondary'">
 *                  Cancel
 *               </aw-button>
 *           </aw-page-actions>
 *
 *           <aw-page-content>
 *             <aw-section title="Sourcing request info" (onStateChanged)="onStateChange($event)">
 *
 *                   <m-context [object]="rfxEntity.headerInfo"
 *                              [operation]="this.editabilityState.headerInfoOp"
 *                              layout="Inspect"
 *                              uiGroup="HeaderGeneral"
 *                   >
 *                       <m-include-component></m-include-component>
 *                   </m-context>
 *
 *             </aw-section>
 *           </aw-page-content>
 *       </aw-object-page-wrapper>
 *    `
 *    })
 *    export class RFXPage
 *    {
 *       // To keep track what section is editable and which read only
 *       editabilityState: EditabilityState;
 *
 *       // Current RFX event
 *       rfxEntity: RfxEventEntity;
 *
 *       // Notifications
 *       notification: PageNotification = new PageNotification("warn",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
class ObjectPageWrapperComponent extends PageWrapper {
    /**
     * @param {?} element
     * @param {?} env
     * @param {?} componentRegistry
     * @param {?} pageLifecycleService
     */
    constructor(element, env, componentRegistry, pageLifecycleService) {
        super(env, PageType.Object, componentRegistry, pageLifecycleService);
        this.element = element;
        this.env = env;
        /**
         * Set true if page should not include any header. Need to set to true even no header
         * object is passed in. Otherwise, a default Header component will be added.
         */
        this.hideHeader = false;
        /**
         * Set true if page should not include any footer. Need to set to true even no footer
         * object is passed in. Otherwise, a default Footer component will be added.
         */
        this.hideFooter = false;
        /**
         * The positioning of the page actions (page buttons)
         *   'top' :    page buttons are placed at the top of the page, below the title, to the right.
         *   'bottom' : page buttons are placed at the bottom of the page, above the footer.
         *   'both'   : page buttons are placed at both top and bottom.
         *
         */
        this.pageActionPosition = 'top';
        /**
         * This flag is driven by pageActionPosition. The default position is top.
         * Value is true for both 'top' and 'both' of pageActionPosition.
         */
        this.hasTopPageActions = true;
        this.objectStateIndex = 0;
        // Setting Default header component
        this.header = PageHeaderComponent;
        this.footer = PageFooterComponent;
    }
    /**
     * Generate a unique Id for this object.
     *
     * @return {?}
     */
    generatePageId() {
        return this.objectType + '_' + this.title + (this.id) ? ('_' + this.id) : '';
    }
    /**
     * Does my page have page notification?
     *
     * @return {?}
     */
    hasNotifications() {
        return (this.notifications && this.notifications.length > 0);
    }
    /**
     * @return {?}
     */
    hasObjectStates() {
        return isPresent(this.objectStates);
    }
    /**
     * Initialize my local components
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // New Component types that are used in c-include-component
        if (this.header) {
            this.componentRegistry.registerType(this.header.name, this.header);
        }
        // New Component types that are used in c-include-component
        if (this.footer) {
            this.componentRegistry.registerType(this.footer.name, this.footer);
        }
        /** notify subscribers of the page lifecycle service  */
        this.pageLifecycleService.onPageInit(this.title);
        // Setting the page action position.
        if (this.pageActionPosition === 'bottom') {
            this.hasTopPageActions = false;
            this.hasBottomPageActions = true;
        }
        else if (this.pageActionPosition === 'both') {
            this.hasTopPageActions = true;
            this.hasBottomPageActions = true;
        }
        if (isPresent(this.objectStates) && this.objectStates.length > 1
            && isPresent(this.currentState)) {
            this.objectStateIndex = this.objectStates.indexOf(this.currentState);
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (isPresent(changes['currentState']) &&
            changes['currentState'].currentValue !== changes['currentState'].previousValue) {
            // we dont need to check if objectStates exists
            this.objectStateIndex = this.objectStates.indexOf(this.currentState);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.pageLifecycleService.onPageDestroy(this.title);
    }
}
ObjectPageWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-object-page-wrapper',
                template: `<div class="page-wrapper">
    <ng-template [ngIf]="!hideHeader">
        <aw-include-component [name]='header.name'></aw-include-component>
    </ng-template>

    <div class="arc-object-detail">

        <div class="ui-g">

            <!-- page header -->
            <div class="ui-g-12 page-title">

                <!-- page title -->
                <div class="ui-g-8 ui-md-8 page-title-text">{{title}}</div>

                <div class="ui-g-4 ui-md-4 page-status">
                    <span class="object-status-label">{{objectStatusLabel}} &nbsp;</span>
                    <span class="object-status">{{objectStatus}}</span>
                </div>
            </div>

            <!-- page actions -->
            <div class="ui-g-12 page-actions" *ngIf="hasTopPageActions">
                <ng-template [embeddedItem]="actionsTemplate"
                             *ngIf="hasTopPageActions"></ng-template>
            </div>

            <!-- object states  displays only if state exists. -->
            <div class="ui-g-12 page-state">
                <div class="ui-g-3 page-state-left" [class.content]="hasObjectStates()">
                    <ng-content select=".page-state-left"></ng-content>
                </div>
                <div class="ui-g-6 page-state-center">
                    <ng-container *ngIf="hasObjectStates()">
                        <aw-stepper [steps]="objectStates"
                                    [currentStep]="objectStateIndex"></aw-stepper>
                    </ng-container>
                </div>
                <div class="ui-g-3 page-state-right">
                    <ng-content select=".page-state-right"></ng-content>
                </div>
            </div>


            <!-- Page Notification -->
            <ng-template [ngIf]="hasNotifications()">
                <div class="ui-g-12 u-nopadding">

                    <aw-page-notification *ngFor="let notification of notifications"
                                          [notification]="notification"></aw-page-notification>
                </div>
            </ng-template>

            <!-- additional content -->
            <ng-content select="aw-page-content"></ng-content>

        </div>

    </div>

    <!-- page actions -->
    <div class="ui-g-12 page-actions-bottom" *ngIf="hasBottomPageActions">
        <ng-template [embeddedItem]="actionsTemplate"
                     *ngIf="hasBottomPageActions"></ng-template>

    </div>

    <div class="page-push"></div>
</div>

<ng-template [ngIf]="!hideFooter">
    <aw-include-component [name]='footer.name'></aw-include-component>
</ng-template>
`,
                styles: [`.page-wrapper{background-color:#f2f2f2;min-height:100%;margin-bottom:-100px}.arc-object-detail{padding:20px}.page-title-text{font-size:22px;color:#000;padding:14px 0}.page-title{padding:5px 0;border-bottom:1px solid #d7d7d7}.page-actions{padding:15px 0 5px}.page-actions-bottom{padding:0 20px}.page-state,.page-state-center,.page-state-left,.page-state-right{padding:0}.content::after{content:'\\00a0';font-size:0}.page-title /deep/ .ui-button{min-width:100px}.page-status{text-align:right;padding:18px 0}.page-status .object-status-label{color:#767676}.page-status .object-status{font-weight:700;color:#038719}.page-push{height:100px}`]
            },] },
];
/** @nocollapse */
ObjectPageWrapperComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment },
    { type: ComponentRegistry },
    { type: PageLifeCycleService }
];
ObjectPageWrapperComponent.propDecorators = {
    title: [{ type: Input }],
    objectType: [{ type: Input }],
    objectStatusLabel: [{ type: Input }],
    objectStatus: [{ type: Input }],
    objectStates: [{ type: Input }],
    currentState: [{ type: Input }],
    header: [{ type: Input }],
    hideHeader: [{ type: Input }],
    footer: [{ type: Input }],
    hideFooter: [{ type: Input }],
    pageActionPosition: [{ type: Input }],
    actionsTemplate: [{ type: ContentChild, args: ['pageActions',] }],
    notifications: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Page actions is a wrapper for all page actions, buttons, links, menus that interacts it with the
 * page. The wrapper use the ability to position it as needed.
 */
class PageActionsComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
}
PageActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-actions',
                template: `<div class="page-actions">
    <ng-content></ng-content>
</div>
`,
                styles: [`.page-actions{text-align:right;padding-top:0;padding-right:0}`]
            },] },
];
/** @nocollapse */
PageActionsComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Page content is a wrapper for page content.
 * Currently, it's pretty bare, but as we add more interactions on the page, like a side bar,
 * the page content area will likely get affected.
 */
class PageContentComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
    }
}
PageContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-page-content',
                template: '<ng-content></ng-content>',
                styles: [':host {width: 100%; padding: 0 .5em;}']
            },] },
];
/** @nocollapse */
PageContentComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ STEPPER_COMPLETED_STEP_COLOR = '#58b957';
const /** @type {?} */ STEPPER_CURRENT_STEP_COLOR = '#0076CB';
const /** @type {?} */ STEPPER_REMAINING_STEP_COLOR = '#D7D7D7';
/**
 * Stepper component displays a list of steps for user to follow. It can be used as a checklist
 * to indicate completed, current and remaining items. It could be also be used to indicate
 * the state of an document, created, submitted, approved, etc...
 *
 *
 * Usage:
 *   1.   Use the component inside your template. provide a list of steps and the current step.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                <aw-stepper [steps]="steps" [currentStep]="currentStep"></aw-stepper>
 *
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     steps: string[] = ['Monitor', 'Add Supplier', 'Get Quote'];
 *                     currentStep: number = 1;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *       }
 *
 *   2.  Override the default colors.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                            <aw-stepper [steps]="steps" [stepColorCurrent]="'#ff9900'"
 *                                        [stepColorRemaining]="'#CC0000'"
 *                                        [stepColorCompleted]="'#97a822'"
 *                                        [currentStep]="currentStep">
 *                            </aw-stepper>
 *                  `
 */
class StepperComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Local variable to indicate whether to use the colors array or not.
         */
        this.bUseColorArray = false;
        /**
         * The current step that's on. If not provided default to the first step.
         */
        this.currentStep = 0;
        // Initial color for the different stages of steps.
        this.stepColorCompleted = STEPPER_COMPLETED_STEP_COLOR;
        this.stepColorCurrent = STEPPER_CURRENT_STEP_COLOR;
        this.stepColorRemaining = STEPPER_REMAINING_STEP_COLOR;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Calculate the connector width based on how many steps
        if (isPresent(this.steps) && this.steps.length > 1) {
            // (100% - 20% (side margins)) / (NumOfSteps -1)
            this.connectorWidth = Math.ceil(80 / (this.steps.length - 1)) + '%';
        }
        /**
                 * Use the color array if it's defined.
                 */
        if (isPresent(this.colors)) {
            this.bUseColorArray = true;
            if (this.colors.length !== this.steps.length) {
                throw new Error(`The size of the steps and colors don't match:
                  (steps.length = ${this.steps.length}), (colors.length = ${this.colors.length}`);
            }
        }
    }
    /**
     * Getting the color of the step for the current index
     *
     * @param {?} index
     * @return {?}
     */
    getStepColor(index) {
        // Color Array overrides everything else.
        if (this.bUseColorArray) {
            return this.colors[index];
        }
        if (index < this.currentStep) {
            return this.stepColorCompleted;
        }
        else if (index === this.currentStep) {
            return this.stepColorCurrent;
        }
        else {
            return this.stepColorRemaining;
        }
    }
    /**
     * The connector colors are driven by the step colors.
     *
     * @param {?} index
     * @return {?}
     */
    getConnectorColor(index) {
        // Color Array overrides everything else.
        if (this.bUseColorArray) {
            return this.colors[index];
        }
        if (index < this.currentStep) {
            return this.stepColorCompleted;
        }
        else {
            return this.stepColorRemaining;
        }
    }
    /**
     * Next step.
     * @return {?}
     */
    nextStep() {
        this.currentStep++;
    }
    /**
     * previous step.
     * @return {?}
     */
    prevStep() {
        this.currentStep--;
    }
}
StepperComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-stepper',
                template: `<div class="stepper-container">
    <div class="steps">
        <div class="step-spacing"></div>

        <ng-container *ngFor="let step of steps; let i=index; let last=last;">
            <div class="step">
                <aw-step [title]="step" [color]="getStepColor(i)"></aw-step>
            </div>
            <div *ngIf="!last" class="step-connector" [style.width]="connectorWidth">
                <div class="connector" [style.borderBottomColor]="getConnectorColor(i)"></div>
            </div>
        </ng-container>

        <div class="step-spacing"></div>
    </div>

    <div class="step-labels"></div>
</div>


`,
                styles: [`.stepper-container{display:table;table-layout:fixed;width:100%}.steps{display:table-row}.step-spacing{display:table-cell;width:10%}.step{display:table-cell;width:32px}.step-connector{display:table-cell;vertical-align:middle}.connector{height:1px;border-bottom:3px solid #58b957}.step-labels{display:table-row;height:50px}`]
            },] },
];
/** @nocollapse */
StepperComponent.ctorParameters = () => [
    { type: Environment }
];
StepperComponent.propDecorators = {
    steps: [{ type: Input }],
    colors: [{ type: Input }],
    stepColorCompleted: [{ type: Input }],
    stepColorCurrent: [{ type: Input }],
    stepColorRemaining: [{ type: Input }],
    currentStep: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Renders html step component
 *
 *  * Usage:
 *       Straight forward to use. But mostly it would be used as part of the stepper component.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                           <aw-step [title]="step" [color]="color"></aw-step>
 *                           `
 */
const /** @type {?} */ DEFAULT_COLOR = '#58b957';
class StepComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        this.env = env;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (isBlank(this.color)) {
            this.color = DEFAULT_COLOR;
        }
    }
}
StepComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-step',
                template: `<div class="step-container">
    <div class="outer-circle" [style.borderColor]="color">
        <div class="inner-circle" [style.borderColor]="color" [style.backgroundColor]="color"></div>
    </div>

    <div class="step-title">{{title}}</div>
</div>

`,
                styles: [`.step-container{position:relative;width:32px}.outer-circle{width:26px;height:26px;border-radius:50%;background-color:#fff;border:3px solid #58b957;position:relative}.inner-circle{width:8px;height:8px;border-radius:50%;border:2px solid #58b957;background-color:#58b957;margin:0 auto;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.step-title{position:absolute;width:150px;top:40px;left:-60px;text-align:center}`]
            },] },
];
/** @nocollapse */
StepComponent.ctorParameters = () => [
    { type: Environment }
];
StepComponent.propDecorators = {
    color: [{ type: Input }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWStepperModule {
}
AWStepperModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    StepComponent,
                    StepperComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                ],
                entryComponents: [
                    StepComponent,
                    StepperComponent
                ],
                exports: [
                    StepComponent,
                    StepperComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWPageWrapperModule {
}
AWPageWrapperModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ObjectPageWrapperComponent,
                    PageActionsComponent,
                    PageContentComponent,
                    PageFooterComponent,
                    PageHeaderComponent,
                    SidenavComponent
                ],
                imports: [
                    CommonModule,
                    RouterModule,
                    AWCoreComponentModule,
                    AWStepperModule,
                    AWPageNotificationModule
                ],
                entryComponents: [
                    PageFooterComponent,
                    PageActionsComponent,
                    PageContentComponent,
                    PageHeaderComponent
                ],
                exports: [
                    ObjectPageWrapperComponent,
                    PageActionsComponent,
                    PageContentComponent,
                    PageFooterComponent,
                    PageHeaderComponent,
                    SidenavComponent
                ],
                providers: [PageLifeCycleService]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const EditorType = {
    Default: 0,
    // Default Editor supports Minimal set of functionality
    // [ bold | italic | underline | ordered | bullet | alignment]
    Full: 1,
    // The full list of functionality,
    TextFormat: 2,
    // Functionalities that affects text formatting.
    Custom: 3,
};
EditorType[EditorType.Default] = "Default";
EditorType[EditorType.Full] = "Full";
EditorType[EditorType.TextFormat] = "TextFormat";
EditorType[EditorType.Custom] = "Custom";
const /** @type {?} */ EDITOR_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => RichTextAreaComponent),
    multi: true
};
class RichTextAreaComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * A value used to save and read when rendering and updating this component
         */
        this.value = '';
        /**
         * Expose editorType so that it can be used in this components template.
         */
        this.EditorType = EditorType;
        this.type = EditorType.Default;
        this.styleClass = 'default-editor';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        super.registerFormControl(this.value);
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(val => {
            this.value = val;
            this.onModelChanged(this.value);
        });
    }
    /**
     * Internal. Please see ControlValueAccessor
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value);
        }
    }
}
RichTextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-richtextarea',
                template: `<ng-template [ngIf]="editable">

    <!-- Basic editor, also the default, which the most used features enabled. -->
    <div *ngIf="type === EditorType.Default">
        <p-editor [(ngModel)]="value" [styleClass]="styleClass" [style]="{'height':'180px'}"
                  [placeholder]="placeHolder">
            <p-header>
                    <span class="ql-formats">
                        <button class="ql-bold" aria-label="Bold"></button>
                        <button class="ql-italic" aria-label="Italic"></button>
                        <button class="ql-underline" aria-label="Underline"></button>
                    </span>
                <span class="ql-formats">
                        <button class="ql-list" value="ordered"></button>
                        <button class="ql-list" value="bullet"></button>
                    </span>
                <span class="ql-formats">
                            <button value="left" selected></button>
                            <button value="center"></button>
                            <button value="right"></button>
                            <button value="justify"></button>
                    </span>
            </p-header>
        </p-editor>
    </div>

    <!-- Editor with all the features enabled -->
    <div *ngIf="type === EditorType.Full">
        <p-editor [(ngModel)]="value" [styleClass]="styleClass" [style]="{'height':'180px'}"
                  [placeholder]="placeHolder"></p-editor>
    </div>

    <!-- Editor with all Text formatting  -->
    <div *ngIf="type === EditorType.TextFormat">
        <p-editor [(ngModel)]="value" [styleClass]="styleClass" [style]="{'height':'180px'}"
                  [placeholder]="placeHolder">
            <p-header>
            <span class="ql-format-group">
              <select title="Font" class="ql-font">
                <option value="sans-serif" selected="">Sans Serif</option>
                <option value="serif">Serif</option>
                <option value="monospace">Monospace</option>
              </select>
              <select title="Size" class="ql-size">
                <option value="10px">Small</option>
                <option value="13px" selected="">Normal</option>
                <option value="18px">Large</option>
                <option value="32px">Huge</option>
              </select>
            </span>
                <span class="ql-formats">
                    <button class="ql-bold" aria-label="Bold"></button>
                    <button class="ql-italic" aria-label="Italic"></button>
                    <button class="ql-underline" aria-label="Underline"></button>
                </span>
                <span class="ql-format-group">
              <select title="Text Color" class="ql-color">
                <option value="rgb(0, 0, 0)" label="rgb(0, 0, 0)" selected=""></option>
                <option value="rgb(230, 0, 0)" label="rgb(230, 0, 0)"></option>
                <option value="rgb(255, 153, 0)" label="rgb(255, 153, 0)"></option>
                <option value="rgb(255, 255, 0)" label="rgb(255, 255, 0)"></option>
                <option value="rgb(0, 138, 0)" label="rgb(0, 138, 0)"></option>
                <option value="rgb(0, 102, 204)" label="rgb(0, 102, 204)"></option>
                <option value="rgb(153, 51, 255)" label="rgb(153, 51, 255)"></option>
                <option value="rgb(255, 255, 255)" label="rgb(255, 255, 255)"></option>
                <option value="rgb(250, 204, 204)" label="rgb(250, 204, 204)"></option>
                <option value="rgb(255, 235, 204)" label="rgb(255, 235, 204)"></option>
                <option value="rgb(255, 255, 204)" label="rgb(255, 255, 204)"></option>
                <option value="rgb(204, 232, 204)" label="rgb(204, 232, 204)"></option>
                <option value="rgb(204, 224, 245)" label="rgb(204, 224, 245)"></option>
                <option value="rgb(235, 214, 255)" label="rgb(235, 214, 255)"></option>
                <option value="rgb(187, 187, 187)" label="rgb(187, 187, 187)"></option>
                <option value="rgb(240, 102, 102)" label="rgb(240, 102, 102)"></option>
                <option value="rgb(255, 194, 102)" label="rgb(255, 194, 102)"></option>
                <option value="rgb(255, 255, 102)" label="rgb(255, 255, 102)"></option>
                <option value="rgb(102, 185, 102)" label="rgb(102, 185, 102)"></option>
                <option value="rgb(102, 163, 224)" label="rgb(102, 163, 224)"></option>
                <option value="rgb(194, 133, 255)" label="rgb(194, 133, 255)"></option>
                <option value="rgb(136, 136, 136)" label="rgb(136, 136, 136)"></option>
                <option value="rgb(161, 0, 0)" label="rgb(161, 0, 0)"></option>
                <option value="rgb(178, 107, 0)" label="rgb(178, 107, 0)"></option>
                <option value="rgb(178, 178, 0)" label="rgb(178, 178, 0)"></option>
                <option value="rgb(0, 97, 0)" label="rgb(0, 97, 0)"></option>
                <option value="rgb(0, 71, 178)" label="rgb(0, 71, 178)"></option>
                <option value="rgb(107, 36, 178)" label="rgb(107, 36, 178)"></option>
                <option value="rgb(68, 68, 68)" label="rgb(68, 68, 68)"></option>
                <option value="rgb(92, 0, 0)" label="rgb(92, 0, 0)"></option>
                <option value="rgb(102, 61, 0)" label="rgb(102, 61, 0)"></option>
                <option value="rgb(102, 102, 0)" label="rgb(102, 102, 0)"></option>
                <option value="rgb(0, 55, 0)" label="rgb(0, 55, 0)"></option>
                <option value="rgb(0, 41, 102)" label="rgb(0, 41, 102)"></option>
                <option value="rgb(61, 20, 102)" label="rgb(61, 20, 102)"></option>
              </select>
              <span class="ql-format-separator"></span>
              <select title="Background Color" class="ql-background">
                <option value="rgb(0, 0, 0)" label="rgb(0, 0, 0)"></option>
                <option value="rgb(230, 0, 0)" label="rgb(230, 0, 0)"></option>
                <option value="rgb(255, 153, 0)" label="rgb(255, 153, 0)"></option>
                <option value="rgb(255, 255, 0)" label="rgb(255, 255, 0)"></option>
                <option value="rgb(0, 138, 0)" label="rgb(0, 138, 0)"></option>
                <option value="rgb(0, 102, 204)" label="rgb(0, 102, 204)"></option>
                <option value="rgb(153, 51, 255)" label="rgb(153, 51, 255)"></option>
                <option value="rgb(255, 255, 255)" label="rgb(255, 255, 255)" selected=""></option>
                <option value="rgb(250, 204, 204)" label="rgb(250, 204, 204)"></option>
                <option value="rgb(255, 235, 204)" label="rgb(255, 235, 204)"></option>
                <option value="rgb(255, 255, 204)" label="rgb(255, 255, 204)"></option>
                <option value="rgb(204, 232, 204)" label="rgb(204, 232, 204)"></option>
                <option value="rgb(204, 224, 245)" label="rgb(204, 224, 245)"></option>
                <option value="rgb(235, 214, 255)" label="rgb(235, 214, 255)"></option>
                <option value="rgb(187, 187, 187)" label="rgb(187, 187, 187)"></option>
                <option value="rgb(240, 102, 102)" label="rgb(240, 102, 102)"></option>
                <option value="rgb(255, 194, 102)" label="rgb(255, 194, 102)"></option>
                <option value="rgb(255, 255, 102)" label="rgb(255, 255, 102)"></option>
                <option value="rgb(102, 185, 102)" label="rgb(102, 185, 102)"></option>
                <option value="rgb(102, 163, 224)" label="rgb(102, 163, 224)"></option>
                <option value="rgb(194, 133, 255)" label="rgb(194, 133, 255)"></option>
                <option value="rgb(136, 136, 136)" label="rgb(136, 136, 136)"></option>
                <option value="rgb(161, 0, 0)" label="rgb(161, 0, 0)"></option>
                <option value="rgb(178, 107, 0)" label="rgb(178, 107, 0)"></option>
                <option value="rgb(178, 178, 0)" label="rgb(178, 178, 0)"></option>
                <option value="rgb(0, 97, 0)" label="rgb(0, 97, 0)"></option>
                <option value="rgb(0, 71, 178)" label="rgb(0, 71, 178)"></option>
                <option value="rgb(107, 36, 178)" label="rgb(107, 36, 178)"></option>
                <option value="rgb(68, 68, 68)" label="rgb(68, 68, 68)"></option>
                <option value="rgb(92, 0, 0)" label="rgb(92, 0, 0)"></option>
                <option value="rgb(102, 61, 0)" label="rgb(102, 61, 0)"></option>
                <option value="rgb(102, 102, 0)" label="rgb(102, 102, 0)"></option>
                <option value="rgb(0, 55, 0)" label="rgb(0, 55, 0)"></option>
                <option value="rgb(0, 41, 102)" label="rgb(0, 41, 102)"></option>
                <option value="rgb(61, 20, 102)" label="rgb(61, 20, 102)"></option>
              </select>
            </span>
                <span class="ql-formats">
                <button class="ql-list" value="ordered"></button>
                <button class="ql-list" value="bullet"></button>
            </span>
                <span class="ql-formats">
                    <button value="left" selected></button>
                    <button value="center"></button>
                    <button value="right"></button>
                    <button value="justify"></button>
            </span>
            </p-header>
        </p-editor>
    </div>

    <!-- Custom header Text Editor -->
    <div *ngIf="type === EditorType.Custom">
        <p-editor [(ngModel)]="value" [styleClass]="styleClass" [style]="{'height':'180px'}"
                  [placeholder]="placeHolder">
            <p-header>
                <ng-content select="custom-header"></ng-content>
            </p-header>
        </p-editor>
    </div>

</ng-template>


<ng-template [ngIf]="!editable">
    <aw-string [value]="value"></aw-string>
</ng-template>
`,
                styles: [`/deep/ .ui-editor-toolbar{background-color:#f5f5f5;border:1px solid #d7d7d7}/deep/ p-editor:active /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow{border-color:#199de0}/deep/ p-editor:active /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-content.ql-container.ql-snow{border-color:#199de0}`],
                providers: [
                    EDITOR_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => RichTextAreaComponent) }
                ]
            },] },
];
/** @nocollapse */
RichTextAreaComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => FormRowComponent),] }] }
];
RichTextAreaComponent.propDecorators = {
    type: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWRichTextAreaModule {
}
AWRichTextAreaModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RichTextAreaComponent
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    EditorModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    RichTextAreaComponent
                ],
                exports: [
                    RichTextAreaComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Allow developer to override default actions. Must have this declared before class when we
 * want to have this declaration inside the same file.
 */
class SectionActionsComponent {
}
SectionActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-section-actions',
                template: `<ng-content></ng-content> `,
            },] },
];
/**
 *
 * Section component that implements a section of the page. It's an outline box that
 * has the ability to expand and hide its content.
 *
 * ```ts
 * \@Component({
 *    selector: 'rfx-details' ,
 *    template: `
 *         <aw-section title="Sourcing request info" (onEdit)="onStateChange($event)"
 *                          [editable]="true">
 *
 *                <m-context [object]="rfxEntity.headerInfo"
 *                          [operation]="this.editabilityState.headerInfoOp"
 *                          layout="Inspect"
 *                          uiGroup="HeaderGeneral">
 *                   <m-include-component></m-include-component>
 *               </m-context>
 *           </aw-section>
 *
 *
 *           <aw-section #supplierSection title="Selected suppliers" (onOpen)="onOpen()"
 *                [opened]="false">
 *               <supplier-profile-card></supplier-profile-card>
 *           </aw-section>
 *
 *           <aw-section title="RFQ Details"
 *                       description="Review and update information for suppliers to respond."
 *                       [disableClose]="true">
 *
 *               <aw-subsection title="Event timeline">
 *                   <aw-form-table [useFiveZone]="false" [editable]="true">
 *
 *                       <aw-form-row [label]="'Start Date'" [name]="'startDate'" [size]="'small'"
 *                                   [highlightRow]="true">
 *                           <aw-date-time
 *                               formatName="dateTime"
 *                               name="startDate" [value]="rfxEntity.created"
 *                               [showTime]="true"></aw-date-time>
 *                       </aw-form-row>
 *                   </aw-form-table>
 *               </aw-subsection>
 *          </aw-section>
 *    `
 *    })
 *    export class MyPage
 *    {
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 *
 * ```
 *
 * Section component also supports editability modes and if enabled it will render action buttons
 * in the footer. Developer can also override default behavior and provide custom actions.
 *
 *
 * e.g:
 *
 * ```
 *      <aw-section [title]="title" [editable]="true"
 *                          (onCancelAction)="someHandler1($event)"
 *                          (onSaveAction)="someHandler2($event)" >
 *              section content
 *
 *
 *   </aw-section>
 *
 * ```
 *
 * or custom action buttons:
 *
 *
 * ```html
 *
 *       <aw-section-actions>
 *                      <aw-button >
 *                            ButtonTest1
 *                      </aw-button>
 *                      <aw-button>
 *                            ButtonTest2
 *                      </aw-button>
 *     </aw-section-actions>
 *
 * ```
 *
 *
 * There are two edit modes
 *  # Default
 *      Renders action buttons in the footers and emit actions to the application
 *
 *  # External
 *     No action buttons are shown in the footer and behavior is handled by application. Only event
 *     is emited.
 *
 *
 *  e.g:
 *
 *  ```ts
 *
 *      <aw-section title="User Information" (onEdit)="onAddSomething($event)"
 *                  [editable]="true" [editMode]="'external'" >
 *                  <div>
 *                      Content
 *                  </div>
 *      </aw-section>
 *
 *  ```
 *
 * Note: When using editing mode you have to call at the end of the editing cycle method
 * `completeEditing()` to commit editing which changes internal state of the Section.
 *
 *
 *
 */
class SectionComponent extends BaseComponent {
    /**
     * @param {?} element
     * @param {?} env
     */
    constructor(element, env) {
        super(env);
        this.element = element;
        this.env = env;
        /**
         * Should this section be opened at the start. Default is opened.
         */
        this.opened = true;
        /**
         * Whether this section can be closed or not.
         *
         */
        this.disableClose = false;
        /**
         * Whether this section is in EditState or not.
         *
         * When in editing state and we show "Cancel / Save" button developer needs use this binding
         * to control the state.
         */
        this.editState = false;
        /**
         * Current Editing mode. Tells the components if its its default behavior or driven by
         * application using this component.
         *
         * {\@see EditMode}
         *
         */
        this.editMode = 'default';
        /**
         * Developer can provide custom Edit action icon that will appear in the right top corner
         */
        this.actionIcon = 'icon-edit';
        /**
         * Event emitted when the section is fully opened.
         */
        this.onOpen = new EventEmitter();
        /**
         * Event emitted when the section is fully closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Edit state to broadcast state of current section
         */
        this.onEdit = new EventEmitter();
        /**
         * When in editing state and default buttons are rendered on click broadcast Cancel action
         */
        this.onCancelAction = new EventEmitter();
        /**
         * When in editing state and default buttons are rendered on click broadcast Save action
         */
        this.onSaveAction = new EventEmitter();
        this.onEditingComplete = new EventEmitter();
        this.editable = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        // If I have not header, then I can't close the section.
        if (!this.isHeaderDisplayed()) {
            this.disableClose = true;
        }
        // If I can't close the section, then it should default open.
        if (this.disableClose) {
            this.opened = true;
        }
        // initialize the expanded state.
        this.expanded = this.opened;
    }
    /**
     * Don't display header area if I don't have title and description.
     *
     * @return {?}
     */
    isHeaderDisplayed() {
        return (isPresent(this.title) || isPresent(this.description));
    }
    /**
     * Css Class that control the look and feel for section component.
     * @return {?}
     */
    aClass() {
        if (!this.isHeaderDisplayed()) {
            return 'section-no-header';
        }
        return '';
    }
    /**
     * Since we introduced buttons and editState the decision on when to exit editing mode
     * should be on the developer using this component therefore only startEditing
     *
     * @param {?} $event
     * @return {?}
     */
    onEditAction($event) {
        // when in editing make sure we dont switch state as there can be some Form errors
        // which needs to be handled by developer and only then change the editState
        if (!this.editState) {
            this.editState = !this.editState;
            let /** @type {?} */ state$$1 = (this.editState) ? 'inEdit' : 'notInEdit';
            this.onEdit.emit(state$$1);
            this.open();
        }
        // prevent the original event from bubbling up. Because the edit icon is inside
        // the header. If the click even is bubbled up, this event will cause the section to
        // expand or collapse.
        if (isPresent($event.event)) {
            $event.event.stopPropagation();
            $event.event.preventDefault();
        }
    }
    /**
     * @return {?}
     */
    hasDescription() {
        return isPresent(this.description);
    }
    /**
     * Open this section, if it's already open, will do nothing.
     * @param {?=} event
     * @return {?}
     */
    open(event) {
        if (!this.expanded) {
            this.accordionTab.toggle(event);
        }
    }
    /**
     * Close this section, if it's already close, will do nothing.
     * @param {?} event
     * @return {?}
     */
    close(event) {
        if (this.expanded) {
            this.accordionTab.toggle(event);
        }
    }
    /**
     * Callback to be invoked when accordion is opened
     *
     * @param {?} event
     * @return {?}
     */
    onSectionOpen(event) {
        this.expanded = true;
        this.onOpen.emit('open');
    }
    /**
     * Callback to be invoked when accordion is closed
     *
     * @param {?} event
     * @return {?}
     */
    onSectionClose(event) {
        this.expanded = false;
        this.onClose.emit('close');
    }
    /**
     *
     * Tells us if we need to render application defined custom actions
     *
     * @return {?}
     */
    hasCustomActions() {
        return isPresent(this.customActions);
    }
    /**
     * Emit the editing state back to non-editable
     * @return {?}
     */
    completeEditing() {
        this.editState = false;
        this.onEditingComplete.emit(this.editState);
    }
}
SectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-section',
                template: `<div class="ui-g-12 section-container"
     [class.editing]="editable && editState && editMode === 'default'">

    <p-accordion (onOpen)="onSectionOpen($event)" (onClose)="onSectionClose($event)"
                 [styleClass]="aClass()">
        <p-accordionTab #accordionTab [selected]="opened" [disabled]="disableClose">
            <p-header>
                <!-- title and description -->
                <div class="section-header-container">
                    <div class="section-title">{{title}}</div>
                    <div *ngIf="hasDescription()" class="section-description">{{description}}</div>

                    <!-- actions: Hide when in editing and editMode is default -->
                    <div *ngIf="(editable && !editState && editMode === 'default') ||
                        (editable && editMode === 'external')"
                         class="section-actions">
                        <aw-hyperlink (action)="onEditAction($event)">
                            <i class="sap-icon section-edit-action" [ngClass]="actionIcon"></i>
                        </aw-hyperlink>
                    </div>
                </div>
            </p-header>

            <ng-content></ng-content>
        </p-accordionTab>
    </p-accordion>
    <!--
        need to put it outside of p-accordion otherwise button will inherit different
        color scheme
    -->
    <div class="section-footer-container" *ngIf="editable && editState &&
            editMode === 'default'">
        <div class="footer-actions">

            <ng-template [ngIf]="!hasCustomActions()">
                <aw-button [style]="'secondary'" size="small"
                           (action)="onCancelAction.emit($event)">
                    Cancel
                </aw-button>
                <aw-button size="small" (action)="onSaveAction.emit($event)">
                    Save
                </aw-button>
            </ng-template>

            <ng-content select="aw-section-actions"></ng-content>
        </div>
    </div>
</div>
`,
                styles: [`.section-header-container{position:relative}.section-container{margin:10px 0;background-color:#fff;padding:.2em .5em;border:2px dashed transparent}.section-container.editing{border-color:#199de0}.section-container ::ng-deep .ui-accordion-header>a{display:flex}.section-container ::ng-deep .ui-accordion-header>a .ui-accordion-toggle-icon{flex:0 0 30px;padding-top:2px}.section-container ::ng-deep .ui-accordion-header>a p-header{flex:1 0}.section-container /deep/ .ui-accordion-header.ui-state-disabled{opacity:1}.section-title{font-size:1.1em}.section-description{font-size:.9em;padding:.6em 0 .2em}.section-footer-container{margin:1em 2em 0;padding:.8em 0 1.5em .8em;border-top:1px solid #d7d7d7}.section-footer-container .footer-actions{display:inline-block;text-align:right;width:100%}.section-actions{position:absolute;top:0;right:0;z-index:1}.section-actions /deep/ a.link,.section-actions /deep/ a.link:hover{padding:0;text-decoration:none}.section-edit-action{font-size:1.5em;position:relative;padding:.1em 0 .1em .5em;cursor:pointer}.section-edit-action.icon-edit{font-size:1.4em}.section-container /deep/ .ui-accordion-header{color:#363636;border:none;background:#fff!important;padding:0 1em}.section-container /deep/ .ui-accordion-content{border:none;padding:1em 2em}.section-container /deep/ .ui-accordion-header /deep/ a[role=tab]{padding:.75em 0;text-decoration:none}.section-container /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:1px solid #d7d7d7;color:#363636}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header{height:1px}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:none}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header .section-edit-action{cursor:pointer!important}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down,:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right{font-family:"SAP icon fonts";font-size:1.1em;top:.8em;left:.1em;color:#767676;margin-top:0}:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .fa,:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .pi{display:none}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right:before{content:"\\e1ed"}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down:before{content:"\\e1ef"}`]
            },] },
];
/** @nocollapse */
SectionComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment }
];
SectionComponent.propDecorators = {
    title: [{ type: Input }],
    description: [{ type: Input }],
    opened: [{ type: Input }],
    disableClose: [{ type: Input }],
    editState: [{ type: Input }],
    editMode: [{ type: Input }],
    actionIcon: [{ type: Input }],
    onOpen: [{ type: Output }],
    onClose: [{ type: Output }],
    onEdit: [{ type: Output }],
    onCancelAction: [{ type: Output }],
    onSaveAction: [{ type: Output }],
    onEditingComplete: [{ type: Output }],
    accordionTab: [{ type: ViewChild, args: ['accordionTab',] }],
    customActions: [{ type: ContentChild, args: [SectionActionsComponent,] }]
};
class SubSectionComponent {
}
SubSectionComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-subsection',
                template: `
                    <h4 class="subsection-title">{{title}}</h4>
                    <ng-content></ng-content>
                 `,
                styles: ['.subsection-title {color: #363636; }']
            },] },
];
SubSectionComponent.propDecorators = {
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWSectionModule {
}
AWSectionModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SectionComponent,
                    SubSectionComponent,
                    SectionActionsComponent
                ],
                imports: [
                    CommonModule,
                    AccordionModule,
                    AribaCoreModule,
                    AWStringFieldModule,
                    AWHyperlinkModule,
                    AWButtonModule,
                    SharedModule
                ],
                entryComponents: [
                    SectionComponent,
                    SubSectionComponent,
                    SectionActionsComponent
                ],
                exports: [
                    SectionComponent,
                    SectionActionsComponent,
                    SubSectionComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DTColumn represent single column including header and its body. Each column has its own
 * rendererTemplate which a entry to this component.
 *
 * Keeping this separate from the datatable where DT is not really aware what it is rendering,
 * it allows us more flexibility in terms of different type of column inheriting from this
 * one.. Such as:
 *  DTRowDetail  column
 *  DTSingleSelection column
 *  DTMultiSelection column
 *
 * This way we don't do IF/THEN/ELSE inside the datatable and trying to create different cases.
 *
 *  Then later on this will let us create additional logic for the pivotal layout. Because DT
 *  does know anything about the type of the column so whatever is added to the DT.columns it
 *  will be rendered.
 *
 *
 *  Columns can be also frozen meaning if the content overflows they dont scroll. To make the
 *  column frozen we need to use [frozen] binding and se it to TRUE plus it requires a [width]
 *  binding to be set (in px).
 *  We need this to be able to properly position the second table which is changed to absolute
 *  positioning.
 *
 *
 *
 */
class DTColumn2Component extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env);
        this.env = env;
        this.domHandler = domHandler;
        /**
         *
         * Cell alignment. It inserts regular align attribute to the table cell
         *
         */
        this.align = 'left';
        /**
         *
         * If false applies dt-is-hidden style that hides the column
         *
         */
        this.isVisible = true;
        /**
         * Sorting direction
         *
         */
        this.sortOrdering = 'descending';
        /**
         * Tells the template if whether to render a label
         *
         */
        this.showColumnLabel = true;
        /**
         *
         * See AWDataTable
         *
         */
        this.showSubHeader = false;
        /**
         *
         * Used together with cell selectionMode to tell which column is selectable
         *
         */
        this.selectable = false;
        /**
         * Use globally defined HEADER template for current column
         *
         */
        this.useGlobalHeader = true;
        /**
         * Use globally defined SubHeader template for current column
         *
         */
        this.useGlobalSubHeader = true;
        /**
         * Use globally defined body template
         *
         */
        this.useGlobalBody = true;
        /**
         * Tells if the column is data column  - if it is rendering data or just a label or some
         * control
         *
         * This is important when calculating a column span and we need to know which columns are or
         * will be just for selection controls and which holds data
         */
        this.isDataColumn = true;
        /**
         * Identifies column that will not scroll horizontally with other columns. Column is
         * frozen.
         *
         * For such columns that are marked as frozen binding [width] is required.
         *
         */
        this.frozen = false;
        this.maxWidthPx = 0;
        this.minWidthPx = 0;
        this.widthPx = 0;
        this.widestCell = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isBlank(this.key) && isBlank(this.label)) {
            throw new Error('Missing required binding: ' +
                '[key] or [label] bindings must be used at minimum');
        }
        // To be able to position second DT we require [width] to be set as well
        if (this.frozen && isBlank(this.width)) {
            throw new Error('Missing required binding [width]: ' +
                'when [frozen]=true then [width] binding needs to be specified.');
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // need to deffer this and trigger change detection otherwise I get
        // value was changed after it was checked error
        // setTimeout(() =>
        // {
        // });
    }
    /**
     *
     * When cell selectionMode is enabled this method is triggered when we click on header.
     * It delegates the call to the DT where it toggles currently selected value
     *
     * @param {?} event
     * @param {?} element
     * @return {?}
     */
    handleHeaderClick(event, element) {
        if (this.isHeaderSelectable()) {
            this.dt.onHeaderSelectionChange(element, this);
        }
        else if (this.sortable) {
            this.sort(event);
        }
        event.preventDefault();
    }
    /**
     *
     * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
     *
     * @param {?} event
     * @return {?}
     */
    sort(event) {
        if (!this.sortable) {
            return;
        }
        let /** @type {?} */ targetNode = event.target;
        if (this.domHandler.hasClass(targetNode, 'dt-u-sortable') ||
            this.domHandler.hasClass(targetNode, 'dt-col-title') ||
            this.domHandler.hasClass(targetNode, 'dt-col-sortable-icon')) {
            if (isPresent(this.dt.sortColumn) && this.dt.sortColumn.key === this.key) {
                this.sortOrder = this.sortOrder * -1;
                this.sortOrdering = this.dt.sortOrderingForNumber(this.sortOrder);
            }
            else {
                this.dt.sortColumn = this;
            }
            this.dt.dataSource.state.sortKey = this.key;
            this.dt.dataSource.state.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
            this.dt.sortSingle();
        }
        this.dt.updateDataToRender();
    }
    /**
     * Calculated style class based on data
     *
     *
     * @param {?} item
     * @return {?}
     */
    dynamicBodyClass(item) {
        let /** @type {?} */ dynClass = isPresent(this.bodyClassFn)
            ? this.bodyClassFn.apply(this.dt.context, [this, item]) : '';
        if (isPresent(this.bodyStyleClass)) {
            dynClass += ' ' + this.bodyStyleClass;
        }
        else if (isPresent(this.styleClass)) {
            dynClass += ' ' + this.styleClass;
        }
        return dynClass;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isRowSelectable(item) {
        if (isPresent(this.dt.isRowSelectable)) {
            return this.dt.isRowSelectable(item);
        }
        return false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isCellSelectable(item) {
        return this.dt.selectionMode === 'cell' && this.isRowSelectable(item) && this.selectable;
    }
    /**
     * @return {?}
     */
    isHeaderSelectable() {
        return this.dt.selectionMode === 'cell' && this.selectable;
    }
    /**
     * @return {?}
     */
    getSortOrder() {
        let /** @type {?} */ order = 0;
        if (isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key) {
            order = this.dt.sortColumn.sortOrder;
        }
        return order;
    }
    /**
     * @return {?}
     */
    isSorted() {
        if (!this.sortable) {
            return false;
        }
        return isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key;
    }
    /**
     * @param {?} table
     * @return {?}
     */
    initialize(table) {
        this.dt = table;
        if (isPresent(this.dt.initialSortKey) && this.dt.initialSortKey === this.key) {
            this.sortable = true;
            this.sortOrder = this.dt.sortOrderingForString(this.dt.initialSortOrder);
            this.dt.sortColumn = this;
        }
        if (isBlank(this.bodyTemplate) && this.useGlobalBody) {
            this.bodyTemplate = this.dt.bodyTemplate;
        }
        if (isBlank(this.headerTemplate) && this.useGlobalHeader) {
            this.headerTemplate = this.dt.headerTemplate;
        }
        if (isBlank(this.subHeaderTemplate) && this.useGlobalSubHeader) {
            this.subHeaderTemplate = this.dt.subHeaderTemplate;
        }
        if (isBlank(this.bodyClassFn)) {
            this.bodyClassFn = this.dt.bodyClassFn;
        }
        this.maxWidthPx = this.widthToPx(this.maxWidth);
        this.minWidthPx = this.widthToPx(this.minWidth);
        this.widthPx = this.widthToPx(this.width);
    }
    /**
     * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
     *
     * In case we use MaxWidth directive we set new width once for all columsn
     * @param {?} myIndex
     * @return {?}
     */
    postInitialize(myIndex) {
        const /** @type {?} */ colIndex = myIndex + 1;
        let /** @type {?} */ table;
        if (this.dt.hasFrozenColumns()) {
            table = (/** @type {?} */ (this.dt)).el
                .nativeElement.querySelector('.dt-body-frozen table');
        }
        else {
            table = (/** @type {?} */ (this.dt)).el.nativeElement.querySelector('table');
        }
        if (this.widestCell > 0) {
            let /** @type {?} */ all = table.querySelectorAll('tr th:nth-child(' + colIndex + '), ' +
                'tr td:nth-child(' + colIndex + ')').forEach((node) => {
                node.style.width = this.widestCell + 'px';
            });
        }
    }
    /**
     * You either use this binding directly and say its datacolumn or when there is a [key]
     * biding we know it refers to some field.
     *
     * @return {?}
     */
    isValueColumn() {
        return (isPresent(this.isDataColumn) && BooleanWrapper.isTrue(this.isDataColumn)) ||
            isPresent(this.key);
    }
    /**
     * When we are in outline mode  we need to also indend each selection control accordingly.
     *
     * indent - 1 > only offset with
     * indent
     * @param {?} cell
     * @param {?} level
     * @return {?}
     */
    indentForControl(cell, level) {
        if (this.dt.isOutline() && level > 0 && cell.offsetWidth > 0
            && isPresent(cell.nextElementSibling)) {
            let /** @type {?} */ outlineNodePadding = parseInt(getComputedStyle(cell.nextElementSibling).paddingLeft) || 0;
            // 1st level is pushed as root
            if (this.dt.pushRootSectionOnNewLine) {
                return (level === 1) ? null : (this.dt.indentationPerLevel * level)
                    - outlineNodePadding;
            }
            else {
                return (this.dt.indentationPerLevel * level) + outlineNodePadding;
            }
        }
        return null;
    }
    /**
     *
     * Internal
     * @param {?} width
     * @return {?}
     */
    widthToPx(width) {
        let /** @type {?} */ px;
        if (isPresent(width)) {
            if (width.indexOf('%') > 0) {
                const /** @type {?} */ nonPc = parseFloat(width) / 100;
                px = nonPc * (/** @type {?} */ (this.dt)).el.nativeElement.offsetWidth;
            }
            else {
                px = parseFloat(width);
            }
        }
        return px;
    }
}
DTColumn2Component.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-column2',
                template: `<!--
    To make it more readable Each Column type has its own rendering template instead of putting
    all this into datatable as this is more responsibility of the column. And the main goal
    was try to be modular as possible. When There will be different types of columns

    - Regular DTColumn (current implementation),
    - SelectionColumn (Single/Multi select) - todo,
    - DetailRow column, then pivotal collumn to render row/column/detail attributes - todo.

    When implementing new column type you just inherit this DTColumnComponent and provide your
    own rendering template and DT take care of the rest.

    todo: We have SingleSelect, Multiselect rendering template that is Added programatically
    todo: We have pivotal rendering template


-->
<ng-template #renderingTemplate let-isHeader let-isSubHeader="isSubHeader" let-column="column"
             let-dataToRender="data"
             let-columnIndex="columnIndex"
             let-rowIndex="rowIndex">

    <ng-template *ngIf="isHeader" [ngTemplateOutlet]="colHeader"
                 [ngTemplateOutletContext]="{$implicit: isSubHeader, columnIndex:columnIndex, data: dataToRender,
                 rowIndex:rowIndex}">
    </ng-template>

    <ng-template *ngIf="!isHeader" [ngTemplateOutlet]="colBody"
                 [ngTemplateOutletContext]="{$implicit: column, data:dataToRender,rowIndex:rowIndex}">
    </ng-template>
</ng-template>


<!--
    Templates for header columns. Here we are rendering two types. Header and Subheader that we
    usually use here as some kind of summary columns. Not really having summary at the bottom like other
    DT.

    TH column and their text are usually unselectable and most of these were inherited from
    original PrimeNg DT even not many things got left after we refactor this but the idea is the
    same.

    Each cell has its dt-cell-def class that sets default styling like font, background, alignment
    padding, etcs..


-->
<ng-template #colHeader let-isSubHeader let-columnIndex="columnIndex" let-data="data" let-rowIndex="rowIndex">

    <th #headerCell1 [class]="headerStyleClass||styleClass" *ngIf="!isSubHeader"
        (click)="handleHeaderClick($event, headerCell1)"
        [ngClass]="{'dt-is-default dt-u-unselectable-text' :true,
                    'dt-cell-def': dt.selectionMode !== 'cell' || (!dt.isOutline() || !dt.pivotalLayout),
                    'dt-u-sortable': sortable,
                    'dt-is-active': isSorted(),
                    'dt-is-hidden': !isVisible}"
        [attr.width]="width"
        [attr.align]="align"
        [attr.tabindex]="sortable ? 1 : null"
        [dtMaxWidth]="maxWidthPx"
    >

        <ng-template [ngIf]="dt.headerFilterTemplate && columnIndex === 0 ">
            <ng-container *ngTemplateOutlet="dt.headerFilterTemplate">
            </ng-container>
        </ng-template>
        <!--
            when cell are selectable we need two version where one wrap the cell content in div
        -->
        <ng-template [ngIf]="isHeaderSelectable()">
            <ng-container *ngTemplateOutlet="selectableHeaderCell; context: {$implicit: this}">
            </ng-container>
        </ng-template>


        <ng-template [ngIf]="!isHeaderSelectable()">
            <ng-container *ngTemplateOutlet="nonSelectableHeaderCell; context: {$implicit: this}">
            </ng-container>
        </ng-template>
    </th>

    <th #headerCell2 [class]="headerStyleClass||styleClass" *ngIf="isSubHeader"
        [attr.width]="width"
        [attr.align]="align"
        [ngClass]="{'dt-is-default dt-cell-def dt-sub-header dt-u-unselectable-text':true}"
        [dtMaxWidth]="maxWidthPx">

        <span class="dt-col-title" *ngIf="dt.showSubHeader && subHeaderTemplate">
            <ng-container *ngTemplateOutlet="subHeaderTemplate;
                    context: {$implicit: this, rowData: data, rowIndex: rowIndex}">
            </ng-container>
        </span>
    </th>
</ng-template>


<!--
    Template for the body = the TD. For the body and we might want to do the same for header we
    allow to have calculated body class that comes from the application. So based on the data types
    you might want to apply different class in order to apply custom styling.
-->
<ng-template #colBody let-data="data" let-rowIndex="rowIndex">

    <td #cell [class]="dynamicBodyClass(data)"
        (click)="dt.onCellSelectionChange(cell, this, data)"
        [attr.width]="width"
        [attr.align]="align"
        [ngClass]="{ 'dt-is-default': true,
        'dt-cell-def': !isCellSelectable(data),
        'dt-is-hidden': !isVisible}"
        [dtMaxWidth]="maxWidthPx"
        >

        <!--
            Since we need to support cell selection when we need to draw border around it
            We are wrapping such sells with div which gives us better flexibility
        -->
        <ng-template [ngIf]="isCellSelectable(data)">
            <ng-container *ngTemplateOutlet="selectableBodyCell;
                        context: {$implicit: this, data: data, rowIndex: rowIndex }">
            </ng-container>

        </ng-template>


        <ng-template [ngIf]="!isCellSelectable(data)">
            <ng-container *ngTemplateOutlet="nonSelectableBodyCell;
                        context: {$implicit: this, data: data, rowIndex: rowIndex}">
            </ng-container>
        </ng-template>

    </td>
</ng-template>

<!--
    Todo: create better solution instead of using different template create directive that wraps
    it with the div conditionally
-->
<ng-template #selectableHeaderCell let-data="data" let-rowIndex="rowIndex">

    <div class="dt-cell-def-selectable"
         [ngClass]="{'dt-cell-selected': dt.isHeaderSelected(this)}">
        <ng-container *ngTemplateOutlet="headerCellContent;
                        context: {$implicit: this, data: data, rowIndex: rowIndex}">
        </ng-container>
    </div>
</ng-template>


<ng-template #nonSelectableHeaderCell let-data="data" let-rowIndex="rowIndex">
    <ng-container *ngTemplateOutlet="headerCellContent;
                        context: {$implicit: this, data: data, rowIndex: rowIndex}">
    </ng-container>
</ng-template>


<ng-template #headerCellContent let-data="data" let-rowIndex="rowIndex">
    <span class="dt-col-title" *ngIf="showColumnLabel && !headerTemplate">
                {{label}}
    </span>

    <span class="dt-col-title" *ngIf="showColumnLabel && headerTemplate">
                    <ng-container *ngTemplateOutlet="headerTemplate;
                        context: {$implicit: this, rowData: data, rowIndex: rowIndex }">
                    </ng-container>
    </span>

    <span class="dt-col-sortable-icon sap-icon icon-sort" *ngIf="sortable"
          [ngClass]="{'icon-sort-descending': (getSortOrder() == -1),
                           'icon-sort-ascending': (getSortOrder() == 1)}">
    </span>
</ng-template>


<ng-template #selectableBodyCell let-data="data" let-rowIndex="rowIndex">
    <div class="dt-cell-def-selectable"
         [ngClass]="{'dt-cell-selected': dt.isBodyCellSelected(this, data)}">
        <ng-container *ngTemplateOutlet="bodyCellContent;
                        context: {$implicit: this, data: data, rowIndex: rowIndex}">
        </ng-container>
    </div>
</ng-template>


<ng-template #nonSelectableBodyCell let-data="data" let-rowIndex="rowIndex">
    <ng-container *ngTemplateOutlet="bodyCellContent;
                        context: {$implicit: this, data: data, rowIndex: rowIndex}">
    </ng-container>
</ng-template>


<ng-template #bodyCellContent let-data="data" let-rowIndex="rowIndex">
    <!--
           when no template is used use our FieldPath to access the object value based on the
           key binding
        -->
    <span class="dt-col-cell-data" *ngIf="!bodyTemplate">
            {{dt.getValue(data, key)}}
        </span>


    <!--
        In case application wants to provide their own cell component they use
        #body ng-template to do so.
    -->
    <span class="dt-col-cell-data" *ngIf="bodyTemplate">
            <ng-container *ngTemplateOutlet="bodyTemplate;
            context: {$implicit: this, rowData: data, rowIndex: rowIndex}"></ng-container>
        </span>
</ng-template>
`,
                styles: [`.dt-sortable-col{cursor:pointer}.dt-col-sortable-icon{display:inline-block;margin-left:.125em}th.dt-cell-def{font-weight:400;color:#4a4a4a}th.dt-is-default{background-color:#f2f2f2;white-space:nowrap}th.dt-is-default.dt-cell-def:not(.dt-sub-header){border-bottom-color:#f2f2f2}th.dt-sub-header{background-color:#fff}th .dt-cell-selected{border-color:#58b957}td .dt-cell-selected{border-left-color:#4f9fcf}.dt-root-section .dt-selection-column,.dt-selection-column{width:46px;padding:0 12px}.dt-pivot-layout td.dt-selection-column,th.dt-selection-column{border-right-color:transparent}thead tr:first-child th{border-top-color:transparent}tbody tr:last-child:not(.dt-drag-row-bottom) td{border-bottom-color:transparent}td:first-child,th:first-child{border-left-color:transparent}td:last-child,th:last-child{border-right-color:transparent}tbody .dt-drag-row-top>td{background:linear-gradient(0deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-bottom>td{background:linear-gradient(180deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-both>td{background:linear-gradient(0deg,#0271d2 0,#fff 3%,#fff 97%,#0271d2 100%)}tbody .dt-row-dragging>td{background-color:#ececec;color:#b9b9b9}tbody .dt-row-dragging .ui-state-active{opacity:.5;cursor:not-allowed}`],
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler]
            },] },
];
/** @nocollapse */
DTColumn2Component.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];
DTColumn2Component.propDecorators = {
    label: [{ type: Input }],
    key: [{ type: Input }],
    align: [{ type: Input }],
    bodyClassFn: [{ type: Input }],
    isVisible: [{ type: Input }],
    sortable: [{ type: Input }],
    sortOrdering: [{ type: Input }],
    showColumnLabel: [{ type: Input }],
    showSubHeader: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    bodyStyleClass: [{ type: Input }],
    selectable: [{ type: Input }],
    useGlobalHeader: [{ type: Input }],
    useGlobalSubHeader: [{ type: Input }],
    useGlobalBody: [{ type: Input }],
    isDataColumn: [{ type: Input }],
    frozen: [{ type: Input }],
    maxWidth: [{ type: Input }],
    minWidth: [{ type: Input }],
    rendererTemplate: [{ type: ViewChild, args: ['renderingTemplate',] }],
    headerTemplate: [{ type: ContentChild, args: ['header',] }],
    subHeaderTemplate: [{ type: ContentChild, args: ['subHeader',] }],
    bodyTemplate: [{ type: ContentChild, args: ['body',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An datatable header area.
 *
 * See {\@link DataTableComponent} for more explanation.
 */
class DTHeaderComponent2 {
}
DTHeaderComponent2.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-header2',
                template: '<ng-content></ng-content>'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Custom column implementation to render detail row spaning its column across whole table width.
 *
 *
 */
class DTDetailRowComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        /**
         *
         * tells if we need to render a line between item row and its detail
         *
         */
        this.showRowLine = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // just to get around the check in parent class
        this.key = '';
        super.ngOnInit();
    }
    /**
     * Check if we need to keep some leading TDs
     *
     * @return {?}
     */
    visibleLeadingCols() {
        return this.dt.numberOfColsBeforeData - (this.dt.hasInvisibleSelectionColumn() ? 1 : 0);
    }
    /**
     *
     * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
     * Here can hook on application level custom method to decide if current item has detail row
     * or not
     *
     * Or we can use isVisible=true to tell all row have detail row
     *
     * @param {?} item
     * @return {?}
     */
    showDetailRow(item) {
        let /** @type {?} */ isVisible = this.isVisible;
        if (isPresent(this.isVisibleFn)) {
            isVisible = this.isVisibleFn.apply(this.dt.context, [this, item]);
        }
        return isVisible;
    }
    /**
     * @param {?} table
     * @return {?}
     */
    initialize(table) {
        super.initialize(table);
        this.isVisible = !this.dt.isOutline() || !this.dt.pivotalLayout;
    }
}
DTDetailRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-detail-column',
                template: `<!--
    Renders application defined detail column. This template just renders a detail row and
    not expansion control. This is implemented by different DtColumn implementation and its added
    (will be) added programmatically during column initialization
-->
<ng-template #renderingTemplate let-column="column" let-rowData="data">

    <tr #detailRowElement class="dt-body-row dt-detail-row">

        <td *ngIf="dt.hasInvisibleSelectionColumn()" width="1px"></td>
        <td *ngIf="visibleLeadingCols() > 0" colspan="visibleLeadingCols()" width="1px">
            &nbsp;&nbsp;
        </td>
        <td [attr.colspan]="dt.startOfFirstDataColumn" [class]="dynamicBodyClass(rowData)"
            [ngClass]="{ 'dt-is-default dt-cell-def': true}">

            <ng-container
                *ngTemplateOutlet="bodyTemplate; context:{$implicit: this, rowData:rowData}">
            </ng-container>
        </td>
    </tr>
</ng-template>

`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler]
            },] },
];
/** @nocollapse */
DTDetailRowComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];
DTDetailRowComponent.propDecorators = {
    isVisibleFn: [{ type: Input }],
    showRowLine: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 *
 *
 *
 */
class DTDetailRowExpanderComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        // we dont want to show the row/column unless application says so
        this.isVisible = false;
        // default width of the selection control
        this.width = '45px';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // just to get around the check in parent class
        this.key = '';
        super.ngOnInit();
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    toggleExpansion(event, item) {
        this.dt.detailRowExpansionState.toggle(item);
        event.stopPropagation();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    calculateStyleClass(item) {
        return this.dt.detailRowExpansionState.isExpanded(item) ?
            'icon-slim-arrow-down' : 'icon-slim-arrow-right';
    }
}
DTDetailRowExpanderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-detail-column-expand',
                template: `<!--
   Special column that renders expand/collapse control for detail row when detail row is enabled.

   Just like for the other column it renders header section as well as body section with
   expand control to toggle the expansion

-->
<ng-template #renderingTemplate let-isHeader let-isSubHeader="isSubHeader" let-column="column"
             let-dataToRender="data" let-columnIndex="columnIndex" let-rowIndex="rowIndex">


    <ng-template [ngIf]="isHeader && !isSubHeader">
        <th #headerCell1 [class]="headerStyleClass||styleClass"
            class="dt-row-cell-expando"
            [ngClass]="{'dt-is-default dt-u-unselectable-text dt-cell-def' :true,
                        'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender)}">
        </th>

    </ng-template>

    <ng-template [ngIf]="!isHeader && !isSubHeader">
        <td #cell
            class="dt-row-cell-expando"
            [ngClass]="{ 'dt-is-default': true,
                    'dt-cell-def': !isCellSelectable(dataToRender),
                    'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender),
                    'dt-det-row-with-ln' : dt.rowDetailColumn.showRowLine}">

            <span (click)="toggleExpansion($event, dataToRender)"
                  class="dt-det-row-expand sap-icon"
                  [ngClass]="calculateStyleClass(dataToRender)">

            </span>

        </td>

    </ng-template>


</ng-template>

`,
                styles: [`.dt-row-cell-expando{width:14px;text-align:right;padding:17px 5px 17px 17px;border-right-color:transparent}.dt-row-cell-expando .dt-det-row-expand{cursor:pointer;line-height:21px}td.dt-det-row-expanded:not(.dt-det-row-with-ln),td.dt-det-row-expanded:not(.dt-det-row-with-ln)~td{border-bottom-color:transparent}`],
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler]
            },] },
];
/** @nocollapse */
DTDetailRowExpanderComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * @license
 * Copyright 2017 SAP Ariba
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 *
 */
const /** @type {?} */ DragEvents = ['mousedown', 'dragstart', 'dragover', 'dragenter', 'dragleave',
    'drop', 'dragend'];
/** @enum {string} */
const DragDirection = {
    None: 'none',
    Up: 'dt-drag-row-top',
    Down: 'dt-drag-row-bottom',
    Middle: 'dt-drag-row-both',
};
/** @enum {string} */
const DropPosition = {
    Before: 'before',
    After: 'after',
    Into: 'into',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Concrete DataSource implementation for Datatable which defines state and column definition that
 * can programmatically modify rendered columns (if provided) and method for inserting and
 * and deleting records;
 *
 * All operations dealing with data use Observable<T> and instant() method to retrieve current
 * state is not implemented.
 *
 *
 */
class DT2DataSource extends DataSource {
    /**
     * @param {?=} dataProviders
     * @param {?=} finders
     */
    constructor(dataProviders, finders) {
        super(dataProviders, finders);
        this.dataProviders = dataProviders;
        this.finders = finders;
        this.initialized = false;
        this.state = Datatable2State.create();
        this.debugTime = new Date().getTime();
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    init(...args) {
        if (isBlank(args) || args.length !== 1 && !isDTInitParams(args[0])) {
            throw new Error('You need to initialize DS with (DSChooserInitParams)');
        }
        let /** @type {?} */ init = args[0];
        // use existing or find best match for dataProvider
        this.dataProvider = isPresent(init.dataProvider) ? init.dataProvider
            : this.dataProviders.find(init.obj);
        // use existing or find best match for dataFinder
        this.dataFinder = isPresent(init.dataFinder) ? init.dataFinder
            : this.finders.find(this.dataProvider, init.queryType);
        assert(isPresent(this.dataProvider) && isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
        this.dataFinder.lookupKey = init.lookupKey;
        if (isBlank(init.state)) {
            this.state = new Datatable2State();
        }
        else {
            this.state = init.state;
        }
        this.initialized = true;
    }
    /**
     * Triggers async fetch data request and result is given back using dataProvider.dataChanges
     *
     * @param {?=} withParams
     * @return {?}
     */
    fetch(withParams) {
        let /** @type {?} */ params = null;
        if (isPresent(withParams)) {
            params = new Map().set('offset', withParams.offset)
                .set('limit', withParams.limit)
                .set('orderby', withParams.sortKey)
                .set('selector', withParams.sortOrder);
        }
        this.dataProvider.fetch(params).subscribe((result) => {
            if (withParams.offset > 0) {
                let /** @type {?} */ incrData = [...this.dataProvider.dataChanges.getValue(), ...result];
                this.dataProvider.dataChanges.next(incrData);
            }
            else {
                this.dataProvider.dataChanges.next(result);
            }
        });
    }
    /**
     * Component uses this method to open up continuous stream to listen for any changes which
     * need to be reflected on the UI.
     *
     * Dont forget to unsubscribe when component is destroyed.
     * @template T
     * @return {?}
     */
    open() {
        return this.dataProvider.dataChanges.asObservable();
    }
    /**
     * @return {?}
     */
    close() {
        this.dataProvider = null;
        this.dataFinder = null;
    }
    /**
     * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
     * dataProvider.dataChanges that are new data. If not enabled we have default implementation
     * which works with local array
     *
     * @param {?} object
     * @return {?}
     */
    insert(object) {
        if (this.dataProvider.canCRUD()) {
            this.dataProvider.insert(object);
        }
        else {
            this.dataProvider.offScreenData.push(object);
            this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
        }
    }
    /**
     * Please see {\@link insert} method
     *
     * @param {?} object
     * @return {?}
     */
    remove(object) {
        if (this.dataProvider.canCRUD()) {
            this.dataProvider.remove(object);
        }
        else {
            ListWrapper.removeIfExist(this.dataProvider.offScreenData, object);
            this.dataProvider.dataChanges.next(this.dataProvider.offScreenData);
        }
    }
    /**
     *
     * Provides access to DataFinder which can accept either plain string or Map.
     *
     * To be able to provide correct input we need to ask DataFinder if it supports FullText like
     * type query or Predicate. In case of Predicate we build the Map with different key/value
     * pairs
     *
     *
     * @param {?=} pattern
     * @return {?}
     */
    find(pattern) {
        if (isBlank(pattern) || pattern.length === 0) {
            // if we received empty string return orginal list
            this.fetch(this.state);
            return;
        }
        let /** @type {?} */ searchParam = pattern;
        if (this.dataFinder.accepts(this.dataProvider, QueryType.Predicate)) {
            searchParam = new Map().set('query', pattern).set('limit', DT2DataSource.MaxLimit);
            if (isPresent(this.state.sortKey)) {
                searchParam.set('orderby', this.state.sortKey);
            }
            if (isPresent(this.state.sortKey)) {
                searchParam.set('selector', this.state.sortOrder);
            }
        }
        else {
            assert(isString(pattern), 'Cannot pass non-string value to FullText Finder');
        }
        this.dataFinder.match(searchParam).subscribe((result) => {
            this.dataProvider.dataChanges.next(result);
        });
    }
    /**
     *
     * Data source delegates the responsibility to the given data provider which needs to implement
     * specific sorting mechanism
     *
     * Todo: Extend to sort by multiple columns
     *
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    sort(key, sortOrder) {
        if (isBlank(this.dataProvider.data()) || this.dataProvider.data().length === 0) {
            return;
        }
        this.state.sortKey = key;
        this.state.sortOrder = sortOrder;
        this.fetch(this.state);
    }
    /**
     *
     * Persist db state
     *
     * @param {?} offset
     * @param {?} sortField
     * @param {?} sOrder
     * @return {?}
     */
    updateState(offset, sortField, sOrder) {
        this.state.offset = offset;
        this.state.sortKey = sortField;
        this.state.sortOrder = sOrder;
    }
    /**
     *
     * reshuffles current array based on new row D&D result.
     *
     * Since there is a difference if we move item from bottom or from the top and then accordingly
     * highlighting a space between rows. We need to reflect this in here as well.
     *
     * UseCase 1:
     *
     * 1. You can grab item with index 0 and move it down so that you can see a dropping line
     * between row with index 2 - 3
     *
     * 2. In this case splice() starts from position 2 and insert all elements after 2
     *      splice(start: number, deleteCount: number, ...items: T[]): T[];
     *
     * 3. no need to update newPos
     *
     * UseCase 2:
     *
     * 1. You can grab item with index 0 and move all the way down of the DT and now move the
     * row toward TOP and space between rows with index 2 - 3 is highlighted again.
     *
     * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
     * it seems the same but its highlighted row #3 with line at the TOP.
     *
     * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
     * where where the line between rows is created.
     *
     *
     * We don't need any complicated calculation trying to find out if we are on one half of the row
     * or second half and based on this try to apply certain style. This would not give so much
     * space if we want drop row into the row. And the calculation with coordinates woudl be too
     * complicated.
     *
     * We simply remember the direction we are moving and based on this we apply style to
     * to create a line at the TOP if we are going upwards or bottom otherwise.
     *
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    reorderRows(origPos, newPos, dropPos) {
        let /** @type {?} */ array = this.dataProvider.data().slice();
        // take something from top and drag&drop under
        if (newPos > origPos && dropPos === DropPosition.Before && newPos < array.length) {
            newPos -= 1;
            // take something from bottom and drag&drop above
        }
        else if (newPos < origPos && dropPos === DropPosition.After && newPos >= 0) {
            newPos += 1;
        }
        array.splice(newPos, 0, ...array.splice(origPos, 1)[0]);
        this.dataProvider.dataChanges.next(array);
    }
}
DT2DataSource.MaxLimit = 100;
/**
 * Keeps current datatable state the state which drivers the way while fetching the data as well
 * encapsulate set of properties that needs to be persistet in order to recover a state after e.g.
 * browser refresh
 *
 *
 * todo: Create methods to convert this state from and to JSON for easier serialization
 */
class Datatable2State {
    constructor() {
        /**
         * Properties for paging and fetching
         */
        this.offset = 0;
        this.limit = 0;
        /**
         * Identifies default value that is used to render N number of rows in non-fullscreen
         * mode
         *
         */
        this.displayLimit = 0;
        /**
         * Sorting order of the sort field. DataTable support sorting for multiple column but we
         * dont persist it now. Maybe in the future
         */
        this.sortOrder = Datatable2State.Ascending;
        /**
         * If we are using global filter for current datatable then save it here
         */
        this.currentSearchQuery = '';
        this.outlineState = new Map();
        this.detailRowExpandState = new Map();
    }
    /**
     * @param {?=} offset
     * @param {?=} limit
     * @param {?=} displayLimit
     * @param {?=} sortField
     * @param {?=} sOrder
     * @param {?=} searchQuery
     * @param {?=} filter
     * @param {?=} outlineState
     * @param {?=} detailRowState
     * @return {?}
     */
    static create(offset = 0, limit = 15, displayLimit = 5, sortField = '', sOrder = 0, searchQuery, filter, outlineState = new Map(), detailRowState = new Map()) {
        let /** @type {?} */ s = new Datatable2State();
        s.offset = offset;
        s.limit = limit;
        s.displayLimit = displayLimit;
        s.sortKey = sortField;
        s.sortOrder = sOrder;
        s.currentSearchQuery = searchQuery;
        s.currentFilter = filter;
        s.outlineState = outlineState;
        s.detailRowExpandState = detailRowState;
        return s;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static fromJSON(data) {
        let /** @type {?} */ state$$1 = JSON.parse(data);
        let /** @type {?} */ ds = new Datatable2State();
        ds.offset = state$$1.offset;
        ds.limit = state$$1.limit;
        ds.displayLimit = state$$1.displayLimit;
        ds.sortKey = state$$1.sortKey;
        ds.sortOrder = state$$1.sortOrder;
        ds.currentSearchQuery = state$$1.currentSearchQuery;
        ds.outlineState = MapWrapper.createFromAnyMap(state$$1.outlineState);
        ds.detailRowExpandState = MapWrapper.createFromAnyMap(state$$1.detailRowExpandState);
        return ds;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    static toJSON(data) {
        let /** @type {?} */ toConvert = {
            offset: data.offset,
            limit: data.limit,
            displayLimit: data.displayLimit,
            sortKey: data.sortKey,
            sortOrder: data.sortOrder,
            currentSearchQuery: data.currentSearchQuery,
            outlineState: MapWrapper.toAnyMap(data.outlineState),
            detailRowExpandState: MapWrapper.toAnyMap(data.detailRowExpandState)
        };
        return JSON.stringify(toConvert);
    }
}
Datatable2State.Ascending = 1;
Datatable2State.Descending = -1;
/**
 * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
 * simple we have a map holding item reference as a key and boolean value indicating if the
 * detail row is visible
 *
 * Todo: move this out to DS
 */
class DetailRowExpansionState {
    /**
     * @param {?} dt
     */
    constructor(dt) {
        this.dt = dt;
    }
    /**
     * @return {?}
     */
    get detailExpansionEnabled() {
        return isPresent(this.expansionStates);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set detailExpansionEnabled(value) {
        if (value) {
            this.expansionStates = new Map();
        }
        else {
            this.expansionStates = null;
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    toggle(item) {
        let /** @type {?} */ key = this.itemToKey(item);
        if (!this.isExpanded(item)) {
            this.expansionStates.set(key, true);
        }
        else {
            this.expansionStates.delete(key);
        }
        this.dt.dataSource.state.detailRowExpandState = this.expansionStates;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    isExpanded(item) {
        let /** @type {?} */ key = this.itemToKey(item);
        // handle special case where we collapse parent of parent while detail row is expanded
        if (this.dt.isOutline() && !this.dt.outlineState.isExpanded(key)) {
            this.expansionStates.delete(key);
            return false;
        }
        let /** @type {?} */ isOutlineExpanded = this.dt.isOutline() ? this.dt.outlineState.isExpanded(key) : true;
        return isPresent(key) && this.expansionStates.has(key);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    itemToKey(item) {
        return isEntity(item) ? (/** @type {?} */ (item)).identity() : item;
    }
}
/**
 * @param {?} init
 * @return {?}
 */
function isDTInitParams(init) {
    return isPresent(init.obj) || isPresent(init.queryType) || isPresent(init.entity);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Column implementation for the Multiselection where we show checkbox control
 *
 *
 */
class DTMultiSelectColumnComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        // default width of the selection control
        this.width = '45px';
    }
}
DTMultiSelectColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-multi-select-column',
                template: `<!--
    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is
    enabled as well as each checkbox per row
-->
<ng-template #renderingTemplate let-isHeader let-isSubHeader="isSubHeader" let-column="column"
             let-dataToRender="data"
             let-level="nestingLevel"
             let-columnIndex="columnIndex"
             let-rowIndex="rowIndex">

    <ng-template *ngIf="isHeader" [ngTemplateOutlet]="colHeader"
                 [ngTemplateOutletContext]="{$implicit: isSubHeader, columnIndex:columnIndex,
                 level:level}">
    </ng-template>

    <ng-template *ngIf="!isHeader" [ngTemplateOutlet]="colBody"
                 [ngTemplateOutletContext]="{$implicit: column, level:level,
                    data:dataToRender,rowIndex:rowIndex}">
    </ng-template>
</ng-template>


<ng-template #colHeader let-isSubHeader let-columnIndex="columnIndex">
    <th [ngClass]="{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,
                    'dt-cell-def': true,
                    'dt-sub-header': isSubHeader,
                    'dt-is-hidden': !dt.showSelectionColumn}" align="center">

        <ng-template [ngIf]="dt.showSelectAll">
            <aw-checkbox [type]="'action'" (action)="dt.toggleAllColumns($event)"
                         [value]="dt.isToggleAllColumnSelected()"
                         [disabled]="dt.isToggleAllColumnDisabled()">
            </aw-checkbox>
        </ng-template>

        <ng-template [ngIf]="!dt.showSelectAll">&nbsp;
        </ng-template>
    </th>

</ng-template>


<ng-template #colBody let-data="data" let-rowIndex="rowIndex" , let-level="level">

    <td #cell [class]="dynamicBodyClass(data)"
        [style.padding-left.px]="indentForControl(cell, level)"
        align="center"
        [ngClass]="{ 'dt-is-default dt-selection-column': true,
        'dt-cell-def': true,
        'dt-is-hidden': !dt.showSelectionColumn}">

        <aw-checkbox [type]="'action'" [value]="dt.isRowSelected(data)">
        </aw-checkbox>

    </td>
</ng-template>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler]
            },] },
];
/** @nocollapse */
DTMultiSelectColumnComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Column implementation for the SingleSelect where we show checkbox control
 *
 *
 */
class DTSingleSelectColumnComponent extends DTColumn2Component {
    /**
     * @param {?} env
     * @param {?} domHandler
     */
    constructor(env, domHandler) {
        super(env, domHandler);
        this.env = env;
        this.domHandler = domHandler;
        // default width of the selection control
        this.width = '45px';
    }
}
DTSingleSelectColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-single-select-column',
                template: `<!--
    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is
    enabled as well as each checkbox per row
-->
<ng-template #renderingTemplate let-isHeader let-isSubHeader="isSubHeader" let-column="column"
             let-dataToRender="data"
             let-level="nestingLevel"
             let-columnIndex="columnIndex"
             let-rowIndex="rowIndex">

    <ng-template *ngIf="isHeader" [ngTemplateOutlet]="colHeader"
                 [ngTemplateOutletContext]="{$implicit: isSubHeader, columnIndex:columnIndex,
                 level:level}">
    </ng-template>

    <ng-template *ngIf="!isHeader" [ngTemplateOutlet]="colBody"
                 [ngTemplateOutletContext]="{$implicit: column, level:level,
                    data:dataToRender,rowIndex:rowIndex}">
    </ng-template>
</ng-template>


<ng-template #colHeader let-isSubHeader let-columnIndex="columnIndex">
    <th [ngClass]="{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,
                    'dt-cell-def': true,
                    'dt-sub-header': isSubHeader,
                    'dt-is-hidden': !dt.showSelectionColumn}" align="center">
        &nbsp;
    </th>

</ng-template>


<ng-template #colBody let-data="data" let-rowIndex="rowIndex" , let-level="level">

    <td #cell [class]="dynamicBodyClass(data)"
        [style.padding-left.px]="indentForControl(cell, level)"
        align="center"
        [ngClass]="{ 'dt-is-default dt-selection-column': true,
        'dt-cell-def': true,
        'dt-is-hidden': !dt.showSelectionColumn}">

        <aw-radiobutton [name]="'DTRadio'" [value]="data" [(ngModel)]="dt.dataSource.state.selection">
        </aw-radiobutton>
    </td>
</ng-template>
`,
                styles: [``],
                encapsulation: ViewEncapsulation.None,
                providers: [DomHandler]
            },] },
];
/** @nocollapse */
DTSingleSelectColumnComponent.ctorParameters = () => [
    { type: Environment },
    { type: DomHandler }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DT component that implements the data grid that shows tabular data. Even the basic
 * structure is based on PrimeNG datatable its completely refactored into smaller pieces that
 * allows more extensibility and trying to stay as close as possible to existing AWL implementation
 *
 * There are 3 main pieces:
 *
 *  Table Wrapper - focuses on the outer structure. Container with basic datable layout plus
 *  contains any additional panels that datatable needs such as our new concept how editing will
 *  work - sliding panel from the bottom
 *
 *  Datatable Column - Instead of rendering everything inside DT I split the part that renders
 *  column into separate component. This way component column has its own renderer template which
 *  can render both header and data cells.
 *  Later on DTColumn is then extended to support other additional column types
 *  SingleSelectionColumn, MultiSelectionColumn, both responsible for rendering selection controls.
 *
 * To support pivotal layout this can be extended for other additional columns that implements their
 * own rendering templates
 *
 * Datatable - The main component that is only focus on header and body rendering and basaed on the
 * column type it will render the correct template
 * column type it will render the correct template
 *
 *
 *
 *
 *
 */
class Datatable2Component extends BaseComponent {
    /**
     *
     * In case of outline table we are inject OutlineState which is provided in the DT component
     * definition. This is used by nested outlineFor component it set itself as reference and
     * initialize the state so it can be used later on inside OutlineControl
     *
     *
     * Each Datatable is pre-defaulted with its own version of DataSource so all the observers
     * inside are unique for this component
     *
     * @param {?} env
     * @param {?} el
     * @param {?} _defaultDS
     * @param {?} changeDetector
     * @param {?} factoryResolver
     * @param {?} outlineState
     * @param {?} zone
     * @param {?} injector
     */
    constructor(env, el, _defaultDS, changeDetector, factoryResolver, outlineState, zone, injector) {
        super(env);
        this.env = env;
        this.el = el;
        this._defaultDS = _defaultDS;
        this.changeDetector = changeDetector;
        this.factoryResolver = factoryResolver;
        this.outlineState = outlineState;
        this.zone = zone;
        this.injector = injector;
        /**
         *  Hides or shows table heading where we have filters and tools menus
         */
        this.showTableHeader = true;
        /**
         * See AWDataTable
         *
         */
        this.pivotalLayout = false;
        /**
         * See AWDataTable
         */
        this.initialSortOrder = 'descending';
        /**
         * When DT is loaded in the page and we are not in the full screen (full page mode), this
         * is hte number of lines that DT will show
         *
         * todo: come up with better name
         */
        this.displayRowSize = 10;
        /**
         * Used for paging on lazy loading using infinite scroller to set initial fetch limit size
         *
         * todo: come up with better name !!!
         *
         */
        this.pageSize = 15;
        /**
         * Default message when there are no data .
         *
         * todo: Use i18n value and create resource file
         */
        this.emptyMessage = 'No records found';
        /**
         *
         * See AWDataTable
         *
         */
        this.selectionMode = 'none';
        /**
         *
         * Can provide custom icon. These icons are not animated divs, we used css
         * transformation to rotate them.
         *
         */
        this.loadingIcon = 'icon-synchronize';
        /**
         * Additional indent can be added when rendering detail row
         */
        this.indentDetailRow = false;
        /**
         * See AWDataTable
         *
         */
        this.indentationPerLevel = 25;
        /**
         *
         *  SubHeader is used to show summary columns, which in our UX is shown at the top just under
         *  the regular table header
         *
         */
        this.showSubHeader = false;
        /**
         * See OutlineFor - only used in the tree mode
         */
        this.expandAll = false;
        /**
         *
         * See OutlineFor  - format - only used in the tree mode
         */
        this.outlineFormat = 'free';
        /**
         * See AWDataTable
         */
        this.pushRootSectionOnNewLine = true;
        /**
         * Render or hide expansion control for row detail columns. Expansion control makes sense for
         * simple table, when using this inside outline (tree table), its driven by outline control
         */
        this.showRowDetailExpansionControl = true;
        /**
         * See AWDataTable
         *
         */
        this.showSelectionColumn = true;
        /**
         * See AWDataTable
         *
         */
        this.showSelectAll = true;
        /**
         * Show or hide global search term input field in the header
         */
        this.showGlobalSearch = true;
        /**
         * Enables or disables row reordering
         *
         */
        this.dndRowEnabled = false;
        /**
         *
         * Fires event that sorting is enabled for column and we trigger sorting
         *
         */
        this.onSort = new EventEmitter();
        /**
         * Based on selection mode it triggers even
         *
         */
        this.onRowClick = new EventEmitter();
        /**
         *
         * When multi or single selection mode is enabled it will trigger event when checkbox or
         * radio buttons is selected
         *
         * todo: implement SingleSelectionDTColumn, MultiSelectionDTColumn with their renderers
         */
        this.onRowSelectionChange = new EventEmitter();
        /**
         * When cell body selection changes we fire event
         *
         */
        this.onCellChange = new EventEmitter();
        /**
         * When cell header selection changes we fire event
         *
         */
        this.onHeaderSelection = new EventEmitter();
        /**
         *
         * Triggers when items in the list are updated
         *
         */
        this.valueChange = new EventEmitter();
        this.classList = 'w-datatable ';
        /**
         *  Indicates that columns were initialed Also used when we hide and show column to trigger
         *  change.
         *
         */
        this.columnsChanged = false;
        /**
         * See AWDataTable
         */
        this.numberOfColsBeforeData = 0;
        /**
         * See AWDataTable
         */
        this.startOfFirstDataColumn = 0;
        this.dataSource = this._defaultDS;
    }
    /**
     * Pushes a state out to application. Can be use as two way bindings
     *
     * [(state)]=dtState(s)
     *
     * @return {?}
     */
    get state() {
        return this.dataSource.state;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set state(val) {
        this.dataSource.state = val;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (isPresent(this.list) && isPresent(this.destinationClass)) {
            throw new Error('You cannot use both bindings [list] and [destinationClass]!');
        }
        this.detailRowExpansionState = new DetailRowExpansionState(this);
        // init default columns
        this.rowDetailExpandColumn = this.factoryResolver
            .resolveComponentFactory(DTDetailRowExpanderComponent).create(this.injector).instance;
        this.multiSelectColumn = this.factoryResolver
            .resolveComponentFactory(DTMultiSelectColumnComponent).create(this.injector).instance;
        this.singleSelectColumn = this.factoryResolver
            .resolveComponentFactory(DTSingleSelectColumnComponent).create(this.injector).instance;
        /**
                 * If the data are not deferred and we get list directly then it creates DS. If
                 * ngOnChanges is called first we properly init DS and clean this.list
                 *
                 */
        if (isPresent(this.destinationClass) || isPresent(this.list)) {
            this.initDatasource();
        }
        else if (this.dataSource.initialized) {
            this.initDatasource(false);
        }
        // since we work with references let's pass created map inside our state
        this.outlineState.expansionStates = this.state.outlineState;
    }
    /**
     * When data arrives later maybe due to REST API latency, initialize DS only when we have a
     * data, otherwise if data changed thru the bindings just trigger dataChange event
     *
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        super.ngOnChanges(changes);
        if (changes['list'] && isPresent(changes['list'].currentValue)
            && !this.dataSource.initialized) {
            this.initDatasource();
        }
        else if (this.dataSource.initialized) {
            this.dataSource.dataProvider.dataChanges.next(this.list);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // make sure we init a state when detail column is present
        // todo: move this initialization to datasource
        this.detailRowExpansionState.detailExpansionEnabled = isPresent(this.rowDetailColumn);
        this.initColumns();
        this.columnsSubscription = this.colsQuery.changes.subscribe(_ => {
            this.initColumns();
            this.changeDetector.markForCheck();
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // assign it programatically as we want to have a context for the filter
        if (isPresent(this.rowDetailColumn) && isPresent(this.outlineState.outlineFor)) {
            this.outlineState.outlineFor.filterOut = this.skipOutlineItem.bind(this);
        }
        if (isPresent(this.outlineState.outlineFor)) ;
        this.initialized = true;
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.columnsChanged && this.el.nativeElement.offsetParent) {
            this.columnsChanged = false;
        }
        if (this.hasFrozenColumns()) {
            this.frozenColumns.forEach((col, index) => col.postInitialize(index));
        }
        else {
            this.columns.forEach((col, index) => col.postInitialize(index));
        }
    }
    /**
     * Key entry method that initialized our columns. Later on when we will support selection and
     * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
     * components and add them to the list so they can be rendered.
     *
     * so the idea here is:
     *
     * When DT component initialize and we are in editing mode and we support Single/Multi selection
     * we will use ComponentFactoryResolver to create component and add it as first item to the list
     * and then it will be rendered just like anythign else.
     *
     * @return {?}
     */
    initColumns() {
        this.columns = [];
        this.frozenColumns = [];
        if (this.detailRowExpansionState.detailExpansionEnabled) {
            this.initDetailColumnExpansion();
        }
        if (this.hasLeadingSelectColumn() && this.selectionMode === 'multi') {
            this.multiSelectColumn.initialize(this);
            this.columns.push(this.multiSelectColumn);
        }
        else if (this.hasLeadingSelectColumn() && this.selectionMode === 'single') {
            this.singleSelectColumn.initialize(this);
            this.columns.push(this.singleSelectColumn);
        }
        /**
                 * Add expansion column when detail row is enabled
                 */
        if (this.detailRowExpansionState.detailExpansionEnabled && !this.isOutline()) {
            this.rowDetailExpandColumn.initialize(this);
            this.columns.push(this.rowDetailExpandColumn);
        }
        this.colsQuery
            .filter((col1) => !col1.frozen)
            .forEach((col) => {
            col.initialize(this);
            this.columns.push(col);
        });
        this.initFrozenColumns();
        this.initColumnInfo();
        this.columnsChanged = true;
    }
    /**
     * Check if current column is programmatically created
     *
     * @param {?} col
     * @return {?}
     */
    isInternalColumn(col) {
        return col instanceof DTSingleSelectColumnComponent ||
            col instanceof DTMultiSelectColumnComponent ||
            col instanceof DTDetailRowExpanderComponent;
    }
    /**
     * Create new Datasource based on passed values. It tries to initialize DS for first time
     * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
     * can be triggered also from ngOnChanges.
     *
     * @param {?=} initialize
     * @return {?}
     */
    initDatasource(initialize = true) {
        if (isBlank(this.state)) {
            this.state = Datatable2State.create(0, this.pageSize, this.displayRowSize, this.initialSortKey, this.sortOrderingForString(this.initialSortOrder));
        }
        else {
            this.state.limit = this.state.displayLimit = this.displayRowSize;
            if (isPresent(this.initialSortKey)) {
                this.state.sortKey = this.initialSortKey;
                this.state.sortOrder = this.sortOrderingForString(this.initialSortOrder);
            }
        }
        if (initialize) {
            let /** @type {?} */ qType = (this.isOutline() && this.outlineFormat === 'tree') ?
                QueryType.FullTextOutline : QueryType.FullText;
            this.dataSource.init({
                obj: isPresent(this.destinationClass) ? this.destinationClass : this.list,
                queryType: qType,
                state: this.state,
                multiselect: false
            });
        }
        this.dataSource.fetch(this.state);
        // reset list to make sure it comes from DataProvider, we use list  to initialize
        this.list = null;
        // This is the ENTRY point for the DATA CHANGES. All addition, edits, deletion ends up
        // here. We dont work directly with LIST. Any change is reactive and here is listener
        this.dataSource.open().subscribe((data) => {
            this.updateList(data);
        });
    }
    /**
     * When detailRow column is present we initialize a state holding information which item is
     * expanded.
     *
     * todo: This is temporary here and once we suport lazy loading move this to datasource.
     *
     * For example for outline tree table we need to connect a state from outline with a state in
     * here as we are using outline control to expand and collapse items
     * @return {?}
     */
    initDetailColumnExpansion() {
        if (isPresent(this.rowDetailColumn)) {
            this.rowDetailColumn.initialize(this);
        }
        this.detailRowExpansionState.detailExpansionEnabled = isPresent(this.rowDetailColumn) &&
            BooleanWrapper.isTrue(this.showRowDetailExpansionControl);
    }
    /**
     * This method is executed after we initialize all the columns in order to calculate correct
     * numbers used for indentation while rendering selection columns as well as detail row columns.
     *
     * Here we need to be aware how many columns to span
     *
     * @return {?}
     */
    initColumnInfo() {
        this.numberOfColsBeforeData = 0;
        this.columns.forEach((col) => {
            if (!col.isValueColumn()) {
                this.numberOfColsBeforeData++;
            }
        });
        if (this.indentDetailRow) {
            this.numberOfColsBeforeData++;
        }
        this.startOfFirstDataColumn = this.columns.length - this.numberOfColsBeforeData;
    }
    /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    onCellSelectionChange(cell, column, item) {
        if (this.selectionMode !== 'cell') {
            return;
        }
        let /** @type {?} */ lookupKey = {
            col: column.key || column.label,
            item: item
        };
        if (isPresent(this.state.selection) && this.state.selection.length > 0) {
            let /** @type {?} */ foundIndex = ListWrapper.findIndexComplex(this.state.selection, lookupKey);
            let /** @type {?} */ isSelected = foundIndex !== -1;
            if (isSelected) {
                this.state.selection = this.state.selection
                    .filter((val, index) => index !== foundIndex);
            }
            else {
                this.state.selection = [...this.state.selection, lookupKey];
            }
        }
        else {
            this.state.selection = [lookupKey];
        }
        this.onCellChange.emit(this.state.selection);
    }
    /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @return {?}
     */
    onHeaderSelectionChange(cell, column) {
        if (isPresent(this.state.headerSelection)) {
            if (this.isHeaderSelected(column)) {
                this.state.headerSelection = null;
            }
            else {
                this.state.headerSelection = column;
            }
        }
        else {
            this.state.headerSelection = column;
        }
        this.onHeaderSelection.emit(this.state.headerSelection);
    }
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onHandleRowClicked(event, item) {
        // special alt key modifier. When used with rows it indicates there is a D&D enabled
        if (event.altKey) {
            return;
        }
        if (this.selectionMode === 'multi') {
            this.onRowToggle(event, item);
        }
        else if (this.selectionMode === 'single') {
            this.onRowSelect(event, item);
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onRowToggle(event, item) {
        let /** @type {?} */ rowSelected = true;
        if (isPresent(this.state.selection) && this.state.selection.length > 0) {
            let /** @type {?} */ foundIndex = ListWrapper.findIndexComplex(this.state.selection, item);
            let /** @type {?} */ isSelected = foundIndex !== -1;
            if (isSelected) {
                this.state.selection = this.state.selection
                    .filter((val, index) => index !== foundIndex);
                rowSelected = false;
            }
            else {
                this.state.selection = [...this.state.selection, item];
            }
            // for the outline go up and down the sync with treeitems
            if (this.isOutline()) {
                this.onHandleOutlineRowToggleToChildren(item, isSelected);
                this.oHandleOutlineRowToggleToParent(item, isSelected);
            }
        }
        else {
            this.state.selection = [item];
            if (this.isOutline()) {
                this.onHandleOutlineRowToggleToChildren(item, false);
                this.oHandleOutlineRowToggleToParent(item, false);
            }
        }
        this.onRowSelectionChange.emit({
            isSelected: rowSelected,
            item: this.state.selection
        });
        event.stopPropagation();
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    onRowSelect(event, item) {
        this.state.selection = item;
        event.stopPropagation();
        this.onRowSelectionChange.emit(item);
    }
    /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    onHandleOutlineRowToggleToChildren(currentItem, isSelected) {
        let /** @type {?} */ childrenForNode = this.children.apply(this.context, [currentItem]) || [];
        if (childrenForNode.length > 0) {
            // If is selected currently then toggle to other state
            if (!isSelected) {
                // when checking all from root, deselect children and add all
                this.onHandleOutlineRowToggleToChildren(currentItem, true);
                this.state.selection = [...this.state.selection, ...childrenForNode];
            }
            else {
                // remove each child
                for (let /** @type {?} */ child of childrenForNode) {
                    let /** @type {?} */ foundIndex = ListWrapper.findIndexComplex(this.state.selection, child);
                    this.state.selection = this.state.selection
                        .filter((val, index) => index !== foundIndex);
                }
            }
            // apply the same for children of children
            for (let /** @type {?} */ child of childrenForNode) {
                this.onHandleOutlineRowToggleToChildren(child, isSelected);
            }
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    oHandleOutlineRowToggleToParent(currentItem, isSelected) {
        let /** @type {?} */ parent = currentItem.$$parentItem;
        if (isPresent(parent)) {
            let /** @type {?} */ childrenForNode = this.children.apply(this.context, [parent]) || [];
            let /** @type {?} */ allSelected = true;
            for (let /** @type {?} */ child of childrenForNode) {
                allSelected = ListWrapper.findIndexComplex(this.state.selection, child) !== -1
                    && allSelected;
            }
            if (!isSelected) {
                if (allSelected) {
                    this.state.selection.push(parent);
                }
            }
            else {
                if (!allSelected) {
                    let /** @type {?} */ parentIndex = ListWrapper.findIndexComplex(this.state.selection, parent);
                    this.state.selection = this.state.selection
                        .filter((val, index) => index !== parentIndex);
                }
            }
            this.oHandleOutlineRowToggleToParent(currentItem.$$parentItem, isSelected);
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    onDnDRowDrop(origPos, newPos, dropPos) {
        if (isPresent(this.dataSource)) {
            // console.log('Dropping row #: ', origPos + ' ' + dropPos + ' row #: ' + newPos);
            this.dataSource.reorderRows(origPos, newPos, dropPos);
        }
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    onOutlineExpandChange(event) {
        let /** @type {?} */ item = event.item;
        // We dont really need to store a state form outline locally as we are using the same object
        // reference
        // this.state.outlineState = this.outlineState.expansionStates;
        if (this.canUseForDetailRow(item)) {
            this.detailRowExpansionState.toggle(item);
        }
    }
    /**
     * See AWDataTable
     *
     *
     * @return {?}
     */
    sortSingle() {
        if (isPresent(this.list) && isPresent(this.sortColumn)) {
            assert(isPresent(this.sortColumn.key), 'Invalid column to sort');
            this.dataSource.sort(this.sortColumn.key, this.sortColumn.sortOrder);
            this.onSort.emit({
                field: this.sortColumn.key,
                order: this.sortColumn.sortOrder
            });
        }
    }
    /**
     * See AWDataTable
     *
     * @return {?}
     */
    handleDataChange() {
        if (this.state.sortKey || this.sortColumn) {
            if (!this.sortColumn && this.columns) {
                this.sortColumn = this.columns.find(col => col.key === this.state.sortKey);
            }
        }
        this.updateDataToRender();
        this.valueChange.emit(this.list);
    }
    /**
     * @param {?=} datasource
     * @return {?}
     */
    updateDataToRender(datasource) {
        this.dataToRender = datasource || this.list;
        if (isBlank(this.children) && isPresent(this.dataToRender)
            && this.dataToRender.length > 0 && isOutlineNode(this.dataToRender[0])) {
            this.outlineFormat = 'tree';
        }
        // this.changeDetector.markForCheck();
        this.changeDetector.detectChanges();
    }
    /**
     * @return {?}
     */
    reset() {
        this.sortColumn = null;
        this.updateDataToRender();
    }
    /**
     * See AWDataTable
     * @param {?} item
     * @return {?}
     */
    isHeaderSelected(item) {
        if (isBlank(this.state.headerSelection)) {
            return false;
        }
        let /** @type {?} */ colMatched = item.key || item.label;
        let /** @type {?} */ currentCol = this.state.headerSelection.key || this.state.headerSelection.label;
        return colMatched === currentCol;
    }
    /**
     *
     * See AWDataTable
     *
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    isBodyCellSelected(column, item) {
        let /** @type {?} */ lookupKey = {
            col: column.key || column.label,
            item: item
        };
        return isPresent(this.state.selection) &&
            ListWrapper.findIndexComplex(this.state.selection, lookupKey) !== -1;
    }
    /**
     *  See AWDataTable
     *
     * @param {?} item
     * @return {?}
     */
    isRowSelected(item) {
        if (this.hasLeadingSelectColumn() && isPresent(this.state.selection)) {
            if (this.selectionMode === 'multi') {
                return ListWrapper.findIndexComplex(this.state.selection, item) !== -1;
            }
            else if (this.selectionMode === 'single') {
                return equals(this.state.selection, item);
            }
        }
        return false;
    }
    /**
     *
     * Do we have data to render Used inside template to tell if we should use the NoData template
     *
     * @return {?}
     */
    isEmpty() {
        return isBlank(this.dataToRender) || (this.dataToRender.length === 0);
    }
    /**
     * @return {?}
     */
    hasFrozenColumns() {
        return isPresent(this.frozenColumns) && this.frozenColumns.length > 0;
    }
    /**
     * See AWDataTable
     * @return {?}
     */
    hasInvisibleSelectionColumn() {
        return this.hasLeadingSelectColumn() && !this.showSelectionColumn;
    }
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    hasLeadingSelectColumn() {
        return this.selectionMode !== 'none' && this.selectionMode !== 'cell';
    }
    /**
     * @return {?}
     */
    visibleColumns() {
        return this.columns ? this.columns.filter(c => c.isVisible) : [];
    }
    /**
     * See AWDataTable
     *
     * @param {?} direction
     * @return {?}
     */
    sortOrderingForString(direction) {
        if (isBlank(direction) || direction === 'ascending') {
            return 1;
        }
        if (isBlank(direction) || direction === 'descending') {
            return -1;
        }
        // todo: log bad key
        return 1;
    }
    /**
     * @param {?} direction
     * @return {?}
     */
    sortOrderingForNumber(direction) {
        if (isBlank(direction) || direction === 1) {
            return 'ascending';
        }
        if (isBlank(direction) || direction === -1) {
            return 'descending';
        }
        // todo: log bad key
        return 'ascending';
    }
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    toggleAllColumns(event) {
        let /** @type {?} */ currentItems = this.dataToRender || [];
        let /** @type {?} */ selectedObject = this.state.selection || [];
        if (selectedObject.length >= currentItems.length) {
            this.state.selection = [];
        }
        else {
            this.state.selection = [];
            this.state.selection = [...currentItems];
        }
    }
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    isToggleAllColumnSelected() {
        let /** @type {?} */ currentItems = this.dataToRender || [];
        let /** @type {?} */ selectedObject = this.state.selection || [];
        return currentItems.length > 0 && selectedObject.length >= currentItems.length;
    }
    /**
     * @return {?}
     */
    isToggleAllColumnDisabled() {
        let /** @type {?} */ currentItems = this.dataToRender || [];
        return currentItems.length === 0;
    }
    /**
     *
     * Used by template to decide if we need to render DetailRow template. We need to have
     * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
     * check if the item that is about to be rendered is eligible for detail row
     *
     * @param {?} item
     * @return {?}
     */
    showDetailColumn(item) {
        if (this.canUseForDetailRow(item) && this.detailRowExpansionState.isExpanded(item)) {
            return true;
        }
        return false;
    }
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    isOutline() {
        return isPresent(this.children) || this.outlineFormat === 'tree';
    }
    /**
     *
     * When dealing with detail column (detail row) and outline all together we need have a
     * mechanism to tell to the outline "don't render the next level of items" and use detail row.
     * So certain item type needs to be skipped.
     *
     * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
     * if we should skip next level.
     *
     * @param {?} item
     * @return {?}
     */
    skipOutlineItem(item) {
        return this.canUseForDetailRow(item);
    }
    /**
     *
     * See AWDaTable
     *
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    getValue(data, field) {
        return FieldPath.getFieldValue(data, field);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.columnsSubscription) {
            this.columnsSubscription.unsubscribe();
        }
    }
    /**
     * Makes sure that we also include programmatic column if present. Move them to the correct
     * array
     *
     * @return {?}
     */
    initFrozenColumns() {
        this.colsQuery
            .filter((col1) => col1.frozen)
            .forEach((col) => {
            col.initialize(this);
            this.frozenColumns.push(col);
        });
        if (this.frozenColumns.length > 0) {
            // find last index of column that is internal / programmatic
            let /** @type {?} */ lastInx = this.columns.slice()
                .reverse()
                .findIndex((col) => this.isInternalColumn(col));
            if (lastInx !== -1) {
                let /** @type {?} */ idx = this.columns.length - 1 - lastInx;
                let /** @type {?} */ internalCols = this.columns.splice(0, idx + 1);
                this.frozenColumns = [...internalCols, ...this.frozenColumns];
            }
            let /** @type {?} */ hasValidCols = this.columns
                .findIndex((col) => isBlank(col.width)) === -1;
            assert(hasValidCols || isPresent(this.scrollWidth), 'When using [frozen] binding you need specify [width] for each ' +
                'column or [scrollWidth] on datatable!');
            assert(isBlank(this.rowDetailColumn), 'You cannot combine aw-dt-detail-column with frozen columns!');
        }
    }
    /**
     * Updates current immutable list and trigger change detection. Need to wrap it with
     * setTimeout as the change can easily come after view checked and this would result some errors
     *
     * @param {?} newList
     * @return {?}
     */
    updateList(newList) {
        setTimeout(() => {
            this.list = newList;
            this.handleDataChange();
        });
    }
    /**
     * @param {?} item
     * @return {?}
     */
    canUseForDetailRow(item) {
        return isPresent(this.rowDetailColumn) &&
            (/** @type {?} */ (this.rowDetailColumn)).showDetailRow(item);
    }
}
Datatable2Component.decorators = [
    { type: Component, args: [{
                selector: 'aw-datatable2',
                template: `<!--
    This template focus only on header and body rendering.

    This datatable also supports frozen column and for this rendering it is pretty much transparent
    as it received sets of column that it needs to render from the TableWrapper.

    TableWrapper in case of frozen columns calls #headerRows and #bodyRows templates twice to
    render to separate tables where one has frozen columns and another one has the rest and its
    scrollable
-->

<aw-dt-wrapper #dtWrapper>
    <ng-template #headingArea>
        <ng-content select="aw-dt-header2"></ng-content>
    </ng-template>

    <ng-template #headerRows let-colsToRender let-frozenView="frozenColumns">
        <ng-container
            *ngTemplateOutlet="header; context:{$implicit: colsToRender, frozen:frozenView }">
        </ng-container>
    </ng-template>

    <ng-template #bodyRows let-colsToRender>
        <ng-template [ngIf]="isOutline()">
            <ng-container
                *ngTemplateOutlet="bodyOutline; context:{$implicit: colsToRender}"></ng-container>
        </ng-template>
        <ng-template [ngIf]="!isOutline()">
            <ng-container
                *ngTemplateOutlet="bodyPlain; context:{$implicit: colsToRender}"></ng-container>
        </ng-template>
    </ng-template>
</aw-dt-wrapper>


<!--
    Each rendering column has its own renderTemplate which define how things should be render.
    Based on different column types this code should be transparent as we dont care on this
    level what kind of column we are rendering.

    Later on when we will support single/multi selection, this will be just another column extending
    DTColumn and providing its own template

    We pass into this template if we are rendering header, subHeader, or data
-->
<ng-template #header let-colsToRender let-frozen="frozen">
    <tr>
        <ng-template ngFor let-col [ngForOf]="colsToRender" let-lastCol="last"
                     let-columnIndex="index">

            <ng-container *ngTemplateOutlet="col.rendererTemplate;
                context:{$implicit: true, isSubHeader:false,
                columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))}">
            </ng-container>
        </ng-template>
    </tr>

    <tr *ngIf="showSubHeader">
        <ng-template ngFor let-col [ngForOf]="colsToRender" let-lastCol="last">
            <ng-container *ngTemplateOutlet="col.rendererTemplate;
                context:{$implicit: true, isSubHeader:true}">
            </ng-container>
        </ng-template>
    </tr>
</ng-template>


<ng-template #bodyPlain let-colsToRender>

    <tbody [ngClass]="{'dt-content dt-data-cells ': true, 'dt-is-hoverable-row': rowHover}">

    <ng-template ngFor let-rowData [ngForOf]="dataToRender" let-even="even" let-odd="odd"
                 let-rowIndex="index" [ngForTrackBy]="rowTrackBy">

        <ng-container *ngTemplateOutlet="rowTemplate; context:{$implicit: rowData, even:even,
                                          odd:odd, rowIndex:rowIndex, colsToRender:colsToRender}">
        </ng-container>

        <ng-template [ngIf]="showDetailColumn(rowData)">
            <ng-container *ngTemplateOutlet="rowDetailColumn.rendererTemplate;
                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}">
            </ng-container>
        </ng-template>

    </ng-template>
    <ng-container *ngTemplateOutlet="noData"></ng-container>
    </tbody>
</ng-template>


<ng-template #bodyOutline let-colsToRender>
    <tbody #outlineFor awOutlineFor [list]="dataToRender"
           [format]="outlineFormat"
           [context]="context"
           [indentationPerLevel]="indentationPerLevel"
           [pushRootSectionOnNewLine]="pushRootSectionOnNewLine"
           [children]="children" [expandAll]="expandAll"
           [state]="outlineState"
           [ngClass]="{'dt-content dt-data-cells ': true,
                           'dt-is-hoverable-row': rowHover}"
           (onExpandChange)="onOutlineExpandChange($event)">

    <ng-template #outline let-rowData let-nestingLevel="nestingLevel" let-rowIndex="rowIndex">
        <ng-container *ngTemplateOutlet="rowTemplate;
                                context:{$implicit: rowData, nestingLevel:nestingLevel, colsToRender:colsToRender}">
        </ng-container>

        <ng-template [ngIf]="showDetailColumn(rowData)">
            <ng-container *ngTemplateOutlet="rowDetailColumn.rendererTemplate;
                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}">
            </ng-container>
        </ng-template>

    </ng-template>
    <ng-container *ngTemplateOutlet="noData"></ng-container>
    </tbody>
</ng-template>

<!--
    Default template that is display when there are no data
-->
<ng-template #noData>
    <tr *ngIf="isEmpty()" class=" dt-emptymessage-row"
        [style.visibility]="loading ? 'hidden' : 'visible'">

        <td [attr.colspan]="visibleColumns().length" class="dt-emptymessage">
            <span *ngIf="!emptyMessageTemplate">{{emptyMessage}}</span>
            <ng-container *ngTemplateOutlet="emptyMessageTemplate"></ng-container>
        </td>
    </tr>
</ng-template>

<!--
    Template that renders actual row. Renders both header and body column. Each rendered
    column has its own template called rendererTemplate that has all things that needs to be
    rendered and we just tell the template if we are rendering header, subheader or body
-->
<ng-template #rowTemplate let-rowData let-even="event" let-odd="odd" let-rowIndex="rowIndex"
             let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">


    <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
        class="dt-body-row"
        (click)="onHandleRowClicked($event, rowData)"
        [attr.nestingLevel]="nestingLevel"
        [ngClass]="{'dt-even-row': even, 'dt-odd-row': odd,
            'dt-row-selected': isRowSelected(rowData),
            'dt-row-draggable': dndRowEnabled,
            'dt-root-section': nestingLevel === 0 }">

        <ng-template ngFor let-col [ngForOf]="colsToRender" let-colIndex="index">
            <ng-container *ngTemplateOutlet="col.rendererTemplate;
                    context:{$implicit: false, data:rowData, rowIndex:rowIndex,
                    nestingLevel:nestingLevel}">
            </ng-container>
        </ng-template>
    </tr>
</ng-template>


`,
                styles: [`.w-datatable{position:relative;display:block;box-sizing:border-box}.w-datatable table{border-collapse:collapse;width:100%;table-layout:fixed}.w-datatable tbody,.w-datatable td,.w-datatable th{outline:0}.dt-cell-def,.dt-cell-def-selectable{border:1px solid transparent;padding:17px 16px;box-sizing:border-box}.dt-cell-def-selectable{cursor:pointer;width:100%;height:100%}th .dt-cell-def-selectable{border-width:4px 1px 1px;padding:14px 16px 17px}td .dt-cell-def-selectable{border-width:0 1px 0 5px;padding:17px 16px 17px 13px}.dt-data-cells tr.dt-is-highlight,.dt-data-cells tr.dt-is-hover{border-color:inherit;font-weight:inherit;cursor:pointer}.w-datatable-rtl{direction:rtl}.w-datatable-rtl.w-datatable-rtl.w-datatable thead th{text-align:right}.dt-root-section .dt-cell-def,.dt-root-section .dt-cell-def-selectable{background-color:#f3f6f8;padding:10px 16px;border-bottom-color:transparent;border-right-color:transparent}.dt-plain-layout .dt-is-active,.dt-plain-layout .dt-is-default,.dt-plain-layout .dt-is-highlight,.dt-plain-layout .dt-is-hover,.dt-plain-layout .dt-is-hoverable-row{border-right-color:transparent}.dt-is-active,.dt-is-default,.dt-is-highlight,.dt-is-hover,.dt-is-hoverable-row{border:1px solid #d7d7d7;background-color:#fff;color:#363636}.dt-row-selected td{background-color:rgba(238,255,238,.71)}.dt-is-active{border-color:#065d9c;color:#199de0}.dt-is-highlight{background-color:rgba(65,117,5,.18)}.dt-is-hidden{display:none}.dt-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none}.dt-u-sortable{cursor:pointer}`],
                providers: [
                    ObjectUtils,
                    OutlineState,
                    { provide: DATA_SOURCE, useClass: DT2DataSource, deps: [DataProviders, DataFinders] },
                ],
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
Datatable2Component.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef },
    { type: DT2DataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
    { type: ChangeDetectorRef },
    { type: ComponentFactoryResolver },
    { type: OutlineState },
    { type: NgZone },
    { type: Injector }
];
Datatable2Component.propDecorators = {
    list: [{ type: Input }],
    destinationClass: [{ type: Input }],
    tableStyleClass: [{ type: Input }],
    bodyClassFn: [{ type: Input }],
    isRowSelectable: [{ type: Input }],
    showTableHeader: [{ type: Input }],
    pivotalLayout: [{ type: Input }],
    context: [{ type: Input }],
    initialSortOrder: [{ type: Input }],
    initialSortKey: [{ type: Input }],
    displayRowSize: [{ type: Input }],
    pageSize: [{ type: Input }],
    dataSource: [{ type: Input }],
    emptyMessage: [{ type: Input }],
    rowTrackBy: [{ type: Input }],
    rowHover: [{ type: Input }],
    loading: [{ type: Input }],
    selectionMode: [{ type: Input }],
    loadingIcon: [{ type: Input }],
    indentDetailRow: [{ type: Input }],
    indentationPerLevel: [{ type: Input }],
    showSubHeader: [{ type: Input }],
    children: [{ type: Input }],
    showExpansionControl: [{ type: Input }],
    expandAll: [{ type: Input }],
    outlineFormat: [{ type: Input }],
    pushRootSectionOnNewLine: [{ type: Input }],
    showRowDetailExpansionControl: [{ type: Input }],
    showSelectionColumn: [{ type: Input }],
    showSelectAll: [{ type: Input }],
    showGlobalSearch: [{ type: Input }],
    scrollWidth: [{ type: Input }],
    dndRowEnabled: [{ type: Input }],
    onSort: [{ type: Output }],
    onRowClick: [{ type: Output }],
    onRowSelectionChange: [{ type: Output }],
    onCellChange: [{ type: Output }],
    onHeaderSelection: [{ type: Output }],
    header: [{ type: ContentChild, args: [DTHeaderComponent2,] }],
    emptyMessageTemplate: [{ type: ContentChild, args: ['noDataTempl',] }],
    headerTemplate: [{ type: ContentChild, args: ['dtHeader',] }],
    subHeaderTemplate: [{ type: ContentChild, args: ['dtSubHeader',] }],
    bodyTemplate: [{ type: ContentChild, args: ['dtBody',] }],
    headerFilterTemplate: [{ type: ContentChild, args: ['headerFilter',] }],
    colsQuery: [{ type: ContentChildren, args: [DTColumn2Component,] }],
    rowDetailColumn: [{ type: ContentChild, args: [DTDetailRowComponent,] }],
    valueChange: [{ type: Output }],
    classList: [{ type: HostBinding, args: ['class',] }],
    state: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Please see datatable for more detail description. But the main goal of this wrapper to remove
 * all the common surrounding parts around the datatable and make sure DT can focus only actual
 * header and body structure
 *
 * It is expected that wrapper also provides some code for the sliding up panel containing
 * buttons and other actions that will be used during editing
 *
 *
 * Todo: Extract the expand logic out into some directive or component or just a class
 *
 */
class DTWrapper extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} render
     * @param {?} thisElement
     * @param {?} domUtils
     * @param {?} platformId
     * @param {?} dt
     */
    constructor(env, render, thisElement, domUtils, platformId, dt) {
        super(env);
        this.env = env;
        this.render = render;
        this.thisElement = thisElement;
        this.domUtils = domUtils;
        this.platformId = platformId;
        this.dt = dt;
        /**
         * Color that is used by full screen div overlay to create expanding effect which needs to have
         * little tent;
         *
         */
        this.expandColorFrom = '#f3f3f3';
        /**
         * Color that is used to set after we are in the full screen so our overlay div hide everything
         * on the page
         *
         */
        this.expandColorTo = '#FFFFFF';
        /**
         * In order to debounce the typing we need to use subject
         *
         */
        this.searchTerms = new Subject();
        /**
         *  Specifies if we are in viewing/editing mode that can browse whole dataset lazily
         *
         */
        this.isFullScreenMode = false;
        /**
         * Tells if we can support full screen mode - only available for the browser
         *
         */
        this.supportFullScreen = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.querySubscription = this.searchTerms.pipe(
        // wait 300ms after each keystroke before considering the term
        debounceTime(300), 
        // ignore new term if same as previous term
        distinctUntilChanged(), switchMap((term) => of(term))).subscribe((term) => {
            if (isPresent(term)) {
                this.dt.dataSource.find(term);
            }
        });
        this.loadingSub = this.dt.valueChange
            .subscribe((data) => this.loadingFinished());
    }
    /**
     * Iterates over all columns marked as frozen and retrieve a width so we can update
     * parent div
     *
     * @return {?}
     */
    calculateFrozenWidth() {
        if (!this.dt.hasFrozenColumns()) {
            return null;
        }
        let /** @type {?} */ fWidth = 0;
        this.dt.frozenColumns.forEach((col) => {
            if (col.maxWidthPx > 0) {
                fWidth += col.widestCell;
            }
            else {
                fWidth += parseInt(col.width);
            }
        });
        return fWidth;
    }
    /**
     * When having two separate tables we need to make sure that rows of the tables are aligned.
     *
     * Therefore this method takes first column from each table read the height of the rows and set
     * the max height to both rows.
     *
     *
     * @param {?} frozenView
     * @param {?} unFrozenView
     * @return {?}
     */
    alignTablesHeights(frozenView, unFrozenView) {
        assert(isPresent(frozenView) && isPresent(frozenView), 'Cant align table views as one of the view is undefined');
        let /** @type {?} */ frozenRows = frozenView.querySelectorAll('table tr');
        let /** @type {?} */ unFrozenRows = unFrozenView.querySelectorAll('table tr');
        assert(frozenRows.length === unFrozenRows.length, 'Frozen Column: Two tables does not much!');
        Array.from(frozenRows).forEach((frozen, index) => {
            let /** @type {?} */ h = Math.max(frozen.offsetHeight, unFrozenRows[index].offsetHeight);
            frozen.style.height = h + 'px';
            unFrozenRows[index].style.height = h + 'px';
        });
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initFullScreen();
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.dt.hasFrozenColumns()) {
            let /** @type {?} */ frozenView = this.thisElement.nativeElement.querySelector('.dt-body-frozen');
            let /** @type {?} */ unFrozenView = this.thisElement.nativeElement.querySelector('.dt-body-unfrozen');
            let /** @type {?} */ frozenWidth = this.calculateFrozenWidth();
            frozenView.style.width = frozenWidth + 'px';
            if (isPresent(unFrozenView)) {
                // include border and create indent effect by having 1px white space
                unFrozenView.style.left = (frozenWidth + 2) + 'px';
                unFrozenView.style.width = unFrozenView.parentElement.offsetWidth
                    - frozenView.offsetWidth + 'px';
                this.alignTablesHeights(frozenView, unFrozenView);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (isPresent(this.querySubscription)) {
            this.querySubscription.unsubscribe();
        }
        if (isPresent(this.loadingSub)) {
            this.loadingSub.unsubscribe();
        }
    }
    /**
     *
     * When fullscreen functionality is enabled this method switches between norml and full screen
     * mode
     *
     * @param {?} event
     * @return {?}
     */
    toggleFullScreen(event) {
        if (this.isFullScreenMode) {
            this.closeFullScreen(event);
        }
        else {
            this.openFullScreen(event);
        }
    }
    /**
     * To push this component to full screen mode or maybe full page mode we need run following:
     *
     *  - Execute expand transformation, where we have additional overlay div that we slowly expand
     *  and this creates impression the DT is expanding
     *
     *  - apply full-screen class on top host element  - in this case its DataTable to switch
     *  to absolute positioning
     *
     *  - make sure we are scrolled all the way up
     *
     *  - hide all the elements on the page so their dimension don't interfere with this table.
     *
     *
     * @param {?} event
     * @return {?}
     */
    openFullScreen(event) {
        this.isFullScreenMode = true;
        this.runExpandEffect();
        this.originalScrollPosition = window.pageYOffset;
        window.scroll(0, 0);
        this.toggleFullScreenOnDT(true);
        // mark my element in the path that needs to stay
        let /** @type {?} */ parentNode = this.thisElement.nativeElement.parentNode;
        while (isPresent(parentNode) && parentNode.tagName !== 'BODY') {
            parentNode.classList.add('u-full-screen-element');
            parentNode = parentNode.parentNode;
        }
        this.hideNonFullScreenElement(document.body);
        this.dt.state.limit = Math.round(this.calculateLimit());
        this.dt.dataSource.fetch(this.dt.state);
        // once loaded set back correct page size we use when loading data
        this.dt.state.limit = this.dt.pageSize;
    }
    /**
     *
     * The same like above method (openFullScreen) but in reverse order.
     *
     * @param {?} event
     * @return {?}
     */
    closeFullScreen(event) {
        this.isFullScreenMode = false;
        this.showNonFullScreenElement();
        this.runCollapseEffect();
        this.toggleFullScreenOnDT(false);
        this.dt.dataSource.state.limit = this.dt.dataSource.state.displayLimit;
        this.dt.dataSource.state.offset = 0;
        this.dt.dataSource.fetch(this.dt.dataSource.state);
        setTimeout(() => {
            window.scroll(0, this.originalScrollPosition);
        }, 300);
    }
    /**
     * Applies set of set of css properties to make the DT main component on the page expand to
     * full page mode and back
     *
     * We want to make it with little delay to let other animation finish
     * @param {?} fullScreen
     * @return {?}
     */
    toggleFullScreenOnDT(fullScreen) {
        this.dt.el.nativeElement.style.opacity = 0;
        setTimeout(() => {
            if (fullScreen) {
                this.dt.classList += 'dt-full-screen';
                this.dt.el.nativeElement.style.opacity = 1;
            }
            else {
                this.dt.classList = this.dt.classList.replace('dt-full-screen', '');
                this.dt.el.nativeElement.style.opacity = 1;
            }
        }, 200);
    }
    /**
     * Listen for infinite scroll event and request new data from data source
     *
     * @param {?} event
     * @return {?}
     */
    onLazyLoad(event) {
        if (event.isLoad) {
            this.dt.state.offset = event.offset;
            this.dt.dataSource.fetch(this.dt.state);
        }
        else {
            let /** @type {?} */ dataProvider = this.dt.dataSource.dataProvider;
            let /** @type {?} */ data = dataProvider.dataChanges.getValue();
            dataProvider.dataChanges.next(data.slice(0, event.offset));
        }
    }
    /**
     * Creates animation effect to make it feel like the element (in this case DT) is expanding
     * from the middle to the full page mode.
     *
     * We take the dimension of the table then it is scaled slowly to the full page
     * @return {?}
     */
    runExpandEffect() {
        this.dtBoundingClientRect = this.thisElement.nativeElement.getBoundingClientRect();
        this.updateElement();
        this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorFrom;
        this.dtFullScreenOverlay.nativeElement.style.opacity = 1;
        this.applyTransformation(true);
        setTimeout(() => {
            this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorTo;
        }, 300);
    }
    /**
     * Applies the transformation and scale the helper div (overlay) down to make it look like
     * it collapses
     * @return {?}
     */
    runCollapseEffect() {
        this.updateElement();
        this.applyTransformation(false);
        setTimeout(() => {
            this.updateElement();
            this.dtFullScreenOverlay.nativeElement.style.opacity = 0;
        }, 200);
        setTimeout(() => {
            this.updateElement(this.dtBoundingClientRect.left, this.dtBoundingClientRect.top, 0, 0);
        }, 400);
    }
    /**
     * DFS  - to go thru all the element under BODY and remove them from the page.
     *
     * @param {?} parentElement
     * @return {?}
     */
    hideNonFullScreenElement(parentElement) {
        if (this.thisElement.nativeElement.parentNode === parentElement) {
            return;
        }
        for (let /** @type {?} */ i = 0; i < parentElement.children.length; i++) {
            let /** @type {?} */ element = parentElement.children[i];
            if (this.needTraverseDown(element)) {
                this.hideNonFullScreenElement(element);
            }
            else if (!element.classList.contains('dt-full-screen')) {
                element.classList.add('u-fs-element-out');
            }
        }
    }
    /**
     * Put all the element that were previously removed by hideNonFullScreenElement() back
     * @return {?}
     */
    showNonFullScreenElement() {
        Array.from(document.querySelectorAll('.u-fs-element-out'))
            .forEach((elem) => elem.classList.remove('u-fs-element-out'));
    }
    /**
     * \@Internal
     *
     * @param {?} element
     * @return {?}
     */
    needTraverseDown(element) {
        return isPresent(element) && element.tagName !== 'SCRIPT' &&
            element.classList.contains('u-full-screen-element') &&
            !element.classList.contains('dt-full-screen');
    }
    /**
     * When we enter full screen /page mode when need to calculate how many rows to load initially
     *
     * @return {?}
     */
    calculateLimit() {
        let /** @type {?} */ browserH = this.domUtils.browserDimentions().height;
        let /** @type {?} */ rowH = this.dt.el.nativeElement.querySelector('tbody tr:first-child').offsetHeight;
        return (isPresent(rowH) && rowH > 0) ? (browserH / rowH) + 20 : 50;
    }
    /**
     * \@Internal
     *
     * @param {?=} l
     * @param {?=} t
     * @param {?=} w
     * @param {?=} h
     * @return {?}
     */
    updateElement(l = this.dtBoundingClientRect.left, t = this.dtBoundingClientRect.top, w = this.dtBoundingClientRect.width, h = this.dtBoundingClientRect.height) {
        this.dtFullScreenOverlay.nativeElement.style.left = l + 'px';
        this.dtFullScreenOverlay.nativeElement.style.top = t + 'px';
        this.dtFullScreenOverlay.nativeElement.style.width = w + 'px';
        this.dtFullScreenOverlay.nativeElement.style.height = h + 'px';
    }
    /**
     * \@Internal
     *
     * @param {?} expand
     * @return {?}
     */
    applyTransformation(expand) {
        let /** @type {?} */ x, /** @type {?} */ y, /** @type {?} */ tx, /** @type {?} */ ty;
        if (expand) {
            x = window.innerWidth / this.dtBoundingClientRect.width;
            y = window.innerHeight / this.dtBoundingClientRect.height;
            tx = (window.innerWidth / 2 - this.dtBoundingClientRect.width / 2
                - this.dtBoundingClientRect.left) / x;
            ty = (window.innerHeight / 2 - this.dtBoundingClientRect.height / 2
                - this.dtBoundingClientRect.top) / y;
        }
        else {
            x = 1;
            y = 1;
            tx = this.dtBoundingClientRect.left;
            ty = this.dtBoundingClientRect.top;
        }
        this.dtFullScreenOverlay.nativeElement.style.transform =
            'scaleX(' + x + ') scaleY(' + y + ') translate3d(' + (tx) + 'px, ' + (ty) + 'px, 0px)';
    }
    /**
     * INFINITE SCROLLING METHODS
     * @return {?}
     */
    initFullScreen() {
        if (!isPlatformBrowser(this.platformId)) {
            this.supportFullScreen = false;
            return;
        }
        this.render.appendChild(document.body, this.dtFullScreenOverlay.nativeElement);
    }
    /**
     * When loading is finished mark loading icon is done so we can hide it. I am using little
     * delay to make the animation visible
     * @return {?}
     */
    loadingFinished() {
        if (isPresent(this.infiniteScroll)) {
            setTimeout(() => this.infiniteScroll.complete(), 200);
        }
    }
}
DTWrapper.decorators = [
    { type: Component, args: [{
                selector: 'aw-dt-wrapper',
                template: `<div [ngClass]="dt.styleClass" [class.dt-full-screen-mode]="isFullScreenMode"
     [style.width]="dt.width"
>
    <div class="dt-loading-overlay" *ngIf="dt.loading"></div>
    <div class="dt-loading-content" *ngIf="dt.loading">
        <i [class]="'sap-icon u-dt-spin-icon ' + dt.loadingIcon"></i>
    </div>

    <div class="dt-header" *ngIf="dt.showTableHeader">
        <ng-template *ngIf="dt.header; then appDefinedHeader else defaultHeader"></ng-template>
    </div>

    <!-- DT BODY with table headers and values -->
    <div class="dt-body-wrapper-view">
        <ng-template
            *ngIf="dt.hasFrozenColumns(); then dtBodyWithFrozenColumns else dtBodyNoFrozenColumns">
        </ng-template>
    </div>

    <!--<div class="dt-footer" *ngIf="footer">-->
    <!--&lt;!&ndash; footerArea&ndash;&gt;-->
    <!--<ng-content select="aw-dt-footer"></ng-content>-->
    <!--</div>-->
</div>

<!-- todo: dont activate this if we reached the end of list - -->
<aw-infinite-scroll #infiniteScroll *ngIf="isFullScreenMode"
                    [distance]="'10%'"
                    [fetchSize]="dt.state.limit"
                    (onLoad)="onLazyLoad($event)">
</aw-infinite-scroll>


<ng-template #appDefinedHeader>
    <ng-container *ngTemplateOutlet="heading;"></ng-container>
</ng-template>

<ng-template #defaultHeader>
    <div class="dt-global-filter">
        <span class="sap-icon icon-filter"></span>
    </div>

    <div class="dt-global-actions">
        <div class="dt-action-combo">
            <span *ngIf="supportFullScreen" class="sap-icon icon-resize"
                  (click)="toggleFullScreen($event)"></span>

            <aw-input-field *ngIf="dt.showGlobalSearch" styleClass="dt-table-search"
                            [(ngModel)]="dt.state.currentSearchQuery"
                            placeHolder="search"
                            icon="icon-search"
                            (ngModelChange)="searchTerms.next($event)">
            </aw-input-field>
            <span class="ariba-icon icon-more"></span>
        </div>
    </div>
</ng-template>

<!--
    Each section frozen/non-frozen is calculated inside table-wrapper in the ngAfterViewChecked, where we set
    proper width for each frame as well as left coordinates for the right one
-->
<ng-template #dtBodyNoFrozenColumns>
    <!--
        For non-frozen case we also need to set TRUE as the view is actually frozen and does not
        scroll.
        We use this frozenColumns flag inside DT to properly set column index on the header level
        columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))

        therefore we need to set true even in this case to return real columnIndex since we dont
        have the second table.
    -->
    <ng-container *ngTemplateOutlet="dtBody; context:{$implicit: dt.columns, frozenColumns: true }">
    </ng-container>
</ng-template>

<ng-template #dtBodyWithFrozenColumns>
    <ng-container
        *ngTemplateOutlet="dtBody; context:{$implicit: dt.frozenColumns, frozenColumns: true }">
    </ng-container>
    <ng-container
        *ngTemplateOutlet="dtBody; context:{$implicit: dt.columns, frozenColumns: false }">
    </ng-container>
</ng-template>


<ng-template #dtBody let-columns let-frozenColumns="frozenColumns">

    <div #dtContainer class="dt-body-wrapper"
         [style.width.px]="this.calculateFrozenWidth()"
         [class.dt-body-unfrozen]="dt.hasFrozenColumns() && !frozenColumns"
         [class.dt-body-frozen]="dt.hasFrozenColumns() && frozenColumns"
    >

        <table [ngClass]="dt.tableStyleClass"
               [style.width]="frozenColumns ? null : dt.scrollWidth"
               [class.dt-pivot-layout]="dt.pivotalLayout"
               [class.dt-plain-layout]="!dt.pivotalLayout && !dt.isOutline()">

            <!-- Render TH header rows-->
            <thead class="dt-thead">
            <ng-container *ngTemplateOutlet="headerRows; context:{$implicit: columns,frozenColumns:frozenColumns }">
            </ng-container>
            </thead>

            <!--
                Render data rows. For data rows we need to keep tbody tag inside DT table
                due to Outline
             -->
            <ng-container *ngTemplateOutlet="bodyRows; context:{$implicit: columns,  frozenColumns:frozenColumns }">
            </ng-container>
        </table>
    </div>
</ng-template>


<div #dtFullScreenOverlay class="dt-full-screen-overlay u-full-screen-element"></div>
`,
                styles: [`.dt-footer,.dt-header{text-align:center;padding:.5em .75em;box-sizing:border-box}.dt-footer{border-top:0}.dt-thead tr{border-width:0}.dt-body-wrapper-view{position:relative}.dt-body-wrapper{overflow:hidden;border:1px solid #d7d7d7}.dt-body-wrapper.dt-body-unfrozen{border-left-color:transparent;position:absolute;top:0;overflow-x:auto}.dt-loading-overlay{position:absolute;background-color:#9b9b9b;width:100%;height:100%;opacity:.1;z-index:1}.dt-loading-content{position:absolute;left:50%;top:25%;z-index:2}.dt-header{width:100%;display:flex;flex-flow:row nowrap;justify-content:space-between;color:#363636;border-bottom:1px solid #f1f1f1;margin-bottom:30px}.dt-header .dt-global-filter{flex:0 0;align-items:flex-start;font-size:18px}.dt-header .dt-global-actions{flex:0 0;align-items:flex-end}.dt-header .dt-action-combo{display:flex;flex-flow:row nowrap;color:#7d7d7d}.dt-header .dt-action-combo .ariba-icon,.dt-header .dt-action-combo .sap-icon{margin-left:15px;font-size:20px;align-self:center;cursor:pointer}.dt-header .dt-action-combo .dt-table-search{border-top-color:transparent;border-left-color:transparent;border-right-color:transparent}.dt-header .dt-action-combo .icon-resize{color:#4a4a4a;font-size:16px;line-height:18px;margin-right:15px}.u-dt-spin-icon{display:inline-block;-webkit-animation:2s linear infinite doSpin;animation:2s linear infinite doSpin}@-webkit-keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dt-full-screen-overlay{position:fixed;z-index:100;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transition:all .4s ease-in-out}.dt-full-screen{width:98vw;z-index:120;position:absolute;top:15px;pointer-events:all;transition:opacity .5s ease-in-out}.u-fs-element-out{display:none}`],
                encapsulation: ViewEncapsulation.None
            },] },
];
/** @nocollapse */
DTWrapper.ctorParameters = () => [
    { type: Environment },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DomUtilsService },
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
    { type: Datatable2Component, decorators: [{ type: Inject, args: [forwardRef(() => Datatable2Component),] }] }
];
DTWrapper.propDecorators = {
    expandColorFrom: [{ type: Input }],
    expandColorTo: [{ type: Input }],
    heading: [{ type: ContentChild, args: ['headingArea',] }],
    headerRows: [{ type: ContentChild, args: ['headerRows',] }],
    bodyRows: [{ type: ContentChild, args: ['bodyRows',] }],
    footer: [{ type: ContentChild, args: ['footerArea',] }],
    dtFullScreenOverlay: [{ type: ViewChild, args: ['dtFullScreenOverlay',] }],
    infiniteScroll: [{ type: ViewChild, args: ['infiniteScroll',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * This directive is responsible for checking and setting the widest content width onto
 * Column component as the widestCell property.
 *
 * We use this directive inside dt-column.component to store a current width for each td,th
 *
 *
 */
class SetCellMaxWidthDirective {
    /**
     * @param {?} element
     * @param {?} render
     * @param {?} td
     */
    constructor(element, render, td) {
        this.element = element;
        this.render = render;
        this.td = td;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // console.log('Cell Max Width: ' + this.dtMaxWidth, this.dtMaxWidth > 0);
        if (isPresent(this.dtMaxWidth) && this.dtMaxWidth > 0) {
            let /** @type {?} */ inlineData = this.element.nativeElement.querySelector('.dt-col-cell-data');
            if (isPresent(inlineData)) {
                inlineData.style.whiteSpace = 'nowrap';
                inlineData.style.display = 'inline-block';
                let /** @type {?} */ cellWidth = inlineData.offsetWidth; // td
                inlineData.style.whiteSpace = 'normal';
                inlineData.style.display = 'inline';
                if (!this.isInThresHold(cellWidth)) {
                    return;
                }
                cellWidth += this.tdPadding();
                if (cellWidth > this.td.widthPx) {
                    if (cellWidth < this.dtMaxWidth) {
                        this.td.widestCell = cellWidth > this.td.widestCell ? cellWidth :
                            this.td.widestCell;
                    }
                    else if (cellWidth >= this.dtMaxWidth) {
                        this.td.widestCell = (this.dtMaxWidth > this.td.widestCell)
                            ? this.dtMaxWidth : this.td.widestCell;
                    }
                }
            }
        }
    }
    /**
     *
     * Is the new width the same as the one already set on the column? If yes then probably
     * new content does not differ that much. We still keep certain threshold as the new content
     * width might differ 1 or 2 pixes depending how set the css.
     *
     * To make sure we resize column only if necessary because it could be original size
     * is 400px but the new one is 401px since somewhere add some extra border we have this
     * safe threshold
     *
     * @param {?} newWidth
     * @return {?}
     */
    isInThresHold(newWidth) {
        if (this.td.widestCell > 0) {
            return Math.abs(this.td.widestCell - newWidth) > 3 && newWidth > this.td.widestCell;
        }
        return true;
    }
    /**
     * @return {?}
     */
    tdPadding() {
        let /** @type {?} */ computedStyle = getComputedStyle(this.element.nativeElement);
        let /** @type {?} */ cell = parseInt(computedStyle.paddingLeft) || 0;
        cell += parseInt(computedStyle.paddingRight) || 0;
        cell += parseInt(computedStyle.borderRightWidth) || 0;
        cell += parseInt(computedStyle.borderLeftWidth) || 0;
        // plus give it some little space around the text so it nots px to px inner width of the td
        // cuz it could wrap
        cell += 5;
        return cell;
    }
}
SetCellMaxWidthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dtMaxWidth]'
            },] },
];
/** @nocollapse */
SetCellMaxWidthDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: DTColumn2Component }
];
SetCellMaxWidthDirective.propDecorators = {
    dtMaxWidth: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Directive used inside DT in order to support table rows re-ordering. This manages all the
 * D&D necessary logic for this functionality.
 *
 * [dtDraggableRow] is used inside the `rowTemplate` like this:
 *
 *
 * ```html
 *
 * <ng-template #rowTemplate let-rowData let-even='event" let-odd="odd" let-rowIndex="rowIndex"
 *              let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">
 *
 *     <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
 *          class="dt-body-row"
 *
 *
 *
 * ```
 *
 * which enabled or disables based on the used DT binding [dndRowEnabled]. By default its disabled.
 *
 *
 *
 */
class DTDraggableRowDirective {
    /**
     * @param {?} element
     * @param {?} dt
     * @param {?} domUtils
     * @param {?} ngZone
     */
    constructor(element, dt, domUtils, ngZone) {
        this.element = element;
        this.dt = dt;
        this.domUtils = domUtils;
        this.ngZone = ngZone;
        /**
         *
         * Tells the directive if we enable middle row zone to create an effect that we are dropping
         * into the row. Used for outline DT mainly.
         *
         */
        this.dropIntoEnabled = false;
        /**
         * Current TR index number
         *
         */
        this.dndRowIndex = 0;
        /**
         * Holds information about our dragging direction UP and DOWN in order to assign correct style
         * that highlights the row at the top or bottom
         *
         */
        this.dragDir = DragDirection.None;
        /**
         * Indicates that we dragged our row and stopped in the middle of the other row
         *
         */
        this.inMiddle = false;
        /**
         *
         * Current drag Y coordinates which is used together with the dragDir when assinging dragging
         * direction.
         *
         */
        this.dragY = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.dt.dndRowEnabled) {
            this.setupEventListeners();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.dt.dndRowEnabled) {
            this.releaseEventListeners();
        }
    }
    /**
     * Setups listeners and returns handle to them so we can later on unsubscribe.
     * @return {?}
     */
    setupEventListeners() {
        this.ngZone.runOutsideAngular(() => {
            this.eventHandlers = {};
            this.eventHandlers['mousedown'] = this.onMouseDownEvent.bind(this);
            this.element.nativeElement.addEventListener('mousedown', this.eventHandlers['mousedown']);
            this.eventHandlers['dragstart'] = this.onDragStartEvent.bind(this);
            this.element.nativeElement.addEventListener('dragstart', this.eventHandlers['dragstart']);
            this.eventHandlers['dragover'] = this.onDragOverEvent.bind(this);
            this.element.nativeElement.addEventListener('dragover', this.eventHandlers['dragover']);
            this.eventHandlers['dragleave'] = this.onDragLeaveEvent.bind(this);
            this.element.nativeElement.addEventListener('dragleave', this.eventHandlers['dragleave']);
            this.eventHandlers['drop'] = this.onDropEvent.bind(this);
            this.element.nativeElement.addEventListener('drop', this.eventHandlers['drop']);
            this.eventHandlers['dragend'] = this.onDragEndEvent.bind(this);
            this.element.nativeElement.addEventListener('dragend', this.eventHandlers['dragend']);
        });
    }
    /**
     * Removes all the created listeners inside destroy() callback
     * @return {?}
     */
    releaseEventListeners() {
        DragEvents.forEach((name) => {
            document.removeEventListener('name', this.eventHandlers[name]);
        });
    }
    /**
     *
     * This is first event where we:
     *
     *  - Mark element draggable to enable D&D
     *  - Set click position relative to the middle of the current row
     *      This is mainly needed when we are trying to calculate something for
     *      dropInto row (outline)
     *
     * event.target usually contains reference to TD element
     * @param {?} event
     * @return {?}
     */
    onMouseDownEvent(event) {
        if (event.altKey && this.domUtils.hasParent(event.target, '.dt-row-draggable')) {
            this.element.nativeElement.draggable = true;
            let /** @type {?} */ elToBeDragged = this.domUtils.elementDimensions(event.target);
            this.dt.env.setValue('ddClickDeviance', (elToBeDragged.height / 2) - event.offsetY);
        }
        else {
            this.element.nativeElement.draggable = false;
        }
    }
    /**
     * This is second triggered event when the actual dragging starts. Here we need to disable
     * dragged row and save information that are common to a table.
     *
     * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
     * if we would go without it then D&D framework would create a copy of row in disabled state.
     * Now we grab a row with active state and after a 200ms delay we disable the original row.
     *
     * @param {?} event
     * @return {?}
     */
    onDragStartEvent(event) {
        setTimeout(() => {
            if (isPresent(event.target.classList)) {
                event.target.classList.add('dt-row-dragging');
            }
        }, 200);
        this.dt.env.setValue('isDragging', true);
        this.dt.env.setValue('dndId', this.dndRowIndex);
        event.dataTransfer.setData('text', this.dndRowIndex);
    }
    /**
     *
     * This events happens anytime as we drag over rows. This event triggered after certain
     * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
     *
     * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
     * show a user where we are.
     *
     * Once we know the direction and the drop target is valid we mark the row with correct class
     * that does the trick
     * @param {?} event
     * @return {?}
     */
    onDragOverEvent(event) {
        event.dataTransfer.dropEffect = 'move';
        if (this.dragY < event.pageY) {
            this.dragDir = DragDirection.Down;
        }
        else if (this.dragY > event.pageY) {
            this.dragDir = DragDirection.Up;
        }
        // dont set again unless its different
        if (this.dragY !== event.pageY) {
            this.dragY = event.pageY;
        }
        if (this.isValidDropTarget(event)) {
            // todo test this preventDefault() so it does not create some sideeffect
            event.preventDefault();
            this.markRowWithClass(event, this.domUtils.closest(event.target, 'tr'));
        }
    }
    /**
     * This is finishing event just before D&D is done. It takes current information and
     * broadcast them to the DT so DT can do necessary row reordering
     *
     *
     * @param {?} event
     * @return {?}
     */
    onDropEvent(event) {
        this.clearClasses(event.target.parentElement);
        // event.preventDefault();
        let /** @type {?} */ origIndx = this.dt.env.getValue('dndId');
        let /** @type {?} */ dropPos = this.inMiddle ? DropPosition.Into : (this.dragDir === DragDirection.Up ? DropPosition.Before : DropPosition.After);
        this.dt.onDnDRowDrop(origIndx, this.dndRowIndex, dropPos);
        this.inMiddle = false;
        this.dragY = 0;
    }
    /**
     * Every time we drag over the element we apply some classes to the it. this method does the
     * opposite which is to remove everything so we are ready for the next row
     *
     *
     * @param {?} event
     * @return {?}
     */
    onDragLeaveEvent(event) {
        let /** @type {?} */ tr = this.domUtils.closest(event.target, 'tr');
        this.clearClasses(tr);
        this.dt.env.deleteValue('dndOnHoldIndex');
    }
    /**
     *
     * This is last event within D&D flow. Mainly used to clean up all the resource that has not
     * been clean up already inside onDropEvent.
     *
     * @param {?} event
     * @return {?}
     */
    onDragEndEvent(event) {
        if (isPresent(event.target.classList)) {
            event.target.classList.remove('dt-row-dragging');
        }
        this.clearClasses(event.target);
        this.element.nativeElement.draggable = false;
        this.dt.env.deleteValue('isDragging');
        this.dt.env.deleteValue('dndId');
        this.dt.env.deleteValue('ddClickDeviance');
    }
    /**
     * Assign CSS classes to the row to create an highlighting effect to capture current position
     * for the user.
     *
     * Based on the Drag direction we either apply
     * css class that creates a line on top or bottom.  Only for the dropInto functionality we
     * need to calculate some more to identify if we are really in the middle of the row.
     *
     * DropInto:
     * ---------
     *
     * Initially we captured a position (in mousedown) the distance to the middle of the row and
     * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
     * perfect.
     *
     * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
     *      Read center of current row
     *
     * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
     *      Read mouse coordinates relative to current row/td and add to it our deviation.
     *
     *
     * @param {?} event
     * @param {?} activeRow
     * @return {?}
     */
    markRowWithClass(event, activeRow) {
        this.clearClasses(activeRow);
        // Check if drag item is in the middle of other row
        let /** @type {?} */ currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
        let /** @type {?} */ draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
        if (this.dropIntoEnabled) {
            this.inMiddle = Math.abs(currentTrCenter - draggedTrCenter) < 2;
        }
        if (this.inMiddle) {
            activeRow.classList.add(DragDirection.Middle);
        }
        else {
            activeRow.classList.add(this.dragDir);
        }
    }
    /**
     *
     * Drop target must be only another TR and it cannot be the element itself the one we are
     * dragging and it does not make sense to allow to drop to the same position we started from
     *
     * @param {?} event
     * @return {?}
     */
    isValidDropTarget(event) {
        let /** @type {?} */ origInx = this.dt.env.getValue('dndId');
        let /** @type {?} */ siblingRow = this.dndRowIndex - origInx;
        return event.target.parentElement.tagName === 'TR' && this.dndRowIndex !== origInx &&
            !(siblingRow === 1 && this.dragDir === DragDirection.Up) &&
            !(siblingRow === -1 && this.dragDir === DragDirection.Down);
    }
    /**
     *  private
     *
     * @param {?} tr
     * @return {?}
     */
    clearClasses(tr) {
        tr.classList.remove('dt-drag-row-top');
        tr.classList.remove('dt-drag-row-bottom');
        tr.classList.remove('dt-drag-row-both');
    }
    /**
     *  private
     *
     * @return {?}
     */
    dragDirToString() {
        switch (this.dragDir) {
            case DragDirection.Up:
                return 'Up';
            case DragDirection.Down:
                return 'Down';
            default:
                return 'Not Sure';
        }
    }
}
DTDraggableRowDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dtDraggableRow]'
            },] },
];
/** @nocollapse */
DTDraggableRowDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Datatable2Component, decorators: [{ type: Inject, args: [forwardRef(() => Datatable2Component),] }] },
    { type: DomUtilsService },
    { type: NgZone }
];
DTDraggableRowDirective.propDecorators = {
    dropIntoEnabled: [{ type: Input }],
    dndRowIndex: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWDatatable2Module {
}
AWDatatable2Module.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    Datatable2Component,
                    DTWrapper,
                    DTColumn2Component,
                    DTHeaderComponent2,
                    DTDetailRowComponent,
                    DTDetailRowExpanderComponent,
                    DTMultiSelectColumnComponent,
                    DTSingleSelectColumnComponent,
                    DTDraggableRowDirective,
                    SetCellMaxWidthDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    AWCoreComponentModule,
                    AWCheckBoxModule,
                    AWOutlineForModule,
                    AWRadioButtonModule,
                    AWInputFieldModule
                ],
                entryComponents: [
                    DTDetailRowExpanderComponent,
                    DTMultiSelectColumnComponent,
                    DTSingleSelectColumnComponent
                ],
                exports: [
                    Datatable2Component,
                    DTColumn2Component,
                    AWOutlineForModule,
                    DTHeaderComponent2,
                    DTDetailRowComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An confirmation header area.
 *
 * See {\@link ConfirmationComponent} for more explanation.
 */
class ConfirmationHeaderComponent {
}
ConfirmationHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-confirmation-header',
                template: '<ng-content></ng-content>'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An confirmation header area.
 *
 * See {\@link ConfirmationComponent} for more explanation.
 */
class ConfirmationFooterComponent {
}
ConfirmationFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-confirmation-footer',
                template: '<ng-content></ng-content>'
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Confirmation Component is a specific version of the dialog where it supports confirm and cancel
 * functionality. It behaves like a dialog, is modal, and not closable by default.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<ConfirmationComponent>), service.close()
 *
 * Usage:
 *    1.  Using ModalService directly to display a modal popup. This usage is a quick way to show
 *        a confirmation to the user.
 *
 *          this.modalService.open<ConfirmationComponent>(ConfirmationComponent, {
 *                        title: 'Confirmation',
 *                        body: ` Are you sure ? `,
 *                        width: 300,
 *                        onConfirm: () => {
 *                              this.confirmAction();
 *                        },
 *                        onCancel: () => {
 *                              this.cancelAction();
 *                        }
 *           });
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                              <aw-confirmation [title]="'Confirmation'"
 *                                      [(visible)]="display"
 *                                     (onConfirm)="confirmAction()"
 *                                    (onCancel)="cancelAction()">
 *                                       <i class="sap-icon icon-alert"></i>
 *                                       Are you sure you want to delete your hard drive?
 *                            </aw-confirmation>
 *
 *                                   <aw-button [size]="'small'" (click)="open()">
 *                                       Open Confirmation
 *                                   </aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     display: boolean = false;
 *
 *                     confirmAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     open() {
 *                        this.display = true;
 *                     }
 *
 *                     confirmAction()  {
 *                        this.confirmAction = "confirmed";
 *                      }
 *
 *                      close() {
 *                         this.display = false;
 *                      }
 *
 *                      cancelAction() {
 *                          this.confirmAction = "canceled";
 *                      }
 *
 *       }
 *
 *
 */
class ConfirmationComponent extends ModalContainer {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * support two way data binding on visible property.
         */
        this.visibleChange = new EventEmitter();
        /**
         * Whether there's an x at the top right that makes the dialog closable.
         */
        this.closable = false;
        /**
         * Event fired when dialog is closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event fired when the dialog is opened.
         */
        this.onOpen = new EventEmitter();
        /**
         * Fired when user clicked on confirm button.
         */
        this.onConfirm = new EventEmitter();
        /**
         * Fired when user clicked on cancel button.
         */
        this.onCancel = new EventEmitter();
        this.width = 400;
        this.height = 'auto';
        // Todo: internationalize.
        this.confirmActionLabel = 'Confirm';
        this.cancelActionLabel = 'Cancel';
    }
    /**
     * open confirmation.
     * @return {?}
     */
    open() {
        this.visible = true;
        this.onOpen.emit();
        this.visibleChange.emit(true);
    }
    /**
     * close confirmation.
     * @return {?}
     */
    close() {
        this.visible = false;
        this.onClose.emit();
        // Important to make sure change is set on parent binding.
        // Otherwise, the variable and dialog open/close state can be out
        // of sync and we wouldn't trigger change detection.
        this.visibleChange.emit(false);
    }
    /**
     * Does the confirmation have header content?
     * @return {?}
     */
    hasHeader() {
        return isPresent(this.header);
    }
    /**
     * Does the confirmation have footer content?
     * @return {?}
     */
    hasFooter() {
        return isPresent(this.footer);
    }
    /**
     * Confirm action.
     * @return {?}
     */
    confirm() {
        this.close();
        this.onConfirm.emit();
    }
    /**
     * Cancel action.
     * @return {?}
     */
    cancel() {
        this.close();
        this.onCancel.emit();
    }
}
ConfirmationComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-confirmation',
                template: `<aw-dialog [title]="title" [(visible)]="visible"
           [modal]="true" [closable]="closable" [width]="width" [height]="height"
           [styleClass]="styleClass" [appendTo]="appendTo" (onOpen)="open()" (onClose)="close()">

    <aw-dialog-header *ngIf="hasHeader()">
        <ng-content select="aw-confirmation-header"></ng-content>
    </aw-dialog-header>

    {{body}}
    <ng-content></ng-content>


    <aw-dialog-footer *ngIf="hasFooter(); else defaultFooter">
        <ng-content select="aw-confirmation-footer"></ng-content>
    </aw-dialog-footer>

    <ng-template #defaultFooter>
        <aw-dialog-footer>
            <aw-button name="confirm" [style]="'primary'" (action)="confirm()">
                {{confirmActionLabel}}
            </aw-button>

            <aw-button name="cancel" [style]="'secondary'" (action)="cancel()">
                {{cancelActionLabel}}
            </aw-button>

        </aw-dialog-footer>
    </ng-template>

</aw-dialog>
`,
                styles: [`.confirmation-footer-separator{border-top:1px solid #d7d7d7;height:14px}`]
            },] },
];
/** @nocollapse */
ConfirmationComponent.ctorParameters = () => [
    { type: Environment }
];
ConfirmationComponent.propDecorators = {
    title: [{ type: Input }],
    body: [{ type: Input }],
    confirmActionLabel: [{ type: Input }],
    cancelActionLabel: [{ type: Input }],
    visibleChange: [{ type: Output }],
    closable: [{ type: Input }],
    appendTo: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    onConfirm: [{ type: Output }],
    onCancel: [{ type: Output }],
    header: [{ type: ContentChild, args: [ConfirmationHeaderComponent,] }],
    footer: [{ type: ContentChild, args: [ConfirmationFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWConfirmationModule {
}
AWConfirmationModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ConfirmationComponent,
                    ConfirmationHeaderComponent,
                    ConfirmationFooterComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                    AWDialogModule,
                    AWButtonModule
                ],
                entryComponents: [
                    ModalComponent,
                    ConfirmationComponent,
                    ConfirmationHeaderComponent,
                    ConfirmationFooterComponent
                ],
                exports: [
                    ConfirmationComponent,
                    ConfirmationHeaderComponent,
                    ConfirmationFooterComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Container panel providing scrolling functionality for its children. You can configure this
 * container to let it to scroll its content either horizontally, vertically or let the content
 * wrap.
 *
 *
 * Usage is pretty simple:
 *
 *  ### Example using horizontal scroll (default behavior):
 *
 *  ```
 *            <aw-scrollable>
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *
 *  ```
 *
 *  ### Example using vertical scroll:
 *
 *  ```
 *            <aw-scrollable [direction]="'vertical'" [height]="'40vh'">
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *
 * ```
 *
 *  ### Example scrolling is disabled and content wraps and centers:
 *
 *  ```
 *            <aw-scrollable [direction]="'none'" [alignment]="'center'">
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *  ```
 *
 * ### Height property:
 *
 * When using "horizontal scrolling" it set "flexbox-direction" to "row" where height
 * is set automatically based on its content. The height should be always 100% when using
 * this in parent container.
 *
 * If "vertical scrolling" is used you need to make sure that:
 *   - your parent container sets the boundaries with correctly set width and height
 *   otherwise it will use 100% of the viewport
 *   - if used as standalone you need to limit the height otherwise it will expand to 100% of
 *   the document
 *
 *
 *
 *
 */
class ScrollableContainerComponent extends BaseComponent {
    /**
     * @param {?} env
     * @param {?} elementRef
     */
    constructor(env, elementRef) {
        super(env);
        this.env = env;
        this.elementRef = elementRef;
        /**
         * Defines scrolling direction of the container meaning tells which overflow axies will be
         * disabled or enabled.
         *
         * Default value is "horizontal": Here we lock overflow-y and overflow-x set to auto.
         *
         * When scrolling direction is "vertical" please make sure you maintain correct height and
         * width.
         *
         */
        this.direction = 'horizontal';
        /**
         * Defines how flexbox container items should be aligned. Default behavior is LEFT
         *
         */
        this.alignment = 'left';
        this.height = '100%';
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initDefault();
    }
    /**
     * Make sure we re-initialize default when Input Bindings changes
     *
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.initDefault();
    }
    /**
     * Initialize default values and Calculates layout and alignment class. The reason for using
     * these utility classes is that we can change the behavior anytime as compared to using
     * directly [style.xxx] bindings.
     *
     * ### Direction flow class:
     *  - u-scrollable-f<direction>
     *
     * ### Alignment class:
     *  - u-scrollable-a<alignment>
     *
     * @return {?}
     */
    initDefault() {
        this.layoutClass = 'u-scrollable-fh';
        if (this.direction === 'vertical') {
            this.layoutClass = 'u-scrollable-fv';
        }
        if (this.direction === 'vertical-row') {
            this.layoutClass = 'u-scrollable-fv-row';
        }
        else if (this.direction === 'both') {
            this.layoutClass = 'u-scrollable-fb';
        }
        else if (this.direction === 'none') {
            this.layoutClass = 'u-scrollable-fn';
        }
        this.layoutClass += ' u-scrollable-a' + this.alignment.substring(0, 1);
        if (isPresent(this.styleClass)) {
            this.layoutClass += ` ${this.styleClass}`;
        }
        // make sure we default width and height to some value in case somebody passes null
        if (isBlank(this.width)) {
            this.width = '100%';
        }
        if (isBlank(this.height)) {
            this.height = '100%';
        }
    }
    /**
     * Tells if the horizontal scrollbar is visible
     *
     * @return {?}
     */
    hasHorizontalScroll() {
        let /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
        return scrollContainer.scrollWidth > scrollContainer.clientWidth;
    }
    /**
     * Tells if the vertical scrollbar is visible
     *
     * @return {?}
     */
    hasVerticalScroll() {
        let /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
        return scrollContainer.scrollHeight > scrollContainer.clientHeight;
    }
}
ScrollableContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-scrollable',
                template: `<div class="w-scrollable" [ngClass]="layoutClass" [style.width]="width"
     [style.height]="height">
    <ng-content></ng-content>
</div>
`,
                styles: [`.w-scrollable{display:flex;display:-webkit-flex;backface-visibility:hidden;-webkit-backface-visibility:hidden;will-change:overflow}.w-scrollable /deep/>*{flex:0 0 auto;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;margin:10px}.u-scrollable-fh{flex-flow:row nowrap;overflow-x:auto;overflow-y:hidden}.u-scrollable-fv{flex-flow:column nowrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fb{flex-flow:row nowrap;overflow-x:auto;overflow-y:auto}.u-scrollable-fv-row{flex-flow:row wrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fn{flex-flow:row wrap}.u-scrollable-al{justify-content:flex-start;-webkit-justify-content:flex-start}.u-scrollable-ar{justify-content:flex-end;-webkit-justify-content:flex-end}.u-scrollable-ac{justify-content:center;-webkit-justify-content:center}.u-scrollable-aj,.u-scrollable-aj-around{justify-content:space-between;-webkit-justify-content:space-between}`]
            },] },
];
/** @nocollapse */
ScrollableContainerComponent.ctorParameters = () => [
    { type: Environment },
    { type: ElementRef }
];
ScrollableContainerComponent.propDecorators = {
    direction: [{ type: Input }],
    alignment: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWScrollableContainerModule {
}
AWScrollableContainerModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ScrollableContainerComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    ScrollableContainerComponent
                ],
                exports: [
                    ScrollableContainerComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ LB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => ListComponent),
    multi: true
};
/**
 *
 * The List component represent a structure which contains a list of selectable items. Items
 * selection can be configured in single-selection, multi-selection or multi-selection with visible
 * checkboxes mode.
 * In addition it can display data inside 3 zones LEFT, MIDDLE and RIGHT in order to provide
 * easy way for application developer to layout its own custom content or even change out of box
 * behavior.
 *
 *
 *  ### Examples
 *
 *  1. Render simple single selection list
 *
 *  ```html
 *
 *      <aw-list [list]="list"></aw-list>
 *
 *  ```
 *  2. Render list - multi selection with custom RIGHT content to show a CheckMark when item
 *  is selected
 *
 *  ```html
 *
 *   <aw-list #awlist [list]="list"
 *                       height="150px"
 *                       width="250px"
 *                       [selectionMode]="'multi'">
 *
 *                  <ng-template #right let-item>
 *
 *                      <span class="sap-icon"
 *                            [ngClass]="{'icon-accept': awlist.pListBox.isSelected(item),
 *                            '': !awlist.pListBox.isSelected(item)}">
 *
 *                      </span>
 *                  </ng-template>
 *   </aw-list>
 *
 *  ```
 *
 * 3. Render list - multi selection with visible checkboxes and custom MIDDLE content to change
 *  the way item name is rendered
 *
 *
 *
 *  ```html
 *
 *   <aw-list [list]="list" height="180px"
 *                       width="200px"
 *                       [selection]="selection"
 *                       [selectionMode]="'multiWithCheckbox'">
 *
 *                  <ng-template #middle let-item>
 *                      XX-{{item.value}}
 *                  </ng-template>
 *    </aw-list>
 *
 *  ```
 *
 *
 *
 */
class ListComponent extends BaseFormComponent {
    /**
     * @param {?} env
     * @param {?} parentContainer
     */
    constructor(env, parentContainer) {
        super(env, parentContainer);
        this.env = env;
        this.parentContainer = parentContainer;
        /**
         * Component recognizes 3 modes: single, multi, multi with visible checkboxes
         */
        this.selectionMode = 'single';
        /**
         * Don't render Listbox border. Used for embedding this inside other components
         *
         */
        this.borderless = false;
        /**
         * Triggered when we double click on the list Item
         *
         */
        this.action = new EventEmitter();
        /**
         * Event fired when user select a item
         *
         */
        this.onSelection = new EventEmitter();
        this.listStyle = {};
        this.isMultiple = false;
        this.showCheckbox = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.isMultiple = this.selectionMode === 'multi' ||
            this.selectionMode === 'multiWithCheckbox';
        this.showCheckbox = this.selectionMode === 'multiWithCheckbox';
        // cannot have both either we use field to get display value or valueTransformer
        if (isPresent(this.field) && isPresent(this.valueTransformer)) {
            throw new Error('You can have either [field] or [valueTransformer].');
        }
        if (isPresent(this.list)) {
            this.initList();
        }
        else {
            throw new Error('Missing [list] binding.');
        }
        // Also add overflowY to make sure it can scroll and does not expand based on its content
        if (isPresent(this.height)) {
            this.listStyle['height'] = this.height;
            this.listStyle['overflow-y'] = 'auto';
        }
        if (isPresent(this.width)) {
            this.listStyle['width'] = this.width;
        }
        if (this.borderless) {
            this.listStyle['border-color'] = 'transparent';
        }
        if (this.isStandalone) {
            super.registerFormControl(this.selection);
            if (isBlank(this.selection)) {
                this.selection = this.formControl.value;
            }
        }
    }
    /**
     *
     * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
     * checkbox as well as item text.
     *
     *
     * @param {?} event
     * @param {?} item
     * @param {?} checkbox
     * @return {?}
     */
    itemClicked(event, item, checkbox) {
        if (isPresent(checkbox)) {
            this.pListBox.onCheckboxClick(event, item);
        }
        else if (isPresent(this.pListBox)) {
            this.pListBox.onOptionClick(event, item);
            event.stopPropagation();
            event.preventDefault();
        }
    }
    /**
     * Internal
     *
     * @return {?}
     */
    hasRightTempl() {
        return isPresent(this.rZoneTempl);
    }
    /**
     * @return {?}
     */
    hasLeftTempl() {
        return isPresent(this.lZoneTempl);
    }
    /**
     * @return {?}
     */
    hasMiddleTempl() {
        return isPresent(this.mZoneTempl);
    }
    /**
     *
     * Triggered by p-listbox component when item is selected. When state is managed internally
     * we also update FormControl model.
     *
     * @param {?} event
     * @return {?}
     */
    onItemSelected(event) {
        if (isBlank(event.value)) {
            return;
        }
        this.onSelection.emit(event.value);
        if (this.isStandalone) {
            this.formControl.setValue(event.value, { emitEvent: true });
        }
        this.onModelChanged(event.value);
    }
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!equals(value, this.selection)) {
            this.selection = value;
            if (this.isStandalone) {
                this.formControl.setValue(value);
            }
        }
    }
    /**
     * Translates external form of the list into PrimeNG expected format where it uses
     * SelectionItem interface
     * @return {?}
     */
    initList() {
        if (isPresent(this.list)) {
            this.internalList = this.list.map((item) => {
                return { label: this.displayValue(item), value: item };
            });
        }
    }
    /**
     *  Generates label value for the list box.
     *
     * @param {?} item
     * @return {?}
     */
    displayValue(item) {
        if (isBlank(item)) {
            return '';
        }
        let /** @type {?} */ val = item.toString();
        if (isPresent(this.field)) {
            val = item[this.field];
        }
        else if (isPresent(this.valueTransformer)) {
            val = this.valueTransformer(item);
        }
        return val;
    }
}
ListComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-list',
                template: `<p-listbox #listbox [options]="internalList" [multiple]="isMultiple" [checkbox]="showCheckbox"
           [(ngModel)]="selection" [disabled]="disabled" [style]="listStyle" [showToggleAll]="false"
           (onChange)="onItemSelected($event)" (onDblClick)="action.emit($event.value)"
           [styleClass]="styleClass">


    <ng-template let-item pTemplate="item">
        <div class="w-li-wrapper">
            <div class="w-li-left">
                <ng-template *ngIf="hasLeftTempl(); else defaultLeft"
                             [ngTemplateOutlet]="lZoneTempl"
                             [ngTemplateOutletContext]="{$implicit: item}"></ng-template>


                <ng-template #defaultLeft>
                    <aw-checkbox #check *ngIf="isMultiple && showCheckbox"
                                 [isStandalone]="false"
                                 [value]="listbox.isSelected(item)"
                                 type="action"
                                 (action)="itemClicked($event, item, check)">
                    </aw-checkbox>
                </ng-template>
            </div>

            <div class="w-li-middle" (click)="itemClicked($event, item, null)">

                <ng-template *ngIf="hasMiddleTempl(); else defaultMiddle"
                             [ngTemplateOutlet]="mZoneTempl"
                             [ngTemplateOutletContext]="{$implicit: item}"></ng-template>

                <ng-template #defaultMiddle>
                    {{item.label}}
                </ng-template>

            </div>

            <div class="w-li-right" *ngIf="hasRightTempl()">
                <ng-template [ngTemplateOutlet]="rZoneTempl"
                             [ngTemplateOutletContext]="{$implicit: item}">
                </ng-template>

            </div>
        </div>
    </ng-template>
</p-listbox>
`,
                styles: [`::ng-deep .ui-listbox-item>.ui-chkbox{display:none}::ng-deep .ui-listbox-item .ui-chkbox{margin-right:1em}.w-li-wrapper{display:flex;align-items:flex-start}.w-li-wrapper .w-li-left,.w-li-wrapper .w-li-right{flex:0 1 auto}.w-li-wrapper .w-li-middle{flex:1 1 auto}`],
                providers: [
                    LB_CONTROL_VALUE_ACCESSOR,
                    { provide: BaseFormComponent, useExisting: forwardRef(() => ListComponent) }
                ]
            },] },
];
/** @nocollapse */
ListComponent.ctorParameters = () => [
    { type: Environment },
    { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(() => BaseFormComponent),] }] }
];
ListComponent.propDecorators = {
    list: [{ type: Input }],
    selection: [{ type: Input }],
    selectionMode: [{ type: Input }],
    valueTransformer: [{ type: Input }],
    field: [{ type: Input }],
    borderless: [{ type: Input }],
    action: [{ type: Output }],
    onSelection: [{ type: Output }],
    pListBox: [{ type: ViewChild, args: ['listbox',] }],
    lZoneTempl: [{ type: ContentChild, args: ['left',] }],
    mZoneTempl: [{ type: ContentChild, args: ['middle',] }],
    rZoneTempl: [{ type: ContentChild, args: ['right',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWListModule {
}
AWListModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ListComponent
                ],
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    FormsModule,
                    ListboxModule,
                    AWCheckBoxModule
                ],
                entryComponents: [
                    ListComponent
                ],
                exports: [
                    ListComponent,
                    ReactiveFormsModule,
                    FormsModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class WizardProgressComponent {
    constructor() {
        this.currentStep = 0;
        this.stepChanged = new EventEmitter();
        this.totalSteps = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.steps) {
            let /** @type {?} */ currentIndex = this.steps.indexOf(this.steps.filter(step => step.current)[0]);
            this.totalSteps = this.steps.length;
            this.setCurrentStep(~currentIndex ? currentIndex : 0);
        }
    }
    /**
     * @param {?=} index
     * @return {?}
     */
    setCurrentStep(index = 0) {
        this.steps[index].current = true;
        this.currentStep = index;
        this.stepChanged.emit({ current: this.currentStep });
    }
    /**
     * @param {?} index
     * @return {?}
     */
    goToStep(index) {
        if (!this.steps[index].complete) {
            return;
        }
        let /** @type {?} */ currentIndex = this.steps.indexOf(this.steps.filter(step => step.current)[0]);
        this.steps[currentIndex].current = false;
        this.setCurrentStep(index);
    }
}
WizardProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-wizard-progress',
                template: `<div class="step-indicator">{{currentStep + 1}}/{{totalSteps}}</div>
<div class="aw-step-progress">
    <div class="aw-step-progress__item" *ngFor="let step of steps; let i = index;"
         [ngClass]="{ 'aw-step-progress__item--is-active': step.current === true }"
         (click)="goToStep(i);">
    </div>
</div>
`,
                styles: [`:host{display:block}.step-indicator{width:100%;text-align:center;font-size:14px;font-weight:600;padding-bottom:.3rem}.aw-step-progress{display:flex;flex-direction:row;padding:.2rem;justify-content:center}.aw-step-progress__item{cursor:pointer;list-style:none;width:1.2rem;margin:0 .2rem;border-radius:.3rem;height:.4rem;background-color:#eaeaea}.aw-step-progress__item:last-child{margin-right:0}.aw-step-progress__item:first-child{margin-left:0}.aw-step-progress__item--is-active{background-color:#09a7af}`]
            },] },
];
/** @nocollapse */
WizardProgressComponent.ctorParameters = () => [];
WizardProgressComponent.propDecorators = {
    steps: [{ type: Input }],
    currentStep: [{ type: Input }],
    stepChanged: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class WizardProgressModule {
}
WizardProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    WizardProgressComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    WizardProgressComponent
                ],
                exports: [
                    WizardProgressComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Renders a Toggle Switch
 *
 * ### Example
 *
 * ```typescript
 *
 * \@Component({
 *          selector: 'myToggleSection' ,
 *          template: '<aw-toggle [model]="inputValue" [labelText]="labelText" >
 *              </aw-toggle>'
 *      })
 *      export class MyNoteComponent
 *      {
 *          inputValue: boolean = false;
 *          labelText: string = 'my label';
 *      }
 *
 * ```
 */
class ToggleSwitchComponent extends BaseComponent {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * toggle model
         */
        this.model = false;
    }
    /**
     * click handler for toggle
     * @return {?}
     */
    changeHandler() {
        this.model = !this.model;
    }
}
ToggleSwitchComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-toggle',
                template: `<div class="w-toggle">
    <label class="w-toggle__label" *ngIf="labelText">
        {{ labelText }}
    </label>
    <div class="slider" (click)="changeHandler()">
        <div class="slider__button" [ngClass]="{ 'slider__button--is-active': model === true }"></div>
    </div>
</div>
`,
                styles: [`:host{display:block}.w-toggle input{display:none}.w-toggle__label{color:#999;margin-right:.2rem}.w-toggle .slider{position:relative;height:.6rem;width:1.5rem;background-color:#d8d8d8;border-radius:.9rem;display:inline-block;border-top:1px solid #7e7e7e;border-left:1px solid #b5b5b5;border-right:1px solid #b5b5b5}.w-toggle .slider__button{left:-.1rem;transition:left .1s ease-out;cursor:pointer;position:absolute;height:1rem;width:1rem;border-radius:50%;background-color:#eaeaea;top:-.2rem}.w-toggle .slider__button--is-active{left:calc(100% - .8rem);background-color:#09a7af}`]
            },] },
];
/** @nocollapse */
ToggleSwitchComponent.ctorParameters = () => [
    { type: Environment }
];
ToggleSwitchComponent.propDecorators = {
    model: [{ type: Input }],
    labelText: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ToggleSwitchModule {
}
ToggleSwitchModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ToggleSwitchComponent
                ],
                imports: [
                    CommonModule
                ],
                entryComponents: [
                    ToggleSwitchComponent
                ],
                exports: [
                    ToggleSwitchComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Overlay Component is a simple version of the dialog where there's only content.
 * Overlay will appear at the position where the action performed trigger an overlay.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<OverlayComponent>), service.close()
 *
 * Usage:
 *    1.  Using ModalService directly to display a modal popup. The usage is a little tricky
 *        because angular currently doesn't support dynamic content projection.
 *
 *          let overlay = this.modalService.open<OverlayComponent>(OverlayComponent, {});
 *
 *            // Add content. There's not support for dynamic content projection yet.
 *            // So have add content directly.
 *            // This is probably not the best way.
 *          overlay.instance.overlay.el.nativeElement.querySelector(".ui-overlaypanel-content")
 *               .innerHTML = `<img style='width:300px;' src="sales.png" alt="Sales Chart" />`;
 *
 *          // delay the opening after ng lifecycle has been initialized.
 *          setTimeout(() => { overlay.instance.open(event); }, 1);
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                                <aw-overlay #overlay (onOpen)="overlayAction='open'"
 *                                                     (onClose)="overlayAction='close'">
 *                                      <img src="sales.png" alt="Chart"/>
 *                                </aw-overlay>
 *
 *                                <aw-button [size]="'small'" (click)="overlay.open($event)">
 *                                    Open Overlay
 *                                </aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     overlayAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *       }
 *
 *
 */
class OverlayComponent extends ModalContainer {
    /**
     * @param {?} env
     */
    constructor(env) {
        super(env);
        this.env = env;
        /**
         * Enables hide overlay when outside is clicked.
         */
        this.dismissable = true;
        /**
         * displays the close icon 'x' at top of right corner.
         */
        this.showCloseIcon = false;
        /**
         * Event fired when overlay is closed.
         */
        this.onClose = new EventEmitter();
        /**
         * Event fired when the overlay is opened.
         */
        this.onOpen = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * Open Overlay
     * @param {?} event
     * @return {?}
     */
    open(event) {
        this.overlay.show(event);
        this.onOpened(null);
    }
    /**
     * Close Overlay
     * @return {?}
     */
    close() {
        this.overlay.hide();
    }
    /**
     * toggle open and close.
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        this.overlay.toggle(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onOpened(event) {
        this.onOpen.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClosed(event) {
        this.onClose.emit(event);
    }
}
OverlayComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-overlay',
                template: `<p-overlayPanel [dismissable]="dismissable" [showCloseIcon]="showCloseIcon"
                [styleClass]="styleClass" [appendTo]="appendTo"
                (onAfterHide)="onClosed($event)">
    <ng-content></ng-content>
</p-overlayPanel>
`,
                styles: [`::ng-deep .ui-overlaypanel{border:1px solid #d7d7d7;box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .ui-overlaypanel-content{padding:2em 3.4em .6em 1.43em}::ng-deep .ui-overlaypanel-close{border-radius:0;top:.5em;right:.5em}::ng-deep .ui-overlaypanel-close.ui-state-default{border:none}`]
            },] },
];
/** @nocollapse */
OverlayComponent.ctorParameters = () => [
    { type: Environment }
];
OverlayComponent.propDecorators = {
    dismissable: [{ type: Input }],
    showCloseIcon: [{ type: Input }],
    appendTo: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    overlay: [{ type: ViewChild, args: [OverlayPanel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
const HCCardPosition = {
    top: 0,
    bottom: 1,
    none: 2,
};
HCCardPosition[HCCardPosition.top] = "top";
HCCardPosition[HCCardPosition.bottom] = "bottom";
HCCardPosition[HCCardPosition.none] = "none";
/** @enum {number} */
const HCCardAlignment = {
    left: 0,
    paddedLeft: 1,
    right: 2,
    paddedRight: 3,
    default: 4,
};
HCCardAlignment[HCCardAlignment.left] = "left";
HCCardAlignment[HCCardAlignment.paddedLeft] = "paddedLeft";
HCCardAlignment[HCCardAlignment.right] = "right";
HCCardAlignment[HCCardAlignment.paddedRight] = "paddedRight";
HCCardAlignment[HCCardAlignment.default] = "default";
/**
 * Maps position to styles that are applied to the Card container. This is just to make it easier
 * as we are working with enumerations and have already enum type.
 *
 * u-hc-arrow-b: Arrow will appear at the bottom
 * u-hc-arrow-t: Arrow will appear at the top
 *
 * u-hc-shadow-t: Border shadow will appear at the top
 * u-hc-shadow-b: Border shadow will appear at the bottom
 */
const /** @type {?} */ PositionToStyle = {
    top: ' w-hc-panel-arrow u-hc-arrow-b u-hc-shadow-t',
    bottom: ' w-hc-panel-arrow u-hc-arrow-t u-hc-shadow-b',
    none: ''
};
/**
 *
 * Maps aligned Card container to custom styles in order to apply correct arrow
 *
 * -ll: Stands for Large Left (large: there is plenty of space around )
 * -lr: Stands for Large right
 * -sl: Stands for Small left (Small and resized screen where we try to fit card container
 * somewhere in between)
 * -sr: Stands for Large right
 *
 */
const /** @type {?} */ AlignmentToStyle = {
    left: ' u-hc-arrow-ll',
    right: ' u-hc-arrow-lr',
    paddedLeft: ' u-hc-arrow-sl',
    paddedRight: ' u-hc-arrow-sr',
    default: ' u-hc-arrow-ll',
};
/**
 * The HoverCard components adds hover behavior to text, the specified content is loaded
 * on the left or right side of the element.
 *
 * Todo: extends so we can wrap any element and any element can be triggering this. Not only
 * linkTitle
 *
 *
 * ### Example:
 *
 * ```
 *
 *   <aw-hover-card [linkTitle]="'Frank kolar'">
 *       <h3>My Card Title</h3>
 *       <div>
 *
 *           This is my contents
 *
 *       </div>
 *
 *
 *    </aw-hover-card>
 * ```
 *
 * By default there is [forceClose]=true which forces the user to use X close icon
 *
 *
 *
 */
class HoverCardComponent extends BaseComponent {
    /**
     * @param {?} elem
     * @param {?} env
     * @param {?} cd
     */
    constructor(elem, env, cd) {
        super(env);
        this.elem = elem;
        this.env = env;
        this.cd = cd;
        /**
         * Should we keep the hover card open and force user to manually close
         *
         */
        this.forceClose = true;
        /**
         *
         * This current workaround until we find better solution. PrimeNG overlays operates within
         * its relative element so if the overlay is wrapped inside some other relative container
         * the overlay content is croped by its parent and content is not visible.
         *
         * They have [appendTo] binding which we need to use for this purpose
         *
         */
        this.appendContentToBody = true;
        /**
         *
         * Internal style class to use to apply additional styles when it needs to show a Arrow on the
         * card
         *
         */
        this.arrowClass = '';
        this.opening = false;
        this.currrentPosition = HCCardPosition.none;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        assert(isPresent(this.linkTitle), 'You must provide [linkTitle] binding !');
        // make sure there is open HC when we start new component
        this.env.deleteValue('hc-open');
        if (!this.appendContentToBody) {
            this.appendTo = null;
        }
    }
    /**
     * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
     * during this phase.
     *
     * So now its broken down into two parts:
     *   - Apply class styles
     *   - Position it.
     * @return {?}
     */
    ngAfterViewChecked() {
        if (this.opening) {
            let /** @type {?} */ container = this.awOverlay.overlay.container;
            let /** @type {?} */ cntRect = container.getBoundingClientRect();
            if (this.currrentPosition !== HCCardPosition.none) {
                this.adjustCard(container, cntRect, this.awOverlay.overlay);
            }
            else {
                this.arrowClass = '';
            }
            this.opening = false;
        }
    }
    /**
     * Init elements BoundingClientRect that we use for calculation
     *
     * @return {?}
     */
    initElements() {
        let /** @type {?} */ titleElem = this.elem.nativeElement.querySelector('.w-hc-title');
        let /** @type {?} */ triggerElem = this.elem.nativeElement.querySelector('.sap-icon');
        this.titleAreaRect = titleElem.getBoundingClientRect();
        this.trigRect = triggerElem.getBoundingClientRect();
        this.trigIconMiddle = this.trigRect.width / 2;
    }
    /**
     *
     * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
     * only one Card is opened at the time it uses Environment to save extra information for it
     *
     *
     * @param {?} event
     * @return {?}
     */
    openCard(event) {
        if (isPresent(this.awOverlay) && !this.env.hasValue('hc-open')) {
            this.awOverlay.open(event);
            this.env.setValue('hc-open', true);
        }
    }
    /**
     *
     * Fired at the end of the opening cycle when all is initialized and the card is about to
     * fade in.
     *
     * This method first simulates displaying card by setting display:block and
     * domHandler.absolutePosition so we can read dimensions and then later on position the card
     * accordingly.
     *
     * @param {?} event
     * @return {?}
     */
    cardOpened(event) {
        let /** @type {?} */ container = this.awOverlay.overlay.container;
        let /** @type {?} */ target = this.awOverlay.overlay.target;
        this.openForAdjustments(container);
        // pre-run positioning so we can calculate new coordinates
        this.awOverlay.overlay.domHandler.absolutePosition(container, target);
        let /** @type {?} */ cntRect = container.getBoundingClientRect();
        this.currrentPosition = this.positionForCard(container, cntRect);
        this.applyStyleClass(container, cntRect, this.awOverlay.overlay);
        this.closeForAdjustments(container);
        this.opening = true;
    }
    /**
     *
     * When card is closed we need to release it and delete all the references from Environment
     *
     *
     * @param {?} event
     * @return {?}
     */
    cardClosed(event) {
        this.env.deleteValue('hc-open');
    }
    /**
     *
     * Applies style.TOP and style.LEFT to the container in order to reposition it and add
     * extra arrow.
     *
     * First based on the initial position we apply style.TOP and depending if its on the
     * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
     *
     * Then for positioning horizontally we use two types.
     *  - When there is allot of space the arrow is 25% from the edge
     *
     *    -----^------------   or       -----------^----
     *
     *
     *  - When there is less or none space we have only 10% far away form the edge
     *
     *    --^------------   or       -----------^--
     *
     *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
     *  either to the left or right.
     *
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    adjustCard(container, containerRect, modalContainer) {
        let /** @type {?} */ diff = (this.currrentPosition === HCCardPosition.bottom) ? 1 : -1;
        let /** @type {?} */ scrollTop = modalContainer.domHandler.getWindowScrollTop();
        let /** @type {?} */ posWithScroll = containerRect.top + scrollTop;
        container.style.top = (posWithScroll + (HoverCardComponent.ArrowPad * diff)) + 'px';
        let /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
        container.style.left = this.calcLeftForAlignment(containerRect, alignment) + 'px';
    }
    /**
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    applyStyleClass(container, containerRect, modalContainer) {
        if (this.currrentPosition !== HCCardPosition.none) {
            let /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
            this.arrowClass = (/** @type {?} */ (PositionToStyle))[(/** @type {?} */ (HCCardPosition))[this.currrentPosition]];
            this.arrowClass += (/** @type {?} */ (AlignmentToStyle))[(/** @type {?} */ (HCCardAlignment))[alignment]];
        }
        else {
            this.arrowClass = '';
        }
    }
    /**
     *
     * Detects if the card is going to be shown on the top of the Link label or under. Or if
     * its covering it.
     *
     * @param {?} container
     * @param {?} boundingRect
     * @return {?}
     */
    positionForCard(container, boundingRect) {
        // secure this in case of IE returning undefined
        let /** @type {?} */ borderWidth = getComputedStyle(container).borderWidth;
        let /** @type {?} */ cntWidth = parseFloat(borderWidth || '0');
        let /** @type {?} */ pos = HCCardPosition.none;
        if (this.trigRect.bottom < boundingRect.top) {
            pos = HCCardPosition.bottom;
        }
        else if (this.trigRect.top > (boundingRect.bottom - cntWidth)) {
            pos = HCCardPosition.top;
        }
        return pos;
    }
    /**
     *
     * Detect horizontal alignment.
     *
     * @param {?} boundingRect
     * @param {?} modalContainer
     * @return {?}
     */
    alignmentForCard(boundingRect, modalContainer) {
        let /** @type {?} */ alignment = HCCardAlignment.left;
        let /** @type {?} */ viewPort = modalContainer.domHandler.getViewport();
        if (this.trigRect.left.toFixed(0) === boundingRect.left.toFixed(0) &&
            boundingRect.left > HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.left;
        }
        else if (boundingRect.left < HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.paddedLeft;
        }
        else if ((viewPort.width - boundingRect.right) < HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.paddedRight;
        }
        else if (this.trigRect.right.toFixed(0) === boundingRect.right.toFixed(0) ||
            (viewPort.width - boundingRect.right) > HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.right;
        }
        else {
            alignment = HCCardAlignment.default;
        }
        return alignment;
    }
    /**
     *
     * Turn on temporary display to BLOCK so we can read dimensions
     *
     * @param {?} container
     * @return {?}
     */
    openForAdjustments(container) {
        container.style.visibility = 'hidden';
        container.style.display = 'block';
        this.initElements();
    }
    /**
     *
     * Turn off display back NONE
     *
     * @param {?} container
     * @return {?}
     */
    closeForAdjustments(container) {
        container.style.visibility = 'visible';
        // container.style.display = 'none';
    }
    /**
     *
     * Calculates positioning for style.LEFT. As already said they are two types of triangles that
     * are applies for these case:
     *
     *
     * a) Large left, Large right
     *
     *  PrimeNG aligns the card with either the right side or left side of the triggering icon
     *
     *
     *  V                                                                V
     *  ......^........................ or  .......................^......
     *
     *
     *
     *
     *  b) Small left , small right
     *
     *  This is for cases where there is not enough space and PrimeNG position the card off to the
     *  triggering icons, so even primeNg does not have space to align it with the V
     *
     *
     *     V                                                      V
     *  ....^........................ or  .......................^....
     *
     *
     * c)Aligned with the edge of browser
     *
     * On the right side this is problem as we cannot calculate full future width of the card.
     * but we applly for this case #b (arrow 10% )
     *
     *
     *
     * @param {?} boundingRect
     * @param {?} alignment
     * @return {?}
     */
    calcLeftForAlignment(boundingRect, alignment) {
        // width for which we need to shift card. 25% or 10% of the container width
        let /** @type {?} */ wLargeTriangle = boundingRect.width * 0.25;
        let /** @type {?} */ wSmallTriangle = boundingRect.width * 0.10;
        switch (alignment) {
            case HCCardAlignment.right:
                let /** @type {?} */ shiftRight = boundingRect.left + wLargeTriangle;
                let /** @type {?} */ trigRight = this.trigRect.right - this.trigIconMiddle;
                return shiftRight - (boundingRect.right - trigRight);
            case HCCardAlignment.paddedRight:
                let /** @type {?} */ shiftRightS = boundingRect.left + wSmallTriangle;
                let /** @type {?} */ trigRightS = this.trigRect.right - this.trigIconMiddle;
                return shiftRightS - (boundingRect.right - trigRightS);
            case HCCardAlignment.paddedLeft:
                let /** @type {?} */ shiftLeftPad = boundingRect.left - wSmallTriangle;
                return shiftLeftPad + this.trigIconMiddle;
            case HCCardAlignment.left:
            default:
                let /** @type {?} */ shiftLeft = boundingRect.left - wLargeTriangle;
                return shiftLeft + this.trigIconMiddle;
        }
    }
}
/**
 * Default padding representing a height of the Arrow for which we need to vertically adjust
 * Card container
 *
 */
HoverCardComponent.ArrowPad = 10;
/**
 * Defines safe threshold where there might not be enough space around or Card is aligned with
 * the left or right edge of the viewport for which we need to position the Arrow closer to the
 * side of the card
 *
 */
HoverCardComponent.SpacingLimit = 50;
HoverCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'aw-hover-card',
                template: `<span class="w-hc">
    <span class="w-hc-title">
        <aw-string [value]="linkTitle"></aw-string>
        <span class="sap-icon icon-slim-arrow-down" (mouseover)="openCard($event)"></span>
    </span>

    <div class="w-hc-body">

         <aw-overlay #overlay [showCloseIcon]="forceClose" [dismissable]="!forceClose"
                     [styleClass]="arrowClass"
                     [appendTo]="appendTo"
                     (onOpen)="cardOpened($event)"
                     (onClose)="cardClosed($event)">

        <!-- this is workaround to create a _ngcontent-INDEX reference so we can
        refer to this ng-content. Angular does not have any way right now to track this
        -->
        <span class="u-ngcontent">
                <ng-content></ng-content>
            </span>

    </aw-overlay>

    </div>
</span>


<!--<ng-template #contentToBody>-->
    <!--<aw-overlay #overlay [showCloseIcon]="forceClose" [dismissable]="!forceClose"-->
                <!--[styleClass]="arrowClass"-->
                <!--[appendTo]="appendTo"-->
                <!--(onOpen)="cardOpened($event)"-->
                <!--(onClose)="cardClosed($event)">-->

        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->
        <!--refer to this ng-content. Angular does not have any way right now to track this-->
        <!--&ndash;&gt;-->
        <!--<span class="u-ngcontent">-->
                <!--<ng-content></ng-content>-->
            <!--</span>-->

    <!--</aw-overlay>-->

<!--</ng-template>-->


<!--<ng-template #contentToOverlay>-->

    <!--<aw-overlay #overlay [showCloseIcon]="forceClose" [dismissable]="!forceClose"-->
                <!--[styleClass]="arrowClass"-->
                <!--(onOpen)="cardOpened($event)"-->
                <!--(onClose)="cardClosed($event)">-->

        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->
        <!--refer to this ng-content. Angular does not have any way right now to track this-->
        <!--&ndash;&gt;-->
        <!--<span class="u-ngcontent">-->
                <!--<ng-content></ng-content>-->
            <!--</span>-->

    <!--</aw-overlay>-->
<!--</ng-template>-->


`,
                styles: [`.w-hc-title{padding-right:1.4em;position:relative;white-space:nowrap}.w-hc-title .sap-icon{font-size:1em;color:#00679e;position:absolute;padding-top:.2em;right:0}::ng-deep .w-hc-panel-arrow.u-hc-shadow-b{box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow.u-hc-shadow-t{box-shadow:0 -2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow:after,::ng-deep .w-hc-panel-arrow:before{left:25%;border:solid transparent;content:" ";height:0;width:0;position:absolute;pointer-events:none}::ng-deep .w-hc-panel-arrow:after{border-color:rgba(136,183,213,0);border-width:.7em;margin-left:-.7em}::ng-deep .w-hc-panel-arrow:before{border-color:rgba(255,136,56,0);border-width:.8em;margin-left:-.8em}::ng-deep .u-hc-arrow-ll:after,::ng-deep .u-hc-arrow-ll:before{left:25%}::ng-deep .u-hc-arrow-lr:after,::ng-deep .u-hc-arrow-lr:before{left:75%}::ng-deep .u-hc-arrow-sl:after,::ng-deep .u-hc-arrow-sl:before{left:10%}::ng-deep .u-hc-arrow-sr:after,::ng-deep .u-hc-arrow-sr:before{left:90%}::ng-deep .u-hc-arrow-t:after,::ng-deep .u-hc-arrow-t:before{bottom:100%}::ng-deep .u-hc-arrow-t:after{border-bottom-color:#fff}::ng-deep .u-hc-arrow-t:before{border-bottom-color:#d7d7d7}::ng-deep .u-hc-arrow-b:after,::ng-deep .u-hc-arrow-b:before{top:100%}::ng-deep .u-hc-arrow-b:after{border-top-color:#fff}::ng-deep .u-hc-arrow-b:before{border-top-color:#d7d7d7}`]
            },] },
];
/** @nocollapse */
HoverCardComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Environment },
    { type: ChangeDetectorRef }
];
HoverCardComponent.propDecorators = {
    linkTitle: [{ type: Input }],
    forceClose: [{ type: Input }],
    appendContentToBody: [{ type: Input }],
    awOverlay: [{ type: ViewChild, args: ['overlay',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Spy lifecycle directive is used for debugging purposes to track lifecycle callback
 *
 * ###Usage
 *
 * ```
 *   <my-directive spyhooks><my-directive>
 *
 * ```
 */
class SpyLifeCycleHooksDirective {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.logIt('onInit');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.logIt('onDestroy');
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        this.logIt('ngOnChanges = ' + changes);
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        this.logIt('ngDoCheck');
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.logIt('ngAfterContentInit');
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.logIt('ngAfterContentChecked');
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.logIt('ngAfterViewInit');
    }
    /**
     * @return {?}
     */
    ngAfterViewChecked() {
        this.logIt('ngAfterViewChecked');
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    logIt(msg) {
        let /** @type {?} */ level = 0;
        let /** @type {?} */ me = this.elementRef.nativeElement;
        let /** @type {?} */ tagBody = me;
        while ((tagBody = tagBody.parentNode) != null) {
            level++;
            if (tagBody.tagName === 'APP-ROOT' || level === 6) {
                break;
            }
        }
        let /** @type {?} */ indent = '';
        let /** @type {?} */ indentNumber = level;
        while (level > 0) {
            indent += '\t';
            level--;
        }
        let /** @type {?} */ params = '';
        if (isPresent(me.attributes)) {
            for (let /** @type {?} */ i = 0; i < me.attributes.length; i++) {
                let /** @type {?} */ attr = me.attributes.item(i);
                if (this.ignore(attr.name.toLowerCase())) {
                    continue;
                }
                params += '(' + attr.name + '=' + attr.value + '),  ';
            }
        }
        print(indent + me.tagName + '(' + indentNumber + '): ' + msg + ' => ' + params);
    }
    /**
     * @param {?} name
     * @return {?}
     */
    ignore(name) {
        return name.indexOf('_ng') > -1 ||
            name.indexOf('ng-') > -1 ||
            name.indexOf('spyhooks') > -1;
    }
}
SpyLifeCycleHooksDirective.decorators = [
    { type: Directive, args: [{ selector: '[spyHooks]' },] },
];
/** @nocollapse */
SpyLifeCycleHooksDirective.ctorParameters = () => [
    { type: ElementRef }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var components = /*#__PURE__*/Object.freeze({
    AWCoreComponentModule: AWCoreComponentModule,
    ErrorMessagesComponent: ErrorMessagesComponent,
    ModalContainer: ModalContainer,
    ModalService: ModalService,
    ModalComponent: ModalComponent,
    CurrencyFormatPipe: CurrencyFormatPipe,
    BaseComponent: BaseComponent,
    BaseFormComponent: BaseFormComponent,
    WidgetSizeColumns: WidgetSizeColumns,
    DomUtilsService: DomUtilsService,
    EmbeddedItemDirective: EmbeddedItemDirective,
    EmbededItem: EmbededItem,
    ErrorManagerService: ErrorManagerService,
    GenericContainerComponent: GenericContainerComponent,
    IncludeComponentDirective: IncludeComponentDirective,
    ComponentRegistry: ComponentRegistry,
    DataTypeProviderRegistry: DataTypeProviderRegistry,
    DataProviders: DataProviders,
    DataFinders: DataFinders,
    DataFinder: DataFinder,
    FullTextArrayDataFinder: FullTextArrayDataFinder,
    QueryType: QueryType,
    DATA_SOURCE: DATA_SOURCE,
    DataProvider: DataProvider,
    ArrayDataProvider: ArrayDataProvider,
    NgForSetDirective: NgForSetDirective,
    AwNameDirective: AwNameDirective,
    AwNameStore: AwNameStore,
    FormTableComponent: FormTableComponent,
    AWFormTableModule: AWFormTableModule,
    FormRowComponent: FormRowComponent,
    TopZoneComponent: TopZoneComponent,
    LeftZoneComponent: LeftZoneComponent,
    MiddleZoneComponent: MiddleZoneComponent,
    RightZoneComponent: RightZoneComponent,
    BottomZoneComponent: BottomZoneComponent,
    AWInputFieldModule: AWInputFieldModule,
    AWStringFieldModule: AWStringFieldModule,
    AWBasicNavigatorModule: AWBasicNavigatorModule,
    AWButtonModule: AWButtonModule,
    AWCardModule: AWCardModule,
    AWCheckBoxModule: AWCheckBoxModule,
    AWCheckBoxListModule: AWCheckBoxListModule,
    AWHyperlinkModule: AWHyperlinkModule,
    AWChooserModule: AWChooserModule,
    AWDropdownModule: AWDropdownModule,
    AWCurrencyModule: AWCurrencyModule,
    AWDateAndTimeModule: AWDateAndTimeModule,
    AWDialogModule: AWDialogModule,
    AWGenericChooserModule: AWGenericChooserModule,
    AWRadioButtonModule: AWRadioButtonModule,
    AWRadioButtonListModule: AWRadioButtonListModule,
    AWOutlineForModule: AWOutlineForModule,
    AWTextAreaModule: AWTextAreaModule,
    AWPageNotificationModule: AWPageNotificationModule,
    AWPageWrapperModule: AWPageWrapperModule,
    AWRichTextAreaModule: AWRichTextAreaModule,
    AWSectionModule: AWSectionModule,
    AWStepperModule: AWStepperModule,
    AWDatatable2Module: AWDatatable2Module,
    AWConfirmationModule: AWConfirmationModule,
    AWScrollableContainerModule: AWScrollableContainerModule,
    AWListModule: AWListModule,
    WizardProgressModule: WizardProgressModule,
    ToggleSwitchModule: ToggleSwitchModule,
    BasicNavigatorComponent: BasicNavigatorComponent,
    ButtonComponent: ButtonComponent,
    CheckBoxListComponent: CheckBoxListComponent,
    CHOOSER_CONTROL_VALUE_ACCESSOR: CHOOSER_CONTROL_VALUE_ACCESSOR,
    ChooserComponent: ChooserComponent,
    ChooserState: ChooserState,
    DefaultSelectionState: DefaultSelectionState,
    ChooserSelectionState: ChooserSelectionState,
    ChooserDataSource: ChooserDataSource,
    isDSChooserInitParams: isDSChooserInitParams,
    CURRENCY_CONTROL_VALUE_ACCESSOR: CURRENCY_CONTROL_VALUE_ACCESSOR,
    CurrencyComponent: CurrencyComponent,
    Money: Money,
    DateAndTimeComponent: DateAndTimeComponent,
    DATETIME_CONTROL_VALUE_ACCESSOR: DATETIME_CONTROL_VALUE_ACCESSOR,
    DialogComponent: DialogComponent,
    DialogHeaderComponent: DialogHeaderComponent,
    DialogFooterComponent: DialogFooterComponent,
    ConfirmationComponent: ConfirmationComponent,
    ConfirmationHeaderComponent: ConfirmationHeaderComponent,
    ConfirmationFooterComponent: ConfirmationFooterComponent,
    OverlayComponent: OverlayComponent,
    DD_CONTROL_VALUE_ACCESSOR: DD_CONTROL_VALUE_ACCESSOR,
    DropdownComponent: DropdownComponent,
    GCChooserState: GCChooserState,
    GenericChooserComponent: GenericChooserComponent,
    HyperlinkComponent: HyperlinkComponent,
    INPUT_CONTROL_VALUE_ACCESSOR: INPUT_CONTROL_VALUE_ACCESSOR,
    InputFieldComponent: InputFieldComponent,
    RadioButtonListComponent: RadioButtonListComponent,
    StringComponent: StringComponent,
    TEXTAREA_CONTROL_VALUE_ACCESSOR: TEXTAREA_CONTROL_VALUE_ACCESSOR,
    TextAreaComponent: TextAreaComponent,
    CardComponent: CardComponent,
    CardZoneTitleComponent: CardZoneTitleComponent,
    CardZoneTopComponent: CardZoneTopComponent,
    CardZoneBottomComponent: CardZoneBottomComponent,
    OutlineForComponent: OutlineForComponent,
    OutlineControlComponent: OutlineControlComponent,
    OutlineState: OutlineState,
    isOutlineNode: isOutlineNode,
    PageContentComponent: PageContentComponent,
    PageNotificationComponent: PageNotificationComponent,
    PageNotification: PageNotification,
    PageInitialized: PageInitialized,
    PageDestroyed: PageDestroyed,
    PageWrapper: PageWrapper,
    PageLifeCycleService: PageLifeCycleService,
    ObjectPageWrapperComponent: ObjectPageWrapperComponent,
    PageHeaderComponent: PageHeaderComponent,
    PageMenuItem: PageMenuItem,
    UserNotification: UserNotification,
    PageFooterComponent: PageFooterComponent,
    SidenavComponent: SidenavComponent,
    PageActionsComponent: PageActionsComponent,
    SectionComponent: SectionComponent,
    SubSectionComponent: SubSectionComponent,
    SectionActionsComponent: SectionActionsComponent,
    EditorType: EditorType,
    RichTextAreaComponent: RichTextAreaComponent,
    CheckboxComponent: CheckboxComponent,
    RadioButtonComponent: RadioButtonComponent,
    StepperComponent: StepperComponent,
    StepComponent: StepComponent,
    ScrollableContainerComponent: ScrollableContainerComponent,
    HoverCardComponent: HoverCardComponent,
    ListComponent: ListComponent,
    Datatable2Component: Datatable2Component,
    DTHeaderComponent2: DTHeaderComponent2,
    DTColumn2Component: DTColumn2Component,
    DTDetailRowComponent: DTDetailRowComponent,
    Datatable2State: Datatable2State,
    isDTInitParams: isDTInitParams,
    DT2DataSource: DT2DataSource,
    DetailRowExpansionState: DetailRowExpansionState,
    DTMultiSelectColumnComponent: DTMultiSelectColumnComponent,
    WizardProgressComponent: WizardProgressComponent,
    ToggleSwitchComponent: ToggleSwitchComponent,
    DomHandler: DomHandler,
    TreeDragDropService: TreeDragDropService,
    ConfirmationService: ConfirmationService,
    Header: Header,
    Footer: Footer,
    PrimeTemplate: PrimeTemplate,
    Column: Column,
    Row: Row,
    HeaderColumnGroup: HeaderColumnGroup,
    FooterColumnGroup: FooterColumnGroup,
    SharedModule: SharedModule,
    AccordionTab: AccordionTab,
    Accordion: Accordion,
    AccordionModule: AccordionModule,
    AUTOCOMPLETE_VALUE_ACCESSOR: AUTOCOMPLETE_VALUE_ACCESSOR,
    AutoComplete: AutoComplete,
    AutoCompleteModule: AutoCompleteModule,
    BlockUI: BlockUI,
    BlockUIModule: BlockUIModule,
    Breadcrumb: Breadcrumb,
    BreadcrumbModule: BreadcrumbModule,
    ButtonDirective: ButtonDirective,
    Button: Button,
    ButtonModule: ButtonModule,
    Captcha: Captcha,
    CaptchaModule: CaptchaModule,
    CALENDAR_VALUE_ACCESSOR: CALENDAR_VALUE_ACCESSOR,
    Calendar: Calendar,
    CalendarModule: CalendarModule,
    Card: Card,
    CardModule: CardModule,
    Carousel: Carousel,
    CarouselModule: CarouselModule,
    UIChart: UIChart,
    ChartModule: ChartModule,
    CHECKBOX_VALUE_ACCESSOR: CHECKBOX_VALUE_ACCESSOR,
    Checkbox: Checkbox,
    CheckboxModule: CheckboxModule,
    CHIPS_VALUE_ACCESSOR: CHIPS_VALUE_ACCESSOR,
    Chips: Chips,
    ChipsModule: ChipsModule,
    CodeHighlighter: CodeHighlighter,
    CodeHighlighterModule: CodeHighlighterModule,
    COLORPICKER_VALUE_ACCESSOR: COLORPICKER_VALUE_ACCESSOR,
    ColorPicker: ColorPicker,
    ColorPickerModule: ColorPickerModule,
    ConfirmDialog: ConfirmDialog,
    ConfirmDialogModule: ConfirmDialogModule,
    ContextMenuSub: ContextMenuSub,
    ContextMenu: ContextMenu,
    ContextMenuModule: ContextMenuModule,
    DataGrid: DataGrid,
    DataGridModule: DataGridModule,
    DataList: DataList,
    DataListModule: DataListModule,
    DataScroller: DataScroller,
    DataScrollerModule: DataScrollerModule,
    DTRadioButton: DTRadioButton,
    DTCheckbox: DTCheckbox,
    ColumnHeaders: ColumnHeaders,
    ColumnFooters: ColumnFooters,
    TableBody: TableBody,
    ScrollableView: ScrollableView,
    DataTable: DataTable,
    DataTableModule: DataTableModule,
    DeferredLoader: DeferredLoader,
    DeferModule: DeferModule,
    Dialog: Dialog,
    DialogModule: DialogModule,
    Draggable: Draggable,
    Droppable: Droppable,
    DragDropModule: DragDropModule,
    DROPDOWN_VALUE_ACCESSOR: DROPDOWN_VALUE_ACCESSOR,
    Dropdown: Dropdown,
    DropdownModule: DropdownModule,
    EDITOR_VALUE_ACCESSOR: EDITOR_VALUE_ACCESSOR,
    Editor: Editor,
    EditorModule: EditorModule,
    Fieldset: Fieldset,
    FieldsetModule: FieldsetModule,
    FileUpload: FileUpload,
    FileUploadModule: FileUploadModule,
    Galleria: Galleria,
    GalleriaModule: GalleriaModule,
    GMap: GMap,
    GMapModule: GMapModule,
    Growl: Growl,
    GrowlModule: GrowlModule,
    InplaceDisplay: InplaceDisplay,
    InplaceContent: InplaceContent,
    Inplace: Inplace,
    InplaceModule: InplaceModule,
    INPUTMASK_VALUE_ACCESSOR: INPUTMASK_VALUE_ACCESSOR,
    InputMask: InputMask,
    InputMaskModule: InputMaskModule,
    INPUTSWITCH_VALUE_ACCESSOR: INPUTSWITCH_VALUE_ACCESSOR,
    InputSwitch: InputSwitch,
    InputSwitchModule: InputSwitchModule,
    InputText: InputText,
    InputTextModule: InputTextModule$1,
    InputTextarea: InputTextarea,
    InputTextareaModule: InputTextareaModule,
    KEYFILTER_VALIDATOR: KEYFILTER_VALIDATOR,
    KeyFilter: KeyFilter,
    KeyFilterModule: KeyFilterModule,
    Lightbox: Lightbox,
    LightboxModule: LightboxModule,
    LISTBOX_VALUE_ACCESSOR: LISTBOX_VALUE_ACCESSOR,
    Listbox: Listbox,
    ListboxModule: ListboxModule,
    MegaMenu: MegaMenu,
    MegaMenuModule: MegaMenuModule,
    MenuItemContent: MenuItemContent,
    Menu: Menu,
    MenuModule: MenuModule,
    MenubarSub: MenubarSub,
    Menubar: Menubar,
    MenubarModule: MenubarModule,
    Messages: Messages,
    MessagesModule: MessagesModule,
    UIMessage: UIMessage,
    MessageModule: MessageModule,
    MULTISELECT_VALUE_ACCESSOR: MULTISELECT_VALUE_ACCESSOR,
    MultiSelect: MultiSelect,
    MultiSelectModule: MultiSelectModule,
    OrderList: OrderList,
    OrderListModule: OrderListModule,
    OrganizationChartNode: OrganizationChartNode,
    OrganizationChart: OrganizationChart,
    OrganizationChartModule: OrganizationChartModule,
    OverlayPanel: OverlayPanel,
    OverlayPanelModule: OverlayPanelModule,
    Paginator: Paginator,
    PaginatorModule: PaginatorModule,
    Panel: Panel,
    PanelModule: PanelModule,
    BasePanelMenuItem: BasePanelMenuItem,
    PanelMenuSub: PanelMenuSub,
    PanelMenu: PanelMenu,
    PanelMenuModule: PanelMenuModule,
    Password: Password,
    PasswordModule: PasswordModule,
    PickList: PickList,
    PickListModule: PickListModule,
    ProgressBar: ProgressBar,
    ProgressBarModule: ProgressBarModule,
    ProgressSpinner: ProgressSpinner,
    ProgressSpinnerModule: ProgressSpinnerModule,
    RADIO_VALUE_ACCESSOR: RADIO_VALUE_ACCESSOR,
    RadioButton: RadioButton,
    RadioButtonModule: RadioButtonModule,
    RATING_VALUE_ACCESSOR: RATING_VALUE_ACCESSOR,
    Rating: Rating,
    RatingModule: RatingModule,
    Schedule: Schedule,
    ScheduleModule: ScheduleModule,
    ScrollPanel: ScrollPanel,
    ScrollPanelModule: ScrollPanelModule,
    SELECTBUTTON_VALUE_ACCESSOR: SELECTBUTTON_VALUE_ACCESSOR,
    SelectButton: SelectButton,
    SelectButtonModule: SelectButtonModule,
    SlideMenuSub: SlideMenuSub,
    SlideMenu: SlideMenu,
    SlideMenuModule: SlideMenuModule,
    SLIDER_VALUE_ACCESSOR: SLIDER_VALUE_ACCESSOR,
    Slider: Slider,
    SliderModule: SliderModule,
    Sidebar: Sidebar,
    SidebarModule: SidebarModule,
    SPINNER_VALUE_ACCESSOR: SPINNER_VALUE_ACCESSOR,
    Spinner: Spinner,
    SpinnerModule: SpinnerModule,
    SplitButton: SplitButton,
    SplitButtonModule: SplitButtonModule,
    Steps: Steps,
    StepsModule: StepsModule,
    TabViewNav: TabViewNav,
    TabPanel: TabPanel,
    TabView: TabView,
    TabViewModule: TabViewModule,
    TabMenu: TabMenu,
    TabMenuModule: TabMenuModule,
    Terminal: Terminal,
    TerminalModule: TerminalModule,
    TieredMenuSub: TieredMenuSub,
    TieredMenu: TieredMenu,
    TieredMenuModule: TieredMenuModule,
    TOGGLEBUTTON_VALUE_ACCESSOR: TOGGLEBUTTON_VALUE_ACCESSOR,
    ToggleButton: ToggleButton,
    ToggleButtonModule: ToggleButtonModule,
    Toolbar: Toolbar,
    ToolbarModule: ToolbarModule,
    Tooltip: Tooltip,
    TooltipModule: TooltipModule,
    UITreeNode: UITreeNode,
    Tree: Tree,
    TreeModule: TreeModule,
    TreeTableService: TreeTableService,
    TreeTable: TreeTable,
    TTBody: TTBody,
    TTScrollableView: TTScrollableView,
    TTSortableColumn: TTSortableColumn,
    TTSortIcon: TTSortIcon,
    TTResizableColumn: TTResizableColumn,
    TTReorderableColumn: TTReorderableColumn,
    TTSelectableRow: TTSelectableRow,
    TTSelectableRowDblClick: TTSelectableRowDblClick,
    TTContextMenuRow: TTContextMenuRow,
    TTCheckbox: TTCheckbox,
    TTHeaderCheckbox: TTHeaderCheckbox,
    TTEditableColumn: TTEditableColumn,
    TreeTableCellEditor: TreeTableCellEditor,
    TreeTableToggler: TreeTableToggler,
    TreeTableModule: TreeTableModule,
    TRISTATECHECKBOX_VALUE_ACCESSOR: TRISTATECHECKBOX_VALUE_ACCESSOR,
    TriStateCheckbox: TriStateCheckbox,
    TriStateCheckboxModule: TriStateCheckboxModule
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWOverlayModule {
}
AWOverlayModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    OverlayComponent
                ],
                imports: [
                    CommonModule,
                    AWCoreComponentModule,
                    OverlayPanelModule
                ],
                entryComponents: [
                    OverlayComponent
                ],
                exports: [
                    OverlayComponent,
                    AWCoreComponentModule
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class AWHoverCardModule {
}
AWHoverCardModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    HoverCardComponent
                ],
                imports: [
                    CommonModule,
                    AWOverlayModule,
                    AWStringFieldModule
                ],
                entryComponents: [
                    HoverCardComponent
                ],
                exports: [
                    HoverCardComponent
                ],
                providers: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Component module is core module for the common layouts and widgets libraries.
 *
 * todo: There are some things that I still need to resolve - please see and notices \@Duplicates
 * jsdoc I want to keep this there to remind me that I need to refactor this as of now there are
 * not much option with angular.
 *
 */
class AribaComponentsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AribaComponentsModule,
            providers: [
                ModalService,
                ComponentRegistry,
                ErrorManagerService,
                DomUtilsService,
                DataTypeProviderRegistry,
                DataProviders,
                DataFinders,
                AwNameStore,
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerComponents,
                    deps: [ComponentRegistry],
                    multi: true,
                }
            ]
        };
    }
}
AribaComponentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    AribaCoreModule,
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AWCoreComponentModule,
                    AWBasicNavigatorModule,
                    AWCardModule,
                    AWCheckBoxListModule,
                    AWCheckBoxModule,
                    AWChooserModule,
                    AWConfirmationModule,
                    AWCurrencyModule,
                    AWDateAndTimeModule,
                    AWDialogModule,
                    AWDropdownModule,
                    AWGenericChooserModule,
                    AWHyperlinkModule,
                    AWInputFieldModule,
                    AWOutlineForModule,
                    AWOverlayModule,
                    AWPageNotificationModule,
                    AWPageWrapperModule,
                    AWRadioButtonModule,
                    AWRadioButtonListModule,
                    AWRichTextAreaModule,
                    AWScrollableContainerModule,
                    AWSectionModule,
                    AWStepperModule,
                    AWStringFieldModule,
                    AWTextAreaModule,
                    AWFormTableModule,
                    AWButtonModule,
                    AWHoverCardModule,
                    AWListModule,
                    AWDatatable2Module,
                    WizardProgressModule,
                    ToggleSwitchModule,
                    PanelModule,
                    ButtonModule,
                    ToolbarModule,
                    InputTextModule$1,
                    InputTextareaModule,
                    AutoCompleteModule,
                    DropdownModule,
                    CalendarModule,
                    CheckboxModule,
                    RadioButtonModule,
                    SharedModule,
                    DialogModule,
                    MenuModule,
                    TabMenuModule,
                    AccordionModule,
                    EditorModule,
                    DataTableModule,
                    PaginatorModule,
                    OverlayPanelModule,
                    TreeModule
                ],
                declarations: [
                    SpyLifeCycleHooksDirective,
                ],
                bootstrap: [],
                entryComponents: [
                    Checkbox,
                    Dialog
                ],
                exports: [
                    ReactiveFormsModule,
                    FormsModule,
                    SpyLifeCycleHooksDirective,
                    AWCoreComponentModule,
                    AWBasicNavigatorModule,
                    AWCardModule,
                    AWCheckBoxListModule,
                    AWCheckBoxModule,
                    AWChooserModule,
                    AWConfirmationModule,
                    AWCurrencyModule,
                    AWDateAndTimeModule,
                    AWDialogModule,
                    AWDropdownModule,
                    AWGenericChooserModule,
                    AWHyperlinkModule,
                    AWInputFieldModule,
                    AWOutlineForModule,
                    AWOverlayModule,
                    AWPageNotificationModule,
                    AWPageWrapperModule,
                    AWRadioButtonModule,
                    AWRadioButtonListModule,
                    AWRichTextAreaModule,
                    AWScrollableContainerModule,
                    AWSectionModule,
                    AWStepperModule,
                    AWStringFieldModule,
                    AWTextAreaModule,
                    AWFormTableModule,
                    EmbeddedItemDirective,
                    AWButtonModule,
                    AWHoverCardModule,
                    AWListModule,
                    AWDatatable2Module,
                    WizardProgressModule,
                    ToggleSwitchModule,
                    SharedModule,
                    PanelModule,
                    ButtonModule,
                    ToolbarModule,
                    InputTextModule$1,
                    InputTextareaModule,
                    AutoCompleteModule,
                    DropdownModule,
                    CalendarModule,
                    CheckboxModule,
                    RadioButtonModule,
                    DialogModule,
                    MenuModule,
                    TabMenuModule,
                    EditorModule,
                    DataTableModule,
                    PaginatorModule,
                    OverlayPanelModule
                ]
            },] },
];
/**
 * @param {?} compRegistry
 * @return {?}
 */
function registerComponents(compRegistry) {
    return compRegistry.initialize.bind(compRegistry, components);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * This module is used mainly for tests as importing a module with all the components and you
 * use only 1 or two has a big impact on the performance execution. e.g. from executing couple
 * tests under 1 sec can go up to 10sec if you import all the things that you are not using.
 *
 * I havent noticed anything similar in application its only jasmine/karma that needs to init
 * components for every test.
 *
 */
class AribaComponentsTestProviderModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AribaComponentsTestProviderModule,
            providers: [
                ModalService,
                ComponentRegistry,
                ErrorManagerService,
                DomUtilsService,
                DataTypeProviderRegistry,
                DataProviders,
                DataFinders,
                AwNameStore,
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerComponents$1,
                    deps: [ComponentRegistry],
                    multi: true,
                }
            ]
        };
    }
}
AribaComponentsTestProviderModule.decorators = [
    { type: NgModule, args: [{
                imports: []
            },] },
];
/**
 * @param {?} compRegistry
 * @return {?}
 */
function registerComponents$1(compRegistry) {
    return compRegistry.initialize.bind(compRegistry, components);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { ErrorMessagesComponent, ModalContainer, ModalService, ModalComponent, CurrencyFormatPipe, BaseComponent, WidgetSizeColumns, DomUtilsService, EmbeddedItemDirective, EmbededItem, ErrorManagerService, GenericContainerComponent, IncludeComponentDirective, ComponentRegistry, AWCoreComponentModule, BaseFormComponent, DataTypeProviderRegistry, DataProvider, DataProviders, DataFinders, DataFinder, QueryType, FullTextArrayDataFinder, DATA_SOURCE, ArrayDataProvider, NgForSetDirective, AwNameDirective, AwNameStore, FormTableComponent, FormRowComponent, TopZoneComponent, LeftZoneComponent, MiddleZoneComponent, RightZoneComponent, BottomZoneComponent, AWFormTableModule, BasicNavigatorComponent, ButtonComponent, CheckBoxListComponent, CHOOSER_CONTROL_VALUE_ACCESSOR, ChooserComponent, ChooserState, DefaultSelectionState, ChooserSelectionState, CURRENCY_CONTROL_VALUE_ACCESSOR, CurrencyComponent, Money, DateAndTimeComponent, DATETIME_CONTROL_VALUE_ACCESSOR, DialogComponent, DialogHeaderComponent, DialogFooterComponent, ConfirmationComponent, ConfirmationHeaderComponent, ConfirmationFooterComponent, OverlayComponent, DropdownComponent, GCChooserState, GenericChooserComponent, HyperlinkComponent, INPUT_CONTROL_VALUE_ACCESSOR, InputFieldComponent, RadioButtonListComponent, StringComponent, TEXTAREA_CONTROL_VALUE_ACCESSOR, TextAreaComponent, OutlineForComponent, OutlineControlComponent, PageActionsComponent, PageContentComponent, PageFooterComponent, PageHeaderComponent, PageMenuItem, UserNotification, PageNotificationComponent, PageNotification, PageInitialized, PageDestroyed, PageWrapper, PageLifeCycleService, ObjectPageWrapperComponent, SectionComponent, SubSectionComponent, RichTextAreaComponent, EditorType, CheckboxComponent, RadioButtonComponent, StepperComponent, StepComponent, AWInputFieldModule, AWStringFieldModule, AWBasicNavigatorModule, AWButtonModule, AWHyperlinkModule, AWCardModule, AWCheckBoxModule, AWCheckBoxListModule, AWChooserModule, AWDropdownModule, AWCurrencyModule, AWDateAndTimeModule, AWDialogModule, AWGenericChooserModule, AWRadioButtonModule, AWRadioButtonListModule, AWTextAreaModule, AWPageNotificationModule, AWPageWrapperModule, AWRichTextAreaModule, AWSectionModule, AWStepperModule, ScrollableContainerComponent, AWScrollableContainerModule, AWConfirmationModule, ChooserDataSource, isDSChooserInitParams, HoverCardComponent, ListComponent, AWListModule, CardComponent, OutlineState, Datatable2Component, DTColumn2Component, DTHeaderComponent2, DTDetailRowComponent, DetailRowExpansionState, Datatable2State, isDTInitParams, DT2DataSource, DTMultiSelectColumnComponent, AWDatatable2Module, WizardProgressComponent, isOutlineNode, AWOutlineForModule, ToggleSwitchComponent, WizardProgressModule, ToggleSwitchModule, AribaComponentsModule, AribaComponentsTestProviderModule, SpyLifeCycleHooksDirective, registerComponents as ɵp, registerComponents$1 as ɵq, BaseComponent as ɵy, DataSource as ɵa, InfiniteScrollComponent as ɵr, CardZoneTitleComponent as ɵh, CardZoneBottomComponent as ɵg, CardZoneTopComponent as ɵf, AWCardModule as ɵb, CB_LIST_CONTROL_VALUE_ACCESSOR as ɵc, CB_CONTROL_VALUE_ACCESSOR as ɵm, DTDetailRowExpanderComponent as ɵu, DTSingleSelectColumnComponent as ɵv, SetCellMaxWidthDirective as ɵx, DTDraggableRowDirective as ɵw, DTWrapper as ɵt, DD_CONTROL_VALUE_ACCESSOR as ɵd, AWHoverCardModule as ɵba, LB_CONTROL_VALUE_ACCESSOR as ɵo, InitNestingDirective as ɵi, AWOverlayModule as ɵz, SidenavComponent as ɵj, RB_LIST_CONTROL_VALUE_ACCESSOR as ɵe, RAB_CONTROL_VALUE_ACCESSOR as ɵn, EDITOR_CONTROL_VALUE_ACCESSOR as ɵl, SectionActionsComponent as ɵk };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJpYmF1aS1jb21wb25lbnRzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZW1iZWRkZWQtaXRlbS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2dlbmVyaWMtY29udGFpbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Jhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvb24tbmdmb3Itc2V0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RvbS11dGlscy5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvaW5maXRlLXNjcm9sbC9pbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9jb3JlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9hcnJheS1kYXRhLXByb3ZpZGVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycy50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RhdGEvZGF0YS1maW5kZXJzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9sYXlvdXRzL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9idXR0b24vYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLXRpdGxlL2NhcmQtdGl0bGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9oeXBlcmxpbmsvaHlwZXJsaW5rLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRlLWFuZC10aW1lLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWZvb3Rlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtc3RhdGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3RleHQtYXJlYS90ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1ldmVudHMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1saWZlY3ljbGUuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIvb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1hY3Rpb25zL3BhZ2UtYWN0aW9ucy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1jb250ZW50L3BhZ2UtY29udGVudC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwL3N0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3NlY3Rpb24vc2VjdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9hdy1kYXRhdGFibGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RpcmVjdGl2ZXMvZHQtY2VsbC1kaXJlY3RpdmVzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9saXN0L2xpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3dpemFyZC1wcm9ncmVzcy93aXphcmQtcHJvZ3Jlc3MuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvd2l6YXJkLXByb2dyZXNzL3dpemFyZC1wcm9ncmVzcy5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy90b2dnbGUtc3dpdGNoL3RvZ2dsZS1zd2l0Y2guY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdG9nZ2xlLXN3aXRjaC90b2dnbGUtc3dpdGNoLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3NweS1saWZlY3ljbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvYXJpYmEuY29tcG9uZW50Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9hcmliYS5jb21wb25lbnQucHJvdmlkZXIubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBXaGVuIHdlIGhhdmUgYSBjdXN0b20gY29tcG9uZW50IGxpa2UgZHJvcGRvd24sIHJhZGlvYnV0dG9ubGlzdCBhbmRcbiAqIG1hbnkgbW9yZSB3ZSB3YW50IHRvIHByb3ZpZGUgYSBjdXN0b20gY29udGVudCB0byBpdCBsaWtlIHNvOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICpcbiAqIGBgYFxuICogV2hvIGVsc2Ugd291bGQga25vdyBob3cgdG8gcmVuZGVyIGxpc3Qgb2Ygb2JqZWN0cy4uXG4gKlxuICogQnV0IGl0cyBub3QgcG9zc2libGUgaW4gY3VycmVudCBmb3JtLiBpZiBJIGRvIG5vdCBwcm92aWRlIEFuZ3VsYXIgc29tZSBhcyB0aGV5IGNhbGwgaXQgdGhpc1xuICogc3ludGFjdGljIHN1Z2FyICosXG4gKlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biAqbXlTdWdlckRpcmVjdGl2ZT0uLi4uLj5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICogYGBgXG4gKlxuICpcbiAqIHRoZW4gYW5ndWxhciB3aWxsIG5vdCBrbm93ICBpbnNpZGUgaXMgYSB0ZW1wbGF0ZSBhbmQgSSB3b250IGJlIGFibGUgdG8gZ2V0IGhvbGQgb2YgVGVtcGxhdGVSZWZcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50XG4gKlxuICogU28gdGhlIG9ubHkgd2F5IEkgZm91bmQgKGV4cGVjdGluZyBJIGRvIG5vdCB3YW50IHRvIGNoYW5nZSBhbnl0aGluZyBpbiB0ZXJtcyBvZiBiaW5kaW5ncyBhbmQgdGhlXG4gKiBzaWduYXR1cmUgSSB1c2UgaXQuIEkgaGF2ZSB0byB1c2UgaXQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtPiB7e2l0ZW0udXNlck5hbWV9fTwvbmctdGVtcGxhdGU+XG4gKlxuICogICA8YXctZHJvcGRvd25cbiAqXG4gKiBgYGBcbiAqXG4gKiAgVGhpcyB3YXkgaXQgY291bGQgd29yay4gU2luY2UgSSBhbSBpbnNpZGUgbmdGb3IgSSB3YW50IHRvIHJlbmRlciB0aGUgaXRlbSBpbnRvIHRoZSBjb3JyZWN0XG4gKiB2aWV3Q29udGFpbmVyIG9mIG5nRm9yJ3MgY3VycmVudCBpdGVtLlxuICpcbiAqICBUaGlzIHdheSBJIGNhbiBhbHNvIGV4cG9zZSBpdGVtIG91dHNpZGUgdXNpbmcgQW5ndWxhcidzIHNwZWNpYWwgbG9jYWwgdmFyaWFibGUgY2FsbGVkOlxuICogJGltcGxpY2l0LlxuICpcbiAqIFRoaXMgZ2V0cyBldmVuIG1vcmUgY29tcGxleCBpZiB3ZSB0cnkgdG8gcGFzcyB0aGlzIHRlbXBsYXRlIDIgbGV2ZWxzIGRvd24sIGxpa2UgaW4gY2FzZSBvZlxuICogUmFkaW9CdXR0b25MaXN0LiBCdXQgbGF0ZXIgb24gSSBtaWdodCB3YW50IHRvIHJlZmFjdG9yIHRoaXMgaW50byBjdXN0b20gTkcgRk9SXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbmdUZW1wbGF0ZU91dGxldCAod2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tlbWJlZGRlZEl0ZW1dJ30pXG5leHBvcnQgY2xhc3MgRW1iZWRkZWRJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzXG57XG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgd2Ugd2FudCB0byByZW5kZXIgTi1UaW1lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1iZWRkZWRJdGVtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFZhbHVlID0gaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbXBsaWNpdFZhbHVlOiBhbnk7XG4gICAgcHJpdmF0ZSBfdmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fdmlld1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXIuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZW1iZWRkZWRJdGVtKSkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgRW1iZWRlZEl0ZW0odGhpcy5faW1wbGljaXRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5lbWJlZGRlZEl0ZW0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgQW5ndWxhcidzIEVtYmVkZGVkVmlld1JlZi5jb250ZXh0KClcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBFbWJlZGVkSXRlbVxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ6IGFueSlcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCBpcyB1c2VkIGJ5IGluY2x1ZGUtY29tcG9uZW50LmRpcmVjdGl2ZSB0byBkeW5hbWljYWxseSBjcmVhdGUgYW5cbiAqIEhUTUxFbGVtZW50IGFuZCB1c2UgdGhpcyBlbGVtZW50IHRvIHdyYXAgYSBjaGlsZCBjb21wb25lbnQuIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvXG4gKiBtb2RpZnkgYSBjaGlsZCBieSB3cmFwcGluZyBpdCB3aXRoIGEgYm9yZGVyLCBhIGJhY2tncm91bmQsIG9yIGJvbGQgaXRzIHRleHQuXG4gKlxuICogVGhlIHdyYXBwZXIgZWxlbWVudCBpcyBkeW5hbWljYWxseSBjcmVhdGVkLiBJdCdzIGVsZW1lbnQgaXMgc3BlY2lmaWVkIGJ5IHRoZSB0YWdOYW1lIHByb3BlcnR5IGluXG4gKiB0aGUgYmluZGluZ3MgQElucHV0LlxuICpcbiAqICAjIyMgRXhhbXBsZS4gIERpcmVjdGx5IGluIGh0bWxcbiAqXG4gKiAgIGFwcC5odG1sXG4gKiAgICAgIDxhdy1nZW5lcmljLWNvbnRhaW5lciB0YWdOYW1lPVwidGFnTmFtZVwiIGJpbmRpbmdzPVwiYmluZGluZ3NcIj5cbiAqICAgICAgICAgIDxteS1jb21wb25lbnQgLi5iaW5kaW5ncy4uPjwvbXktY29tcG9uZW50PlxuICogICAgICA8L2F3LWdlbmVyaWMtY29udGFpbmVyPlxuICpcbiAqICAgYXBwLmNvbXBvbmVudC50c1xuICpcbiAqICAgICAgIHRhZ05hbWUgPSAoYkJvbGQpID8gJ2gxJyA6ICdzcGFuJztcbiAqICAgICAgIGJpbmRpbmdzID0geyAgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnIH1cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZ2VuZXJpYy1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgc3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrXG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRhZ05hbWUgaWYgbm9uZSBpcyBzcGVjaWZpZWQgaW5zaWRlIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IERlZmF1bHRUYWdOYW1lID0gJ2Rpdic7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kaW5ncyB0byBiZSBhZGRlZCBhcyBhdHRyaWJ1dGVzIHRvIHRoZSB0YWdOYW1lIGVsZW1lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gYmUgY3JlYXRlZCB0aGF0IHdyYXBzIGl0J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhZ05hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByb290IGVsZW1lbnQuIFBvaW50cyB0byA8YXctZ2VuZXJpYy1jb250YWluZXI+XG4gICAgICovXG4gICAgcHJpdmF0ZSBuYXRpdmVFbGVtZW50OiBOb2RlO1xuXG4gICAgcHJpdmF0ZSBjaGlsZEVsZW1lbnQ6IE5vZGU7XG5cblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHJlbmRlcmVyIC0gUmVuZGVyZXIgaXMgdXNlZCB0byBjcmVhdGUgJ3RhZ05hbWUnIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiwgdmVyaWZ5IHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGlucHV0LCB0aGlzIGNvbXBvbmVudCB3b3VsZG4ndCBrbm93IHdoYXQgdG8gZG8gYW5kIHRocm93IGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5iaW5kaW5ncykgJiYgaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbmVyaWNDb250YWluZXJDb21wb25lbnQgaW5wdXQgYmluZGluZ3Mgb3IgdGFnTmFtZSAnICtcbiAgICAgICAgICAgICAgICAnaGF2ZSBub3QgYmVlbiBzZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdGFnTmFtZSBpcyBibGFuaywgdGhlIGdldCBpdCBmcm9tIGJpbmRpbmdzLlxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ05hbWUgPSB0aGlzLmJpbmRpbmdzLmdldCgndGFnTmFtZScpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9IEdlbmVyaWNDb250YWluZXJDb21wb25lbnQuRGVmYXVsdFRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGZpcnN0IGFkZGVkXG4gICAgICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY2hpbGRFbGVtZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5jaGlsZEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblxuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBjb250ZW50IGhhcyBiZWVuIGluaXRpYWxpemVkLiBDcmVhdGUgdGhlIHRhZ05hbWUgZWxlbWVudC4gQXBwbHkgYWxsIHRoZSBiaW5kaW5ncyBvbiB0b1xuICAgICAqIHRoZSBlbGVtZW50IGFzIGF0dHJpYnV0ZS4gRmluYWxseSwgbW92ZSB0aGUgY2hpbGQgZWxlbWVudCwgPG5nLWNvbnRlbnQ+LCB0byBpbnNpZGUgdGhlXG4gICAgICogd3JhcHBlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb1JlbmRlcigpXG4gICAge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmF0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5uYXRpdmVFbGVtZW50LCBlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBiaW5kaW5ncyBhbmQgYWRkIHRoZW0gdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUodGhpcy5iaW5kaW5ncykuZm9yRWFjaCgodiwgaykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgaywgdik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoaXMgZGl2RWxlbWVudC5cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgIH1cblxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RG9DaGVjaywgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBcHBDb25maWcsIEVudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqICBCYXNlIGNvbXBvbmVudCBzaGFyZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgYW1vbmcgYWxsIHRoZSBjb21wb25lbnRzIChsYXlvdXRzLCB3aWRnZXRzKS5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2ssIE9uRGVzdHJveVxue1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBkaXNhYmxlZCBmbGFnIHRvIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogV2VhdGhlciB0aGlzIGNvbXBvbmVudCBpcyB2aXNpYmxlXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZTtcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgIHRoZSBjb21wb25lbnQgaWYgd2UgYXJlIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFibGU/OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGNvbXBvbmVudCBoYXZlIG9wdGlvbiB0byBzZXQgYSBjdXN0b20gd2l0aFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB3aWR0aDogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlcnkgY29tcG9uZW50IGhhdmUgb3B0aW9uIHRvIHNldCBhIGN1c3RvbSB3aXRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoZWlnaHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIG9wdGlvbmFsIGNzcyBjbGFzcyB3aGljaCBjYW4gYmUgdXRpbGl6ZWQgYnkgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdHlsZUNsYXNzOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHBhZGRpbmcgZnJvbSB0aGUgY29tcG9uZW50LiBVc3VhbGx5IHVzZWQgd2hlbiB3ZSBhcmUgbmVzdGluZyBvdGhlciBjb21wb25lbnQgd2l0aFxuICAgICAqIGl0cyBvd24gZ3JpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9taXRQYWRkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBleHRlbnNpb24gc3VwcG9ydCByZWdpc3RlciBoZXJlIGFueSBkeW5hbWljIGZpZWxkIHRoYXQgZG9lcyBub3QgZXhpc3Rpbmcgb24gdGhlXG4gICAgICogY2xhc3MvY29tcG9uZW50XG4gICAgICovXG4gICAgZXh0QmluZGluZ3M6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFByZWZpeCBmb3IgdGhlIGNvcnJlY3QgYXNzZXQgcGF0aFxuICAgICAqL1xuICAgIGFzc2V0Rm9sZGVyOiBzdHJpbmcgPSAnYXNzZXRzJztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY/OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHRoaXMuZXh0QmluZGluZ3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgICB0aGlzLm9taXRQYWRkaW5nID0gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmFzc2V0Rm9sZGVyID0gdGhpcy5lbnYuZ2V0VmFsdWUoQXBwQ29uZmlnLkFzc2V0Rm9sZGVyKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudCwgbm9vcCwgdXVpZH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge2ZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBQaXBlVHJhbnNmb3JtLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIHgtc21hbGwgPSA+IDEyJSAgPSA+IGNvbC0xXG4gKiBzbWFsbCA9ID4gYFxuICogbWVkaXVtID0gPiA1MCUgICA9ID4gY29sLTZcbiAqIGxhcmdlID0gPiA3NSUgICAgPSA+IGNvbC05XG4gKiBsYXJnZSA9ID4gMTAwJSAgID0gPiBjb2wtMTJcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIFdpZGdldFNpemUgPSAneC1zbWFsbCcgfCAnc21hbGwnIHwgJ21lZGl1bScgfCAnbGFyZ2UnIHwgJ3gtbGFyZ2UnO1xuXG5leHBvcnQgZW51bSBXaWRnZXRTaXplQ29sdW1uc1xue1xuICAgIHhzbWFsbCA9IDEsXG4gICAgc21hbGwgPSAzLFxuICAgIG1lZGl1bSA9IDYsXG4gICAgbGFyZ2UgPSA5LFxuICAgIHhsYXJnZSA9IDEyXG59XG5cblxuLyoqXG4gKiAgQmFzZUZvcm1Db21wb25uZXQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGZvciBhZGQgc3BlY2lmaWMgZm9ybSBiZWhhdmlvclxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VGb3JtQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG57XG4gICAgLypcbiAgICAgKiAgU3VwcG9ydGVkIGxheW91dCBjb25zdGFudHMuIEl0IGlzIGV4cGVjdGVkIHRoZXJlIHdpbGwgYmUgbW9yZSBvcHRpb25zIGFzIHdlIGN1cnJlbnRseVxuICAgICAqICBzdXBwb3J0IG9ubHkgdGhlc2UgdHdvIHRoZXJlIHdpbGwgYmUgb3RoZXIgdmFyaWF0aW9ucyBvZiBpdC4gZS5nLiBmb3Igc3RhY2tlZCBpdCB3aWxsIG5vdFxuICAgICAqICBiZSAxIGNvbHVtbnMgbGlrZSBpdCBpcyBub3cgYnV0IG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWFkb25seSBMYXlvdXRTdGFja2VkID0gJ3N0YWNrZWQnO1xuICAgIHN0YXRpYyByZWFkb25seSBMYXlvdXRJbmxpbmUgPSAnaW5saW5lJztcblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IG5hbWUgYXR0cmlidXRlLiBDYW4gYmUgdXNlZCB0byBsb29rdXAgY29tcG9uZW50IGluIGZvcm0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBuYW1lOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCBJZC4gQ2FuIGJlIHVzZWQgdG8gbG9va3VwIGNvbXBvbmVudCBpbiBmb3JtLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyBjdXJyZW50IGVsZW1lbnQgdmlzaWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHBhc3MgaW4gZm9ybUdyb3VwIHdoaWNoIHdpbGwgYmUgdXNlZCB3aXRoIGluIHRoZSBmb3JtXG4gICAgICpcbiAgICAgKiBASW5wdXQoKSAtIHNlZSBnZXR0ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIF9mb3JtR3JvdXA6IEZvcm1Hcm91cDtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyByZXF1aXJlZCBmbGV4IGFyb3VuZCB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqICBhIHRleHQgZGlzcGxheWVkIHdoZW4gdmFsdWUgaXMgZW1wdHkgb3IgTlVMTFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGxhY2VIb2xkZXI6IFN0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZnkgaWYgdGhpcyBjb250cm9sIGlzIHVzZWQgZGlyZWN0bHkgb3IgaWYgaXRzIHBhcnQgb2Ygc29tZSBvdGhlciBjb250cm9sXG4gICAgICogZS5nLiBHZW5lcmljQ2hvb3NlciBhbmQgbWFuYWdlZCBieSB0aGlzIGNvbnRyb2wuXG4gICAgICogTWVhbmluZyBTdGF0ZSBpcyBtYW5hbmdlZCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzU3RhbmRhbG9uZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm0gQ29udHJvbCBmb3IgdGhlIGNvbXBvbmVudC4gSXRzIGVpdGhlciBpbmhlcml0ZWQgc2luY2UgaXQgd2FzIHByZWNyZWF0ZWQgaW4gcGFyZW50XG4gICAgICogY29tcG9uZW50IG9yIGl0cyBjcmVhdGVkIGJhc2VkIG9uIHBhc3NlZCAnbmFtZScgYW5kIHJlZ2lzdGVyZWQgd2l0aCB0aGUgJ2Zvcm1Hcm91cCdcbiAgICAgKlxuICAgICAqIFdoZW4gIGluaXRpYWxpemUgRm9ybUNvbnRyb2wgd2UgZG8gc2V0VmFsdWUgd2l0aCBvbmx5U2VsZjp0cnVlIGZsYWcgYW5kIHdlIGRvIG5vdCBlbWl0IGFueVxuICAgICAqIGV2ZW50IG91dHNpZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGZvcm1Db250cm9sOiBGb3JtQ29udHJvbDtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHRoYXQgY2FuIGJlIGFzc2lnbiB0byB0aGUgY29tcG9uZW50IGluIG9yZGVyIHRvIGZvcm1hdCBpdHMgaW5wdXRcbiAgICAgKi9cbiAgICBmb3JtYXR0ZXI6IFBpcGVUcmFuc2Zvcm07XG5cblxuICAgIHByb3RlY3RlZCBvbk1vZGVsQ2hhbmdlZDogKF86IGFueSkgPT4gdm9pZCA9IG5vb3A7XG4gICAgcHJvdGVjdGVkIG9uTW9kZWxUb3VjaGVkOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcblxuXG4gICAgLyoqXG4gICAgICogU29tZSBvZiB0aGUgQmFzZUZvcm1Db21wb25lbnQgY2FuIHdyYXAgb3RoZXIgY29tcG9uZW50IGFuZCBpbiB0aGVzZSBjYXNlcyB3ZSB3YW50IHRvXG4gICAgICogaW5oZXJpdCBzb21lIG9mIHRoZSBiZWhhdmlvciBmcm9tIHBhcmVudFxuICAgICAqXG4gICAgICogQEluamVjdChFbnZpcm9ubWVudCkgcHVibGljIGVudjogRW52aXJvbm1lbnQgOiBpcyB0ZW0gYSB3b3JrYXJvdW5kIGFzIHdpdGhvdXQgaW5qZWN0XG4gICAgICogb24gdGhpcyBzcGVjaWZpYyBjb21wb25lbnQgaXQgY29tcGxhaW5zIHRoYXQgRW52aXJvbm1lbnQgaXMgdW5yZXNvbHZlZCBzeW1ib2xcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChASW5qZWN0KEVudmlyb25tZW50KSBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUdyb3VwID0gdGhpcy5wYXJlbnRDb250YWluZXIuZm9ybUdyb3VwO1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0luaXRGb3JtKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGF2YWlsYWJsZSBmb3JtR3JvdXAgYW5kIE5hbWUgYW5kIElEXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2hlY2tJbml0Rm9ybSAoKVxuICAgIHtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmVudi5jdXJyZW50Rm9ybSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9kbzogUmlnaHQgbm93IEkganVzdCBuZWVkIHRvIGluaXRpYWxpemUgbmFtZSAsIGJ1dCBpZGVhbGx5IGl0IG5lZWRzIHRvIGJlIGdlbmVyYXRlZFxuICAgICAgICAgKiBudW1iZXIgYmFzZWRvbiBzb21lIHNlbWFudGljcyBhcHAucGFnZS5jb21wb25lbnQgaWYgdGhlcmUgYXJlIG1vcmUgY29tcG9uZW50IG9uIHRoZSBwYWdlXG4gICAgICAgICAqIHRoZW4gYXBwLnBhZ2UuY29tcG9uZW50TnVtYmVyLiBTaW1wbGUgc29sdXRpb24gaXMgdG8gaXMgdG8gZ2V0IEVsZW1lbnRyZWYgYW5kIHF1ZXJ5IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdXVpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB1dWlkKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBkb1JlZ2lzdGVyIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBGb3JtQ29udHJvbFxuICAgIHtcblxuICAgICAgICBsZXQgZkNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtR3JvdXAucmVnaXN0ZXJDb250cm9sKG5hbWUsIG5ldyBGb3JtQ29udHJvbCh2YWx1ZSkpO1xuICAgICAgICAgICAgZkNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICBsZXQgdXBkYXRlZFZhbHVlOiBhbnkgPSBpc1ByZXNlbnQoZkNvbnRyb2wudmFsdWUpID8gZkNvbnRyb2wudmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgIGZDb250cm9sLnBhdGNoVmFsdWUodXBkYXRlZFZhbHVlLCB7b25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZkNvbnRyb2w7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggRm9ybXMgdGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdG8gcmVnaXN0ZXIgY29udHJvbFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgZGVmYXVsdCB2YWx1ZSB0byBiZSBwcmUtc2V0XG4gICAgICovXG4gICAgcmVnaXN0ZXJGb3JtQ29udHJvbCAodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSB0aGlzLmRvUmVnaXN0ZXIodGhpcy5uYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBASW5wdXQoKSBnZXQgZm9ybUdyb3VwICgpOiBGb3JtR3JvdXBcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fZm9ybUdyb3VwKSA/IHRoaXMuX2Zvcm1Hcm91cCA6IHRoaXMuZW52LmN1cnJlbnRGb3JtO1xuICAgIH1cblxuICAgIHNldCBmb3JtR3JvdXAgKHZhbHVlOiBGb3JtR3JvdXApXG4gICAge1xuICAgICAgICB0aGlzLl9mb3JtR3JvdXAgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgd2UgY2FuIHBhc3MgZmllbGQgdHlwZSBhcyBhIGJpbmRpbmcgdG8gdGhlIGNvbXBvbmVudHMuIGUuZy4gSW5wdXRGaWVsZCBuZWVkXG4gICAgICogc3VjaCB0eXBlIHRvIGNvcnJlY3RseSByZW5kZXIgaW5wdXQgdHlwZT10ZXh0LCBudW1iZXJcbiAgICAgKlxuICAgICAqIHRvZG86IGlzIHRoaXMgbmVlZGVkPyBjYW4gd2UgbWF5YmUgcGFzcyB0aGlzIHRvIHRoZSBmb3JtUm93P1xuICAgICAqL1xuICAgIGNhblNldFR5cGUgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIHdyaXRlVmFsdWUgKHZhbHVlOiBhbnkpXG4gICAge1xuXG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZSAoZm46IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZCAoZm46IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RG9tU2FuaXRpemVyfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSBjb21wb25lbnQgcmVuZGVyaW5nIHZhbHVlcyBpbiB0aGUgcmVhZCBvbmx5IG1vZGUuIEp1c3QgbmVlZGVkIHNvbWUgY29tcG9uZW50IHVzZWRcbiAqIHRvIHJlbmRlciBTdHJpbmdzIGluIHJlYWQgb25seSBtb2RlXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICpcbiAqIFVzaW5nIGl0IGluc2lkZSBmb3JtIGNvbnRhaW5lciBhbG9uZyB3aXRoIGxhYmVsXG4gKlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgIHNlbGVjdG9yOiAndXNlckluZm8nICxcbiAqICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgW2VkaXRhYmxlXT1cImZhbHNlXCIgPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbmFtZV09XCJmaWVsZE5hbWVcIiAgW2xhYmVsXT1cImxhYmVsXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiA+PC9hdy1zdHJpbmc+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgICB9KVxuICogICAgICAgICAgZXhwb3J0IGNsYXNzIFVzZXJQcm9maWxlQ29tcG9uZW50XG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgdGV4dCc7XG4gKiAgICAgICAgICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICAgICAgICAgICAgICBmaWVsZE5hbWU6IHN0cmluZyA9ICdmaXJzdE5hbWUnO1xuICogICAgICAgICAgICAgIGxhYmVsOiBzdHJpbmcgPSAnTXkgTmFtZSc7XG4gKiAgICAgICAgICAgICAgcmVxdWlyZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICAgICAgICAgIGVkaXRpbmc6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICAgICAgICAgIGxhYmVsc09uVG9wOiBib29sZWFuID0gZmFsc2U7XG4gKlxuICogICAgICAgICAgfVxuICpcbiAqICBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBodG1sIHRhZ3MuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN0cmluZycsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ3LXN0cmluZy1maWVsZFwiIFtpbm5lckhUTUxdPVwidmFsdWVcIj48L3NwYW4+XG4gICAgYCxcbiAgICBzdHlsZXM6IFtgLnctc3RyaW5nLWZpZWxke2Rpc3BsYXk6aW5saW5lLWJsb2NrfWBdXG59KVxuZXhwb3J0IGNsYXNzIFN0cmluZ0NvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogIFZhbHVlIHRvIGJlIGludGVycG9sYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZyA9ICcnO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgfVxuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdEh0bWwodGhpcy5fdmFsdWUpO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1N0cmluZ01hcH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBBIGNsYXNzIGhvbGRpbmcgYSByZWZlcmVuY2VzIHRvIGNvbXBvbmVudHMuIFRoZSBtZXRob2RzIGFyZSBzZWxmLWV4cGxhbmF0b3J5LlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbXBvbmVudFJlZ2lzdHJ5XG57XG4gICAgcHJpdmF0ZSBfbmFtZVRvVHlwZTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgaW5pdGlhbGl6ZShyZWZlcmVuY2VzOiBhbnkpOiBQcm9taXNlPGFueT5cbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJUeXBlcyhyZWZlcmVuY2VzKTtcbiAgICAgICAgbGV0IHByb21pc2U6IFByb21pc2U8YW55PiA9IG5ldyBQcm9taXNlKChyZXNvbHZlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcblxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJUeXBlKG5hbWU6IHN0cmluZywgdHlwZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWVUb1R5cGUuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lVG9UeXBlLnNldChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJUeXBlcyhyZWZlcmVuY2VzOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIWlzU3RyaW5nTWFwKHJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhyZWZlcmVuY2VzKS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUeXBlKG5hbWUsIHJlZmVyZW5jZXNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGdldCBuYW1lVG9UeXBlKCk6IE1hcDxzdHJpbmcsIGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lVG9UeXBlO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBpc0JsYW5rLCBpc1ByZXNlbnQsIE1hcFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTdHJpbmdDb21wb25lbnR9IGZyb20gJy4uL3dpZGdldHMvc3RyaW5nL3N0cmluZy5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21wb25lbnRSZWZlcmVuY2V9IGZyb20gJy4vY29tcG9uZW50LXJlZmVyZW5jZSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcblxuLyoqXG4gKiB0aGlzIGlzIHNwZWNpZmljIGltcG9ydCB0byB3ZSBjYW4gdXNlIGNvbXBvbmVudHMgYXMgY29tcG9uZW50c1t0eXBlbmFtZV0gYW5kICBnZXQgYmFjayBhXG4gKiB0eXBlLlxuICogSSBjb3VsZCBub3QgZmluZCBhbnkgYmV0dGVyIGR5bmFtaWMgd2F5IHVwIHRvIG5vd1xuICovXG4vKipcbiAqICBgSW5jbHVkZUNvbXBvbmVudGAgZGlyZWN0aXZlIGR5bmFtaWNhbGx5IGluc3RhbnRpYXRlIGFuZCBpbnNlcnQgYSBjb21wb25lbnRzIGludG8gdGhlIHNjcmVlblxuICogYmFzZWQgb24gdGhlIG5hbWUuIEl0IGNhbiBhY2NlcHRzIGJpbmRpbmdzIGFzIHdlbGwgd2hpY2ggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIGFuZCBhcHBsaWVkXG4gKiB0byB0aGUgY29tcG9uZW50XG4gKlxuICogICMjIyB1c2FnZTpcbiAqXG4gKiAgSW5zdGVhZCBvZiBpbnNlcnRpbmcgY29tcG9uZW50IGluIHRoZSB3YXk6XG4gKlxuICogIGBgYFxuICogICAgPHRleHRmaWVsZCB2YWx1ZT1cInNvbWUgdmFsdWVcIj5cbiAqXG4gKiAgYGBgXG4gKlxuICogIHlvdSBjYW4gZG8gc28gZHluYW1pY2FsbHkgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1pbmNsdWRlLWNvbXBvbmVudCAnVGV4dGZpZWxkQ29tcG9uZW50JyBbYmluZGluZ3NdPWJpbmRpbmdzID48L2F3LWluY2x1ZGUtY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogVGhpcyBpcyB0aGUgbWFpbiBidWlsZGluZyBibG9jayB0byBkeW5hbWljYWxseSBnZW5lcmF0ZWQgVUkuXG4gKlxuICpcbiAqIFRvZG86IEN1cnJlbnRseSB0aGUgd2F5IEFuZ3VsYXIgQVBJIHdvcmsgYW5kIHdlIHVzZSBpdCB0byBjcmVhdGUgcHJvZ3JhbWF0aWNhbGx5IGNvbXBvbmVudHNcbiAqIGlzIHRvbyBjb21wbGV4dCB3ZSBuZWVkIHRvIGNyZWF0ZSBldmVyeXRoaW5nIDMgZGlmZmVyZW50IGNhbGxzIHRvIHBsYWNlIGEgY29tcG9uZW50IHRvIHRoZVxuICogY29udGFpbmVyLiBXaGF0IEkgd2FudCBpcyBpcyB0byBjcmVhdGUgc29tZSBraW5kIG9mIHJlcHJlc2VudGF0aW9uIG9mIENvbnRhaW5lckVsZW1lbnQgYW5kIHRoaXNcbiAqIGNhbiBiZSBhbHNvIHBhcmVudCBmb3Igb3VyIEJhc2VDb21wb25lbnQgd2l0aCBtZXRob2QgYWRkIGFuZCByZW1vdmUgY29udGVudC4gVGhlbiB3ZSBjb3VsZCBoYXZlXG4gKiBzb21lIEFXQ29udGVudC5cbiAqXG4gKiBlLmcuOiB0byByZXBsYWNlIGFwcGx5Q29udGVudEVsZW1lbnRJZkFueSB3aGVyZSB3ZSBoYXZlIHNldmVyYWwgY2FsbHMgdG8gY3JlYXRlIGFuZCBhZGRcbiAqIGNvbXBvbmVudCB0byB0aGUgdmlldy5cbiAqXG4gKiBgYGB0c1xuICogIGxldCBjb250YWluZXJFbGVtZW50ID0gQVdDb25jcmV0ZVRlbXBsYXRlKHZpZXdDb250YWluZXIsIGZhY3RvcnlSZXNvbHZlcilcbiAqICBjb250YWluZXJFbGVtZW50LmFkZCgnQ2xjayBNZScpXG4gKiBgYGBcbiAqXG4gKiBUbyBhc3NlbWJsZSBkaWZmZXJlbnQgY29tcG9uZW50cyB0b2dldGhlciAtIG5vdCBvbmx5IGFkZGluZyBzdHJpbmcgY29udGVudFxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRlbnQgPSBuZXcgQVdDb250ZW50KEJ1dHRvbkNvbXBvbmVudCwgYmluZGluZ3NNYXApXG4gKiAgY29udGVudC5hZGQoJ0NsaWNrIE1lJyk7XG4gKiAgY29udGFpbmVyRWxlbWVudC5hZGQoY29udGVudClcbiAqXG4gKiBgYGBcbiAqXG4gKiBhZGQgbW9yZSBjb21wb25lbnQgaGllcmFyY2h5OlxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRlbnQgPSBuZXcgQVdDb250ZW50KEhvdmVyQ2FyZENvbXBvbm5ldHMsIGJpbmRpbmdzTWFwKVxuICogIGNvbnRlbnQuYWRkKGNyZWF0ZUxheW91dCgpO1xuICogIGNvbnRhaW5lckVsZW1lbnQuYWRkKGNvbnRlbnQpXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2F3LWluY2x1ZGUtY29tcG9uZW50J1xufSlcbmV4cG9ydCBjbGFzcyBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQsIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdDb250ZW50ID0gJ25nY29udGVudCc7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5nQ29udGVudEVsZW1lbnQgPSAnbmdjb250ZW50RWxlbWVudCc7XG5cbiAgICAvKipcbiAgICAgKiBGdWxsIGNvbXBvbmVudCBuYW1lIGUuZy46IERyb3Bkb3duQ29tcG9uZW50IHdoaWNoIGlzIGdvaW5nIHRvIGJlIGluc2VydGVkLiBXZSBuZWVkIHRvIHRha2VcbiAgICAgKiB0aGlzIG5hbWUgYW5kIHRyYW5zbGF0ZSBpdCBpbnRvIGFjdHVhbCBUWVBFLiBJbiBvcmRlciB0byBkbyB0aGlzIHdlIHVzZSBhIHRyaWNrIHdoZXJlIHdlXG4gICAgICogYWNjZXNzIGFuIElNUE9SVEVEIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4uL2NvbXBvbmVudHMnO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlbiB5b3UgY2FuIHJldHJpZXZlIGEgdHlwZSBieSBqdXN0IGNvbXBvbmVudHNbPFN0cmluZyBMaXRlcmFsID5dID0+IENvbXBvbmVudCBUWVBFXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBiaW5kaW5ncyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbnRvIHRoZSBjb21wb25lbnQgd2hlbiBpbnN0YW50aWF0ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByb3RlY3RlZCBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY3JlYXRlZCBjb21wb25lbnQgcmVmZXJlbmNlIHVzaW5nIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci4gV2UgdXNlIHRoaXMgdG8gYWNjZXNzXG4gICAgICogdGhlIGFjdHVhbCBjb21wb25lbnQgaW5zdGFuY2UgYW5kIEVsZW1lbnQgUmVmZXJlbmNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRDb21wb25lbnQ6IENvbXBvbmVudFJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogSSB1c2UgdGhpcyBmbGFnIHRvIGlkZW50aWZ5IHRoYXQgY29tcG9uZW50IGlzIHJlbmRlcmluZyBmb3IgZmlyc3QgdGltZSBvciBpdHMgdXBkYXRlZCBkdXJpbmdcbiAgICAgKiBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE5vdCBzdXJlIGlmIHdlIG5lZWQgdGhpcywgYnV0IHdhbnQgdG8ga2VlcCBpdCBoZXJlIG9yIG1heWJlIG1vdmUgaXQgdG8gc29tZSBzZXJ2aWNlIHNvIHdlXG4gICAgICogY2FuIGNhY2hlIGNyZWF0ZWQgY29tcG9uZW50cyBhbmQgbWF5YmUgcmV1c2UgdGhlbS5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjb21wb25lbnRSZWZlcmVuY2VzOiBNYXA8c3RyaW5nLCBDb21wb25lbnRSZWZlcmVuY2U+ID1cbiAgICAgICAgbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudFJlZmVyZW5jZT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogTmVlZCB0byBjYWNoZSB0aGUgcmVzb2x2ZWQgY29tcG9uZW50IHJlZmVyZW5jZSBzbyB3ZSBkb250IGNhbGwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogZXZlcnl0aGluZyB3ZSB3YW50IHRvIHJlZnJlc2ggYSBzY3JlZW5cbiAgICAgKi9cbiAgICByZXNvbHZlZENvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmZXJlbmNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgcHVibGljIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgY29tcFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSlcbiAgICB7XG5cbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcblxuICAgICAgICB0aGlzLmluaXRSZW5kZXJJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgLy8gdG9kbzogY2hlY2sgaWYgdGhpcyB0aGUgcmlnaHQgbGlmZWN5Y2xlIGNhbGxiYWNrLCB0aGlzIGlzIGNhbGxlZCBvbmx5IG9uY2UgYW5kIHlvdSB3YW50XG4gICAgICAgIC8vIHRvIHByb2JhYmx5IGxpc3RlbiBmb3IgY2hhbmdlcywgYW5kIGNoYW5nZSBkZWN0aW9uIGRlY2lkZSB0aGVyZSBpcyBzb21lIGNoYW5nZSBhbmQgd2VcbiAgICAgICAgLy8gbmVlZCB0byByZS1kcmF3IHRoZSB2aWV3XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB0aGlzLmRvUmVuZGVyQ29tcG9uZW50KCk7XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWyduYW1lJ10pICYmXG4gICAgICAgICAgICAoY2hhbmdlc1snbmFtZSddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1snbmFtZSddLnByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9SZW5kZXJDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgYW5kIHJlcG9zaXRpb24gRE9NIGVsZW1lbnQgYm90aCBmb3Igd3JhcHBlciBhbmRcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICB0aGlzLmNyZWF0ZVdyYXBwZXJFbGVtZW50SWZBbnkoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250ZW50RWxlbWVudElmQW55KCk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIHJlc29sdmUgYWRkaXRpb25hbCBjb21wb25lbnQgYW5kIHdyYXAgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqIEp1c3QgbGlrZSByZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKSB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSBleGVjdXRlZCBhZnRlciBhbGxcbiAgICAgKiBpcyBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCAoaW5zaWRlIHRoZSBuZ0FmdGVyVmlld0luaXQoKSApXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlV3JhcHBlckVsZW1lbnRJZkFueSgpOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBjb21wb25lbnQgaW50byBhY3R1YWwgVmlldyBDb250YWluZXIuIFRoZSBwcm9jZXNzIGdvZXMgYXMgdGhpcy5cbiAgICAgKiAgMS4gV2UgcmV0cmlldmUgY29tcG9uZW50IFR5cGUgYmFzZWQgb24gdGhlIGNvbXBvbmVudCBuYW1lLCB3aGljaCBjcmVhdGVzIGNvbXBvbmVudFJlZlxuICAgICAqICAyLiBQbGFjZSB0aGUgY29tcG9uZW50IG9udG8gdGhlIHNjcmVlblxuICAgICAqICAzLiBSZWFkIGNvbXBvbmVudCBtZXRhZGF0YSwgbWFpbmx5IElOUFVUcyBhbmQgYXBwbHkgYmluZGluZ3MgZm9yIGVhY2ggb2YgdGhlbVxuICAgICAqICA0LiBNYW51YWxseSBzcGluIGNoYW5nZSBkZXRlY3Rpb24gdG8gdXBkYXRlIHRoZSBzY3JlZW4uIE1haW5seSBmb3IgY2FzZSB3aGVyZSBJIG5lZWQgdG9cbiAgICAgKiByZWRyYXcgYSBzY3JlZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZG9SZW5kZXJDb21wb25lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wbGFjZVRoZUNvbXBvbmVudCgpO1xuICAgICAgICAvLyB0aGlzLmN1cnJlbnRDb21wb25lbnQuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0YWNoKCk7XG5cbiAgICAgICAgdGhpcy5hcHBseUJpbmRpbmdzKHRoaXMuY29tcG9uZW50UmVmZXJlbmNlKCksIHRoaXMuY3VycmVudENvbXBvbmVudCwgdGhpcy5iaW5kaW5ncyk7XG4gICAgICAgIC8vIHRoaXMuY3VycmVudENvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICAgICAgLy8gU3RpbGwgbm90IHN1cmUgYWJvdXQgdGhpcyB3aGF0IGFsbCBJIHNob3VsZCByZWxlYXNlIGhlcmUuXG4gICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudC5vbkRlc3Ryb3koKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcy5iaW5kaW5ncy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdGhpcy5iaW5kaW5ncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUGxhY2UgYWN0dWFsIGNvbXBvbmVudCBvbnRvIHRoZSBzY3JlZW4gdXNpbmcgVmlld0NvbnRhaW5lclJlZlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBsYWNlVGhlQ29tcG9uZW50KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCByZWZlcmVuY2UgPSB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KHJlZmVyZW5jZS5yZXNvbHZlZENvbXBGYWN0b3J5KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW5zZXJ0aW5nIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGhhdmUgYSBjb250ZW50IGxpa2UgZS5nLiBoeXBlcmxpbmsgb3IgYnV0dG9uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgIDxidXR0b24+IE1ZIE5HIENPTlRFTlQgPC9idXR0b24+XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgdGhpcyBtZXRob2QgYXBwbGllcyBhbmQgaW5zZXJ0IGEgY2hpbGQgY29udGVudCBpbnRvIHRoZSBtYWluIGNvbXBvbmVudC4gVGhpcyBtZXRob2QgaW5zZXJ0XG4gICAgICogYSBzaW1wbGUgc3RyaW5nLiBXZSBhcmUgbm90IHdyYXBwaW5nIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIGFub3RoZXIgY29tcG9uZW50IGhlcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG5lZWQgdG8gcnVuIGRldGVjdCBjaGFuZ2VzID8gZGVmYXVsdCBpcyBmYWxzZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVDb250ZW50RWxlbWVudElmQW55KCk6IGJvb2xlYW5cbiAgICB7XG5cbiAgICAgICAgbGV0IGRldGVjdENoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5nQ29udGVudCA9IHRoaXMubmdDb250ZW50KCk7XG4gICAgICAgIGxldCBuZ0NvbnRlbnRFbGVtZW50ID0gdGhpcy5uZ0NvbnRlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQobmdDb250ZW50KSkge1xuICAgICAgICAgICAgbGV0IGF3Q29udGVudENvbXBvbmVudCA9IHRoaXMuZmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN0cmluZ0NvbXBvbmVudCk7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChhd0NvbnRlbnRDb21wb25lbnQsIDApO1xuXG4gICAgICAgICAgICAoPFN0cmluZ0NvbXBvbmVudD5jb21wb25lbnQuaW5zdGFuY2UpLnZhbHVlID0gbmdDb250ZW50O1xuICAgICAgICAgICAgbGV0IGF3Q29udGVudENvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBhd0NvbnRlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBkZXRlY3RDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQobmdDb250ZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb250ZW50IEVsZW1lbnQ6ICcsIG5nQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRldGVjdENoYW5nZXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGEgTkcgQ29udGVudCBmcm9tIGJpbmRpbmcgbGlzdCBhbmQgcmVtb3ZlIGl0IHNvIGl0IGl0cyBub3QgcHJlcGFnYXRlZCBkb3duIHdoZW5cbiAgICAgKiBhcHBseWluZyBvdGhlciBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBuZ0NvbnRlbnQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgY29udGVudDogYW55O1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbnRlbnQgPSB0aGlzLmJpbmRpbmdzLmdldChJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgbmdDb250ZW50RWxlbWVudCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBjb250ZW50OiBhbnk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29udGVudCA9IHRoaXMuYmluZGluZ3MuZ2V0KEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50RWxlbWVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gY29udmVydCBhIGNvbXBvbmVudCBuYW1lIHRvIGFjdHVhbCBhIHR5cGUgYW5kIHRoZW4gdXNlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxuICAgICAqIHRvIGluc3RhbnRpYXRlIGEgYSBjb21wb25lbnQgYW5kIHNhdmUgaXRzIGluZm9ybWF0aW9uIGludG8gb3VyIGNvbXBvbmVudCByZWZlcmVuY2VzLiBUaGVcbiAgICAgKiByZWFzb24gd2h5IHdlIGhhdmUgdGhpcyBjb21wb25lbnQgcmVmZXJlbmNlIGlzIHdlIG5lZWQgdG8gc3RvcmUgQW5ndWxhcidzIGNvbXBvbmVudCBtZXRhZGF0YVxuICAgICAqIHNvIHdlIGNhbiBpdGVyYXRlIHRocnUgYWxsIHRoZSBpbnB1dHMgYW5kIGJpbmQgdGhlbSB0byB0aGUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIHJldHVybnMge0NvbXBvbmVudFJlZmVyZW5jZX0gYSByZWZlcmVuY2UgcmVwcmVzZW50aW5nIGEgY29tcG9lbnQgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZmVyZW5jZSgpOiBDb21wb25lbnRSZWZlcmVuY2VcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyVHlwZSA9IHRoaXMucmVzb2x2ZUNvbXBvbmVudFR5cGUoKTtcbiAgICAgICAgbGV0IGNvbXBvbmVudEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55PiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY3VyclR5cGUpO1xuXG4gICAgICAgIGxldCBjb21wb25lbnRNZXRhOiBDb21wb25lbnQgPSB0aGlzLnJlc29sdmVEaXJlY3RpdmUoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIGxldCBjb21wUmVmZXJlbmNlOiBDb21wb25lbnRSZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY29tcG9uZW50TWV0YSxcbiAgICAgICAgICAgIHJlc29sdmVkQ29tcEZhY3Rvcnk6IGNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBjdXJyVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IHRoaXMubmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzb2x2ZWRDb21wb25lbnRSZWYgPSBjb21wUmVmZXJlbmNlO1xuICAgICAgICByZXR1cm4gY29tcFJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJ1IENvbXBvbmVudE1ldGFkYXRhIEBJbnB1dHMoKSBhbmQgY2hlY2sgaWYgd2UgaGF2ZSBhdmFpbGFibGUgYmluZGluZyBpbnNpZGUgdGhlXG4gICAgICogJ3RoaXMuYmluZGluZ3MnXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFwcGx5QmluZGluZ3MoY1JlZjogQ29tcG9uZW50UmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3M6IE1hcDxzdHJpbmcsIGFueT4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgaW5wdXRzOiBzdHJpbmdbXSA9IGNSZWYubWV0YWRhdGEuaW5wdXRzO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGlucHV0cykgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNob3VsZCB3ZSBkbyBhbnkgdHlwZSBjb252ZXJzaW9uP1xuICAgICAgICBNYXBXcmFwcGVyLml0ZXJhYmxlKGJpbmRpbmdzKS5mb3JFYWNoKCh2LCBrKSA9PlxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcG9uZW50Lmluc3RhbmNlW2tdKSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBjb21wb25lbnQgVHlwZSBiYXNlZCBvbiB0aGUgc3RyaW5nIGxpdGVyYWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGNvbXBvbmVudCB0eXBlIHVzZWQgYnkgYENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcmBcbiAgICAgKlxuICAgICAqIHRvZG86IHJlbmFtZSB0aGUgbWV0aG9kIHNvIGl0cyBjbGVhciB0aGF0IGl0IHJldHVybnMgY29tcG9uZW50IHR5cGUgYmFzZWQgb24gc3RyaW5nLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZXNvbHZlQ29tcG9uZW50VHlwZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIGxldCBjb21wb25lbnRUeXBlID0gdGhpcy5jb21wUmVnaXN0cnkubmFtZVRvVHlwZS5nZXQodGhpcy5uYW1lKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhjb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCB0aGlzLm5hbWUgKyAnIGNvbXBvbmVudCBkb2VzIG5vdCBleGlzdHMuIENyZWF0ZSBEdW1teSBDb21wb25lbnQgaW5zdGVhZCcgK1xuICAgICAgICAgICAgICAgICcgb2YgdGhyb3dpbmcgdGhpcyBlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRUeXBlO1xuICAgIH1cblxuXG4gICAgcHJvdGVjdGVkIHJlc29sdmVEaXJlY3RpdmUoY29tcEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55Pik6IENvbXBvbmVudFxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBNZXRhOiBDb21wb25lbnQgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBGYWN0b3J5LmlucHV0cykgJiYgY29tcEZhY3RvcnkuaW5wdXRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29tcEZhY3RvcnkuaW5wdXRzLmZvckVhY2goKGlucHV0OiB7cHJvcE5hbWU6IHN0cmluZywgdGVtcGxhdGVOYW1lOiBzdHJpbmd9KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBNZXRhLmlucHV0cy5wdXNoKGlucHV0LnByb3BOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjb21wRmFjdG9yeS5vdXRwdXRzKSAmJiBjb21wRmFjdG9yeS5vdXRwdXRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29tcEZhY3Rvcnkub3V0cHV0cy5mb3JFYWNoKChvdXRwdXQ6IHtwcm9wTmFtZTogc3RyaW5nLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZ30pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcE1ldGEub3V0cHV0cy5wdXNoKG91dHB1dC5wcm9wTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcE1ldGE7XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VycmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmlld0NvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmN1cnJlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N0cmluZ1dyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIEVycm9yIE1hbmFnZXIgaXMgYSBzZXJ2aWNlIHVzZWQgYnkgRm9ybXMgY29tcG9uZW50cyB0byBtYXAgZXJyb3IgY29kZXMgaW50byBtZWFuaW5nZnVsIG1lc3NhZ2VzLlxuICogQ3VycmVudGx5IGl0IGRvZXMgbm90IGhhdmUgbXVjaCBidXQgb25jZSB3ZSBwbHVnIGluIGxvY2FsaXphdGlvbiBpdCB3aWxsIG1ha2UgbW9yZSBzZW5zZVxuICpcbiAqXG4gKiB0b2RvOiBPbmNlIG5nLXRyYW5zbGF0ZSBpcyBpbXBsZW1lbnRlZCByZXBsYWNlIHRoaXMgd2l0aCBuZy10cmFuc2xhdGUgZnVuY3Rpb25hbGl0eSBzbyB3ZSBjYW5cbiAqIGV4dGVybmFsaXplIHRoZXNlIG1lc3NhZ2VzIGludG8gbG9jYWxlIGZpbGVzLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEVycm9yTWFuYWdlclNlcnZpY2VcbntcbiAgICBtZXNzYWdlczoge1trZXk6IHN0cmluZ106IGFueX07XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0ge1xuICAgICAgICAgICAgJ3JlcXVpcmVkJzogJ1JlcXVpcmVkIGZpZWxkJyxcbiAgICAgICAgICAgICdtaW5sZW5ndGgnOiAnRmllbGQgZG9lcyBub3QgbWVldCBtaW5pbXVtIGxlbmd0aCcsXG4gICAgICAgICAgICAnbWF4bGVuZ3RoJzogJ0ZpZWxkIGRvZXMgbm90IG1lZXQgbWF4aW11bSBsZW5ndGgnLFxuICAgICAgICAgICAgJ2N1c3RvbU1zZyc6ICclcycsXG4gICAgICAgICAgICAnbWV0YXZhbGlkJzogJyVzJ1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZXJyb3JNZXNzYWdlKHZhbGlkYXRvck5hbWU6IHN0cmluZywgdmFsaWRhdG9yVmFsdWU/OiBhbnkpXG4gICAge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbdmFsaWRhdG9yTmFtZV07XG4gICAgICAgIGlmIChTdHJpbmdXcmFwcGVyLmNvbnRhaW5zKG1lc3NhZ2UsICclcycpKSB7XG4gICAgICAgICAgICAvLyB0b2RvOiB1c2UgbmctdHJhbnNsYXRlIHdpdGggcHJvcGVyIG1lc3NhZ2UgZm9ybWF0dGluZ1xuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nV3JhcHBlci5yZXBsYWNlKG1lc3NhZ2UsICclcycsIHZhbGlkYXRvclZhbHVlLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2x9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RXJyb3JNYW5hZ2VyU2VydmljZX0gZnJvbSAnLi4vLi4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuXG4vKipcbiAqIEVycm9yTWVzc2FnZXNDb21wb25lbnQgaXMgdXNlZCBieSBmb3JtJ3MgY29tcG9uZW50IGxpa2UgRm9ybVJvdyB0byBwcmludCBpdHMgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKiBJdHMgIGJhc2VkIG9uIE1vZGVsRHJpdmVuIChSZWFjdGl2ZSBmb3JtcykgYW5kIGl0IHJlYWRzIGVycm9ycyBmcm9tIEZvcm1Db250cm9sXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYS1lcnJvci1tZXNzYWdlcycsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbWFsbCAqbmdJZj1cImhhc01lc3NhZ2UoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInVpLWctMTIgdWktbWVzc2FnZSB1aS1tZXNzYWdlcy1lcnJvciB1aS1jb3JuZXItYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBlcnJvck1zZyB9fVxuICAgICAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgICBzdHlsZXM6IFtgYF1cbn0pXG5leHBvcnQgY2xhc3MgRXJyb3JNZXNzYWdlc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBmb3JtIEZvcm1Db250cm9sbCB0byBjaGVjayBmb3IgRXJyb3JzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250cm9sOiBGb3JtQ29udHJvbDtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlcnJNYW5hZ2VyOiBFcnJvck1hbmFnZXJTZXJ2aWNlKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgfVxuXG5cbiAgICBoYXNNZXNzYWdlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBtc2cgPSB0aGlzLmVycm9yTXNnO1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KG1zZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBtZXNzYWdlcyBpZiBhbnkgcmVnaXN0ZXJlZCBieSBhZGRlZCB2YWxpZGF0b3JzXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgZXJyb3JNc2coKTogc3RyaW5nXG4gICAge1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gdGhpcy5jb250cm9sLmVycm9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC5lcnJvcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSAmJiB0aGlzLmNvbnRyb2wudG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVyck1hbmFnZXIuZXJyb3JNZXNzYWdlKHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLmVycm9yc1twcm9wZXJ0eU5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2hvdyBlcnJvcnM/IFdlIGN1cnJlbnRseSBzaG93cyBlcnJvcnMgaWYgdGhlIGNvbnRyb2wgaXMgbm90IHZhbGlkLCBpdCB3YXMgdG91Y2hlZCBieSB1c2VyLlxuICAgICAqIE1vc3Qgb2YgdGhlIHR5cGUgb24gYmx1ciBldmVudCAgYW5kIGF0IGxhc3QgaXRzIG5vdCBwcmlzdGluZSBhbnltb3JlIChpdHMgZGlydHkpXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93RXJyb3JzKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250cm9sLnZhbGlkICYmICF0aGlzLmNvbnRyb2wucHJpc3RpbmUgJiYgdGhpcy5jb250cm9sLnRvdWNoZWQ7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50RmFjdG9yeSxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIEluamVjdGFibGUsXG4gICAgVHlwZSxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIE1vZGFsIHNlcnZpY2UgaXMgdXNlZCB0byB0byBjcmVhdGUgbW9kYWwgZGlhbG9ncy4gSXQgY3JlYXRlcyBtb2RhbCBkaWFsb2dzIGR5bmFtaWNhbGx5LlxuICogVGhlIHNlcnZpY2UgYWxzbyBrZWVwcyB0cmFjayBvZiB0aGUgY3JlYXRlZCBtb2RhbCBkaWFsb2cgYW5kIGNhbiBjbG9zZSBpdCBieSBjYWxsaW5nIHRoZVxuICogc2VydmljZSdzIGNsb3NlKClcbiAqXG4gKiBNb2RhbCBzZXJ2aWNlIHJlcXVpcmVzIGEgVmlld0NvbnRhaW5lciB0byBpbnNlcnQgbmV3bHkgY3JlYXRlZCBtb2RhbHMuIFRoaXMgaXMgdGFrZW4gY2FyZVxuICogYnkgdGhlIE1vZGFsQ29tcG9uZW50LlxuICpcbiAqIFVzYWdlOlxuICogICAgIEFkZCAgIDxhdy1tb2RhbD48L2F3LW1vZGFsPiAgaW50byB5b3VyIGFwcGxpY2F0aW9uIG1haW4gaHRtbC4gSXQgbmVlZHMgdG8gYmUgb24gZXZlcnlcbiAqICAgICBwYWdlIHdoZXJlIGEgbW9kYWwgZGlhbG9nIHdpbGwgYXBwZWFyLlxuICpcbiAqICAgIDEuICBQb3B1cCBhIGRpYWxvZyB3aXRob3V0IGNyZWF0aW5nIHlvdXIgb3duIGNvbXBvbmVudC5cbiAqICAgICAgICBVc2UgdGhlIGV4aXN0aW5nIERpYWxvZ0NvbXBvbmVudCBpbiB3aWRnZXRzLlxuICpcbiAqICAgICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48RGlhbG9nQ29tcG9uZW50PihEaWFsb2dDb21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdNeSBQb3B1cCBUaXRsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICdNeSBQb3B1cCBCb2R5J1xuICogICAgICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgQ3JlYXRpbmcgeW91ciBvd24gRGlhbG9nIENvbXBvbmVudCB0byBwb3B1cC5cbiAqXG4gKiAgICAgICAgIGxldCBjb21wb25lbnRSZWYgPSB0aGlzLm1vZGFsU2VydmljZS5vcGVuPE15RGlhbG9nQ29tcG9uZW50PihNeURpYWxvZ0NvbXBvbmVudCxcbiAqIHtpbnB1dHN9KTtcbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctbXlkaWFsb2cnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nIChvbkNsb3NlKT1cImNsb3NlUG9wdXAoKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICN0aXRsZVRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+PGkgY2xhc3M9XCJmYSBmYS1lbnZpcmFcIiA+PC9pPlRoaXMgaXMgbXlcbiAqICAgICBUaXRsZSA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNib2R5VGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj48aSBjbGFzcz1cImZhIGZhLWVudmlyYVwiID48L2k+VGhpcyBpcyBteVxuICogICAgIEJvZHkgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGlhbG9nPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICB9KVxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlEaWFsb2dDb21wb25lbnQgZXh0ZW5kcyBEaWFsb2dDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICogICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgIG5nT25Jbml0KCkgeyB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjbG9zZVBvcHVwKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2UuY2xvc2UoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9kYWxTZXJ2aWNlXG57XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHN0YXRpYyBsaXN0IG9mIG91dHB1dCBwYXJhbWV0ZXIgZnJvbSBEaWFsb2csIENvbmZpcm1hdGlvbiBjb21wb25lbnRzXG4gICAgICogdGhhdCBuZWVkcyB0byBiZSBoYW5kbGVkLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgT1VUUFVUX1BBUkFNRVRFUlM6IHN0cmluZ1tdID0gWydvbkNsb3NlJywgJ29uQ29uZmlybScsICdvbkNhbmNlbCddO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgZm9yIHRoZSBuZXdseSBjcmVhdGVkIG1vZGFsLiBUaGlzIGlzIHBhc3NlZCBpbiB0aHJvdWdoIHRoZVxuICAgICAqIHJlZ2lzdGVyVmlld0NvbnRhaW5lclJlZigpLlxuICAgICAqL1xuICAgIHByaXZhdGUgdmNSZWY6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgICAvKipcbiAgICAgKiBTdG9yaW5nIHRoZSBjcmVhdGVkIG1vZGFsIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5zdGFuY2U6IGFueTtcblxuICAgIC8qKlxuICAgICAqIERJIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBiZSB1c2VkIHRvIGNyZWF0ZSBtb2RhbCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2ZyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcilcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFBsYWNlSG9sZGVyIGZvciBtb2RhbCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2Y1JlZlxuICAgICAqL1xuICAgIHJlZ2lzdGVyVmlld0NvbnRhaW5lclJlZih2Y1JlZjogVmlld0NvbnRhaW5lclJlZik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMudmNSZWYgPSB2Y1JlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgbW9kYWwgZGlhbG9nIGJ5IGR5bmFtaWNhbGx5IGNyZWF0aW5nIHRoZSBjb21wb25lbnQgYW5kIGFkZGluZyBpdCB0byB2Y1JlZi5cbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW48VD4oY29tcG9uZW50OiBUeXBlPFQ+LCBwYXJhbWV0ZXJzPzogYW55KTogQ29tcG9uZW50UmVmPFQ+XG4gICAge1xuICAgICAgICBjb25zdCBjZjogQ29tcG9uZW50RmFjdG9yeTxUPiA9IHRoaXMuY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudCk7XG4gICAgICAgIGxldCBjb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxUPiA9IHRoaXMudmNSZWYuY3JlYXRlQ29tcG9uZW50KGNmKTtcblxuICAgICAgICAvLyBBdXRvIHNldCB2aXNpYmxpdHkgdG8gdHJ1ZS4gU28gdGhhdCB0aGUgRGlhbG9nIHdpbGwgZGlzcGxheVxuICAgICAgICBwYXJhbWV0ZXJzID0gKHBhcmFtZXRlcnMpID8gcGFyYW1ldGVycyA6IHt9O1xuICAgICAgICBwYXJhbWV0ZXJzWyd2aXNpYmxlJ10gPSB0cnVlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBvdXRwdXQgcGFyYW1ldGVycy5cbiAgICAgICAgTW9kYWxTZXJ2aWNlLk9VVFBVVF9QQVJBTUVURVJTLmZvckVhY2goKHBhcmFtKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAoPGFueT5jb21wb25lbnRSZWYuaW5zdGFuY2UpW3BhcmFtXS5zdWJzY3JpYmUocGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbWV0ZXJzW3BhcmFtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb21wb25lbnRSZWYuaW5zdGFuY2UsIHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIC8vIGhhZCB0byBjYXN0IGl0IGluIG9yZGVyIHRvIGF2b2lkIGFueSBpbmRleCBFcnJvclxuICAgICAgICAvLyBBdHRhY2ggYSBkZXN0cm95IG1ldGhvZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQuXG4gICAgICAgICg8YW55PmNvbXBvbmVudFJlZi5pbnN0YW5jZSlbJ2Rlc3Ryb3knXSA9ICgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNhdmUgdGhlIGluc3RhbmNlLCBzbyBpdCBjYW4gYmUgZGVzdHJveWVkIGxhdGVyLlxuICAgICAgICB0aGlzLmluc3RhbmNlID0gY29tcG9uZW50UmVmO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGluZyBjbG9zZSgpIHdpbGwgcmVtb3ZlIHRoZSBtb2RhbCBmcm9tIHZpZXcuXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBPbkluaXQsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge01vZGFsU2VydmljZX0gZnJvbSAnLi4vbW9kYWwuc2VydmljZSc7XG5cblxuLyoqXG4gKiBQbGFjZSBob2xkZXIgZm9yIGFsbCBtb2RhbCBkaWFsb2dzLiBUaGlzIGNvbXBvbmVudCB3b3JrcyB3aXRoIHRoZSBtb2RhbFNlcnZpY2UgYnkgcHJvdmlkaW5nXG4gKiBhIHBsYWNlIGhvbGRlciBmb3IgaXQgdG8gaW5qZWN0IERpYWxvZyBjb21wb25lbnQgaW50by5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1tb2RhbCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICNtb2RhbD48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYGBdXG59KVxuZXhwb3J0IGNsYXNzIE1vZGFsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICBAVmlld0NoaWxkKCdtb2RhbCcsIHtyZWFkOiBWaWV3Q29udGFpbmVyUmVmfSlcbiAgICB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSlcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2UucmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKHRoaXMudmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGN1cnJlbmN5IGZvcm1hdHRlciB3aWxsIGlnbm9yZSBudWxsIGFuZCBlbXB0eSBzdHJpbmcgZm9yIHZhbHVlLlxuICogSXNzdWUgOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy84Njk0ICBESSBmYWlscyB3aGVuIGV4dGVuZHMgb3RoZXIgY2xhc3Nlc1xuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2N1cnJlbmN5Rm9ybWF0JyxcbiAgICBwdXJlOiBmYWxzZVxufSlcbmV4cG9ydCBjbGFzcyBDdXJyZW5jeUZvcm1hdFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtXG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGN1cnJlbmN5UGlwZTogQ3VycmVuY3lQaXBlKVxuICAgIHtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgLi4uYXJnczogYW55W10pOiBhbnlcbiAgICB7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgbGV0IGN1cnJlbmN5Q29kZSA9ICdVU0QnLCBzeW1ib2xEaXNwbGF5ID0gdHJ1ZSwgZGlnaXRzID0gJzEuMC0yJztcblxuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY29kZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoY29kZSAmJiBjb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeUNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgY3VycmVuY3lDb2RlLCBzeW1ib2xEaXNwbGF5LCBkaWdpdHMpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSB1dGlsaXR5IGRpcmVjdGl2ZSB0aGF0IGlzIHVzZWQgYnkgTkcgRm9yIGN5Y2xlIGluIHNpdHVhdGlvbiB3aGVyZSB3ZSBuZWVkIHRvIGNhbGwgYVxuICogb3IgZXhlY3V0ZSBzb21lIGxvZ2ljIGFmdGVyIGVhY2ggaXRlcmF0aW9uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW25nRm9yU2V0XSdcbn0pXG5leHBvcnQgY2xhc3MgTmdGb3JTZXREaXJlY3RpdmVcbntcblxuICAgIEBPdXRwdXQoKVxuICAgIG9uSXRlbTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5vbkl0ZW0uZW1pdCgnLS0nKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSBjb252ZW5pZW50IHNlcnZpY2UgdG8gd29yayB3aXRoIHRoZSBkb20uIEFsbCB0aGUgZnV0dXJlIGxvZ2ljIHJlbGF0ZWQgdG8gRE9NIG1hbmlwdWxhdGlvblxuICogb3IgdHJhdmVyc2FsIHNob3VsZCBiZSBwdXQgaW50byB0aGlzIHNlcnZpY2VcbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEb21VdGlsc1NlcnZpY2VcbntcblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdvZXMgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIGJvZHkgYW5kIGNoZWNrcyBpZiB0aGVyZSBpcyBhIGVsZW1lbnQgaWRlbnRpZmllZCBieSBhICdzZWxlY3RvcidcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1BhcmVudCAobmF0aXZlRWxlbWVudDogYW55LCBzZWxlY3Rvcjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNsb3Nlc3QobmF0aXZlRWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBUcmF2ZWxzIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBCT0RZIGFuZCByZXRyaWV2ZSBlbGVtZW50IGlkZW50aWZpZWQgYnkgJ3NlbGVjdG9yJyBvciBOVUxMIGlmXG4gICAgICogbm90IGZvdW5kXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZXN0IChuYXRpdmVFbGVtZW50OiBhbnksIHNlbGVjdG9yOiBzdHJpbmcpOiBhbnlcbiAgICB7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBzZWxlY3Rvci5jaGFyQXQoMCk7XG5cbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBuYXRpdmVFbGVtZW50O1xuXG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudCgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnLicgJiYgcGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoc2VsZWN0b3Iuc3Vic3RyKDEpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnIycgJiYgcGFyZW50Tm9kZS5pZCA9PT0gc2VsZWN0b3Iuc3Vic3RyKDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgdGFnXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBwYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgcGFyZW50Tm9kZS50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFuZ3VsYXIgY29tcG9uZW50IGlzIHJlbmRlcmVkIGFsb25nIHdpdGggTkdDb250ZW50IGl0IGhhcyBpdHMgb3duIF9uZ0NvbnRlbnRfSU5ERVhcbiAgICAgKiB3aGljaCBhbHdheXMgY29ycmVzcG9uZHMgd2l0aCBfbmdob3N0X0lOREVYLCB0aGlzIHdvcmtzIGZpbmUgaWYgd2UgaGF2ZSBhY3R1YWwgY29tcG9uZW50XG4gICAgICogdGhhdCBpcyBhbHJlYWR5IHJlbmRlcmVkLiBJZiB3ZSBhcmUgY3JlYXRpbmcgY29tcG9uZW50IHByb2dyYW1hdGljYWxseSB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICAgKiBpZGVudGlmeSB3aGVyZSB0aGUgYWN0dWFsIG5nLWNvbnRlbnQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBlLmcuIENvbnNpZGVyIGZvbGxvd2luZyBleGFtcGxlOlxuICAgICAqXG4gICAgICpcbiAgICAgKiBCdXR0b24gQ29tcG9uZW50IFRlbXBsYXRlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogIDxzcGFuIGNsYXNzPW15YnV0dG9uVGl0bGU+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZW4geW91IHVzZSBidXR0b24gY29tcG9uZW50IGFzIDxhdy1idXR0b24+Q2xpY2tNZTwvYXctYnV0dG9uPiAgdGhlbiBpdHMgcmVuZGVyZWQgYXNcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhdy1idXR0b24gX25naG9zdF8xMjM+XG4gICAgICogIDxzcGFuIF9uZ2NvbnRlbnRfMTIzIGNsYXNzPW15YnV0dG9uVGl0bGU+Q2xpY2tNZTwvc3Bhbj5cbiAgICAgKiA8L2F3LWJ1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJ1dCB3aXRoIHByb2dyYW1tYXRpYyBBUEkgeW91IGluc3RhbnRpYXRlIEJ1dHRvbiBhbmQgc2luY2UgaXQgY3JlYXRlZCB3aXRob3V0IGEgQ29udGVudCBpdFxuICAgICAqIGxvb2tzIGxpa2UgdGhpcztcbiAgICAgKlxuICAgICAqICBgYGBcbiAgICAgKiA8YXctYnV0dG9uIF9uZ2hvc3RfMTIzPlxuICAgICAqICA8c3BhbiBjbGFzcz1teWJ1dHRvblRpdGxlPjwvc3Bhbj5cbiAgICAgKiA8L2F3LWJ1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZXJlIGRvIHlvdSBwbGFjZSB5b3UgY2hpbGQgKGNvbnRlbnQgY29tcG9uZW50KT8gVGhlcmVmb3JlIHV0aWxpdHkgY3NzIGNsYXNzIHdhcyBjcmVhdGVkXG4gICAgICogdG8gd3JhcCA8bmctY29udGVudD4gdG8gZ2V0IGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gICAgICpcbiAgICAgKiAgYGBgXG4gICAgICogICA8c3BhbiBjbGFzcz1cInUtbmdjb250ZW50XCI+XG4gICAgICogICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICA8L3NwYW4+XG4gICAgICogIGBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydEludG9QYXJlbnROZ0NvbnRlbnQgKHBhcmVudE5hdGl2ZUVsOiBhbnksIGNoaWxkTmF0aXZlRWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IGl0IGFzIGNoaWxkIHRvIHBhcmVudE5hdGl2ZUVsXG4gICAgICAgIGxldCBuZ0NvbnRlbnRQYXJlbnQgPSBwYXJlbnROYXRpdmVFbDtcblxuICAgICAgICBsZXQgZm91bmROZ0NvbnRlbnQgPSBwYXJlbnROYXRpdmVFbC5xdWVyeVNlbGVjdG9yKCcudS1uZ2NvbnRlbnQnKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChmb3VuZE5nQ29udGVudCkpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvdmVyIGEgY2FzZSB3aGVyZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBuZ2NvbnRlbnRzXG4gICAgICAgICAgICBuZ0NvbnRlbnRQYXJlbnQgPSBmb3VuZE5nQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBuZ0NvbnRlbnRQYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGROYXRpdmVFbCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgYnJvd3NlciB3aW5kb3cgd2lkdGggYW5kIGhlaWdodFxuICAgICAqXG4gICAgICovXG4gICAgYnJvd3NlckRpbWVudGlvbnMgKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZXMgZWxlbWVtZW50cyBkaW1lbnNpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBlbGVtZW50RGltZW5zaW9ucyAoZWxlbWVudDogYW55KTogYW55XG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogVW5kZXIgQG9yaWdpbmFsLWxpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50IERyaWZ0eSBDby5cbiAqIGh0dHA6Ly9kcmlmdHkuY29tL1xuICpcbiAqICBNSVQgTGljZW5zZVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKlxuICogQ3JlZGl0IHRvIGRyaWZ0eSBmb3IgdGhpcyBleGNlbGxlbnQgY29tcG9uZW50LiBXZSBoYXZlIGEgc3Ryb25nIG5lZWRzIGZvciBnb29kIGluZmluaXRlXG4gKiBzY3JvbGxpbmcgY29tcG9uZW50IHNvIHRoaXMgaXMgZGVyaXZlZCB3b3JrIGJhc2VkIG9uIHRoaXMgZHJpZnR5IGNvbXBvbmVudCBhcyB3ZSBjYW4gbm90IHJlYWxseVxuICogYnJpbmcgaW4gd2hvbGUgZnJhbWV3b3JrIGFuZCB0aGVpciBjb21wb25lbnQvQVBJLiBJdCB3b3VsZCBiZSB0b28gaGVhdnlcbiAqXG4gKiBDb21wb25lbnQgaXMgdXBkYXRlZCB3aXRoIG5hdGl2ZSBET00gQVBJLiBwbHVzIHNpbXBsaWZpZWQgYnkgcmVtb3ZpbmcgdGhpbmdzXG4gKiB0aGF0IGFyZSBub3QgbmVjZXNzYXJ5IGZvciBvdXIgdXNlY2FzZS4gVXBkYXRlZCBkaXJlY3RpdmUgcHJlZml4IHRvIG1hdGNoIG91ciBndWlkZWxpbmVzXG4gKlxuICpcbiAqXG4gKi9cblxuXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSwgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuXG4vKipcbiAqIFRoZSBJbmZpbml0ZSBTY3JvbGwgYWxsb3dzIHlvdSB0byBwZXJmb3JtIGFuIGFjdGlvbiB3aGVuIHRoZSB1c2VyXG4gKiBzY3JvbGxzIGEgc3BlY2lmaWVkIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbSBvciB0b3Agb2YgdGhlIHBhZ2UuXG4gKlxuICogVGhlIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gdGhlIGBpbmZpbml0ZWAgZXZlbnQgaXMgY2FsbGVkIHdoZW5cbiAqIHRoZSB1c2VyIHNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBkaXN0YW5jZS4gV2hlbiB0aGlzIGV4cHJlc3Npb25cbiAqIGhhcyBmaW5pc2hlZCBpdHMgdGFza3MsIGl0IHNob3VsZCBjYWxsIHRoZSBgY29tcGxldGUoKWAgbWV0aG9kXG4gKiBvbiB0aGUgaW5maW5pdGUgc2Nyb2xsIGluc3RhbmNlLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8ZGl2ICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19IDwvZGl2PlxuICogICA8YXctaW5maW5pdGUtc2Nyb2xsIChvbkxvYWQpPVwiZG9JbmZpbml0ZSgkZXZlbnQpXCI+XG4gKiAgPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFlvdSBjYW4gYWxzbyBzZXQgYSB0aHJlc2hvbGQgdG8gY2hhbmdlIHRoZSBkaXN0YW5jZSB3aGVuIHRoZSBsYXp5IGxvYWQga2lja3NcbiAqIGluLlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxkaXYgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX0gPC9kaXY+XG4gKiAgIDxhdy1pbmZpbml0ZS1zY3JvbGwgKG9uTG9hZCk9XCJkb0luZmluaXRlKCRldmVudClcIiAgW2Rpc3RhbmNlXT1cIicxNSUnXCI+XG4gKiAgPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG4gKlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5maW5pdGUtc2Nyb2xsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LWluZmluaXRlLWxvYWRlci1wYW5lbFwiICpuZ0lmPVwiaXNMb2FkaW5nKClcIj5cbiAgICA8c3BhbiBjbGFzcz1cInNhcC1pY29uIGljb24tc3luY2hyb25pemUgdS1zcGluLWljb25cIj48L3NwYW4+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWluZmluaXRlLWxvYWRlci1wYW5lbHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojZmZmO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMHB4O3otaW5kZXg6MzAwO2JvdHRvbToxMDBweH0udy1pbmZpbml0ZS1sb2FkZXItcGFuZWwgc3Bhbntjb2xvcjojNGE0YTRhO2ZvbnQtc2l6ZToyZW19YF0sXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgX2xhc3RDaGVjazogbnVtYmVyID0gMDtcbiAgICBfbGFzdFNjcm9sbFRvcDogbnVtYmVyID0gMDtcbiAgICBfc2NMc246IGFueTtcbiAgICBfdGhyOiBzdHJpbmcgPSAnMTAlJztcbiAgICBfdGhyUHg6IG51bWJlciA9IDA7XG4gICAgX3RoclBjOiBudW1iZXIgPSAwLjEwO1xuICAgIF9pbml0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBfY29udGVudDogYW55O1xuICAgIF9kb2NCb2R5OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0ZTogc3RyaW5nID0gU1RBVEVfRU5BQkxFRDtcblxuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBUaGUgdGhyZXNob2xkIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbVxuICAgICAqIG9mIHRoZSBjb250ZW50IHRvIGNhbGwgdGhlIGBvbkxvYWRgIG91dHB1dCBldmVudCB3aGVuIHNjcm9sbGVkLlxuICAgICAqIFRoZSB0aHJlc2hvbGQgdmFsdWUgY2FuIGJlIGVpdGhlciBhIHBlcmNlbnQsIG9yXG4gICAgICogaW4gcGl4ZWxzLiBGb3IgZXhhbXBsZSwgdXNlIHRoZSB2YWx1ZSBvZiBgMTAlYCBmb3IgdGhlIGBpbmZpbml0ZWBcbiAgICAgKiBvdXRwdXQgZXZlbnQgdG8gZ2V0IGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBzY3JvbGxlZCAxMCVcbiAgICAgKiBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFVzZSB0aGUgdmFsdWUgYDEwMHB4YCB3aGVuIHRoZVxuICAgICAqIHNjcm9sbCBpcyB3aXRoaW4gMTAwIHBpeGVscyBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuXG4gICAgICogRGVmYXVsdCBpcyBgMTUlYC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXN0YW5jZSAoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyO1xuICAgIH1cblxuICAgIHNldCBkaXN0YW5jZSAodmFsOiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLl90aHIgPSB2YWw7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RoclB4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RoclBjID0gKHBhcnNlRmxvYXQodmFsKSAvIDEwMCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RoclB4ID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgICAgdGhpcy5fdGhyUGMgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlucHV0IHtib29sZWFufSBJZiB0cnVlLCBXaGV0aGVyIG9yIG5vdCB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGVuYWJsZWQgKHNob3VsZEVuYWJsZTogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIHRoaXMuZW5hYmxlKHNob3VsZEVuYWJsZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAb3V0cHV0IHtldmVudH0gRW1pdHRlZCB3aGVuIHRoZSBzY3JvbGwgcmVhY2hlc1xuICAgICAqIHRoZSB0aHJlc2hvbGQgZGlzdGFuY2UuIEZyb20gd2l0aGluIHlvdXIgaW5maW5pdGUgaGFuZGxlcixcbiAgICAgKiB5b3UgbXVzdCBjYWxsIHRoZSBpbmZpbml0ZSBzY3JvbGwncyBgY29tcGxldGUoKWAgbWV0aG9kIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uTG9hZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgQFZpZXdDaGlsZCgnbG9hZGluUGFuZWwnKVxuICAgIGxvYWRQYW5lbDogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBMYXp5IGxvYWQgY3VycmVudCBudW1iZXJzLiB0ZWxsIHRoZSBhcHAgc3RhcnRpbmcgcG9pbnQgYW5kIHdoYXQgaXMgdGhlIHNpemUgb2YgbG9hZGVkXG4gICAgICogbGlzdFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmZXRjaFNpemU6IG51bWJlciA9IDA7XG5cbiAgICBsb2FkT2Zmc2V0OiBudW1iZXIgPSAwO1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfcmVuZGVyOiBSZW5kZXJlcjIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYpXG4gICAge1xuXG5cbiAgICB9XG5cblxuICAgIG5nT25Jbml0ICgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2hhcy1pbmZpbml0ZS1zY3JvbGwnKTtcblxuICAgIH1cblxuICAgIF9vblNjcm9sbCAoZXY6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdXN0IHRocm90dGxlIHRoZSBjbGFzcyBieSAxMDBtc1xuICAgICAgICBpZiAodGhpcy5fbGFzdENoZWNrICsgMTAwID4gZXYudGltZVN0YW1wKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGNoZWNrIGxlc3MgdGhhbiBldmVyeSBYWG1zXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0Q2hlY2sgPSBldi50aW1lU3RhbXA7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgIGxldCB3aW5IZWlnaHQgPSB0aGlzLmRvbVV0aWxzLmJyb3dzZXJEaW1lbnRpb25zKCkuaGVpZ2h0O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLl9kb2NCb2R5LnNjcm9sbEhlaWdodCwgdGhpcy5fZG9jQm9keS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICB3aW5IZWlnaHQsIHRoaXMuX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0LCB0aGlzLl9jb250ZW50Lm9mZnNldEhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyUGMgPyAoaGVpZ2h0ICogdGhpcy5fdGhyUGMpIDogdGhpcy5fdGhyUHg7XG4gICAgICAgIGxldCBkaXN0YW5jZUZyb21JbmZpbml0ZSA9IHRoaXMuX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0IC0gd2luSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gdGhyZXNob2xkO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoZWlnaHQgKCcgKyBoZWlnaHQgKyAnKSAsIERpc3RhbmNlIGZyb20gYm90dG9tICdcbiAgICAgICAgLy8gKyBkaXN0YW5jZUZyb21JbmZpbml0ZSArICcsICA9PiB0aHJlc2hvbGQgPSAnICtcbiAgICAgICAgLy8gICAgIHRoaXMuZGlzdGFuY2UgKyAnICgnICsgdGhyZXNob2xkICsgJyknKTtcblxuICAgICAgICBpZiAoZGlzdGFuY2VGcm9tSW5maW5pdGUgPCAwICYmIHRoaXMuX2xhc3RTY3JvbGxUb3AgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZU9uTGF6eUxvYWQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RTY3JvbGxUb3AgPiBzY3JvbGxUb3AgJiYgc2Nyb2xsVG9wIDwgd2luSGVpZ2h0XG4gICAgICAgICAgICAmJiB0aGlzLmxvYWRPZmZzZXQgIT09IHRoaXMuZmV0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVPbkxhenlVbkxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9kbzogcmVmYWN0b3IgdG8gb25lIG1ldGhvZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmlyZU9uTGF6eUxvYWQgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9MT0FESU5HICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0xPQURJTkc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5mZXRjaFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sb2FkT2Zmc2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb24gdGhlIG5leHQgcmVjb3JkXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkT2Zmc2V0ICs9IHRoaXMuZmV0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgZmlyZU9uTGF6eVVuTG9hZCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX0xPQURJTkcgJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfTE9BRElORztcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9uIHRoZSBuZXh0IHJlY29yZFxuICAgICAgICAgICAgICAgIHRoaXMubG9hZE9mZnNldCA9IHRoaXMuZmV0Y2hTaXplO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGlzTG9hZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmZldGNoU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxvYWRPZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIHNjcm9sbFRvcCAoKTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCB0aGlzLl9jb250ZW50LnNjcm9sbFRvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgY29tcGxldGUoKWAgd2l0aGluIHRoZSBgaW5maW5pdGVgIG91dHB1dCBldmVudCBoYW5kbGVyIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLiBGb3IgZXhhbXBsZSwgdGhlIGBsb2FkaW5nYFxuICAgICAqIHN0YXRlIGlzIHdoaWxlIHRoZSBhcHAgaXMgcGVyZm9ybWluZyBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLFxuICAgICAqIHN1Y2ggYXMgcmVjZWl2aW5nIG1vcmUgZGF0YSBmcm9tIGFuIEFKQVggcmVxdWVzdCB0byBhZGQgbW9yZSBpdGVtc1xuICAgICAqIHRvIGEgZGF0YSBsaXN0LiBPbmNlIHRoZSBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBVSSB1cGRhdGVkLCB5b3VcbiAgICAgKiB0aGVuIGNhbGwgdGhpcyBtZXRob2QgdG8gc2lnbmlmeSB0aGF0IHRoZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgdGhlIGluZmluaXRlIHNjcm9sbCdzIHN0YXRlIGZyb20gYGxvYWRpbmdgXG4gICAgICogdG8gYGVuYWJsZWRgLlxuICAgICAqL1xuICAgIGNvbXBsZXRlICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfTE9BRElORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRU5BQkxFRDtcblxuICAgICAgICAgICAgLy8gbmVlZCB0byB0cmlnZ2VyIGV4dHJhIGRldGVjdCBjaGFuZ2VzIHRvIHJlcmVuZGVyIGxvYWRpbmcgaWNvblxuICAgICAgICAgICAgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgZW5hYmxlKGZhbHNlKWAgdG8gZGlzYWJsZSB0aGUgaW5maW5pdGUgc2Nyb2xsIGZyb20gYWN0aXZlbHlcbiAgICAgKiB0cnlpbmcgdG8gcmVjZWl2ZSBuZXcgZGF0YSB3aGlsZSBzY3JvbGxpbmcuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxuICAgICAqIHdoZW4gaXQgaXMga25vd24gdGhhdCB0aGVyZSBpcyBubyBtb3JlIGRhdGEgdGhhdCBjYW4gYmUgYWRkZWQsIGFuZFxuICAgICAqIHRoZSBpbmZpbml0ZSBzY3JvbGwgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gc2hvdWxkRW5hYmxlICBJZiB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIGVuYWJsZSAoc2hvdWxkRW5hYmxlOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IChzaG91bGRFbmFibGUgPyBTVEFURV9FTkFCTEVEIDogU1RBVEVfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoc2hvdWxkRW5hYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG5hdGl2ZSB3aW5kb3dzIHNjcm9sbCBldmVudFxuICAgICAqL1xuICAgIF9zZXRMaXN0ZW5lcnMgKHNob3VsZExpc3RlbjogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0KSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTGlzdGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zY0xzbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjTHNuID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY0xzbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NjTHNuKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fc2NMc24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY0xzbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBpc0xvYWRpbmcgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTVEFURV9MT0FESU5HO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RvY0JvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyh0aGlzLnN0YXRlICE9PSBTVEFURV9ESVNBQkxFRCk7XG5cbiAgICAgICAgaWYgKHRoaXMubG9hZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5maXJlT25MYXp5TG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95ICgpXG4gICAge1xuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoZmFsc2UpO1xuICAgIH1cblxufVxuXG5cbmNvbnN0IFNUQVRFX0VOQUJMRUQgPSAnZW5hYmxlZCc7XG5jb25zdCBTVEFURV9ESVNBQkxFRCA9ICdkaXNhYmxlZCc7XG5jb25zdCBTVEFURV9MT0FESU5HID0gJ2xvYWRpbmcnO1xuIiwiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF3TmFtZVN0b3JlIHtcblxuICAgIHByaXZhdGUgc3RvcmU6IE1hcDxzdHJpbmcsIGFueT47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBhZGQobmFtZTogc3RyaW5nLCBlbDogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxpZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgaXMgbm90IHVuaXF1ZSEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5zZXQobmFtZSwgZWwpO1xuICAgIH1cblxuICAgIHJlbW92ZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZGVsZXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGNvbGxpZGVzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuY2xlYXIoKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7XG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIE9uRGVzdHJveVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQXBwQ29uZmlnXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5pbXBvcnQge1xuICAgIEF3TmFtZVN0b3JlXG59IGZyb20gJy4vYXctbmFtZS5zdG9yZSc7XG5cbi8qKlxuICogVGhlICdhd05hbWUnIGRpcmVjdGl2ZSBhdHRhY2hlcyBhIGlkZW50aWZpZXIgdG8gZGVjb3JhdGVkIGVsZW1lbnQgdG8gYWlkIHNlbGVjdG9ycyBmb3IgdGVzdGluZ1xuICogcHVycG9zZXMuIFRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgdHJpZXMgdG8gZ2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciBiYXNlZCBvbiBjb250ZXh0dWFsIGRhdGFcbiAqIGFuZCBpbmhlcmFudCBpbW11dGFibGUgZWxlbWVudCBhdHRyaWJ1dGVzLlxuICpcbiAqICoqR2VuZXJhdGluZyB0aGUgQmFzZSBOYW1lKipcbiAqXG4gKiBUaGUgJ2F3TmFtZScgZGlyZWN0aXZlIGdlbmVyYXRlcyBhIGJhc2UgbmFtZSBmcm9tIGVsZW1lbnQgdGFnIG5hbWUgYW5kIGF0dHJpYnV0ZXMgd2hpY2ggYXJlXG4gKiBzdGF0aWMgYnkgbmF0dXJlLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGF3TmFtZT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGF3bmFtZT1cImJ1dHRvbl9vcmRlclwiPlxuICpcbiAqIElmIHRoZSBlbGVtZW50IGhhcyBhbiAnaWQnLCB0aGF0IHZhbHVlIHRha2VzIHByZWNlZGVudCBhbmQgaXMgdXNlZCBpbnN0ZWFkIG9mIGEgZ2VuZXJhdGVkXG4gKiBuYW1lLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGlkPVwibXlPcmRlckJ1dHRvblwiIGF3TmFtZT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGlkPVwibXlPcmRlckJ1dHRvblwiIGF3bmFtZT1cImJ1dHRvbl9teU9yZGVyQnV0dG9uXCI+XG4gKlxuICpcbiAqICoqUmVwZWF0ZWQgRWxlbWVudHMgYW5kIHRoZSAnZXh0JyBQYXJhbWV0ZXIqKlxuICpcbiAqIFRoZXJlIGFyZSBtYW55IGNhc2VzIHdoZXJlIGVsZW1lbnRzIGFyZSBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgaW4gdGhlIGNvZGUgYXMgbGlzdHMgb3IgdGFibGVzLlxuICogSW4gc3VjaCBjYXNlcywgaXQgbWF5IG5vdCBiZSBlYXN5IHRvIGRpc3Rpbmd1aXNoIGluZGl2aWR1YWwgZWxlbWVudHMgYnkgc3RhbmRhcmQgSFRNTFxuICogYXR0cmlidXRlcywgc28gdGhlICdhd05hbWUnIGRpcmVjdGl2ZSBhbGxvd3MgY3VzdG9tIGV4dGVudGlvbnMgdG8gdGhlIGJhc2UgbmFtZSB0byBiZSBwcm92aWRlZFxuICogdXNpbmcgdGhlICdleHQnIGF0dHJpYnV0ZS5cbiAqXG4gKiAgICBFeGFtcGxlOlxuICogICAgICAgIGZydWl0cyA9IFsnYXBwbGUnLCAnYmFuYW5hJywgJ29yYW5nZSddO1xuICpcbiAqICAgICAgICA8dWw+XG4gKiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgZnJ1aXQgb2YgZnJ1aXRzXCIgYXdOYW1lIGV4dD1cInt7ZnJ1aXR9fVwiPnt7ZnJ1aXR9fTwvbGk+XG4gKiAgICAgICAgPC91bD5cbiAqXG4gKiAgIFJlc3VsdDpcbiAqICAgICAgIDx1bD5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfYXBwbGVcIj5hcHBsZTwvbGk+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX2JhbmFuYVwiPmJhbmFuYTwvbGk+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX29yYW5lXCI+b3JhbmdlPC9saT5cbiAqICAgICAgIDwvdWw+XG4gKlxuICogKipBZGRpbmcgQ29udGV4dCBUaHJvdWdoIEFuY2VzdG9yIEluc3BlY3Rpb24qKlxuICpcbiAqIEluIG9yZGVyIHRvIHByb3ZpZGUgY29udGV4dCB0byB0aGUgZWxlbWVudCBuYW1pbmcsIHRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgbG9vcHMgdGhyb3VnaCB0aGVcbiAqIHBhcmVudCBhbmNlc3RyeSBhbmQgc2VhcmNoZXMgZm9yIGFueSB1bmlxdWUgZWxlbWVudCAnaWQnIHRvIHByZXBlbmQgdG8gdGhlIGJhc2UgbmFtZS5cbiAqXG4gKiAgICAgRXhhbXBsZTpcbiAqICAgICAgICAgPGZvcm0gaWQ9XCJhcHBsaWNhbnRcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICA8L2Zvcm0+XG4gKiAgICAgICAgIDxmb3JtIGlkPVwic3BvdXNlXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxmb3JtIGlkPVwiYXBwbGljYW50XCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd25hbWU9XCJhcHBsaWNhbnRfaW5wdXRfZmlyc3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3bmFtZT1cImFwcGxpY2FudF9pbnB1dF9sYXN0TmFtZVwiPlxuICogICAgICAgICA8L2Zvcm0+XG4gKiAgICAgICAgIDxmb3JtIGlkPVwic3BvdXNlXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd25hbWU9XCJzcG91c2VfaW5wdXRfZmlyc3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3bmFtZT1cInNwb3VzZV9pbnB1dF9sYXN0bmFtZVwiPlxuICogICAgICAgICA8L2Zvcm0+XG4gKlxuICogKipVbmlxdWVuZXNzIENoZWNrKipcbiAqXG4gKiAnYXdOYW1lJyBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXMgaXQgY3JlYXRlcyBieSBhZGRpbmcgdGhlbSB0byBhIG1hcCBzdG9yZS4gV2hlbmV2ZXIgaXRcbiAqIGNyZWF0ZXMgYSBuZXcgbmFtZSBkdXJpbmcgdGhlIGBuZ09uSW5pdGAgcGhhc2UgaXQgY2hlY2tzIGl0IGFnYWluc3QgdGhlIGV4aXN0aW5nIG1hcCxcbiAqIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIGl0IGVuY291bnRlcnMgYSBkdXBsaWNhdGUuIE1vcmVvdmVyIGR1cmluZyB0aGUgZWxlbWVudCBkZXN0cnVjdGlvblxuICogcGhhc2UsIGBuZ09uRGVzdHJveWAsICdhd05hbWUnIHJlbW92ZXMgdGhlIGdlbmVyYXRlZCBuYW1lIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqXG4gKiAqKkluIFByb2R1Y3Rpb24qKlxuICpcbiAqIFVzaW5nICdhd05hbWUnIGFkZHMgYSBzbWFsbCBiaXQgb2YgcmVuZGVyaW5nIG92ZXJoZWFkIGZvciBlYWNoIGVsZW1lbnQgaXQgaXMgdXNlZCBvbi4gSW5cbiAqIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgJ2F3TmFtZScgc2VydmVzIG5vIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGVuZCB1c2VyLCBidXQgbWF5IGhhdmVcbiAqIGEgcGVyZm9ybWFuY2UgaW1wYWN0IG9uIHRoZSBhcHBsaWNhdGlvbi4gQXMgc3VjaCwgJ2F3TmFtZScgdGFrZXMgaW50byBhY2NvdW50IHRoZVxuICogYEFwcENvbmZpZ2Agc2V0dGluZ3MgYW5kIGRpc2FibGVzIG5hbWUgZ2VuZXJhdGlvbiB3aGVuIGBBcHBDb25maWcuaXNQcm9kdWN0aW9uTW9kZSgpYFxuICogaXMgYHRydWVgLlxuICpcbiAqIEluIHlvdXIgYXBwbGljYXRpb24sIHlvdSBjYW4gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgYnkgc2V0dGluZyBgZGV2bW9kZS5lbmFibGVkYCB0b1xuICogYGZhbHNlYCB3aGVuIGNvbmZpZ3VyaW5nIGBBcmliYUNvcmVNb2R1bGVgOlxuICpcbiAqICAgICBBcmliYUNvcmVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgICAgICAgICdkZXZtb2RlLmVuYWJsZWQnOiBmYWxzZVxuICogICAgIH0pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thd05hbWVdJyxcbn0pXG5leHBvcnQgY2xhc3MgQXdOYW1lRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgZXh0OiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIG5hbWU6IHN0cmluZztcblxuICAgIHByaXZhdGUgc2VwYXJhdG9yOiBzdHJpbmcgPSAnXyc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogQXdOYW1lU3RvcmUsXG4gICAgICAgIHByaXZhdGUgY29uZmlnOiBBcHBDb25maWdcbiAgICApIHt9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5pc1Byb2R1Y3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY3JlYXRlTmFtZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFRvU3RvcmUodGhpcy5uYW1lLCB0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F3bmFtZScsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5yZW1vdmUodGhpcy5uYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZWxlbWVudCBuYW1lL2lkIGFuZCByZWZlcmVuY2UgdG8gbWFwIHN0b3JlLiBJZiBuYW1lL2lkIGFscmVhZHlcbiAgICAgKiBleGlzdHMgaW4gc3RvcmUgdGhlbiBpdCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRFbGVtZW50VG9TdG9yZShuYW1lOiBzdHJpbmcsIGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuYWRkKG5hbWUsIGVsZW0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSArIGAuIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgaW4gdXNlLmAsIGVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuYW1lL2lkIGZvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqIEByZXR1cm4gU3RyaW5nIE5hbWUvSURcbiAgICAgKi9cbiAgICBjcmVhdGVOYW1lKGVsZW06IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICBjb25zdCB0YWdOYW1lID0gdGhpcy5nZXRUYWdOYW1lKGVsZW0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXJyYXkgb2Ygc3RyaW5nIHBhcnRzXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICAgICAgLy8gRmluZCBhbmNlc3RvciB0YWcgaWQsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBjb25zdCBwYXJlbnRJRCA9IHRoaXMuZ2V0QW5jZXN0b3JJZChlbGVtKTtcbiAgICAgICAgaWYgKHBhcmVudElEKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcmVudElEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB0YWcgdHlwZVxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSB0aGlzLmdldFBhcmVudE5hbWUoZWxlbSk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFyZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGFnbmFtZVxuICAgICAgICBwYXJ0cy5wdXNoKHRhZ05hbWUpO1xuXG4gICAgICAgIC8vIENob29zZSBpZCBwcm9wZXJ0eSBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5pZCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChlbGVtLm5hdGl2ZUVsZW1lbnQuaWQpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBidWlsZCBleHRlbnNpb24gZnJvbSB0YWcgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIChlbGVtLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCduYW1lJykpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVsZW0ubmF0aXZlRWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHZhbHVlIGF0dHJpYnV0ZSBpZiAnb3B0aW9uJyB0YWdcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zcGFjZXNUb1VuZGVyc2NvcmUoZWxlbS5uYXRpdmVFbGVtZW50LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjdXN0b20gZXh0ZW5zaW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5leHQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zcGFjZXNUb1VuZGVyc2NvcmUodGhpcy5leHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMuc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGFnIG5hbWUgZnJvbSBlbGVtZW50IHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWUoZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gZWxlbS5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBlbGVtZW50IGFuY2VzdHJ5IGFuZCByZXR1cm4gZmlyc3QgaWQgYXR0cmlidXRlXG4gICAgICogZW5jb3VudGVyZWQuXG4gICAgICogQHBhcmFtIGVsZW0gUmVmZXJlbmNlIHRvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRBbmNlc3RvcklkKGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGVsZW0ubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBsZXQgaWQgPSAnJztcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhaWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBhcmVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbmFtZSBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgaWYgbmFtZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgICAqIEBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0UGFyZW50TmFtZShlbGVtOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW0ubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4gKHBhcmVudC5uYW1lICYmICFwYXJlbnQuaWQpID8gcGFyZW50Lm5hbWUgOiBudWxsO1xuICAgIH1cblxuICAgIHNwYWNlc1RvVW5kZXJzY29yZShzdHI6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccysvZywgJ18nKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RW1iZWRkZWRJdGVtRGlyZWN0aXZlfSBmcm9tICcuL2VtYmVkZGVkLWl0ZW0nO1xuaW1wb3J0IHtHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50fSBmcm9tICcuL2dlbmVyaWMtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0luY2x1ZGVDb21wb25lbnREaXJlY3RpdmV9IGZyb20gJy4vaW5jbHVkZS1jb21wb25lbnQuZGlyZWN0aXZlJztcbmltcG9ydCB7RXJyb3JNZXNzYWdlc0NvbXBvbmVudH0gZnJvbSAnLi9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RhbENvbXBvbmVudH0gZnJvbSAnLi9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudCc7XG5pbXBvcnQge0N1cnJlbmN5Rm9ybWF0UGlwZX0gZnJvbSAnLi9waXBlcy9jdXJyZW5jeS1mb3JtYXQucGlwZSc7XG5pbXBvcnQge05nRm9yU2V0RGlyZWN0aXZlfSBmcm9tICcuL29uLW5nZm9yLXNldC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbENvbXBvbmVudH0gZnJvbSAnLi9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7QXdOYW1lRGlyZWN0aXZlfSBmcm9tICcuL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEVtYmVkZGVkSXRlbURpcmVjdGl2ZSxcbiAgICAgICAgSW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZSxcbiAgICAgICAgR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgRXJyb3JNZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgTW9kYWxDb21wb25lbnQsXG4gICAgICAgIEN1cnJlbmN5Rm9ybWF0UGlwZSxcbiAgICAgICAgTmdGb3JTZXREaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50LFxuICAgICAgICBBd05hbWVEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgTW9kYWxDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLFxuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBFcnJvck1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ3VycmVuY3lGb3JtYXRQaXBlLFxuICAgICAgICBOZ0ZvclNldERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxDb21wb25lbnQsXG4gICAgICAgIEF3TmFtZURpcmVjdGl2ZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0Vudmlyb25tZW50LCBub29wfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIG1vZGFsIGRpYWxvZ3MuIFByb3ZpZGVzIGRlZmF1bHRzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBtb2RhbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RhbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGRlc3Ryb3k6ICgpID0+IHZvaWQgPSBub29wO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGNsb3NlcyB0aGUgZGlhbG9nIGJ5IGNhbGxpbmcgZGVzdHJveSBvbiB0aGUgY29tcG9uZW50IHJlZmVyZW5jZS5cbiAgICAgKiBNZXRob2QgaW5oZXJpdGVkIGJ5IGFsbCBpdHMgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2xvc2VNb2RhbCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZSwgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgaXNTdHJpbmdNYXAsIGlzVHlwZSwgb2JqZWN0VG9OYW1lfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeSBhZ2dyZWdhdGVzIGRpZmZlcmVudCBEYXRhUHJvdmlkZXJzIHBlciB0eXBlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5XG57XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGNsYXNzIG5hbWUgdG8gRGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RyeUJ5UHJvdmlkZXI6IE1hcDxzdHJpbmcsIERhdGFQcm92aWRlcjxhbnk+PjtcblxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIGNsYXNzIE5hbWUgIHRvIGFjdHVhbCB0eXBlXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RyeU5hbWVUb0NsYXNzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlciA9IG5ldyBNYXA8c3RyaW5nLCBEYXRhUHJvdmlkZXI8YW55Pj4oKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZXZlcnkgc2luZ2xlIHJlZ2lzdGVyZWQgRGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIHdlIGFsc28gbmVlZCBzdG9yZSBpdHMgcHJvdG90eXBlXG4gICAgICogaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBzdXBwb3J0IHNvbWUga2luZCBvZiBpbmhlcml0YW5jZS4gWW91IGNhbiByZWdpc3RlciBhIHByb3ZpZGVyIGZvclxuICAgICAqIGEgcGFyZW50IGNsYXNzIGlmIG5lZWRlZFxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJQcm92aWRlcjxUPih0YXJnZXQ6IGFueSwgcHJvdmlkZXI6IERhdGFQcm92aWRlcjxUPik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRhcmdldCkgfHwgKCFpc1N0cmluZ01hcCh0YXJnZXQpICYmICFpc1R5cGUodGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignIENhbm5vdCByZWdpc3RlciBub24tb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbmFtZSA9IGlzVHlwZSh0YXJnZXQpID8gdGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lIDogdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHRoaXMucmVnaXN0cnlCeVByb3ZpZGVyLnNldChuYW1lLCBwcm92aWRlcik7XG5cbiAgICAgICAgbGV0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3Muc2V0KG5hbWUsIHByb3RvdHlwZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWFyY2ggZm9yIGJlc3QgbWF0Y2hpbmcgcHJvdmlkZXIuIElmIG5vdCBmb3VuZCB0aGVuIHVzZSBvYmplY3QgcHJvdG90eXBlIHRvIGdldCBob2xkIG9mIGl0c1xuICAgICAqIHBhcmVudCBhbmQgc2VlIGlmIHRoZXJlIGlzIGEgcHJvdmlkZXIgcmVnaXN0ZXJlZCBvbiB0aGlzIGxldmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBiZXN0TWF0Y2hGb3JDbGFzczxUPihjbGFzc05hbWU6IHN0cmluZyk6IERhdGFQcm92aWRlcjxUPlxuICAgIHtcbiAgICAgICAgbGV0IHJlZ2lzdGVyZWRDbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGxldCBjbGFzc1Byb3RvID0gdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLmdldChjbGFzc05hbWUpO1xuXG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQocmVnaXN0ZXJlZENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcjogRGF0YVByb3ZpZGVyPFQ+ID0gdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIuZ2V0KHJlZ2lzdGVyZWRDbGFzc05hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnR5cGUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHbyB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY2xhc3NQcm90bykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc1Byb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNsYXNzUHJvdG8pO1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnROYW1lID0gb2JqZWN0VG9OYW1lKGNsYXNzUHJvdG8pO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRDbGFzc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICAoaXNQcmVzZW50KHBhcmVudE5hbWUpICYmIHBhcmVudE5hbWUgIT09IHJlZ2lzdGVyZWRDbGFzc05hbWUpID8gcGFyZW50TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIGJlc3RNYXRjaEZvckNsYXNzKCkgd2l0aCB0aGUgZGlmZmVyZW5jZSB0byBwYXNzIGEgdHlwZS4gSWYgeW91IHdhbnQgdG9cbiAgICAgKiBzdXBwb3J0IG9iamVjdCBpbmhlcml0YW5jZSB5b3UgbmVlZCB0aGlzLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBiZXN0TWF0Y2hGb3JUeXBlPFQ+KHR5cGU6IFR5cGU8VD4pOiBEYXRhUHJvdmlkZXI8VD5cbiAgICB7XG4gICAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBvYmplY3RUb05hbWUodHlwZSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLnNldChuYW1lLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVzdE1hdGNoRm9yQ2xhc3M8VD4obmFtZSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogUHJvdmlkZXIgaXMgYSBkYXRhIGRyaXZlciB0aGF0IGNhbiBhY2Nlc3MgZGF0YSBhbmQgcmV0cmlldmUgdGhlbS4gSXQga25vd3MgaG93IHRvIGdldCAxXG4gKiBvciBtb3JlIHJlY29yZHMsIG1heWJlIGRvIHBhZ2luZyBhbmQgc29tZSBvdGhlciB0aGluZ3MuXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVByb3ZpZGVyPFQ+XG57XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXJyZW50IHR5cGUgZm9yIHRoaXMgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgdHlwZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIHRoZSBsaXN0ZW5lcnMgaW4gY2FzZSBvZiBkYXRhIGFyZSBhdmFpbGFibGUgb3IgaWYgdGhleSBjaGFuZ2VkIGR1ZSB0byBzb21lIHVzZXJcbiAgICAgKiBpbnRlcmFjdGlvbiAgKHNlYXJjaCwgYWRkaW5nIG9yIHJlbW92aW5nKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGRhdGFDaGFuZ2VzOiBCZWhhdmlvclN1YmplY3Q8VFtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VFtdPihbXSk7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGRhdGEgc291cmNlIHBvcHVsYXRlZCBieSBmZXRjaCBvciBzZWFyY2guIEpTIGFwcGxpY2F0aW9uIGNhbiBob2xkIGxhcmdlIGFtb3VudCBvZlxuICAgICAqIHJlY29yZHMgd2l0aG91dCBnb2luZyBiYWNrIHRvIHRoZSBSRVNUIHNlcnZlci4gVGhpcyBjYW4gYmUgdXNlZCB0byBjYWNoZSBzZWFyY2ggcmVzdWx0IG9uXG4gICAgICogdGhlIGNsaWVudCBzaXRlLlxuICAgICAqXG4gICAgICovXG4gICAgb2ZmU2NyZWVuRGF0YTogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqICBSZXR1cm4gc2l6ZSBvZiB0aGUgc291cmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBleHBlY3RlZENvdW50KHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZvciB1c2UgY2FzZXMgd2hlcmUgd2UgbmVlZCB0byByZXRyaWV2ZSBkYXRhIGJhc2VkIG9uIHNvbWUgY3JpdGVyaWEgZS5nLlxuICAgICAqXG4gICAgICogIC0gbWF4IG51bWJlciBvZiByZWNvcmRzXG4gICAgICogIC0gc3VwcG9ydCBwYWdpbmcgd2l0aCBvZmZzZXQgYW5kIGxpbWl0XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBieSBmZXRjaFxuICAgICAqL1xuICAgIGFic3RyYWN0IGRhdGFGb3JQYXJhbXMocGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+KTogQXJyYXk8VD47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmV0Y2hlcyBkYXRhIGZyb20gdW5kZXJseWluZyBkYXRhUHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgZGF0YWZvclBhcmFtc1xuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgZmV0Y2gocGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+KTogT2JzZXJ2YWJsZTxUW10+O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIG5vbi1hc3luYyBjdXJyZW50IHN0YXRlIG9mIGRhdGFcbiAgICAgKi9cbiAgICBkYXRhKCk6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhpcyBEYXRhUHJvdmlkZXIgc3VwcG9ydHMgSU5TRVJULCBSRU1PVkVcbiAgICAgKlxuICAgICAqL1xuICAgIGNhbkNSVUQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhpcyBEYXRhUHJvdmlkZXIgc3VwcG9ydHMgcXVlcnkgY2FwYWJpbGl0eVxuICAgICAqXG4gICAgICovXG4gICAgY2FuUXVlcnkoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byBzdXBwb3J0IGluc2VydGlvbi4gQWZ0ZXIgcmVjb3JkIGlzIGluc2VydGVkIGVtaXQgZXZlbnQgZm9yIGRhdGFDaGFuZ2VzIHRvXG4gICAgICogaW5mb3JtIGFsbCBzdWJzY3JpYmVyc1xuICAgICAqXG4gICAgICovXG4gICAgaW5zZXJ0KG9iajogYW55KTogdm9pZFxuICAgIHtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byBzdXBwb3J0IHJlY29yZCByZW1vdmFsLiBBZnRlciByZWNvcmQgaXMgcmVtb3ZlZCBlbWl0IGV2ZW50IGZvciBkYXRhQ2hhbmdlcyB0b1xuICAgICAqIGluZm9ybSBhbGwgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmUob2JqOiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHByb3ZpZGUgYWNjZXNzIHRvIGxvdyBsZXZlbCBzZWFyY2cgQVBJLlxuICAgICAqXG4gICAgICovXG4gICAgcXVlcnkocGFyYW1zOiBNYXA8c3RyaW5nLCBzdHJpbmc+KTogdm9pZFxuICAgIHtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtGaWVsZFBhdGgsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZn0gZnJvbSAncnhqcyc7XG5cblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBBcnJheXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBBcnJheURhdGFQcm92aWRlcjxUPiBleHRlbmRzIERhdGFQcm92aWRlcjxUPlxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkICB2YWx1ZXM6IEFycmF5PFQ+KVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gQXJyYXk7XG5cbiAgICAgICAgdGhpcy5vZmZTY3JlZW5EYXRhID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZXMubmV4dCh0aGlzLnZhbHVlcyk7XG4gICAgfVxuXG4gICAgZXhwZWN0ZWRDb3VudChwYXJhbXM/OiBNYXA8c3RyaW5nLCBhbnk+KTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmZTY3JlZW5EYXRhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBkYXRhRm9yUGFyYW1zKHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBBcnJheTxUPlxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsocGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2ZmU2NyZWVuRGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMub2ZmU2NyZWVuRGF0YTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmFtcykgJiYgcGFyYW1zLmhhcygnb2Zmc2V0JykgJiYgcGFyYW1zLmhhcygnbGltaXQnKSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHBhcmFtcy5nZXQoJ29mZnNldCcpO1xuICAgICAgICAgICAgbGV0IGxpbWl0ID0gcGFyYW1zLmdldCgnbGltaXQnKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gKG9mZnNldCArIGxpbWl0KSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShvZmZzZXQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGFzKCdvcmRlcmJ5JykgJiYgcGFyYW1zLmhhcygnc2VsZWN0b3InKSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0KGRhdGEsIHBhcmFtcy5nZXQoJ29yZGVyYnknKSwgcGFyYW1zLmdldCgnc2VsZWN0b3InKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG5cbiAgICBmZXRjaChwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YodGhpcy5kYXRhRm9yUGFyYW1zKHBhcmFtcykpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3Igc29ydGluZyBjdXJyZW50IGRhdGFzZXQgYnkgb25lIGNvbHVtbiAvIGtleVxuICAgICAqXG4gICAgICogZm9yIHNvcnRPcmRlcmluZyBwbGVhc2Ugc2VlIERhdGF0YWJsZSBhbmQgaXRzIHNvcnRPcmRlcmluZ0Zvck51bWJlcigpXG4gICAgICpcbiAgICAgKiAgICAgIDEgID0gYXNjZW5kaW5nXG4gICAgICogICAgICAtMSA9IGRlc2NlbmRpbmdcbiAgICAgKi9cbiAgICBwcml2YXRlIHNvcnQoYXJyYXlUb1NvcnQ6IGFueVtdLCBrZXk6IHN0cmluZywgc29ydE9yZGVyOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBhcnJheVRvU29ydC5zb3J0KChkYXRhMTogYW55LCBkYXRhMjogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdmFsdWUxID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YTEsIGtleSk7XG4gICAgICAgICAgICBsZXQgdmFsdWUyID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YTIsIGtleSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHZhbHVlMSA9PSBudWxsICYmIHZhbHVlMiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlMSAhPSBudWxsICYmIHZhbHVlMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUxID09IG51bGwgJiYgdmFsdWUyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUxID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlMS5sb2NhbGVDb21wYXJlKHZhbHVlMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICh2YWx1ZTEgPCB2YWx1ZTIpID8gLTEgOiAodmFsdWUxID4gdmFsdWUyKSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHNvcnRPcmRlciAqIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyLCBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc0FycmF5LCBpc1N0cmluZ30gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FycmF5RGF0YVByb3ZpZGVyfSBmcm9tICcuL2FycmF5LWRhdGEtcHJvdmlkZXInO1xuXG5cbi8qKlxuICogUHJvdmlkZXMgdG9wIGxldmVsIGFjY2Vzc29yIGNsYXNzIGluIG9yZGVyIHRvIG1ha2Uge0BsaW5rIERhdGFQcm92aWRlcn0gcmV0cmlldmFsIHByb2Nlc3MgZWFzaWVyLlxuICogVXNpbmcge0BsaW5rIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gd2UgZWl0aGVyIHJldHJpZXZlIHJlZ2lzdGVyZWQgaW5zdGFuY2Ugb2YgY29uY3JldGVcbiAqIHByb3ZpZGVyIG9yIGluc3RhbnRpYXRlIG91ciBpbXBsaWNpdCBwcm92aWRlciBmb3IgbmF0aXZlIHR5cGVzIHN1Y2ggYXMgQXJyYXkuXG4gKlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFQcm92aWRlcnNcbntcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWdpc3RyeTogRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5KVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYmVzdCBtYXRjaGluZyAgRGF0YVByb3ZpZGVyIG9yIGNyZWF0ZSBuZXcgb25lIGluIGNhc2Ugb2YgQXJyYXlcbiAgICAgKiBNb3JlIHJvb20gdG8gcmVnaXN0ZXIgYW5kIGluc3RhbnRpYXRlIHNvbWUgb3RoZXIgaW1wbGljaXQgUHJvdmlkZXJzXG4gICAgICovXG4gICAgZmluZCh0YXJnZXQ6IGFueSk6IERhdGFQcm92aWRlcjxhbnk+XG4gICAge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5RGF0YVByb3ZpZGVyKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuYmVzdE1hdGNoRm9yQ2xhc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmJlc3RNYXRjaEZvclR5cGUodGFyZ2V0KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgcHJvdmlkZXIgd2l0aGluIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeVxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXI8VD4odGFyZ2V0OiBhbnksIHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyUHJvdmlkZXIodGFyZ2V0LCBwcm92aWRlcik7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7SW5qZWN0YWJsZSwgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIGFzc2VydCxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNBcnJheSxcbiAgICBpc0JsYW5rLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNKc09iamVjdCxcbiAgICBpc1ByZXNlbnQsXG4gICAgb2JqZWN0VG9OYW1lLFxuICAgIG9iamVjdFZhbHVlcyxcbiAgICB1bmltcGxlbWVudGVkXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZiBhcyBvYnNlcnZhYmxlT2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtBcnJheURhdGFQcm92aWRlcn0gZnJvbSAnLi9hcnJheS1kYXRhLXByb3ZpZGVyJztcbmltcG9ydCB7T3V0bGluZU5vZGV9IGZyb20gJy4uLy4uL3dpZGdldHMvb3V0bGluZS9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIFByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgZGlmZmVyZW50IGRhdGEgRmluZGVycyB1c2VkIG1vc3RseSBieSBEYXRhU291cmNlcy4gQWxsIEZpbmRlcnMgYXJlXG4gKiByZWdpc3RlcmVkIGJ5IHRoaXMgY2xhc3MgYXMgd2UgZG9uJ3QgaGF2ZSBhbnkgbmVlZHMgcmlnaHQgbm93IHRvIGV4cG9zZSB0aGlzIHRvIGRldmVsb3Blci5cbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhRmluZGVyc1xue1xuXG4gICAgcHJpdmF0ZSBmaW5kZXJzQnlUeXBlOiBNYXA8RGF0YUZpbmRlciwgVHlwZTxEYXRhRmluZGVyPj4gPSBuZXcgTWFwKCk7XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLmluaXRGaW5kZXJzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgRGF0YUZpbmRlciBiYXNlZCBvbiB0aGUgb2JqZWN0IHR5cGUgYW5kIHF1ZXJ5VHlwZS5cbiAgICAgKi9cbiAgICBmaW5kKGZvclByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogRGF0YUZpbmRlclxuICAgIHtcblxuICAgICAgICBsZXQgZmluZGVyTWF0Y2g6IFR5cGU8RGF0YUZpbmRlcj47XG4gICAgICAgIHRoaXMuZmluZGVyc0J5VHlwZS5mb3JFYWNoKCh2OiBUeXBlPERhdGFGaW5kZXI+LCBrOiBEYXRhRmluZGVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoay5hY2NlcHRzKGZvclByb3ZpZGVyLCBmb3JUeXBlKSkge1xuICAgICAgICAgICAgICAgIGZpbmRlck1hdGNoID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChmaW5kZXJNYXRjaCkpIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IGZpbmRlck1hdGNoKCk7XG4gICAgICAgICAgICBjb3B5LmZvckRhdGEoZm9yUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgbmV3IGZpbmRlclxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXI8VD4ocHJvdG90eXBlOiBEYXRhRmluZGVyLCB0eXBlOiBUeXBlPERhdGFGaW5kZXI+KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChwcm90b3R5cGUsIHR5cGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEZpbmRlcnMoKVxuICAgIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcHJvdG90eXBlIGZvciBlYWNoXG4gICAgICAgIHRoaXMuZmluZGVyc0J5VHlwZS5zZXQobmV3IEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKCksIEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKTtcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChuZXcgT3V0bGluZUZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKCksXG4gICAgICAgICAgICBPdXRsaW5lRnVsbFRleHRBcnJheURhdGFGaW5kZXIpO1xuXG4gICAgfVxufVxuXG4vKipcbiAqIFdlIGhhdmUgZGlmZmVyZW50IG9wdGlvbnMgaG93IHRvIHF1ZXJ5IGRhdGEuIEZ1bGxUZXh0IHVzZXMgYSBzdHJpbmcgd2hlcmUgcHJlZGljYXRlIGlzXG4gKiB1c2luZyBrZXk6dmFsdWUgcGFpciB0byBidWlsdCBhIHF1ZXJ5XG4gKi9cbmV4cG9ydCBlbnVtIFF1ZXJ5VHlwZVxue1xuICAgIEZ1bGxUZXh0LFxuICAgIEZ1bGxUZXh0T3V0bGluZSxcbiAgICBQcmVkaWNhdGUsXG4gICAgRnVsbFRleHRBbmRQcmVkaWNhdGVcbn1cblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgbWF0Y2hpbmcgY2FwYWJpbGl0eSBmb3IgZ2l2ZW4gRGF0YVByb3ZpZGVyLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YUZpbmRlclxue1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExvb2t1cCBrZXkgdG8gYXBwbHkgd2hlbiBydW5uaW5nIG1hdGNoLiBJZGVhbGx5IHlvdXIgRFMgc2hvdWxkIGJlIGFibGUgdG8gc2V0IGxvb2t1cEtleVxuICAgICAqIGVpdGhlciBnbG9iYWxseSBmb3IgZ2l2ZW4gZGF0YVByb3ZpZGVyIG9yIGxvY2FsbHkgZXZlcnkgdGltZSB5b3UgcnVuIHNlYXJjaC4gVGhpcyBpcyBpblxuICAgICAqIGNhc2UgeW91IGhhdmUgbWFueSBjaG9vc2VycyBmb3IgdGhlIHNhbWUgdHlwZSBhbmQgeW91IHdhbnQgdGhlbSB0byBoYXZlIGRpZmZlcmVudCBsb29rdXBcbiAgICAgKiBrZXkuXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0IGxvb2t1cEtleShrZXk6IHN0cmluZyk7XG5cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBmaW5kIGNvbmNyZXRlIERhdGFGaW5kZXIgd2UgbmVlZCB0byBrbm93IHRoZSB0YXJnZXQgdHlwZSBhbmQgdGhlIHF1ZXJ5IHR5cGVcbiAgICAgKlxuICAgICAqL1xuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldHMgYSBEYXRhUHJvdmlkZXIgZm9yIERhdGFGaW5kZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGZvckRhdGEocHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+KTogRGF0YUZpbmRlcjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWF0Y2hpbmcgbWV0aG9kcyB3aGljaCBhcmUgZWl0aGVyIGFzeW5jIG9yIHN5bmNcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGluc3RhbnRNYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IFRbXTtcblxuICAgIGFic3RyYWN0IGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnNGb3JNYXRjaDogYW55W10sIHF1ZXJ5OiBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBudW1iZXIpOiBUW107XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUXVlcnkgY2FuIGJlIGEgc2ltcGxlIHN0cmluZyBsaXRlcmFsIG9yIGEgbWFwIGhhdmluZyBkaWZmZXJlbnQga2V5IHZhbHVlIHBhaXIgYXMgYVxuICAgICAqIGZpbHRlclxuICAgICAqXG4gICAgICovXG4gICAgbWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIgPSAtMSk6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cbiAgICBtYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnM6IGFueVtdLCBxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTaW1wbGUgRnVsbFRleHQgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gaW5maXggc3RyaW5nIG1hdGNoaW5nIHdoaWNoIHdvcmtzIG9uIHRvcCBvZlxuICogQXJyYXlEYXRhUHJvdmlkZXIuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRnVsbFRleHRBcnJheURhdGFGaW5kZXIgZXh0ZW5kcyBEYXRhRmluZGVyXG57XG4gICAgLyoqXG4gICAgICogIElmIGxpc3QgdmFsdWUgaXMgb2JqZWN0IHNldCBrZXlQYXRoIHRvIGdldCB0aGUgb2JqZWN0IHZhbHVlXG4gICAgICovXG4gICAgX2tleVBhdGg6IEZpZWxkUGF0aDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgRGF0YVByb3ZpZGVyIHVzZWQgdG8gYWNjZXNzIGRhdGFcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Byb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcblxuICAgIHNldCBsb29rdXBLZXkoa2V5OiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLl9rZXlQYXRoID0gaXNQcmVzZW50KGtleSkgPyBuZXcgRmllbGRQYXRoKGtleSkgOiBudWxsO1xuICAgIH1cblxuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmb3JEYXRhIGluc3RhbmNlb2YgQXJyYXlEYXRhUHJvdmlkZXIgJiYgZm9yVHlwZSA9PT0gUXVlcnlUeXBlLkZ1bGxUZXh0O1xuICAgIH1cblxuICAgIGZvckRhdGEocHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+KTogRnVsbFRleHRBcnJheURhdGFGaW5kZXJcbiAgICB7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGluc3RhbnRNYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IFRbXVxuICAgIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLl9wcm92aWRlciksICdNaXNzaW5nIERhdGFQcm92aWRlcicpO1xuXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5fcHJvdmlkZXIuZGF0YUZvclBhcmFtcyhuZXcgTWFwKCkuc2V0KCdsaW1pdCcsIG1heCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihsaXN0LCBxdWVyeSwgbWF4KTtcbiAgICB9XG5cbiAgICBpbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihzZWxlY3Rpb25zRm9yTWF0Y2g6IGFueVtdLCBxdWVyeTogc3RyaW5nLCBtYXg6IG51bWJlcik6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuX3Byb3ZpZGVyKSwgJ01pc3NpbmcgRGF0YVByb3ZpZGVyJyk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsocXVlcnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uc0Zvck1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgICAgIGxldCB0b0xvd2VyUGF0dGVybiA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25zRm9yTWF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gc2VsZWN0aW9uc0Zvck1hdGNoW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMubWF0Y2hlcyhpdGVtLCB0b0xvd2VyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+PSBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBJZiB5b3UgZG9udCBzdXBwbHkgc2VhcmNoIEtleSBhbmQgeW91IHdhbnQgZnVsbHRleHQgc2VhcmNoIGFuZCB5b3UgdXNlIHRoaXNcbiAgICAgKiBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGJlIGF3YXJlIHRoYXQgaXQgY2FuICBwZXJmb3JtIHBvb3JseSBhcyBpdCBpcyBuYWl2ZSBpbXBsZW1lbnRhaW9uXG4gICAgICogdGhhdCBkb2VzIG5vdCBkbyBkZWVwIGNvbXBhcmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBtYXRjaGVzPFQ+KGl0ZW06IGFueSwgcGF0dGVybjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHZhbCA9IChpc1ByZXNlbnQodGhpcy5fa2V5UGF0aCkpID8gdGhpcy5fa2V5UGF0aC5nZXRGaWVsZFZhbHVlKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmNhbGwoaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNKc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzT2JqZWN0VmFsdWUoaXRlbSwgcGF0dGVybik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JsYW5rKHBhdHRlcm4pIHx8XG4gICAgICAgICAgICAgICAgaXNQcmVzZW50KHZhbCkgJiYgdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHBhdHRlcm4pID4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHRoaXMuaW5zdGFudE1hdGNoKHF1ZXJ5LCBtYXgpKTtcbiAgICB9XG5cbiAgICBtYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnM6IGFueVtdLCBxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zKHNlbGVjdGlvbnMsIHF1ZXJ5LCBtYXgpKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaGFzT2JqZWN0VmFsdWUob2JqOiBhbnksIHBhdHRlcm46IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBvYmplY3RWYWx1ZXMob2JqKTtcbiAgICAgICAgbGV0IHBhcmVudE9iaiA9IG9iamVjdFRvTmFtZShvYmopO1xuICAgICAgICBsZXQgbGVuZ3RoMiA9IHZhbHVlcy5maWx0ZXIoKHZhbHVlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSB8fCBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNKc09iamVjdCh2YWx1ZSkgJiYgIWlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHBhdHRlcm4pICE9PSAtMTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0pzT2JqZWN0KHZhbHVlKSAmJiBvYmplY3RUb05hbWUodmFsdWUpICE9PSBwYXJlbnRPYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNPYmplY3RWYWx1ZSh2YWx1ZSwgcGF0dGVybik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoMiA+IDA7XG4gICAgfVxufVxuXG5cbi8qKlxuICogRXh0ZW5kcyBiYXNpYyBJbmZpeCBpbXBsZW1lbnRhdGlvbiB0byB3b3JrIG9uIHRvcCBvZiBPdXRsaW5lTm9kZXMuIEl0IGZpcnN0IGNoZWNrcyBhbGwgdGhlXG4gKiBjaGlsZHJlbiBvbiBsb3dlc3QgbGV2ZWwgYW5kIG1vdmluZyB1cCB0byB0aGUgcm9vdCBhbmQgbWFya2luZyBub2RlcyB0aGF0IGNhbiBiZSByZW1vdmVkLlxuICpcbiAqICBGb3Igc2ltcGxlIGRhdGEgc3RydWN0dXJlIHdoaWNoIG9wZXJhdGVzIG9uIGxvY2FsIGFycmF5IHRoaXMgc2hvdWxkIGJlIGdvb2QgZW5vdWdoIHdlIHRoaXNcbiAqICBjYW4gbmV2ZXIgbWF0Y2ggd2l0aCByZWFsIERCIGZ1bGwgdGV4dCBzZWFyY2guXG4gKlxuICovXG5leHBvcnQgY2xhc3MgT3V0bGluZUZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyIGV4dGVuZHMgRnVsbFRleHRBcnJheURhdGFGaW5kZXJcbntcblxuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmb3JEYXRhIGluc3RhbmNlb2YgQXJyYXlEYXRhUHJvdmlkZXIgJiYgZm9yVHlwZSA9PT0gUXVlcnlUeXBlLkZ1bGxUZXh0T3V0bGluZTtcbiAgICB9XG5cblxuICAgIGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnNGb3JNYXRjaDogYW55W10sIHF1ZXJ5OiBzdHJpbmcsIG1heDogbnVtYmVyKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5fcHJvdmlkZXIpLCAnTWlzc2luZyBEYXRhUHJvdmlkZXInKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25zRm9yTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvTG93ZXJQYXR0ZXJuID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBsZXQgc291cmNlVG9TZWFyY2ggPSBzZWxlY3Rpb25zRm9yTWF0Y2guc2xpY2UoKTtcbiAgICAgICAgdGhpcy5yb2xsdXAoc291cmNlVG9TZWFyY2gsIHRvTG93ZXJQYXR0ZXJuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hha2Uoc291cmNlVG9TZWFyY2gpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBHb2luZyB0aHJ1IHRoZSB0cmVlIGZyb20gYm90dG9tIHVwIGFuZCBtYXJrIGFsbCB0aGF0IG1hdGNoZXMgcXVlcnlcbiAgICAgKlxuICAgICAqL1xuICAgIHJvbGx1cChub2RlczogT3V0bGluZU5vZGVbXSwgcXVlcnk6IHN0cmluZyk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKGl0ZW06IE91dGxpbmVOb2RlKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIGJvdHRvbSB1cCBhbmQgY2FwdHVyZSBob3cgbWFueSBvY2N1cnJlbmNlcyBpcyBmb3VuZCBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgbGV0IGhhc0NoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoaXRlbS5jaGlsZHJlbikgJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaGFzQ2hpbGRyZW5NYXRjaCA9IHRoaXMucm9sbHVwKGl0ZW0uY2hpbGRyZW4sIHF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0udmlzaWJsZSA9IGhhc0NoaWxkcmVuTWF0Y2ggfHwgdGhpcy5tYXRjaGVzKGl0ZW0sIHF1ZXJ5KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGVzLnNvbWUoKGl0ZW06IE91dGxpbmVOb2RlKSA9PiBpdGVtLnZpc2libGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbHRlciBvdXQgYWxsIHRoZSBub2RlcyB0aGF0IGFyZSBtYXJrZWQgYXMgdmlzaWJsZSA9IGZhbHNlIGFuZCBtYWtlIHN1cmUgYW5kXG4gICAgICogZG9uJ3QgbW9kaWZ5IG9yaWdpbmFsIGxpc3RcbiAgICAgKlxuICAgICAqL1xuICAgIHNoYWtlKG5vZGVzOiBPdXRsaW5lTm9kZVtdKTogYW55W11cbiAgICB7XG4gICAgICAgIHJldHVybiBub2Rlc1xuICAgICAgICAgICAgLmZpbHRlcihub2RlID0+IG5vZGUudmlzaWJsZSlcbiAgICAgICAgICAgIC5tYXAobm9kZSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgaXNFeHBhbmRlZDogbm9kZS52aXNpYmxlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuICYmIHRoaXMuc2hha2Uobm9kZS5jaGlsZHJlbilcbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG5cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVyc30gZnJvbSAnLi9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHt1bmltcGxlbWVudGVkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5cblxuZXhwb3J0IGNvbnN0IERBVEFfU09VUkNFID0gbmV3IEluamVjdGlvblRva2VuPERhdGFTb3VyY2U+KCdEQVRBX1NPVVJDRScpO1xuXG4vKipcbiAqIERhdGFTb3VyY2UgZGVzY3JpYmVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGhhbmRsaW5nIHN0cmVhbSBvZiBkYXRhIHNwZWNpZmljIHRvIGNvbXBvbmVudFxuICpcbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgRGF0YVNvdXJjZSB3aWxsIGJlIGRlZmluZWQgYXMgY29tcG9uZW50IHByb3ZpZGVyIHVzaW5nXG4gKlxuICogQENvbXBvbmVudHMgKHtcbiAqICAgICAgLi4uXG4gKiAgICAgIHByb3ZpZGVyczpbXG4gKlxuICogICAgICAgICAgcHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZVBsYWluQXJyYXlFeGFtcGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXVxuICogICAgICBdXG4gKlxuICogfSlcbiAqXG4gKlxuICogc28gYWxsIHRoZSBkZXBlbmRlbmNpZXMgKERhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzKSBhcmUgcHJvcGVybHkgaW5qZWN0ZWQuXG4gKlxuICogRGF0YVByb3ZpZGVyIHVzZXMgb3BlbigpIG1ldGhvZCB0byBicm9hZGNhc3QgY2hhbmdlcyB0byBhbGwgdGhlIHN1YnNjcmliZXJzIGluIHJlYWN0aXZlIHdheS5cbiAqIE9yIHlvdSBjYW4gdXNlIGluc3RhbnQoKSBtZXRob2QgdG8gcmV0cmlldmUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIERhdGFTb3VyY2UgKHN5bmMpXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVNvdXJjZVxue1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhMZW5ndGggPSAxMDtcbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4UmVjZW50U2VsZWN0ZWQgPSA1O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFYWNoIERhdGFTb3VyY2UgaGF2ZSBpbmplY3RlZCBEYXRhUHJvdmlkZXJzIGFuZCBEYXRhRmluZGVycyB0byByZXRyaWV2ZSBjb25jcmV0ZVxuICAgICAqIGltcGxlbWVudGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGF0YVByb3ZpZGVycz86IERhdGFQcm92aWRlcnMsIHByb3RlY3RlZCBmaW5kZXJzPzogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIGluaXRpYWxpemUgZGF0YSBzb3VyY2UgYW5kIHBhc3Mgc29tZSBhZGRpdGlvbmFsIHZhbHVlc1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIERhdGFQcm92aWRlcnMgd29ya3Mgd2l0aCBzdHJlYW0gb2YgZGF0YSBhbmQgdGhpcyBvcGVucyB1cCB0aGUgY2hhbm5lbCBpbiBvcmRlciB0b1xuICAgICAqIGxpc3RlbiBhbmQgcmVhY3QgZm9yIGFueSBjaGFuZ2VzIHRoYXQgY291bGQgaGFwcGVuIGluc2lkZSBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvcGVuPFQ+KCk6IE9ic2VydmFibGU8VFtdPjtcblxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSBzdWJzY3JpcHRpb24gdG8gRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgYWJzdHJhY3QgY2xvc2UoKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRhdGEgaW5zdGFudGx5IGZyb20gdGhlIGludGVybmFsIHN0YXRlIG9mIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIGluc3RhbnQ8VD4oKTogVFtdXG4gICAge1xuXG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEU0luaXRQYXJhbXNcbntcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHZhbHVlcyBvciB0aGUgb2JqZWN0IHR5cGUgbmFtZSB3ZSB3YW50IHRvIHJlbmRlclxuICAgICAqL1xuICAgIG9iaj86IGFueTtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGZpbmQgd2Ugd2FudCB0byBsb2FkIEZ1bGxUZXh0IG9yIFByZWRpY2F0ZVxuICAgICAqL1xuICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHNwZWNpZnkgbG9va3VwIEtleSB0byBuYXJyb3cgZG93biB0aGUgc2VhcmNoIHRvIHNwZWNpZmljIGZpZWxkLiBJZiBsb29rdXAga2V5IGlzXG4gICAgICogbnVsbCwgaXRlbXMgYXJlIGFzc3VtZWQgdG8gYmUgc3RyaW5nc1xuICAgICAqL1xuICAgIGxvb2t1cEtleT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBDaG9vc2VyIGlzIHNpbmdsZSBvciBtdWx0aSBzZWxlY3RcbiAgICAgKi9cbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbiB0byBwYXNzIGN1c3RvbSBEYXRhUHJvdmlkZXIgaW5zdGVhZCBsZXR0aW5nIERhdGFQcm92aWRlcnMgdG8gZmluZCBtYXRjaFxuICAgICAqL1xuICAgIGRhdGFQcm92aWRlcj86IERhdGFQcm92aWRlcjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIERhdGFGaW5kZXIgaW5zdGVhZCBsZXR0aW5nIERhdGFGaW5kZXJzIHRvIGZpbmQgbWF0Y2hcbiAgICAgKi9cbiAgICBkYXRhRmluZGVyPzogRGF0YUZpbmRlcjtcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEhvc3RCaW5kaW5nfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBXZSBhcmUgdXNpbmcgdGhlc2UgY29tcG9uZW50cyBhcyBhIGJldHRlciB3YXkgc2VsZWN0b3JzLlxuICpcbiAqL1xuXG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10b3AnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgVG9wWm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQgJztcbn1cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWxlZnQnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgTGVmdFpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcbn1cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW1pZGRsZScsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBNaWRkbGVab25lQ29tcG9uZW50XG57XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJ3VpLWctMTIgdWktbWQtNiB1aS1sZy00IHVpLWctbm9wYWQnO1xufVxuXG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yaWdodCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBSaWdodFpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcblxufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctYm90dG9tJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIEJvdHRvbVpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBc3luY1ZhbGlkYXRvckZuLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9yc30gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlciwgU3RyaW5nV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Zvcm1UYWJsZUNvbXBvbmVudH0gZnJvbSAnLi4vZm9ybS10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudCwgV2lkZ2V0U2l6ZUNvbHVtbnN9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVXNlZCBieSBGb3JtVGFibGUgdG8gbGF5b3V0IGZpZWxkcyBpbnRvIFJvd3MuIEVhY2ggRm9ybVRhYmxlIHJvdyBpcyByZWFzb25hYmxlIGZvciBub3Qgb25seSB0b1xuICogaW5jbHVkZSBhY3R1YWwgY29tcG9uZW50IHN1Y2ggaXMgRHJvcERvd24gb3IgSW5wdXRGaWVsZCBidXQgbWFpbmx5IHByb3ZpZGVzIGEgZW5vdWdoIGNvbnRleHQgZm9yXG4gKiB0aGUgY29tcG9uZW50IHRvIHNwZWNpZnkgdGhlIHNpemUsIGhvdyBpdCBzaG91bGQgbGF5b3V0LCB3aGV0aGVyIHdlIG5lZWQgdG8gc2hvdyByZXF1aXJlZCBmbGFnLFxuICogdG8gc2hvdy9oaWRlIGxhYmVscyBpbiBjYXNlIGlmIHdlIGhhdmUgbm8gbGFiZWwgbGF5b3V0IGFuZCBtdWNoIG1vcmUuXG4gKlxuICogRm9ybVJvdyBjb21wb25lbnQgYWxzbyByZWdpc3RlcnMgYW5ndWxhciB2YWxpZGF0b3IgZm9yIHRoZSBjdXJyZW50IHJvdy9maWVsZC4gQXMgYWxyZWFkeVxuICogbWVudGlvbmVkIFdlIHRyZWF0IG91ciB3aWRnZXRzIHdpdGggbWluaW1hbCByZXNwb25zaWJpbGl0eSBhcyBwb3NzaWJsZSB0byBwcmVzZW50IGFuZCByZXRyaXZlXG4gKiBpbmZvcm1hdGlvbiB0by9mcm9tIHVzZXIgYW5kIGxldCBzb21lYm9keSBlbHNlIHRvIGZpZ3VyZSBvdXQgd2hlcmUgaXQgYXBwZWFyIGFuZCBob3cuXG4gKlxuICogdG9kbzogTW92ZSB1bmRlciBGb3JtVGFibGVcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1mb3JtLXJvdycsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiIWhpZGRlblwiXG4gICAgIGNsYXNzPVwidy1mb3JtLXJvdyB1aS1nXCJcbiAgICAgW2NsYXNzLmhpZ2hsaWdodC1yb3ddPVwiaGlnaGxpZ2h0Um93XCJcbiAgICAgW2NsYXNzLnJlcXVpcmVkXT1cInJlcXVpcmVkXCJcbiAgICAgW2NsYXNzLmxhYmVsLW9uLXRvcF09XCJsYWJlbHNPblRvcFwiXG4gICAgIFtjbGFzcy5sYWJlbC1vbi1zaWRlXT1cIiFsYWJlbHNPblRvcFwiXG4gICAgIFtjbGFzcy5oYXMtZGFuZ2VyXT1cIiFmb3JtQ29udHJvbC52YWxpZCAmJiAhZm9ybUNvbnRyb2wucHJpc3RpbmUgXCJcbiAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRyb2wtbGFiZWwgdWktZy0xMiB1aS1nLW5vcGFkXCJcbiAgICAgICAgICpuZ0lmPVwiIW5vTGFiZWxMYXlvdXRcIlxuICAgICAgICAgW2NsYXNzLnVpLW1kLTNdPVwiIWxhYmVsc09uVG9wXCI+XG4gICAgICAgIDxsYWJlbCBbY2xhc3Muc3Itb25seV09XCJub0xhYmVsTGF5b3V0XCI+e3tsYWJlbH19PC9sYWJlbD5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLXZhbHVlIHVpLWctbm9wYWRcIiBbbmdDbGFzc109XCJzaXplXCJcbiAgICAgICAgIFtjbGFzcy5yZWFkLW9ubHldPVwiIWVkaXRhYmxlXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPGEtZXJyb3ItbWVzc2FnZXMgW2NvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIj48L2EtZXJyb3ItbWVzc2FnZXM+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5yZXF1aXJlZCBsYWJlbDphZnRlcntjb250ZW50OlwiKlwiO2NvbG9yOnJlZH0vZGVlcC8gLmhpZ2hsaWdodC1yb3d7YmFja2dyb3VuZC1jb2xvcjojZjdmOGZhfS53LWZvcm0tcm93LmhpZ2hsaWdodC1yb3d7YmFja2dyb3VuZC1jb2xvcjojZjdmOGZhfS53LWZvcm0tcm93LmxhYmVsLW9uLXRvcHtwYWRkaW5nLWJvdHRvbToxM3B4fS53LWZvcm0tcm93LmxhYmVsLW9uLXRvcCAuY29udHJvbC1sYWJlbCwudy1mb3JtLXJvdy5sYWJlbC1vbi10b3AgLmNvbnRyb2wtdmFsdWV7cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowfS53LWZvcm0tcm93LmxhYmVsLW9uLXRvcCAuY29udHJvbC1sYWJlbHtwYWRkaW5nLWJvdHRvbToxMnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwsLnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC12YWx1ZXtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjB9LnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC1sYWJlbCA6Om5nLWRlZXAgLnctc3RyaW5nLWZpZWxkLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgOjpuZy1kZWVwIC53LXN0cmluZy1maWVsZHtsaW5lLWhlaWdodDozNnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwgOjpuZy1kZWVwIC5zYXAtaWNvbiwudy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLXZhbHVlIDo6bmctZGVlcCAuc2FwLWljb257bGluZS1oZWlnaHQ6MjZweH0udy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLWxhYmVsIGxhYmVsLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgbGFiZWx7bGluZS1oZWlnaHQ6MzZweH0udy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLWxhYmVsIC5mYSwudy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLXZhbHVlIC5mYXtsaW5lLWhlaWdodDoxOHB4fS5jb250cm9sLWxhYmVse2NvbG9yOiM2MzYzNjN9LnUtdmFsaWRhdGlvbi1lcnJvcntib3JkZXItY29sb3I6cmVkfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRm9ybVJvd0NvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub0xhYmVsTGF5b3V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHJvdyB3aXRoIGhpZ2hsaWdodGVkIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlnaGxpZ2h0Um93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBGaWVsZCBsYWJlbCB0aGF0IHNob3VsZCBhcHBlYXIgYWJvdmUgb3IgbmV4dCB0byB0aGUgY29udHJvbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiAgRm9yIGlucHV0cyB0eXBlIGZpZWxkcyBwcm92aWRlcyBkZWZhdWx0IGFuZ3VsYXIgdmFsaWRhdG9ycywgbWF4aW1hbCBsZW5ndGggb2YgdGhlIGZpZWxkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhMZW5ndGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciB2YWxpZGF0b3JzLCBtaW5pbWFsIGxlbmd0aCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbkxlbmd0aDogbnVtYmVyO1xuXG5cbiAgICAvKipcbiAgICAgKiAgRm9yIGlucHV0cyB0eXBlIGZpZWxkcyBwcm92aWRlcyBkZWZhdWx0IGFuZ3VsYXIgZm9ybWF0dGVycy4gSG93IHRoZSBpbnB1dCBmaWVsZHMgc2hvdWxkIGJlXG4gICAgICogZm9ybWF0dGVkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tIGFzeW5jIHZhbGlkYXRvcnMgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgQ29udHJvbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VzdG9tQXN5bmNWYWxpZGF0b3JzOiBBc3luY1ZhbGlkYXRvckZuW107XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1c3RvbSAgdmFsaWRhdG9ycyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBDb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21WYWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBpcyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmaWVsZC4gQ3VycmVudCB3ZSBzdXBwb3J0IDQgZGlmZmVyZW50IHNpemVzOiB4LXNtYWxsLCBzbWFsbCxcbiAgICAgKiBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2l6ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGb3Igc2luZ2xlIGNvbHVtbiBsYXlvdXQgd2l0aG91dCB6b25lcyB3ZSBuZWVkIHRvIGFwcGx5IGdyaWQgZGlyZWN0bHkgdG8gdGhlIEZvcm1Sb3cgdGFnXG4gICAgICogc28gd2UgZG9uJ3QgbmVlZCB0byBpbnRyb2R1Y2UgZXh0cmEgZGl2IGxldmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAnJztcblxuXG4gICAgcHJpdmF0ZSBfbGFiZWxzT25Ub3A6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAvLyBFdmVudCB0aGlzIGNyZWF0ZXMgQ0kgZGVwZW5kcy4gTmVlZCB0byBoYXZlIGEgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vIEkgbmVlZCB0byByZWZhY3RvciBtb3JlIHBhcmVudCB0byBub3QgdXNlIHRoaXMgY2hpbGQgYW5kIHJlZmFjdG9yIGxheW91dGluZ1xuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtVGFibGVDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEZvcm1UYWJsZUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fc2l6ZSA9ICd1aS1nLTEyIHVpLW1kLScgKyBXaWRnZXRTaXplQ29sdW1ucy5tZWRpdW07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSaWdodCBub3cgd2UganVzdCBpbml0aWFsaXplIHRoaXMgb25jZSBhbmQgdXNlIHRoZSB2YWx1ZXMgd2UgZG8gbm90IGV4cGVjdCBub3cgdG8gcmVhY3QgdG9cbiAgICAgKiBjaGFuZ2VzXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wobnVsbCk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlclZhbGlkYXRvcnMoKTtcblxuICAgICAgICB0aGlzLm9taXRQYWRkaW5nID0gdGhpcy5wYXJlbnRDb250YWluZXIub21pdFBhZGRpbmc7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ICs9IGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikgPyAnIHVpLWctMTIgJyA6ICcnO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdCA9IHRoaXMuaGlnaGxpZ2h0Um93ID8gdGhpcy5jbGFzc0xpc3QgKyAnIGhpZ2hsaWdodC1yb3cgJyA6IHRoaXMuY2xhc3NMaXN0O1xuXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5vbWl0UGFkZGluZyA/IHRoaXMuY2xhc3NMaXN0ICsgJyB1aS1nLW5vcGFkICcgOiB0aGlzLmNsYXNzTGlzdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEp1c3QgYSBzaXplIGdldHRlclxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IHNpemUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEEgc2l6ZSBzZXR0ZXIgd2UgdHJhbnNsYXRlIGN1c3RvbSBzaXplcyBpbnRvIGFjdHVhbCBib290c3RyYXAgZ3JpZCBzeXN0ZW0uIFdlIHVzZSBtZWRpdW1cbiAgICAgKiByaWdodCBub3cuIGJ1dCB3ZSBzaG91bGQgZXh0ZW5kIHRoaXMgZm9yIG90aGVyIHNjcmVlbiBzaXplc1xuICAgICAqXG4gICAgICogIHRvZG86IHByb3ZpZGUgbWFwcGluZyBhbmQgYWRkIG90aGVyIGdyaWQgY2xhc3NlcyBmb3Igb3RoZXIgc2l6ZXMgeHMsIHNtLCBsZywgeGxcbiAgICAgKlxuICAgICAqICBBbHNvIGNoZWNrIGlmIHRoaXMgaXMgZHluYW1pYyBzaXplIHRoYXQgc2hvdWxkIHZhcnkgYmFzZWQgb24gdGhlIGhvdyBtYW55IG51bWJlciBvZiBjb2x1bW5zXG4gICAgICogd2UgaGF2ZS4gZS5nLiBEYXRlIHdpZGdldHMgaXMgYnkgZGVmYXVsdCBzbWFsbCwgYnV0IGluIDIsIDMgY29sdW1ucyBsYXlvdXQgdGhpcyBzbWFsbCBpcyB0b29cbiAgICAgKiBzbWFsbC5cbiAgICAgKi9cblxuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzaXplKHZhbHVlOiBzdHJpbmcpIHtcblxuICAgICAgICBsZXQgaXNEeW5WYWwgPSBmYWxzZTtcblxuICAgICAgICBpZiAoU3RyaW5nV3JhcHBlci5zdGFydHNXaWR0aCh2YWx1ZSwgJ2QtJykpIHtcbiAgICAgICAgICAgIGlzRHluVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDIsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IHRoaXMuZHluU2l6ZSh2YWx1ZSwgaXNEeW5WYWwpO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9ICd1aS1nLTEyIHVpLW1kLScgKyBkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSAmJiB0aGlzLmVkaXRhYmxlICE9PSB0aGlzLnBhcmVudENvbnRhaW5lci5lZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaCBvdXQgb2YgYm94IGFuZ3VsYXIgdmFsaWRhdG9yIGFzIHdlbGwgYXMgY3VzdG9tIG9uZSB0byBjdXJyZW50IEZvcm1Db250cm9sXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RlclZhbGlkYXRvcnMoKSB7XG4gICAgICAgIGxldCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdID0gW107XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1heExlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLm1heExlbmd0aCh0aGlzLm1heExlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1pbkxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLm1pbkxlbmd0aCh0aGlzLm1pbkxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJlcXVpcmVkKSAmJiB0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnBhdHRlcm4odGhpcy5wYXR0ZXJuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmN1c3RvbVZhbGlkYXRvcnMpKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwodmFsaWRhdG9ycywgdGhpcy5jdXN0b21WYWxpZGF0b3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKFZhbGlkYXRvcnMuY29tcG9zZSh2YWxpZGF0b3JzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzKSAmJiB0aGlzLmN1c3RvbUFzeW5jVmFsaWRhdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpICYmIHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRG8gd2UgaGF2ZSBsYWJlbHMgb24gVE9QLCB0cnkgdG8gcmVhZCB0aGlzIGZyb20gUGFyZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgbGFiZWxzT25Ub3AoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX2xhYmVsc09uVG9wKSAmJiBpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxGb3JtVGFibGVDb21wb25lbnQ+dGhpcy5wYXJlbnRDb250YWluZXIpLmlzTGFiZWxzT25Ub3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbiByZWZhY3RvciBhbGwgaW50byAxIGxpbmUgYnV0IGl0cyBoYXJkIHRvIGRlYnVnIHNvIHRoaXMgaXMganVzdCBmb3IgcmVhZFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkeW5TaXplKHZhbHVlOiBzdHJpbmcsIGlzRHluVmFsdWU6IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgICAgICBsZXQgbm9ybWFsaXplU2l6ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSAmJlxuICAgICAgICAgICAgKDxGb3JtVGFibGVDb21wb25lbnQ+dGhpcy5wYXJlbnRDb250YWluZXIpLmhhc1R3b0NvbHVtbiAmJiBpc0R5blZhbHVlKSB7XG5cbiAgICAgICAgICAgIGxldCBlbnVtVmFsdWVzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKFdpZGdldFNpemVDb2x1bW5zKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNpemUgPSBlbnVtVmFsdWVzW2VudW1WYWx1ZXMuaW5kZXhPZihub3JtYWxpemVTaXplKSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPGFueT5XaWRnZXRTaXplQ29sdW1ucylbbm9ybWFsaXplU2l6ZV07XG5cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBCb3R0b21ab25lQ29tcG9uZW50LFxuICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgIFRvcFpvbmVDb21wb25lbnRcbn0gZnJvbSAnLi4vZml2ZS16b25lLWxheW91dC5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogRm9ybVRhYmxlIGlzIGEgc3BlY2lmaWMgbGF5b3V0IGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIExhYmVscyBhbmQgaXRzIGNvbnRyb2xzIGluIHR3byBjb2x1bW5zXG4gKiBhbmQgNSBkaWZmZXJlbnQgem9uZXMuXG4gKlxuICogV2Ugc3VwcG9ydCBMRUZULCBNSURETEUsIFJJR0hULCBUT1AsIEJPVFRPTSB6b25lIHdoZXJlIHdlIGNhbiBwbGFjZSBvdXIgY29tcG9uZW50IG9yIHdpZGdldHMuXG4gKiBUaGlzXG4gKiBjb21wb25lbnQgaXMgdXNlZCBhcyBwcmltYXJ5IGxheW91dCB0byB3cmFwIGFsbCB0aGUgY29tbW9uIHVzZSBjYXNlcy4gRS5nLiBXaGVuIHdlIGxheSBvdXRcbiAqIGZpZWxkcyBpbiB0aGUgZm9ybSBJIGRvIG5vdCB3YW50IGNvbnRyb2xzIHRvIGJlIGF3YXJlIG9mIGVycm9yIHZhbGlkYXRpb24sIHNpemUsIGxhYmVscywgYW5kXG4gKiBzb21lIG90aGVyIHRoaW5ncy4gQ29udHJvbCBzdWNoIElOUFVUIGlzIGp1c3QgcmVzcG9uc2libGUgZm9yIHJldHJpZXZlIHVzZXIgdmFsdWUgYnV0IG5vdCBob3cgaXRcbiAqIGFwcGVhciBvbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGlzIHdheSB3ZSBjYW4gYmUgZmxleGlibGUgaG93IHdlIHRyZWF0IHdpZGdldHMgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBzaXR1YXRpb24gZGVwZW5kaW5nXG4gKiB3aGVyZSB0aGV5IGFwcGVhclxuXG4gKiBGb3JtVGFibGUganVzdCBsaWtlIHRoZSByZXN0IG9mIHRoZSBjb21wb25lbnRzIGFyZSB1c2luZyBNb2RlbCBkcml2ZW4gYXBwcm9hY2ggaG93IHRvIHdvcmsgd2l0aFxuICogZGF0YSwgbWVhbiB3ZSBhcmUgdXNpbmcgRm9ybUdyb3VwLCBGb3JtQ29udHJvbCBldGMuIEZvcm1Hcm91cCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIEZvcm1UYWJsZSxcbiAqIG90aGVyd2lzZSBpdHMgYXV0b21hdGljYWxseSBjcmVhdGVkIHdoZW4gdGhlIEZvcm1UYWJsZSBpcyBpbnN0YW50aWF0ZWQuXG4gKlxuICogRm9ybUdyb3VwIGlzIHNhdmVkIGluc29kZSBFbnZpcm9ubWVudCB3aGVyZSB3ZSBhcmUgdXNpbmcgdGhpcyB0byBwYXNzIHRoaXMgYXJvdW5kIHRoZSBwYWdlcyBhbmRcbiAqIGNvbXBvbmVudHMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBTaW1wbGUgTGF5b3V0IGZpZWxkcyBhbmQgaXRzIGNvbnRyb2xcbiAqXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYFxuICogIFx0XHRcdDxhdy1mb3JtLXRhYmxlIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgKG9uU3VibWl0KT0+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIiduYW1lJ1wiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogIFx0XHRcdFx0XHQ8YXctaW5wdXQtZmllbGQgW3R5cGVdPVwiJ3N0cmluZydcIj48L2F3LWlucHV0LWZpZWxkPlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidQcmVmZXJyZWQgQ29sb3JzJ1wiIFtuYW1lXT1cIidteUNvbG9ycydcIj5cbiAqICBcdFx0XHRcdFx0PGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgW2xheW91dF09XCInaW5saW5lJ1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGljaygkZXZlbnQpXCI+XG4gKiAgXHRcdFx0XHRcdDwvYXctY2hlY2tib3gtbGlzdD5cbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidHZW5kZXInXCIgW25hbWVdPVwiJ2dlbmRlcidcIj5cbiAqXG4gKiAgXHRcdFx0XHRcdDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiVmFsdWVzXCIgW3NlbGVjdGlvbl09XCJyYlNlbGVjdGlvblwiPlxuICpcbiAqICBcdFx0XHRcdFx0PC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICpcbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidNeSBiaXJ0aGRhdGUnXCIgW25hbWVdPVwiJ2JpcnRoRGF0ZSdcIiBbc2l6ZV09XCInc21hbGwnXCI+XG4gKlxuICogIFx0XHRcdFx0XHQ8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgW3Nob3dUaW1lXT1cInNob3dUaW1lXCI+XG4gKiAgXHRcdFx0XHRcdDwvYXctZGF0ZS10aW1lPlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHQ8L2F3LWZvcm0tdGFibGU+XG4gKiAgICBgXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgU2hvd1VzZXJJbmZvQ29tcG9uZW50XG4gKiAge1xuICogICAgICAgY2hlY2tCb3hMaXN0VmFsdWVzOiBzdHJpbmdbXSA9IFsnYmx1ZScgLCAncmVkJyAsICd5ZWxsb3cnICwgJ29yYW5nZScgLCAnd2hpdGUnICwgJ3NpbHZlcidcbiAqICAgICAsICdibGFjaycgLCAnR3JlZW4nXG4gKiAgICAgLCAnR3JheScgLCAnTmF2eScgLFxuICogICAgICAgICAgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqICAgICAgc2VsZWN0ZWRWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKiAgICAgIHJiVmFsdWVzOiBzdHJpbmdbXSA9IFsnbWFsZScgLCAnZmVtYWxlJyAsICdvdGhlciddO1xuICogICAgICByYlNlbGVjdGlvbjogc3RyaW5nID0gJ21hbGUnO1xuICogICAgICBlZGl0YWJsZTogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgIHNob3dUaW1lOiBib29sZWFuID0gdHJ1ZTtcbiAqXG4gKiAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgb25DQkNsaWNrIChldmVudCk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIG9uU3VibWl0IChtb2RlbDogYW55KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG1vZGVsKVxuICpcbiAqICAgICAgICAgLy8gd2lsbCBwcmludCB7IG5hbWU6bnVsbCwgbXlDb2xvcnM6WydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ10sIGdlbmRlcjpcbiAqICAgICBtYWxlfVxuICogICAgICB9XG4gKlxuICogIH1cbiAqXG4gKiAgYGBgXG4gKlxuICogIE9yIHlvdSBjYW4gdXNlIHpvbmUgdG8gbGF5b3V0IHRoZXNlIGZpZWxkcyBpbnRvIHR3byBjb2x1bW5zOlxuICpcbiAqICBDdXJyZW50IHpvbmVzIGFyZSBpbXBsZW1lbnQgd2l0aCA8bmctY29udGVudCBTRUxFQ1Q+IHdoaWNoIGlzIGp1c3QgYSBzZWxlY3RvciB0byBzZWFyY2hlcyBmb3JcbiAqICAgICBzcGVjaWZpYyBwYXR0ZXJuLiBJbiBvdXIgY2FzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGV4dHJhIHdyYXBwZXIgY3VzdG9tIGNvbXBvbmVudCB1c2Ugc2ltcGxlXG4gKiAgICAgQ1NTIGNsYXNzXG4gKlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgI21ldGFGb3JtVGFibGUgW2VkaXRhYmxlXT1cImVkaXRpbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFt1c2VGaXZlWm9uZV09XCJpc0ZpdmVab25lTGF5b3V0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25TdWJtaXQpPVwib25TYXZlQWN0aW9uKCRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICA8YXctbGVmdCAgKm5nSWY9XCJjYW5TaG93Wm9uZSgnekxlZnQnKVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInbmFtZSdcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1pbnB1dC1maWVsZCBbdHlwZV09XCInc3RyaW5nJ1wiPjwvYXctaW5wdXQtZmllbGQ+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidQcmVmZXJyZWQgQ29sb3JzJ1wiIFtuYW1lXT1cIidteUNvbG9ycydcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1jaGVja2JveC1saXN0IFtsaXN0XT1cImNoZWNrQm94TGlzdFZhbHVlc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25zXT1cInNlbGVjdGVkVmFsdWVzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xheW91dF09XCInaW5saW5lJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvbkNCQ2xpY2soJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgPC9hdy1sZWZ0PlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICA8YXctcmlnaHQgICpuZ0lmPVwiY2FuU2hvd1pvbmUoJ3pSaWdodCcpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0dlbmRlcidcIiBbbmFtZV09XCInZ2VuZGVyJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiVmFsdWVzXCIgW3NlbGVjdGlvbl09XCJyYlNlbGVjdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ015IGJpcnRoZGF0ZSdcIiBbbmFtZV09XCInYmlydGhEYXRlJ1wiXG4gKiAgICAgW3NpemVdPVwiJ3NtYWxsJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRhdGUtdGltZSBbdmFsdWVdPVwiZGF0ZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gKiAgICAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRhdGUtdGltZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgIDwvPGF3LXJpZ2h0PlxuICogICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogIGBgYFxuICpcbiAqICB0b2RvOiByZW1vdmUgbXkgY3NzIHNlbGVjdG9ycyBmb3Igem9uZXMgYW5kIHJlcGxhY2UgaXQgd2l0aCByZWFsIGNvbXBvbmVudCBldmVuIGp1c3QgYSB0YWdcbiAqICB0b2RvOiB3b3VsZCB3b3JrIGZpbGVcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZm9ybS10YWJsZScsXG4gICAgdGVtcGxhdGU6IGA8Zm9ybSBjbGFzcz1cInctZm9ybS10YWJsZSB1aS1nIHVpLWZsdWlkXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIlxuICAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiXG4gICAgICAobmdTdWJtaXQpPVwib25TdWJtaXRGb3JtKGZvcm1Hcm91cC52YWx1ZSlcIiBub3ZhbGlkYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG48L2Zvcm0+XG5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLWNvbnRhaW5lcj5mb3Jte21hcmdpbi10b3A6MWVtfS53LWZvcm0tdGFibGUgYnV0dG9ue2Zsb2F0OnJpZ2h0fWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1UYWJsZUNvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtVGFibGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHRoZSBmb3JtIGxheW91dCB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbGFiZWxzIHN0YWNrZWQgIG9yIHNpZGUgYnkgc2lkZSBuZXh0IHRvXG4gICAgICogdGhlIGNvbnRyb2xcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxzT25Ub3A/OiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgdGhpcyBhIDQgem9uZSBsYXlvdXRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlRml2ZVpvbmU/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgY2VydGFpbiB1c2VjYXNlIHdlIGRvbnQgd2FudCB0byBzZXQgYXV0b21hdGljYWxseSB0aGlzIHRvIGFsbCBjaGlsZHJlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFiaWxpdHlDaGVjazogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiAgVHJpZ2dlcnMgd2hlbiB0aGUgPGZvcm0+IGlzIHN1Ym1pdHRlZC4gb25TdWJtaXQgd2UgZW1pdCB0aGUgd2hvbGUgZm9ybUNvbnRyb2xsZXIgb2JqZWN0c1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblN1Ym1pdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgcmVwcmVzZW50IGluZGl2aWR1YWwgem9uZXMgYW5kIHdlIHVzZSB0aGVtIHRvIGFkanVzdCBvdXIgY29sdW1uIGdyaWRcbiAgICAgKiBsYXlvdXRcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKExlZnRab25lQ29tcG9uZW50KSBsZWZ0Wm9uZTogTGVmdFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKE1pZGRsZVpvbmVDb21wb25lbnQpIG1pZGRsZVpvbmU6IE1pZGRsZVpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKFJpZ2h0Wm9uZUNvbXBvbmVudCkgcmlnaHRab25lOiBSaWdodFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKFRvcFpvbmVDb21wb25lbnQpIHRvcFpvbmU6IFRvcFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKEJvdHRvbVpvbmVDb21wb25lbnQpIGJvdHRvbVpvbmU6IEJvdHRvbVpvbmVDb21wb25lbnQ7XG5cblxuICAgIEBDb250ZW50Q2hpbGRyZW4oQmFzZUZvcm1Db21wb25lbnQsIHtkZXNjZW5kYW50czogdHJ1ZX0pXG4gICAgZm9ybUZpZWxkczogUXVlcnlMaXN0PEJhc2VGb3JtQ29tcG9uZW50PjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSwge2Rlc2NlbmRhbnRzOiB0cnVlfSlcbiAgICByb3dzOiBRdWVyeUxpc3Q8Rm9ybVJvd0NvbXBvbmVudD47XG5cblxuICAgIC8qKlxuICAgICAqIENhY2hlIGNhbGN1bGF0ZWQgcHJvcGVydGllcyB3aGVuIGluaXQgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc09uZUNvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhhc1R3b0NvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhhc1RocmVlQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBudWxsKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ2VkaXRhYmxlJ10pICYmXG4gICAgICAgICAgICBjaGFuZ2VzWydlZGl0YWJsZSddLnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXNbJ2VkaXRhYmxlJ10uY3VycmVudFZhbHVlKSB7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUZpZWxkcygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBvblN1Ym1pdEZvcm0oZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25TdWJtaXQuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcmUgbGFiZWxzIG9uIHRvcFxuICAgICAqXG4gICAgICovXG4gICAgaXNMYWJlbHNPblRvcCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNPblRvcDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSBjaGlsZCBjb21wb25lbnQgdG8gaW5oZXJpdCBlZGl0YWJpbGl0eVxuICAgICAqXG4gICAgICovXG4gICAgaXNGb3JtRWRpdGFibGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGU7XG4gICAgfVxuXG5cbiAgICBhcHBseUNvbHVtbnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZUZpdmVab25lICYmIHRoaXMuaGFzQW55Wm9uZXMoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lcyBkZXRlY3RlZCBpbiB0aGUgRm9ybVRhYmxlIGJ1dCB1c2VGaXZlWm9uZSBvcHRpb24gaXMgZmFsc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzT25lQ29sdW1uID0gIWlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiYgIWlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpO1xuICAgICAgICB0aGlzLmhhc1R3b0NvbHVtbiA9IGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSAmJiBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmXG4gICAgICAgICAgICAhaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSk7XG5cbiAgICAgICAgdGhpcy5oYXNUaHJlZUNvbHVtbiA9IGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSAmJiBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmXG4gICAgICAgICAgICBpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNUd29Db2x1bW4gJiYgIXRoaXMuaXNUd29ab25lUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTYnO1xuICAgICAgICAgICAgdGhpcy5yaWdodFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy02JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc1RocmVlQ29sdW1uICYmICF0aGlzLmlzVGhyZWVab25lUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTQnO1xuICAgICAgICAgICAgdGhpcy5yaWdodFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy00JztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBoYXNBbnlab25lcygpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgfHwgaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSlcbiAgICAgICAgICAgIHx8IGlzUHJlc2VudCh0aGlzLnRvcFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLmJvdHRvbVpvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSBpbml0aWFsaXplZCB0aGUgY2xhc3NMaXN0LlxuICAgICAqIHRoZVxuICAgICAqXG4gICAgICogVE9ETzogUHJvYmFibHkgc3RyaW5nIGFycmF5IHdvdWxkIGJlIGVhc2llclxuICAgICAqL1xuICAgIGlzVHdvWm9uZVJlYWR5KCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy02JykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy02JykgPiAwO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBhbHJlYWR5IGluaXRpYWxpemVkIHRoZSBjbGFzc0xpc3QuXG4gICAgICogdGhlXG4gICAgICpcbiAgICAgKiBUT0RPOiBQcm9iYWJseSBzdHJpbmcgYXJyYXkgd291bGQgYmUgZWFzaWVyXG4gICAgICovXG4gICAgaXNUaHJlZVpvbmVSZWFkeSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNCcpID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNCcpID4gMDtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gcHJvYmxlbSBzaW5jZSBBbmd1bGFyIDQuMiwgbmdBZnRlckNvbnRlbnRJbml0XG4gICAgICAgIC8vIHdpdGhvdXQgdGhpcyBJIGdldCBlcnJvciB0aGF0IHZhbHVlIHdhcyBjaGFuZ2VkIGFmdGVyIHZpZXcgd2FzIGNoZWNrZWRcbiAgICAgICAgLy8gdG9kbzogcmVmYWN0b3IgIC0gbWFpbmx5IG91ciB6b25lcyBsZWZ0LCByaWdodCBtaWRkbGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Q29sdW1ucygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtRmllbGRzKCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdExheW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdXBkYXRlRm9ybUZpZWxkcygpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJpbGl0eUNoZWNrICYmIGlzUHJlc2VudCh0aGlzLmZvcm1GaWVsZHMpICYmIHRoaXMuZm9ybUZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1GaWVsZHMuZm9yRWFjaCgoaXRlbTogQmFzZUZvcm1Db21wb25lbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXRlbS5lZGl0YWJsZSA9IHRoaXMuZWRpdGFibGU7XG4gICAgICAgICAgICAgICAgLy8gaXRlbS5mb3JtR3JvdXAgPSB0aGlzLmZvcm1Hcm91cDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiBpZiB3ZSBhcmUgMiBvciAzIG9yIDEgY29sdW1uIGxheW91dCB3ZSBuZWVkIHRvIGFkanVzdCB3aWRnZXRzIHdpZHRoIHdpdGhpbiB0aGVcbiAgICAgKiBmb3JtIHJvdy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFkanVzdExheW91dCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucm93cykgJiYgdGhpcy5yb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1RocmVlQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzLmZvckVhY2goKGl0ZW06IEZvcm1Sb3dDb21wb25lbnQpID0+IGl0ZW0uc2l6ZSA9ICdsYXJnZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1UYWJsZUNvbXBvbmVudH0gZnJvbSAnLi9mb3JtLXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4vZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgQm90dG9tWm9uZUNvbXBvbmVudCxcbiAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICBUb3Bab25lQ29tcG9uZW50XG59IGZyb20gJy4uL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRm9ybVRhYmxlQ29tcG9uZW50LFxuICAgICAgICBGb3JtUm93Q29tcG9uZW50LFxuICAgICAgICBUb3Bab25lQ29tcG9uZW50LFxuICAgICAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgICAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgICAgICBCb3R0b21ab25lQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Zvcm1UYWJsZU1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50LCBWYWx1ZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGVjaW1hbFBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZXByZXNlbnQgYSBJbnB1dCBmaWVsZCBhbmQgaXQgY2FuICBhY2NlcHQgZGlmZmVyZW50IHR5cGVzIG9mIHZhbHVlcyBzdWNoIGFzXG4gKiB0ZXh0LCBudW1iZXIuXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICd3cmFwcGVyLWNvbXAnICxcbiAqICAgICAgdGVtcGxhdGU6ICc8YXctaW5wdXQtZmllbGQgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiBbdHlwZV09XCJpbnB1dFR5cGVcIj48L2F3LWlucHV0LWZpZWxkPidcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBUZXN0SW5wdXRDb21wb25lbnRcbiAqICB7XG4gKiAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHRleHQnO1xuICpcbiAqICAgICAgLy8gYnkgZGVmYXVsdCBpbnB1dCB0eXBlIGlzIHRleHQsIHlvdSBjYW4gcGFzcyBzdHJpbmcsIFN0cmluZywgb3IgdGV4dFxuICogICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogIH1cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIHdoZXIgaW5wdXQgZmllbGQgaXMgaW5pdGlhbGl6ZWQgd2l0aCBuZ01vZGVsXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1pbnB1dC1maWVsZCBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFsobmdNb2RlbCldPVwiaW5wdXRUeXBlXCI+PC9hdy1pbnB1dC1maWVsZD4nXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgVGVzdElucHV0Q29tcG9uZW50XG4gKiAge1xuICogICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSB0ZXh0JztcbiAqXG4gKiAgICAgIC8vIGJ5IGRlZmF1bHQgaW5wdXQgdHlwZSBpcyB0ZXh0LCB5b3UgY2FuIHBhc3Mgc3RyaW5nLCBTdHJpbmcsIG9yIHRleHRcbiAqICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICB9XG4gKlxuICogYGBgXG4gKlxuICogIE5vdGU6IGlmIHlvdSBhcmUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIEZvcm1UYWJsZSBwbGVhc2UgcHJvdmlkZSB5b3VyIG93biBGb3JtR3JvdXBcbiAqXG4gKi9cblxuXG5cbmV4cG9ydCBjb25zdCBJTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSW5wdXRGaWVsZENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1pbnB1dC1maWVsZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiZWRpdGFibGVcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiIGNsYXNzPVwidy1pbnB1dC13cmFwcGVyXCI+XG5cbiAgICA8aW5wdXQgcElucHV0VGV4dFxuICAgICAgICAgICAjaW5wdXRGaWVsZFZhbHVlXG4gICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgIFthdHRyLnR5cGVdPVwidHlwZVwiXG4gICAgICAgICAgIGNsYXNzPVwidy1pbnB1dC1maWVsZFwiXG4gICAgICAgICAgIFtuZ0NsYXNzXT1cInN0eWxlQ2xhc3NcIlxuICAgICAgICAgICBbY2xhc3MuaGFzLWljb25dPVwiaWNvblwiXG4gICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3twbGFjZUhvbGRlcn19XCJcbiAgICAgICAgICAgW2NsYXNzLnUtdmFsaWRhdGlvbi1lcnJvcl09XCIhKGZvcm1Db250cm9sLnZhbGlkIHx8IChmb3JtQ29udHJvbC5wcmlzdGluZSkpXCJcbiAgICAgICAgICAgZm9ybUNvbnRyb2xOYW1lPVwie3tuYW1lfX1cIlxuICAgICAgICAgICAoa2V5ZG93bik9XCJvbktleURvd24oaW5wdXRGaWVsZFZhbHVlKVwiXG4gICAgICAgICAgIChibHVyKT1cIm9uQmx1cihpbnB1dEZpZWxkVmFsdWUpXCJcbiAgICAgICAgICAgW3ZhbHVlXT1cImRpc3BsYXlWYWx1ZVwiPlxuICAgIDxzcGFuICpuZ0lmPVwiaWNvblwiIGNsYXNzPVwic2FwLWljb25cIiBbbmdDbGFzc109XCJpY29uXCI+PC9zcGFuPlxuPC9kaXY+XG5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cImRpc3BsYXlWYWx1ZVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWlucHV0LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmV9LnctaW5wdXQtZmllbGR7cGFkZGluZy1yaWdodDozNXB4fS53LWlucHV0LWZpZWxkfnNwYW57dG9wOjEzcHg7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MTVweH1gXSxcblxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBJTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSW5wdXRGaWVsZENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dEZpZWxkQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHNhdmUgYW5kIHJlYWQgIHdoZW4gcmVuZGVyaW5nIGFuZCB1cGRhdGluZyBhIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdXNlZCB0byBmb3JtYXQgdGhlIG51bWJlciBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByZWNpc2lvbjogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQmlnRGVjaW1hbCBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdmFsdWUgYW5kIGxvY2FsZS5cbiAgICAgKiBJZiB0aGlzIG9iamVjdCBpcyBzZXQsIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJpZ0RlY2ltYWw6IEJpZ0RlY2ltYWw7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGN1c3RvbSBpY29uIHRoYXQgaXMgcGxhY2VkIGludG8gdGhlIGlucHV0IGZpZWxkLlxuICAgICAqXG4gICAgICogVG9kbzogYWRkIGV4dHJhIGJpbmRpbmcgdGhhdCB3aWxsIGFsbG93IGRldmVsb3BlciB0byB0ZWxsIHBvc2l0aW9uLCBsZWZ0IHJpZ2h0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpY29uOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGRlY2ltYWwgcGlwZSBpcyB1c2VkIHRvIGZvcm1hdCBvdXIgbnVtYmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBkZWNpbWFsUGlwZTogRGVjaW1hbFBpcGU7XG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBkZWNpbWFsIHZhbHVlLiBVc2VzIGFuZ3VsYXIgZGVjaW1hbFBpcGUgdG8gZm9ybWF0IGJhc2VkIG9uIGxvY2FsZS5cbiAgICAgKi9cbiAgICBkaXNwbGF5VmFsdWU6IHN0cmluZyA9ICcnO1xuICAgIC8qKlxuICAgICAqIEp1c3QgdG8gY2xlYW4gdXAgc3Vic2NyaWJlciB3aGVuIGNvbXBvbmVudCBpcyBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIHZjaFN1YnNjcmliZXI6IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kZWNpbWFsUGlwZSA9IG5ldyBEZWNpbWFsUGlwZShlbnYubG9jYWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBmaWVsZCB0eXBlLiBDdXJyZW50bHkgd2Ugc3VwcG9ydCBlaXRoZXIgTnVtYmVyIG9yIHRleHRcbiAgICAgKi9cbiAgICBwcml2YXRlIF90eXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcblxuICAgIGdldCB0eXBlKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBnZW5lcmF0ZWQgc2V0dGVyIHRvIGNoZWNrIGZvciB2YWx1ZSBhbmQgbm9ybWFsaXppbmcgaW50byBleHBlY3RlZCBlaXRoZXIgbnVtYmVyIG9yIHRleHRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IHR5cGUodmFsdWU6IHN0cmluZylcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnc3RyaW5nJyB8fCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAndGV4dCc7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPSAnbnVtYmVyJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5iaWdEZWNpbWFsKTtcblxuICAgICAgICB0aGlzLnZjaFN1YnNjcmliZXIgPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuYmlnRGVjaW1hbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdE51bWJlcih0aGlzLmJpZ0RlY2ltYWwuYW1vdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNhblNldFR5cGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb25LZXlEb3duKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gZWwudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuZGlzcGxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQmx1cihlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX3R5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmJpZ0RlY2ltYWwgPSBuZXcgQmlnRGVjaW1hbChOdW1iZXIoZWwudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXROdW1iZXIodGhpcy5iaWdEZWNpbWFsLmFtb3VudCk7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuZGlzcGxheVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5kaXNwbGF5VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gJyc7XG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHtvbmx5U2VsZjogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRoZSBudW1iZXIgb2JqZWN0IGFjY29yZGluZyB0byBpdHMgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICovXG4gICAgZm9ybWF0TnVtYmVyKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBwcmVjaXNpb24gaXMgcHJlc2VudCwgdXNlIGl0IGZvciBmb3JtYXQgdGhlIGJpZ0RlY2ltYWwgdmFsdWUgZm9yIGRpc3BsYXkuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wcmVjaXNpb24pICYmXG4gICAgICAgICAgICB0aGlzLl90eXBlID09PSAnbnVtYmVyJylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlzIDIuIEZvciBleGFtcGxlLCAxMC4yMy5cbiAgICAgICAgICAgIGxldCBkaWdpdHMgPSAnMS4wLTInO1xuICAgICAgICAgICAgZGlnaXRzID0gJzEuMC0nICsgdGhpcy5wcmVjaXNpb247XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNpbWFsUGlwZS50cmFuc2Zvcm0odmFsdWUsIGRpZ2l0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnZjaFN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnZjaFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCaWdEZWNpbWFsIG9iamVjdCBpcyByZXByZXNlbnRlZCBhcyBhIHZhbHVlLCBsb2NhbGUsIGFuZCBjdXJyZW5jeUNvZGVcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZ0RlY2ltYWwgaW1wbGVtZW50cyBWYWx1ZVxue1xuICAgIHVuaXF1ZU5hbWU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBhbW91bnQ6IG51bWJlciA9IDAsXG4gICAgICAgICAgICAgICAgcHVibGljIHJlYWRvbmx5IGxvY2FsZTogc3RyaW5nID0gJ2VuX1VTJylcbiAgICB7XG4gICAgfVxuXG5cbiAgICBnZXRUeXBlcygpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IE51bWJlcixcbiAgICAgICAgICAgIGxvY2FsZTogU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3NOYW1lKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuICdCaWdEZWNpbWFsJztcbiAgICB9XG5cbiAgICAkcHJvdG8oKTogQmlnRGVjaW1hbFxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKDEsICdlbl9VUycpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50ICsgJywgbG9jYWxlOiAnICsgdGhpcy5sb2NhbGU7XG4gICAgfVxuXG5cbiAgICBjbG9uZShkYXRhOiB7IGFtb3VudD86IG51bWJlciwgbG9jYWxlPzogc3RyaW5nIH0gPSB7fSk6IEJpZ0RlY2ltYWxcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnRGVjaW1hbChcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmFtb3VudCkgPyBkYXRhLmFtb3VudCA6IHRoaXMuYW1vdW50LFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEubG9jYWxlKSA/IGRhdGEubG9jYWxlIDogdGhpcy5sb2NhbGUpO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1N0cmluZ0NvbXBvbmVudH0gZnJvbSAnLi9zdHJpbmcuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU3RyaW5nQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU3RyaW5nQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU3RyaW5nRmllbGRNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtJbnB1dFRleHRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvY29tcG9uZW50cy9pbnB1dHRleHQvaW5wdXR0ZXh0JztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbnB1dEZpZWxkQ29tcG9uZW50fSBmcm9tICcuLi9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIElucHV0RmllbGRDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgSW5wdXRGaWVsZENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBJbnB1dEZpZWxkQ29tcG9uZW50LFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0lucHV0RmllbGRNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVGVtcGxhdGVSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7QXBwQ29uZmlnLCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqXG4gKiBiYXNpYyBuYXZpZ2F0aW9uIGJhciBwcm92aWRlIGEgbWFpbiBhY3Rpb24gYnV0dG9ucyBmb3IgaXRzIGNvbnRlbnQgKHBhZ2UgbGV2ZWwgYnV0dG9ucykuXG4gKiBUaGlzIGlzIG5vdCB0aGUgVG9wIGxldmVsIGFwcGxpY2F0aW9uIG5hdmlnYXRpb24uIFRoaXMgY29tcG9uZW50IHByb3ZpZGVzIGJ5IGRlZmF1bHQgYWN0aW9uIE9LLFxuICogQ0FOQ0VMIGFuZCB5b3UgYXJlIGZyZWUgdG8gbW9kaWZ5IGhvdyB0aGUgT0sgb3IgQ0FOQ0VMIHdpbGwgYmUgY2FsbCBhcyB3ZWxsIGFzIHN1YnNjcmliZSB0byB0aGVcbiAqIGV2ZW50LiBPciB5b3UgY2FuIHByb3ZpZGUgeW91ciBvd24gYnV0dG9ucyB0ZW1wbGF0ZSB3aGljaCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGlzIGRlZmF1bHRcbiAqIG9uZS5cbiAqXG4gKlxuICpcbiAqXG4gKlxuICogIyMjIEV4YW1wbGUgMTpcbiAqXG4gKiBJbiBvcmRlciB0byB1c2UgbmF2aWdhdGlvbiBiYXIgaW4gaXRzIGJhc2ljIHVzYWdlIHlvdSBjYW4gZG8gZm9sbG93aW5nOlxuICogdGhpcyB3aWxsIHJlbmRlciBidXR0b25zIG9uIHRoZSB0b3AgYXMgd2VsbCBhcyBvbiB0aGUgYm90dG9tIGFyb3VuZCB0aGUgY29udGVudC5cbiAqXG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgICAgIDxhdy1iYXNpYy1uYXZpZ2F0b3IgW2JyYW5kSW1nXT1cIidpbWcvYXJpYmFsb2dvYmFsLnBuZydcIj5cbiAqXG4gKiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAqICAgICAgICAgICAgICAgIDxmb3JtPlxuICogICAgICAgICAgICAgICAgICAgIFVzZXIgbmFtZTogPGlucHV0IHR5cGU9dGV4dCB2YWx1ZT1cInBldGVyLnBhblwiPlxuICogICAgICAgICAgICAgICAgPC88Zm9ybT4+XG4gKiAgICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L2F3LWJhc2ljLW5hdmlnYXRvcj5cbiAqXG4gKlxuICogYGBgXG4gKlxuICogIGlmIHlvdSBkbyBub3Qgd2FudCBidXR0b24gb24gdGhlIHRvcCBvciBib3R0b20geW91IGNhbiBzYXkgdGhpIHVzaW5nIGJpbmRpbmcgc2hvd1RvcCBvclxuICogc2hvd0JvdHRvbS5cbiAqXG4gKlxuICogIyMjIEV4YW1wbGUgMjpcbiAqICBJbiB0aGlzIGV4YW1wbGUgd2UgYXJlIHByb3ZpZGluZyBjdXN0b20gYnV0dG9ucyBhcyB3ZWxsIGFzIGJyYW5rIHNlY3Rpb25cbiAqXG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKlxuICogICAgICA8YXctYmFzaWMtbmF2aWdhdG9yIFticmFuZEltZ109XCInaW1nL2FyaWJhbG9nb2JhbC5wbmcnXCI+XG4gKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjYnV0dG9ucz5cbiAqICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cIm5hdiBuYXZiYXItbmF2IGZsb2F0LW1kLXJpZ2h0IGNvbGxhcHNlIG5hdmJhci10b2dnbGVhYmxlLXhzXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiIHR5cGU9XCJidXR0b25cIlxuICogKGNsaWNrKT1cIm9uU2F2ZUFjdGlvbigkZXZlbXQpXCI+Q2FuY2VsPC9idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAqICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBhY3RpdmVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIHR5cGU9XCJidXR0b25cIlxuICogKGNsaWNrKT1cIm9uQ2FuY2VsQWN0aW9uKCRldmVudClcIj4gU2F2ZVxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICogICAgICAgICAgICAgICAgPC91bD5cbiAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjYnJhbmQ+XG4gKiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJyYW5kLXRpdGxlXCI+QXJpYmE8L3NwYW4+XG4gKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICogICAgICAgICAgICAgICAgPGZvcm0+XG4gKiAgICAgICAgICAgICAgICAgICAgVXNlciBuYW1lOiA8aW5wdXQgdHlwZT10ZXh0IHZhbHVlPVwicGV0ZXIucGFuXCI+XG4gKiAgICAgICAgICAgICAgICA8Lzxmb3JtPj5cbiAqICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvYXctYmFzaWMtbmF2aWdhdG9yPlxuICpcbiAqXG4gKiBgYGBcblxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1iYXNpYy1uYXZpZ2F0b3InLFxuICAgIHRlbXBsYXRlOiBgPHAtdG9vbGJhciAqbmdJZj1cInNob3dUb3BcIiBbY2xhc3NdPVwiJ3ctYmFzaWMtbmF2aWdhdG9yJ1wiPlxuICAgIDxkaXYgY2xhc3M9XCJ1aS10b29sYmFyLWdyb3VwLWxlZnRcIj5cblxuICAgICAgICA8YSBjbGFzcz1cIm5hdi1icmFuZFwiIGhyZWY9XCIjXCIgKm5nSWY9XCJzaG93QnJhbmRcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzQnJhbmRUZW1wbGF0ZSgpXCI+XG4gICAgICAgICAgICAgICAgPGltZyBzcmM9XCJ7e2Fzc2V0Rm9sZGVyfX0ve3ticmFuZEltZ319XCIgaGVpZ2h0PVwiMzBcIiBhbHQ9XCJcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm5hdi1icmFuZC10aXRsZVwiPkFyaWJhPC9zcGFuPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiYnJhbmRUZW1wbGF0ZVwiIFtpdGVtXT1cImNvbnRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzQnJhbmRUZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9hPlxuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidWktdG9vbGJhci1ncm91cC1yaWdodFwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0J1dHRvblRlbXBsYXRlKClcIj5cblxuICAgICAgICAgICAgPGF3LWJ1dHRvbiAqbmdJZj1cInNob3dDYW5jZWxCdXR0b25cIiBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAoYWN0aW9uKT1cIm9uQ2FuY2VsQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIHt7Y2FuY2VsQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG5cbiAgICAgICAgICAgIDxhdy1idXR0b24gKGFjdGlvbik9XCJvbk9LQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIHt7b2tBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuXG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cImJ1dHRvbnNUZW1wbGF0ZVwiIFtpdGVtXT1cImNvbnRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCdXR0b25UZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuPC9wLXRvb2xiYXI+XG5cbjxuZy1jb250ZW50PjwvbmctY29udGVudD5cblxuPHAtdG9vbGJhciAqbmdJZj1cInNob3dCb3R0b21cIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aS10b29sYmFyLWdyb3VwLXJpZ2h0XCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzQnV0dG9uVGVtcGxhdGUoKVwiPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uICpuZ0lmPVwic2hvd0NhbmNlbEJ1dHRvblwiIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiXG4gICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DYW5jZWxBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAge3tjYW5jZWxBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuICAgICAgICAgICAgPGF3LWJ1dHRvbiAoYWN0aW9uKT1cIm9uT0tBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAge3tva0FjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJidXR0b25zVGVtcGxhdGVcIiBbaXRlbV09XCJjb250ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzQnV0dG9uVGVtcGxhdGUoKVwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG5cbjwvcC10b29sYmFyPlxuXG5cblxuYCxcbiAgICBzdHlsZXM6IFtgYS5uYXYtYnJhbmR7dmVydGljYWwtYWxpZ246bWlkZGxlO2xpbmUtaGVpZ2h0OmluaGVyaXQ7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6IzJkMzUzY31hLm5hdi1icmFuZDpmb2N1cyxhLm5hdi1icmFuZDpob3Zlcnt0ZXh0LWRlY29yYXRpb246bm9uZX1hLm5hdi1icmFuZCBzcGFue3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubmF2LWJyYW5kIGltZ3tkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7cGFkZGluZzozcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBidXR0b25zIHdpbGwgYmUgcmVuZGVyZWQgb24gdGhlIHRvcFxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBUUlVFXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dUb3A6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBidXR0b25zIHdpbGwgYmUgcmVuZGVyZWQgb24gdGhlIGJvdHRvbVxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBUUlVFXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dCb3R0b206IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYnJhbmQgc2VjdGlvbiB0aGF0IGlzIG9uIHRoZSBsZWZ0IHNpZGUgYW5kIG9ubHkgaW4gdGhlIHRvcCBiYXIgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBUUlVFXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dCcmFuZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGl2ZSBwYXRoIHRvIGEgaW1hZ2UuIEltYWdlcyBhcmUgc2F2ZWQgaW5zaWRlIGFzc2V0cyBmb2xkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJyYW5kSW1nOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBPSyBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9rQWN0aW9uTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIENhbmNlbCBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNhbmNlbEFjdGlvbkxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbnRleHQgaXMgYW4gb2JqZWN0IHdoaWNoIGlzIHJlbmRlcmVkIGluc2lkZSBuYXYtYmFyIGNvbnRlbnQuIFNvbWV0aW1lcyB0aGVyZSBhcmUgc2l0dWF0aW9uXG4gICAgICogdGhhdCB5b3Ugd2FudCB0byByZW5kZXIgc29tZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvYmplY3QgaW5zaWRlIG5hdmlnYXRpb24gYmFyLiBTbyB5b3UgYXJlXG4gICAgICogZnJlZSB0byBwYXNzIGEgY29udGV4dCBvYmplY3QgYW5kIHRoZW4gYWNjZXNzIGl0IGluc2lkZSB5b3VyIHRlbXBsYXRlXG4gICAgICpcbiAgICAgKiBgYGBIVE1MXG4gICAgICogICAgICAgICAgICA8bmctdGVtcGxhdGUgI2JyYW5kIGxldC1pdGVtPlxuICAgICAqICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYnJhbmQtdGl0bGVcIj57e2l0ZW0uZmlyc3ROYW1lfX08L3NwYW4+XG4gICAgICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250ZXh0OiBhbnk7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2hvd0NhbmNlbEJ1dHRvbjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRXZlbnRFbWl0dGVyIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4geW91IGNsaWNrIG9uIGRlZmF1bHQgT0sgQWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9LQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFdmVudEVtaXR0ZXIgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB5b3UgY2xpY2sgb24gZGVmYXVsdCBDQU5DRUwgQWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNhbmNlbEFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyBhIGJ1dHRvbnMgdGVtcGxhdGUgaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYnV0dG9ucycpXG4gICAgYnV0dG9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyBhIGJyYW5kIHRlbXBsYXRlIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2JyYW5kJylcbiAgICBicmFuZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cblxuICAgIGNvbnN0cnVjdG9yKGVudjogRW52aXJvbm1lbnQsIGFwcENvbmZpZzogQXBwQ29uZmlnKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICAvLyB0b2RvOiBsb2FkIHRoaXMgZnJvbSByZXNvdXJjZSBmaWxlIHVzaW5nIG5nVHJhbnNsYXRlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5va0FjdGlvbkxhYmVsID0gJ09LJztcbiAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb25MYWJlbCA9ICdDYW5jZWwnO1xuICAgICAgICB0aGlzLmJyYW5kSW1nID0gJ2ltYWdlcy9hcmliYWxvZ29iYWwucG5nJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNob3dDYW5jZWxCdXR0b24pKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dDYW5jZWxCdXR0b24gPSB0aGlzLmVkaXRhYmxlIHx8ICh0aGlzLm9uQ2FuY2VsQWN0aW9uLm9ic2VydmVycy5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5vbk9LQWN0aW9uLm9ic2VydmVycy5sZW5ndGggPiAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBidXR0b25zVGVtcGxhdGUgaXMgYXZhaWxhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNCdXR0b25UZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuYnV0dG9uc1RlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGJyYW5kVGVtcGxhdGUgaXMgYXZhaWxhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNCcmFuZFRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5icmFuZFRlbXBsYXRlKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBCdXR0b24gY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yLiBCdXR0b24gY2FuIGJlIHJlbmRlcmVkIGVpdGhlciBhc1xuICogYSBidXR0b24gb3IgYXMgYSBsaW5rLiBJdCBjb3VsZCBiZSBzdGFuZGFsb25lIG9yIGJlIHBhcnQgb2YgYSBmb3JtLlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgPGF3LWZvcm0tdGFibGUgPlxuICogICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInQW1vdW50J1wiIFtuYW1lXT1cIidhbW91bnQnXCIgW3NpemVdPVwiJ3NtYWxsJ1wiPlxuICpcbiAqICAgICAgICAgICA8YXctYnV0dG9uIFt0eXBlXT1cIidzdWJtaXQnXCIgW25hbWVdPVwiJ2J1dHRvbidcIlxuICogICAgICAgICAgICAgICAgICAgICAoYWN0aW9uKT1cIm9uQ2xpY2tlZCgkZXZlbnQpXCIgW3ZhbHVlXT1cImNvbW1hbmRcIlxuICogICAgICAgICAgICAgICAgICAgICBbc3R5bGVdPVwiJ3dhcm5pbmcnXCIgPkJ1dHRvbjwvYXctYnV0dG9uPlxuICogICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgPC9hdy1mb3JtLXRhYmxlPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBjb21tYW5kOmJvb2xlYW47XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICAgICAgb25DbGlja2VkKHZhbHVlOnN0cmluZykge1xuICogICAgICAgICAgIGlmICh2YWx1ZSkge1xuICogICAgICAgICAgICAgIC8vIHN1Ym1pdCBmb3JtLlxuICogICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZTogYDxidXR0b25cbiAgICBwQnV0dG9uXG4gICAgW2F0dHIudHlwZV09XCJ0eXBlXCJcbiAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgIFtuZ0NsYXNzXT1cImJ1dHRvbkNsYXNzXCJcbiAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgIFthdHRyLnZhbHVlXT1cInZhbHVlXCJcbiAgICAoY2xpY2spPVwiY2xpY2tlZCgkZXZlbnQpXCI+XG5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2J1dHRvbj5cbmAsXG4gICAgc3R5bGVzOiBbYC51aS1idXR0b24tbGlua3tjb2xvcjojMzM3YWI3O2ZvbnQtd2VpZ2h0OjQwMDtib3JkZXItcmFkaXVzOjA7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0udWktYnV0dG9uLWxpbmssLnVpLWJ1dHRvbi1saW5rLmFjdGl2ZSwudWktYnV0dG9uLWxpbms6YWN0aXZlLC51aS1idXR0b24tbGluazpmb2N1cywudWktYnV0dG9uLWxpbms6aG92ZXIsLnVpLWJ1dHRvbi1saW5rW2Rpc2FibGVkXXtib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9LnVpLWJ1dHRvbi1saW5rOmZvY3VzLC51aS1idXR0b24tbGluazpob3Zlcntjb2xvcjojMzM3YWI3Oy13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiMzMzdhYjc7dGV4dC1kZWNvcmF0aW9uOiMzMzdhYjc7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0udWktYnV0dG9uLWxpbmtbZGlzYWJsZWRdOmZvY3VzLC51aS1idXR0b24tbGlua1tkaXNhYmxlZF06aG92ZXJ7Y29sb3I6IzIzOTllNTt0ZXh0LWRlY29yYXRpb246bm9uZX0udWktYnV0dG9ue21hcmdpbi1yaWdodDo1cHh9LmJ0bi1taWR7aGVpZ2h0OjM2cHg7cGFkZGluZzo1cHggMTBweH0uYnRuLWxne2hlaWdodDo0MnB4O2ZvbnQtc2l6ZToxNnB4O3BhZGRpbmc6NXB4IDEycHh9LmJ0bi1zbXtoZWlnaHQ6MzBweDtmb250LXNpemU6MTJweDtwYWRkaW5nOjVweCAxMHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIEJ1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBCdXR0b24gdHlwZXMgIFsgYnV0dG9uIHwgc3VibWl0IHwgcmVzZXQgXVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBzdHJpbmcgPSAnYnV0dG9uJztcblxuICAgIC8qKlxuICAgICAqIE5hbWUgZm9yIHRoaXMgYnV0dG9uLiBDYW4gYmUgdXNlZCB0byBsb29rdXAgY29tcG9uZW50IGluIGZvcm0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBuYW1lOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHN0eWxpbmcgZm9yIHRoaXMgYnV0dG9uLiBTZWUgQnV0dG9uU3R5bGUgZm9yIGFsbCBzdXBwb3J0ZWQgc3R5bGVzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3R5bGU6IEJ1dHRvblN0eWxlID0gJ3ByaW1hcnknO1xuXG5cbiAgICAvKipcbiAgICAgKiBzaXppbmcgZm9yIHRoaXMgYnV0dG9uLiBbbGFyZ2UsIG5vcm1hbCwgc21hbGxdLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2l6ZTogQnV0dG9uU2l6ZSA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgdGFyZ2V0IG9mIHRoZSBidXR0b24uIFtfYmxhbmsgfCBfc2VsZiB8IF9wYXJlbnQgfCBfdG9wIHwgZnJhbWVuYW1lIF1cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhcmdldDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gYmUgc2VuZCB0byBzZXJ2ZXIgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogUHJpbWVOZyBidXR0b24gc2ltcGx5IGRvZXMgbm90IHN1cHBvcnQgY29udGVudCBzbyB3ZSBuZWVkIHRvIGdldCBhcm91bmQgaXRcbiAgICAgKi9cbiAgICBsYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgQ1NTIGNsYXNzIHRoYXQgc3R5bGVzIHRoaXMgYnV0dG9uIGJhc2VkIG9uIGlucHV0ICdzdHlsZScgYW5kICdzaXplJ1xuICAgICAqL1xuICAgIGJ1dHRvbkNsYXNzOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIERlZmF1bHQgYnV0dG9uIGNsYXNzIGlzIHNlY29uZGFyeS5cbiAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICd1aS1idXR0b24tc2Vjb25kYXJ5JztcblxuICAgICAgICAvLyBEZWZhdWx0IGRpc2FibGVkXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICAvLyBIb3cgdG8gc3R5bGUgdGhpcyBidXR0b24uXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdHlsZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlID09PSAncHJpbWFyeScpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IC51aS1idXR0b24gYW5kIC51aS1idXR0b24tcHJpbWFyeSBnZXQgdGhlIHNhbWUgc3R5bGUuXG4gICAgICAgICAgICAgICAgLy8gLnVpLWJ1dHRvbi1wcmltYXJ5IGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGJ1dHRvbiBzdHlsZSBjYW4gYmUgb3ZlcnJpZGRlblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gaW5jbHVkZWQgaW5zaWRlIG90aGVyIHdpZGdldHMuIFNvIHNwZWNpZnkgcHJpbWFyeVxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAndWktYnV0dG9uLXByaW1hcnknO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJ3VpLWJ1dHRvbi0nICsgdGhpcy5zdHlsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgYnV0dG9uIGNsYXNzIGJhc2VkIG9uIGlucHV0IHNpemUuXG4gICAgICAgIGlmICh0aGlzLnNpemUpIHtcblxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsYXJnZScgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzICs9ICcgYnRuLWxnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbm9ybWFsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgKz0gJyBidG4tbWlkJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyArPSAnIGJ0bi1zbSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGxpdHRsZSBoYWNreSBoYWNraXR5IGhhY2sgYXMgY3VycmVudGx5IHByaW1lbmcgYnV0dG9uIGRpcmVjdGl2ZSBkb2VzIG5vdCB3b3JrIHdpdGhcbiAgICAgKiBuZ2NvbnRlbnQgcHJvamVjdGlvbiBidXQgaXQgaGFzIGEgbGFiZWwgYmluZGluZ3MsIHdoaWNoIGlzIG5vdCB0aGUgd2F5IGRldmVsb3BlcnMgd29yayB3aXRoXG4gICAgICogYnV0dG9uLiB5b3Ugd2FudCB0b1xuICAgICAqXG4gICAgICogPGJ1dHRvbj4gTVkgQ09OVEVOVDwvYnV0dG9uIGluc3RlYWQgb2YgPGJ1dHRvbiBsYWJlbD0nTXlDb250ZW50Jz48L2J1dHRvbj5cbiAgICAgKlxuICAgICAqXG4gICAgICogQFRvZG86IENoYW5nZSB0aGlzIHVudGlsIHRoZSB0aW1lIGtlZXAgYSB0ZXN0IHRoYXQgY2hlY2sgdGhhdCB0aGV5IGFyZSBzdGlsbCB1c2luZyB1aS1idXR0b25cbiAgICAgKiAgICAgdGhhdCB3ZSBhcmUgZXhwZWN0aW5nIGFuZCByZXBsYWNpbmdcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmVsZW1lbnQpKSB7XG4gICAgICAgICAgICBsZXQgYnV0dG9uID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uJyk7XG4gICAgICAgICAgICBsZXQgYnV0dG9uVGl0bGUgPSBidXR0b24uY2hpbGRyZW5bMF07XG4gICAgICAgICAgICBidXR0b24uY2hpbGRyZW5bMF0udGV4dENvbnRlbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC50ZXh0Q29udGVudC50cmltKClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgndWktYnV0dG9uJywgJycpLnJlcGxhY2UoJ3VpLWJ0bicsICcnKTtcblxuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ3VpLWJ1dHRvbi10ZXh0LWVtcHR5Jyk7XG4gICAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChidXR0b25UaXRsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQWN0aW9uIGNsaWNrZWQuIENhbGwgcGFyZW50IGFjdGlvbi5cbiAgICAgKi9cbiAgICBjbGlja2VkKCRldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5hY3Rpb24uZW1pdChpc0JsYW5rKHRoaXMudmFsdWUpID8gJGV2ZW50IDogdGhpcy52YWx1ZSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogU3VwcG9ydGVkIEJ1dHRvbiBTdHlsZVxuICovXG5leHBvcnQgdHlwZSBCdXR0b25TdHlsZSA9ICdpbmZvJyB8ICdwcmltYXJ5JyB8ICdzZWNvbmRhcnknIHwgJ3dhcm5pbmcnIHwgJ3N1Y2Nlc3MnIHwgJ2RhbmdlcicgfFxuICAgICdsaW5rJztcblxuLyoqXG4gKiBTdXBwb3J0ZWQgQnV0dG9uIFNpemVcbiAqL1xuZXhwb3J0IHR5cGUgQnV0dG9uU2l6ZSA9ICdsYXJnZScgfCAnbm9ybWFsJyB8ICdzbWFsbCc7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0J1dHRvbkNvbXBvbmVudH0gZnJvbSAnLi9idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7QnV0dG9uTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEJ1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEJ1dHRvbk1vZHVsZSxcblxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEJ1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBCdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdCdXR0b25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Jhc2ljTmF2aWdhdG9yQ29tcG9uZW50fSBmcm9tICcuL2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQnO1xuaW1wb3J0IHtUb29sYmFyTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEJhc2ljTmF2aWdhdG9yQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgVG9vbGJhck1vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEJhc2ljTmF2aWdhdG9yQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQmFzaWNOYXZpZ2F0b3JNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYGF3LWNhcmQtdG9wYCxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd3LWNhcmQtenRvcCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhcmRab25lVG9wQ29tcG9uZW50XG57XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgYXctY2FyZC1ib3R0b21gLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC16Ym90dG9tJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFpvbmVCb3R0b21Db21wb25lbnRcbntcbn1cblxuLyoqXG4gKlxuICogQ2FyZCBjb21wb25lbnQgaXMgYSBjb250YWluZXIgcmVuZGVyaW5nIGl0cyBjb250ZW50IGluc2lkZSAzIGRpZmZlcmVudCB6b25lcy5cbiAqXG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgfCAgIFRJVExFICAgICAgICAgICAgICAgICAgICAgICB8IEFDVElPTiB8XG4gKiAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgIFRPUCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgIEJPVFRPTSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICpcbiAqICBUaGVyZSBhcmUgMyB6b25lcyAgKyAxIHBsYWNlaG9sZGVyIGZvciB0aGUgYWN0aW9uSWNvblxuICpcbiAqICBDYXJkcyBjYW4gYmUgc2VsZWN0YWJsZSB3aGljaCBtZWFucyB3aGVuIHlvdSBjbGljayBvbiBpdCB0aGVyZSB3aWxsIGJlIHJlbmRlcmVkIGEgYm9yZGVyIHdpdGhcbiAqICBhIGNoZWNrIG1hcmsgaW5zaWRlIEFjdGlvbiB6b25lICh0aGlzIGlzIGRlZmF1bHQgYmVoYXZpb3IpLlxuICogIFlvdSBjYW4gdXNlIFtzZWxlY3RhYmxlXSBiaW5kaW5nIHRvIGRpc2FibGUgdGhpcywgaW4gc3VjaCBjYXNlIGNhcmQgd2lsbCBoYXZlIGp1c3QgYSBib3JkZXJcbiAqICB3aXRob3V0IGFueSBjaGVjayBtYXJrLlxuICpcbiAqICBDYXJkcyBjYW4gYWxzbyBjb250YWluIGN1c3RvbSBBY3Rpb24gd2hpY2ggaXMgcmVuZGVyZWQgaW5zaWRlIEFDVElPTiB6b25lIGFuZCBvbiB0aGVcbiAqICBhcHBsaWNhdGlvbiBsZXZlbCB5b3UgY2FuIGxpc3RlbiBmb3IgKGNsaWNrKSBldmVudHMgYXMgd2VsbCBhcyB5b3UgY2FuIHByb3ZpZGUgeW91ciBvd24gYWN0aW9uXG4gKiAgaWNvblxuICpcbiAqICBCZXNpZGVzIEFDVElPTiwgVElUTEUsIFRPUCBhbmQgQk9UVE9NIGNvbnRlbnQgem9uZXMgY2FyZHMgc3VwcG9ydCBob3ZlciBvdmVybGF5IGVmZmVjdCBhbmRcbiAqICB3aGVuIGl0cyBhY3RpdmF0ZWQgdGhlcmUgaXMgYSBvdmVybGF5IGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGNhcmQgd2l0aCBJY29uIGluIHRoZSBtaWRkbGUuXG4gKiAgUGxlYXNlIG5vdGUgd2hlbiBbaGFzSG92ZXJdIGlzIFRSVUUgYWxsIHRoZSBhY3Rpb25zIGFuZCBzZWxlY3RhYmlsaXR5IGFyZSBkaXNhYmxlZCBhcyB0aGVyZSBpc1xuICogIG9ubHkgb25lIGFjdGlvbiB3aGljaCBjbGljayBvbiB0aGUgaG92ZXIgb3ZlcmxheS5cbiAqXG4gKlxuICogIyMjZXhhbXBsZSAxOlxuICogIEJhc2ljIGhvdmVyIGNhcmQgd2hpY2ggYnkgZGVmYXVsdCBzdXBwb3J0IHNlbGVjdGFibGUgbW9kZVxuICpcbiAqIGBgYFxuICogICAgICAgICAgPGF3LWNhcmQgI2NhcmQxIFtoYXNBY3Rpb25dPVwiZmFsc2VcIiBbd2lkdGhdPVwiJzIwMnB4J1wiIFtoZWlnaHRdPVwiJzE1NHB4J1wiPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10aXRsZSBbYWxpZ25dPVwiJ2JvdHRvbS1sZWZ0J1wiPlxuICogICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImEtc3VwcGxpZXItdGFnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBQcmVmZXJyZWRcbiAqICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC10aXRsZT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdG9wPlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VwcGxpZXJOYW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBIYWlnaHQgUHVtcHNcbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllckxvY2F0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBQYWxvIEFsdG8sIENBLCBVU0FcbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRvcD5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtYm90dG9tIGNsYXNzPVwidy1jYXJkLXpib3R0b21cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgc29tZSB0ZXh0IGFib3V0IHRoZSBzdXBwbGllciBhbmQgaGlzIHBhcmVudHM8YnIvPlxuICogICAgICAgICAgICAgICAgICAgICBhbmQgc29tZSBjb250YWN0c1xuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC1ib3R0b20+XG4gKlxuICogICAgICAgICAgICAgPC9hdy1jYXJkPlxuICpcbiAqIGBgYFxuICpcbiAqICAjIyNleGFtcGxlIDI6XG4gKiAgIEhvdmVyIGNhcmQgd2l0aCBjdXN0b20gYWN0aW9uLiB3aGVuIHVuc2VsZWN0ZWQgYWN0aW9uIHdpbGwgYXBwZWFyIGFuZCB1c2VyIGNhbiBjbGljayBvbiBpdC5cbiAqXG4gKiBgYGBcbiAqICAgICAgICAgIDxhdy1jYXJkICNjYXJkMSBbc2VsZWN0YWJsZV09XCJ0cnVlXCIgW2FjdGlvbkljb25dPVwiJ2ljb24tcXVlc3Rpb24tbWFyaydcIlxuICogICAgICAgICAgICAgICAgICAgICAob25BY3Rpb24pPVwib25BY3Rpb24oMywgJGV2ZW50KVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10aXRsZSBbYWxpZ25dPVwiJ2JvdHRvbS1sZWZ0J1wiPlxuICogICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImEtc3VwcGxpZXItdGFnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBQcmVmZXJyZWRcbiAqICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC10aXRsZT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdG9wPlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VwcGxpZXJOYW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBIYWlnaHQgUHVtcHNcbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllckxvY2F0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICBQYWxvIEFsdG8sIENBLCBVU0FcbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRvcD5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtYm90dG9tIGNsYXNzPVwidy1jYXJkLXpib3R0b21cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgc29tZSB0ZXh0IGFib3V0IHRoZSBzdXBwbGllciBhbmQgaGlzIHBhcmVudHM8YnIvPlxuICogICAgICAgICAgICAgICAgICAgICBhbmQgc29tZSBjb250YWN0c1xuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC1ib3R0b20+XG4gKlxuICogICAgICAgICAgICAgPC9hdy1jYXJkPlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNhcmQnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctY2FyZFwiIFtzdHlsZS53aWR0aF09XCJ3aWR0aFwiIFtzdHlsZS5oZWlnaHRdPVwiaGVpZ2h0XCJcbiAgICAgW2NsYXNzLnUtaXMtaG92ZXJdPVwiaGFzSG92ZXJcIlxuICAgICAobW91c2VlbnRlcik9XCJvbkhvdmVyKHRydWUpXCJcbiAgICAgKG1vdXNlbGVhdmUpPVwib25Ib3ZlcihmYWxzZSlcIlxuICAgICBbY2xhc3MudS1jYXJkLXNlbGVjdGVkXT1cInNlbGVjdGVkXCJcbiAgICAgW2NsYXNzLnUtY2FyZC11bnNlbGVjdGVkXT1cIiFzZWxlY3RlZFwiXG4gICAgIFtuZ0NsYXNzXT1cInN0eWxlQ2xhc3NcIlxuPlxuXG4gICAgPGRpdiBjbGFzcz1cImNhcmQtYm9keSB1aS1nXCIgICpuZ0lmPVwiIXNob3dCb2R5VGVtcGxhdGUoKVwiPlxuICAgICAgICA8IS0tIEhvdmVyIGVsZW1lbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYnkgbW91c2VlbnRlciwgbW91c2VsZWF2ZSBldmVudHMtLT5cbiAgICAgICAgPGRpdiAjaG92ZXJEaXYgKm5nSWY9XCJoYXNIb3ZlclwiIGNsYXNzPVwidS1jYXJkLWhvdmVyXCIgKGNsaWNrKT1cIm9uSG92ZXJBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8c3BhbiBbc3R5bGUud2lkdGhdPVwiJzEwMCUnXCIgY2xhc3M9XCJzYXAtaWNvblwiIFtuZ0NsYXNzXT1cImhvdmVySWNvblwiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDwhLS0gSEVBREVSIEhBVklORyBUSVRMRSBBTkQgSUNPTlMvQUNUSU9OUy0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1nLW5vcGFkIHctY2FyZC1oZWFkZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LWNhcmQtenRpdGxlIHVpLWctbm9wYWRcIiAoY2xpY2spPVwidG9nZ2xlU2VsZWN0KCRldmVudClcIlxuICAgICAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLXBvaW50ZXJdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsndWktZy05JzogaGFzQWN0aW9uIHx8IHNlbGVjdGFibGUsICd1aS1nLTExJzogIWhhc0FjdGlvbiAmJiAhc2VsZWN0YWJsZX1cIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jYXJkLXRpdGxlXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJoYXNBY3Rpb24gfHwgc2VsZWN0YWJsZVwiIGNsYXNzPVwidy1jYXJkLXphY3Rpb24gdWktZy1ub3BhZCB1aS1nLTNcIj5cblxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwic2VsZWN0ZWQgJiYgc2VsZWN0YWJsZVwiIGNsYXNzPVwic2FwLWljb24gc2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLXBvaW50ZXJdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1hY3Rpb24tYmddPVwic2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVTZWxlY3QoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwic2VsZWN0ZWRJY29uXCI+PC9zcGFuPlxuXG5cbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cImhhc0FjdGlvbiAmJiAoIXNlbGVjdGVkIHx8ICFzZWxlY3RhYmxlKSBcIlxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic2FwLWljb24gYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLXBvaW50ZXJdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uQWN0aW9uQ2xpY2soJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiYWN0aW9uSWNvblwiXG4gICAgICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8IS0tVE9QIENBUkQgU0VDVElPTi0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidy1jYXJkLXp0b3AgdWktZy1ub3BhZCB1aS1nLTEyIFwiXG4gICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVNlbGVjdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLXBvaW50ZXJdPVwic2VsZWN0YWJsZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY2FyZC10b3BcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLWctbm9wYWQgdy1jYXJkLWxpbmUtZGl2aWRlciAgXCIgKm5nSWY9XCJzaG93Qm90dG9tU2VjdGlvbigpXCI+PC9kaXY+XG4gICAgICAgIDwhLS1CT1RUT00gQ0FSRCBTRUNUSU9OLS0+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJzaG93Qm90dG9tU2VjdGlvbigpXCIgY2xhc3M9XCJ1aS1nLTEyIHVpLWctbm9wYWQgdy1jYXJkLXpib3R0b21cIlxuICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlU2VsZWN0KCRldmVudClcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWNhcmQtYm90dG9tXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgKm5nSWY9XCJzaG93Qm9keVRlbXBsYXRlKClcIiBjbGFzcz1cInctY2FyZC11c2VyLWNudFwiID5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlUZW1wbGF0ZVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2Audy1jYXJke2JvcmRlcjoycHggc29saWQgIzAwNzZjYjtkaXNwbGF5OmlubGluZS1ibG9jaztvdmVyZmxvdzpoaWRkZW47Y29sb3I6IzYzNjM2Mztib3gtc2l6aW5nOmJvcmRlci1ib3h9LnctY2FyZC1oZWFkZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjMwcHg7cGFkZGluZy1sZWZ0OjFlbX0udy1jYXJkLXp0aXRsZXtoZWlnaHQ6MTAwJTtwYWRkaW5nLXRvcDozcHh9LnctY2FyZC16dGl0bGUgOjpuZy1kZWVwIC53LWNhcmQtdGl0bGV7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXh9LnctY2FyZC16dGl0bGUgOjpuZy1kZWVwIC53LWNhcmQtdGl0bGU+KntmbGV4OjAgMX0udy1jYXJkLXphY3Rpb257aGVpZ2h0OjEwMCU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjpyaWdodH0udy1jYXJkLXphY3Rpb24gLnNhcC1pY29ue3dpZHRoOjI5cHg7aGVpZ2h0OjI5cHg7dGV4dC1hbGlnbjpjZW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1zaXplOjEuNWVtO2xpbmUtaGVpZ2h0OjEuNGVtfS53LWNhcmQtemFjdGlvbiAuc2FwLWljb24uc2VsZWN0aW9ue2NvbG9yOiNmZmZ9LnctY2FyZC16YWN0aW9uIC5zYXAtaWNvbi5hY3Rpb257Y29sb3I6Izk2OTY5Nn0udy1jYXJkLXpib3R0b20sLnctY2FyZC16dG9we3BhZGRpbmc6MWVtfS53LWNhcmQtbGluZS1kaXZpZGVye2JvcmRlci10b3A6MXB4IHNvbGlkICNkNmQ2ZDY7bWFyZ2luOjAgMTRweH0udy1jYXJkLXVzZXItY250e3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cG9zaXRpb246cmVsYXRpdmU7YmFja2dyb3VuZC1jb2xvcjojZWVlfS51LWNhcmQtaG92ZXJ7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJTtvcGFjaXR5OjA7dHJhbnNpdGlvbjouNXMgZWFzZTtiYWNrZ3JvdW5kLWNvbG9yOiMwMDc2Y2I7ei1pbmRleDoxMDB9LnUtY2FyZC1ob3ZlciAuc2FwLWljb257dGV4dC1hbGlnbjpjZW50ZXI7ZGlzcGxheTppbmxpbmUtYmxvY2s7Zm9udC1zaXplOjRlbTtjb2xvcjojZmZmO3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKX0udS1jYXJkLWFjdGlvbi1iZ3tiYWNrZ3JvdW5kOiMwMDc2Y2J9LnUtaXMtaG92ZXJ7cG9zaXRpb246cmVsYXRpdmV9LnUtY2FyZC1zZWxlY3RlZHtib3JkZXItY29sb3I6IzAwNzZjYn0udS1jYXJkLXVuc2VsZWN0ZWR7Ym9yZGVyLWNvbG9yOiNkN2Q3ZDd9LnUtY2FyZC1ob3ZlciwudS1jYXJkLXBvaW50ZXJ7Y3Vyc29yOnBvaW50ZXJ9YF1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB3ZSBzaG91bGQgZXhwbGljaXRseSBoaWRlIHRoZSBhY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGFzQWN0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIHNlbGVjdGFibGUgbW9kZSBzdXBwb3J0ZWQ/IFNheWluZyBZZXMsIGNhcmQgd2lsbCBoYXZlIGJ5IGRlZmF1bHQgY2hlY2stbWFyayBpbiB0aGVcbiAgICAgKiBBQ1RJT04gem9uZSB3aGVuIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGFibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIFwiQ2FyZCBTZWxlY3RlZFwiIEljb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0ZWRJY29uOiBzdHJpbmcgPSAnaWNvbi1hY2NlcHQnO1xuXG4gICAgLyoqXG4gICAgICogVGhlcmUgaXMgbm8gZGVmYXVsdCB2YWx1ZSBmb3IgYWN0aW9uIGljb24sIHdoZW4gYXBwbGljYXRpb24gd2FudCB0byBhZGQgYWN0aW9uIHRvIHRoZSBjYXJkXG4gICAgICogaXQgbXVzdCBhbHNvIHByb3ZpZGUgYSBpY29uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFjdGlvbkljb246IHN0cmluZztcblxuICAgIC8qXG4gICAgICogRW5hYmxlIGFuZCBkaXNhYmxlcyBob3ZlciBlZmZlY3Qgb24gdG9wIG9mIHRoZSBjYXJkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoYXNIb3ZlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IGljb24gbmFtZSBmb3IgdGhlIGhvdmVyIG92ZXJsYXkuIFRoaXMgaWNvbnMgc2hvd3MgdXAgaW4gdGhlIG1pZGRsZSBvdmVyIHRoZSBjYXJkXG4gICAgICogdmVydGljYWxseSBhbmQgaG9yaXpvbnRhbGx5IGNlbnRlcmVkXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhvdmVySWNvbjogc3RyaW5nID0gJ2ljb24tYWRkJztcblxuXG4gICAgLyoqXG4gICAgICogIFNlbGVjdGlvbiBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RlZDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNhcmQgaXMgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGFjdGlvbiBpY29uIGlzIGNsaWNrZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgaG92ZXIgb3ZlcmxheS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uSG92ZXJBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIHF1ZXJ5IGlzIHVzZWQgdG8gc2F2ZSB0aGUgY29udGVudCByZWZlcmVuY2UgdG8gYm90dG9tIHNlY3Rpb24gaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChDYXJkWm9uZUJvdHRvbUNvbXBvbmVudClcbiAgICBib3R0b206IENhcmRab25lQm90dG9tQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBjdXN0b20gdGVtcGxhdGUgZm9yIHRoZSBib2R5IHdoaWNoIGlzIHVuZGVyIGFwcGxpY2F0aW9uIGRldmVsb3BlciBjb250cm9sLlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2JvZHknKVxuICAgIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgQFZpZXdDaGlsZCgnaG92ZXJEaXYnKVxuICAgIGhvdmVyRGl2OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogVXN1YWxseSB3aGVuIHRlbXBsYXRlIGlzIHByb3ZpZGVkIHdlIHdhbnQgdG8gdXNlIGl0IGFuZCByZXBsYWNlIGludGVybmFsIG9uZSBidXQgaW4gdGhpc1xuICAgICAqIGNhc2UgaXQgd2lsbCBiZSBhbHdheXMgY29uZGl0aW9uYWwgYW5kIGFwcGxpY2F0aW9uIGRldmVsb3BlciBjYW4gc3dpdGNoIGJldHdlZW4gZGVmYXVsdFxuICAgICAqIHRlbXBsYXRlIHdpdGggem9uZXMgYW5kIGN1c3RvbSBvbmUgcHJvdmlkZWQgYnkgZGV2ZWxvcGVyLlxuICAgICAqXG4gICAgICovXG4gICAgdXNlQm9keVRlbXBsYXRlOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICAvLyBzZXRzIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgdGhpcy53aWR0aCA9ICcyMDJweCc7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJzE1NHB4JztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIC8vIElmIGFwcGxpY2F0aW9uIHdhbnRzIHRvIHVzZSBhY3Rpb24gaXQgbXVzdCBwcm92aWRlIGFjdGlvbkljb25cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5hY3Rpb25JY29uKSAmJiB0aGlzLmhhc0FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBwcm92aWRlIGFjdGlvbiBpY29uJyk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBzaG93Qm90dG9tU2VjdGlvbigpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuYm90dG9tKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIGZpcmVzIHNlbGVjdCBhbmQgdW5zZWxlY3QgZXZlbnQuXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0KGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gIXRoaXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLm9uU2VsZWN0LmVtaXQodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE9ubHkgZmlyZWQgd2hlbiBhY3Rpb24gaXMgcmVuZGVyZWQgYW5kIHVzZXIgY2xpY2tzIG9uIGN1c3RvbSBhY3Rpb25JY29uXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkFjdGlvbkNsaWNrKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5oYXNBY3Rpb24gJiYgKCF0aGlzLnNlbGVjdGVkIHx8ICF0aGlzLnNlbGVjdGFibGUpKSB7XG4gICAgICAgICAgICB0aGlzLm9uQWN0aW9uLmVtaXQodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgIHdoZW4gaG92ZXIgZWZmZWN0IGlzIG9uICsgdXNlciBjbGljayBvbiB0aGUgY2FyZFxuICAgICAqXG4gICAgICovXG4gICAgb25Ib3Zlcihpc0VudGVyOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmhvdmVyRGl2KSkge1xuICAgICAgICAgICAgdGhpcy5ob3ZlckRpdi5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBpc0VudGVyID8gMC41IDogMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB0byBkZWNpZGUgaWYgd2Ugc2hvdWxkIHJlbmRlciBpbXBsaWNpdCBjYXJkIHRlbXBsYXRlIHdpdGggb3VyIHpvbmVzIG9yXG4gICAgICogdXNlciBwcm92aWRlZCB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgc2hvd0JvZHlUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuYm9keVRlbXBsYXRlKSAgJiYgdGhpcy51c2VCb2R5VGVtcGxhdGU7XG4gICAgfVxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBNYXBzIG91ciBpbnRlcm5hbCBhbGlnbm1lbnQgdmFsdWUgdG8gcmVhbCBjc3MgdmFsdWVzXG4gKlxuICovXG5jb25zdCBWQWxpZ25NYXAgPSB7XG4gICAgJ3RvcC1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICd0b3AtY2VudGVyJzogJ2ZsZXgtc3RhcnQnLFxuICAgICd0b3AtcmlnaHQnOiAnZmxleC1zdGFydCcsXG4gICAgJ2NlbnRlci1sZWZ0JzogJ2NlbnRlcicsXG4gICAgJ2NlbnRlci1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAnY2VudGVyLXJpZ2h0JzogJ2NlbnRlcicsXG4gICAgJ2JvdHRvbS1sZWZ0JzogJ2ZsZXgtZW5kJyxcbiAgICAnYm90dG9tLWNlbnRlcic6ICdmbGV4LWVuZCcsXG4gICAgJ2JvdHRvbS1yaWdodCc6ICdmbGV4LWVuZCdcbn07XG5cblxuY29uc3QgSEFsaWduTWFwID0ge1xuICAgICd0b3AtbGVmdCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAndG9wLWNlbnRlcic6ICdjZW50ZXInLFxuICAgICd0b3AtcmlnaHQnOiAnZmxleC1lbmQnLFxuICAgICdjZW50ZXItbGVmdCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnY2VudGVyLWNlbnRlcic6ICdjZW50ZXInLFxuICAgICdjZW50ZXItcmlnaHQnOiAnZmxleC1lbmQnLFxuICAgICdib3R0b20tbGVmdCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnYm90dG9tLWNlbnRlcic6ICdjZW50ZXInLFxuICAgICdib3R0b20tcmlnaHQnOiAnZmxleC1lbmQnXG59O1xuXG5cbi8qKlxuICogVGl0bGUgem9uZSBwcm92aWRlcyBhIGNvbnRlbnQgcGxhY2Vob2xkZXIgZm9yIHRoZSBUaXRsZSBBcmVhLiBUaGlzIHpvbmUgaXMgYWRkaW5nIGFiaWxpdHlcbiAqIHRvIGFsaWduIGl0cyBjb250ZW50IGludG8gOSBkaWZmZXJlbnQgcG9zaXRpb24uXG4gKlxuICogWW91IGNhbiB1c2UgdGhpcyBUaXRsZSB6b25lIHdpdGhpbiA8YXctY2FyZD4gYXM6XG4gKlxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiAgPGF3LWNhcmQgIFt3aWR0aF09XCInMjAycHgnXCIgW2hlaWdodF09XCInMTU0cHgnXCIgW2hhc0hvdmVyXT1cInRydWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3RhYmxlXT1cImZhbHNlXCIgW2hhc0FjdGlvbl09XCJmYWxzZVwiXG4gKiAgICAgICAgICAgICAgICAgIChvbkhvdmVyQWN0aW9uKT1cIm9uQWN0aW9uKDcsICRldmVudClcIiA+XG4gKlxuICogICAgICAgICAgICAgICAgICA8YXctY2FyZC10aXRsZSBbYWxpZ25dPVwiJ2JvdHRvbS1sZWZ0J1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhLXN1cHBsaWVyLXRhZ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdGl0bGU+XG4gKlxuICogICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKiBEZWZhdWx0IGFsaWdubWVudCBpcyB0b3AtbGVmdFxuICpcbiAqXG4gKlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBhdy1jYXJkLXRpdGxlYCxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd3LWNhcmQtdGl0bGUnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkWm9uZVRpdGxlQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgcHJvcGVydHkgd2hpY2ggaXMgdXNlZCB0byBhcHBseSBmbGV4IHByb3BlcnRpZXMgZm9yIGFsaWduaW5nIGNvbnRlbnQgdmVydGljYWxseVxuICAgICAqIGFzIHdlbGwgYXMgaG9yaXpvbnRhbGx5XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsaWduOiBDYXJkVGl0bGVBbGlnbm1lbnQgPSAndG9wLWxlZnQnO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGVsZW06IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnN0eWxlLmFsaWduSXRlbXMgPSBWQWxpZ25NYXBbdGhpcy5hbGlnbl07XG4gICAgICAgIHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnN0eWxlLmp1c3RpZnlDb250ZW50ID0gSEFsaWduTWFwW3RoaXMuYWxpZ25dO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIE1ha2Ugc3VyZSB3ZSBkb250IGFjY2VwdCBhbnkgdW5zdXBwb3J0ZWQgdmFsdWVzLiBUaGVzZSB2YWx1ZXMgbWFwcyB0byB0aGUgSEFsaWduTWFwIGFuZFxuICogVkFsaWduTWFwIGluIG9yZGVyIHRvIGdldCByZWFsIGNzcyB2YWx1ZSBmb3IgdGhlIGZsZXggYWxpZ25tZW50XG4gKi9cbmV4cG9ydCB0eXBlIENhcmRUaXRsZUFsaWdubWVudCA9ICd0b3AtbGVmdCcgfCAndG9wLWNlbnRlcicgfCAndG9wLXJpZ2h0JyB8ICdjZW50ZXItbGVmdCcgfFxuICAgICdjZW50ZXItY2VudGVyJyAgfCAnY2VudGVyLXJpZ2h0JyB8ICdib3R0b20tbGVmdCcgfCAnYm90dG9tLWNlbnRlcicgfCAnYm90dG9tLXJpZ2h0JztcblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Q2FyZENvbXBvbmVudCwgQ2FyZFpvbmVCb3R0b21Db21wb25lbnQsIENhcmRab25lVG9wQ29tcG9uZW50fSBmcm9tICcuL2NhcmQuY29tcG9uZW50JztcbmltcG9ydCB7Q2FyZFpvbmVUaXRsZUNvbXBvbmVudH0gZnJvbSAnLi9jYXJkLXRpdGxlL2NhcmQtdGl0bGUuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2FyZENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVUaXRsZUNvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVUb3BDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lQm90dG9tQ29tcG9uZW50XG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDYXJkQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRpdGxlQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRvcENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVCb3R0b21Db21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDYXJkTW9kdWxlXG57XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0Jvb2xlYW4sIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogIENoZWNrYm94VHlwZSBkZXNjcmliZXMgd2hhdCB0eXBlIG9mIGNoZWNrYm94IGlzIHRoaXM6XG4gKlxuICogLSBGb3JtIHR5cGU6IHRoYXQgaXMgd3JpdGluZyBhbmQgcmVhZGluZyBhIHZhbHVlIGZyb20vdG8gbW9kZWwgYm90aCB1c2luZyBGb3JtR3JvdXAgYXMgd2VsbFxuICogICAgICAgICAgICAgIGFzIG5nTW9kZWxcbiAqIC0gQWN0aW9uIHR5cGU6ICBvbmx5IGZpcmVzIGFjdGlvbiBhbmQgZG9lcyBub3Qgd3JpdGUgdmFsdWUgdG8gbW9kZWwuXG4gKlxuICpcbiAqL1xuZXhwb3J0IHR5cGUgQ2hlY2tib3hUeXBlID0gJ2Zvcm0nIHwgJ2FjdGlvbic7XG5cbi8qKlxuICpcbiAqIEltcGxlbWVudHMgc3RhbmRhcmQgSFRNTCBjaGVja2JveCBvbiB0b3Agb2YgUHJpbWVORy4gVGhlcmUgYXJlIDIgdHlwZXMgb2ZcbiAqIHtAbGluayBDaGVja2JveENvbXBvbmVudH06IGZvcm0gYW5kIGFjdGlvbiBjaGVja2JveCBhcyBkZXNjcmliZWQgYWJvdmUuXG4gKlxuICpcbiAqIFVzYWdlOiBCYXNpYyBleGFtcGxlIGhhdmluZyByZWQgY2hlY2tib3ggY2hlY2tlZFxuICpcbiAqIGBgYEhUTUxcbiAqICAgICAgICA8YXctY2hlY2tib3ggW25hbWVdPVwiJ2NvbG9yJ1wiIFt2YWx1ZV09XCIncmVkJ1wiIFtsYWJlbF09XCInUmVkJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICAgPC9hdy1jaGVja2JveD5cbiAqICAgICAgICA8YXctY2hlY2tib3ggW25hbWVdPVwiJ2NvbG9yJ1wiIFt2YWx1ZV09XCInYmx1ZSdcIiBbbGFiZWxdPVwiJ0JsdWUnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgIDwvYXctY2hlY2tib3g+XG4gKlxuICogYGBgXG4gKlxuICogYGBgdHNcbiAqXG4gKlxuICogICBjbGFzcyBDQkJhc2ljV2l0aE5nTW9kZWxDb21wb25lbnRcbiAqICAge1xuICpcbiAqICAgICAgIG1vZGVsOiBzdHJpbmdbXSA9IFsncmVkJ107XG4gKlxuICogICAgICAgY29uc3RydWN0b3IoKVxuICogICAgICAge1xuICogICAgICAgfVxuICogICB9XG4gKlxuICogYGBgXG4gKlxuICogRm9yIG1vcmUgZXhhbXBsZXMgcGxlYXNlIHNlZSBhIHBsYXlncm91bmQgb3IgdW5pdCB0ZXN0LlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IENCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja2JveENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jaGVja2JveCcsXG4gICAgdGVtcGxhdGU6IGA8c3BhbiBjbGFzcz1cInctY2hlY2tib3hcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlZGl0YWJsZSAmJiBpc0Zvcm1UeXBlKClcIj5cbiAgICAgICAgPHAtY2hlY2tib3ggW25hbWVdPVwibmFtZVwiIFt2YWx1ZV09XCJ2YWx1ZVwiIFtsYWJlbF09XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIlxuICAgICAgICAgICAgICAgICAgICBbYmluYXJ5XT1cImlzQmluYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICBbY2xhc3MudS12YWxpZGF0aW9uLWVycm9yXT1cIiEoZm9ybUNvbnRyb2wudmFsaWQgfHwgKGZvcm1Db250cm9sLnByaXN0aW5lKSlcIlxuICAgICAgICA+XG4gICAgICAgIDwvcC1jaGVja2JveD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzRm9ybVR5cGUoKVwiPlxuICAgICAgICA8cC1jaGVja2JveCBbYmluYXJ5XT1cImlzQmluYXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgW2xhYmVsXT1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCI+XG4gICAgICAgIDwvcC1jaGVja2JveD5cblxuICAgIDwvbmctdGVtcGxhdGU+XG48L3NwYW4+XG5gLFxuICAgIHN0eWxlczogW2AvZGVlcC8gLnVpLWNoa2JveCAudWktY2hrYm94LWJveHt3aWR0aDoyMnB4O2hlaWdodDoyMnB4fS9kZWVwLyAudWktY2hrYm94IC5waXtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Y29sb3I6IzE5OWRlMDtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4wN2VtO2xpbmUtaGVpZ2h0OjEuNDJlbX0vZGVlcC8gLnVpLWNoa2JveCAucGkucGktY2hlY2s6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMDViJ31gXSxcblxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIENoZWNrYm94Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjaGVja2JveFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIFR5cGUgb2YgY2hlY2tib3guIEZvcm0gYmFzZWQgdXBkYXRlcyBtb2RlbCBhbmQgQWN0aW9uIGJhc2VkIG9ubHkgZmlyZXMgY2xpY2sgZXZlbnRzXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IENoZWNrYm94VHlwZSA9ICdmb3JtJztcblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBhIGNoZWNrYm94XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGNsaWNrIGV2ZW50LlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFByaW1lTkcgaGFzIHRoaXMgdHlwZSBjYWxsZWQgYmluYXJ5IHdoaWNoIHdvcmtzIG9ubHkgd2l0aCBCb29sZWFuIG1lYW5pbmcgaXQgZG9lcyBub3QgYWRkIG9yXG4gICAgICogcmVtb3ZlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEluIG91ciBjYXNlIENoZWNrdHlwZSA9IEFjdGlvbiBpcyBhbHdheXMgYmluYXJ5IG9yIHdoZW4gdGhpcy52YWx1ZSBpcyBib29sZWFuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0JpbmFyeTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWwgZm9yIGNoZWNrYm94XG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy50eXBlID0gdGhpcy5hY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDAgPyAnYWN0aW9uJyA6IHRoaXMudHlwZTtcblxuICAgICAgICBpZiAodGhpcy5pc0Zvcm1UeXBlKCkpIHtcbiAgICAgICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGNvbnRyb2wgZnJvbSBwYXJlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdmFsdWUgaXMgYm9vbGVhbiB3ZSBhcmUgZGVhbGluZyB3aXRoIFByaW1lTmcgQmluYXJ5IGNoZWNrYm94XG4gICAgICAgIC8vIHdoaWNoIG9ubHkgc2V0cyBUUlVFL0ZBTFNFIGFuZCBkb2VzIG5vdCBhZGQgb3IgcmVtb3ZlIHZhbHVlc1xuICAgICAgICB0aGlzLmlzQmluYXJ5ID0gaXNCb29sZWFuKHRoaXMudmFsdWUpO1xuXG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWyd2YWx1ZSddKSAmJlxuICAgICAgICAgICAgKGNoYW5nZXNbJ3ZhbHVlJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWyd2YWx1ZSddLnByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gY2hhbmdlc1sndmFsdWUnXS5jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gQ2hlY2tib3ggaXMgY2xpY2tlZCBhbmQgaXQgZWl0aGVyIGZpcmUgYWN0aW9uIG9yIHVwZGF0ZXMgdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxsIGlmIHdlIGFyZSB1c2luZyBGb3JtIENoZWNrYm94LiBUaGlzIGlzIHVzZWQgcmVtb3ZlIHNvbWUgb2YgdGhlIGJpbmRpbmdzIHRoYXQgYXJlIG5vdFxuICAgICAqIGFwcGxpY2FibGUgZm9yIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzRm9ybVR5cGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gJ2Zvcm0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubW9kZWwgJiYgdGhpcy5pc0Zvcm1UeXBlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB2YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NoZWNrYm94Q29tcG9uZW50fSBmcm9tICcuL2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQge0NoZWNrYm94TW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlXG4gICAgXSxcblxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDaGVja2JveENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDaGVja2JveENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaGVja0JveE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiAgQ2hlY2tib3ggbGlzdCBpcyBhIHdyYXBwZXIgY2xhc3MgYXJvdW5kICdDaGVja2JveCcgY29tcG9uZW50IHRvIHNpbXBseSBhc3NlbWJseSBvZiBtdWx0aSBjaG9pY2VcbiAqIGNvbXBvbmVudFxuICpcbiAqIEluIEFkZGl0aW9uIGl0IGFkZHMgYWJpbGl0eSB0byB3b3JrIHdpdGggY29tcGxleCBvYmplY3QuIFByaW1lTkcgY2hlY2tib3hlcyB3b3JrIG9ubHkgd2l0aFxuICogcHJpbWl0aXZlIHZhbHVlcy5cbiAqXG4gKiBAc2VlIHtAbGluayBjaGVjay1ib3gvY2hlY2stYm94LmNvbXBvbmVudC50c31cbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKlxuICogICAgQENvbXBvbmVudCh7XG4gKiAgICAgICBzZWxlY3RvcjogJ3Nob3dDaGVja0JveExpc3QnICxcbiAqICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgPGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCIgW3NlbGVjdGlvbnNdPVwic2VsZWN0ZWRWYWx1ZXNcIlxuICpcbiAqICAgICAgICAgICAgW25hbWVdPVwiJ215Q29sb3JzJ1wiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGlja1wiPlxuICogICAgICAgICAgIDwvYXctY2hlY2tib3gtbGlzdD5cbiAqICAgICAgIGBcbiAqXG4gKiAgICAgICB9KVxuICogICAgICAgIGNsYXNzIE15U2hvd0NMQ29tcG9uZW50XG4gKiAgICAgICAge1xuICogICAgICAgICAgICBjaGVja0JveExpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdyZWQnICwgJ3llbGxvdycgLCAnb3JhbmdlJyAsICd3aGl0ZScgLFxuICogICAgICdzaWx2ZXInICwgJ2JsYWNrJyAsXG4gKiAgICAgICAgICAgICdHcmVlbicgLCAnR3JheScgLCAnTmF2eScgLCAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddO1xuICpcbiAqICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKlxuICpcbiAqICAgICAgICAgICAgZm9ybUdyb3VwOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqXG4gKlxuICogICAgICAgICAgICBvbkNCQ2xpY2sgKGV2ZW50KTogdm9pZFxuICogICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb25DQkNsaWNrID0gJyArIGV2ZW50KTtcbiAqICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICB9XG4gKipcbiAqL1xuXG5cblxuXG5leHBvcnQgY29uc3QgQ0JfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tCb3hMaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNoZWNrYm94LWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBsaXN0OyBsZXQgaSA9IGluZGV4XCIgY2xhc3M9XCJ1aS1nXCI+XG5cbiAgICA8IS0tIGluIHRoZSBmdXR1cmUgd2Ugc2hvdWxkIGJlIGFibGUgdG8gdG8gc3VwcG9ydCBpbmxpbmUgYW5kIHN0YWNrLS0+XG4gICAgPGRpdiBjbGFzcz1cInVpLWctMTJcIj5cbiAgICAgICAgPGF3LWNoZWNrYm94IFsobmdNb2RlbCldPVwibW9kZWxcIlxuICAgICAgICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJpXCJcbiAgICAgICAgICAgICAgICAgICAgIFtsYWJlbF09XCJsYWJlbFZhbHVlKGl0ZW0pXCI+XG5cbiAgICAgICAgPC9hdy1jaGVja2JveD5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja0JveExpc3RDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tCb3hMaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiB2YWx1ZXMgdXNlZCB0byByZW5kZXIgY2hlY2tib3hlcy4gRXZlbiB3ZSBoYXZlIGhlcmUgdHlwZSBhcyBBTlkgd2UgaW50ZXJuYWxseVxuICAgICAqIHN1cHBvcnQgb25seSBzdHJpbmcgYXQgdGhlIG1vbWVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqICBTZWxlY3Rpb25zIGFyZSBkZWZhdWx0IENIRUNLRUQgdmFsdWVzIHBhc3NlZC4gZS5nLiBXaGVuIHJlbmRlcmluZyBmaWVsZCBmYXZvcml0ZSBjb2xvcnM6XG4gICAgICogYmx1ZSwgcmVkLCB5ZWxsb3cgeW91IHdpbGwgcGFzcyBpbiBoZXJlIGJsdWUsIHJlZCwgdGhlbiBjaGVja2JveGVzIHdpdGggdmFsdWUgYmx1ZSwgcmVkIHdpbFxuICAgICAqIGJlIHJlbmRlcmVkIGFzIGNoZWNrIGFuZCB5ZWxsb3cgdW5jaGVja2VkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25zOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVzIGV2ZW50IHdoZW4gY2hlY2tib3ggaXMgc2VsZWN0ZWQvY2xpY2tlZC4gRW1pdHMgY3VycmVudCBjbGlja2VkIGNoZWNrYm94ZWQuIG5vdCB0aGVcbiAgICAgKiBhY3R1YWxsIGludGVybmFsIG1vZGVsIHZhbHVlIGluIHRoaXMgY2FzZSBhcnJheSBvZiBjaG9pY2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqIHNwZWNpYWwgZXhwcmVzc2lvbiB0byBmb3JtYXQgbGFiZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsRm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbFxuICAgICAqL1xuICAgIG1vZGVsOiBhbnkgPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9ucyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9ucyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLnNlbGVjdGlvbnMpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuc2VsZWN0aW9ucyk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRNb2RlbDogYW55W10gPSBbXTtcblxuICAgICAgICB0aGlzLm1vZGVsLmZvckVhY2goKGluZGV4OiBudW1iZXIpID0+IHVwZGF0ZWRNb2RlbC5wdXNoKHRoaXMubGlzdFtpbmRleF0pKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBpcyBleHRyYWN0ZWQgaW50byB0aGlzIG1ldGhvZCBzbyBpbiB0aGUgZnV0dXJlIHdlIGNhbiBwbGF5IG1vcmUgaG93IHdlIHdhbnQgdG8gZGlzcGxheVxuICAgICAqIHRoZSB2YWx1ZS4gU2luY2UgSSB3YW50IHRvIHN1cHBvcnQgZm9ybWF0dGVycyBmb3IgZWFjaCBjb21wb25lbnRzIHdlIG1pZ2h0IGhhdmUgYSBjaGFuY2UgdG9cbiAgICAgKiBkZWNpZGUgaG93IGxhYmVsIHdpbGwgbG9vayBsaWtlLlxuICAgICAqXG4gICAgICovXG4gICAgbGFiZWxWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sYWJlbEZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiB0aGlzIHZlcnNpb24gb2YgY2hlY2tib3hlcyB3ZSBzdGlsbCBleHBlY3Qgb25seSBwcmltaXRpdmUgdHlwZXMuIEtlZXAgdGhpcyBmdW5jdGlvbmFsaXR5XG4gICAgICogaW4gZXh0cmEgbWV0aG9kIHNvIHdlIGNhbiB3b3JrIHdpdGggaXQgZXZlbiBub3cgd2UganVzdCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFja1xuICAgICAqL1xuICAgIHZhbHVlKGl0ZW06IGFueSk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZWdhdGUgZXZlbnQgb3V0c2lkZSBvZiB0aGlzIGNvbXBvbmVudCBhbmQgY29udmVydCBpbmRleGVkIG1vZGVsIHRvIG9yaWdpbmFsIG9iamVjdHNcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnlbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMubW9kZWwuZm9yRWFjaCgoaW5kZXg6IG51bWJlcikgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdXBkYXRlZE1vZGVsLnB1c2godGhpcy5saXN0W2luZGV4XSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodXBkYXRlZE1vZGVsLCB7XG4gICAgICAgICAgICBlbWl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGNvbXBsZXggb2JqZWN0IHN0b3JlIG9ubHkgSU5ERVhlcyBudW1iZXIgaW4gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTW9kZWwoc291cmNlTGlzdDogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICBzb3VyY2VMaXN0LmZvckVhY2goKGl0ZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5saXN0LmZpbmRJbmRleCgoZWxlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHMoaXRlbSwgZWxlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwucHVzaChpbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5tb2RlbCkgJiYgaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IG5ld01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKG5ld01vZGVsKTtcblxuICAgICAgICAgICAgLy8gdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2hlY2tCb3hMaXN0Q29tcG9uZW50fSBmcm9tICcuLi9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuLi9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDaGVja0JveExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZVxuICAgIF0sXG5cblxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2hlY2tCb3hMaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2hlY2tCb3hMaXN0TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBIeXBlcmxpbmsgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yLiBIeXBlcmxpbmsgc3VwcG9ydHMgYWxsIG9mIHRoZVxuICogbmF0aXZlIGxpbmsgZnVuY3Rpb25hbGl0eS4gSW4gYWRkaXRpb24sIGl0IHN1cHBvcnRzIG5hdmlnYXRpb24gdG8gY29tcG9uZW50cyB0aHJvdWdoIHRoZSBhY3Rpb25cbiAqIGJpbmRpbmcuXG4gKlxuICpcbiAqIGZvciBtb3JlIGluZm8gcGxlYXNlIHNlZSBjbGFzcyBEb2Mgb2YgdGhlOlxuICogIEBzZWUge0BsaW5rIGJ1dHRvbi9idXR0b24uY29tcG9uZW50LnRzfVxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgICAgICA8YXctaHlwZXJsaW5rICBbdHlwZV09XCIndGV4dC9odG1sJ1wiIFtuYW1lXT1cIidsaW5rJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DbGlja2VkKCRldmVudClcIiBbdmFsdWVdPVwiY3VzdG9tZXJJZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtzaXplXT1cIidsYXJnZSdcIiA+bXkgbGluazwvYXctaHlwZXJsaW5rPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBjb21tYW5kOmJvb2xlYW47XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICAgICAgb25DbGlja2VkKGN1c3RvbWVySWQ6c3RyaW5nKSB7XG4gKiAgICAgICAgICAgaWYgKGN1c3RvbWVySWQpIHtcbiAqICAgICAgICAgICAgICAvLyBkaXNwbGF5IGN1c3RvbWVyIGRldGFpbHMgY29tcG9uZW50LlxuICogICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaHlwZXJsaW5rJyxcbiAgICB0ZW1wbGF0ZTogYDxhIFthdHRyLnR5cGVdPVwidHlwZVwiXG4gICBbYXR0ci5ocmVmXT1cImhyZWZcIlxuICAgW2F0dHIucmVsXT1cInJlbFwiXG4gICBbYXR0ci50YXJnZXRdPVwidGFyZ2V0XCJcbiAgIFtuZ0NsYXNzXT1cImxpbmtDbGFzc1wiXG4gICBbY2xhc3MuZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgKGNsaWNrKT1cImNsaWNrZWQoJGV2ZW50KVwiPlxuXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9hPlxuYCxcbiAgICBzdHlsZXM6IFtgLmxpbmt7Y29sb3I6IzAyNzVkODtjdXJzb3I6cG9pbnRlcn0ubGluay5saW5rLWJoe2NvbG9yOiMwMjc1ZDh9LmxpbmsubGluay1iaDpob3Zlcnt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lO2N1cnNvcjpwb2ludGVyfS5saW5rLXNte2ZvbnQtc2l6ZTouODc1ZW19LmxpbmstbWlke2ZvbnQtc2l6ZToxZW19LmxpbmstbGd7Zm9udC1zaXplOjEuMjVlbX0ubGluay5kaXNhYmxlZHtwb2ludGVyLWV2ZW50czpub25lO2N1cnNvcjpkZWZhdWx0O2NvbG9yOiNkZGR9YF1cbn0pXG5leHBvcnQgY2xhc3MgSHlwZXJsaW5rQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogICAgU3BlY2lmaWVzIHRoZSBtZWRpYSB0eXBlIG9mIHRoZSBsaW5rZWQgZG9jdW1lbnQuIE1pbWUgdHlwZVxuICAgICAqICAgIGV4OiBbdGV4dC9odG1sIHwgdGV4dC9jc3YgfCBpbWFnZS9wbmcgfCBhdWRpby8zZ3BwIHwgLi4uLl1cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIHVybCBmb3IgdGhpcyBoeXBlcmxpbmsuIENhbiBiZSB1c2VkIHRvIG5hdmlnYXRlIHRvIGEgY29tcG9uZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaHJlZjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogcmVsIGZvciB0aGlzIGh5cGVybGluay4gU3BlY2lmeSB0aGUgcmVsYXRpb25zaGlwIG9mIHRoZSBjdXJyZW50IGRvY3VtZW50IGFuZCBsaW5rZWQgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBzaXppbmcgZm9yIHRoaXMgbGluay4gW2xhcmdlLCBub3JtYWwsIHNtYWxsXS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNpemU6IExpbmtTaXplID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSB0YXJnZXQgb2YgdGhlIGh5cGVybGluay4gW19ibGFuayB8IF9zZWxmIHwgX3BhcmVudCB8IF90b3AgfCBmcmFtZW5hbWUgXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFyZ2V0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byBiZSBzZW5kIHRvIHNlcnZlciB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgQ1NTIGNsYXNzIHRoYXQgc3R5bGVzIHRoaXMgaHlwZXJsaW5rIGJhc2VkIG9uIGlucHV0ICdzaXplJ1xuICAgICAqL1xuICAgIGxpbmtDbGFzczogc3RyaW5nID0gJ2xpbmsnO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGxpbmsgY2xhc3MgYmFzZWQgb24gaW5wdXQgc2l6ZS5cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsYXJnZScgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstbGcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLW1pZCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1zbSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgSSBoYXZlIGFuIGFjdGlvbiB0YWcsIGFuZCBubyBocmVmLiBXZSBhZGQgZGVmYXVsdCBzdHlsaW5nIGFuZCBiZWhhdmlvci5cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uLm9ic2VydmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstYmgnO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQWN0aW9uIGNsaWNrZWQuIENhbGwgcGFyZW50IGFjdGlvbi5cbiAgICAgKi9cbiAgICBjbGlja2VkKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTdXBwb3J0ZWQgTGluayBTaXplXG4gKi9cbmV4cG9ydCB0eXBlIExpbmtTaXplID0gJ2xhcmdlJyB8ICdub3JtYWwnIHwgJ3NtYWxsJztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SHlwZXJsaW5rQ29tcG9uZW50fSBmcm9tICcuL2h5cGVybGluay5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEh5cGVybGlua0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBIeXBlcmxpbmtDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSHlwZXJsaW5rQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSHlwZXJsaW5rTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge3VuaW1wbGVtZW50ZWR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU2VsZWN0aW9uIFN0YXRlIGZvciB0aGUgY2hvb3NlciBpbiBvcmRlciB0byBiZSBhYmxlIHRvIGNvbXVuaWNhdGUgd2l0aCB0aGUgcGFyZW50IG9iamVjdCB1c2luZyBhXG4gKiBjaG9vc2VyLiBJZiBJIHdvdWxkIGhhdmUgdG8gbWFuYWdlIG9ubHkgc2luZ2xlIHZhbHVlcyB3aXRoIG5vIGFkZGlvbmFsIG1ldGhvZHMgaSB3b3VsZCB1c2VyXG4gKiBlbWl0dGVycyB0byBkbyB0aGUgam9iLCBidXQgaW4gdGhpcyBjYXNlIHdlIG5lZWQgdGhpcyBpbnRlcmZhY2UgKGFic3RyYWN0IGNsYXNzKSBiZXR3ZWVuIGFcbiAqIGNob29zZXIgYW5kIGFjdHVhbCBvYmplY3QuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENob29zZXJTZWxlY3Rpb25TdGF0ZVxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0IHNlbGVjdGlvbiBzdGF0ZSBpcyB1c3VhbGx5IHRyaWdnZXJlZCBieSBzZWxlY3RpbmcgYW5kIHVuc2VsZWN0aW5nIGEgaXRlbSAoaW4gY2FzZSBvZlxuICAgICAqIG11bHRpc2VsZWN0KSBhbmQgaXQgc2hvdWxkIHVwZGF0ZSBpdHMgbGlzdCBvZiBvYmplY3RzIHdpdGggZWl0aGVyIHNldHRpbmdzL2FkZGluZyBpdGVtIG9yXG4gICAgICogcmVtb3ZpbmcgaXQuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiAuIE51bGwgaWYgbGFzdCBhY3Rpb24gd2FzIGEgZGVzZWxlY3Rpb24uIFVzdWFsbHkgdXNlZCBieSBDaG9vc2VyXG4gICAgICogb3IgQ2hvb3NlclN0YXRlIHRvIGdldCBjdXVyZW50IHZhbHVlLlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdGhlIGl0ZW0gc2VsZWN0aW9uIGl0ZW1zIGlzIGluIHRoZSBzZWxlY3RlZE9iamVjdHNcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q2hvb3NlclNlbGVjdGlvblN0YXRlfSBmcm9tICcuL2Nob29zZXItc2VsZWN0aW9uLXN0YXRlJztcbmltcG9ydCB7RGF0YVNvdXJjZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcblxuLyoqXG4gKiBDaG9vc2VyU3RhdGUgbWFuYWdlcyBjb21wbGV0ZSBsaWZlY3ljbGUgZm9yIHRoZSBDaG9vc2VyIENvbXBvbmVudC4gSXQga2VlcHMgdHJhY2sgb2YgY3VycmVudFxuICogc2VsZWN0aW9uIGFzIHdlbGwgYXMgaXQgY2FuIGJyb2FkY2FzdCBhbnkgdXBkYXRlcy5cbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hvb3NlclN0YXRlXG57XG5cbiAgICAvKipcbiAgICAgKiAgQ2FsbGJhY2sgdG8gdGhlIHBhcmVudCBvYmplY3QgdG8gc3RvcmUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBzZWxlY3Rpb25TdGF0ZTogQ2hvb3NlclNlbGVjdGlvblN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogdG9kbzogV2UgZG8gbm90IG5lZWRlZCB0aGlzICEhXG4gICAgICovXG4gICAgY3VycmVudEl0ZW06IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogTWF0Y2hpbmcgcGF0dGVybi4gVXNlciBsYXRlc3QgaW5wdXQgdG8gdGhlIGNob29zZXIgaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBwYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIExhc3Qgc3VjY2Vzc2Z1bGwgcGF0dGVybiB0aGF0IHJldHJpZXZlZCBzb21lIGRhdGFcbiAgICAgKi9cbiAgICBsYXN0RnVsbE1hdGNoUGF0dGVybjogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IG1hdGNoZWQgaXRlbXMgdXNpbmcgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG4gICAgICovXG4gICAgbWF0Y2hlczogQXJyYXk8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBtdWx0aXNlbGVjdCBjaG9vc2VyXG4gICAgICovXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW1wbGVtZW50YXRpb24gY2FuIHNldCBsb29rdXAga2V5IHRvIG5hcnJvdyB0aGUgc2VhcmNoLiBJZiB3ZSBhcmUgZGVhbGluZyB3aXRoIG9iamVjdFxuICAgICAqIHlvdSBzaG91bGQgc2V0IHRoaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBsb29rdXBLZXk6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogcHJldmlvdXMgZGlzcGxheSB2YWx1ZSBpcyBzZXQgd2hlbiB0aGUgZGlzcGxheSB2YWx1ZSBpcyByZW5kZXJlZCBvbiB0aGUgY2hvb3Nlci4gd2UgY2FjaGVcbiAgICAgKiB0aGUgVUkgdmFsdWUgdG8gY29tcGFyZSB3aXRoIHRoZSBpbmJvdW5kIHZhbHVlIGxhdGVyIGluc3RlYWQgb2YgdGhlIHZhbHVlIGZyb20gdW5kZXJseWluZ1xuICAgICAqIG9iamVjdCBiZWNhdXNlIGJ1c2luZXNzIGxvZ2ljIGxldmVsIGNvZGUgY291bGQgaGF2ZSBjaGFuZ2VkIHRoZSB1bmRlcmx5aW5nIG9iamVjdCdzIHZhbHVlXG4gICAgICpcbiAgICAgKiB0b2RvOiBkbyBJIHN0aWxsIG5lZWQgdGhpcz9cbiAgICAgKi9cbiAgICBwcmV2RGlzcGxheVZhbHVlOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGVyZSBhcmUgYW55IHZhbGlkYXRpb24gbGlrZSBlbnRlcmVkIHZhbHVlIGRvZXMgbm90IG11Y2ggd2l0aCB0aGUgc291cmNlIGxpc3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0ludmFsaWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogaW5kaWNhdGVzIHRoYXQgd2Ugc3RhcnRlZCB0byBzb21lIGVkaXRpbmcgZS5nLiBzdGFydGluZyB0byB0eXBlIGluIHNvbWV0aGluZyBpbnRvIHRoZVxuICAgICAqIGZpbHRlciwgb3IgcmVtb3ZpbmcgYWxyZWFkeSBzZWxlY3RlZCBpdGVtc1xuICAgICAqL1xuICAgIGFkZE1vZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgcmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQ6IG51bWJlciA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBvcHRpb24gaXMgYWN0aXZlIHdlIGRvIG5vdCBzaG93IGFsbCBzZWxlY3RlZCBpdGVtcywgYnV0IG1heCBudW1iZXIgdGhhdCBpc1xuICAgICAqIGRlZmluZWQuIFVzZXIgaXMgYWJsZSB0byB0b2dnbGUgdG8gZXhwYW5kIHRoZSB2aWV3IHRvIHNlZSBhbGwgc2VsZWN0aW9ucyBhbmQgaGlkZSB0aGVtIGFzXG4gICAgICogd2VsbFxuICAgICAqL1xuICAgIHNob3dBbGxSZWNlbnRseVNlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKGNob29zZXJTZWxlY3Rpb25TdGF0ZT86IENob29zZXJTZWxlY3Rpb25TdGF0ZSwgaXNNdWx0aTogYm9vbGVhbiA9IHRydWUpXG4gICAge1xuXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGUgPSBjaG9vc2VyU2VsZWN0aW9uU3RhdGU7XG4gICAgICAgIHRoaXMubXVsdGlzZWxlY3QgPSBpc011bHRpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gbmV3IERlZmF1bHRTZWxlY3Rpb25TdGF0ZSh0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJdCB3aWxsIHNlbGVjdCBhbmQgcGVyc2lzdCBhbiBpdGVtIHVzaW5nIENob29zZXJTZWxlY3Rpb25TdGF0ZSBwcm92aWRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoaXRlbSkpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLmN1cnJlbnRJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKGl0ZW0sIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0ID0gdGhpcy5zZWxlY3RlZE9iamVjdCgpO1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0cyA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzKCk7XG5cblxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkTW9kZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzSW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHNlbGVjdGVkT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3RlZE9iamVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShpdGVtLCAhTGlzdFdyYXBwZXIuY29udGFpbnNDb21wbGV4KHNlbGVjdGVkT2JqZWN0cywgaXRlbSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHNlbGVjdGVkT2JqZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGVkT2JqZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNlciBzZWxlY3Rpb24gaXMgbGFyZ2Ugd2UgdXNlIHRoaXMgbWV0aG9kIHRvIGNoZWNrIGlmIHdlIG5lZWQgdG8gc2hvdyBhbGwgc2VsZWN0ZWRcbiAgICAgKiBpdGVtcyBvciBvbmx5IE1heFJlY2VudFNlbGVjdGVkXG4gICAgICovXG4gICAgdG9nZ2xlQWxsU2VsZWN0ZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCA9ICF0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZW5kZXJzIHVzZXIncyBzZWxlY3Rpb24gdW5kZXIgdGhlIGlucHV0IGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgcmVjZW50U2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5IDxhbnk+XG4gICAge1xuXG4gICAgICAgIGlmICghdGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlY2VudFNlbGVjdGVkT2JqZWN0czogYW55W10gPSBbXTtcbiAgICAgICAgdGhpcy5yZWNlbnRTZWxlY3RlZERpc3BsYXllZCA9IDA7XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICBsZXQgc2l6ZSA9IHNlbGVjdGVkT2JqZWN0cy5sZW5ndGg7XG4gICAgICAgIGxldCBtYXhDb3VudCA9IERhdGFTb3VyY2UuTWF4UmVjZW50U2VsZWN0ZWQ7XG4gICAgICAgIGlmIChzaXplID4gRGF0YVNvdXJjZS5NYXhSZWNlbnRTZWxlY3RlZCAmJiAhdGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgbWF4Q291bnQgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgbWF4Q291bnQgPSBzaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IHNpemUgLSAxOyBpID49IDAgJiYgKHRoaXMucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQgPCBtYXhDb3VudCk7IGktLSkge1xuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHNlbGVjdGVkT2JqZWN0c1tpXTtcbiAgICAgICAgICAgIHJlY2VudFNlbGVjdGVkT2JqZWN0cy5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVjZW50U2VsZWN0ZWRPYmplY3RzO1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhdGUuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICB9XG5cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHNlbGVjdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlLnNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbiwgc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBEdW1teSBpbXBsZW1lbnRhdGlvbiBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRTZWxlY3Rpb25TdGF0ZSBleHRlbmRzIENob29zZXJTZWxlY3Rpb25TdGF0ZVxue1xuICAgIHByaXZhdGUgX3NlbGVjdGVkT2JqZWN0OiBhbnk7XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRPYmplY3RzOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbXVsdGlTZWxlY3Q6IGJvb2xlYW4pXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRPYmplY3QgPSBzZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdCAmJiAhTGlzdFdyYXBwZXIuY29udGFpbnNDb21wbGV4KHRoaXMuc2VsZWN0ZWRPYmplY3RzKCksXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkT2JqZWN0cygpLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlSWZFeGlzdCh0aGlzLnNlbGVjdGVkT2JqZWN0cygpLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRPYmplY3Q7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX3NlbGVjdGVkT2JqZWN0cykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT2JqZWN0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZE9iamVjdHM7XG4gICAgfVxuXG4gICAgaXNTZWxlY3RlZChzZWxlY3Rpb246IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBzdXBlci5pc1NlbGVjdGVkKHNlbGVjdGlvbik7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFTb3VyY2UsIERTSW5pdFBhcmFtc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgRGF0YUZpbmRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0Nob29zZXJTdGF0ZX0gZnJvbSAnLi9jaG9vc2VyLXN0YXRlJztcbmltcG9ydCB7YXNzZXJ0LCBpc0FycmF5LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBDb25jcmV0ZSBEYXRhU291cmNlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgQ2hvb3NlciBjb21wb25lbnQuIFRoZXJlIGFyZSB0d28gd2F5cyBob3cgdG8gdXNlIGl0OlxuICpcbiAqIDEpIFlvdSBjYW4gdXNlIGRlZmF1bHQgRGF0YVNvdXJjZSBpbmplY3RlZCBpbnNpZGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGFuZCBqdXN0IGNhbGxcbiAqIGluaXRpYWxpemUgdG8gY29uZmlndXJlIGl0IHdpdGggY29ycmVjdCBEYXRhUHJvdmlkZXIgYW5kIERhdGFGaW5kZXI6XG4gKlxuICpcbiAqIGBgYFxuICogICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gKiAgICAgICAgICAgICAgIG9iajogdGhpcy5saXN0LFxuICogICAgICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAqICAgICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gKiAgICAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gKiAgICAgICAgICAgfSk7XG4gKlxuICogYGBgXG4gKlxuICogYW5kIHRoZW4geW91IGNhbiB1c2UgaXQgdG8gc2ltcGx5IHJldHJpZXZlIGRhdGEgb3IgcnVuIHF1ZXJpZXMuXG4gKlxuICogMikgWW91IHdpbGwgaW5zdGFudGlhdGUgeW91ciBvd24gRGF0YVNvdXJjZSBhbmQgcGFzcyBpdCBpbnRvIHRoZSBjb21wb25lbnQgdXNpbmcgW2RhdGFTb3VyY2VdXG4gKiBiaW5kaW5nXG4gKlxuICogYGBgXG4gKlxuICogICB0aGlzLmRzID0gbmV3IENob29zZXJEYXRhU291cmNlKHRoaXMuZGF0YSwgdGhpcy5maW5kZXJzKTtcbiAqICAgdGhpcy5kcy5pbml0KHtcbiAqICAgICAgICAgICAgICAgb2JqOiB0aGlzLmxpc3QsXG4gKiAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICogICAgICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAqICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAqICAgICAgICAgICB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgQ2hvb3NlckRhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlXG57XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGluZyBkYXRhUHJvdmlkZXJzIGFuZCBmaW5kZXJzXG4gICAgICovXG4gICAgcHJpdmF0ZSBkYXRhUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuICAgIHByaXZhdGUgZGF0YUZpbmRlcjogRGF0YUZpbmRlcjtcblxuXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBvYmplY3QgdG8ga2VlcCBjdXJyZW50IHN0YXRlIG9mIHRoaXMgY2hvb3NlclxuICAgICAqL1xuICAgIHN0YXRlOiBDaG9vc2VyU3RhdGU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRhUHJvdmlkZXJzOiBEYXRhUHJvdmlkZXJzLCBwdWJsaWMgZmluZGVyczogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgICAgICBzdXBlcihkYXRhUHJvdmlkZXJzLCBmaW5kZXJzKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRvIGluaXRpYWxpemUgdGhpcyBEYXRhU291cmNlIHdpdGggY3VycmVudCBEYXRhRmluZGVyIGFuZCBQcm92aWRlciBhcyB3ZWxsIGFzIHN0YXRlIHdlIHVzZVxuICAgICAqIGFuIGludGVyZmFjZSBEU0Nob29zZXJJbml0UGFyYW1zIHRvIGhhdmUgYWxsIGluaXQgdmFsdWVzIHR5cGVkIGNoZWNrZWRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdCguLi5hcmdzOiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGFyZ3MpIHx8IGFyZ3MubGVuZ3RoICE9PSAxICYmICFpc0RTQ2hvb3NlckluaXRQYXJhbXMoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBEUyB3aXRoIChEU0Nob29zZXJJbml0UGFyYW1zKScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbml0OiBEU0Nob29zZXJJbml0UGFyYW1zID0gYXJnc1swXTtcblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IGlzUHJlc2VudChpbml0LmRhdGFQcm92aWRlcikgPyBpbml0LmRhdGFQcm92aWRlclxuICAgICAgICAgICAgOiB0aGlzLmRhdGFQcm92aWRlcnMuZmluZChpbml0Lm9iaik7XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YUZpbmRlcikgPyBpbml0LmRhdGFGaW5kZXJcbiAgICAgICAgICAgIDogdGhpcy5maW5kZXJzLmZpbmQodGhpcy5kYXRhUHJvdmlkZXIsIGluaXQucXVlcnlUeXBlKTtcblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuZGF0YVByb3ZpZGVyKSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhRmluZGVyKSxcbiAgICAgICAgICAgICdEYXRhU291cmNlIGluY29ycmVjdGx5IGluaXRpYWxpemVkLiAoRGF0YVByb3ZpZGVyLCBEYXRhRmluZGVyKSBtaXNzaW5nLiAnKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGluaXQuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gaW5pdC5zdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgQ2hvb3NlclN0YXRlKG51bGwsIGluaXQubXVsdGlzZWxlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IGluaXQubG9va3VwS2V5O1xuICAgICAgICB0aGlzLnN0YXRlLmxvb2t1cEtleSA9IGluaXQubG9va3VwS2V5O1xuICAgIH1cblxuXG4gICAgZmluZChwYXR0ZXJuOiBzdHJpbmcsIG1heDogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICAgICAgdGhpcy5zdGF0ZS5sYXN0RnVsbE1hdGNoUGF0dGVybiA9IHBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdHRlcm4gPT09ICcqJykgeyAvLyBxdWVyeSBldmVyeXRoaW5nXG4gICAgICAgICAgICBwYXR0ZXJuID0gJyc7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkYXRhRmluZGVyIGhhcyBleHBlY3RlZCBsb29rdXAga2V5XG4gICAgICAgIGxldCBvcmlnS2V5ID0gdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleTtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IHRoaXMuc3RhdGUubG9va3VwS2V5O1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIuZm9yRGF0YSh0aGlzLmRhdGFQcm92aWRlcikubWF0Y2g8YW55PihwYXR0ZXJuLCBtYXgpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChyZXN1bHQ6IGFueVtdKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUubWF0Y2hlcyA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlSWZFeGlzdCh0aGlzLnN0YXRlLm1hdGNoZXMsIGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IG9yaWdLZXk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gbXVsdGlzZWxlY3QgdGhpcyBtZXRob2QgY2hlY2tzIGlmIHdlIG5lZWQgdG8gc2hvdyBTSE9XIE1PUkUgbGFiZWwgdW5kZXIgdGhlIHNlbGVjdGVkXG4gICAgICogaXRlbXMuIFdlIGRvIG5vdCB3YW50IHNob3cgZS5nLiA1MCBzZWxlY3Rpb24gdW5kZXIgdGhlIGNob29zZXIgdGhhdCB3b3VsZCB0YWtlIHVwIHdob2xlXG4gICAgICogcGFnZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dNb3JlU2VsZWN0ZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoID49IERhdGFTb3VyY2UuTWF4UmVjZW50U2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgb3BlbjxUPigpOiBPYnNlcnZhYmxlPFRbXT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5hc09ic2VydmFibGUoKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGluc3RhbnQ8VD4oKTogVFtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBpdGVtczogYW55W10gPSB2YWx1ZTtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHRoaXMuc3RhdGUudXBkYXRlZFNlbGVjdGVkT2JqZWN0cyhpdGVtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHModmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuYWRkTW9kZSA9IGZhbHNlO1xuXG4gICAgfVxuXG5cbiAgICBnZXQgbG9va3VwS2V5KCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXk7XG4gICAgfVxufVxuXG4vKiBpcyBcImluaXRcIiB0eXBlIG9mIERTQ2hvb3NlckluaXRQYXJhbXMgaW50ZXJmYWNlID8gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RTQ2hvb3NlckluaXRQYXJhbXMoaW5pdDogRFNDaG9vc2VySW5pdFBhcmFtcyk6IGluaXQgaXMgRFNDaG9vc2VySW5pdFBhcmFtc1xue1xuICAgIHJldHVybiBpc1ByZXNlbnQoaW5pdC5vYmopIHx8IGlzUHJlc2VudChpbml0LnF1ZXJ5VHlwZSk7XG59XG5cbi8qKlxuICogVG8gbWFrZSBpbml0aWFsaXphdGlvbiBlYXNpZXIgd2UgaGF2ZSB0aGlzIGNvbW1vbiBmb3JtYXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRFNDaG9vc2VySW5pdFBhcmFtcyBleHRlbmRzIERTSW5pdFBhcmFtc1xue1xuICAgIC8qKlxuICAgICAqIENob29zZXIgc3RhdGUga2VlcGluZyBpbmZvcm1hdGlvbiB3aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZCAsIHJlc3VsdCBvZiB0aGUgbGFzdCBtYXRjaFxuICAgICAqL1xuICAgIHN0YXRlPzogQ2hvb3NlclN0YXRlO1xufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBdXRvQ29tcGxldGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtEQVRBX1NPVVJDRX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7Q2hvb3NlckRhdGFTb3VyY2V9IGZyb20gJy4vY2hvb3Nlci1kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGUsIERlZmF1bHRTZWxlY3Rpb25TdGF0ZX0gZnJvbSAnLi9jaG9vc2VyLXN0YXRlJztcblxuXG4vKipcbiAqIFR5cGVhaGVhZCBjaG9vc2VyIHRoYXQgc3VwcG9ydHMgYm90aCBzaW5nbGUgYW5kIG11bHRpLXNlbGVjdC4gTm90IGxpa2UgRHJvcGRvd24sIHRoaXMgY2hvb3NlclxuICogcmVxdWlyZXMgbGl0dGxlIGJpdCBkaWZmZXJlbnQgc2V0dXAuIEl0IHJlcXVpcmVzIGF0IG1pbmltdW0gQElucHV0IGRhdGFTb3VyY2Ugb3JcbiAqIGRlc3RpbmF0aW9uQ2xhc3NcbiAqXG4gKlxuICogQnkgZGVmYXVsdCBjaG9vc2VyIGlzIG11bHRpLXNlbGVjdC4gSWYgeW91IHdhbnQgc2luZ2xlIHNlbGVjdCB0aGVuIHlvdSBtdXN0IHByb3ZpZGUgbXVsdGktc2VsZWN0XG4gKiB3aXRoIEBJbnB1dC5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIEluIHNpbXBsZSBzY2VuYXJpbyB5b3UgY2FuIHVzZSBDaG9vc2VyIGxpa2Ugc286XG4gKlxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ2Nob29zZXItYXBwJyAsXG4gKiAgICAgIHRlbXBsYXRlOiBgPGF3LWNob29zZXIgIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgbmFtZT1cImNvbG9yXCInXG4gKiAgICAgICAgICAgICAgICAgICAgICBbZGF0YVNvdXJjZV09XCJkc1wiPjwvYXctY2hvb3Nlcj5gXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgTXlDaG9vc2VyQXBwXG4gKiAge1xuICpcbiAqICAgICAgZHM6IENob29zZXJEYXRhU291cmNlO1xuICpcbiAqICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGE6IERhdGFQcm92aWRlcnMsIHByaXZhdGUgZmluZGVyczogRGF0YUZpbmRlcnMpe1xuICogICAgICAgICAgdGhpcy5kcyA9IG5ldyBDaG9vc2VyRGF0YVNvdXJjZSh0aGlzLmRhdGEsIHRoaXMuZmluZGVycyk7XG4gKlxuICogICAgICAgdGhpcy5kcy5pbml0KHtcbiAqICAgICAgICAgICBvYmo6IFsnYmx1ZScsICdyZWQnLCAneWVsbG93J10sIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LCBzdGF0ZTogbnVsbCxcbiAqICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRydWVcbiAqICAgICAgIH0pO1xuICpcbiAqICAgICB9XG4gKiAgfVxuICpcbiAqIGBgYGBcbiAqICBBYm92ZSBleGFtcGxlIHdpbGwgdXNlIHByb3ZpZGVkIGRhdGFTb3VyY2UgYW5kIHJlbmRlciBtdWx0aS1zZWxlY3QgY2hvb3Nlci4gV2l0aCBkZWZhdWx0XG4gKiAgaW1wbGVtZW50YXRpb24gIHNlbGVjdGVkIHZhbHVlcyB3aWxsIGFwcGVhciBhcyBhIHRhZ3MgdW5kZXIgdGhlIGlucHV0IGJveFxuICpcbiAqXG4gKlxuICogKiAjIyMgRXhhbXBsZVxuICpcbiAqICBJbiB0aGlzIGV4YW1wbGUgd2UgcHJvdmlkZSBjdXN0b20gdGVtcGxhdGUgdG8gY2hhbmdlIHRoZSB3YXkgaG93IGNob29zZXIncyBNZW51SXRlbSBhcmVcbiAqICAgICByZW5kZXJlZCBhcyB3ZWxsIGFzIHRlbXBsYXRlIGZvciB0aGUgc2VsZWN0aW9uIGl0ZW0gbG9va3MgbGlrZVxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ2Nob29zZXItYXBwJyAsXG4gKiAgICAgIHRlbXBsYXRlOiBgPGF3LWNob29zZXIgIG5hbWU9XCJjb21tb2RpdHlcIicgW2RhdGFTb3VyY2VdPVwiZHNcIj5cbiAqXG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUgI21lbnVJdGVtIGxldC1pdGVtPlxuICogICAgICAgICAgICAgXHQ8c3Bhbj5cbiAqICAgICAgICAgICAgIFx0XHQ8aSBjbGFzcz1cImZhIGZhLWVudmlyYSBcIiA+PC9pPlxuICogICAgICAgICAgICAgXHRcdHt7aXRlbX19XG4gKiAgICAgICAgICAgICBcdDwvc3Bhbj5cbiAqXG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjc2VsZWN0aW9uSXRlbSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgIFx0PHNwYW4gY2xhc3M9XCJ0YWcgdGFnLWNpcmNsZVwiPlxuICogICAgICAgICAgICAgXHRcdGl0ZW06IHt7aXRlbSB9fVxuICogICAgICAgICAgICAgXHRcdDxpIGNsYXNzPVwiZmEgZmEtY2xvc2VcIiAoY2xpY2spPVwiY2hvb3Nlci5yZW1vdmVWYWx1ZShpdGVtKVwiPjwvaT5cbiAqICAgICAgICAgICAgIFx0PC9zcGFuPlxuICpcbiAqXG4gKiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICA8L2F3LWNob29zZXI+XG4gKiAgICAgIGBcbiAqICAgICAgc3R5bGU6IFtgXG4gKiAgICAgICAgICAgICAgLnRhZy1jaXJjbGUge1xuICogICAgICAgICAgICAgIFx0Ym9yZGVyLXJhZGl1czogNnJlbTtcbiAqICAgICAgICAgICAgICBcdGhlaWdodDogN3JlbTtcbiAqICAgICAgICAgICAgICBcdGNvbG9yOiAjZThlZWYxO1xuICogICAgICAgICAgICAgIFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSg1MywgNTYsIDU4LCAwLjY3KTtcbiAqICAgICAgICAgICAgICBcdGxpbmUtaGVpZ2h0OiA2cmVtO1xuICogICAgICAgICAgICAgIH1cbiAqICAgICAgYF1cbiAqICB9KVxuICpcbiAqIGBgYGBcbiAqXG4gKiAgSW4gYWJvdmUgZXhhbXBsZSB3ZSBjaGFuZ2UgaG93IHRoZSBjaG9vc2VyJ3MgbWVudSBpdGVtIGxvb2sgbGlrZSBhcyB3ZWxsIGFzIHdlIGRlZmluZSBjdXN0b21cbiAqICAgICB0ZW1wbGF0ZSBmb3Igc2VsZWN0aW9uIGl0ZW0gdG8gdHVybiBhbGwgc2VsZWN0aW9uIHRvIGNpcmNsZXMgd2l0aCB0ZXh0IGluIHRoZSBtaWRkbGUuXG4gKlxuICpcbiAqXG4gKi9cblxuZXhwb3J0IGNvbnN0IENIT09TRVJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENob29zZXJDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hvb3NlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidy1jaG9vc2VyIFwiPlxuXG4gICAgPHAtYXV0b0NvbXBsZXRlICNhdXRvQ29tcHBsZXRlIFsobmdNb2RlbCldPVwiaW50ZXJuYWxDaG9vc2VyTW9kZWxcIlxuICAgICAgICAgICAgICAgICAgICBbc3VnZ2VzdGlvbnNdPVwiZGF0YVNvdXJjZS5zdGF0ZS5tYXRjaGVzXCJcbiAgICAgICAgICAgICAgICAgICAgW211bHRpcGxlXT1cImRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICBbZHJvcGRvd25dPVwiIWRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICBbbWluTGVuZ3RoXT1cIm1pbkxlbkZvclNlYXJjaFwiXG4gICAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiXG4gICAgICAgICAgICAgICAgICAgIFtkZWxheV09XCJkZWxheVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgIChvbkRyb3Bkb3duQ2xpY2spPVwib25Ecm9wZG93bkNsaWNrKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAoY29tcGxldGVNZXRob2QpPVwibWF0Y2goJGV2ZW50LnF1ZXJ5KVwiXG4gICAgICAgICAgICAgICAgICAgIChvblNlbGVjdCk9XCJzZWxlY3RJdGVtKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAob25VbnNlbGVjdCk9XCJyZW1vdmVWYWx1ZSgkZXZlbnQpXCI+XG5cblxuICAgICAgICA8bmctdGVtcGxhdGUgbGV0LWludGVybmFsQ2hvb3Nlck1vZGVsIHBUZW1wbGF0ZT1cIml0ZW1cIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzTWVudVRlbXBsYXRlKClcIj5cbiAgICAgICAgICAgICAgICB7eyBkaXNwbGF5SXRlbShpbnRlcm5hbENob29zZXJNb2RlbCkgfX1cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJtZW51VGVtcGxhdGVcIiBbaXRlbV09XCJpbnRlcm5hbENob29zZXJNb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNNZW51VGVtcGxhdGUoKVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9wLWF1dG9Db21wbGV0ZT5cblxuICAgIDwhLS1cbiAgICAgICAgV3JhcCB3aG9sZSBzZWxlY3Rpb24gd2l0aCBvbmUgZXh0cmEgZWxlbWVudCBzbyB3ZSBjYW4gbW92ZSBpdCBhcm91bmRcblxuICAgICAgICAgc2VlOiBzZWxlY3Rpb25BcHBlbmRUb1xuICAgIC0tPlxuICAgIDxzcGFuICNzZWxlY3Rpb25WaWV3PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidy1jaG9vc2VyLXNlbGVjdGlvbnNcIlxuICAgICAgICAgICAgICpuZ0lmPVwibXVsdGlzZWxlY3QgJiYgZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZE9iamVjdHMubGVuZ3RoID4gMFwiPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzU2VsZWN0aW9uVGVtcGxhdGUoKVwiPlxuXG4gICAgICAgICAgICA8IS0tIG5vIHNlbGVjdGlvbiB0ZW1wbGF0ZSByZW5kZXIgaXQgYXMgaXQgaXMgZnJvbSBDT1JFLS0+XG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJ1aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIHVpLXdpZGdldCB1aS1zdGF0ZS1kZWZhdWx0IFwiXG4gICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieyd1aS1zdGF0ZS1kaXNhYmxlZCc6ZGlzYWJsZWQsJ3VpLXN0YXRlLWZvY3VzJzphdXRvQ29tcGxldGVDb21wb25lbnQuZm9jdXN9XCI+XG5cbiAgICAgICAgICAgICAgICA8bGkgI3Rva2VuICpuZ0Zvcj1cImxldCBpdGVtIG9mIGRhdGFTb3VyY2Uuc3RhdGUucmVjZW50U2VsZWN0ZWRPYmplY3RzXCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ1aS1hdXRvY29tcGxldGUtdG9rZW4gdWktc3RhdGUtaGlnaGxpZ2h0IHVpLWNvcm5lci1hbGxcIiB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5dXAuZGVsZXRlKT1cInJlbW92ZVZhbHVlKGl0ZW0pXCJcbiAgICAgICAgICAgICAgICAgICAgKGtleXVwLmJhY2tzcGFjZSk9XCJyZW1vdmVWYWx1ZShpdGVtKVwiPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwidWktYXV0b2NvbXBsZXRlLXRva2VuLWljb24gc2FwLWljb24gaWNvbi1kZWNsaW5lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInJlbW92ZVZhbHVlKGl0ZW0pXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS10b2tlbi1sYWJlbFwiPnt7IGRpc3BsYXlJdGVtKGl0ZW0pIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8IS0tWWVzIHRoZXJlIGlzIHNlbGVjdGlvbiB0ZW1wbGF0ZSBsZXQncyBpdGVyYXRlIGFuZCBwdXNoIGVhY2ggaXRlbSB0byBiZSByZW5kZXJlZC0tPlxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgW25nRm9yT2ZdPVwiZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZE9iamVjdHNcIiBsZXQtaXRlbT5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cInNlbGVjdGlvblRlbXBsYXRlXCIgW2l0ZW1dPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNTZWxlY3Rpb25UZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZGF0YVNvdXJjZS5zaG93TW9yZVNlbGVjdGVkKClcIj5cblx0XHRcdDxzcGFuIGNsYXNzPVwibW9yZS1zZWxlY3RlZFwiPlxuXHRcdFx0XHQ8YXctaHlwZXJsaW5rIFtzaXplXT1cIidzbWFsbCdcIiAoYWN0aW9uKT1cImRhdGFTb3VyY2Uuc3RhdGUudG9nZ2xlQWxsU2VsZWN0ZWQoKVwiPlxuXHRcdFx0XHRcdHt7bW9yZVNlbGVjdFN0cmluZygpfX1cblx0XHRcdFx0PC9hdy1oeXBlcmxpbms+XG5cdFx0XHQ8L3NwYW4+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG4gICAgPC9zcGFuPlxuXG5cbjwvZGl2PlxuXG5gLFxuICAgIHN0eWxlczogW2AvZGVlcC8gLnVpLWZsdWlkIC51aS1hdXRvY29tcGxldGUudWktYXV0b2NvbXBsZXRlLWRkIC51aS1hdXRvY29tcGxldGUtaW5wdXQsL2RlZXAvIC51aS1mbHVpZCAudWktYXV0b2NvbXBsZXRlLnVpLWF1dG9jb21wbGV0ZS1kZCAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lcnt3aWR0aDoxMDAlfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGV7bGluZS1oZWlnaHQ6bm9ybWFsfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXR7d2lkdGg6MTAwJX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3duLnVpLWJ1dHRvbntyaWdodDowO3Bvc2l0aW9uOmFic29sdXRlO2JvcmRlcjowO3dpZHRoOjMwcHg7YmFja2dyb3VuZDowIDB9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1kcm9wZG93bi51aS1idXR0b24gLnBpe2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojNzY3Njc2O2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjRlbTttYXJnaW4tbGVmdDotLjg1ZW19L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1kcm9wZG93bi51aS1idXR0b24gLnBpLWNhcmV0LWRvd246YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWVmJ30vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3duLnVpLWJ1dHRvbiBpbnB1dHtwYWRkaW5nLXJpZ2h0OjMwcHh9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbntwYWRkaW5nOjA7bWFyZ2luOjA7dmVydGljYWwtYWxpZ246YmFzZWxpbmU7d2lkdGg6aW5oZXJpdH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuIC5mYXtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Y29sb3I6Izc2NzY3NjtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS4yZW19L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbiAuZmEtc2VhcmNoOmJlZm9yZXtjb250ZW50OidcXFxcZTAwZCd9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbiBpbnB1dHt3aWR0aDppbmhlcml0O3BhZGRpbmctcmlnaHQ6MjVweH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuIHNwYW57cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6NXB4O3RvcDowO3BhZGRpbmctdG9wOi42ZW19L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1kcm9wZG93bntoZWlnaHQ6MzZweH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLXBhbmVsIC51aS1hdXRvY29tcGxldGUtbGlzdC1pdGVte3BhZGRpbmc6LjY1ZW0gMmVtIC42NWVtIC42NGVtO21hcmdpbjowfS9kZWVwLyBib2R5IC51aS1hdXRvY29tcGxldGUudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVye3BhZGRpbmc6LjRlbSAuNWVtIC40ZW0gMWVtfS53LWNob29zZXItc2VsZWN0aW9uc3ttYXJnaW4tdG9wOjJweH0udy1jaG9vc2VyLXNlbGVjdGlvbnMgdWx7bWFyZ2luOjA7cGFkZGluZzowfS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lcntib3JkZXI6MH0udy1jaG9vc2VyLXNlbGVjdGlvbnMgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXIgLnVpLWF1dG9jb21wbGV0ZS10b2tlbntmb250LXNpemU6Ljg1ZW07bGV0dGVyLXNwYWNpbmc6LjFweDtmb250LXdlaWdodDo0MDA7cGFkZGluZzowO2JhY2tncm91bmQ6I2UwZjJmZjttYXJnaW4tcmlnaHQ6NXB4O21hcmdpbi1ib3R0b206NXB4fS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciAudWktYXV0b2NvbXBsZXRlLXRva2VuLWxhYmVse3BhZGRpbmc6NHB4IDIxcHggNHB4IDVweH0udy1jaG9vc2VyLXNlbGVjdGlvbnMgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXIgLnVpLWF1dG9jb21wbGV0ZS10b2tlbi1pY29ue2ZvbnQtc2l6ZTouNzhlbTtwYWRkaW5nLXJpZ2h0Oi4yOGVtfS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciAuc2FwLWljb257bGluZS1oZWlnaHQ6aW5oZXJpdH0udy1jaG9vc2VyLXNlbGVjdGlvbnMgLm1vcmUtc2VsZWN0ZWR7ZGlzcGxheTppbmxpbmUtYmxvY2t9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENIT09TRVJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaG9vc2VyQ29tcG9uZW50KX0sXG4gICAgICAgIHtwcm92aWRlOiBEQVRBX1NPVVJDRSwgdXNlQ2xhc3M6IENob29zZXJEYXRhU291cmNlLCBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdfVxuICAgIF1cblxuXG59KVxuZXhwb3J0IGNsYXNzIENob29zZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKipcbiAgICAgKiBNYXggbnVtYmVyIG9mIGl0ZW1zIHJldHVybiBhdCBzaW5nbGUgTWF0Y2ggc28gd2UgZG8gbm90IHJldHVybiAxMDAwIGl0ZW1zIGF0IHNpbmdsZSB0aW1lLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhMZW5ndGg6IG51bWJlciA9IDEwO1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXggbnVtYmVyIG9mIGl0ZW1zIHJldHVybiBhdCBzaW5nbGUgTWF0Y2ggc28gd2UgZG8gbm90IHJldHVybiAxMDAwIGl0ZW1zIGF0IHNpbmdsZSB0aW1lLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtaW5MZW5Gb3JTZWFyY2g6IG51bWJlciA9IDE7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHRlciB1c2VkIHRvIGZvcm1hdCBlYWNoIHNlbGVjdGlvbiBhbmQgc2VsZWN0ZWQgb2JqZWN0IGZvciBkaXNwbGF5LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZVRyYW5zZm9ybWVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSXMgdGhpcyBtdWx0aXNlbGVjdFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQgQ2hvb3NlckRhdGFTb3VyY2Ugd2lsbCBiZSBjcmVhdGVkIGJ1dCB0aGVyZSBpcyBhIG9wdGlvbiB0byBzZXRcbiAgICAgKiBjdXN0b20gb25lIG9uIGFwcGxpY2F0aW9uIGxldmVsXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkYXRhU291cmNlOiBDaG9vc2VyRGF0YVNvdXJjZTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB3ZSB3YW50IHRvIGNoYW5nZSB0aGUgcGxhY2Ugd2hlcmUgc2VsZWN0aW9uIGlzIHJlbmRlcmVkIHVzZSB0aGlzIGFwcGVuZFRvIHByb3BlcnR5XG4gICAgICogYW5kIGl0IHdpbGwgdXNlIERPTSBvcGVyYXRpb24gYXBwZW5kQ2hpbGQoKSB0byBtb3ZlIHNlbGVjdGlvblZpZXcgdW5kZXIgZGlmZmVyZW50IHBhcmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uQXBwZW5kVG86IEVsZW1lbnRSZWY7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgZGVsYXk6IG51bWJlciA9IDMwMDtcblxuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IHR5cGUgdG8gcmVuZGVyLiBEYXRhIHdpbGwgYmUgcmVhZCBmcm9tIHRoZSByZWdpc3RlcmVkIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGVzdGluYXRpb25DbGFzczogc3RyaW5nO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIGZpZWxkOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBtb2RlbCB0byBsaXN0ZW4gZm9yIElucHV0IHZhbHVlIGNoYW5nZXNcbiAgICAgKi9cbiAgICBpbnRlcm5hbENob29zZXJNb2RlbDogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBFbWJlZGRlZCB0ZW1wbGF0ZSBkZWZpbmVkIGJ5IHVzZXIuIElmIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhbnkgdGVtcGxhdGUgdGhlbiB3aGVuIHJlbmRlcmluZ1xuICAgICAqIGFuIGl0ZW0gd2UgYXNzdW1lIHdlIGFyZSBkZWFsaW5nIHdpdGggcHJpbWl0aXZlIHR5cGVzIGFuZCBjYWxsIG9uIGVhY2ggaXRlbSB0b1N0cmluZygpLCBpZlxuICAgICAqIHdlIGFyZSBkZWFsaW5nIHdpdGggb2JqZWN0LCB0aGVuIHdlIGV4cGVjdCB1c2VyIHRvIHByb3ZpZGUgYSB0ZW1wbGF0ZSBhbmQgdGVsbCB0aGUgY2hvb3NlclxuICAgICAqIGhvdyBpdGVtcyBzaG91bGRzIGJlIGhhbmRsZWQgb3IgYXQgbGVhc3QgdmFsdWVUcmFuc2Zvcm1lciBzbyB3ZSBrbm93IGhvdyB0byBjb252ZXJ0IHRoaXNcbiAgICAgKiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEVhY2ggb2JqZWN0IGNhbiBwcm92aWRlIGl0cyBvd24gdG9TdHJpbmcgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdtZW51SXRlbScpXG4gICAgbWVudVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICBAQ29udGVudENoaWxkKCdzZWxlY3Rpb25JdGVtJylcbiAgICBzZWxlY3Rpb25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBWaWV3Q2hpbGQoJ2F1dG9Db21wcGxldGUnKVxuICAgIGF1dG9Db21wbGV0ZUNvbXBvbmVudDogQXV0b0NvbXBsZXRlO1xuXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0aW9uVmlldycpXG4gICAgc2VsZWN0aW9uVmlld0VsZW06IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHNlbGVjdGlvbiBpcyA+IG1heCBzZWxlY3Rpb24sIHRoZW4gc2hvdyBoaWRlIGxpbmsuXG4gICAgICovXG4gICAgcHJpdmF0ZSBoaWRlTGluazogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHByaXZhdGUgZWxlbWVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHByaXZhdGUgX2RlZmF1bHREUzogQ2hvb3NlckRhdGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5wbGFjZUhvbGRlcikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMucGxhY2VIb2xkZXIgPSBpMThuLmluc3RhbnQoJ1dpZGdldHMuY2hvb3Nlci5wbGFjZUhvbGRlcicpO1xuICAgICAgICAgICAgdGhpcy5wbGFjZUhvbGRlciA9ICdTZWFyY2gnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMuaGlkZUxpbmsgPSBpMThuLmluc3RhbnQoJ1dpZGdldHMuY2hvb3Nlci5oaWRlU2VsZWN0aW9uJyk7XG4gICAgICAgIHRoaXMuaGlkZUxpbmsgPSAnSGlkZSc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kYXRhU291cmNlKSkge1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB0aGlzLl9kZWZhdWx0RFM7XG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wpICYmIGlzUHJlc2VudCh0aGlzLmZvcm1Db250cm9sLnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnVwZGF0ZVZhbHVlKHRoaXMuZm9ybUNvbnRyb2wudmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0SW50ZXJuYWxNb2RlbCgpO1xuXG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBTZWFyY2ggaWNvbiBpbiBjYXNlIG9mIG11bHRpc2VsZWN0LlxuICAgICAqIHRvZG86IE9uY2UgUHJpbWVORyB3aWxsIHByb3ZpZGUgYSB0ZW1wbGF0ZSB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yIHJlbW92ZSBpdFxuICAgICAqXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlYXJjaElucHV0ID0gdGhpcy5lbGVtZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgJy51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4nKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHNlYXJjaElucHV0KSkge1xuICAgICAgICAgICAgbGV0IGljb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgaWNvbkVsZW1lbnQuY2xhc3NOYW1lID0gJ3NlYXJjaC1pY29uLXJpZ2h0IGZhIGZhLWZ3IGZhLXNlYXJjaCc7XG4gICAgICAgICAgICBzZWFyY2hJbnB1dC5hcHBlbmRDaGlsZChpY29uRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uQXBwZW5kVG8pICYmIGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblZpZXdFbGVtKSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudEVsZW0gPSB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvIGluc3RhbmNlb2YgRWxlbWVudFJlZiA/XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25BcHBlbmRUby5uYXRpdmVFbGVtZW50IDogdGhpcy5zZWxlY3Rpb25BcHBlbmRUbztcblxuICAgICAgICAgICAgcGFyZW50RWxlbS5hcHBlbmRDaGlsZCh0aGlzLnNlbGVjdGlvblZpZXdFbGVtLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmVlZCB0byBjaGFuZ2UgY3VycmVudCBiZWhhdmlvciBzaW5jZSB3ZSB3YW50IHRvIHNob3cgc2VsZWN0aW9uIHVuZGVyIHRoZSBjaG9vc2VyLiBLXG4gICAgICpcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9rZW5zID0gdGhpcy5lbGVtZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJy51aS1hdXRvY29tcGxldGUgLnVpLWF1dG9jb21wbGV0ZS10b2tlbicpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRva2VucykgJiYgdG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRva2Vucy5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVtLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gdmFsdWUgaXMgZW50ZXJlZCBpbnRvIHNlYXJjaCBib3gsIHdlIGFzayBvdXIgRGF0YVNvdXJjZSB0byBtYXRjaCB0aGlzIHBhdHRlcm5cbiAgICAgKiBhZ2FpbnN0IGRhdGEgcmVwb3NpdG9yeS4gSXQgd2lsbCByZXRyaWV2ZSBhbGwgcG9zc2libGUgbWF0Y2hlcyBsaW1pdGVkIGJ5IE1heExlbiBhbmQgdGhpc1xuICAgICAqIGlzIGFnYWluIGZpbHRlcmVkIHNvIGl0IGRvZXMgbm90IGluY2x1ZGUgYWxyZWFkeSBzZWxlY3RlZCBpdGVtcy5cbiAgICAgKlxuICAgICAqICB0aGUgbWF0Y2hlZCByZXN1bHRlZCBpcyBzYXZlZCBpbiB0aGU6IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tYXRjaGVzXG4gICAgICovXG4gICAgbWF0Y2gocGF0dGVybjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxldCBtYXhMZW4gPSB0aGlzLm1heExlbmd0aCA/IHRoaXMubWF4TGVuZ3RoIDogQ2hvb3NlckRhdGFTb3VyY2UuTWF4TGVuZ3RoO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZmluZChwYXR0ZXJuLCBtYXhMZW4pO1xuXG5cbiAgICAgICAgLy8gZml4OiBmb3IgdGVzdHM6IEluIHZlcnNpb24gNCB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgZm9jdXMgaW5wdXQgb3RoZXJ3aXNlIGF1dG9jb21wbGV0ZVxuICAgICAgICAvLyBkb2Vzbid0IGdpdmUgdXMgYW55IHBvcHVwIHBhbmVsXG4gICAgICAgIGlmICh0aGlzLmVudi5pblRlc3QgJiYgaXNQcmVzZW50KHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQuZm9jdXNJbnB1dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEludm9rZWQgYnkgRHJvcGRvd24gYnV0dG9uIGluIGNhc2Ugb2Ygc2luZ2xlIHNlbGVjdCBhbmQgaGVyZSB3ZSB3YW50IHRvIGludm9rZSBtYXRjaFxuICAgICAqIHRvIHJldHJpZXZlIGFsbCBzdWdnZXN0aW9ucyB3aXRob3V0IGFueSBmaWx0ZXJcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRHJvcGRvd25DbGljayhldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMubWF0Y2goJyonKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hdGNoKCcqJyk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaG9vc2VyIHN0YXRlIGlzIHVwZGF0ZWQgIHdpdGggdXNlciBzZWxlY3Rpb24uIFBsZWFzZSBzZWUgd3JpdGVWYWx1ZS4gV2hlbiBkbyBub3QgbmVlZFxuICAgICAqIGNhbGwgYW55dGhpbmcgYWRkaXRpb25hbCBhcyBpbnRlcm5hbENob29zZXJNb2RlbCBhbmQgdGhpcy5jaG9vc2VyU3RhdGUuc2VsZWN0ZWRPYmplY3RzKClcbiAgICAgKiBzaGFyZXMgdGhlIHNhbWUgcmVmZXJlbmNlcyBzbyBpdHMgaW1wb3J0YW50IHRoYXQgd2UgZmlyc3Qgc2F2ZSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGlzLmNob29zZXJTdGF0ZS5zZWxlY3RlZE9iamVjdHMoKSBhbmQgdGhlbiBiYWNrIHRvIGludGVybmFsQ2hvb3Nlck1vZGVsXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3RJdGVtKGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KHtvbmx5U2VsZjogdHJ1ZX0pO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUudXBkYXRlZFNlbGVjdGVkT2JqZWN0cyhpdGVtKTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50LmlucHV0RUwubmF0aXZlRWxlbWVudC52YWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5SXRlbSh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVbnNlbGVjdCBpdGVtXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmVWYWx1ZShpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUudXBkYXRlZFNlbGVjdGVkT2JqZWN0cyhpdGVtKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsID0gdGhpcy5kYXRhU291cmNlLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpO1xuXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoe29ubHlTZWxmOiB0cnVlfSk7XG5cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcblxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudC5mb2N1c0lucHV0KCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ29udmVydCBhIG9iamVjdCBpZiBhbnkgaW50byB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICpcbiAgICAgKiB0b2RvOiBpbXBsZW1lbnQgYmV0dGVyIHdheSBob3cgdG8gd29yayB3aXRoIG9iamVjdHNcbiAgICAgKlxuICAgICAqL1xuICAgIGRpc3BsYXlJdGVtKGl0ZW06IGFueSkge1xuICAgICAgICBpZiAoaXNCbGFuayhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmN1cnJlbnRJdGVtID0gaXRlbTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmFsdWVUcmFuc2Zvcm1lcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlVHJhbnNmb3JtZXIoaXRlbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlLmxvb2t1cEtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtW3RoaXMuZGF0YVNvdXJjZS5sb29rdXBLZXldO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgbGFiZWwgdGhhdCBpcyBzaG93biB1bmRlciB0aGUgc2VsZWN0ZWQgaXRlbSB3aGVuIHVzZXIgc2VsZWN0aW9uIGlzID5cbiAgICAgKiBNYXhSZWNlbnRTZWxlY3RlZFxuICAgICAqXG4gICAgICovXG4gICAgbW9yZVNlbGVjdFN0cmluZygpOiBzdHJpbmcge1xuICAgICAgICBsZXQgbW9yZVNlbGVjdGVkID0gdGhpcy5kYXRhU291cmNlLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpLmxlbmd0aCAtXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQ7XG4gICAgICAgIGlmIChtb3JlU2VsZWN0ZWQgPCAyICYmICF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGVMaW5rO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHttb3JlU2VsZWN0ZWR9IG1vcmUgc2VsZWN0ZWQuLi5gO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBtdWx0aXNlbGVjdCA9IGZhbHNlIGNoZWNrIGlmIHdlIHdhbnQgdG8gc2hvdyBhIHNlbGVjdGVkIHZhbHVlIGluc2lkZSB0aGUgaW5wdXRcbiAgICAgKiBmaWVsZFxuICAgICAqXG4gICAgICovXG4gICAgc2luZ2xlVmFsdWVTZWxlY3RlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUgJiYgaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5jdXJyZW50SXRlbSlcbiAgICAgICAgICAgICYmICF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZTtcbiAgICB9XG5cbiAgICBoYXNNZW51VGVtcGxhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5tZW51VGVtcGxhdGUpO1xuICAgIH1cblxuXG4gICAgaGFzU2VsZWN0aW9uVGVtcGxhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25UZW1wbGF0ZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqIEFzIHdlIGFyZSB1c2luZyBEYXRhU291cmNlIGludGVybmFsbHkgZm9yIFsobmdNb2RlbCldIGNhc2Ugd2UgbmVlZCB0byBkZWZmZXIgRGF0YVNvdXJjZVxuICAgICAqIGluaXRpYWxpemF0aW9uIG9uY2Ugd2UgaGF2ZSBhIHZhbHVlIGFuZCB3ZSBvbmx5IGFjY2VwdCBbXVxuICAgICAqXG4gICAgICpcbiAgICAgKiA/IFNob3VsZCB3ZSBkbyBzb21lIGRlZXBlciBjb21wYXJpc2lvbj9cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2VsU3RhdGU6IERlZmF1bHRTZWxlY3Rpb25TdGF0ZSA9IG5ldyBEZWZhdWx0U2VsZWN0aW9uU3RhdGUodGhpcy5tdWx0aXNlbGVjdCk7XG4gICAgICAgICAgICBsZXQgY2hTdGF0ZTogQ2hvb3NlclN0YXRlID0gbmV3IENob29zZXJTdGF0ZShzZWxTdGF0ZSwgdGhpcy5tdWx0aXNlbGVjdCk7XG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKGNoU3RhdGUpO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UudXBkYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0SW50ZXJuYWxNb2RlbCgpO1xuICAgIH1cblxuICAgIGluaXREYXRhc291cmNlKGNob29zZXJTdGF0ZT86IENob29zZXJTdGF0ZSk6IHZvaWQge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcyksXG4gICAgICAgICAgICAnWW91IG5lZWQgdG8gcHJvdmlkZSBkZXN0aW5hdGlvbkNsYXNzIG9yIGN1c3RvbSBEYXRhU291cmNlJyk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICAgICAgICAgICAgb2JqOiB0aGlzLmRlc3RpbmF0aW9uQ2xhc3MsXG4gICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAgICAgICAgICAgIGxvb2t1cEtleTogdGhpcy5maWVsZCxcbiAgICAgICAgICAgIHN0YXRlOiBjaG9vc2VyU3RhdGUsXG4gICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgYnkgbmdPbkluaXQgYW5kIFdyaXRlIHZhbHVlIHRvIHJlYWQgc3RhdGUgZnJvbSBDaG9vc2VyU3RhdGUgYW5kIHNldCBpdCB0byBpbnRlcm5hbFxuICAgICAqIG5nTW9kZWwgcHJvcGVydHlcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdEludGVybmFsTW9kZWwoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsID0gdGhpcy5kYXRhU291cmNlLnN0YXRlLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZvcm1Db250cm9sKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2hvb3NlckNvbXBvbmVudH0gZnJvbSAnLi9jaG9vc2VyLmNvbXBvbmVudCc7XG5pbXBvcnQge0F1dG9Db21wbGV0ZU1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdIeXBlcmxpbmtNb2R1bGV9IGZyb20gJy4uL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEF1dG9Db21wbGV0ZU1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDaG9vc2VyQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Nob29zZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmLFxuICAgIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7U2VsZWN0SXRlbX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBBIHBvcHVwIGxpa2UgY29tcG9uZW50IHJlbmRlcmluZyBsaXN0IG9mIHZhbHVlcyBhcy4gQmFzZWQgb24gUHJpbWVORyBjb21wb25lbnQgYW5kIG9uZSBvZiB0aGVcbiAqIG1haW4gcmVhc29uIHdoeSB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpcyB0byBleHRlbmQgaXRzIGNhcGFiaWxpdGllcyB0byBhY2NlcHQgYWxtb3N0IGFueVxuICogZGF0YSB0eXBlIHdpdGhvdXQgdXNpbmcgUHJpbWVucydzIHNwZWNpZmljIFNlbGVjdEl0ZW0gdHlwZS5cbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICdzaG93RHJvcERvd24nICxcbiAqICAgICAgdGVtcGxhdGU6ICc8YXctZHJvcGRvd24gW2xpc3RdPVwidGVzdEl0ZW1TbWFsbFwiXG4gKiAgICAgKG9uU2VsZWN0aW9uKT1cIm9uU2VsZWN0aW9uKCRldmVudClcIj48L2F3LWRyb3Bkb3duPidcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBNeURyb3BDb21wb25lbnRcbiAqICB7XG4gKiAgICAgIHRlc3RJdGVtU21hbGw6IHN0cmluZ1tdID0gWyd2aWV3JyAsICdlZGl0J107XG4gKlxuICogICAgICAvLyB3aGVuIHlvdSBzd2l0Y2ggbGlzdCBiaW5kaW5nIHRvIHJlZmVydCB0byBsYXJnZSBpdGVtIGZpaWx0ZXIgYXV0b21hdGljYWxseSBpcyBzaG93biBhbmRcbiAqICAgICBtYXggMTAgaXRlbXMgYXJlXG4gKiAgICAgIC8vIHZpc2libGVcbiAqICAgICAgdGVzdEl0ZW1MYXJnZTogc3RyaW5nW10gPSBbJ3ZpZXcnICwgJ2VkaXQnICwgJ2ZyYW5rJyAsICdrb2xhcicgLCAnVGhlIFN1bicgLCAnRG9nJyAsXG4gKiAgICAgJ0NvbXB1dGVyJyAsICdBIERlc2snICxcbiAqICAgICAgJ015IENhcicgLCAnUGVuY2lsJyAsICdUaGlzIFBhZ2UnICwgJ1llc3RlcmRheScgLCAnTW9uZGF5JyAsICdUdWVzZGF5JyAsICdCTVcgUjEyMDAgR1MnICxcbiAqICAgICAnQ3plY2ggUmVwdWJsaWMnICxcbiAqICAgICAgJ0xhc3QgSXRlbSddO1xuICpcbiAqXG4gKiAgICAgIGl0ZW1TZWxlY3RlZDogc3RyaW5nID0gJ3ZpZXcnO1xuICogICAgICBpdGVtU2VsZWN0ZWRMZzogc3RyaW5nID0gJ01vbmRheSc7XG4gKlxuICogICAgICBub3NlbFN0cmluZzogc3RyaW5nID0gJyhubyBzZWxlY3Rpb24pJztcbiAqXG4gKlxuICogICAgICBvblNlbGVjdGlvbiAoZXZlbnQpOiB2b2lkXG4gKiAgICAgIHtcbiAqICAgICAgICAgIHRoaXMuaXRlbVNlbGVjdGVkID0gZXZlbnQ7XG4gKlxuICogICAgICB9XG4gKiAgfVxuICpcbiAqICBgYGBcbiAqXG4gKi9cblxuXG5leHBvcnQgY29uc3QgRERfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERyb3Bkb3duQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRyb3Bkb3duJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LWRyb3Bkb3duXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc1N0YW5kYWxvbmVcIj5cbiAgICAgICAgPHAtZHJvcGRvd24gW29wdGlvbnNdPVwiaW50ZXJuYWxMaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgW2Zvcm1Db250cm9sTmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cIm5vU2VsZWN0aW9uU3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgW2F1dG9XaWR0aF09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwic2hvd0ZpbHRlcigpXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uSXRlbVNlbGVjdGlvbigkZXZlbnQpXCI+XG5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBsZXQtaXRlbSBwVGVtcGxhdGU9XCJpdGVtXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNFbWJlZGRlZFRlbXBsYXRlKCkgJiYgaXRlbUV4aXN0KGl0ZW0pXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7aXRlbS5sYWJlbCB9fVxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJpdGVtVGVtcGxhdGVcIiBbaXRlbV09XCJpdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNFbWJlZGRlZFRlbXBsYXRlKCkgJiYgaXRlbUV4aXN0KGl0ZW0pXCI+XG5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgICAgIDwvcC1kcm9wZG93bj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9kaXY+XG5cblxuPCEtLSBubyBmb3JtQ29udHJvbCBOYW1lIGhlcmUuIG5nTW9kZWwgY2Fubm90IGhhdmUgZm9ybUdyb3VwIGFyb3VuZCAtLT5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNTdGFuZGFsb25lXCI+XG4gICAgPGRpdiBjbGFzcz1cInctZHJvcGRvd25cIj5cbiAgICAgICAgPHAtZHJvcGRvd24gW29wdGlvbnNdPVwiaW50ZXJuYWxMaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwibm9TZWxlY3Rpb25TdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBbYXV0b1dpZHRoXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJzaG93RmlsdGVyKClcIlxuICAgICAgICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25JdGVtU2VsZWN0aW9uKCRldmVudClcIj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtIHBUZW1wbGF0ZT1cIml0ZW1cIj5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzRW1iZWRkZWRUZW1wbGF0ZSgpICYmIGl0ZW1FeGlzdChpdGVtKVwiPlxuICAgICAgICAgICAgICAgICAgICB7e2l0ZW0ubGFiZWwgfX1cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cIml0ZW1UZW1wbGF0ZVwiIFtpdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0VtYmVkZGVkVGVtcGxhdGUoKSAmJiBpdGVtRXhpc3QoaXRlbSlcIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9wLWRyb3Bkb3duPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWl0ZW1zLXdyYXBwZXJ7bWF4LWhlaWdodDpub25lIWltcG9ydGFudH0vZGVlcC8gLnVpLWRyb3Bkb3duLXBhbmVsIC51aS1kcm9wZG93bi1pdGVte3BhZGRpbmc6LjY1ZW0gMmVtIC42NWVtIC42NGVtO21hcmdpbjowfS9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWZpbHRlci1jb250YWluZXJ7d2lkdGg6MTAwJX0vZGVlcC8gLnVpLWRyb3Bkb3duLXBhbmVsIC51aS1kcm9wZG93bi1maWx0ZXItY29udGFpbmVyIC5mYXt0b3A6MS4yZW19L2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24tbGlzdHtwYWRkaW5nOjFlbSAwfS9kZWVwLyAudy1kcm9wZG93bjpub3QoLm5nLWRpcnR5KSBsYWJlbHtjb2xvcjojOTY5Njk2fS9kZWVwLyAudy1kcm9wZG93biAudWktZHJvcGRvd24tdHJpZ2dlci51aS1jb3JuZXItcmlnaHR7Ym9yZGVyLWxlZnQ6bm9uZTtjb2xvcjojOTY5Njk2fS9kZWVwLyAudy1kcm9wZG93biAudWktZHJvcGRvd24tdHJpZ2dlciAucGl7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2NvbG9yOiM3Njc2NzY7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuNGVtO21hcmdpbi1sZWZ0Oi0uODVlbX0vZGVlcC8gLnctZHJvcGRvd24gLnVpLWRyb3Bkb3duLXRyaWdnZXIgLnBpLWNhcmV0LWRvd246YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWVmJ30vZGVlcC8gLnctZHJvcGRvd24gLnVpLWRyb3Bkb3duLWxhYmVse3BhZGRpbmctcmlnaHQ6Mi40ZW19YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIEREX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRHJvcGRvd25Db21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBEcm9wZG93bkNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4TnVtU2hvd24gPSAxMDtcblxuICAgIC8qKlxuICAgICAqIE9yZGVyZWQgbGlzdCBvZiBpdGVtcyByZW5kZXJlZCBhcyBhIHBvcHVwIG1lbnVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogSXRlbXMgd2hpY2ggd2FzIHNlbGVjdGVkIGFzIGEgZGVmYXVsdCB2YWx1ZSBvciBieSB1c2VkIGluIHRoZSBwb3B1cCBtZW51LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVuZGVyZWQgYXMgZmlyc3QgdmFsdWUgaW4gdGhlIHBvcHVwIHdoaWNoIGxldCB0aGUgdXNlciB0byBtYWtlICdubyBzZWxlY3Rpb24nIGZyb21cbiAgICAgKiBhdmFpbGFibGUgbGlzdCBvZiB2YWx1ZXMuIFdoZW4gdGhpcyBvcHRpb24gaXMgYWN0aXZlIGFuZCB1c2UgbWFrZSB0aGlzIHNlbGVjdGlvbiB3ZSBzYXZlIGFcbiAgICAgKiBOVUxMIHZhbHVlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub1NlbGVjdGlvblN0cmluZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBpbnRlcm5hbCBsaXN0IHRoYXQgaGlkZXMgUHJpbWVORyBzcGVjaWZpY3Mgd2hlcmUgd2UgbmVlZCB0byBkZWFsIHdpdGggc3BlY2lhbFxuICAgICAqIHR5cGU6IFNlbGVjdEl0ZW0uIE91ciBleHBlY3RhdGlvbiBpcyB0aGF0IHlvdSBuZWVkIHRvIGJlIGFibGUgdG8gcGFzcyByZWd1bGFyIHN0cmluZyB2YWx1ZXNcbiAgICAgKiBvciBmdWxsIG9iamVjdCBhbmQgbm90IHRyeWluZyB0byB3cmFwIGl0IGludG8gZXh0cmEgbGF5ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnRlcm5hbExpc3Q6IFNlbGVjdEl0ZW1bXTtcblxuXG4gICAgLyoqXG4gICAgICogRW1iZWRkZWQgdGVtcGxhdGUgZGVmaW5lZCBieSB1c2VyLiBJZiB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYW55IHRlbXBsYXRlIGFuZCB3aGlsZSByZW5kZXJpbmdcbiAgICAgKiBpdGVtIHdlIGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHByaW1pdGl2ZSB0eXBlcyBhbmQgY2FsbCBvbiBlYWNoIGl0ZW0gdG9TdHJpbmcoKSwgaWYgd2VcbiAgICAgKiBhcmUgZGVhbGluZyB3aXRoIG9iamVjdCwgdGhlbiB3ZSBleHBlY3QgdXNlciB0byBwcm92aWRlIGEgdGVtcGxhdGUgYW5kIHRlbGwgdGhlIGRyb3Bkb3duIG9mXG4gICAgICogZWFjaCBpdGVtIHNob3VsZCBiZSBoYW5kbGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdpdGVtVGVtcGxhdGUnKVxuICAgIGl0ZW1UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWwgdXNlZCBmb3IgZW1iZWRkZWQgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBtb2RlbDogU2VsZWN0SXRlbTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2RvOiBQdXQgYmFjayB0aGUgc2Nyb2xsaW5nIG9wdGlvbiBvbmNlIHdlIGRlY2lkZSBzby4gQ3VycmVudGx5IHRoZSByZXF1aXJlbWVudHMgYXJlXG4gICAgICogc2hvdyBvbmx5IDEwIGl0ZW1zIG1heCwgbm8gc2Nyb2xsaW5nLiBGdW5jdGlvbmFsaXR5IGNvbW1lbnRlZCBvdXQgY2FuIHNob3cgc2Nyb2xsYmFyIHdpdGhcbiAgICAgKiBzZWFyY2ggZmlsdGVyLlxuICAgICAqL1xuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIHRyYW5zZm9ybSBhIHZhbHVlIHRvIFByaW1lTmcgRm9ybWF0LCB3ZSBhcmUgbm90IHJlYWxseSBiZSB1c2luZyBhIGxhYmVsIGZpZWxkIG9ubHkgYVxuICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSBbXTtcbiAgICAgICAgLy8gaWYgKGlzUHJlc2VudCh0aGlzLm5vU2VsZWN0aW9uU3RyaW5nKSkge1xuICAgICAgICAvLyAgICAgdGhpcy5pbnRlcm5hbExpc3QucHVzaCh7XG4gICAgICAgIC8vICAgICAgICAgbGFiZWw6IHRoaXMubm9TZWxlY3Rpb25TdHJpbmcsXG4gICAgICAgIC8vICAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpICYmIHRoaXMubGlzdC5sZW5ndGggPj0gRHJvcGRvd25Db21wb25lbnQuTWF4TnVtU2hvd24pIHtcblxuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3Quc2xpY2UoMCwgRHJvcGRvd25Db21wb25lbnQuTWF4TnVtU2hvd24pLm1hcCgoaXRlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IGl0ZW0udG9TdHJpbmcoKSwgdmFsdWU6IGl0ZW19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gdGhpcy5saXN0LnNsaWNlKDApLm1hcCgoaXRlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IGl0ZW0udG9TdHJpbmcoKSwgdmFsdWU6IGl0ZW19O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGhhc0VtYmVkZGVkVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLml0ZW1UZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdG8gcHJldmVudCBFbXB0eSBpdGVtIHRvIGJlIHJlbmRlcmVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBSZXBvcnQgdGhpcyBvbiBQcmltZU5nXG4gICAgICpcbiAgICAgKi9cbiAgICBpdGVtRXhpc3QoaXRlbTogYW55KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChpdGVtKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZHJvcGRvd24gbGlzdCBpcyBtb3JlIHRoZW4gZGVmaW5lZCBjb25zdGFudCBNYXhOdW1TaG93biAoMTApIGF1dG9tYXRpY2FsbHkgc2hvdyBmaWx0ZXJcbiAgICAgKiBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIHNob3dGaWx0ZXIoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyByZXR1cm4gaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgdGhpcy5saXN0Lmxlbmd0aCA+IERyb3Bkb3duQ29tcG9uZW50Lk1heE51bVNob3duO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXBkYXRlcyBpbnRlcm5hbCBtb2RlbHMgb2YgY3VycmVudCBzZWxlY3Rpb25zIGFuZCB0cmlnZ2VycyBvblNlbGVjdGlvbiBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgb25JdGVtU2VsZWN0aW9uKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlLnZhbHVlO1xuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodmFsdWUudmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KHtvbmx5U2VsZjogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh2YWx1ZS52YWx1ZSk7XG4gICAgfVxuXG4gICAgZGlzcGxheUl0ZW0oaXRlbTogYW55KVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChpdGVtKSA/IGl0ZW0ubGFiZWwgOiAnTm8gU2VsZWN0aW9uJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCFlcXVhbHModmFsdWUsIHRoaXMuc2VsZWN0aW9uKSkge1xuXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtEcm9wZG93bkNvbXBvbmVudH0gZnJvbSAnLi9kcm9wZG93bi5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtEcm9wZG93bk1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEcm9wZG93bkNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRHJvcGRvd25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRHJvcGRvd25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXRHJvcGRvd25Nb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc0JsYW5rLCBpc1ByZXNlbnQsIFZhbHVlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG4vKipcbiAqIExpZ2h0d2VpZ2h0IGFuZCBjb25maWd1cmFibGUgQ3VycmVuY3kgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBuZyBib290c3RyYXAgZGlyZWN0aXZlLiBUaGlzXG4gKiBjb21wb25lbnQgY29tYmluZXMgYW4gaW5wdXQgYW5kIGN1cnJlbmN5IGNvZGUgZHJvcGRvd24uXG4gKlxuICpcbiAqIGZvciBtb3JlIGluZm8gcGxlYXNlIHNlZSBjbGFzcyBEb2Mgb2YgdGhlOlxuICogIEBzZWUge0BsaW5rIGN1cnJlbmN5L2N1cnJlbmN5LmNvbXBvbmVudC50c31cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ2Ftb3VudCcgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgIDxhdy1jdXJyZW5jeSBbbW9uZXldPVwicHJpY2VcIiBbY3VycmVuY2llc109XCJjdXJyZW5jaWVzXCIgW25hbWVdPVwiJ2N1cnJlbmN5J1wiPlxuICogICAgICA8L2F3LWN1cnJlbmN5PlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBhbW91bnQ6IG51bWJlciA9IDEwMDA7XG4gKiAgICAgICAgY3VycmVuY2llczogc3RyaW5nW10gPSBbJ1VTRCcsICdDTlknLCAnQVVEJywgJ0VVUicsICdHQlAnXTtcbiAqICAgICAgICBjdXJyZW5jeUNvZGU6IHN0cmluZyA9IHRoaXMuY3VycmVuY2llc1swXTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5cbmV4cG9ydCBjb25zdCBDVVJSRU5DWV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ3VycmVuY3lDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY3VycmVuY3knLFxuICAgIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlXCI+XG4gICAgPGRpdiBjbGFzcz1cInctY3VycmVuY3ktZmllbGQgdWktZmx1aWRcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZyBcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTggdWktZy1ub3BhZCBcIj5cbiAgICAgICAgICAgICAgICA8aW5wdXQgI2N1cnJlbmN5SW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgcElucHV0VGV4dFxuICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiIGNsYXNzPVwidy10ZXh0LWZpZWxkIGN1cnJlbmN5LWZvcm1hdFwiXG4gICAgICAgICAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgIFthdHRyLnBsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImRpc3BsYXlWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgIChmb2N1cyk9XCJvbkZvY3VzKGN1cnJlbmN5SW5wdXQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGJsdXIpPVwib25CbHVyKGN1cnJlbmN5SW5wdXQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTQgdWktZy1ub3BhZCB3LWNjLWZpZWxkXCI+XG4gICAgICAgICAgICAgICAgPGF3LWRyb3Bkb3duICpuZ0lmPVwiIXJlYWRvbmx5Q3VycmVuY3lDb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiIFtsaXN0XT1cImN1cnJlbmNpZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uXT1cIm1vbmV5LmN1cnJlbmN5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uU2VsZWN0aW9uKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cblxuICAgICAgICAgICAgICAgIDwvYXctZHJvcGRvd24+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cInJlYWRvbmx5Q3VycmVuY3lDb2RlXCIgY2xhc3M9XCJ3LWNjLXJlYWRvbmx5LWZpZWxkXCI+e3ttb25leS5jdXJyZW5jeX19PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tIGN1cnJlbmN5OidVU0QnOnRydWUgLS0+XG5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhZWRpdGFibGVcIj5cbiAgICA8YXctc3RyaW5nIHZhbHVlPVwie3tkaXNwbGF5VmFsdWV9fSB7eyBnZXRNb25leUN1cnJlbmN5KCkgfX1cIj48L2F3LXN0cmluZz5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2Audy1jdXJyZW5jeS1maWVsZCBbcmVhZG9ubHldLC53LWN1cnJlbmN5LXR5cGUtZmllbGQgW3JlYWRvbmx5XXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnctY3VycmVuY3ktZmllbGQgaW5wdXQsLnctY3VycmVuY3ktdHlwZS1maWVsZCBpbnB1dHttaW4td2lkdGg6ODBweH0udy1jdXJyZW5jeS1maWVsZCBpLmZhLC53LWN1cnJlbmN5LXR5cGUtZmllbGQgaS5mYXtjdXJzb3I6cG9pbnRlcn0udy1jdXJyZW5jeS1maWVsZHttYXJnaW4tdG9wOjB9LnctY3VycmVuY3ktZmllbGQgL2RlZXAvIC51aS1kcm9wZG93bnttaW4td2lkdGg6ODBweH0udy1jYy1maWVsZHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfS53LWNjLXJlYWRvbmx5LWZpZWxke3BhZGRpbmctbGVmdDo1cHg7Y29sb3I6Izk2OTY5Nn0ubm8tZ3V0dGVyPltjbGFzcyo9dWktZy1de3BhZGRpbmctcmlnaHQ6MDtwYWRkaW5nLWxlZnQ6MH1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ1VSUkVOQ1lfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDdXJyZW5jeUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIEN1cnJlbmN5Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBNb25leSBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdmFsdWUsIGxvY2FsZSwgY3VycmVuY3kgY29kZS5cbiAgICAgKiBJZiB0aGlzIG9iamVjdCBpcyBzZXQsIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1vbmV5OiBNb25leTtcblxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdXNlciB0byBjaGFuZ2UgTW9uZXkncyBjdXJyZW5jeSBjb2RlIGFuZCBzdGlsbFxuICAgICAqIGFsbG93IHVzZXIgdG8gZWRpdCBNb25leSdzIGFtb3VudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlYWRvbmx5Q3VycmVuY3lDb2RlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVuY3kgdGhhdCdzIHNlbGVjdGVkIGZvciB0aGlzIGN1cnJlbmN5IGZpZWxkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVuY3lTZWxlY3Rpb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB1c2VkIHRvIGZvcm1hdCB0aGUgbW9uZXkgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwcmVjaXNpb246IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgY3VycmVuY2llcyB0aGF0IHRoaXMgY3VycmVuY3kgd2lkZ2V0IHN1cHBvcnQuIFRoZSBmb3JtYXQgZm9yIGVhY2ggZW50cnkgc2hvdWxkIGJlXG4gICAgICogW2N1cnJlbmN5LWNvZGUgLSBkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBfY3VycmVuY2llczogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtYXR0ZWQgY3VycmVuY3kgdmFsdWUuIFVzZXMgYW5ndWxhciBjdXJyZW5jeVBpcGUgdG8gZm9ybWF0IGJhc2VkIG9uIGNvdW50cnkgY29kZS5cbiAgICAgKi9cbiAgICBkaXNwbGF5VmFsdWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW5jeSBwaXBlIGlzIHVzZWQgdG8gZm9ybWF0IG91ciBtb25leSBvYmplY3QuXG4gICAgICovXG4gICAgY3VycmVuY3lQaXBlOiBDdXJyZW5jeVBpcGU7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjdXJyZW5jaWVzLlxuICAgICAgICB0aGlzLmluaXRDdXJyZW5jaWVzKCk7XG5cbiAgICAgICAgdGhpcy5jdXJyZW5jeVBpcGUgPSBuZXcgQ3VycmVuY3lQaXBlKGVudi5sb2NhbGUpO1xuXG4gICAgICAgIGVudi5vbkxvY2FsZUNoYW5nZS5zdWJzY3JpYmUoKGxvY2FsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5UGlwZSA9IG5ldyBDdXJyZW5jeVBpcGUobG9jYWxlKTtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vbmV5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb25leS5hbW91bnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5tb25leSk7XG5cbiAgICAgICAgdGhpcy5pbml0Q3VycmVuY2llcygpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY3VycmVuY3lTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gdGhpcy5fY3VycmVuY2llc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlYWR5IHRoZSBtb25leSBmaWVsZCBpZiBpdCBleGlzdHMuIGFuZCBvdmVycmlkZSB0aGUgZXhpc3RpbmcgdmFsdWVzLlxuICAgICAgICBpZiAodGhpcy5tb25leSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IHRoaXMubW9uZXkuY3VycmVuY3k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vbmV5ID0gbmV3IE1vbmV5KG51bGwsIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgaW5pdEN1cnJlbmNpZXMoKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jdXJyZW5jaWVzIHx8IHRoaXMuX2N1cnJlbmNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW5jaWVzID0gWydVU0QnLCAnQ05ZJywgJ0FVRCcsICdFVVInLCAnR0JQJ107XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIERpc3BsYXkgdGhlIHJlYWwgdmFsdWUgd2hlbiB0aGUgdXNlciBjbGlja3MgaW4gdGhlIGN1cnJlbmN5IHdpZGdldC4gVGhlbiBoZSBjYW4gbW9kaWZ5IHRoZVxuICAgICAqIHZhbHVlIHdpdGhvdXQgc2VlaW5nIHRoZSBmb3JtYXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsXG4gICAgICovXG4gICAgb25Gb2N1cyhlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vbmV5KSAmJiBpc1ByZXNlbnQodGhpcy5tb25leS5hbW91bnQpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMubW9uZXkuYW1vdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5IHRoZSBmb3JtYXR0ZWQgY3VycmVuY3kgdmFsdWUgd2hlbiB0aGUgdXNlciBuYXZpZ2F0ZXMgYXdheS5cbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBvbkJsdXIoZWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubW9uZXkgPSB0aGlzLm1vbmV5LmNsb25lKHthbW91bnQ6IE51bWJlcihlbC52YWx1ZSl9KTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9uZXkpO1xuICAgIH1cblxuICAgIG9uU2VsZWN0aW9uKGN1cnJlbmN5OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gY3VycmVuY3k7XG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeSh0aGlzLm1vbmV5LmFtb3VudCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHdpbGwgY2hlY2sgdG8gc2VlIGlmIGN1cnJlbmN5IGlzIGEgdmFsaWQgbnVtYmVyIGJlZm9yZSBmb3JtYXR0aW5nLlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKi9cbiAgICBwcml2YXRlIGZvcm1hdEN1cnJlbmN5KHZhbDogYW55KTogYW55XG4gICAge1xuICAgICAgICBpZiAoIXZhbCB8fCB2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZSA9ICdVU0QnO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW5jeVNlbGVjdGlvbikge1xuICAgICAgICAgICAgY29kZSA9IHRoaXMuY3VycmVuY3lTZWxlY3Rpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbmV5ID0gdGhpcy5tb25leS5jbG9uZSh7Y3VycmVuY3k6IHRoaXMuY3VycmVuY3lTZWxlY3Rpb259KTtcblxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB0aGUgcHJlY2lzaW9uIGlzIDIuIEZvciBleGFtcGxlLCAxMC4yMyBVU0QuXG4gICAgICAgIGxldCBkaWdpdHMgPSAnMS4wLTInO1xuICAgICAgICAvLyBJZiBwcmVjaXNpb24gaXMgcHJlc2VudCwgdXNlIGl0IGZvciBmb3JtYXQgdGhlIG1vbmV5IHZhbHVlIGZvciBkaXNwbGF5LlxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucHJlY2lzaW9uKSkge1xuICAgICAgICAgICAgZGlnaXRzID0gJzEuMC0nICsgdGhpcy5wcmVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lQaXBlLnRyYW5zZm9ybSh2YWwsIGNvZGUsICdzeW1ib2wnLCBkaWdpdHMpO1xuICAgIH1cblxuICAgIGdldE1vbmV5Q3VycmVuY3koKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRpc3BsYXlWYWx1ZSkgJiYgdGhpcy5kaXNwbGF5VmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lTZWxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGN1cnJlbmNpZXMoKTogYW55W11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW5jaWVzO1xuICAgIH1cblxuICAgIHNldCBjdXJyZW5jaWVzKHZhbHVlOiBhbnlbXSlcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW5jaWVzID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCh2YWx1ZSBpbnN0YW5jZW9mIE1vbmV5KSAmJiAhZXF1YWxzKHZhbHVlLCB0aGlzLm1vbmV5KSkge1xuICAgICAgICAgICAgdGhpcy5tb25leSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vbmV5LmN1cnJlbmN5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSB0aGlzLm1vbmV5LmN1cnJlbmN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb25leSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogTW9uZXkgb2JqZWN0IGlzIHJlcHJlc2VudGVkIGFzIGEgdmFsdWUsIGxvY2FsZSwgYW5kIGN1cnJlbmN5Q29kZVxuICovXG5leHBvcnQgY2xhc3MgTW9uZXkgaW1wbGVtZW50cyBWYWx1ZVxue1xuICAgIHVuaXF1ZU5hbWU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSBhbW91bnQ6IG51bWJlciA9IDAsIHB1YmxpYyByZWFkb25seSBjdXJyZW5jeTogc3RyaW5nID0gJ1VTRCcsXG4gICAgICAgICAgICAgICAgcHVibGljIHJlYWRvbmx5IGxvY2FsZTogc3RyaW5nID0gJ2VuX1VTJylcbiAgICB7XG4gICAgfVxuXG5cbiAgICBnZXRUeXBlcygpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IE51bWJlcixcbiAgICAgICAgICAgIGN1cnJlbmN5OiBTdHJpbmcsXG4gICAgICAgICAgICBsb2NhbGU6IFN0cmluZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzTmFtZSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiAnTW9uZXknO1xuICAgIH1cblxuICAgICRwcm90bygpOiBNb25leVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25leSgxLCAnMjMnLCAnMzMnKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmFtb3VudCArICcsIGxvY2FsZTogJyArIHRoaXMubG9jYWxlICsgJywgY29kZTogICcgKyB0aGlzLmN1cnJlbmN5O1xuICAgIH1cblxuXG4gICAgY2xvbmUoZGF0YTogeyBhbW91bnQ/OiBudW1iZXIsIGN1cnJlbmN5Pzogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcgfSA9IHt9KTogTW9uZXlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgTW9uZXkoXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5hbW91bnQpID8gZGF0YS5hbW91bnQgOiB0aGlzLmFtb3VudCxcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmN1cnJlbmN5KSA/IGRhdGEuY3VycmVuY3kgOiB0aGlzLmN1cnJlbmN5LFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEubG9jYWxlKSA/IGRhdGEubG9jYWxlIDogdGhpcy5sb2NhbGVcbiAgICAgICAgKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZSwgQ3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtEcm9wZG93bk1vZHVsZSwgSW5wdXRUZXh0TW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtDdXJyZW5jeUNvbXBvbmVudH0gZnJvbSAnLi9jdXJyZW5jeS5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FXRHJvcGRvd25Nb2R1bGV9IGZyb20gJy4uL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEN1cnJlbmN5Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEN1cnJlbmN5Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEN1cnJlbmN5Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbQ3VycmVuY3lQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBBV0N1cnJlbmN5TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNEYXRlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogTGlnaHR3ZWlnaHQgYW5kIGNvbmZpZ3VyYWJsZSBEYXRlIGFuZCBUaW1lIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgcHJpbWVuZy4gVGhpc1xuICogY29tcG9uZW50IGNvbWJpbmVzIGJvdGggZGF0ZSBwaWNrZXIgYXMgd2VsbCBhcyB0aW1lIHBpY2tlclxuICpcbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215VGltZXInICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICA8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgIFtuYW1lXT1cIidkdWVEYXRlJ1wiPlxuICogICAgPC9hdy1kYXRlLXRpbWU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVRpbW1lckNvbXBvbmV0XG4gKiAgICB7XG4gKlxuICogICAgICAgIGRhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICpcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHRoaXMuZGF0ZS5zZXRGdWxsWWVhcigyMDE2ICwgMTAgLCAzKTtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEhvdXJzKDEwICwgMTAgLCAxMCk7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQgeW91IHdpbGwgc2VlIGRhdGUgZmllbGQgYW5kIHRpbWUgZmllbGQgaXMgaGlkZGVuIHRvIHNob3cgYm90aCB5b3UganVzdCBkbyBmb2xsb3dpbmc6XG4gKlxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXlUaW1lcicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICA8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgIFtzaG93VGltZV09XCJzaG93VGltZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiICBbbmFtZV09XCInYmJkZCdcIj5cbiAqICAgIDwvYXctZGF0ZS10aW1lPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlUaW1tZXJDb21wb25ldFxuICogICAge1xuICogICAgICAgIGRhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuICogICAgICAgIHNob3dUaW1lID0gdHJ1ZTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIHRoaXMuZGF0ZS5zZXRGdWxsWWVhcigyMDE2ICwgMTAgLCAzKTtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEhvdXJzKDEwICwgMTAgLCAxMCk7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICovXG5cblxuZXhwb3J0IGNvbnN0IERBVEVUSU1FX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlQW5kVGltZUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGF0ZS10aW1lJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlZGl0YWJsZVwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInctZGF0ZXRpbWUgXCIgW2NsYXNzLmhhcy10aW1lXT1cInNob3dUaW1lXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIj5cblxuICAgICAgICA8cC1jYWxlbmRhciBmb3JtQ29udHJvbE5hbWU9XCJ7e25hbWV9fVwiXG4gICAgICAgICAgICAgICAgICAgIFtkZWZhdWx0RGF0ZV09XCJkZWZhdWx0RGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzaG93SWNvbl09XCJzaG93SWNvblwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ9XCJ7e3Nob3dUaW1lID8gZm9ybWF0TmFtZVdpdGhUaW1lIDogZm9ybWF0UGF0dGVybn19XCJcbiAgICAgICAgICAgICAgICAgICAgW3llYXJOYXZpZ2F0b3JdPVwic2hvd05hdmlnYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbbW9udGhOYXZpZ2F0b3JdPVwic2hvd05hdmlnYXRpb25cIlxuICAgICAgICAgICAgICAgICAgICBbeWVhclJhbmdlXT1cInllYXJSYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3tzaG93VGltZSA/IGZvcm1hdE5hbWVXaXRoVGltZS50b1VwcGVyQ2FzZSgpIDogZm9ybWF0UGF0dGVybi50b1VwcGVyQ2FzZSgpfX1cIlxuICAgICAgICAgICAgICAgICAgICAob25TZWxlY3QpPVwib25EYXRlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICBbdGltZU9ubHldPVwiIXNob3dEYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW3JlYWRvbmx5SW5wdXRdPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2NhbGVdPVwiaTE4blwiPlxuICAgICAgICA8L3AtY2FsZW5kYXI+XG5cbiAgICAgICAgPHAtY2FsZW5kYXIgKm5nSWY9XCJzaG93VGltZVwiXG4gICAgICAgICAgICAgICAgICAgIGljb249XCJpY29uLWhpc3RvcnlcIlxuICAgICAgICAgICAgICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJ7e25hbWV9fVwiXG4gICAgICAgICAgICAgICAgICAgIFtob3VyRm9ybWF0XT1cImhvdXJGb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICBbZGVmYXVsdERhdGVdPVwiZGVmYXVsdERhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbc2hvd0ljb25dPVwic2hvd0ljb25cIlxuICAgICAgICAgICAgICAgICAgICBbdGltZU9ubHldPVwic2hvd1RpbWVcIlxuICAgICAgICAgICAgICAgICAgICBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIlxuICAgICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwidGltZVBsYWNlSG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0KT1cIm9uRGF0ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgW2xvY2FsZV09XCJpMThuXCI+XG4gICAgICAgIDwvcC1jYWxlbmRhcj5cblxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgdmFsdWU9XCJ7e3ZhbHVlIHwgZGF0ZTogZm9ybWF0UGF0dGVybk5HfX1cIj48L2F3LXN0cmluZz5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2AvZGVlcC8gLnctZGF0ZXRpbWUgLnVpLWNhbGVuZGFyIGJ1dHRvbntib3JkZXI6MDt3aWR0aDowfS9kZWVwLyAudy1kYXRldGltZSAudWktY2FsZW5kYXIudWktY2FsZW5kYXItdy1idG4gLnVpLWlucHV0dGV4dHt3aWR0aDoxMDAlfS9kZWVwLyAudWktY2FsZW5kYXIgLnVpLWNhbGVuZGFyLWJ1dHRvbiAudWktYnV0dG9uLWljb24tbGVmdHtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Y29sb3I6IzE5OWRlMDtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS40ZW19L2RlZXAvIC51aS1jYWxlbmRhciAudWktY2FsZW5kYXItYnV0dG9uIC51aS1idXR0b24taWNvbi1sZWZ0LnBpLWNhbGVuZGFyOmJlZm9yZXtjb250ZW50OidcXFxcZTBlMCd9L2RlZXAvIC51aS1jYWxlbmRhciAudWktY2FsZW5kYXItYnV0dG9uIC51aS1idXR0b24taWNvbi1sZWZ0Lmljb24taGlzdG9yeTpiZWZvcmV7Y29udGVudDonXFxcXGUwMmQnfS9kZWVwLyAudWktZGF0ZXBpY2tlcnt3aWR0aDoyNC4yOGVtO2xpbmUtaGVpZ2h0OjI1cHg7cGFkZGluZzowO2JvcmRlci1jb2xvcjojOTc5Nzk3O2JveC1zaGFkb3c6bm9uZX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItaGVhZGVye3BhZGRpbmc6LjkyZW0gMDtmb250LXdlaWdodDo0MDA7Y29sb3I6IzAwMDtmb250LXNpemU6MWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1uZXh0LC9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1wcmV2e3RvcDoxZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLXByZXZ7bGVmdDouMmVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1uZXh0e3JpZ2h0Oi4yZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIHRhYmxle2ZvbnQtc2l6ZToxZW07bWFyZ2luOjAgMCAxLjVlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGh7Zm9udC13ZWlnaHQ6NDAwO2JhY2tncm91bmQtY29sb3I6I2VjZWNlYztjb2xvcjojMzYzNjM2O3BhZGRpbmc6Ljc4NmVtIDEuMDdlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGR7cGFkZGluZzouMWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0ZCBhe3RleHQtYWxpZ246Y2VudGVyO3dpZHRoOjIuN2VtO2hlaWdodDoyLjdlbTtsaW5lLWhlaWdodDoyLjdlbTtwYWRkaW5nOjA7Ym9yZGVyLXJhZGl1czo1MCV9L2RlZXAvIC51aS1kYXRlcGlja2VyIHRkIGEudWktc3RhdGUtZGVmYXVsdHtib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9L2RlZXAvIC51aS1kYXRlcGlja2VyIHRkIGEudWktc3RhdGUtYWN0aXZle2JhY2tncm91bmQtY29sb3I6IzE5OWRlMDtjb2xvcjojZmZmfS9kZWVwLyAudWktZGF0ZXBpY2tlciAucGl7Zm9udC1zaXplOjFlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnBpLnBpLWNoZXZyb24tbGVmdDpiZWZvcmV7Y29udGVudDonXFxcXGUxZWUnfS9kZWVwLyAudWktZGF0ZXBpY2tlciAucGkucGktY2hldnJvbi1yaWdodDpiZWZvcmV7Y29udGVudDonXFxcXGUxZWQnfS9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1jYWxlbmRhciB0ZDpub3QoLnVpLXN0YXRlLWRpc2FibGVkKSBhOmhvdmVye2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjUsMTU3LDIyNCwuNyk7b3BhY2l0eTouNzU7Y29sb3I6IzM2MzYzNn0vZGVlcC8gLnVpLWRhdGVwaWNrZXItdGltZW9ubHl7d2lkdGg6MTAwJX0vZGVlcC8gLnVpLXRpbWVwaWNrZXJ7Zm9udC1zaXplOjEuMTRlbTtjb2xvcjojNzY3Njc2O2ZvbnQtd2VpZ2h0OjQwMH0vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnBpe2ZvbnQtc2l6ZToxZW19L2RlZXAvIC51aS10aW1lcGlja2VyIC5waS5waS1jaGV2cm9uLXVwOmJlZm9yZXtjb250ZW50OidcXFxcZTFmMCd9L2RlZXAvIC51aS10aW1lcGlja2VyIC5waS5waS1jaGV2cm9uLWRvd246YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWVmJ30vZGVlcC8gLnVpLXRpbWVwaWNrZXI+ZGl2e21hcmdpbi1sZWZ0OjB9L2RlZXAvIC51aS10aW1lcGlja2VyIC51aS1zZXBhcmF0b3J7d2lkdGg6LjFlbTttaW4td2lkdGg6LjFlbX0vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnVpLXNlcGFyYXRvciAucGl7Zm9udC1zaXplOjB9L2RlZXAvIC51aS1kYXRlcGlja2VyLXRyaWdnZXJ7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0vZGVlcC8gLnVpLWRhdGVwaWNrZXItdHJpZ2dlci51aS1idXR0b246ZW5hYmxlZDpob3ZlciwvZGVlcC8gLnVpLWRhdGVwaWNrZXItdHJpZ2dlci51aS1idXR0b246Zm9jdXN7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0vZGVlcC8gLmhhcy10aW1le2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6bm93cmFwfS9kZWVwLyAuaGFzLXRpbWUgcC1jYWxlbmRhcjpmaXJzdC1jaGlsZHt3aWR0aDo1NSU7bWFyZ2luLXJpZ2h0OjE0cHh9L2RlZXAvIC5oYXMtdGltZSBwLWNhbGVuZGFyOmxhc3QtY2hpbGR7d2lkdGg6NDUlfS9kZWVwLyAuaGFzLXRpbWUgcC1jYWxlbmRhcjpsYXN0LWNoaWxkIC51aS1kYXRlcGlja2Vye3BhZGRpbmc6MH0vZGVlcC8gLmhhcy10aW1lIC51aS1idXR0b24taWNvbi1sZWZ0e2xpbmUtaGVpZ2h0OjE4cHh9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIERBVEVUSU1FX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUFuZFRpbWVDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBEYXRlQW5kVGltZUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcblxuICAgIHN0YXRpYyByZWFkb25seSBOZ1RpbWUxMjogc3RyaW5nID0gJ2hoOm1tIGEnO1xuICAgIHN0YXRpYyByZWFkb25seSBOZ1RpbWUyNDogc3RyaW5nID0gJ0hILm1tIGEnO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlIHVzZWQgdG8gc2V0IHRoZSBkYXRlIGFuZCB0aW1lIHBpY2tlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IERhdGU7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IGRhdGUgZm9ybWF0IHBhdHRlcm4gdXNlZCBpZiBub25lIGlzIHBhc3NlZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JtYXRQYXR0ZXJuOiBzdHJpbmcgPSAnbW0vZGQveXknO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIHdvcmthcm91bmQgYXMgZm9ybWF0dGVycyBpbiB0aGUgcHJpbWVORyBhbmQgYW5ndWxhciBhcmUgZGlmZmVyZW50IHNvIHVudGlsIGl0c1xuICAgICAqIGZpeGVkIHdlIG5lZWQgdG8ga2VlcCB0aGlzIGV4dHJhIHBhdHRlcm4uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JtYXRQYXR0ZXJuTkc6IHN0cmluZyA9ICdNTS9kZC95eSc7XG5cblxuICAgIC8qKlxuICAgICAqIFNob3dzIGFuZCBoaWRlcyBuYXZpZ2F0aW9uIGJhciB3aXRoIHllYXIgYW5kIG1vbnRocyBzZWxlY3Rpb25zXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93TmF2aWdhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBZZWFyIHJhbmdlIGRpc3BsYXllZCBmb3IgdGhlIGRyb3AgZG93bi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHllYXJSYW5nZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYW5kIGhpZGVzIG5hdmlnYXRpb24gYmFyIHdpdGggeWVhciBhbmQgbW9udGhzIHNlbGVjdGlvbnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dJY29uOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aW1lcGlja2VyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93VGltZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgRGF0ZVBpY2tlci4gRXZlbiB3ZSBjYW4gaGlkZSBpdC4gaXQgc2hvdWxkIGJlIGZvciBtb3N0IG9mIHRoZSBjYXNlIGFsd2F5c1xuICAgICAqIHRydWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dEYXRlOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyB0aGUgZGF0ZSBwaWNrZXIgd2hhdCBmb3JtYXQgaXQgc2hvdWxkIHVzZSB3aGVuIHByZXNlbnRpbmcgdGltZS4gV2hlbiBob3VyRm9ybWF0IGlzIDEyLFxuICAgICAqIGl0IHNob3dzIHRoZSBBTSwgUE1cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaG91ckZvcm1hdDogc3RyaW5nID0gJzI0JztcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGV2ZW50IHdoZW4gc3BlY2lmaWMgZGF0ZSBpcyBjbGlja2VkIGluc2lkZSBEYXRlUGlja2VyXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBkYXRlIHRvIGhpZ2hsaWdodCBvbiBmaXJzdCBvcGVuaW5nIGlmIHRoZSBmaWVsZCBpcyBibGFuay5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlZmF1bHREYXRlOiBEYXRlID0gbmV3IERhdGUoKTtcblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugb2YgRGF0ZXRpbWUgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhlIERhdGVBbmRUaW1lIGZvcm1hdE5hbWUgaXMgbm90IHByb3BhZ2F0ZWRcbiAgICAgKiB0byBEYXRlIGZpZWxkLlxuICAgICAqL1xuICAgIGZvcm1hdE5hbWVXaXRoVGltZTogc3RyaW5nO1xuXG5cbiAgICBpMThuOiBhbnk7XG4gICAgdGltZVBsYWNlSG9sZGVyOiBzdHJpbmcgPSAnaGg6c3MnO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB0byBkYXRlVGltZSBwYXR0ZXJuIHdoaWNoIGlzIGRlZmluZWQgaW4gcmVzb3VyY2UgZmlsZXNcbiAgICAgICAgaWYgKHRoaXMuaG91ckZvcm1hdCAhPT0gJzEyJyAmJiB0aGlzLmhvdXJGb3JtYXQgIT09ICcyNCcpIHtcbiAgICAgICAgICAgIHRoaXMuaG91ckZvcm1hdCA9ICcyNCc7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRpbWVQbGFjZUhvbGRlciA9ICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicpID9cbiAgICAgICAgICAgIGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUxMn1gIDogYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTI0fWA7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUoKHZhbDogRGF0ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xuXG4gICAgICAgIHRoaXMuZW52Lm9uTG9jYWxlQ2hhbmdlLnN1YnNjcmliZSgobG9jYWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdFRyYW5zbGF0aW9ucygpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIHJlZmFjdG9yIHRoaXMgYXMgdGhpcyByZWFsbHkgZ2V0IGNvbXBsaWNhdGVkIHRyeWluZyB0byBjb3ZlciB1c2VjYXNlIHdpdGggdGltZVxuICAgICAqIGFuZCBkYXRlIGFuZCBldmVyeSBmb3JtYXQgd2UgaGF2ZS4gV2Ugc2hvdWxkIHByb2JhYmx5IGhhdmUgc2VwYXJhdGUgcGF0dGVybnMgZm9yXG4gICAgICogZGF0ZXMgb25seSBhbmQgZGF0ZSArIHRpbWVcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRUcmFuc2xhdGlvbnMoKSB7XG5cbiAgICAgICAgdGhpcy5mb3JtYXROYW1lV2l0aFRpbWUgPSB0aGlzLmZvcm1hdFBhdHRlcm47XG4gICAgICAgIGlmICghdGhpcy5zaG93RGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXR0ZXJuTkcgPSB0aGlzLmZvcm1hdFBhdHRlcm4gKz0gKHRoaXMuaG91ckZvcm1hdCA9PT0gJzEyJykgP1xuICAgICAgICAgICAgICAgIGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUxMn1gIDogYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTI0fWA7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNob3dUaW1lKSB7XG4gICAgICAgICAgICBsZXQgdGltZVN0YXJ0cyA9IHRoaXMuZm9ybWF0UGF0dGVybi5pbmRleE9mKCdoJyk7XG4gICAgICAgICAgICBpZiAodGltZVN0YXJ0cyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdE5hbWVXaXRoVGltZSA9IHRoaXMuZm9ybWF0UGF0dGVybi5zdWJzdHJpbmcoMCwgdGltZVN0YXJ0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBhdHRlcm5ORyArPSAodGhpcy5ob3VyRm9ybWF0ID09PSAnMTInKSA/XG4gICAgICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5pMThuID0ge1xuICAgICAgICAgICAgZmlyc3REYXlPZldlZWs6IDAsXG4gICAgICAgICAgICBkYXlOYW1lczogWydTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsXG4gICAgICAgICAgICAgICAgJ1NhdHVyZGF5J10sXG4gICAgICAgICAgICBkYXlOYW1lc1Nob3J0OiBbJ1N1bicsICdNb24nLCAnVHVlJywgJ1dlZCcsICdUaHUnLCAnRnJpJywgJ1NhdCddLFxuICAgICAgICAgICAgZGF5TmFtZXNNaW46IFsnUycsICdNJywgJ1QnLCAnVycsICdUJywgJ0YnLCAnUyddLFxuICAgICAgICAgICAgbW9udGhOYW1lczogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JyxcbiAgICAgICAgICAgICAgICAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXNTaG9ydDogWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLFxuICAgICAgICAgICAgICAgICdOb3YnLCAnRGVjJ11cbiAgICAgICAgfTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBkYXRlcyBjaGFuZ2VzLiBIZXJlIHdlIHVwZGF0ZSAgdGhpcy52YWx1ZSAtID4gZGF0ZSBhbmQgYWxzbyB1cGRhdGUgdmFsdWUgaW5zaWRlXG4gICAgICogZm9ybUNvbnRyb2xsZXJcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRGF0ZUNoYW5nZShldmVudDogYW55KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0aHJvdyBzb21lIGVycm9yID9cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsdWUgPSBpc0RhdGUoZXZlbnQpID8gZXZlbnQgOiBuZXcgRGF0ZShldmVudCk7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLnZhbHVlLCB7b25seVNlbGY6IGZhbHNlLCBlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2FsZW5kYXJNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RhdGVBbmRUaW1lQ29tcG9uZW50fSBmcm9tICcuL2RhdGUtYW5kLXRpbWUuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEYXRlQW5kVGltZUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdEYXRlQW5kVGltZU1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGRpYWxvZyBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIERpYWxvZ0NvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGlhbG9nLWhlYWRlcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBEaWFsb2dIZWFkZXJDb21wb25lbnRcbntcbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGlhbG9nIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGlhbG9nQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2ctZm9vdGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0Zvb3RlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtNb2RhbENvbnRhaW5lcn0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLWNvbnRhaW5lcic7XG5pbXBvcnQge0RpYWxvZ0hlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0Zvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctZm9vdGVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICogRGlhbG9nIENvbXBvbmVudCB0aGF0IHByb3ZpZGVzIHRoZSBsb29rIGFuZCBmZWVsIGZvciBhIG1vZGFsIGRpYWxvZy4gVGhpcyBjb21wb25lbnQgaGFzIHRocmVlXG4gKiBzZWN0aW9uczogaGVhZGVyLCBib2R5LCBhbmQgZm9vdGVyLiBJdCBjYW4gYmUgdXNlZCBieSBpdHNlbGYgb3IgZXh0ZW5kZWQuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxEaWFsb2dDb21wb25lbnQ+KSwgc2VydmljZS5jbG9zZSgpXG4gKlxuICogVXNhZ2U6XG4gKiAgICAxLiAgVXNpbmcgRGlhbG9nIGRpcmVjdGx5IHRvIGRpc3BsYXkgYSBtb2RhbCBwb3B1cC4gVGhpcyB1c2FnZSBpcyBhIHF1aWNrIHdheSB0byBzaG93IGFcbiAqIG1lc3NhZ2UgdG8gdGhlIHVzZXIuXG4gKlxuICogICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxEaWFsb2dDb21wb25lbnQ+KCBEaWFsb2dDb21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdNeSBQb3B1cCBUaXRsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICdNeSBQb3B1cCBCb2R5J1xuICogICAgICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZyBbKHZpc2libGUpXT1cImRpc3BsYXlcIiBbbW9kYWxdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25PcGVuKT1cIm9wZW5BY3Rpb24oKVwiIChvbkNsb3NlKT1cImNsb3NlQWN0aW9uKClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2ctaGVhZGVyPkRpYWxvZyBIZWFkZXI8L2F3LWRpYWxvZy1oZWFkZXI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlhbG9nIEJvZHk6IENyZWF0aW5nIGEgZGlhbG9nIHVzaW5nIHRoZSBkaWFsb2cgY29tcG9uZW50XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nLWZvb3Rlcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiBbc3R5bGVdPVwiJ3ByaW1hcnknXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJjbG9zZSgpXCI+T0s8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kaWFsb2ctZm9vdGVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRpYWxvZz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm9wZW4oKVwiPk9wZW4gRGlhbG9nPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15UGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBib29sZWFuID0gZmFsc2U7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBkaWFsb2dBY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW4oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gKiAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW5BY3Rpb24oKSAge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZ0FjdGlvbiA9IFwib3BlblwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgfVxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGlhbG9nJyxcbiAgICB0ZW1wbGF0ZTogYDxwLWRpYWxvZyBbaGVhZGVyXT1cInRpdGxlXCIgWyh2aXNpYmxlKV09XCJ2aXNpYmxlXCJcbiAgICAgICAgICBbbW9kYWxdPVwibW9kYWxcIiBbY2xvc2FibGVdPVwiY2xvc2FibGVcIiBbd2lkdGhdPVwid2lkdGhcIiBbaGVpZ2h0XT1cImhlaWdodFwiXG4gICAgICAgICAgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFthcHBlbmRUb109XCJhcHBlbmRUb1wiIChvblNob3cpPVwib3BlbigpXCIgKG9uSGlkZSk9XCJjbG9zZSgpXCI+XG5cbiAgICA8cC1oZWFkZXIgKm5nSWY9XCJoYXNIZWFkZXIoKVwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1kaWFsb2ctaGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvcC1oZWFkZXI+XG5cbiAgICB7e2JvZHl9fVxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblxuICAgIDxwLWZvb3RlciAqbmdJZj1cImhhc0Zvb3RlcigpXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkaWFsb2ctZm9vdGVyLXNlcGFyYXRvclwiPjwvZGl2PlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1kaWFsb2ctZm9vdGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvcC1mb290ZXI+XG48L3AtZGlhbG9nPlxuYCxcbiAgICBzdHlsZXM6IFtgOjpuZy1kZWVwIC51aS1kaWFsb2cgLnVpLWRpYWxvZy10aXRsZWJhcntiYWNrZ3JvdW5kLWNvbG9yOiNmMmYyZjI7cGFkZGluZzoxNXB4IDIwcHh9OjpuZy1kZWVwIC51aS1kaWFsb2cgLnVpLWRpYWxvZy10aXRsZWJhciAudWktZGlhbG9nLXRpdGxlYmFyLWljb246aG92ZXJ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fTo6bmctZGVlcCAudWktd2lkZ2V0LWhlYWRlcntmb250LXdlaWdodDo0MDA7Zm9udC1zaXplOjE2cHh9OjpuZy1kZWVwIC51aS1kaWFsb2cgLnVpLWRpYWxvZy1jb250ZW50e3BhZGRpbmc6MTVweCAyMHB4O2xpbmUtaGVpZ2h0OjEuM2VtfTo6bmctZGVlcCAudWktZGlhbG9nIC51aS13aWRnZXQtY29udGVudHtib3JkZXI6bm9uZX06Om5nLWRlZXAgLnVpLWRpYWxvZy51aS13aWRnZXQtY29udGVudHtib3JkZXI6bm9uZTtib3gtc2hhZG93OjAgMnB4IDEwcHggMCByZ2JhKDAsMCwwLC4zKX06Om5nLWRlZXAgLnVpLWRpYWxvZyAuZGlhbG9nLWZvb3Rlci1zZXBhcmF0b3J7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkNztoZWlnaHQ6MTRweH06Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLWZvb3RlcntwYWRkaW5nOjAgMjBweCAxNXB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0NvbXBvbmVudCBleHRlbmRzIE1vZGFsQ29udGFpbmVyXG57XG4gICAgLyoqXG4gICAgICogVGl0bGUgZm9yIHRoZSBEaWFsb2cuICBpZiB0aXRsZSBhbmQgJ1RpdGxlVGVtcGxhdGUnIGFyZSBib3RoIHNldCwgdGl0bGVUZW1wbGF0ZSB0YWtlc1xuICAgICAqIHByZWNlZGVuY2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQm9keSBzZWN0aW9uIGZvciBEaWFsb2cuIENhbGxlciBzaG91bGQgdXNlIGVpdGhlciB0aGUgYm9keSBzdHJpbmcsIG9yIGNvbnRlbnQgcHJvamVjdGlvblxuICAgICAqIHRvIGFkZCB2YWx1ZXMgdG8gdGhlIGRpYWxvZy4gSWYgYm90aCBhcmUgdXNlZCwgdGhleSB3aWxsIGJvdGggc2hvdyB1cC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHk6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBzdXBwb3J0IHR3byB3YXkgZGF0YSBiaW5kaW5nIG9uIHZpc2libGUgcHJvcGVydHkuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiB3aGV0aGVyIHRoaXMgZGlhbG9nIGJsb2NrcyB0aGUgcmVzdCBvZiB0aGUgcGFnZSBvciBub3Qgd2hlbiBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtb2RhbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZXJlJ3MgYW4geCBhdCB0aGUgdG9wIHJpZ2h0IHRoYXQgbWFrZXMgdGhlIGRpYWxvZyBjbG9zYWJsZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNsb3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZGlhbG9nLiBcImJvZHlcIiBvciBsb2NhbCBuZy10ZW1wbGF0ZSB2YXJpYWJsZSBhcmUgdmFsaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRUbzogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBkaWFsb2cgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgZGlhbG9nIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGNvbXBvbmVudC4gVXN1YWxseSBjb250YWlucyB0aGUgdGl0bGUuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChEaWFsb2dIZWFkZXJDb21wb25lbnQpIGhlYWRlcjogRGlhbG9nSGVhZGVyQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogRGlhbG9nIGZvb3Rlci4gVXN1YWxseSBjb250YWlucyBidXR0b25zXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChEaWFsb2dGb290ZXJDb21wb25lbnQpIGZvb3RlcjogRGlhbG9nRm9vdGVyQ29tcG9uZW50O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IDMwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnYXV0byc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGlzIGRpYWxvZy5cbiAgICAgKi9cbiAgICBvcGVuKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcblxuICAgICAgICAvLyB2aXNpYmxlIGlzIGEgMi13YXkgYmluZGluZyB2YXJpYWJsZS5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgdGhlIGRpYWxvZ1xuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuXG4gICAgICAgIC8vIEltcG9ydGFudCB0byBtYWtlIHN1cmUgY2hhbmdlIGlzIHNldCBvbiBwYXJlbnQgYmluZGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFyaWFibGUgYW5kIGRpYWxvZyBvcGVuL2Nsb3NlIHN0YXRlIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2Ygc3luYyBhbmQgd2Ugd291bGRuJ3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIGRpYWxvZyBoYXZlIGhlYWRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0hlYWRlcigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuaGVhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgZGlhbG9nIGhhdmUgZm9vdGVyLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzRm9vdGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5mb290ZXIpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7RGlhbG9nQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy5jb21wb25lbnQnO1xuaW1wb3J0IHtEaWFsb2dIZWFkZXJDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEaWFsb2dGb290ZXJDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLWZvb3Rlci5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RhbENvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ01vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0Zvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgRGlhbG9nTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgTW9kYWxDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dGb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0Zvb3RlckNvbXBvbmVudCxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXRGlhbG9nTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBTa2lwU2VsZixcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBFbnZpcm9ubWVudCxcbiAgICBlcXVhbHMsXG4gICAgRmllbGRQYXRoLFxuICAgIGlzQXJyYXksXG4gICAgaXNCbGFuayxcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzUHJlc2VudCxcbiAgICBMaXN0V3JhcHBlclxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q2hvb3NlclNlbGVjdGlvblN0YXRlfSBmcm9tICcuLi9jaG9vc2VyL2Nob29zZXItc2VsZWN0aW9uLXN0YXRlJztcbmltcG9ydCB7Q2hvb3NlclN0YXRlfSBmcm9tICcuLi9jaG9vc2VyL2Nob29zZXItc3RhdGUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Q2hvb3NlckRhdGFTb3VyY2V9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RBVEFfU09VUkNFfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcblxuXG4vKipcbiAqIENvbnZlbmllbnQgd3JhcHBlciBjbGFzcyBhcm91bmQgY29udHJvbHMgc3VjaCBhcyByYWRpb2J1dHRvbnMsIGRyb3Bkb3duLCBjaGVja2JveGVzLFxuICogQ2hvb3Nlci4gVGhlIHR5cGUgb2YgdGhlIGNob29zZXIgbWF5IGJlIGRldGVybWluZWQgZHluYW1pY2FsbHkgYmFzZWQgb24gdGhlIG51bWJlciBvZiBpdGVtcyBpblxuICogdGhlIGRhdGEgc291cmNlIGxpc3QsIG9yIGNhbiBiZSBzcGVjaWZpZWQgZXhwbGljaXRseSB2aWEgdGhlIFwidHlwZVwiIGJpbmRpbmcuXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZ2VuZXJpYy1jaG9vc2VyJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgW25nU3dpdGNoXT1cInR5cGVcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdTd2l0Y2hDYXNlXT1cIidDaGVja2JveCdcIj5cbiAgICAgICAgPGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwibGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25zXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxGb3JtYXR0ZXJdPVwiZGlzcGxheVZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uU2VsZWN0aW9uKCRldmVudClcIj5cbiAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdTd2l0Y2hDYXNlXT1cIidSYWRpbydcIj5cbiAgICAgICAgPGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwibGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtsYWJlbEZvcm1hdHRlcl09XCJkaXNwbGF5VmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPlxuICAgICAgICA8L2F3LXJhZGlvYnV0dG9uLWxpc3Q+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdTd2l0Y2hDYXNlXT1cIidEcm9wZG93bidcIj5cbiAgICAgICAgPGF3LWRyb3Bkb3duIFtsaXN0XT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgW25vU2VsZWN0aW9uU3RyaW5nXT1cIm5vU2VsZWN0aW9uU3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgI2l0ZW1UZW1wbGF0ZSBsZXQtaXRlbT5cblxuICAgICAgICAgICAgICAgIDwhLS0gdG9kbzogYWxsb3cgdG8gcGFzcyBhIFBJUEUgdG8gZG8gc29tZSBhZGRpdGlvbmFsIGZvcm1hdHRpbmcgLS0+XG4gICAgICAgICAgICAgICAge3sgZGlzcGxheVZhbHVlKGl0ZW0udmFsdWUpIH19XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2F3LWRyb3Bkb3duPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdTd2l0Y2hDYXNlXT1cIidDaG9vc2VyJ1wiPlxuICAgICAgICA8YXctY2hvb3NlciAjY2hvb3NlclxuICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIFttdWx0aXNlbGVjdF09XCJtdWx0aXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgIFtkYXRhU291cmNlXT1cImRhdGFTb3VyY2VcIlxuICAgICAgICAgICAgICAgICAgICBbdmFsdWVUcmFuc2Zvcm1lcl09XCJkaXNwbGF5VmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cblxuICAgICAgICA8L2F3LWNob29zZXI+XG5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG48L25nLWNvbnRhaW5lcj5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50KX0sXG4gICAgICAgIHtwcm92aWRlOiBEQVRBX1NPVVJDRSwgdXNlQ2xhc3M6IENob29zZXJEYXRhU291cmNlLCBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljQ2hvb3NlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBPcmRlcmVkIGxpc3Qgb2YgaXRlbXMgYXNzaWduYWJsZSB0byB0aGUga2V5IG9mIHRoZSBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9iamVjdCB0aGlzIGNvbnRyb2wgaXMgYmVpbmcgYXNzaWduZWQgdG8uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3Q6IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGtleSBmaWVsZCBwYXRoIHRoaXMgY29udHJvbCBpcyBiZWluZyBhc3NpZ25lZCB0by5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGtleTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCBpbiBwbGFjZSBvZiBMSVNUIGJpbmRpbmcgdG8gcmV0cmlldmUgYSBsaXN0IGJhc2VkIG9uIHRoZSBDaG9pY2VTb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGVzdGluYXRpb25DbGFzczogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHdoZW4gcmV0cmlldmluZyBjaG9pY2VTb3VyY2UgYnkgZGVzdGluYXRpb24gY2xhc3MgYW5kIHRoaXMgYXJlIGV4dHJhIHBhcmFtcyB0aGF0IGNhbiBiZVxuICAgICAqIHVzZWQgdG8gbmFycm93IHRoZSBtYXRjaGluZyBvciB0byBwYXNzIHBhcmFtZXRlcnMgaW50byBDaG9pY2VTb3VyY2UgcHJvdmlkZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNob2ljZVByb3ZpZGVyUGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiAgSXMgdGhpcyBhIExpc3QgcHJvcGVydHksIG9yIGEgdG8tb25lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqICBUaGUgc3R5bGUgb2YgY2hvb3NlciB0byB1c2UgKFJhZGlvLCBDaGVja2JveCwgRHJvcGRvd24sIENob29zZXIpXG4gICAgICogIERlZmF1bHRzIGJhc2VkIG9uIGNhcmRpbmFsaXR5IG9mIHRoZSBsaXN0IGFuZCB3aGV0aGVyIGl0J3MgbXVsdGlTZWxlY3QuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0IGN1c3RvbSBrZXkuIGluIG9yZGVyIHRvIG1ha2UgdGhpcyB3b3JrIHdlIG5lZWQgdG8gaW50cm9kdWNlIGN1c3RvbSA8dGVtcGxhdGVzPiBmb3JcbiAgICAgKiBhbGwgdGhpcyBjaG9vc2VyIHR5cGVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNwbGF5S2V5OiBzdHJpbmc7XG5cbiAgICAvLyAvKipcbiAgICAvLyAgKiAgU2hvdWxkIHdlIGF0dGVtcHQgYSBtYXRjaCBhcyB0aGV5IHR5cGUgKGFnYWluc3QgdGhlIGZ1bGwgbGlzdClcbiAgICAvLyAgKi9cbiAgICAvLyBASW5wdXQoKVxuICAgIC8vIGFsbG93RnVsbE1hdGNoT25JbnB1dDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZW5kZXJlZCBhcyBmaXJzdCB2YWx1ZSBpbiB0aGUgZHJvcGRvd24gd2hpY2ggbGV0IHRoZSB1c2VyIHRvIG1ha2UgJ25vIHNlbGVjdGlvbidcbiAgICAgKiBmcm9tIGF2YWlsYWJsZSBsaXN0IG9mIHZhbHVlcy4gV2hlbiB0aGlzIG9wdGlvbiBpcyBhY3RpdmUgYW5kIHVzZSBtYWtlIHRoaXMgc2VsZWN0aW9uIHdlXG4gICAgICogc2F2ZSBhIE5VTEwgdmFsdWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vU2VsZWN0aW9uU3RyaW5nOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEdlbmVyaWMgQ2hvb3NlciB3b3JrcyBkaXJlY3RseSB3aXRoIG9iamVjdCBhbmQgaXRzIHJlZmVyZW5jZXMgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoaXNcbiAgICAgKiBrZXlwYXRoIHRvIGJlIGFibGUgdG8gc2V0L2dldCB2YWx1ZSBmcm9tIHRhcmdldCBvciBwYXJlbnQgb2JqZWN0XG4gICAgICovXG4gICAga2V5UGF0aDogRmllbGRQYXRoO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KERBVEFfU09VUkNFKSBwdWJsaWMgZGF0YVNvdXJjZTogQ2hvb3NlckRhdGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5vYmplY3QpKSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9ICg8YW55PnRoaXMuX3ZpZXdDb250YWluZXIuaW5qZWN0b3IpLnZpZXcuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtleVBhdGggPSBuZXcgRmllbGRQYXRoKHRoaXMua2V5KTtcbiAgICAgICAgbGV0IGRlZmF1bHREYXRhUHJvdmlkZXIgPSBudWxsO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFQcm92aWRlciA9IHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXJzLmZpbmQodGhpcy5saXN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHREYXRhUHJvdmlkZXIgPSB0aGlzLmRhdGFTb3VyY2UuZGF0YVByb3ZpZGVycy5maW5kKHRoaXMuZGVzdGluYXRpb25DbGFzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcHJvamVjdGVkU2l6ZSA9IGRlZmF1bHREYXRhUHJvdmlkZXIuZXhwZWN0ZWRDb3VudCh0aGlzLmNob2ljZVByb3ZpZGVyUGFyYW1zKTtcbiAgICAgICAgdGhpcy5pbml0VHlwZShwcm9qZWN0ZWRTaXplKTtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnQ2hvb3NlcicpIHtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICAgICAgICAgICAgICAgIGRhdGFQcm92aWRlcjogZGVmYXVsdERhdGFQcm92aWRlcixcbiAgICAgICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAgICAgICAgICAgICAgICBsb29rdXBLZXk6IHRoaXMuZGlzcGxheUtleSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogbmV3IENob29zZXJTdGF0ZShuZXcgR0NDaG9vc2VyU3RhdGUodGhpcyksIHRoaXMubXVsdGlzZWxlY3QpLFxuICAgICAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gZG8gd2UgbmVlZCB0byByZWFkIHRoaXMgdmFsdWUgaW4gYXN5bmM/XG4gICAgICAgICAgICB0aGlzLmxpc3QgPSBkZWZhdWx0RGF0YVByb3ZpZGVyLmRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcXVpcmVkKCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAvLyB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nID0gdGhpcy5pMThuLmluc3RhbnQoJ1dpZGdldHMuZ2Nob29zZXIubm9TZWxTdHJpbmcnKTtcbiAgICAgICAgICAgIHRoaXMubm9TZWxlY3Rpb25TdHJpbmcgPSAnU2VsZWN0IGEgSXRlbSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gQElucHV0IHR5cGUgaXMgbm90IHBhc3NlZCB3ZSB0cnkgdG8gZ3Vlc3MgYW5kIHNlbGVjdCB0aGUgYmVzdCB0eXBlIGZvciBjdXJyZW50IGRhdGFcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdFR5cGUocHJvamVjdGVkU2l6ZTogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy50eXBlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAocHJvamVjdGVkU2l6ZSA8PSAwIHx8IHByb2plY3RlZFNpemUgPiA4KSA/ICdDaG9vc2VyJyA6ICdDaGVja2JveCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IChwcm9qZWN0ZWRTaXplIDw9IDAgfHwgcHJvamVjdGVkU2l6ZSA+IDIwKSA/ICdDaG9vc2VyJ1xuICAgICAgICAgICAgICAgICAgICA6IChwcm9qZWN0ZWRTaXplIDwgNikgPyAnUmFkaW8nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdEcm9wZG93bic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBhcmUgY2VydGFpbiBwcm9wZXJ0aWVzIHdoaWNoIGFyZSByZXF1aXJlZCBieSB0aGlzIGNvbXBvbmVudC4gQXMgYWxyZWFkeSBtZW50aW9uZWRcbiAgICAgKiBhYm92ZSBHZW5lcmljQ2hvb3NlciB3b3JrcyB3aXRoIHJlZmVyZW5jZXMgYW5kIHRoZWZvcmUgdHdvIGtleSBwcm9wZXJ0aWVzIGFyZSBvYmplY3QgYW5kIGtleVxuICAgICAqIHNvIHdlIGNhbiBhY2Nlc3MgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgdmFsaWRhdGVSZXF1aXJlZCgpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBhIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5rZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNvbnRpbnVlIHdpdGhvdXQgYSBrZXkgYmluZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMubGlzdCkgJiYgaXNCbGFuayh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNvbnRpbnVlIHdpdGhvdXQgaGF2aW5nIGVpdGhlciBsaXN0IG9mIHZhbHVlcyBvciBkZXN0aW5hdGlvbkNsYXNzJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KFxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSkgJiZcbiAgICAgICAgICAgICh0aGlzLnR5cGUgIT09ICdSYWRpbycgJiYgdGhpcy50eXBlICE9PSAnQ2hlY2tib3gnICYmIHRoaXMudHlwZSAhPT0gJ0Ryb3Bkb3duJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSAhPT0gJ0Nob29zZXInKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBpbnN0YW50aWF0ZSBHZW5lcmljQ2hvb3NlciAgLSBpbnZhbGlkIHR5cGUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGlzcGxheUtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheUtleSA9ICd0b1N0cmluZyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgd2hlbiBkaXNwbGF5aW5nIHZhbHVlIGJvdGggZnJvbSBwcmltaXRpdmUgdHlwZSBhcyB3ZWxsIGNvbXBsZXggb2JqZWN0LiBJZiB5b3Ugd2FudCB0b1xuICAgICAqIGNvbnRyb2wgaG93IGl0ZW0gaXMgZGlzcGxheWVkIHlvdSBjYW4gcHJvdmlkZSBkaXNwbGF5IGtleSwgd2hpY2ggaXMgY2FuIGJlIGEgIG1ldGhvZCBvclxuICAgICAqIHByb3BlcnR5IG9mIHRoZSBvYmplY3QgeW91IGFyZSBkaXNwbGF5aW5nLlxuICAgICAqXG4gICAgICogVG9kbzogdGhpbmsgYWJvdXQgZm9ybWF0dGVycyBhcyB3ZWxsXG4gICAgICpcbiAgICAgKi9cbiAgICBkaXNwbGF5VmFsdWUoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRpc3BsYXlLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRWYWx1ZSA9IEZpZWxkUGF0aC5nZXRGaWVsZFZhbHVlKGl0ZW0sIHRoaXMuZGlzcGxheUtleSk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGZpZWxkVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmllbGRWYWx1ZS5jYWxsKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWVsZFZhbHVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFJldHJpZXZlIGEgY3VycmVudCB2YWx1ZSBmcm9tIHRoZSBwYXJlbnQvdGFyZ2V0IG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleVBhdGguZ2V0RmllbGRWYWx1ZSh0aGlzLm9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHNldCB2YWx1ZSBiYWNrIHRvIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHNldCBzZWxlY3Rpb24odmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMua2V5UGF0aC5zZXRGaWVsZFZhbHVlKHRoaXMub2JqZWN0LCB2YWx1ZSk7XG4gICAgfVxuXG5cbiAgICBvblNlbGVjdGlvbih2YWx1ZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSgpO1xuXG4gICAgfVxufVxuXG4vKipcbiAqIEdlbmVyaWNDaG9vc2VyIGltcGxlbWVudGF0aW9uIG9mIHRoZSBDaG9vc2VyU2VsZWN0aW9uU3RhdGUgd2hpY2ggaXMgdXNlZCB3aGVuIFR5cGUgPSBDaG9vc2VyLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEdDQ2hvb3NlclN0YXRlIGV4dGVuZHMgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGdDaG9vc2VyOiBHZW5lcmljQ2hvb3NlckNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkID09PSB0aGlzLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QpIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIGltcGxlbWVudCBzbWFydGVyIGFuZCBtb3JlIGdlbmVyaWMgd2F5IGhvdyB3ZSB1c2UgaXQgaW4gamF2YVxuICAgICAgICAgICAgLy8gUmVsYXRpb25zaGlwRmllbGQuYWRkVG8oX29iamVjdCwgX2tleVBhdGgsIHNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGxldCBtdWx0aVJlbDogQXJyYXk8YW55PiA9IHRoaXMuZ0Nob29zZXIua2V5UGF0aC5nZXRGaWVsZFZhbHVlKHRoaXMuZ0Nob29zZXIub2JqZWN0KTtcbiAgICAgICAgICAgIGlmIChpc0JsYW5rKG11bHRpUmVsKSkge1xuICAgICAgICAgICAgICAgIG11bHRpUmVsID0gW107XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KG11bHRpUmVsKSAmJiAhaXNBcnJheShtdWx0aVJlbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0kgY2FuIG5vdCBzdG9yZSBtdWx0aXNlbGVjdCB2YWx1ZSBpbnRvIG5vbi1hcnJheSBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlSZWwucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uID0gbXVsdGlSZWw7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlSWZFeGlzdChtdWx0aVJlbCwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIGxldCBvYmplY3RzID0gdGhpcy5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICAgICAgICAgIHJldHVybiAoaXNCbGFuayhvYmplY3RzKSB8fCBMaXN0V3JhcHBlci5pc0VtcHR5KG9iamVjdHMpKSA/IG51bGwgOiBMaXN0V3JhcHBlci5sYXN0KFxuICAgICAgICAgICAgICAgIG9iamVjdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiA9IHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uO1xuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCAmJiBpc0JsYW5rKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCAmJiBpc0FycmF5KHNlbGVjdGlvbikpID8gc2VsZWN0aW9uIDogW3NlbGVjdGlvbl07XG4gICAgfVxuXG4gICAgaXNTZWxlY3RlZChzZWxlY3Rpb246IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gTGlzdFdyYXBwZXIuY29udGFpbnNDb21wbGV4KHRoaXMuc2VsZWN0ZWRPYmplY3RzKCksIHNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1clZhbHVlID0gdGhpcy5zZWxlY3RlZE9iamVjdCgpO1xuICAgICAgICByZXR1cm4gZXF1YWxzKGN1clZhbHVlLCBzZWxlY3Rpb24pO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqIFdyYXBwZXIgY2xhc3MgZm9yIFJhZGlvQnV0dG9uIGNvbXBvbmVudCBwcm92aWRpbmcgY29udmVuaWVudCB3YXkgdG8gdG8gcmVuZGVyIFJhZGlvQnV0dG9uIEdyb3Vwc1xuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqXG4gKiBgYGBcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ2dlbmRlci1zZWxlY3RvcicgLFxuICogICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24tbGlzdCBbbGlzdF09XCJyYkxpc3RWYWx1ZXNcIiBbbGF5b3V0XT1cImxheW91dFwiXG4gKiAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3RlZFZhbHVlXCIgW25hbWVdPVwiJ25hbWUnXCI+XG4gKiAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAqICAgICAgYFxuICogICAgICB9KVxuICogICAgICBleHBvcnQgY2xhc3MgR2VuZGVyU2VsZWN0b3JDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgcmJMaXN0VmFsdWVzOiBzdHJpbmdbXSA9IFsnbWFsZScgLCAnZmVtYWxlJyAsICdvdGhlciddO1xuICogICAgICAgICAgc2VsZWN0ZWRWYWx1ZTogc3RyaW5nID0gJ290aGVyJztcbiAqICAgICAgICAgIGxheW91dDogc3RyaW5nID0gJ3N0YWNrZWQnO1xuICpcbiAqXG4gKiAgICAgICAgICBmb3JtR3JvdXA6IEZvcm1Hcm91cCA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICpcbiAqXG4gKiAgICAgICAgICBvbkNCQ2xpY2sgKGV2ZW50KTogdm9pZFxuICogICAgICAgICAge1xuICogICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNCQ2xpY2sgPSAnICsgZXZlbnQpO1xuICogICAgICAgICAgfVxuICpcbiAqICAgICAgfVxuICpcbiAqIGBgYFxuICovXG5cblxuZXhwb3J0IGNvbnN0IFJCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yYWRpb2J1dHRvbi1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nRm9yPVwibGV0IGl0ZW0gb2YgbGlzdDsgIGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInVpLWdcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyXCI+XG4gICAgICAgIDxhdy1yYWRpb2J1dHRvblxuICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICBbdmFsdWVdPVwiaVwiXG4gICAgICAgICAgICBbbGFiZWxdPVwibGFiZWxWYWx1ZShpdGVtKVwiPlxuICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBSQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBMSXN0IG9mIHZhbHVlcyB1c2VkIHRvIHJlbmRlciB0aGUgcmFkaW8gYnV0dG9uIGdyb3VwXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZmllcyB3aGljaCByYWRpbyBidXR0b25zIGlzIHNlbGVjdGVkIHdoZW4gcmVuZGVyZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbjogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBzcGVjaWFsIGV4cHJlc3Npb24gdG8gZm9ybWF0IGxhYmVsXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbEZvcm1hdHRlcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlcyBhbiBldmVudCB3aGVuIHJhZGlvIGJ1dHRvbiBpcyBzZWxlY3RlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIG1vZGVsIHRvIGxpc3RlbiBmb3IgcmFkaW8gdmFsdWUgY2hhbmdlc1xuICAgICAqXG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIGlzIGV4dHJhY3RlZCBpbnRvIGEgbWV0aG9kIHNvIGluIHRoZSBmdXR1cmUgd2UgY2FuIHBsYXkgaG93IHdlIHdhbnQgdG8gZGlzcGxheSB0aGVcbiAgICAgKiB2YWx1ZS4gU2luY2UgSSB3YW50IHRvIHN1cHBvcnQgZm9ybWF0dGVycyBmb3IgZWFjaCBjb21wb25lbnRzIHdlIG1pZ2h0IGhhdmUgYSBjaGFuY2UgdG9cbiAgICAgKiBkZWNpZGUgaG93IHRoZSBsYWJlbCB3aWxsIGxvb2sgbGlrZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGxhYmVsVmFsdWUoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGFiZWxGb3JtYXR0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbEZvcm1hdHRlcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyB2ZXJzaW9uIG9mIGNoZWNrYm94ZXMgd2Ugc3RpbGwgZXhwZWN0IG9ubHkgcHJpbWl0aXZlIHR5cGVzLiBLZWVwIHRoaXMgZnVuY3Rpb25hbGl0eVxuICAgICAqIGluIGV4dHJhIG1ldGhvZCBzbyB3ZSBjYW4gd29yayB3aXRoIGl0IGV2ZW4gbm93IHdlIGp1c3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2tcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgdmFsdWUoaXRlbTogYW55KTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT24gTkdNb2RlbCBjaGFuZ2UgcmV0cmlldmUgYWN0dWFsIHJlY29yZCBiYXNlZCBvbiB0aGUgSU5ERVggYW5kIHByb3BhZ2F0ZSBpdCB0byBib3RoXG4gICAgICogbmdNb2RlbCBhcyB3ZWxsIGFzIEZvcm1Hcm91cC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnkgPSB0aGlzLmxpc3RbdGhpcy5tb2RlbF07XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggY29tcGxleCBvYmplY3Qgc3RvcmUgb25seSBJTkRFWCBudW1iZXIgaW4gdGhlIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlTW9kZWwoc291Y2VJdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxpc3QuZmluZEluZGV4KChlbGVtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VjZUl0ZW0gPT09IGVsZW07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1vZGVsID0gaW5kZXggPT09IC0xID8gMCA6IGluZGV4O1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnkgPSB0aGlzLmxpc3RbdGhpcy5tb2RlbF07XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodXBkYXRlZE1vZGVsLCB7XG4gICAgICAgICAgICBlbWl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBuZXdNb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlbChuZXdNb2RlbCk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEhUTUwgcmFkaW8gYnV0dG9uIG9uIHRvcCBvZiBQcmltZU5HIHdpdGggYXJpYmEgc3R5bGluZ1xuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogMS4gQmFzaWMgdXNhZ2UgdXNpbmcgbmdNb2RlbCBwcmUtc2VsZWN0ZWQgZmlyc3QgcmFkaW9cbiAqXG4gKiAgYGBgdHNcbiAqXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdkZW1vLWNvbXAnLFxuICogICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ2NvbG9yJ1wiIFt2YWx1ZV09XCIncmVkJ1wiIFtsYWJlbF09XCInUmVkJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ2NvbG9yJ1wiIFt2YWx1ZV09XCInYmx1ZSdcIiBbbGFiZWxdPVwiJ0JsdWUnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICogICAgICBgXG4gKiAgICAgIH0pKlxuICogICAgICBjbGFzcyBCYXNpY1dpdGhOZ01vZGVsQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIG1vZGVsOiBzdHJpbmdbXSA9IFsncmVkJ107XG4gKlxuICogICAgICAgICAgY29uc3RydWN0b3IoKVxuICogICAgICAgICAge1xuICogICAgICAgICAgfVxuICogICAgICB9XG4gKlxuICogIGBgYFxuICpcbiAqXG4gKiAyLiBCYXNpYyB1c2FnZSB3aXRoIGZvcm1Hcm91cFxuICpcbiAqXG4gKiBgYGB0c1xuICogICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgc2VsZWN0b3I6ICdkZW1vLWNvbXAnLFxuICogICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICA8ZGl2IFtmb3JtR3JvdXBdPVwiZW52LmN1cnJlbnRGb3JtXCI+XG4gKiAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3IyJ1wiIFt2YWx1ZV09XCIncmVkJ1wiIFtsYWJlbF09XCInUmVkJ1wiXG4gKiAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKiAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3IyJ1wiIFt2YWx1ZV09XCInYmx1ZSdcIiBbbGFiZWxdPVwiJ0JsdWUnXCJcbiAqICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqXG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICAgIGBcbiAqICAgICAgIH0pXG4gKiAgICAgICBjbGFzcyBCYXNpY1dpdGhGb3JtR3JvdXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXRcbiAqICAgICAgIHtcbiAqICAgICAgICAgICBtb2RlbDogc3RyaW5nID0gJ2JsdWUnO1xuICpcbiAqICAgICAgICAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICBuZ09uSW5pdCgpOiB2b2lkXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgICB0aGlzLmVudi5jdXJyZW50Rm9ybSA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICogICAgICAgICAgICAgICB0aGlzLmVudi5jdXJyZW50Rm9ybS5yZWdpc3RlckNvbnRyb2woJ2NvbG9yMicsIG5ldyBGb3JtQ29udHJvbCh0aGlzLm1vZGVsKSk7XG4gKiAgICAgICAgICAgfVxuICpcbiAqXG4gKiAgICAgICAgICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgIHRoaXMubW9kZWxTZXQgPSBldmVudDtcbiAqICAgICAgICAgICB9XG4gKlxuICogICAgICAgfVxuICogIGBgYGBcbiAqXG4gKlxuICpcbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBSQUJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJhZGlvYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwidy1yYWRpb2J1dHRvblwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlIFwiPlxuICAgICAgICA8cC1yYWRpb0J1dHRvbiBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cInZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsXT1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cIm9uTW9kZWxDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LXZhbGlkYXRpb24tZXJyb3JdPVwiIShmb3JtQ29udHJvbC52YWxpZCB8fCAoZm9ybUNvbnRyb2wucHJpc3RpbmUpKVwiPlxuICAgICAgICA8L3AtcmFkaW9CdXR0b24+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvc3Bhbj5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudy1yYWRpb2J1dHRvbiAudWktcmFkaW9idXR0b24tYm94e3dpZHRoOjIzcHg7aGVpZ2h0OjIzcHg7bGluZS1oZWlnaHQ6MjNweH0vZGVlcC8gLnctcmFkaW9idXR0b24gLnVpLXJhZGlvYnV0dG9uLWljb257Zm9udC1zaXplOjEuNWVtO2xpbmUtaGVpZ2h0OjFlbX1gXSxcblxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBSQUJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkNvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgcmFkaW9cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgcmFkaW9cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgY2xpY2sgZXZlbnQgd2l0aCBjdXJycmVudCBzZWxlY3RlZCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbCB0byBjb211bmljYXRlIHdpdGggcHJpbWVOZyBSYWRpb1xuICAgICAqL1xuICAgIG1vZGVsOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yIChwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCAoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcmFkaW8gaXMgY2xpY2tlZC4gTm90IHVzaW5nIFByaW1lTkcgY2xpY2sgZXZlbnQgYXMgaXQgaXMgZmlyZWQgYmVmb3JlXG4gICAgICogdGhlIG1vZGVsIGlzIGNoYW5nZWQuIFRoZXJlZm9yZSBuZWVkIHRvIGxpc3RlbiBvbiAobmdNb2RlbENoYW5nZSlcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTW9kZWxDaGFuZ2UgKG5ld1ZhbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQodGhpcy5tb2RlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUgKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMubW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1JhZGlvQnV0dG9uQ29tcG9uZW50fSBmcm9tICcuL3JhZGlvLWJ1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSYWRpb0J1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBSYWRpb0J1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1JhZGlvQnV0dG9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtSYWRpb0J1dHRvbkxpc3RDb21wb25lbnR9IGZyb20gJy4vcmFkaW8tYnV0dG9uLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0dlbmVyaWNDaG9vc2VyQ29tcG9uZW50fSBmcm9tICcuL2dlbmVyaWMtY2hvb3Nlci5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TGlzdE1vZHVsZX0gZnJvbSAnLi4vY2hlY2stYm94LWxpc3QvY2hlY2stYm94LWxpc3QubW9kdWxlJztcbmltcG9ydCB7QVdDaG9vc2VyTW9kdWxlfSBmcm9tICcuLi9jaG9vc2VyL2Nob29zZXIubW9kdWxlJztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbkxpc3RNb2R1bGV9IGZyb20gJy4uL3JhZGlvLWJ1dHRvbi1saXN0L3JhZGlvLWJ1dHRvbi1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXRHJvcGRvd25Nb2R1bGV9IGZyb20gJy4uL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgR2VuZXJpY0Nob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TGlzdE1vZHVsZSxcbiAgICAgICAgQVdDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBHZW5lcmljQ2hvb3NlckNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdHZW5lcmljQ2hvb3Nlck1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7RW50aXR5LCBpc0JsYW5rLCBpc0VudGl0eSwgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPdXRsaW5lRm9yQ29tcG9uZW50LCBPdXRsaW5lTm9kZX0gZnJvbSAnLi9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuXG4vKipcbiAqIE91dGxpbmVTdGF0ZSBpcyB0aGUga2V5IGdsdWluZyBwYXJ0IGZvciB0aGUgT3V0bGluZUZvciBhbmQgT3V0bGluZUNvbnRyb2xsZXIgY29tcG9uZW50cy4gSXRcbiAqIGhvbGRzIGFsbCBpbXBvcnRhbnQgaW5mb3JtYXRpb24gZm9yIHRoZSBjdXJyZW50IG91dGxpbmUgdHJlZSBhbmQgbWFuYWdlcyBleHBhbnNpb24gc3RhdGVzIGluIGZvcm1cbiAqIG9mIHNvIGNhbGxlZCBleHBhbnNpb25QYXRoIGFuZCBleHBhbnNpb25TdGF0ZXNcbiAqXG4gKiBXZSBuZWVkIHRvIGhhdmUgYSB3YXkgaG93IHRvIHdvcmsgd2l0aCBnZW5lcmljIGRhdGEgc3RydWN0dXJlIGluIG9yZGVyIG5vdCB0byBob2xkIFVJIHNwZWNpZmljXG4gKiBpbmZvcm1hdGlvbiBvbiB0aGUgZG9tYWluIG9iamVjdCBtb2RlbCBqdXN0IGxpa2Ugd2UgaGFkIGl0IGJlZm9yZSwgd2hlcmUgd2UgaGFkIGFuIGludGVyZmFjZVxuICogY2FsbGVkIE91dGxpbmVOb2RlLCB3aXRoIGZpZWxkcyAoZXhwYW5kZWQsIHNlbGVjdGVkLCBldGMuLiApXG4gKlxuICpcbiAqIGBleHBhbnNpb25QYXRoYDogSG9sZHMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGFuZCBleHBhbmRlZCBub2Rlcy4gVGhpcyBpcyBmaWxsZWQgYnlcbiAqIE91dGxpbmVDb250cm9sbGVyLlxuICpcbiAqXG4gKiBJZiB3ZSBhcmUgZGVhbGluZyB3aXRoIEVudGl0eSBvciBhbnl0aGluZyB0aGF0IGhhcyBpZGVudGl0eSB0aGVuIHdlIGhhdmUgZWFzaWVyIHNpdHVhdGlvbiBhcyB3ZVxuICogY2FuIGFzayBmb3IgSUQgYW5kIGl0IGlzIG1vcmUgZWZmaWNpZW50IGZvciBzZXJpYWxpemF0aW9uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBPdXRsaW5lU3RhdGVcbntcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgYW5kIGV4cGFuZGVkIG5vZGVzXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIF9leHBhbnNpb25QYXRoOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYGFsbG93U2VsZWN0aW9uYCBpcyBlbmFibGVkIG9uIE91dGxpbmVDb250cm9sIGl0IHNhdmVkIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtIHRvIGJlXG4gICAgICogYWJsZSBsYXRlciBvbiBhcHBseSBzb21lIHN0eWxpbmcgYW5kIGJyb2FkY2FzdCB0aGlzIHNlbGVjdGlvbiBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2VsZWN0ZWRJdGVtOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE1hcHMgb2JqZWN0IHJlZmVyZW5jZSB0byBib29sZWFuIHZhbHVlcywgd2hlcmUgVFJVRSBtZWFucyBFWFBBTkRFRCwgRkFMU0UgY29sbGFwc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBleHBhbnNpb25TdGF0ZXM6IE1hcDxhbnksIGJvb2xlYW4+O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gb3V0bGluZSBpcyByZW5kZXJlZCBmb3IgZmlyc3QgdGltZSBvciByZS1yZW5kZXJlZCBhbmQgd2Ugc2V0IGRlZmF1bHQgdmFsdWUgZm9yIHRoZVxuICAgICAqIGV4cGFuc2lvblN0YXRlcy4gVGhpcyB3YXkgd2UgY2FuIHByZXR0eSBlYXNpbHkgZXhlY3V0ZSBDb2xsYXBzZUFsbCwgRXhwYW5kQWxsXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkQWxsOiBib29sZWFuID0gZmFsc2U7IC8vIGNvbGxhcHNlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBIb2xkcyBjdXJyZW50IGxldmVsIGR1cmluZyB0cmVlIG5vZGUgcmVuZGVyaW5nIHNvIHdlIGNhbiBhcHBseSBjb3JyZWN0IGluZGVudGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50TGV2ZWw6IG51bWJlciA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBkdXJpbmcgYSB0b2dnbGUgYWN0aW9uIHRvIHJlY29yZCBjdXJyZW50IHNlbGVjdGlvbiBwYXRoLlxuICAgICAqXG4gICAgICovXG4gICAgY3VycmVudFBhdGg6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWxseSBzaGFyZWQgcHJvcGVydHlcbiAgICAgKi9cbiAgICBvdXRsaW5lRm9yOiBPdXRsaW5lRm9yQ29tcG9uZW50O1xuXG5cbiAgICBjb25zdHJ1Y3RvciAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBjb2xsYXBzZUFsbCBhbmQgZXhwYW5kQWxsIHdlIGFyZSB1c2luZyBzaW1wbGUgbWVjaGFuaXNtIHdoZXJlIHdlIGNsZWFuIHVwIGFsbFxuICAgICAqIHNlbGVjdGlvbiBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBleHBhbmQgc3RhdGUsIHRoaXMgd2hleSBpc0V4cGFuZCBtZXRob2QgcmV0dXJucyB0aGUgc2FtZVxuICAgICAqIHN0YXRlIGZvciBhbGwgaXRlbXNcbiAgICAgKi9cbiAgICBjb2xsYXBzZUFsbCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm91dGxpbmVGb3IpICYmXG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuXG4gICAgICAgICAgICAvLyBmb3IgdGhpcyBjYXNlIHdlIGNvbGxhcHNlIGFsbCBidXQgcm9vdCBub2Rlc1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpIHtcblxuICAgICAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5saXN0LmZvckVhY2goKGl0ZW06IE91dGxpbmVOb2RlKSA9PlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlcyhpdGVtLmNoaWxkcmVuIHx8IFtdLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZXModGhpcy5vdXRsaW5lRm9yLmxpc3QgfHwgW10sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRXhwYW5kZWRBbGwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBleHBhbmRBbGwgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vdXRsaW5lRm9yKSAmJlxuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZXModGhpcy5vdXRsaW5lRm9yLmxpc3QsIHRydWUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNFeHBhbmRlZEFsbCA9IHRydWU7XG4gICAgfVxuXG5cbiAgICBnZXQgZXhwYW5zaW9uUGF0aCAoKTogYW55W11cbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX2V4cGFuc2lvblBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvblBhdGg7XG4gICAgfVxuXG5cbiAgICBzZXQgZXhwYW5zaW9uUGF0aCAodmFsdWU6IGFueVtdKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uUGF0aCA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX2V4cGFuc2lvblBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uUGF0aC5mb3JFYWNoKChpdGVtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uIChjdXJyZW50UGF0aDogYW55W10sIGNoaWxkcmVuPzogYW55W10pOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGN1cnJlbnRQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpdGVtID0gTGlzdFdyYXBwZXIubGFzdChjdXJyZW50UGF0aCk7XG4gICAgICAgIGxldCBpdGVtQ2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gIXRoaXMuaXNFeHBhbmRlZChpdGVtKTtcbiAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShpdGVtLCBuZXdTdGF0ZSk7XG5cbiAgICAgICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlTGFzdChjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVzKGl0ZW1DaGlsZHJlbiwgbmV3U3RhdGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25QYXRoKGN1cnJlbnRQYXRoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVOb2RlcyAobm9kZXM6IGFueVtdLCBuZXdTdGF0ZTogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKGNoaWxkOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBpdGVtcyA9IHRoaXMub3V0bGluZUZvci5jaGlsZHJlbkZvckl0ZW0oY2hpbGQpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpdGVtcykgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTm9kZXMoaXRlbXMsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUoY2hpbGQsIG5ld1N0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0RXhwYW5zaW9uU3RhdGUgKGl0ZW06IGFueSwgaXNFeHBhbmRlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIEV2ZW4gZm9yIHRyZWUgbW9kZSBmb3JtYXQgc2F2ZSB0aGUgc3RhdGUgc28gd2UgY2FuIHVzZSBpdCBsYXRlciBvbiBpbiBjYXNlIG9iamVjdFxuICAgICAgICAvLyByZWZlcmVuY2VzIGdldHMgbWVlc2VkIHVwXG4gICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IgJiZcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICAoPE91dGxpbmVOb2RlPml0ZW0pLmlzRXhwYW5kZWQgPSBpc0V4cGFuZGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGtleSA9IHRoaXMuaXRlbVRvS2V5KGl0ZW0pO1xuICAgICAgICAgICAgaWYgKGlzRXhwYW5kZWQgPT09IHRoaXMuaXNFeHBhbmRlZEFsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5zZXQoa2V5LCAoaXNFeHBhbmRlZCkgPyB0cnVlIDogZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gaW1wcm92ZSBzdGF0ZSBwZXJzaXN0aW5nIGxldHMgY2hlY2sgaWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBhbiBPYmplY3QgdGhhdCBoYXMgSWRlbnRpdHlcbiAgICAgKiBzbyB3ZSBjYW4gZXh0cmFjdCBhbiBJRCBvdGhlcndpc2UgdXNlIG9iamVjdCB0byBjb21wYXJlIGJ5IHJlZmVyZW5jZVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGl0ZW1Ub0tleSAoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gaXNFbnRpdHkoaXRlbSkgPyAoPEVudGl0eT5pdGVtKS5pZGVudGl0eSgpIDogaXRlbTtcbiAgICB9XG5cblxuICAgIHNldEV4cGFuc2lvblBhdGggKGl0ZW1zOiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uUGF0aCA9IGl0ZW1zO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goKG5vZGU6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShub2RlLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgaXNFeHBhbmRlZCAoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm91dGxpbmVGb3IpICYmXG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICg8T3V0bGluZU5vZGU+aXRlbSkuaXNFeHBhbmRlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHBhbnNpb25TdGF0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc0V4cGFuZGVkQWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YW5pbWF0ZSwgQW5pbWF0aW9uQnVpbGRlciwgc3RhdGUsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgSWRlbnRpdHksIGlzQmxhbmssIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuL291dGxpbmUtc3RhdGUnO1xuXG5cbi8qKlxuICogVGhpcyBpbnRlcmZhY2UgcmVwcmVzZW50IGNvbmNyZXRlIHRyZWUgc3RydWN0dXJlIGZvciB0aGUgb3V0bGluZSB0cmVlIG1vZGVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPdXRsaW5lTm9kZSBleHRlbmRzIElkZW50aXR5XG57XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHBhcmVudCBub2RlLlxuICAgICAqL1xuICAgIHBhcmVudDogT3V0bGluZU5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBOb2RlJ3MgY2hpbGRyZW4uIEV2ZW4gaXRzIGEgZmllbGQgaXQgY2FuIGJlIGltcGxlbWVudGVkIGxhemlseSB1c2luZyBnZXR0ZXIgd2hlcmUgYSB0YXJnZXRcbiAgICAgKiBvYmplY3QgZG9lcyBub3QgaW1wbGVtZW50IHRoaXMgYXMgYSBwdWJsaWMgZmllbGQgYnV0IGEgZ2V0dGVyIHdpdGggY29udHJvbCBvdmVyIHRoZVxuICAgICAqIHJldHJpZXZlZCBsaXN0XG4gICAgICovXG4gICAgY2hpbGRyZW46IE91dGxpbmVOb2RlW107XG5cbiAgICAvKipcbiAgICAgKiBEaWZmZXJlbnQgc3RhdGVzIGZvciBvdXRsaW5lIE5vZGVcbiAgICAgKlxuICAgICAqIGlzRXhwYW5kZWQ6IGJvb2xlYW47PSBtb3Zpbmcgb3V0IGFzIHRoaXMgaXMgbWFuYWdlZCBieSBleHBhbnNpb25zdGF0ZS5cbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkOiBib29sZWFuO1xuICAgIGlzU2VsZWN0ZWQ6IGJvb2xlYW47XG4gICAgaXNNYXRjaD86IGJvb2xlYW47XG4gICAgcmVhZG9ubHk/OiBib29sZWFuO1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gICAgZHJhZ2dhYmxlPzogYm9vbGVhbjtcbiAgICBkcm9wcGFibGU/OiBib29sZWFuO1xuICAgIHZpc2libGU/OiBib29sZWFuO1xuXG59XG5cblxuLyoqXG4gKlxuICogQ2hlY2tzIHR5cGUgZm9yIE91dGxpbmVOb2RlXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPdXRsaW5lTm9kZShub2RlOiBhbnkpOiBub2RlIGlzIE91dGxpbmVOb2RlXG57XG4gICAgcmV0dXJuIGlzUHJlc2VudChub2RlKSAmJiBpc1ByZXNlbnQoKDxPdXRsaW5lTm9kZT5ub2RlKSlcbiAgICAgICAgJiYgaXNQcmVzZW50KCg8T3V0bGluZU5vZGU+bm9kZSkucGFyZW50KVxuICAgICAgICAmJiBpc1ByZXNlbnQoKDxPdXRsaW5lTm9kZT5ub2RlKS5jaGlsZHJlbik7XG59XG5cblxuLyoqXG4gKiBDdXJyZW50bHkgb3V0bGluZSBzdXBwb3J0cyBvbmx5IHR3byBtb2RlcyBmcmVlLCB3aGVyZSBhcHBsaWNhdGlvbiBpcyByZXNwb25zaWJsZSB0byByZXRyaWV2ZVxuICogY2hpbGRyZW4gZm9yIGVhY2ggbm9kZSBhbmQgdHJlZSB3aXRoIGFib3ZlIE91dGxpbmVOb2RlIHN0cnVjdHVyZVxuICovXG5leHBvcnQgdHlwZSBNb2RlbEZvcm1hdCA9ICdmcmVlJyB8ICd0cmVlJztcblxuXG4vKipcbiAqXG4gKiBPdXRsaW5lRm9yQ29tcG9uZW50IGlzIGxpa2UgbmdGb3IsIGJ1dCBmb3IgaGllcmFyY2hpY2FsIChvdXRsaW5lL3RyZWUpIHN0cnVjdHVyZXMgLS0gaS5lLiBpblxuICogdGhvc2UgY2FzZXMgd2hlcmUgYW4gaXRlbSBtYXkgaGF2ZSBjaGlsZHJlbi5cbiAqXG4gKlxuICogSXQgdXNlcyBvdXRsaW5lIGA8YXctb3V0bGluZS1jb250cm9sPmAgdG8gcHJvdmlkZSBleHBhbmRpbmcgZnVuY3Rpb25hbGl0eSwgaW5kZW50YXRpb25cbiAqIGFuZCBvdGhlciB0aGluZ3MuXG4gKlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGhhcyBtaW5pbWFsIHN0eWxpbmcgdG8gbWFrZSBzdXJlIGl0IGNhbiBiZSBjaGFuZ2VkIGVhc2lseS5cbiAqXG4gKiAjIyMgRXhhbXBsZSByZW5kZXJpbmcgdHJlZSBzZWN0aW9uLCB3aGVyZSBiYXNlZCBvbiB0aGUgdHlwZSB3ZSBmb3JtYXQgdGhlIG91dCBwbHVzXG4gKiBmb3IgdGhlIG1haW4gcm9vdCBzZWN0aW9uIHdlIGFsd2F5cyByZW5kZXIgbGl0dGxlIHBvcHVwIG1lbnUuXG4gKlxuICogYGBgXG4gKlxuICogICA8YXctb3V0bGluZS1mb3IgW2xpc3RdPVwibGlzdFwiIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiPlxuICpcbiAqICAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqXG4gKiAgICAgICAgICAgPGRpdiBjbGFzcz1cIm15LXNlY3Rpb25cIj5cbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm91dGxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxhdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwiaXRlbS50eXBlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdTd2l0Y2hDYXNlXT1cIid0ZXh0J1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFzLXBhcmFncmFmXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3tpdGVtPy5jb250ZW50fX1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ1N3aXRjaERlZmF1bHQ+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDwvYXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWx0ZXJzXCIgKm5nSWY9XCJpdGVtLnR5cGUgPT09ICdzZWN0aW9uJ1wiID5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICA8YXctaG92ZXItY2FyZCBbbGlua1RpdGxlXT1cIidGaWx0ZXIgSXRlbXMnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPGF3LWxpc3QgW2xpc3RdPVwiZmlsdGVySXRlbXNcIiBbYm9yZGVybGVzc109XCJ0cnVlXCI+PC9hdy1saXN0PlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1ob3Zlci1jYXJkPlxuICpcbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5gXG4gKiAgIDwvYXctb3V0bGluZS1mb3I+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFdlIGNhbiB1c2UgaXQgYWxzbyBpbiBlbWJlZGRlZCBtb2RlIHdoZXJlIHdlIHVzZSB0aGUgYGF3T3V0bGluZUZvcmAgZGlyZWN0aXZlXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqXG4gKiBgYGBgXG4gKiAgPHRhYmxlICBjbGFzcz1cInRyZWUtdGFibGVcIiA+XG4gKiAgICAgIDx0aGVhZD5cbiAqICAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgICA8dGg+TmFtZTwvdGg+XG4gKiAgICAgICAgICAgICAgPHRoPlR5cGU8L3RoPlxuICogICAgICAgICAgPC90cj5cbiAqICAgICAgPC90aGVhZD5cbiAqICAgICAgPHRib2R5ICNvb28yIGF3T3V0bGluZUZvciBbbGlzdF09XCJsaXN0XCJcbiAqICAgICAgICAgICAgIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiXG4gKiAgICAgICAgICAgICBjbGFzcz1cIm91dGxpbmUtdGFibGVcIlxuICogICAgICA+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUgI291dGxpbmUgbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJpdGVtLW5hbWUgb3V0bGluZS1hbmltYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+PC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gKiAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIml0ZW0tdHlwZSBvdXRsaW5lLWFuaW1hdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgPGRpdj57e2l0ZW0udHlwZX19PC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gKiAgICAgICAgICAgICAgPC90cj5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwvdGJvZHk+XG4gKiAgPC90YWJsZT5cbiAqXG4gKiBgYGBcbiAqXG4gKiBJIHdhcyB0aGlua2luZyBtYXliZSBmb3IgZmlyc3QgdGltZSB3ZSBkb24ndCBuZWVkIHRoZSBzYW1lIGFuaW1hdGlvbiBsaWtlIGV4cGFuZGluZyBhbmRcbiAqIGNvbGxhcHNpbmcuIE1heWJlIHdlIG5lZWQgZmFkZS1pbi4gSW4gc3VjaCBjYXNlIEkgd291bGQgcHJvYmFibHkgYXBwbHkgQHNlY3Rpb24gYW5pbSBvbmx5XG4gKiBvbiBpdGVtcyB3aGVyZSBsZXZlbCA+IDAgKGluIHRoZSB0ZW1wbGF0ZSBJIGtlZXAgbGV2ZWxzKSBhbmQgaWYgbGV2ZWwgPT0gMCB0aGVuIEkgd291bGRcbiAqIGV4ZWN1dGUgdGhlIHNhbWUgcmVuZGVyaW5nIGp1c3Qgd2l0aG91dCBbQHNlY3Rpb25dXG4gKlxuICpcbiAqIFRvZG86IFRoaW5rIGFib3V0IGhvdyB0byBkbyBhbmltYXRpb24gZm9yIHRoZSB0YWJsZSBjYXNlLiBNdXN0IGFsc28gd3JpdGUgdW5pdGVzdCAtIGR1ZSB0b1xuICogQXJpYmFMaXZlIGFnZ3Jlc3NpdmUgc2NoZWR1bGUgd2UgYXJlIHNraXBwaW5nIHRoZW0gZm9yIG5vd1xuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1vdXRsaW5lLWZvciwgW2F3T3V0bGluZUZvcl0nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFN0YXJ0cyB3aXRoIHRoZSBsaXN0LCB3aGVyZSBuZXN0aW5nTGV2ZWwgaXMgLTEuXG4gICAgY2FsbCB0ZW1wbGF0ZSBvdXRsaW5lSXRlbXMgdG8gaXRlcmF0ZSBhbmQgcmVuZGVyIGVhY2ggaXRlbVxuLS0+XG48bmctY29udGFpbmVyIFtuZ0lmXT1cImxpc3RcIiAqbmdUZW1wbGF0ZU91dGxldD1cIm91dGxpbmVJdGVtcztcbiAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGxpc3QsIG5lc3RpbmdMZXZlbDogMCwgcGFyZW50SXRlbTogbnVsbCwgZXhwYW5kZWQ6IHRydWV9XCI+XG48L25nLWNvbnRhaW5lcj5cblxuPCEtLVxuICAgIE1haW4gRW50cnkgcG9pbnQgZm9yIHRoZSByZWN1cnNpb24uIHRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBibG9jayBhYm92ZSBhcyB3ZWxsIGFzIGJ5dCB0aGUgaW5uZXJcbiAgICBwaWVjZSB0aGF0IGNhbGxzIHRoaXMgdGVtcGxhdGUgcmVjdXJzaXZlbHkgYWdhaW4gd2hlbiBhbiBpdGVtIGhhcyBjaGlsZHJlblxuLS0+XG48bmctdGVtcGxhdGUgI291dGxpbmVJdGVtcyBsZXQtY2hpbGRyZW4gbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiXG4gICAgICAgICAgICAgbGV0LXBhcmVudD1cInBhcmVudEl0ZW1cIiBsZXQtZXhwYW5kZWQ9XCJleHBhbmRlZFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cImNoaWxkcmVuXCIgbGV0LXJvd0luZGV4PVwiaW5kZXhcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwib3V0bGluZUl0ZW07XG4gICAgICAgICAgICBjb250ZXh0OnsgJGltcGxpY2l0OiBpdGVtLCBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCwgcGFyZW50SXRlbTogcGFyZW50LFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkLCByb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPCEtLVxuXG4gICAgICAgICAgICBSZWN1cnNpb24gcGllY2U6XG5cbiAgICAgICAgICAgIEZvciBub24gZW1iZWRkZWQgY2FzZSB3aGVuIGV2ZW4gaWYgaXRzIG5vdCBleHBhbmRlZCB3ZSBuZWVkIHRvIGl0ZXJhdGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGFzIHdlIHdhbnQgdG8gYXBwbHkgYW5pbWF0aW9uIHRoYXQgc2hvdWxkIGdvIHdpdGggbmdJZiB3aGljaCBpbnNpZGUgdGhlIG91dGluZUl0ZW1cbiAgICAgICAgICAgIHRlbXBsYXRlXG5cbiAgICAgICAgICAgIERvbnQgcmVjdXJzZS8gcmVuZGVyIGl0ZW1zIHRoYXQgYXJlIG5vdCB2aXNpYmxlLlxuICAgICAgICAtLT5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzQ2hpbGRyZW4oaXRlbSkgJiYgKGlzRXhwYW5kZWQoaXRlbSwgbmVzdGluZ0xldmVsKSB8fCAhZW1iZWRkZWQpICYmIGlzVmlzaWJsZShpdGVtKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm91dGxpbmVJdGVtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGNoaWxkcmVuRm9ySXRlbShpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwrMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6IGlzRXhwYW5kZWQoaXRlbSwgbmVzdGluZ0xldmVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SXRlbTppdGVtIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG5cbjwhLS1cbiAgICBSZW5kZXJzIGFjdHVhbCBvdXRsaW5lIG5vZGUgYW5kIGFwcGxpZXMgYW5pbWF0aW9uIHdoaWxlIGV4cGFuZGluZyBhbmQgY29sbGFwc2luZ1xuXG4gICAgW0BzZWN0aW9uXT1cImV4cGFuZGVkIHx8IGlzRXhwYW5kZWQoaXRlbSkgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1wiXG4tLT5cbjxuZy10ZW1wbGF0ZSAjb3V0bGluZUl0ZW0gbGV0LWl0ZW0gbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1wYXJlbnQ9XCJwYXJlbnRJdGVtXCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgbGV0LWV4cGFuZGVkPVwiZXhwYW5kZWRcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ3LW91dGxpbmUtaXRlbVwiXG4gICAgICAgICAqbmdJZj1cIiFlbWJlZGRlZCAmJiBleHBhbmRlZFwiXG4gICAgICAgICBbc3R5bGUucGFkZGluZy1sZWZ0LnB4XT1cImluZGVudGF0aW9uKG5lc3RpbmdMZXZlbClcIlxuICAgICAgICAgaW5pdE5lc3RpbmcgW3NldExldmVsXT1cIm5lc3RpbmdMZXZlbFwiIFtzZXRQYXJlbnRJdGVtXT1cInBhcmVudFwiXG4gICAgICAgICBbc2V0Q3VycnJlbnRJdGVtXT1cIml0ZW1cIlxuICAgICAgICAgW0BzZWN0aW9uXVxuICAgICAgICAgKEBzZWN0aW9uLmRvbmUpPVwib25BbmltYXRpb25Eb25lKCRldmVudClcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29udHJvbFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogaXRlbSwgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsIHJvd0luZGV4OnJvd0luZGV4IH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tXG4gICAgICAgIFdoZW4gb3V0bGluZSBjb250cm9sIGlzIHVzZWQgYXMgZW1iZWRkZWQgbWVhbmluZyBpdHMgaW5zaWRlIGUuLmcgZGF0YXRhYmxlIHdlXG4gICAgICAgIGNhbm5vdCBoYXZlIGFueSB0YWdzIGFyb3VuZCBpdC5cblxuICAgICAgICBUb2RvOiBSZWZhY3RvciB0aGlzIGluIHRoZSB3YXkgc28gd2UgY2FuIGRvIGFuaW1hdGlvbiB3aGVuIHRhYmxlIGxpbmVzIGFyZVxuICAgICAgICBleHBhbmRlZC4gU2luY2UgaXRzIGVtYmVkZGVkIHdlIGNhbiBub3QgaGF2ZSBhbnkgd3JhcHBpbmcgZWxlbWVudCBhcm91bmQsIHRoZSB0ZW1wbGF0ZVxuICAgICAgICBpcyBmdWxseSByZXNwb25zaWJsZVxuICAgIC0tPlxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlbWJlZGRlZCAmJiBleHBhbmRlZFwiXG4gICAgICAgICAgICAgICAgIGluaXROZXN0aW5nIFtzZXRMZXZlbF09XCJuZXN0aW5nTGV2ZWxcIiBbc2V0UGFyZW50SXRlbV09XCJwYXJlbnRcIlxuICAgICAgICAgICAgICAgICBbc2V0Q3VycnJlbnRJdGVtXT1cIml0ZW1cIlxuICAgID5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjcmVuZGVyZWRJdGVtICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29udHJvbFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogaXRlbSwgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsIHJvd0luZGV4OnJvd0luZGV4ICB9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuYCxcbiAgICBzdHlsZXM6IFtgLmlzLW91dGxpbmUtYW5pbWF0aW9uPmRpdiw6Om5nLWRlZXAgLnctb3V0bGluZS1pdGVte292ZXJmbG93OmhpZGRlbn1gXSxcblxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignc2VjdGlvbicsIFtcbiAgICAgICAgICAgIHN0YXRlKCcqJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICdvdmVyZmxvdy15JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcqJyxcbiAgICAgICAgICAgICAgICAnb3BhY2l0eSc6ICcxJ1xuXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzAnLFxuICAgICAgICAgICAgICAgICdvcGFjaXR5JzogJzAnLFxuICAgICAgICAgICAgICAgICdvdmVyZmxvdy15JzogJ2hpZGRlbidcblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgYW5pbWF0ZSgnMjAwbXMgZWFzZS1vdXQnKSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBhbmltYXRlKCcyMDBtcyBlYXNlLWluJykpXG4gICAgICAgIF0pLFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgT3V0bGluZUZvckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgaXRlbXMgdGhhdCBuZWVkcyB0byBiZSByZW5kZXJlZC4gSXQgZG9lcyBub3QgaGF2ZSB0byBpbiBoaWVyYXJjaGljYWwgb3JkZXIgb3Igd2VcbiAgICAgKiBsZWF2ZSBpdCB1cCB0byB0aGUgYXBwbGljYXRpb24gdG8gZGVjaWRlIGFib3V0IHRoZSBzdHJ1Y3R1cmUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0PzogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBjb21wb25lbnQgbm90IHRvIHJlbmRlciBleHBhbnNpb24gY29udHJvbCwgaW4gc3VjaCBjYXNlIHdlIGV4cGFuZEFsbCBhcyBhXG4gICAgICogZGVmYXVsdCBiZWhhdmlvclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93RXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gbWV0aG9kIHByb3ZpZGVkIGJ5IGFwcGxpY2F0aW9uIHRvIHJldHJpZXZlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGN1cnJlbnQgaXRlbS4gSWZcbiAgICAgKiBjaGlsZHJlbiBpcyB1bmRlZmluZWQgdGhlbiwgZGVmYXVsdCAnY2hpbGRyZW4nIGZpZWxkIGlzIHVzZWQgPGN1cnJlbnRJdGVtPi5jaGlsZHJlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hpbGRyZW46ICh2YWx1ZTogYW55KSA9PiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT3B0aW9uIHRvIGNvbmRpdGlvbmFsbHkgcmVuZGVyIG9ubHkgaXRlbXMgdGhhdCBhcmUgc2F0aXNmeWluZyBmaWx0ZXIgY29uZGl0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpbHRlck91dDogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGFsbCB0cmVlIG5vZGVzLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHBhbmRBbGw6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogIE1hbmFnZXMgdGhlIHN0YXRlIGZvciB0aGUgT3V0bGluZSBjb21wb25lbnQuIExhdGVyIG9uIHdlIGNhbiBwcm92aWRlIGVhc2llciB3ZSBob3cgdG9cbiAgICAgKiAgaW5pdGlhbGl6ZSBhbmQgc2V0IHNlbGVjdGlvblBhdGhzIGFuZCBzZWxlY3Rpb25TdGF0ZXMgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RhdGU6IE91dGxpbmVTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0IGluZGVudGF0aW9uIHNpemUgdG8gYmUgdXNlZCBmb3IgZWFjaCBsZXZlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnRhdGlvblBlckxldmVsOiBudW1iZXIgPSAyNTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB0ZW1wbGF0ZSBpcyBvdXRzaWRlIG9mIHRoZSBvdXRsaW5lRm9yXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHRlcm5hbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gY3VycmVudCBvYmplY3QgdXNpbmcgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSWRlbnRpZmllcyBjdXJyZW50IG1vZGVsIG1vZGUuXG4gICAgICpcbiAgICAgKiBXZSByZWNvZ25pemUgdHdvIG1vZGVzOlxuICAgICAqXG4gICAgICogRnJlZSAtIEFwcGxpY2F0aW9uIG5lZWRzIHRvIGltcGxlbWVudCBhIGNoaWxkcmVuIG1ldGhvZCB0byByZXRyaWV2ZSBhIGxpc3Qgb2YgY2hpbGRyZW4gZm9yXG4gICAgICogZWFjaCBub2RlIGFuZCBmb3JtYXQgaXMgcHJldHR5IG11Y2ggdXB0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogVHJlZSAtIHRoaXMgaXMgbW9yZSByZXN0cmljdGl2ZSB3aGVyZSB3ZSBoYXZlIGNvbmNyZXRlIGRhdGEgc3RydWN0dXJlXG4gICAgICogaW50ZXJmYWNlIHRoYXQgbmVlZHMgdG8gYmUgZm9sbGVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBpbnN0ZWFkIG9mIHBhc3NpbmcgZm9ybWF0IGJpbmRpbmcgdHJ5IHRvIGxvb2sgaW50byB0aGUgbGlzdCB0byBzZWUgd2hhdCB0eXBlIHNvXG4gICAgICogd2UgZG9udCBtYWtlIGl0IG1hbmRhdG9yeVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JtYXQ6IE1vZGVsRm9ybWF0ID0gJ2ZyZWUnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHdoZW4gaW4gc2VsZWN0aW9uIG1vZGUgdG8gcHVzaCBjdXJyZW50IHNlbGVjdGVkIEl0ZW0gdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkl0ZW1TZWxlY3RlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBpcyB0cmlnZ2VyZWQgYnkgT3V0bGluZUNvbnRyb2wgd2hlbiBub2RlIGlzIGV4cGFuZGVkIG9yIGNvbGxhcHNlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25FeHBhbmRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wbGF0ZSB0byB1c2Ugb24gYXBwbGljYXRpb24gbGV2ZWwgdG8gcmVuZGVyIGluZGl2aWR1YWwgaXRlbXNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdvdXRsaW5lJylcbiAgICBjb250cm9sVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBWaWV3Q2hpbGQoJ3JlbmRlcmVkSXRlbScpXG4gICAgb3V0bGluZUl0ZW06IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsc1xuICAgICAqXG4gICAgICogY3VycmVudEl0ZW0gYW5kIHBhcmVudEl0ZW0gYXJlIHVzZWQgdG8gY2FwdHVyZSBjdXJyZW50IHByb2Nlc3NlZCBpdGVtIG9mIG5nRm9yLiBUaGlzIGlzXG4gICAgICogc2V0IGJ5IGRpcmVjdGl2ZSBgSW5pdE5lc3RpbmdEaXJlY3RpdmVgXG4gICAgICpcbiAgICAgKiBhbmltYXRpb25JblByb2dyZXNzOiB1c2VkIGJ5IGFuaW1hdGlvbiBlbmdpbmUgdG8gbWFrZSBzdXJlIHdlIGRvbnQgZG8gYW55IGFjdGlvbnMgd2hpbGVcbiAgICAgKiBhbmltYXRpb24gaXMgaW4gdGhlIHByb2dyZXNzXG4gICAgICpcbiAgICAgKiBlbWJlZGRlZDogSW5kaWNhdGVzIHRoYXQgd2UgYXJlIHVzaW5nIGRpcmVjdGl2ZSBzbyBpdCB3aWxsIG5vdCBoYXZlIGRlZmF1bHQgY29tcG9uZW50XG4gICAgICogd3JhcHBlclxuICAgICAqXG4gICAgICovXG4gICAgY3VycmVudEl0ZW06IGFueTtcbiAgICBwYXJlbnRJdGVtOiBhbnk7XG4gICAgYW5pbWF0aW9uSW5Qcm9ncmVzczogYm9vbGVhbjtcbiAgICBlbWJlZGRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRmxhZyB0aGF0IHRlbGxzIHVzIHRoYXQgY29tcG9uZW50IGlzIGZ1bGx5IHJlbmRlcmVkXG4gICAgICpcbiAgICAgKi9cbiAgICB2aWV3SW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBwcml2YXRlIGJ1aWxkZXI6IEFuaW1hdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgT3V0bGluZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZS5vdXRsaW5lRm9yKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vdXRsaW5lRm9yID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZEFsbCkge1xuICAgICAgICAgICAgdGhpcy5zaG93RXhwYW5zaW9uQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5pc0V4cGFuZGVkQWxsID0gdGhpcy5leHBhbmRBbGw7XG5cbiAgICAgICAgLy8gaW4gY2FzZSB3ZSB3YW50IHRvIHJlbmRlciBjb250ZW50IG9mIHRyZWUgb3V0c2lkZSBvZiBvdXRsaW5lRm9yXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5leHRlcm5hbFRlbXBsYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sVGVtcGxhdGUgPSB0aGlzLmV4dGVybmFsVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVtYmVkZGVkID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCdhd291dGxpbmVmb3InKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNvbnRleHQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcbiAgICB9XG5cbiAgICBpc1RyZWVNb2RlbEZvcm1hdCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQgPT09ICd0cmVlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRlbXBsYXRlIGFuZCBPdXRsaW5lQ29udHJvbCB0byBpZGVudGlmeSB3aGljaCBpdGVtIGlzIGV4cGFuZGVkIGFuZCBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQoaXRlbTogYW55LCBjdXJyZW50TGV2ZWw6IG51bWJlciA9IC0xKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGN1cnJlbnRMZXZlbCA9PT0gMCAmJiB0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIG92ZXJyaWRlL3Jlc2V0IGZvciByb290IG5vZGVzXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICAgICAgKDxPdXRsaW5lTm9kZT5pdGVtKS5pc0V4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRXhwYW5kZWQoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaW5jZSB3ZSBoYXZlIGN1cnJlbnRseSB0d28gd2F5cyBob3cgdG8gcGFzcyBjaGlsZHJlbiBpdGVtcyB3ZSBuZWVkIGhhdmUgdGhpcyBtZXRob2QgdG9cbiAgICAgKiB1bmlmeSB0aGUgd2F5IGhvdyB3ZSBhY2Nlc3MgaXQuIElmIHdlIHBhc3MgYGNoaWxkcmVuYCBiaW5kaW5nIHdlIHVzZSB0aGlzIGluc3RlYWQsIG90aGVyd2lzZVxuICAgICAqIHdlIGV4cGVjdCBjdXJyZW50IG9iamVjdCB0byBoYXZlIGBjaGlsZHJlbmAgZmllbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGNoaWxkcmVuRm9ySXRlbShpdGVtOiBhbnkpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUcmVlTW9kZWxGb3JtYXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICg8T3V0bGluZU5vZGU+aXRlbSkuY2hpbGRyZW4gfHwgW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNDaGlsZHJlbihpdGVtKSA/IHRoaXMuZG9HZXRDaGlsZHJlbihpdGVtKSA6IFtdO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IGl0ZW0gaGFzIGEgY2hpbGRyZW4gYW5kIG5lZWRzIHRvIGJlIHJlbmRlcmVkXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNDaGlsZHJlbihpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pc1RyZWVNb2RlbEZvcm1hdCgpKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSAoPE91dGxpbmVOb2RlPml0ZW0pLmNoaWxkcmVuO1xuICAgICAgICAgICAgcmV0dXJuIGlzUHJlc2VudChjaGlsZHJlbikgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMDtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzQmxhbmsodGhpcy5jaGlsZHJlbikgJiYgaXNCbGFuayhpdGVtLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCAnTWlzc2luZyBbY2hpbGRyZW5dIG1ldGhvZCBiaW5kaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5kb0dldENoaWxkcmVuKGl0ZW0pLmxlbmd0aCA+IDA7XG5cbiAgICB9XG5cbiAgICBkb0dldENoaWxkcmVuKGl0ZW06IGFueSk6IGFueVtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtpdGVtXSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgVXNlcyB0aGUgYE91dGxpbmVTdGF0ZWAgdG8gdG9nZ2xlIHN0YXRlIG9mIGN1cnJlbnQgc2VsZWN0aW9uUGF0aC4gVGhlIGBzZWxlY3Rpb25QYXRoYCBpc1xuICAgICAqICBwdXQgdG9nZXRoZXIgaW5zaWRlIGBPdXRsaW5lQ29udHJvbGAgd2hlcmUgd2UgaXRlcmF0ZSBhbGwgdGhlIHdheSB0byB0aGUgcm9vdCBhbmQgYWRkXG4gICAgICogIGVhY2ggaXRlbSB0byB0aGUgYGN1cnJlbnRQYXRoYCBhcnJheS4gVGhpcyB3YXkgd2UgY29sbGVjdCBsaXN0IG9mIGl0ZW0gcmVwcmVzZW50aW5nIGN1cnJlbnRcbiAgICAgKiAgY3VycmVudCBleHBhbnNpb25QYXRoLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gYmFja3VwIHByb2NlZHVyZSBpbiBjYXNlIG9uQW5pbWF0aW9uRG9uZSBmYWlsc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MpIHsgLy8gY2hhbmdlIG9ubHkgaWYgaXRzIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KHRoaXMuc3RhdGUuY3VycmVudFBhdGgpO1xuICAgICAgICB0aGlzLnN0YXRlLnRvZ2dsZUV4cGFuc2lvbih0aGlzLnN0YXRlLmN1cnJlbnRQYXRoLCB0aGlzLmNoaWxkcmVuRm9ySXRlbShjdXJyZW50SXRlbSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmFuaW1hdGVFbWJlZGRlZEl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBhbmltLiBjYWxsYmFjayB0aGF0IHNldHMgYmFjayB0aGUgZmxhZyB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhbmltYXRpb25zXG4gICAgICogd2hlbiBvbmUgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkFuaW1hdGlvbkRvbmUoZXZlbnQ6IEV2ZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JblByb2dyZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBpbmRlbnRhdGlvbiB1c2VkIHRvIHNoaWZ0IHRoZSBuZXN0ZWQgc2VjdGlvbiB0byB0aGUgcmlnaHQgb3IgbGF0ZXIgb24gdG8gdGhlXG4gICAgICogbGVmdCB3aGVuIFJUTCBpcyBzdXBwb3J0ZWRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaW5kZW50YXRpb24oY3VycmVudExldmVsOiBudW1iZXIpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBjdXJyZW50TGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoY3VycmVudExldmVsID09PSAwICYmIHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKVxuICAgICAgICAgICAgPyAwIDogKHRoaXMuaW5kZW50YXRpb25QZXJMZXZlbCAqIGN1cnJlbnRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90IGFsbCByb3dzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQsIHRoZXJlIGNhbiBiZSBhIGNhc2Ugd2hlcmUgeW91IGRvbnQgd2FudCB0byByZW5kZXIgaXRlbXNcbiAgICAgKiB1c2luZyBvdXRsaW5lLiBlLmcuIERhdGF0YWJsZSB3aXRoIGRldGFpbCByb3cuXG4gICAgICovXG4gICAgaXNWaXNpYmxlKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5maWx0ZXJPdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZmlsdGVyT3V0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogU2luY2Ugd2UgY2FuIG5vdCBkaXJlY3RseSBzZXQgYCpuZ1RlbXBsYXRlT3V0bGV0YCBjb250ZXh0IHZhcmlhYmxlcyB0byB0aGUgdHlwZXNjcmlwdCBjbGFzcyB3ZVxuICogdXNlIHRoaXMgZGlyZWN0aXZlIHRvIGRvIHRoZSBKb2JcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2luaXROZXN0aW5nXSdcbn0pXG5leHBvcnQgY2xhc3MgSW5pdE5lc3RpbmdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXRcbntcblxuICAgIEBJbnB1dCgpXG4gICAgc2V0TGV2ZWw6IG51bWJlcjtcblxuXG4gICAgQElucHV0KClcbiAgICBzZXRDdXJycmVudEl0ZW06IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBzZXRQYXJlbnRJdGVtOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgb3V0bGluZTogT3V0bGluZUZvckNvbXBvbmVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2V0TGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmUuc3RhdGUuY3VycmVudExldmVsID0gdGhpcy5zZXRMZXZlbDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNldEN1cnJyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5jdXJyZW50SXRlbSA9IHRoaXMuc2V0Q3VycnJlbnRJdGVtO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lLmlzVHJlZU1vZGVsRm9ybWF0KCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dGxpbmUuY3VycmVudEl0ZW1bJyQkcGFyZW50SXRlbSddXG4gICAgICAgICAgICAgICAgICAgID0gKDxPdXRsaW5lTm9kZT50aGlzLnNldEN1cnJyZW50SXRlbSkucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm91dGxpbmUuaXNUcmVlTW9kZWxGb3JtYXQoKSAmJiBpc1ByZXNlbnQodGhpcy5zZXRQYXJlbnRJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lLmN1cnJlbnRJdGVtWyckJHBhcmVudEl0ZW0nXSA9IHRoaXMuc2V0UGFyZW50SXRlbTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdXRsaW5lRm9yQ29tcG9uZW50fSBmcm9tICcuLi9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuaW1wb3J0IHtPdXRsaW5lU3RhdGV9IGZyb20gJy4uL291dGxpbmUtc3RhdGUnO1xuXG5cbi8qKlxuICogT3V0bGluZUNvbnRyb2xDb21wb25lbnQgcmVuZGVycyB0aGUgaW5kZW50YXRpb24sIGFycm93LCBhbmQgdGV4dCBmb3IgYSBub2RlIGluIGFuIG91dGxpbmUuXG4gKiBJdCBzaG91bGQgYmUgdXNlZCBlaXRoZXIgaW4gdGhlIGJvZHkgb2YgYW4gT3V0bGluZUZvciBjb21wb25lbnQsIG9yIGluc2lkZSBkYXRhdGFibGVcbiAqXG4gKlxuICogIyNVc2FnZSBpbnNpZGUgYm9keTpcbiAqXG4gKiAgSGVyZSB5b3UgY2FuIHNlZSB0aGF0IHdlIG5lZWQgdG8gd3JhcCBvdXQgY29udGVudCBpbnNpZGUgbmctdGVtcGxhdGUgd2hpY2ggd2lsbCBwdXNoIHVzXG4gKiAgZ2l2ZSB1cyBjdXJyZW50IGl0ZW0gaXRlbSBhbmQgdGhlbiB3ZSBjYW4gcGxhY2UgT3V0bGluZUNvbnRyb2xDb21wb25lbnQgdG8gY29udHJvbFxuICogIHRoZSB0cmVlLlxuICpcbiAqIGBgYFxuICogIDxhdy1vdXRsaW5lLWZvcjIgI29vbyBbbGlzdF09XCJsaXN0XCIgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCI+XG4gKlxuICogICAgICA8bmctdGVtcGxhdGUgI291dGxpbmUgbGV0LWl0ZW0+XG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPVwibXktc2VjdGlvblwiPlxuICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvdXRsaW5lXCI+XG4gKiAgICAgICAgICAgICAgICAgIDxhdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICA8L2F3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICA8L2Rpdj4qXG4gKiAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICA8L2F3LW91dGxpbmUtZm9yMj5cbiAqXG4gKlxuICogYGBgXG4gKlxuICogV2UgY2FuXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1vdXRsaW5lLWNvbnRyb2wnLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIENvbnRyb2wgaXMganVzdCB0aGUgdHdvIGZsZXggYm94IGl0ZW1zIGZvciBkaXNwbGF5aW5nIGV4cGFuZC9jb2xsYXBzZSBpY29uIGFuZCBjb250ZW50XG5cbiAgICBTaW5jZSB3ZSBhbmltYXRlIG9ubHkgc3RhbmRhbG9uZS9ub24tZW1iZWRkZWQgY2FzZSBub3cgdGhlbiB3ZSBuZWVkIHRvIGFsc28gYW5pbWF0ZSB0aGUgaWNvblxuICAgIHNvIHdlIHVzZSBvbmx5IGljb24tc2xpbS1hcnJvdy1yaWdodCBhbmQgZG8gdHJhbmZvcm1hdGlvbiBvbiB0b3Agb2YgdGhpcyB0byBtYWtlIGl0IHJvdGF0ZS5cblxuICAgIElmIGVtYmVkZGVkIGNhc2Ugd2UgdXNlIGJvdGggaWNvbnMgaWNvbi1zbGltLWFycm93LXJpZ2h0IC8gaWNvbi1zbGltLWFycm93LWRvd25cbi0tPlxuPGRpdiBjbGFzcz1cInctb3V0bGluZS1jb250cm9sXCJcbiAgICAgW25nQ2xhc3NdPVwieydvdXRsaW5lLXUtdW5zZWxlY3RhYmxlLXRleHQnOiBvdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiAhaXRlbS4kJHBhcmVudEl0ZW19XCI+XG4gICAgPGRpdiBjbGFzcz1cIm91dGxpbmUtaWNvbiBzYXAtaWNvblwiXG4gICAgICAgICAqbmdJZj1cIiFvdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSB8fCAhaXNSb290SXRlbVwiXG4gICAgICAgICAoY2xpY2spPVwidG9nZ2xlRXhwYW5zaW9uKCRldmVudClcIlxuICAgICAgICAgW3N0eWxlLm1hcmdpbi1sZWZ0LnB4XT1cImluZGVudGF0aW9uXCJcbiAgICAgICAgIFtuZ0NsYXNzXT1cImNhbGN1bGF0ZVN0eWxlQ2xhc3MoKVwiPlxuICAgIDwvZGl2PlxuXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImFsbG93U2VsZWN0aW9uOyB0aGVuIHdpdGhTZWxlY3Rpb24gZWxzZSB3aXRob3V0U2VsZWN0aW9uXCI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cblxuPCEtLVxuIFdlIHN1cHBvcnQgdHdvIGNhc2UgZm9yIHRoZSBjb250ZW50XG5cbiBTZWxlY3Rpb246IFdoZW4geW91IGNsaWNrIG9uIHRoZSBjb250ZW50IGl0IHdpbGwgYWRkIGV4dHJhIGNsYXNzIHNvIHlvdSBjYW4gc3R5bGUgY3VycmVudGx5XG4gc2VsZWN0ZWQgaXRlbSBhcyB3ZWxsIGFzIGJyb2FkY2FzdCBldmVudCBvdXRzaWRlIHNvIGRldmVsb3BlciBjYW4gaG9vayBpbiBzb21lIGN1c3RvbSBsb2dpY1xuXG4gSWYgd2UgZG9udCBzdXBwb3J0IHNlbGVjdGlvbjogVGhlbiBjbGlja2luZyBvbiB0aGUgY29udGVudCBpcyBqdXN0IGxpa2UgY2xpY2tpbmcgb24gZXhwYW5kYWJsZVxuIGljb24sIGl0IHRvZ2dsZXMgdGhlIHN0YXRlXG4tLT5cblxuPG5nLXRlbXBsYXRlICN3aXRoU2VsZWN0aW9uPlxuICAgICA8c3BhbiBjbGFzcz1cIm91dGxpbmUtY29udGVudCBvdXRsaW5lLWNvbnRlbnQtc2VsZWN0ZWRcIiAqbmdJZj1cIiFhbGxvd0VkaXQgJiYgaXNTZWxlY3RlZCgpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJuZ0NvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJvdXRsaW5lLWNvbnRlbnRcIiAqbmdJZj1cIiFhbGxvd0VkaXQgJiYgIWlzU2VsZWN0ZWQoKVwiIChjbGljayk9XCJzZWxlY3QoKVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibmdDb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9zcGFuPlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjd2l0aG91dFNlbGVjdGlvbj5cbiAgICA8c3BhbiAqbmdJZj1cIiFhbGxvd0VkaXRcIiBjbGFzcz1cIm91dGxpbmUtY29udGVudFwiIChjbGljayk9XCJ0b2dnbGVFeHBhbnNpb24oJGV2ZW50KVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibmdDb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9zcGFuPlxuICAgIDxzcGFuICpuZ0lmPVwiYWxsb3dFZGl0XCIgY2xhc3M9XCJvdXRsaW5lLWNvbnRlbnRcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5nQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNuZ0NvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9uZy10ZW1wbGF0ZT5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnctb3V0bGluZS1jb250cm9se292ZXJmbG93OmhpZGRlbjtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOm5vd3JhcDtjdXJzb3I6cG9pbnRlcn0udy1vdXRsaW5lLWNvbnRyb2wgLm91dGxpbmUtaWNvbntmbGV4OjAgMCAxNXB4O2NvbG9yOiNhYmFiYWI7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NzAwO21pbi13aWR0aDoxMXB4O2FsaWduLXNlbGY6Y2VudGVyO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gNTBtcyBlYXNlLWluO3RyYW5zaXRpb246dHJhbnNmb3JtIDUwbXMgZWFzZS1pbjt0cmFuc2l0aW9uOnRyYW5zZm9ybSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNTBtcyBlYXNlLWluOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjoyNSUgNjUlO3RyYW5zZm9ybS1vcmlnaW46MjUlIDY1JTstd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2R9Lnctb3V0bGluZS1jb250cm9sIC5vdXRsaW5lLWljb24ub3V0bGluZS1pY29uLWV4cGFuZGVkey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9Lnctb3V0bGluZS1jb250cm9sIC5vdXRsaW5lLWNvbnRlbnR7ZmxleDoxIDEgYXV0bztmbGV4LXdyYXA6d3JhcDtwYWRkaW5nOjAgNHB4fS53LW91dGxpbmUtY29udHJvbCAub3V0bGluZS1jb250ZW50Lm91dGxpbmUtY29udGVudC1zZWxlY3RlZHtjdXJzb3I6ZGVmYXVsdDtmb250LXdlaWdodDo3MDB9Lm91dGxpbmUtdS11bnNlbGVjdGFibGUtdGV4dHstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1vLXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6YXV0b31gXSxcbn0pXG5leHBvcnQgY2xhc3MgT3V0bGluZUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGl0ZW1zIHRoYXQgbmVlZHMgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBJZiBUUlVFIGl0IGNoYW5nZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBvdXRsaW5lIG5vZGUgdGV4dCB3aGljaCBjbGljayBpcyB0cmlnZ2VyZWRcbiAgICAgKiAgaXQgc2VsZWN0cyB0aGUgaXRlbSBhbmQgYnJvYWRjYXN0IHRoZSBgb25JdGVtU2VsZWN0ZWRgIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsbG93U2VsZWN0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGFsbG93RWRpdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyBhY3Rpb24gd2hlbiBvdXRsaW5lIGl0ZW0gaXMgZXhwYW5kZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGl0ZW0gdXNlZCBmb3IgdGhpcyBgT3V0bGluZUNvbnRyb2xgXG4gICAgICpcbiAgICAgKi9cbiAgICBpdGVtOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIGluZGVudGF0aW9uIHVzZWQgdG8gc2hpZnQgdGhlIG5lc3RlZCBzZWN0aW9uIHRvIHRoZSBsZWZ0LiBUaGlzIGlzIHVzZWQgZm9yXG4gICAgICogZW1iZWRkZWQgbW9kZSBlLmcuIHRyZWUgdGFibGUgd2hlcmUgd2UgY2Fubm90IGluZGVudCBwYXJlbnRcbiAgICAgKi9cbiAgICBpbmRlbnRhdGlvbjogbnVtYmVyO1xuXG5cbiAgICBpc1Jvb3RJdGVtOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gT3V0bGluZVN0YXRlKSlcbiAgICAgICAgICAgICAgICBwcml2YXRlIG91dGxpbmVTdGF0ZTogT3V0bGluZVN0YXRlLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBwYXJlbnRDb250cm9sOiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gT3V0bGluZUZvckNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHVibGljIG91dGxpbmVGb3I6IE91dGxpbmVGb3JDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLnByZXBhcmVDb250cm9sKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdlIGRvbnQgc2hvdyBleHBhbnNpb24gaWNvbnMgd2hlbiB0aGVyZSBubyBjaGlsZHJlblxuICAgICAqXG4gICAgICovXG4gICAgaGFzRXhwYW5zaW9uQ29udHJvbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLmhhc0NoaWxkcmVuKHRoaXMuaXRlbSkgJiYgdGhpcy5vdXRsaW5lRm9yLnNob3dFeHBhbnNpb25Db250cm9sO1xuICAgIH1cblxuXG4gICAgaXNTZWxlY3RlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLnN0YXRlLnNlbGVjdGVkSXRlbSA9PT0gdGhpcy5pdGVtO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVN0eWxlQ2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXhwYW5zaW9uQ29udHJvbCgpIHx8XG4gICAgICAgICAgICAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBpc0JsYW5rKHRoaXMuaXRlbS4kJHBhcmVudEl0ZW0pKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5lbWJlZGRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5pc0V4cGFuZGVkKHRoaXMuaXRlbSkgPyAnaWNvbi1zbGltLWFycm93LWRvd24nXG4gICAgICAgICAgICAgICAgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaXNFeHBhbmRlZCh0aGlzLml0ZW0pXG4gICAgICAgICAgICAgICAgPyAnaWNvbi1zbGltLWFycm93LXJpZ2h0IG91dGxpbmUtaWNvbi1leHBhbmRlZCcgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbmQgZXhwYW5kcyBjdXJyZW50IG5vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmN1cnJlbnRQYXRoID0gW107XG4gICAgICAgIGxldCBjdXJyZW50UGF0aCA9IHRoaXMuaXRlbTtcblxuICAgICAgICB3aGlsZSAoaXNQcmVzZW50KGN1cnJlbnRQYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmN1cnJlbnRQYXRoLnVuc2hpZnQoY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgY3VycmVudFBhdGggPSBjdXJyZW50UGF0aC4kJHBhcmVudEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm91dGxpbmVGb3IudG9nZ2xlRXhwYW5zaW9uKCk7XG4gICAgICAgIGxldCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgaXRlbTogdGhpcy5pdGVtLFxuICAgICAgICAgICAgZXhwYW5kZWQ6IHRoaXMub3V0bGluZUZvci5zdGF0ZS5pc0V4cGFuZGVkKHRoaXMuaXRlbSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3Rpb24uZW1pdChwYXlsb2FkKTtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLm9uRXhwYW5kQ2hhbmdlLmVtaXQocGF5bG9hZCk7XG5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5zZWxlY3RlZEl0ZW0gPSB0aGlzLml0ZW07XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5vbkl0ZW1TZWxlY3RlZC5lbWl0KHRoaXMuaXRlbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmVwYXJlQ29udHJvbCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm91dGxpbmVGb3IpICYmIGlzUHJlc2VudCh0aGlzLm91dGxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvciA9IHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3I7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvciksICdNaXNzaW5nIG91dGxpbmVGb3IgY29tcG9uZW50Jyk7XG4gICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXZlbCAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gKHRoaXMub3V0bGluZUZvci5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbSA9IHRoaXMub3V0bGluZUZvci5jdXJyZW50SXRlbTtcbiAgICAgICAgdGhpcy5pc1Jvb3RJdGVtID0gaXNCbGFuayh0aGlzLml0ZW0uJCRwYXJlbnRJdGVtKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5pdE5lc3RpbmdEaXJlY3RpdmUsIE91dGxpbmVGb3JDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7T3V0bGluZUNvbnRyb2xDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBPdXRsaW5lRm9yQ29tcG9uZW50LFxuICAgICAgICBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgSW5pdE5lc3RpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE91dGxpbmVGb3JDb21wb25lbnQsXG4gICAgICAgIE91dGxpbmVDb250cm9sQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV091dGxpbmVGb3JNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCB0ZXh0IGFyZWEgY29tcG9uZW50XG5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdteU5vdGUnICxcbiAqICAgICAgICAgIHRlbXBsYXRlOiAnPGF3LXRleHQtYXJlYSBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFthdXRvUmVzaXplXT1cImF1dG9SZXNpemVcIiA+XG4gKiAgICAgICAgICAgICAgPC9hdy10ZXh0LWFyZWE+J1xuICogICAgICB9KVxuICogICAgICBleHBvcnQgY2xhc3MgTXlOb3RlQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHJlYWxseSBsb25nIHRleHQnO1xuICogICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2U7XG4gKiAgICAgIH1cbiAqXG4gKiBgYGBcbiAqICBOb3RlOiBpZiB5b3UgYXJlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBGb3JtVGFibGUgcGxlYXNlIHByb3ZpZGUgeW91ciBvd24gRm9ybUdyb3VwXG4gKi9cblxuZXhwb3J0IGNvbnN0IFRFWFRBUkVBX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10ZXh0LWFyZWEnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj1cImVkaXRhYmxlXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIj5cblxuXHQ8dGV4dGFyZWFcbiAgICAgICAgcElucHV0VGV4dGFyZWFcbiAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgY2xhc3M9XCJ3LXRleHQtYXJlYVwiXG4gICAgICAgIFtjbGFzcy51LXZhbGlkYXRpb24tZXJyb3JdPVwiIShmb3JtQ29udHJvbC52YWxpZCB8fCAoZm9ybUNvbnRyb2wucHJpc3RpbmUpKVwiXG4gICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIGZvcm1Db250cm9sTmFtZT1cInt7bmFtZX19XCJcbiAgICAgICAgW3Jvd3NdPVwicm93c1wiXG4gICAgICAgIFtjb2xzXT1cImNvbHVtbnNcIlxuICAgICAgICBbYXV0b1Jlc2l6ZV09XCJhdXRvUmVzaXplXCJcbiAgICAgICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIlxuXG4gICAgPjwvdGV4dGFyZWE+XG5cbjwvZGl2PlxuXG5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhZWRpdGFibGVcIj5cbiAgICA8YXctc3RyaW5nIFt2YWx1ZV09XCJ2YWx1ZVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFRFWFRBUkVBX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEFyZWFDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVGV4dEFyZWFDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHN0b3JlIGFuZCByZWFkIHVzZXIgaW5wdXRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVmaWZpZXMgdmlzaWJsZSBudW1iZXIgb2YgbGluZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd3M6IG51bWJlciA9IDI7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB2aXNpYmxlIHdpZHRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2x1bW5zOiBudW1iZXIgPSAyMDtcblxuXG4gICAgLyoqXG4gICAgICogd2hlbiB0aGlzIG9wdGlvbiBpcyBUUlVFIGFuZCB1c2VyIHN0YXJ0cyB0eXBpbmcgaXQgd2lsbCBtYXhpbWl6ZSB0ZXh0YXJlYSdzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGF1dG9SZXNpemU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgICApLnN1YnNjcmliZSh2YWwgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwge29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5wdXRUZXh0YXJlYU1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7VGV4dEFyZWFDb21wb25lbnR9IGZyb20gJy4vdGV4dC1hcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG5cbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXVGV4dEFyZWFNb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBQYWdlLU5vdGlmaWNhdGlvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGEgbm90aWZpY2F0aW9uIHN5c3RlbSBmb3IgdGhlIHVzZXIgcmVnYXJkaW5nXG4gKiB0aGUgY3VycmVudCBvYmplY3QgaGUncyB3b3JraW5nIG9uLiBUeXBpY2FsIG5vdGlmaWNhdGlvbiBhcmU6XG4gKiAgICAgIFN1Y2Nlc3MgLSBzYXZlZC5cbiAqICAgICAgV2FybmluZyAtIFNvdXJjaW5nIHJlcXVlc3QgcmVxdWlyZXMgMyBzdXBwbGllcnMuXG4gKiAgICAgIEVycm9yICAgLSBjYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXIsIGNoZWNrIGludGVybmV0IGNvbm5lY3Rpb24uXG4gKlxuICpcbiAqXG4gKiBVc2FnZSAxOiAgQXMgcGFydCBvZiBwYWdlIHdyYXBwZXIuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdNeVBhZ2UnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8YXctb2JqZWN0LXBhZ2Utd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwiTXlQYWdlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW29iamVjdFR5cGVdPVwiTXlUeXBlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJwYWdlTm90aWZpY2F0aW9uXCI+XG4gKiAgICAgICAgICAgICBwYWdlIGNvbnRlbnRcbiAqICAgICAgICAgIGBcbiAqICAgICAgIDwvYXctb2JqZWN0LXBhZ2VyLXdyYXBwZXI+XG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBwYWdlTm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uID0gbmV3IFBhZ2VOb3RpZmljYXRpb24oXCJ3YXJuXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUG9saWN5IFdhcm5pbmdcIiwgXCJUaGlzIHJlcXVlc3QgcmVxdWlyZXMgMyBiaWRzLlwiKTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIFVzYWdlIDI6IGRpcmVjdGx5IGludG8gdGhlIHBhZ2UuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxhdy1oZWFkZXI+PC9hdy1oZWFkZXI+XG4gKiAgICAgICAgUGFnZSBIZWFkZXJcbiAqXG4gKiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImhhc05vdGlmaWNhdGlvbnMoKVwiPlxuICogICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdS1ub3BhZGRpbmdcIj5cbiAqICAgICAgICAgICAgPGF3LXBhZ2Utbm90aWZpY2F0aW9uIFtub3RpZmljYXRpb25dPVwibm90aWZpY2F0aW9uXCI+PC9hdy1wYWdlLW5vdGlmaWNhdGlvbj5cbiAqICAgICAgICAgIDwvZGl2PlxuICogICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgICA8YXctZm9vdGVyPjwvYXctZm9vdGVyPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgbm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uID0gbmV3IFBhZ2VOb3RpZmljYXRpb24oXCJ3YXJuaW5nXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUG9saWN5IFdhcm5pbmdcIiwgXCJUaGlzIHJlcXVlc3QgcmVxdWlyZXMgMyBiaWRzLlwiKTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLW5vdGlmaWNhdGlvbicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicGFnZS1ub3RpZmljYXRpb25cIj5cbiAgICA8ZGl2IFtjbGFzc109XCJub3RpZmljYXRpb25DbGFzcygpXCI+XG4gICAgICAgIDxpIFtjbGFzc109XCJub3RpZmljYXRpb25JY29uKClcIj48L2k+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY29udGVudFwiPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRpdGxlXCI+e3tub3RpZmljYXRpb24udGl0bGV9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkZXNjcmlwdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJub3RpZmljYXRpb24uaGFzVGVtcGxhdGUoKTsgZWxzZSBkZXNjcmlwdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJub3RpZmljYXRpb24uY29udGVudFRtcGxcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNkZXNjcmlwdGlvbj57e25vdGlmaWNhdGlvbi5kZXNjcmlwdGlvbn19PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgPC9zcGFuPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS1ub3RpZmljYXRpb257bWFyZ2luOjAgMCA1cHh9Lm5vdGlmaWNhdGlvbi1lcnJvciwubm90aWZpY2F0aW9uLWluZm8sLm5vdGlmaWNhdGlvbi1zdWNjZXNzLC5ub3RpZmljYXRpb24td2FybmluZ3twYWRkaW5nOjlweCA4cHh9Lm5vdGlmaWNhdGlvbi1lcnJvciBpLC5ub3RpZmljYXRpb24taW5mbyBpLC5ub3RpZmljYXRpb24tc3VjY2VzcyBpLC5ub3RpZmljYXRpb24td2FybmluZyBpe2ZvbnQtc2l6ZToyNHB4O21hcmdpbjoxMHB4fS5ub3RpZmljYXRpb24tc3VjY2VzcyBpe2NvbG9yOiM1OGI5NTd9Lm5vdGlmaWNhdGlvbi1pbmZvIGl7Y29sb3I6IzE5OWRlMH0ubm90aWZpY2F0aW9uLXdhcm5pbmcgaXtjb2xvcjojZjkwfS5ub3RpZmljYXRpb24tZXJyb3IgaXtjb2xvcjojYzAwfS5ub3RpZmljYXRpb24tc3VjY2Vzc3tiYWNrZ3JvdW5kLWNvbG9yOiNmMWY5ZjE7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDg4LDE4NSw4NywuNSl9Lm5vdGlmaWNhdGlvbi1pbmZve2JhY2tncm91bmQtY29sb3I6I2VkZjhmZDtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjUsMTU3LDIyNCwuNSl9Lm5vdGlmaWNhdGlvbi13YXJuaW5ne2JhY2tncm91bmQtY29sb3I6I2ZmZjhkZDtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjU1LDE1MywwLC41KX0ubm90aWZpY2F0aW9uLWVycm9ye2JhY2tncm91bmQtY29sb3I6I2ZmZWJlYjtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMjA0LDAsMCwuNSl9Lmljb24tZXJyb3I6YmVmb3Jle2NvbnRlbnQ6XCJcXFxcRUE5RFwifS5pY29uLXdhcm5pbmc6YmVmb3Jle2NvbnRlbnQ6XCJcXFxcRUE5Q1wifS5jb250ZW50e3ZlcnRpY2FsLWFsaWduOnN1cGVyfS50aXRsZXtmb250LXdlaWdodDo3MDA7bWFyZ2luLXJpZ2h0OjEwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIEFueSBpbmZvLCBFcnJvciwgb3IgV2FybiBmb3IgdGhpcyBwYWdlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBub3RpZmljYXRpb25DbGFzcygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgbm90aWZpY2F0aW9uLSR7dGhpcy5ub3RpZmljYXRpb24udHlwZX1gO1xuICAgIH1cblxuICAgIG5vdGlmaWNhdGlvbkljb24oKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYGFyaWJhLWljb24gaWNvbi0ke3RoaXMubm90aWZpY2F0aW9uLnR5cGV9YDtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBQYWdlIE5vdGlmaWNhdGlvbiBhcmUgbWVzc2FnZXMgZm9yIHRoaXMgcGFnZSBvbmx5LiBJdCBkaXNwbGF5cyBpbiB0aGUgY2VudGVyIG9mIHRoZSBwYWdlXG4gKiByaWdodCB1bmRlciBwYWdlIHRpdGxlLiBUeXBpY2FsIHBhZ2Ugbm90aWZpY2F0aW9ucyBhcmUgJ3NhdmUgY29uZmlybWF0aW9uJyxcbiAqICdlcnJvciBkdXJpbmcgc3VibWl0Jywgd2FybmluZ3Mgb2YgZmllbGQgcmVxdWlyZW1lbnRzLCBldGMuXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlTm90aWZpY2F0aW9uXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHR5cGU6IFBhZ2VOb3RpZmljYXRpb25UeXBlLCBwdWJsaWMgdGl0bGU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgZGVzY3JpcHRpb246IHN0cmluZywgcHVibGljIGNvbnRlbnRUbXBsPzogVGVtcGxhdGVSZWY8YW55PilcbiAgICB7XG4gICAgfVxuXG4gICAgaGFzVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNvbnRlbnRUbXBsKTtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgKyAnLCB0aXRsZTogJyArIHRoaXMudGl0bGUgKyAnLCBkZXNjcmlwdGlvbjogICcgKyB0aGlzLmRlc2NyaXB0aW9uO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFnZU5vdGlmaWNhdGlvblR5cGUgPSAnc3VjY2VzcycgfCAnaW5mbycgfCAnd2FybmluZycgfCAnZXJyb3InO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50fSBmcm9tICcuL3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcblxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBwYWdlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VJbml0aWFsaXplZFxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0aXRsZTogc3RyaW5nKVxuICAgIHtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZUluaXRpYWxpemllZCh0aXRsZTogJHt0aGlzLnRpdGxlfSlgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgcGFnZSBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUGFnZURlc3Ryb3llZFxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0aXRsZTogc3RyaW5nKVxuICAgIHtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZURlc3Ryb3llZCh0aXRsZTogJHt0aGlzLnRpdGxlfSlgO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFnZUV2ZW50ID0gUGFnZUluaXRpYWxpemVkIHwgUGFnZURlc3Ryb3llZDtcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U3ViamVjdH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1BhZ2VEZXN0cm95ZWQsIFBhZ2VFdmVudCwgUGFnZUluaXRpYWxpemVkfSBmcm9tICcuL3BhZ2UtZXZlbnRzJztcblxuLyoqXG4gKiBQYWdlIExpZmVDeWNsZSBTZXJ2aWNlIG1vbml0b3JzIGFsbCBwYWdlIGluaXRpYWxpemF0aW9uIGFuZCBkZXN0cnVjdGlvbnMuXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIHNlcnZpY2UgaXMgdG8gaGVscCB0aGUgYXBwbGljYXRpb24gbW9uaXRvciBwYWdlIGxpZmVjeWNsZSwgc3Vic2NyaWJlXG4gKiB0byBsaWZlY3ljbGUgZXZlbnRzIGFuZCBleGVjdXRlIGFjdGlvbnMgc3VjaCBhcyB1c2VyIGFuYWx5dGljcy5cbiAqXG4gKiBVc2FnZTpcbiAqXG4gKiAgICAxLiAgSW5qZWN0IFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlIGludG8geW91ciBjb25zdHJ1Y3RvclxuICpcbiAqICAgIGNvbnN0cnVjdG9yKHBhZ2VMaWZlY3ljbGU6UGFnZUxpZmVDeWNsZVNlcnZpY2UpIHtcbiAqICAgICAgICBwYWdlTGlmZWN5Y2xlLnBhZ2VFdmVudHMuc3Vic2NyaWJlKGV2ZW50OkV2ZW50ID0+IHtcbiAqICAgICAgICAgICAgaWYoZXZlbnQgaW5zdGFuY2VvZiBQYWdlSW5pdGlhbGl6ZWQpIHtcbiAqICAgICAgICAgICAgfVxuICogICAgICAgICAgICAvLyBQYWdlRGVzdHJveWVkXG4gKlxuICogICAgICAgIH0pO1xuICogICAgIH1cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlXG57XG5cbiAgICAvKipcbiAgICAgKiBQYWdlIGV2ZW50IHF1ZXVlIHdoZW4gYWxsIHBhZ2UgbGlmZWN5Y2xlIGV2ZW50czogaW5pdCwgZGVzdHJveSBhcmUgZW1pdHRlZC5cbiAgICAgKiBMaXN0ZW5lcnMgY2FuIHN1YnNjcmliZSB0byB0aGVzZSBldmVudHMuXG4gICAgICovXG4gICAgcHVibGljIHBhZ2VFdmVudHM6IFN1YmplY3Q8UGFnZUV2ZW50PiA9IG5ldyBTdWJqZWN0PFBhZ2VFdmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHBhZ2UgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIHBhZ2VUaXRsZVxuICAgICAqL1xuICAgIHB1YmxpYyBvblBhZ2VJbml0KHBhZ2VUaXRsZTogc3RyaW5nKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlRXZlbnRzLm5leHQobmV3IFBhZ2VJbml0aWFsaXplZChwYWdlVGl0bGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHdoZW4gcGFnZSBoYXMgYmVlbiBkZXN0cm95ZWRcbiAgICAgKiBAcGFyYW0gdGl0bGVcbiAgICAgKi9cbiAgICBwdWJsaWMgb25QYWdlRGVzdHJveShwYWdlVGl0bGU6IHN0cmluZyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucGFnZUV2ZW50cy5uZXh0KG5ldyBQYWdlRGVzdHJveWVkKHBhZ2VUaXRsZSkpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4uLy4uL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlTGlmZUN5Y2xlU2VydmljZX0gZnJvbSAnLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IHBhZ2UgdHlwZXMgaW4gYW4gYXBwbGljYXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIFBhZ2VUeXBlIHtcbiAgICBJbml0LCAgICAgICAgIC8vIEluaXQgUGFnZSB0eXBlXG4gICAgTG9naW4sICAgICAgICAvLyBMb2dpbiBQYWdlXG4gICAgT2JqZWN0LCAgICAgICAvLyBPYmplY3QgZGV0YWlsIHBhZ2VcbiAgICBMaXN0LCAgICAgICAgIC8vIExpc3QgUGFnZVxuICAgIE1hc3RlckRldGFpbCwgLy8gTWFzdGVyRGV0YWlsXG4gICAgRGFzaGJvYXJkLCAgICAvLyBEYXNoYm9hcmQgcGFnZVxuICAgIE1vZGFsICAgICAgICAgLy8gTW9kYWwgcGFnZSwgaXQgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gYmUgYSBwb3B1cCwgb3Igc3RhbmRhbG9uZSBwYWdlLlxufVxuXG4vKiogUGxhY2Vob2xkZXIgbm93LiBUaGUgRXJyb3IgTWFuYWdlciBoYW5kbGVzIGFsbCB0aGUgZXJyb3JzIG9uIHRoZSBwYWdlLlxuICogIEl0IGlzIGluaXRpYWxpemVkIGZvciBldmVyeSBwYWdlLiBQYWdlIGVycm9ycywgd2FybmluZywgaW5mbyBnb2VzIHRocm91Z2hcbiAqICB0aGUgZXJyb3IgTWFuYWdlciBhbmQgdGhlIHJlc3VsdCBtZXNzYWdlIGlzIGRpc3BsYXllZCBvbiB0aGUgcGFnZSBub3RpZmljYXRpb24gYXJlYS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yTWFuYWdlclxue1xuXG59XG5cbi8qKlxuICogIFBhZ2Ugd3JhcHBlciBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIHBhZ2VzLiBUaGUgaWRlYSBpcyB0aGF0IHRoZXJlIGFyZSBkaWZmZXJlbnQgcGFnZSB0eXBlc1xuICogIGluIGFuIEFwcGxpY2F0aW9uLiBBIExpc3QgUGFnZSByZW5kZXJzIGEgbGlzdCBvZiBvYmplY3RzLCBleDogY3VzdG9tZXJzLCByZXF1ZXN0cywgUE8uICBBbmRcbiAqICBhIG9iamVjdCBwYWdlIHdpbGwgcmVuZGVyIG9uZSBvYmplY3QgaW4gZGV0YWlsLlxuICpcbiAqICBUaGV5IHNoYXJlIGNvbW1vbiBhdHRyaWJ1dGVzIHN1Y2ggYXMgcGFnZSB0eXBlIGFuZCBwYWdlIGlkLlxuICpcbiAqICBBcmliYSBQYWdlIGhhdmUgYSBsaWZlIGN5Y2xlLiBXaGVuIHBhZ2Ugc3RhcnRzIHVwLCBpdCdzIGluaXRpYWxpemVkLiBBbmQgd2hlbiB0aGUgcGFnZSBpc1xuICogIGRlc3Ryb3llZCwgaXQnbGwgYmUgY29tcGxldGUuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQYWdlV3JhcHBlciBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBXaGF0IHR5cGUgb2YgcGFnZSB0aGlzIGlzLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBhZ2VUeXBlOiBQYWdlVHlwZSA9IFBhZ2VUeXBlLkluaXQ7XG5cbiAgICAvKipcbiAgICAgKiBQYWdlIElkLiBVc2VkIHdoZW4gcGFnZXMgYXJlIHN0b3JlZCBpbiBtYXAuXG4gICAgICovXG4gICAgaWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEhhbmRsaW5nIGFsbCB0aGUgZXJyb3Igb24gYSBwYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBlcnJvck1hbmFnZXI6IEVycm9yTWFuYWdlcjtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRoYXQgdGhpcyBwYWdlIHdyYXBwZXIgaGFzIGJlZW4gd3JhcHBlZCBieSBhbm90aGVyIHBhZ2Ugd3JhcHBlci5cbiAgICAgKiBJbiB0aGlzIGNhc2UsIHdlIHdvdWxkbid0IGRpc3BsYXkgaGVhZGVyIGFuZCBmb290ZXIgYW5kIG90aGVyIHBhZ2Ugd3JhcHBlciBjb21wb25lbnRzXG4gICAgICovXG4gICAgYWxyZWFkeUluUGFnZVdyYXBwZXI6IGJvb2xlYW47XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwYWdlVHlwZTogUGFnZVR5cGUsXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFnZUxpZmVjeWNsZVNlcnZpY2U6IFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgdGhpcy5wYWdlVHlwZSA9IHBhZ2VUeXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbCBzdWJjbGFzcyBuZWVkcyB0byBnZW5lcmF0ZWQgYSBwYWdlIGlkZW50aWZpZXIuXG4gICAgICogSXQgZm9sbG93cyB0aGUgZm9sbG93aW5nIHBhdHRlcm46XG4gICAgICogICAgdHlwZV90aXRsZV9pZFxuICAgICAqXG4gICAgICogICAgUkZRX1NvdXJjaW5nUmVxdWVzdF8xMjNcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBnZW5lcmF0ZVBhZ2VJZCgpOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHVuaXF1ZSBJZCBmb3IgdGhpcyBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGdldElkKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuZ2VuZXJhdGVQYWdlSWQoKTtcbiAgICB9XG5cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7UGFnZU1lbnVJdGVtfSBmcm9tICcuLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiAgVGhpcyBpcyBhIHRlbXBvcmFyeSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIHBhZ2UgaGVhZGVyIGNvbXBvbmVudC5cbiAqICBXaGVuIHRoZSByZWFsIGltcGxlbWVudGF0aW9uIG9mIHNpZGUgbWVudSBpcyBkb25lLCBQYWdlSGVhZGVyQ29tcG9uZW50IHdpbGxcbiAqICBiZSBzd2FwZWQgdG8gdXNlIGl0LlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zaWRlbmF2JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgW25nQ2xhc3NdPVwiZ2V0U2lkZW5hdkNsYXNzKClcIj5cbiAgICA8ZGl2IGNsYXNzPVwic2lkZW5hdi1jb250ZW50XCI+XG4gICAgICAgIDxhICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCIgW3JvdXRlckxpbmtdPVwiaXRlbS5saW5rXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInNpZGVuYXYtaWNvblwiPjxpIFtuZ0NsYXNzXT1cIidzYXAtaWNvbiAnICsgaXRlbS5pY29uXCI+PC9pPjwvc3Bhbj5cbiAgICAgICAgICAgIHt7aXRlbS5sYWJlbH19XG4gICAgICAgIDwvYT5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnNpZGVuYXZ7aGVpZ2h0OjEwMCU7d2lkdGg6MDtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjE7dG9wOjUwcHg7bGVmdDowO2JhY2tncm91bmQtY29sb3I6IzM2MzYzNjtvdmVyZmxvdy14OmhpZGRlbjtwYWRkaW5nLXRvcDoyMHB4O3RyYW5zaXRpb246LjVzfS5zaWRlbmF2LWFjdGl2ZXt3aWR0aDoyNTBweH0uc2lkZW5hdiBhe3BhZGRpbmc6OHB4IDhweCA4cHggMzJweDt0ZXh0LWRlY29yYXRpb246bm9uZTtmb250LXNpemU6MTZweDtjb2xvcjojZmZmO2Rpc3BsYXk6YmxvY2s7dHJhbnNpdGlvbjouM3N9LnNpZGVuYXYgYTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxMTF9LnNpZGVuYXYtaWNvbntmb250LXNpemU6MzBweDtjb2xvcjojY2NjO21hcmdpbi1yaWdodDoxMHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVuYXZDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBtZW51IGl0ZW1zXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpdGVtczogUGFnZU1lbnVJdGVtW107XG5cbiAgICAvKipcbiAgICAgKiBkaXNwbGF5cyB0aGUgYmFjayBsaW5rIHRoYXQgbmF2aWdhdGVzIHVzZXIgdG8gdGhlIHByZXZpb3VzIHBhZ2Ugd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvdzogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgZ2V0U2lkZW5hdkNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgLy8gT25seSBzaG93IGlmIEkgaGF2ZSBpdGVtc1xuICAgICAgICByZXR1cm4gKHRoaXMuc2hvdyAmJiB0aGlzLml0ZW1zKSA/ICdzaWRlbmF2IHNpZGVuYXYtYWN0aXZlJyA6ICdzaWRlbmF2JztcbiAgICB9XG5cbiAgICBvcGVuKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvdyA9ICF0aGlzLnNob3c7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnQsIFJvdXRpbmdTZXJ2aWNlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7U2lkZW5hdkNvbXBvbmVudH0gZnJvbSAnLi4vc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBIZWFkZXIgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yIGZvciBhbiBBcmliYSBwYWdlLlxuICogSGVhZGVyIGluY2x1ZGVzIGEgbWVudSwgdXNlciBwcm9maWxlLCBhbmQgYWxlcnRzLlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgPGF3LXBhZ2UtaGVhZGVyIFtzaG93QmFja0FjdGlvbl09XCJ0cnVlXCIgdXNlck5hbWU9XCJDaGFkIE5vbGxcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWVudUl0ZW1zXT1cIm1lbnVJdGVtc1wiIFtub3RpZmljYXRpb25zXT1cInVzZXJOb3RpZmljYXRpb25zXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1jZW50ZXJcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXZiYXItYnJhbmRcIiB0YWJpbmRleD1cIjBcIiBocmVmPVwiL1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cIm5hdmJhci1sb2dvXCIgc3JjPVwiLi9pbWFnZXMvU0FQX0FyaWJhX0RCLnBuZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiR28gdG8gaG9tZXBhZ2VcIiBkYXRhLXBpbi1ub3Bpbj1cInRydWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgPC9hdy1wYWdlLWhlYWRlcj5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICogICAgICBtZW51SXRlbXM6IFBhZ2VNZW51SXRlbVtdID0gW25ldyBQYWdlTWVudUl0ZW0oJ2ljb24taG9tZScsICdIb21lJywgJy9wbGF5LycpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1leHBlbnNlLXJlcG9ydCcsICdSZXBvcnRzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvcGFnZWhlYWRlcicpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1zYWxlcy1vcmRlcicsICdQdXJjaGFzZSBPcmRlcicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvcGFnZWhlYWRlcicpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1hY2NvdW50JywgJ0FjY291bnRzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvcGFnZWhlYWRlcicpXTtcbiAqXG4gKiAgICAgdXNlck5vdGlmaWNhdGlvbnM6IFVzZXJOb3RpZmljYXRpb25bXSA9IFtcbiAqICAgICAgIG5ldyBVc2VyTm90aWZpY2F0aW9uKCdpY29uLWV4cGVuc2UtcmVwb3J0JywgJ0V4cGVuc2UgcmVwb3J0IEVYUDQ1MyBoYXMgYmVlbiBhcHByb3ZlZC4nLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS8nKSxcbiAqICAgICAgICAgbmV3IFVzZXJOb3RpZmljYXRpb24oJ2ljb24tc2FsZXMtb3JkZXInLCAnU2FsZXMgT3JkZXIgU08xMjM0IGhhcyBiZWVuIGNyZWF0ZWQuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvJyksXG4gKiAgICAgICAgICAgbmV3IFVzZXJOb3RpZmljYXRpb24oJ2ljb24tYWNjb3VudCcsICdTdXBwbGllciBhY2NvdW50IFNBMTIzNCBoYXMgYmVlbiB1cGRhdGVkLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvJylcbiAqICAgICAgICBdO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxuYXYgY2xhc3M9XCJuYXZiYXIgcGFnZS1oZWFkZXJcIiByb2xlPVwibmF2aWdhdGlvblwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtNCBuYXZiYXItbGVmdFwiPlxuXG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzTWVudUl0ZW1zKClcIj5cbiAgICAgICAgICAgIDxhIChjbGljayk9XCJzaG93SGlkZU1lbnUoKVwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwic2FwLWljb24gaWNvbi1wYWdpbmdcIj48L2k+XG4gICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDwhLS0gU2lkZSBtZW51IC0tPlxuICAgICAgICAgICAgPGF3LXNpZGVuYXYgI3NpZGVtZW51IFtpdGVtc109XCJtZW51SXRlbXNcIj48L2F3LXNpZGVuYXY+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwhLS0gRW5kIEhhbWJ1cmdlciBtZW51LiAtLT5cblxuICAgICAgICAgICAgPCEtLSAgYmFjayBhY3Rpb24gLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJhY2stYWN0aW9uXCI+XG4gICAgICAgICAgICA8YSAoY2xpY2spPVwiYmFja0FjdGlvbigpXCI+XG4gICAgICAgICAgICAgICAgPGkgKm5nSWY9XCJzaG93QmFja0FjdGlvblwiIGNsYXNzPVwic2FwLWljb24gaWNvbi1hcnJvdy1sZWZ0XCIgcm9sZT1cImJ1dHRvblwiPjwvaT5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLW1kLTQgbmF2YmFyLWNlbnRlclwiPlxuXG4gICAgICAgICAgICA8IS0tIGNlbnRyYWwgc2VjdGlvbi4gIEFwcGxpY2F0aW9uIGNhbiBhZGQgQXJpYmEtbG9nbywgc2VhcmNoIGJveCwgZXRjIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2UtaGVhZGVyLWNlbnRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtNCBuYXZiYXItcmlnaHRcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJ1c2VyTmFtZVwiPlxuICAgICAgICAgICAgPGltZyBpZD1cInVzZXJQcm9maWxlUGljdHVyZVwiIGNsYXNzPVwicHJvZmlsZS1sb2dvXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgW3RpdGxlXT1cInVzZXJOYW1lXCIgc3JjPVwie3thc3NldEZvbGRlcn19L2ltYWdlcy9kZWZhdWx0X2ltYWdlX3NtYWxsLnBuZ1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwcm9maWxlLXVzZXJcIiB0aXRsZT1cInt7dXNlck5hbWV9fVwiPnt7dXNlck5hbWV9fTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFoaWRlTm90aWZpY2F0aW9uXCIgY2xhc3M9XCJub3RpZmljYXRpb24tY29udGFpbmVyXCI+XG5cbiAgICAgICAgICAgIDxpICNub3RpZmljYXRpb25JY29uIGNsYXNzPVwiYXJpYmEtaWNvbiBpY29uLW5vdGlmaWNhdGlvblwiXG4gICAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlTm90aWZpY2F0aW9uUGFuZWwoKVwiPjwvaT5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzTm90aWZpY2F0aW9ucygpXCIgY2xhc3M9XCJub3RpZmljYXRpb24tYmFkZ2VcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57e25vdGlmaWNhdGlvbnMubGVuZ3RofX08L3NwYW4+XG5cbiAgICAgICAgICAgICAgICA8IS0tIE9yaWdpbmFsbHkgSSB3YXMgdXNpbmcgcC1vdmVybGF5LXBhbmVsLCBob3dldmVyLCBpdCBkb2Vzbid0IHBvc2l0aW9uIGNvcnJlY3RseSB1bmRlciB0aGUgbm90aWZpY2F0aW9uIGljb24uXG4gICAgICAgICAgICAgICAgICAgICBUaGUgcG9zaXRpb25pbmcgbG9naWMgaW4gcHJpbWUgbmcgbmVlZHMgc29tZSBtb3JlIGludmVzdGlnYXRpb24uIFNvIGZvciBub3csIHVzZSBhIGRpdiBpbnN0ZWFkLS0+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd05vdGlmaWNhdGlvblBhbmVsXCIgY2xhc3M9XCJub3RpZmljYXRpb24tcGFuZWxcIj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJub3RpZmljYXRpb24taGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICBOb3RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJub3RpZmljYXRpb24tY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IG5vdGkgb2Ygbm90aWZpY2F0aW9uc1wiIGNsYXNzPVwibm90aWZpY2F0aW9uLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cIm5vdGkubGlua1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibm90aWZpY2F0aW9uLWl0ZW0taWNvblwiPjxpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIidzYXAtaWNvbiAnICsgbm90aS5pY29uXCI+PC9pPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e25vdGkubGFiZWx9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cblxuXG4gICAgPC9kaXY+XG48L25hdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLWhlYWRlciBpe2ZvbnQtc2l6ZTozMnB4fS5wYWdlLWhlYWRlciAuaWNvbi1wYWdpbmd7Zm9udC1zaXplOjMwcHg7cG9zaXRpb246cmVsYXRpdmU7dG9wOjJweH0uYmFjay1hY3Rpb257ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6MTVweH0uYmFjay1hY3Rpb24gaXtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6M3B4fS5uYXZiYXJ7YmFja2dyb3VuZDojMDAwO2NvbG9yOiNmZmZ9Lm5hdmJhci1sZWZ0e3BhZGRpbmctbGVmdDoxNXB4O2hlaWdodDo1MHB4fS5uYXZiYXItY2VudGVye3RleHQtYWxpZ246Y2VudGVyO2hlaWdodDo1MHB4fS5uYXZiYXItcmlnaHR7dGV4dC1hbGlnbjpyaWdodDtoZWlnaHQ6NTBweH0ucHJvZmlsZS1sb2dve3dpZHRoOjMwcHg7aGVpZ2h0OjMwcHg7cG9zaXRpb246cmVsYXRpdmU7dG9wOjJweH0ucHJvZmlsZS11c2Vye3ZlcnRpY2FsLWFsaWduOnN1cGVyO21hcmdpbi1yaWdodDozMHB4fS5pY29uLW5vdGlmaWNhdGlvbjpiZWZvcmV7Y29udGVudDpcIlxcXFxlQTE0XCJ9Lm5hdmJhciAjc2lkZWJhci1tZW51LWljb257cG9zaXRpb246cmVsYXRpdmU7dG9wOi41ZW19Lm5vdGlmaWNhdGlvbi1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLXJpZ2h0OjIwcHg7ZGlzcGxheTppbmxpbmUtYmxvY2t9Lm5vdGlmaWNhdGlvbi1iYWRnZXtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA1cHg7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojYzAwO2JvcmRlci1yYWRpdXM6MTBweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjE2cHh9Lm5vdGlmaWNhdGlvbi1wYW5lbHtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMjdweDt0b3A6NDVweDt3aWR0aDozNTBweDtjb2xvcjojNzY3Njc2O2JveC1zaGFkb3c6MCAycHggMTBweCAwIHJnYmEoMCwwLDAsLjEzKTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7b3ZlcmZsb3c6aGlkZGVuO3RyYW5zaXRpb246YWxsIC4zcyBlYXNlLWluLW91dH0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taGVhZGVye2JhY2tncm91bmQtY29sb3I6I2YzZjNmMztmb250LXNpemU6MTZweDtoZWlnaHQ6NTBweDtsaW5lLWhlaWdodDo1MHB4O3RleHQtYWxpZ246Y2VudGVyfS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1jb250ZW50e3BhZGRpbmc6MDttYXJnaW46MH0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taXRlbXtoZWlnaHQ6NTBweDtib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3O3BhZGRpbmc6MTVweCAxMHB4O3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1pdGVtIGF7Y29sb3I6Izc2NzY3Njt0ZXh0LWRlY29yYXRpb246bm9uZTtsaW5lLWhlaWdodDozNXB4fS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1pdGVtOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2Y3ZjhmYX0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taXRlbS1pY29ue21hcmdpbi1yaWdodDoxNXB4O2NvbG9yOiM3Njc2NzY7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXRvcDoxMHB4O3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBtZW51IGVudHJpZXMuIFRoZSBwYWdlIG1lbnUgaWNvbiB3aWxsIG9ubHkgZGlzcGxheSB3aGVuIHRoaXMgbGlzdCBpcyBub3QgZW1wdHkuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtZW51SXRlbXM6IFBhZ2VNZW51SXRlbVtdO1xuXG4gICAgLyoqXG4gICAgICogbGlzdCBvZiB1c2VyIG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm90aWZpY2F0aW9uczogVXNlck5vdGlmaWNhdGlvbltdO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSB1c2VyIG5vdGlmaWNhdGlvbiBpY29uIGJlIGhpZGRlbi4gRGVmYXVsdCBpdCB0byBzaG93IHRoZSBpY29uIGV2ZW5cbiAgICAgKiBpZiB0aGVyZSdzIG5vIG5vdGlmaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGVOb3RpZmljYXRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBiYWNrIGxpbmsgdGhhdCBuYXZpZ2F0ZXMgdXNlciB0byB0aGUgcHJldmlvdXMgcGFnZSB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93QmFja0FjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsb2dnZWQgaW4gdXNlciBuYW1lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlck5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWRlbWVudVxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3NpZGVtZW51JylcbiAgICBzaWRlbmF2OiBTaWRlbmF2Q29tcG9uZW50O1xuXG4gICAgc2hvd05vdGlmaWNhdGlvblBhbmVsOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJvdXRpbmc6IFJvdXRpbmdTZXJ2aWNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIGJhY2tBY3Rpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5yb3V0aW5nLmdvQmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvIGkgaGF2ZSBhbnkgbWVudSBpdGVtcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc01lbnVJdGVtcygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMubWVudUl0ZW1zICYmIHRoaXMubWVudUl0ZW1zLmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgc2lkZSBuYXZpZ2F0aW9uIG1lbnUuXG4gICAgICovXG4gICAgc2hvd0hpZGVNZW51KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2lkZW5hdi50b2dnbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBJIGhhdmUgYW55IG5vdGlmaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNOb3RpZmljYXRpb25zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ub3RpZmljYXRpb25zKSAmJiB0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGluZyB3aGVhdGhlciBub3RpZmljYXRpb24gcGFuZWwgaXMgZGlzcGxheWVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICB0b2dnbGVOb3RpZmljYXRpb25QYW5lbCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb25QYW5lbCA9ICF0aGlzLnNob3dOb3RpZmljYXRpb25QYW5lbDtcbiAgICB9XG59XG5cbi8qKlxuICogUGFnZU1lbnVJdGVtIHJlcHJlc2VudHMgYW4gaXRlbSBpbiB0aGUgcGFnZSBtZW51IHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VNZW51SXRlbVxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpY29uICAgIC0gSWNvbiBvZiB0aGlzIG1lbnUgaXRlbS5cbiAgICAgKiBAcGFyYW0gbGFiZWwgICAtIGxhYmVsIG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAcGFyYW0gbGluayAgICAtIGxpbmsgdG8gdGhlIGRlc3RpbmF0aW9uIHdoZW4gdXNlciBjbGlja3Mgb24gaXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHVibGljIGljb246IHN0cmluZywgcHVibGljIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHVibGljIGxpbms6IHN0cmluZylcbiAgICB7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYFBhZ2VNZW51SXRlbTogKGxhYmVsLCAke3RoaXMubGFiZWx9KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIG5vdGlmaWNhdGlvbiBmb3IgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXIuXG4gKiBFeDogIFBSMjA0OSBoYXMgYmVlbiBhcHByb3ZlZC5cbiAqICAgICAgT3JkZXIgUE81MTggcmVjZWl2ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBVc2VyTm90aWZpY2F0aW9uXG57XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWNvbiAgIC0gYWxlcnQgbm90aWZpY2F0aW9uIGljb25cbiAgICAgKiBAcGFyYW0gbGFiZWwgIC0gYWxlcnQgbm90aWZpY2F0aW9uIGxhYmVsXG4gICAgICogQHBhcmFtIGxpbmsgICAtIGxpbmtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaWNvbjogc3RyaW5nLCBwdWJsaWMgbGFiZWw6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgbGluazogc3RyaW5nKVxuICAgIHtcblxuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlVXNlck5vdGlmaWNhdGlvbjogKGxhYmVsLCAke3RoaXMubGFiZWx9KWA7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEZvb3RlciBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuXG4gKiBUaGlzIGZvb3RlciBjb21wb25lbnQgc2VsZiBjb250YWluZWQuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgICAgPGF3LXBhZ2UtZm9vdGVyPlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1mb290ZXItbG9nb1wiPlxuICogICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJpbWFnZXMvYXJpYmFfbG9nb193aGl0ZV9ia2dkLnBuZ1wiPlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtZm9vdGVyLXVzZXItaW5mb1wiPlxuICogICAgICAgICAgICAgICAgICAgQ2hhZCBOb2xsIChjbm9sbCkgbGFzdCB2aXNpdCB7e2xhc3RfdmlzaXRlZCB8IGRhdGU6J01NL2RkL3l5eXkgaDptbWEnIH19XG4gICogICAgICAgICAgICAgICAgICAgfCBCdXllciBPcmdhbml6YXRpb25cbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGFnZS1mb290ZXItY29weXJpZ2h0XCIgI2NvcHlyaWdodD5cbiAqICAgICAgICAgICAgICAgICAgIDxwPsOCwqkgMjAyMMOiwoDCkzIwMjggVGhlIEZ1dHVyZSwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkPC9wPlxuICogICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgPC9hdy1wYWdlLWZvb3Rlcj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWZvb3RlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicGFnZS1mb290ZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwidWktZ1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC04XCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLWZvb3Rlci1sb2dvXCI+PC9uZy1jb250ZW50PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXNlci1pbmZvXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2UtZm9vdGVyLXVzZXItaW5mb1wiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJmb290ZXItbGlua3NcIj5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYV90b3UuY2ZtXCI+VGVybXMgb2ZcbiAgICAgICAgICAgICAgICAgICAgVXNlPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIj48YVxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cDovL3d3dy5hcmliYS5jb20vbGVnYWwvYXJpYmFfc2VjdXJpdHlfcG9saWN5LmNmbVwiPlNlY3VyaXR5XG4gICAgICAgICAgICAgICAgICAgIERpc2Nsb3N1cmU8L2E+PC9saT5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYV9wcml2YWN5X3N0YXRlbWVudC5jZm1cIj5Qcml2YWN5XG4gICAgICAgICAgICAgICAgICAgIFN0YXRlbWVudDwvYT48L2xpPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhLXByaXZhY3ktc3RhdGVtZW50XCI+Q29va2llIFN0YXRlbWVudDwvYT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhLXByaXZhY3ktc3RhdGVtZW50XCI+UGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgU3RhdGVtZW50PC9hPjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC00XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidS1ib3R0b20tYWxpZ25cIj48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1LWhyaWdodCBjb3B5cmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1mb290ZXItY29weXJpZ2h0XCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gRGVmYXVsdCBDb3B5cmlnaHQgLS0+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd0RlZmF1bHRDb3B5cmlnaHRcIiBjbGFzcz1cInUtaHJpZ2h0IGNvcHlyaWdodFwiPlxuICAgICAgICAgICAgICAgIDxwPsOCwqkgMTk5NsOiwoDCkzIwMTcgQXJpYmEsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZDwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS1mb290ZXJ7YmFja2dyb3VuZDojZmZmO3BhZGRpbmc6MTVweCAwIDA7Zm9udC1zaXplOjExcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkN30ucGFnZS1mb290ZXIgLnVzZXItaW5mb3tjb2xvcjojY2NjfS5wYWdlLWZvb3RlciAudWktZ3ttYXJnaW46MCBhdXRvfS5wYWdlLWZvb3RlciAuY29weXJpZ2h0e2NvbG9yOiNjY2N9LmZvb3Rlci1saW5rc3tsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjAgLTE1cHg7cGFkZGluZzowO2ZvbnQtc2l6ZToxMHB4fS5mb290ZXItbGlua3MgbGl7ZmxvYXQ6bGVmdH0uZm9vdGVyLWxpbmtzOmFmdGVyLC5mb290ZXItbGlua3M6YmVmb3Jle2NvbnRlbnQ6XCIgXCI7ZGlzcGxheTp0YWJsZX0uZm9vdGVyLWxpbmtzOmFmdGVye2NsZWFyOmJvdGh9LmZvb3Rlci1saW5rcz5saSwuZm9vdGVyLWxpbmtzPmxpPmF7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9ja30uZm9vdGVyLWxpbmtzPmxpPmF7cGFkZGluZzoxMHB4IDE1cHg7Y29sb3I6IzE5OWRlMH1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlRm9vdGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIGNvcHlyaWdodCBjb250ZW50XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnY29weXJpZ2h0JykgY29weXJpZ2h0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBzaG93IGRlZmF1bHQgY29weXJpZ2h0LiBJZiBjb3B5cmlnaHQgaXMgcGFzc2VkIGluLCB0aGVuIHNob3cgdGhlIHBhc3NlZCBpbiBvbmUuXG4gICAgICovXG4gICAgc2hvd0RlZmF1bHRDb3B5cmlnaHQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd0RlZmF1bHRDb3B5cmlnaHQgPSAhaXNQcmVzZW50KHRoaXMuY29weXJpZ2h0KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4uLy4uLy4uL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlVHlwZSwgUGFnZVdyYXBwZXJ9IGZyb20gJy4uL3BhZ2Utd3JhcHBlcic7XG5pbXBvcnQge1BhZ2VOb3RpZmljYXRpb259IGZyb20gJy4uLy4uL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7UGFnZUhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi4vcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogT2JqZWN0IFBhZ2UgV3JhcHBlciBDb21wb25lbnQgcmVuZGVycyBhbnkgb2JqZWN0IGluc3RhbmNlIGluIGRldGFpbC4gSXQgaGFzIGEgdW5pZm9ybSBsYXlvdXQsXG4gKiBIZWFkZXIsIFBhZ2UgdGl0bGUsIFBhZ2Ugbm90aWZpY2F0aW9uLCBhY3Rpb25zLCBjb250ZW50LCBhbmQgRm9vdGVyLlxuICpcbiAqXG4gKiAgVXNhZ2U6XG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdSRlhQYWdlJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgPGF3LW9iamVjdC1wYWdlLXdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cInJmeEVudGl0eS5oZWFkZXJJbmZvLnRpdGxlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW29iamVjdFR5cGVdPVwicmZ4RW50aXR5LmhlYWRlckluZm8uZXZlbnRUeXBlU3RyaW5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJwYWdlTm90aWZpY2F0aW9uXCI+XG4gKlxuICpcbiAqICAgICAgICAgICA8YXctcGFnZS1hY3Rpb25zPlxuICogICAgICAgICAgICAgICA8YXctYnV0dG9uIFt0eXBlXT1cIidzdWJtaXQnXCIgW25hbWVdPVwiJ2VkaXQnXCIgW3ZhbHVlXT1cImVkaXRcIiBbc3R5bGVdPVwiJ3ByaW1hcnknXCI+XG4gKiAgICAgICAgICAgICAgICAgICBFZGl0XG4gKiAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbdHlwZV09XCInYnV0dG9uJ1wiIFtuYW1lXT1cIidjYW5jZWwnXCIgW3ZhbHVlXT1cImNhbmNlbFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiPlxuICogICAgICAgICAgICAgICAgICBDYW5jZWxcbiAqICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgPC9hdy1wYWdlLWFjdGlvbnM+XG4gKlxuICogICAgICAgICAgIDxhdy1wYWdlLWNvbnRlbnQ+XG4gKiAgICAgICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlNvdXJjaW5nIHJlcXVlc3QgaW5mb1wiIChvblN0YXRlQ2hhbmdlZCk9XCJvblN0YXRlQ2hhbmdlKCRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICA8bS1jb250ZXh0IFtvYmplY3RdPVwicmZ4RW50aXR5LmhlYWRlckluZm9cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlcmF0aW9uXT1cInRoaXMuZWRpdGFiaWxpdHlTdGF0ZS5oZWFkZXJJbmZvT3BcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ9XCJJbnNwZWN0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlHcm91cD1cIkhlYWRlckdlbmVyYWxcIlxuICogICAgICAgICAgICAgICAgICAgPlxuICogICAgICAgICAgICAgICAgICAgICAgIDxtLWluY2x1ZGUtY29tcG9uZW50PjwvbS1pbmNsdWRlLWNvbXBvbmVudD5cbiAqICAgICAgICAgICAgICAgICAgIDwvbS1jb250ZXh0PlxuICpcbiAqICAgICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtY29udGVudD5cbiAqICAgICAgIDwvYXctb2JqZWN0LXBhZ2Utd3JhcHBlcj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgUkZYUGFnZVxuICogICAge1xuICogICAgICAgLy8gVG8ga2VlcCB0cmFjayB3aGF0IHNlY3Rpb24gaXMgZWRpdGFibGUgYW5kIHdoaWNoIHJlYWQgb25seVxuICogICAgICAgZWRpdGFiaWxpdHlTdGF0ZTogRWRpdGFiaWxpdHlTdGF0ZTtcbiAqXG4gKiAgICAgICAvLyBDdXJyZW50IFJGWCBldmVudFxuICogICAgICAgcmZ4RW50aXR5OiBSZnhFdmVudEVudGl0eTtcbiAqXG4gKiAgICAgICAvLyBOb3RpZmljYXRpb25zXG4gKiAgICAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5cIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW9iamVjdC1wYWdlLXdyYXBwZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBhZ2Utd3JhcHBlclwiPlxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGlkZUhlYWRlclwiPlxuICAgICAgICA8YXctaW5jbHVkZS1jb21wb25lbnQgW25hbWVdPSdoZWFkZXIubmFtZSc+PC9hdy1pbmNsdWRlLWNvbXBvbmVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImFyYy1vYmplY3QtZGV0YWlsXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cblxuICAgICAgICAgICAgPCEtLSBwYWdlIGhlYWRlciAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2UtdGl0bGVcIj5cblxuICAgICAgICAgICAgICAgIDwhLS0gcGFnZSB0aXRsZSAtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy04IHVpLW1kLTggcGFnZS10aXRsZS10ZXh0XCI+e3t0aXRsZX19PC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy00IHVpLW1kLTQgcGFnZS1zdGF0dXNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvYmplY3Qtc3RhdHVzLWxhYmVsXCI+e3tvYmplY3RTdGF0dXNMYWJlbH19ICZuYnNwOzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvYmplY3Qtc3RhdHVzXCI+e3tvYmplY3RTdGF0dXN9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIHBhZ2UgYWN0aW9ucyAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2UtYWN0aW9uc1wiICpuZ0lmPVwiaGFzVG9wUGFnZUFjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJhY3Rpb25zVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc1RvcFBhZ2VBY3Rpb25zXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIG9iamVjdCBzdGF0ZXMgIGRpc3BsYXlzIG9ubHkgaWYgc3RhdGUgZXhpc3RzLiAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2Utc3RhdGVcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0zIHBhZ2Utc3RhdGUtbGVmdFwiIFtjbGFzcy5jb250ZW50XT1cImhhc09iamVjdFN0YXRlcygpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLXN0YXRlLWxlZnRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctNiBwYWdlLXN0YXRlLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaGFzT2JqZWN0U3RhdGVzKClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdGVwcGVyIFtzdGVwc109XCJvYmplY3RTdGF0ZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRTdGVwXT1cIm9iamVjdFN0YXRlSW5kZXhcIj48L2F3LXN0ZXBwZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTMgcGFnZS1zdGF0ZS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1zdGF0ZS1yaWdodFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgICAgIDwhLS0gUGFnZSBOb3RpZmljYXRpb24gLS0+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzTm90aWZpY2F0aW9ucygpXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdS1ub3BhZGRpbmdcIj5cblxuICAgICAgICAgICAgICAgICAgICA8YXctcGFnZS1ub3RpZmljYXRpb24gKm5nRm9yPVwibGV0IG5vdGlmaWNhdGlvbiBvZiBub3RpZmljYXRpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtub3RpZmljYXRpb25dPVwibm90aWZpY2F0aW9uXCI+PC9hdy1wYWdlLW5vdGlmaWNhdGlvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwhLS0gYWRkaXRpb25hbCBjb250ZW50IC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctcGFnZS1jb250ZW50XCI+PC9uZy1jb250ZW50PlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIHBhZ2UgYWN0aW9ucyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiBwYWdlLWFjdGlvbnMtYm90dG9tXCIgKm5nSWY9XCJoYXNCb3R0b21QYWdlQWN0aW9uc1wiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJhY3Rpb25zVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCb3R0b21QYWdlQWN0aW9uc1wiPjwvbmctdGVtcGxhdGU+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJwYWdlLXB1c2hcIj48L2Rpdj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWhpZGVGb290ZXJcIj5cbiAgICA8YXctaW5jbHVkZS1jb21wb25lbnQgW25hbWVdPSdmb290ZXIubmFtZSc+PC9hdy1pbmNsdWRlLWNvbXBvbmVudD5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS13cmFwcGVye2JhY2tncm91bmQtY29sb3I6I2YyZjJmMjttaW4taGVpZ2h0OjEwMCU7bWFyZ2luLWJvdHRvbTotMTAwcHh9LmFyYy1vYmplY3QtZGV0YWlse3BhZGRpbmc6MjBweH0ucGFnZS10aXRsZS10ZXh0e2ZvbnQtc2l6ZToyMnB4O2NvbG9yOiMwMDA7cGFkZGluZzoxNHB4IDB9LnBhZ2UtdGl0bGV7cGFkZGluZzo1cHggMDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZDdkN2Q3fS5wYWdlLWFjdGlvbnN7cGFkZGluZzoxNXB4IDAgNXB4fS5wYWdlLWFjdGlvbnMtYm90dG9te3BhZGRpbmc6MCAyMHB4fS5wYWdlLXN0YXRlLC5wYWdlLXN0YXRlLWNlbnRlciwucGFnZS1zdGF0ZS1sZWZ0LC5wYWdlLXN0YXRlLXJpZ2h0e3BhZGRpbmc6MH0uY29udGVudDo6YWZ0ZXJ7Y29udGVudDonXFxcXDAwYTAnO2ZvbnQtc2l6ZTowfS5wYWdlLXRpdGxlIC9kZWVwLyAudWktYnV0dG9ue21pbi13aWR0aDoxMDBweH0ucGFnZS1zdGF0dXN7dGV4dC1hbGlnbjpyaWdodDtwYWRkaW5nOjE4cHggMH0ucGFnZS1zdGF0dXMgLm9iamVjdC1zdGF0dXMtbGFiZWx7Y29sb3I6Izc2NzY3Nn0ucGFnZS1zdGF0dXMgLm9iamVjdC1zdGF0dXN7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiMwMzg3MTl9LnBhZ2UtcHVzaHtoZWlnaHQ6MTAwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgT2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnQgZXh0ZW5kcyBQYWdlV3JhcHBlciBpbXBsZW1lbnRzIE9uRGVzdHJveVxue1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoaXMgcGFnZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYmVpbmcgcmVuZGVyZWQgLSBFdmVudCwgV29ya3NwYWNlLCBjb250cmFjdCwgZXRjLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0VHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogbGFiZWwgZm9yIHRoZSBvYmplY3Qgc3RhdHVzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0U3RhdHVzTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0J3Mgc3RhdHVzLiBGb3IgZXhhbXBsZSwgZHJhZnQsIHBlbmRpbmcgc2VsZWN0aW9uLFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0U3RhdHVzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbC4gU29tZSBvYmplY3QgaGFzIHN0YXRlcy4gRm9yIGV4YW1wbGU6IFJGeE9iamVjdCBoYXMgUmVzb2x2ZSwgUmV2aWV3LCBHZXQgUXVvdGUuXG4gICAgICogT2JqZWN0IHN0YXRlcyB3aWxsIGFwcGVhciBvbiB0aGUgcGFnZSB3aGVuIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RTdGF0ZXM6IHN0cmluZ1tdO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIFN0ZXBwZXIgaXMgdXNlZCB0aGlzIGlkZW50aWZpZXMgY3VycmVudCBzZXQgc3RhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1cnJlbnRTdGF0ZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgaXMgYSBjb21wb25lbnQgdHlwZSB0byBiZSByZW5kZXJlZCBhcyBhIHBhZ2UgSGVhZGVyLlxuICAgICAqXG4gICAgICogVGhlICdkZWZhdWx0JyB2YWx1ZSBpcyB0aGUgY29tcG9uZW50L3dpZGdldC9IZWFkZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlYWRlcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRydWUgaWYgcGFnZSBzaG91bGQgbm90IGluY2x1ZGUgYW55IGhlYWRlci4gTmVlZCB0byBzZXQgdG8gdHJ1ZSBldmVuIG5vIGhlYWRlclxuICAgICAqIG9iamVjdCBpcyBwYXNzZWQgaW4uIE90aGVyd2lzZSwgYSBkZWZhdWx0IEhlYWRlciBjb21wb25lbnQgd2lsbCBiZSBhZGRlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGVIZWFkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZvb3RlciBDb21wb25lbnQgaXMgdGhlIHBhZ2UgZm9vdGVyLlxuICAgICAqIGNhbiBiZSBvdmVycmlkZW4gYnV0IHRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbXBvZW5lbnQvd2lkZ2V0L0Zvb3RlckNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvb3RlcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRydWUgaWYgcGFnZSBzaG91bGQgbm90IGluY2x1ZGUgYW55IGZvb3Rlci4gTmVlZCB0byBzZXQgdG8gdHJ1ZSBldmVuIG5vIGZvb3RlclxuICAgICAqIG9iamVjdCBpcyBwYXNzZWQgaW4uIE90aGVyd2lzZSwgYSBkZWZhdWx0IEZvb3RlciBjb21wb25lbnQgd2lsbCBiZSBhZGRlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGVGb290ZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbmluZyBvZiB0aGUgcGFnZSBhY3Rpb25zIChwYWdlIGJ1dHRvbnMpXG4gICAgICogICAndG9wJyA6ICAgIHBhZ2UgYnV0dG9ucyBhcmUgcGxhY2VkIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGJlbG93IHRoZSB0aXRsZSwgdG8gdGhlIHJpZ2h0LlxuICAgICAqICAgJ2JvdHRvbScgOiBwYWdlIGJ1dHRvbnMgYXJlIHBsYWNlZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLCBhYm92ZSB0aGUgZm9vdGVyLlxuICAgICAqICAgJ2JvdGgnICAgOiBwYWdlIGJ1dHRvbnMgYXJlIHBsYWNlZCBhdCBib3RoIHRvcCBhbmQgYm90dG9tLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYWdlQWN0aW9uUG9zaXRpb246IHN0cmluZyA9ICd0b3AnO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZsYWcgaXMgZHJpdmVuIGJ5IHBhZ2VBY3Rpb25Qb3NpdGlvbi4gVGhlIGRlZmF1bHQgcG9zaXRpb24gaXMgdG9wLlxuICAgICAqIFZhbHVlIGlzIHRydWUgZm9yIGJvdGggJ3RvcCcgYW5kICdib3RoJyBvZiBwYWdlQWN0aW9uUG9zaXRpb24uXG4gICAgICovXG4gICAgaGFzVG9wUGFnZUFjdGlvbnM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmbGFnIGlzIGRyaXZlbiBieSBwYWdlQWN0aW9uIHBvc2l0aW9uLlxuICAgICAqIFZhbHVlIGlzIHRydWUgZm9yIGJvdGggJ2JvdHRvbScgYW5kICdib3RoJyBvZiBwYWdlQWN0aW9uUG9zaXRpb24uXG4gICAgICovXG4gICAgaGFzQm90dG9tUGFnZUFjdGlvbnM6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBwIHRlbXBsYXRlIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ3BhZ2VBY3Rpb25zJylcbiAgICBhY3Rpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBBbnkgU3VjY2VzcywgSW5mbywgRXJyb3IsIG9yIFdhcm4gZm9yIHRoaXMgcGFnZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vdGlmaWNhdGlvbnM6IFBhZ2VOb3RpZmljYXRpb25bXTtcblxuXG4gICAgb2JqZWN0U3RhdGVJbmRleDogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnksIHBhZ2VMaWZlY3ljbGVTZXJ2aWNlOiBQYWdlTGlmZUN5Y2xlU2VydmljZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgUGFnZVR5cGUuT2JqZWN0LCBjb21wb25lbnRSZWdpc3RyeSwgcGFnZUxpZmVjeWNsZVNlcnZpY2UpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgRGVmYXVsdCBoZWFkZXIgY29tcG9uZW50XG4gICAgICAgIHRoaXMuaGVhZGVyID0gUGFnZUhlYWRlckNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5mb290ZXIgPSBQYWdlRm9vdGVyQ29tcG9uZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdW5pcXVlIElkIGZvciB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGdlbmVyYXRlUGFnZUlkKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0VHlwZSArICdfJyArIHRoaXMudGl0bGUgKyAodGhpcy5pZCkgPyAoJ18nICsgdGhpcy5pZCkgOiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIG15IHBhZ2UgaGF2ZSBwYWdlIG5vdGlmaWNhdGlvbj9cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc05vdGlmaWNhdGlvbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5vdGlmaWNhdGlvbnMgJiYgdGhpcy5ub3RpZmljYXRpb25zLmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIGhhc09iamVjdFN0YXRlcygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMub2JqZWN0U3RhdGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG15IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIC8vIE5ldyBDb21wb25lbnQgdHlwZXMgdGhhdCBhcmUgdXNlZCBpbiBjLWluY2x1ZGUtY29tcG9uZW50XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRSZWdpc3RyeS5yZWdpc3RlclR5cGUodGhpcy5oZWFkZXIubmFtZSwgdGhpcy5oZWFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV3IENvbXBvbmVudCB0eXBlcyB0aGF0IGFyZSB1c2VkIGluIGMtaW5jbHVkZS1jb21wb25lbnRcbiAgICAgICAgaWYgKHRoaXMuZm9vdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyVHlwZSh0aGlzLmZvb3Rlci5uYW1lLCB0aGlzLmZvb3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogbm90aWZ5IHN1YnNjcmliZXJzIG9mIHRoZSBwYWdlIGxpZmVjeWNsZSBzZXJ2aWNlICAqL1xuICAgICAgICB0aGlzLnBhZ2VMaWZlY3ljbGVTZXJ2aWNlLm9uUGFnZUluaXQodGhpcy50aXRsZSk7XG5cbiAgICAgICAgLy8gU2V0dGluZyB0aGUgcGFnZSBhY3Rpb24gcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLnBhZ2VBY3Rpb25Qb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVG9wUGFnZUFjdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm90dG9tUGFnZUFjdGlvbnMgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlQWN0aW9uUG9zaXRpb24gPT09ICdib3RoJykge1xuXG4gICAgICAgICAgICB0aGlzLmhhc1RvcFBhZ2VBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm90dG9tUGFnZUFjdGlvbnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm9iamVjdFN0YXRlcykgJiYgdGhpcy5vYmplY3RTdGF0ZXMubGVuZ3RoID4gMVxuICAgICAgICAgICAgJiYgaXNQcmVzZW50KHRoaXMuY3VycmVudFN0YXRlKSkge1xuXG4gICAgICAgICAgICB0aGlzLm9iamVjdFN0YXRlSW5kZXggPSB0aGlzLm9iamVjdFN0YXRlcy5pbmRleE9mKHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlc1snY3VycmVudFN0YXRlJ10pICYmXG4gICAgICAgICAgICBjaGFuZ2VzWydjdXJyZW50U3RhdGUnXS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXNbJ2N1cnJlbnRTdGF0ZSddLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbnQgbmVlZCB0byBjaGVjayBpZiBvYmplY3RTdGF0ZXMgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLm9iamVjdFN0YXRlSW5kZXggPSB0aGlzLm9iamVjdFN0YXRlcy5pbmRleE9mKHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKVxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlTGlmZWN5Y2xlU2VydmljZS5vblBhZ2VEZXN0cm95KHRoaXMudGl0bGUpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFBhZ2UgYWN0aW9ucyBpcyBhIHdyYXBwZXIgZm9yIGFsbCBwYWdlIGFjdGlvbnMsIGJ1dHRvbnMsIGxpbmtzLCBtZW51cyB0aGF0IGludGVyYWN0cyBpdCB3aXRoIHRoZVxuICogcGFnZS4gVGhlIHdyYXBwZXIgdXNlIHRoZSBhYmlsaXR5IHRvIHBvc2l0aW9uIGl0IGFzIG5lZWRlZC5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWFjdGlvbnMnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBhZ2UtYWN0aW9uc1wiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2UtYWN0aW9uc3t0ZXh0LWFsaWduOnJpZ2h0O3BhZGRpbmctdG9wOjA7cGFkZGluZy1yaWdodDowfWBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VBY3Rpb25zQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBQYWdlIGNvbnRlbnQgaXMgYSB3cmFwcGVyIGZvciBwYWdlIGNvbnRlbnQuXG4gKiBDdXJyZW50bHksIGl0J3MgcHJldHR5IGJhcmUsIGJ1dCBhcyB3ZSBhZGQgbW9yZSBpbnRlcmFjdGlvbnMgb24gdGhlIHBhZ2UsIGxpa2UgYSBzaWRlIGJhcixcbiAqIHRoZSBwYWdlIGNvbnRlbnQgYXJlYSB3aWxsIGxpa2VseSBnZXQgYWZmZWN0ZWQuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1jb250ZW50JyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgIHN0eWxlczogWyc6aG9zdCB7d2lkdGg6IDEwMCU7IHBhZGRpbmc6IDAgLjVlbTt9J11cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUNvbnRlbnRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG5cbmNvbnN0IFNURVBQRVJfQ09NUExFVEVEX1NURVBfQ09MT1IgPSAnIzU4Yjk1Nyc7XG5jb25zdCBTVEVQUEVSX0NVUlJFTlRfU1RFUF9DT0xPUiA9ICcjMDA3NkNCJztcbmNvbnN0IFNURVBQRVJfUkVNQUlOSU5HX1NURVBfQ09MT1IgPSAnI0Q3RDdENyc7XG5cbi8qKlxuICogU3RlcHBlciBjb21wb25lbnQgZGlzcGxheXMgYSBsaXN0IG9mIHN0ZXBzIGZvciB1c2VyIHRvIGZvbGxvdy4gSXQgY2FuIGJlIHVzZWQgYXMgYSBjaGVja2xpc3RcbiAqIHRvIGluZGljYXRlIGNvbXBsZXRlZCwgY3VycmVudCBhbmQgcmVtYWluaW5nIGl0ZW1zLiBJdCBjb3VsZCBiZSBhbHNvIGJlIHVzZWQgdG8gaW5kaWNhdGVcbiAqIHRoZSBzdGF0ZSBvZiBhbiBkb2N1bWVudCwgY3JlYXRlZCwgc3VibWl0dGVkLCBhcHByb3ZlZCwgZXRjLi4uXG4gKlxuICpcbiAqIFVzYWdlOlxuICogICAxLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLiBwcm92aWRlIGEgbGlzdCBvZiBzdGVwcyBhbmQgdGhlIGN1cnJlbnQgc3RlcC5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgPGF3LXN0ZXBwZXIgW3N0ZXBzXT1cInN0ZXBzXCIgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCI+PC9hdy1zdGVwcGVyPlxuICpcbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBzdHJpbmdbXSA9IFsnTW9uaXRvcicsICdBZGQgU3VwcGxpZXInLCAnR2V0IFF1b3RlJ107XG4gKiAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBudW1iZXIgPSAxO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICogICAgICAgfVxuICpcbiAqICAgMi4gIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGNvbG9ycy5cbiAqXG4gKiAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RlcHBlciBbc3RlcHNdPVwic3RlcHNcIiBbc3RlcENvbG9yQ3VycmVudF09XCInI2ZmOTkwMCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBDb2xvclJlbWFpbmluZ109XCInI0NDMDAwMCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBDb2xvckNvbXBsZXRlZF09XCInIzk3YTgyMidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LXN0ZXBwZXI+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdGVwcGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJzdGVwcGVyLWNvbnRhaW5lclwiPlxuICAgIDxkaXYgY2xhc3M9XCJzdGVwc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcC1zcGFjaW5nXCI+PC9kaXY+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGk9aW5kZXg7IGxldCBsYXN0PWxhc3Q7XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcFwiPlxuICAgICAgICAgICAgICAgIDxhdy1zdGVwIFt0aXRsZV09XCJzdGVwXCIgW2NvbG9yXT1cImdldFN0ZXBDb2xvcihpKVwiPjwvYXctc3RlcD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cIiFsYXN0XCIgY2xhc3M9XCJzdGVwLWNvbm5lY3RvclwiIFtzdHlsZS53aWR0aF09XCJjb25uZWN0b3JXaWR0aFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb25uZWN0b3JcIiBbc3R5bGUuYm9yZGVyQm90dG9tQ29sb3JdPVwiZ2V0Q29ubmVjdG9yQ29sb3IoaSlcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcC1zcGFjaW5nXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic3RlcC1sYWJlbHNcIj48L2Rpdj5cbjwvZGl2PlxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYC5zdGVwcGVyLWNvbnRhaW5lcntkaXNwbGF5OnRhYmxlO3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5zdGVwc3tkaXNwbGF5OnRhYmxlLXJvd30uc3RlcC1zcGFjaW5ne2Rpc3BsYXk6dGFibGUtY2VsbDt3aWR0aDoxMCV9LnN0ZXB7ZGlzcGxheTp0YWJsZS1jZWxsO3dpZHRoOjMycHh9LnN0ZXAtY29ubmVjdG9ye2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmNvbm5lY3RvcntoZWlnaHQ6MXB4O2JvcmRlci1ib3R0b206M3B4IHNvbGlkICM1OGI5NTd9LnN0ZXAtbGFiZWxze2Rpc3BsYXk6dGFibGUtcm93O2hlaWdodDo1MHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIFN0ZXBwZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogUmVxdWlyZWRcbiAgICAgKiBBcnJheSBvZiBzdGVwcy4gT3JkZXIgb2YgdGhlIHN0ZXBzIHNob3VsZCBiZSBpbiBhcnJheSBvcmRlci5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBzOiBzdHJpbmdbXTtcblxuXG4gICAgLyoqXG4gICAgICogc3BlY2lmeSB0aGUgY29sb3JzIGFzc29jaWF0ZWQgd2l0aCBzdGVwcyBhYm92ZS4gVGhlIG51bWJlciBvZiBjb2xvcnNcbiAgICAgKiBhbmQgbnVtYmVyIG9mIHN0ZXBzIG11c3QgbWF0Y2guXG4gICAgICogT3B0aW9uYWw6LCBpZiBlbXB0eSwgZGVmYXVsdCBjb2xvcnMgb3IgY29sb3JzIGZyb20gc3RlcENvbG9yIGlucHV0cyB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2xvcnM6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgdmFyaWFibGUgdG8gaW5kaWNhdGUgd2hldGhlciB0byB1c2UgdGhlIGNvbG9ycyBhcnJheSBvciBub3QuXG4gICAgICovXG4gICAgYlVzZUNvbG9yQXJyYXk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIGNvbXBsZXRlZCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcENvbG9yQ29tcGxldGVkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiBjdXJyZW50IHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwQ29sb3JDdXJyZW50OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiByZW1haW5pbmcgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBDb2xvclJlbWFpbmluZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RlcCB0aGF0J3Mgb24uIElmIG5vdCBwcm92aWRlZCBkZWZhdWx0IHRvIHRoZSBmaXJzdCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0ZXA6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVkIHRoZSB3aWR0aCBvZiBjb25uZWN0b3JzIGJldHdlZW4gc3RlcHMuIFRoZSBjYWxjdWxhdGlvbnMgaXMgc29cbiAgICAgKiB0aGF0IHRoZSBzdGVwcyBhcmUgc3ByZWFkIG91dCBldmVubHkuXG4gICAgICovXG4gICAgY29ubmVjdG9yV2lkdGg6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgLy8gSW5pdGlhbCBjb2xvciBmb3IgdGhlIGRpZmZlcmVudCBzdGFnZXMgb2Ygc3RlcHMuXG4gICAgICAgIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkID0gU1RFUFBFUl9DT01QTEVURURfU1RFUF9DT0xPUjtcbiAgICAgICAgdGhpcy5zdGVwQ29sb3JDdXJyZW50ID0gU1RFUFBFUl9DVVJSRU5UX1NURVBfQ09MT1I7XG4gICAgICAgIHRoaXMuc3RlcENvbG9yUmVtYWluaW5nID0gU1RFUFBFUl9SRU1BSU5JTkdfU1RFUF9DT0xPUjtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbm5lY3RvciB3aWR0aCBiYXNlZCBvbiBob3cgbWFueSBzdGVwc1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RlcHMpICYmIHRoaXMuc3RlcHMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAvLyAoMTAwJSAtIDIwJSAoc2lkZSBtYXJnaW5zKSkgLyAoTnVtT2ZTdGVwcyAtMSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yV2lkdGggPSBNYXRoLmNlaWwoODAgLyAodGhpcy5zdGVwcy5sZW5ndGggLSAxKSkgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIHRoZSBjb2xvciBhcnJheSBpZiBpdCdzIGRlZmluZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY29sb3JzKSkge1xuXG4gICAgICAgICAgICB0aGlzLmJVc2VDb2xvckFycmF5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JzLmxlbmd0aCAhPT0gdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSBzdGVwcyBhbmQgY29sb3JzIGRvbid0IG1hdGNoOlxuICAgICAgICAgICAgICAgICAgKHN0ZXBzLmxlbmd0aCA9ICR7dGhpcy5zdGVwcy5sZW5ndGh9KSwgKGNvbG9ycy5sZW5ndGggPSAke3RoaXMuY29sb3JzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRpbmcgdGhlIGNvbG9yIG9mIHRoZSBzdGVwIGZvciB0aGUgY3VycmVudCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RlcENvbG9yKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICAvLyBDb2xvciBBcnJheSBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICBpZiAodGhpcy5iVXNlQ29sb3JBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ3VycmVudDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JSZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdG9yIGNvbG9ycyBhcmUgZHJpdmVuIGJ5IHRoZSBzdGVwIGNvbG9ycy5cbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbm5lY3RvckNvbG9yKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICAvLyBDb2xvciBBcnJheSBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICBpZiAodGhpcy5iVXNlQ29sb3JBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvclJlbWFpbmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RlcC5cbiAgICAgKi9cbiAgICBuZXh0U3RlcCgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmlvdXMgc3RlcC5cbiAgICAgKi9cbiAgICBwcmV2U3RlcCgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwLS07XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBSZW5kZXJzIGh0bWwgc3RlcCBjb21wb25lbnRcbiAqXG4gKiAgKiBVc2FnZTpcbiAqICAgICAgIFN0cmFpZ2h0IGZvcndhcmQgdG8gdXNlLiBCdXQgbW9zdGx5IGl0IHdvdWxkIGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgc3RlcHBlciBjb21wb25lbnQuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0ZXAgW3RpdGxlXT1cInN0ZXBcIiBbY29sb3JdPVwiY29sb3JcIj48L2F3LXN0ZXA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAqL1xuXG4gICAgLy8gRGVmYXVsdCBjb2xvciBmb3IgdGhpcyBzdGVwLlxuY29uc3QgREVGQVVMVF9DT0xPUiA9ICcjNThiOTU3JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdGVwJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJzdGVwLWNvbnRhaW5lclwiPlxuICAgIDxkaXYgY2xhc3M9XCJvdXRlci1jaXJjbGVcIiBbc3R5bGUuYm9yZGVyQ29sb3JdPVwiY29sb3JcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyLWNpcmNsZVwiIFtzdHlsZS5ib3JkZXJDb2xvcl09XCJjb2xvclwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiY29sb3JcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzdGVwLXRpdGxlXCI+e3t0aXRsZX19PC9kaXY+XG48L2Rpdj5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnN0ZXAtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjMycHh9Lm91dGVyLWNpcmNsZXt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6M3B4IHNvbGlkICM1OGI5NTc7cG9zaXRpb246cmVsYXRpdmV9LmlubmVyLWNpcmNsZXt3aWR0aDo4cHg7aGVpZ2h0OjhweDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkICM1OGI5NTc7YmFja2dyb3VuZC1jb2xvcjojNThiOTU3O21hcmdpbjowIGF1dG87cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSl9LnN0ZXAtdGl0bGV7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTUwcHg7dG9wOjQwcHg7bGVmdDotNjBweDt0ZXh0LWFsaWduOmNlbnRlcn1gXVxufSlcbmV4cG9ydCBjbGFzcyBTdGVwQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIG9mIHN0ZXAgaWNvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbG9yOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiB0aXRsZSBhcHBlYXJzIHVuZGVyIHRoZSBzdGVwIGdyYXBoaWNzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNvbG9yKSkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1N0ZXBwZXJDb21wb25lbnR9IGZyb20gJy4vc3RlcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtTdGVwQ29tcG9uZW50fSBmcm9tICcuL3N0ZXAvc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG5cbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU3RlcHBlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7UGFnZUxpZmVDeWNsZVNlcnZpY2V9IGZyb20gJy4vcGFnZS1saWZlY3ljbGUuc2VydmljZSc7XG5pbXBvcnQge09iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50fSBmcm9tICcuL29iamVjdC1wYWdlLXdyYXBwZXIvb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlQWN0aW9uc0NvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWFjdGlvbnMvcGFnZS1hY3Rpb25zLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VDb250ZW50Q29tcG9uZW50fSBmcm9tICcuL3BhZ2UtY29udGVudC9wYWdlLWNvbnRlbnQuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWZvb3Rlci9wYWdlLWZvb3Rlci5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RlcHBlck1vZHVsZX0gZnJvbSAnLi4vc3RlcHBlci9zdGVwcGVyLm1vZHVsZSc7XG5pbXBvcnQge1NpZGVuYXZDb21wb25lbnR9IGZyb20gJy4vc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0FXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZX0gZnJvbSAnLi4vcGFnZS1ub3RpZmljYXRpb24vcGFnZS1ub3RpZmljYXRpb24ubW9kdWxlJztcbmltcG9ydCB7Um91dGVyTW9kdWxlfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFBhZ2VDb250ZW50Q29tcG9uZW50LFxuICAgICAgICBQYWdlRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBTaWRlbmF2Q29tcG9uZW50XG5cbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdTdGVwcGVyTW9kdWxlLFxuICAgICAgICBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBQYWdlRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgUGFnZUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgT2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBQYWdlQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgUGFnZUZvb3RlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgU2lkZW5hdkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbUGFnZUxpZmVDeWNsZVNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIEFXUGFnZVdyYXBwZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBSaWNoVGV4dEFyZWEgY29tcG9uZW50IHJlcHJlc2VudHMgYSB0ZXh0IGVkaXRvciB3aGljaCBhbGxvd3MgdXNlcnMgdG8gZm9ybWF0IHRleHQgaW5wdXQuXG4gKiBUaGUgZWRpdG9yJ3MgdG9vbGJhciBpcyBwcmUtY29uZmlndXJlZCB0byBjb250YWluIGZ1bmN0aW9uYWxpdGllcyB0aGF0IGFyZSBpbiBvdXIgZGVzaWduLlxuICogQHNlZSB7QGxpbmsgZWRpdG9yL2VkaXRvci5jb21wb25lbnQuaHRtbH1cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JmeC1ldmVudCcgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgICAgPCEtLSBCYXNpYyBVc2FnZS4gLS0+XG4gKiAgICAgICAgPGF3LXJpY2h0ZXh0YXJlYSBbbmFtZV09XCInZGVzY3JpcHRpb24nXCIgW3ZhbHVlXT1cImRlc2NyaXB0aW9uXCIgcGxhY2VIb2xkZXI9XCJwdXRcbiAqICAgICAgICBkZXNjcmlwdGlvblwiPlxuICogICAgICAgIDwvYXctcmljaHRleHRhcmVhPlxuICpcbiAqICAgICAgICA8IS0tIEVkaXRvciB3aXRoIEZ1bGwgZnVuY3Rpb25hbGl0eSAtLT5cbiAqICAgICAgPGF3LXJpY2h0ZXh0YXJlYSBbbmFtZV09XCInY29tbWVudCdcIiBbdHlwZV09XCJlZGl0b3JUeXBlXCIgW3ZhbHVlXT1cInZhbHVlXCJcbiAqICAgICAgcGxhY2VIb2xkZXI9XCJob2xkIHRoaXNcIj5cbiAqICAgICAgPC9hdy1yaWNodGV4dGFyZWE+XG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgZWRpdG9yVHlwZTpFZGl0b3JUeXBlID0gRWRpdG9yVHlwZS5GdWxsO1xuICogICAgICAgIHZhbHVlOlN0cmluZztcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIHRleHQgZWRpdG9yLiBUaGV5IGFyZSBwcmVjb25maWd1cmVkIHdpdGhcbiAqIGZ1bmN0aW9uYWxpdHkgYmFzZWQgb24gdHlwZS4gVXNlIGN1c3RvbSB0byBhZGQgeW91ciBvd24gdG9vbGJhciBtZW51LlxuICovXG5leHBvcnQgZW51bSBFZGl0b3JUeXBlIHtcbiAgICBEZWZhdWx0LCAgICAvLyBEZWZhdWx0IEVkaXRvciBzdXBwb3J0cyBNaW5pbWFsIHNldCBvZiBmdW5jdGlvbmFsaXR5XG4gICAgLy8gWyBib2xkIHwgaXRhbGljIHwgdW5kZXJsaW5lIHwgb3JkZXJlZCB8IGJ1bGxldCB8IGFsaWdubWVudF1cbiAgICBGdWxsLCAgICAgICAvLyBUaGUgZnVsbCBsaXN0IG9mIGZ1bmN0aW9uYWxpdHksXG4gICAgVGV4dEZvcm1hdCwgLy8gRnVuY3Rpb25hbGl0aWVzIHRoYXQgYWZmZWN0cyB0ZXh0IGZvcm1hdHRpbmcuXG4gICAgQ3VzdG9tICAgICAvLyBDdXN0b20gdG9vbGJhci5cbn1cblxuXG5leHBvcnQgY29uc3QgRURJVE9SX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSaWNoVGV4dEFyZWFDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmljaHRleHRhcmVhJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlZGl0YWJsZVwiPlxuXG4gICAgPCEtLSBCYXNpYyBlZGl0b3IsIGFsc28gdGhlIGRlZmF1bHQsIHdoaWNoIHRoZSBtb3N0IHVzZWQgZmVhdHVyZXMgZW5hYmxlZC4gLS0+XG4gICAgPGRpdiAqbmdJZj1cInR5cGUgPT09IEVkaXRvclR5cGUuRGVmYXVsdFwiPlxuICAgICAgICA8cC1lZGl0b3IgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbc3R5bGVdPVwieydoZWlnaHQnOicxODBweCd9XCJcbiAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiPlxuICAgICAgICAgICAgPHAtaGVhZGVyPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1ib2xkXCIgYXJpYS1sYWJlbD1cIkJvbGRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1pdGFsaWNcIiBhcmlhLWxhYmVsPVwiSXRhbGljXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtdW5kZXJsaW5lXCIgYXJpYS1sYWJlbD1cIlVuZGVybGluZVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXRzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtbGlzdFwiIHZhbHVlPVwib3JkZXJlZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWxpc3RcIiB2YWx1ZT1cImJ1bGxldFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXRzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImxlZnRcIiBzZWxlY3RlZD48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwiY2VudGVyXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cInJpZ2h0XCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImp1c3RpZnlcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9wLWhlYWRlcj5cbiAgICAgICAgPC9wLWVkaXRvcj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRWRpdG9yIHdpdGggYWxsIHRoZSBmZWF0dXJlcyBlbmFibGVkIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJ0eXBlID09PSBFZGl0b3JUeXBlLkZ1bGxcIj5cbiAgICAgICAgPHAtZWRpdG9yIFsobmdNb2RlbCldPVwidmFsdWVcIiBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW3N0eWxlXT1cInsnaGVpZ2h0JzonMTgwcHgnfVwiXG4gICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIj48L3AtZWRpdG9yPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBFZGl0b3Igd2l0aCBhbGwgVGV4dCBmb3JtYXR0aW5nICAtLT5cbiAgICA8ZGl2ICpuZ0lmPVwidHlwZSA9PT0gRWRpdG9yVHlwZS5UZXh0Rm9ybWF0XCI+XG4gICAgICAgIDxwLWVkaXRvciBbKG5nTW9kZWwpXT1cInZhbHVlXCIgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFtzdHlsZV09XCJ7J2hlaWdodCc6JzE4MHB4J31cIlxuICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCI+XG4gICAgICAgICAgICA8cC1oZWFkZXI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdC1ncm91cFwiPlxuICAgICAgICAgICAgICA8c2VsZWN0IHRpdGxlPVwiRm9udFwiIGNsYXNzPVwicWwtZm9udFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzYW5zLXNlcmlmXCIgc2VsZWN0ZWQ9XCJcIj5TYW5zIFNlcmlmPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNlcmlmXCI+U2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwibW9ub3NwYWNlXCI+TW9ub3NwYWNlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICA8c2VsZWN0IHRpdGxlPVwiU2l6ZVwiIGNsYXNzPVwicWwtc2l6ZVwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxMHB4XCI+U21hbGw8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMTNweFwiIHNlbGVjdGVkPVwiXCI+Tm9ybWFsPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjE4cHhcIj5MYXJnZTwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIzMnB4XCI+SHVnZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWJvbGRcIiBhcmlhLWxhYmVsPVwiQm9sZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtaXRhbGljXCIgYXJpYS1sYWJlbD1cIkl0YWxpY1wiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtdW5kZXJsaW5lXCIgYXJpYS1sYWJlbD1cIlVuZGVybGluZVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdC1ncm91cFwiPlxuICAgICAgICAgICAgICA8c2VsZWN0IHRpdGxlPVwiVGV4dCBDb2xvclwiIGNsYXNzPVwicWwtY29sb3JcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMCwgMCwgMClcIiBzZWxlY3RlZD1cIlwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjMwLCAwLCAwKVwiIGxhYmVsPVwicmdiKDIzMCwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMTUzLCAwKVwiIGxhYmVsPVwicmdiKDI1NSwgMTUzLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDApXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAxMzgsIDApXCIgbGFiZWw9XCJyZ2IoMCwgMTM4LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMTAyLCAyMDQpXCIgbGFiZWw9XCJyZ2IoMCwgMTAyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNTMsIDUxLCAyNTUpXCIgbGFiZWw9XCJyZ2IoMTUzLCA1MSwgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjUwLCAyMDQsIDIwNClcIiBsYWJlbD1cInJnYigyNTAsIDIwNCwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyMzUsIDIwNClcIiBsYWJlbD1cInJnYigyNTUsIDIzNSwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDIwNClcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjA0LCAyMzIsIDIwNClcIiBsYWJlbD1cInJnYigyMDQsIDIzMiwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjA0LCAyMjQsIDI0NSlcIiBsYWJlbD1cInJnYigyMDQsIDIyNCwgMjQ1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjM1LCAyMTQsIDI1NSlcIiBsYWJlbD1cInJnYigyMzUsIDIxNCwgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTg3LCAxODcsIDE4NylcIiBsYWJlbD1cInJnYigxODcsIDE4NywgMTg3KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjQwLCAxMDIsIDEwMilcIiBsYWJlbD1cInJnYigyNDAsIDEwMiwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAxOTQsIDEwMilcIiBsYWJlbD1cInJnYigyNTUsIDE5NCwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDEwMilcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxODUsIDEwMilcIiBsYWJlbD1cInJnYigxMDIsIDE4NSwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxNjMsIDIyNClcIiBsYWJlbD1cInJnYigxMDIsIDE2MywgMjI0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTk0LCAxMzMsIDI1NSlcIiBsYWJlbD1cInJnYigxOTQsIDEzMywgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTM2LCAxMzYsIDEzNilcIiBsYWJlbD1cInJnYigxMzYsIDEzNiwgMTM2KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTYxLCAwLCAwKVwiIGxhYmVsPVwicmdiKDE2MSwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE3OCwgMTA3LCAwKVwiIGxhYmVsPVwicmdiKDE3OCwgMTA3LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTc4LCAxNzgsIDApXCIgbGFiZWw9XCJyZ2IoMTc4LCAxNzgsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA5NywgMClcIiBsYWJlbD1cInJnYigwLCA5NywgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDcxLCAxNzgpXCIgbGFiZWw9XCJyZ2IoMCwgNzEsIDE3OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwNywgMzYsIDE3OClcIiBsYWJlbD1cInJnYigxMDcsIDM2LCAxNzgpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYig2OCwgNjgsIDY4KVwiIGxhYmVsPVwicmdiKDY4LCA2OCwgNjgpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYig5MiwgMCwgMClcIiBsYWJlbD1cInJnYig5MiwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgNjEsIDApXCIgbGFiZWw9XCJyZ2IoMTAyLCA2MSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgMTAyLCAwKVwiIGxhYmVsPVwicmdiKDEwMiwgMTAyLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNTUsIDApXCIgbGFiZWw9XCJyZ2IoMCwgNTUsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA0MSwgMTAyKVwiIGxhYmVsPVwicmdiKDAsIDQxLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYig2MSwgMjAsIDEwMilcIiBsYWJlbD1cInJnYig2MSwgMjAsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0LXNlcGFyYXRvclwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNlbGVjdCB0aXRsZT1cIkJhY2tncm91bmQgQ29sb3JcIiBjbGFzcz1cInFsLWJhY2tncm91bmRcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMCwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIzMCwgMCwgMClcIiBsYWJlbD1cInJnYigyMzAsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDE1MywgMClcIiBsYWJlbD1cInJnYigyNTUsIDE1MywgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAwKVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMTM4LCAwKVwiIGxhYmVsPVwicmdiKDAsIDEzOCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDEwMiwgMjA0KVwiIGxhYmVsPVwicmdiKDAsIDEwMiwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTUzLCA1MSwgMjU1KVwiIGxhYmVsPVwicmdiKDE1MywgNTEsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAyNTUpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiBzZWxlY3RlZD1cIlwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjUwLCAyMDQsIDIwNClcIiBsYWJlbD1cInJnYigyNTAsIDIwNCwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyMzUsIDIwNClcIiBsYWJlbD1cInJnYigyNTUsIDIzNSwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDIwNClcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjA0LCAyMzIsIDIwNClcIiBsYWJlbD1cInJnYigyMDQsIDIzMiwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjA0LCAyMjQsIDI0NSlcIiBsYWJlbD1cInJnYigyMDQsIDIyNCwgMjQ1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjM1LCAyMTQsIDI1NSlcIiBsYWJlbD1cInJnYigyMzUsIDIxNCwgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTg3LCAxODcsIDE4NylcIiBsYWJlbD1cInJnYigxODcsIDE4NywgMTg3KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjQwLCAxMDIsIDEwMilcIiBsYWJlbD1cInJnYigyNDAsIDEwMiwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAxOTQsIDEwMilcIiBsYWJlbD1cInJnYigyNTUsIDE5NCwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDEwMilcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxODUsIDEwMilcIiBsYWJlbD1cInJnYigxMDIsIDE4NSwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxNjMsIDIyNClcIiBsYWJlbD1cInJnYigxMDIsIDE2MywgMjI0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTk0LCAxMzMsIDI1NSlcIiBsYWJlbD1cInJnYigxOTQsIDEzMywgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTM2LCAxMzYsIDEzNilcIiBsYWJlbD1cInJnYigxMzYsIDEzNiwgMTM2KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTYxLCAwLCAwKVwiIGxhYmVsPVwicmdiKDE2MSwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE3OCwgMTA3LCAwKVwiIGxhYmVsPVwicmdiKDE3OCwgMTA3LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTc4LCAxNzgsIDApXCIgbGFiZWw9XCJyZ2IoMTc4LCAxNzgsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA5NywgMClcIiBsYWJlbD1cInJnYigwLCA5NywgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDcxLCAxNzgpXCIgbGFiZWw9XCJyZ2IoMCwgNzEsIDE3OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwNywgMzYsIDE3OClcIiBsYWJlbD1cInJnYigxMDcsIDM2LCAxNzgpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYig2OCwgNjgsIDY4KVwiIGxhYmVsPVwicmdiKDY4LCA2OCwgNjgpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYig5MiwgMCwgMClcIiBsYWJlbD1cInJnYig5MiwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgNjEsIDApXCIgbGFiZWw9XCJyZ2IoMTAyLCA2MSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgMTAyLCAwKVwiIGxhYmVsPVwicmdiKDEwMiwgMTAyLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNTUsIDApXCIgbGFiZWw9XCJyZ2IoMCwgNTUsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA0MSwgMTAyKVwiIGxhYmVsPVwicmdiKDAsIDQxLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYig2MSwgMjAsIDEwMilcIiBsYWJlbD1cInJnYig2MSwgMjAsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXRzXCI+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWxpc3RcIiB2YWx1ZT1cIm9yZGVyZWRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtbGlzdFwiIHZhbHVlPVwiYnVsbGV0XCI+PC9idXR0b24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXRzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJsZWZ0XCIgc2VsZWN0ZWQ+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJjZW50ZXJcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cInJpZ2h0XCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJqdXN0aWZ5XCI+PC9idXR0b24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L3AtaGVhZGVyPlxuICAgICAgICA8L3AtZWRpdG9yPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBDdXN0b20gaGVhZGVyIFRleHQgRWRpdG9yIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJ0eXBlID09PSBFZGl0b3JUeXBlLkN1c3RvbVwiPlxuICAgICAgICA8cC1lZGl0b3IgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbc3R5bGVdPVwieydoZWlnaHQnOicxODBweCd9XCJcbiAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiPlxuICAgICAgICAgICAgPHAtaGVhZGVyPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImN1c3RvbS1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L3AtaGVhZGVyPlxuICAgICAgICA8L3AtZWRpdG9yPlxuICAgIDwvZGl2PlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhZWRpdGFibGVcIj5cbiAgICA8YXctc3RyaW5nIFt2YWx1ZV09XCJ2YWx1ZVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudWktZWRpdG9yLXRvb2xiYXJ7YmFja2dyb3VuZC1jb2xvcjojZjVmNWY1O2JvcmRlcjoxcHggc29saWQgI2Q3ZDdkN30vZGVlcC8gcC1lZGl0b3I6YWN0aXZlIC9kZWVwLyAudWktZWRpdG9yLXRvb2xiYXIucWwtdG9vbGJhci5xbC1zbm93LC9kZWVwLyBwLWVkaXRvcjpmb2N1cyAvZGVlcC8gLnVpLWVkaXRvci10b29sYmFyLnFsLXRvb2xiYXIucWwtc25vdywvZGVlcC8gcC1lZGl0b3I6aG92ZXIgL2RlZXAvIC51aS1lZGl0b3ItdG9vbGJhci5xbC10b29sYmFyLnFsLXNub3d7Ym9yZGVyLWNvbG9yOiMxOTlkZTB9L2RlZXAvIHAtZWRpdG9yOmFjdGl2ZSAvZGVlcC8gLnVpLWVkaXRvci1jb250ZW50LnFsLWNvbnRhaW5lci5xbC1zbm93LC9kZWVwLyBwLWVkaXRvcjpmb2N1cyAvZGVlcC8gLnVpLWVkaXRvci1jb250ZW50LnFsLWNvbnRhaW5lci5xbC1zbm93LC9kZWVwLyBwLWVkaXRvcjpob3ZlciAvZGVlcC8gLnVpLWVkaXRvci1jb250ZW50LnFsLWNvbnRhaW5lci5xbC1zbm93e2JvcmRlci1jb2xvcjojMTk5ZGUwfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBFRElUT1JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSaWNoVGV4dEFyZWFDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBSaWNoVGV4dEFyZWFDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGVkaXRvci4gIFNlZSBFZGl0b3JUeXBlIGZvciBkZXNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IEVkaXRvclR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBBIHZhbHVlIHVzZWQgdG8gc2F2ZSBhbmQgcmVhZCB3aGVuIHJlbmRlcmluZyBhbmQgdXBkYXRpbmcgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBlZGl0b3JUeXBlIHNvIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gdGhpcyBjb21wb25lbnRzIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIEVkaXRvclR5cGU6IGFueSA9IEVkaXRvclR5cGU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy50eXBlID0gRWRpdG9yVHlwZS5EZWZhdWx0O1xuICAgICAgICB0aGlzLnN0eWxlQ2xhc3MgPSAnZGVmYXVsdC1lZGl0b3InO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShcbiAgICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICAgKS5zdWJzY3JpYmUodmFsID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFZGl0b3JNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7UmljaFRleHRBcmVhQ29tcG9uZW50fSBmcm9tICcuLi9yaWNoLXRleHQtYXJlYS9yaWNoLXRleHQtYXJlYS5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJpY2hUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBFZGl0b3JNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBSaWNoVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmljaFRleHRBcmVhQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1JpY2hUZXh0QXJlYU1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtBY2NvcmRpb25UYWJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogQWxsb3cgZGV2ZWxvcGVyIHRvIG92ZXJyaWRlIGRlZmF1bHQgYWN0aW9ucy4gTXVzdCBoYXZlIHRoaXMgZGVjbGFyZWQgYmVmb3JlIGNsYXNzIHdoZW4gd2VcbiAqIHdhbnQgdG8gaGF2ZSB0aGlzIGRlY2xhcmF0aW9uIGluc2lkZSB0aGUgc2FtZSBmaWxlLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNlY3Rpb24tYWN0aW9ucycsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+IGAsXG59KVxuZXhwb3J0IGNsYXNzIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50XG57XG5cbn1cblxuXG4vKipcbiAqXG4gKiBTZWN0aW9uIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgYSBzZWN0aW9uIG9mIHRoZSBwYWdlLiBJdCdzIGFuIG91dGxpbmUgYm94IHRoYXRcbiAqIGhhcyB0aGUgYWJpbGl0eSB0byBleHBhbmQgYW5kIGhpZGUgaXRzIGNvbnRlbnQuXG4gKlxuICogYGBgdHNcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmZ4LWRldGFpbHMnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiU291cmNpbmcgcmVxdWVzdCBpbmZvXCIgKG9uRWRpdCk9XCJvblN0YXRlQ2hhbmdlKCRldmVudClcIlxuICAqICAgICAgICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwidHJ1ZVwiPlxuICpcbiAqICAgICAgICAgICAgICAgIDxtLWNvbnRleHQgW29iamVjdF09XCJyZnhFbnRpdHkuaGVhZGVySW5mb1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgW29wZXJhdGlvbl09XCJ0aGlzLmVkaXRhYmlsaXR5U3RhdGUuaGVhZGVySW5mb09wXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ9XCJJbnNwZWN0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB1aUdyb3VwPVwiSGVhZGVyR2VuZXJhbFwiPlxuICogICAgICAgICAgICAgICAgICAgPG0taW5jbHVkZS1jb21wb25lbnQ+PC9tLWluY2x1ZGUtY29tcG9uZW50PlxuICogICAgICAgICAgICAgICA8L20tY29udGV4dD5cbiAqICAgICAgICAgICA8L2F3LXNlY3Rpb24+XG4gKlxuICpcbiAqICAgICAgICAgICA8YXctc2VjdGlvbiAjc3VwcGxpZXJTZWN0aW9uIHRpdGxlPVwiU2VsZWN0ZWQgc3VwcGxpZXJzXCIgKG9uT3Blbik9XCJvbk9wZW4oKVwiXG4gICAqICAgICAgICAgICAgICAgIFtvcGVuZWRdPVwiZmFsc2VcIj5cbiAqICAgICAgICAgICAgICAgPHN1cHBsaWVyLXByb2ZpbGUtY2FyZD48L3N1cHBsaWVyLXByb2ZpbGUtY2FyZD5cbiAqICAgICAgICAgICA8L2F3LXNlY3Rpb24+XG4gKlxuICogICAgICAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiUkZRIERldGFpbHNcIlxuICogICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uPVwiUmV2aWV3IGFuZCB1cGRhdGUgaW5mb3JtYXRpb24gZm9yIHN1cHBsaWVycyB0byByZXNwb25kLlwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVDbG9zZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICA8YXctc3Vic2VjdGlvbiB0aXRsZT1cIkV2ZW50IHRpbWVsaW5lXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8YXctZm9ybS10YWJsZSBbdXNlRml2ZVpvbmVdPVwiZmFsc2VcIiBbZWRpdGFibGVdPVwidHJ1ZVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidTdGFydCBEYXRlJ1wiIFtuYW1lXT1cIidzdGFydERhdGUnXCIgW3NpemVdPVwiJ3NtYWxsJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2hpZ2hsaWdodFJvd109XCJ0cnVlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kYXRlLXRpbWVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdE5hbWU9XCJkYXRlVGltZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwic3RhcnREYXRlXCIgW3ZhbHVlXT1cInJmeEVudGl0eS5jcmVhdGVkXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzaG93VGltZV09XCJ0cnVlXCI+PC9hdy1kYXRlLXRpbWU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS10YWJsZT5cbiAqICAgICAgICAgICAgICAgPC9hdy1zdWJzZWN0aW9uPlxuICogICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBTZWN0aW9uIGNvbXBvbmVudCBhbHNvIHN1cHBvcnRzIGVkaXRhYmlsaXR5IG1vZGVzIGFuZCBpZiBlbmFibGVkIGl0IHdpbGwgcmVuZGVyIGFjdGlvbiBidXR0b25zXG4gKiBpbiB0aGUgZm9vdGVyLiBEZXZlbG9wZXIgY2FuIGFsc28gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvciBhbmQgcHJvdmlkZSBjdXN0b20gYWN0aW9ucy5cbiAqXG4gKlxuICogZS5nOlxuICpcbiAqIGBgYFxuICogICAgICA8YXctc2VjdGlvbiBbdGl0bGVdPVwidGl0bGVcIiBbZWRpdGFibGVdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uQ2FuY2VsQWN0aW9uKT1cInNvbWVIYW5kbGVyMSgkZXZlbnQpXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25TYXZlQWN0aW9uKT1cInNvbWVIYW5kbGVyMigkZXZlbnQpXCIgPlxuICogICAgICAgICAgICAgIHNlY3Rpb24gY29udGVudFxuICpcbiAqXG4gKiAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKiBgYGBcbiAqXG4gKiBvciBjdXN0b20gYWN0aW9uIGJ1dHRvbnM6XG4gKlxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiAgICAgICA8YXctc2VjdGlvbi1hY3Rpb25zPlxuICogICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdXR0b25UZXN0MVxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQnV0dG9uVGVzdDJcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgIDwvYXctc2VjdGlvbi1hY3Rpb25zPlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGVkaXQgbW9kZXNcbiAqICAjIERlZmF1bHRcbiAqICAgICAgUmVuZGVycyBhY3Rpb24gYnV0dG9ucyBpbiB0aGUgZm9vdGVycyBhbmQgZW1pdCBhY3Rpb25zIHRvIHRoZSBhcHBsaWNhdGlvblxuICpcbiAqICAjIEV4dGVybmFsXG4gKiAgICAgTm8gYWN0aW9uIGJ1dHRvbnMgYXJlIHNob3duIGluIHRoZSBmb290ZXIgYW5kIGJlaGF2aW9yIGlzIGhhbmRsZWQgYnkgYXBwbGljYXRpb24uIE9ubHkgZXZlbnRcbiAqICAgICBpcyBlbWl0ZWQuXG4gKlxuICpcbiAqICBlLmc6XG4gKlxuICogIGBgYHRzXG4gKlxuICogICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlVzZXIgSW5mb3JtYXRpb25cIiAob25FZGl0KT1cIm9uQWRkU29tZXRoaW5nKCRldmVudClcIlxuICogICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwidHJ1ZVwiIFtlZGl0TW9kZV09XCInZXh0ZXJuYWwnXCIgPlxuICogICAgICAgICAgICAgICAgICA8ZGl2PlxuICogICAgICAgICAgICAgICAgICAgICAgQ29udGVudFxuICogICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqICBgYGBcbiAqXG4gKiBOb3RlOiBXaGVuIHVzaW5nIGVkaXRpbmcgbW9kZSB5b3UgaGF2ZSB0byBjYWxsIGF0IHRoZSBlbmQgb2YgdGhlIGVkaXRpbmcgY3ljbGUgbWV0aG9kXG4gKiBgY29tcGxldGVFZGl0aW5nKClgIHRvIGNvbW1pdCBlZGl0aW5nIHdoaWNoIGNoYW5nZXMgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIFNlY3Rpb24uXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2VjdGlvbicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidWktZy0xMiBzZWN0aW9uLWNvbnRhaW5lclwiXG4gICAgIFtjbGFzcy5lZGl0aW5nXT1cImVkaXRhYmxlICYmIGVkaXRTdGF0ZSAmJiBlZGl0TW9kZSA9PT0gJ2RlZmF1bHQnXCI+XG5cbiAgICA8cC1hY2NvcmRpb24gKG9uT3Blbik9XCJvblNlY3Rpb25PcGVuKCRldmVudClcIiAob25DbG9zZSk9XCJvblNlY3Rpb25DbG9zZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwiYUNsYXNzKClcIj5cbiAgICAgICAgPHAtYWNjb3JkaW9uVGFiICNhY2NvcmRpb25UYWIgW3NlbGVjdGVkXT1cIm9wZW5lZFwiIFtkaXNhYmxlZF09XCJkaXNhYmxlQ2xvc2VcIj5cbiAgICAgICAgICAgIDxwLWhlYWRlcj5cbiAgICAgICAgICAgICAgICA8IS0tIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiAtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1oZWFkZXItY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLXRpdGxlXCI+e3t0aXRsZX19PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJoYXNEZXNjcmlwdGlvbigpXCIgY2xhc3M9XCJzZWN0aW9uLWRlc2NyaXB0aW9uXCI+e3tkZXNjcmlwdGlvbn19PC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgPCEtLSBhY3Rpb25zOiBIaWRlIHdoZW4gaW4gZWRpdGluZyBhbmQgZWRpdE1vZGUgaXMgZGVmYXVsdCAtLT5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cIihlZGl0YWJsZSAmJiAhZWRpdFN0YXRlICYmIGVkaXRNb2RlID09PSAnZGVmYXVsdCcpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoZWRpdGFibGUgJiYgZWRpdE1vZGUgPT09ICdleHRlcm5hbCcpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInNlY3Rpb24tYWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWh5cGVybGluayAoYWN0aW9uKT1cIm9uRWRpdEFjdGlvbigkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJzYXAtaWNvbiBzZWN0aW9uLWVkaXQtYWN0aW9uXCIgW25nQ2xhc3NdPVwiYWN0aW9uSWNvblwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctaHlwZXJsaW5rPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvcC1oZWFkZXI+XG5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9wLWFjY29yZGlvblRhYj5cbiAgICA8L3AtYWNjb3JkaW9uPlxuICAgIDwhLS1cbiAgICAgICAgbmVlZCB0byBwdXQgaXQgb3V0c2lkZSBvZiBwLWFjY29yZGlvbiBvdGhlcndpc2UgYnV0dG9uIHdpbGwgaW5oZXJpdCBkaWZmZXJlbnRcbiAgICAgICAgY29sb3Igc2NoZW1lXG4gICAgLS0+XG4gICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tZm9vdGVyLWNvbnRhaW5lclwiICpuZ0lmPVwiZWRpdGFibGUgJiYgZWRpdFN0YXRlICYmXG4gICAgICAgICAgICBlZGl0TW9kZSA9PT0gJ2RlZmF1bHQnXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmb290ZXItYWN0aW9uc1wiPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0N1c3RvbUFjdGlvbnMoKVwiPlxuICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3N0eWxlXT1cIidzZWNvbmRhcnknXCIgc2l6ZT1cInNtYWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DYW5jZWxBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgIENhbmNlbFxuICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxhdy1idXR0b24gc2l6ZT1cInNtYWxsXCIgKGFjdGlvbik9XCJvblNhdmVBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgIFNhdmVcbiAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LXNlY3Rpb24tYWN0aW9uc1wiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5zZWN0aW9uLWhlYWRlci1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmV9LnNlY3Rpb24tY29udGFpbmVye21hcmdpbjoxMHB4IDA7YmFja2dyb3VuZC1jb2xvcjojZmZmO3BhZGRpbmc6LjJlbSAuNWVtO2JvcmRlcjoycHggZGFzaGVkIHRyYW5zcGFyZW50fS5zZWN0aW9uLWNvbnRhaW5lci5lZGl0aW5ne2JvcmRlci1jb2xvcjojMTk5ZGUwfS5zZWN0aW9uLWNvbnRhaW5lciA6Om5nLWRlZXAgLnVpLWFjY29yZGlvbi1oZWFkZXI+YXtkaXNwbGF5OmZsZXh9LnNlY3Rpb24tY29udGFpbmVyIDo6bmctZGVlcCAudWktYWNjb3JkaW9uLWhlYWRlcj5hIC51aS1hY2NvcmRpb24tdG9nZ2xlLWljb257ZmxleDowIDAgMzBweDtwYWRkaW5nLXRvcDoycHh9LnNlY3Rpb24tY29udGFpbmVyIDo6bmctZGVlcCAudWktYWNjb3JkaW9uLWhlYWRlcj5hIHAtaGVhZGVye2ZsZXg6MSAwfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtZGlzYWJsZWR7b3BhY2l0eToxfS5zZWN0aW9uLXRpdGxle2ZvbnQtc2l6ZToxLjFlbX0uc2VjdGlvbi1kZXNjcmlwdGlvbntmb250LXNpemU6LjllbTtwYWRkaW5nOi42ZW0gMCAuMmVtfS5zZWN0aW9uLWZvb3Rlci1jb250YWluZXJ7bWFyZ2luOjFlbSAyZW0gMDtwYWRkaW5nOi44ZW0gMCAxLjVlbSAuOGVtO2JvcmRlci10b3A6MXB4IHNvbGlkICNkN2Q3ZDd9LnNlY3Rpb24tZm9vdGVyLWNvbnRhaW5lciAuZm9vdGVyLWFjdGlvbnN7ZGlzcGxheTppbmxpbmUtYmxvY2s7dGV4dC1hbGlnbjpyaWdodDt3aWR0aDoxMDAlfS5zZWN0aW9uLWFjdGlvbnN7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDt6LWluZGV4OjF9LnNlY3Rpb24tYWN0aW9ucyAvZGVlcC8gYS5saW5rLC5zZWN0aW9uLWFjdGlvbnMgL2RlZXAvIGEubGluazpob3ZlcntwYWRkaW5nOjA7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LnNlY3Rpb24tZWRpdC1hY3Rpb257Zm9udC1zaXplOjEuNWVtO3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6LjFlbSAwIC4xZW0gLjVlbTtjdXJzb3I6cG9pbnRlcn0uc2VjdGlvbi1lZGl0LWFjdGlvbi5pY29uLWVkaXR7Zm9udC1zaXplOjEuNGVtfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXJ7Y29sb3I6IzM2MzYzNjtib3JkZXI6bm9uZTtiYWNrZ3JvdW5kOiNmZmYhaW1wb3J0YW50O3BhZGRpbmc6MCAxZW19LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWNvbnRlbnR7Ym9yZGVyOm5vbmU7cGFkZGluZzoxZW0gMmVtfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgL2RlZXAvIGFbcm9sZT10YWJde3BhZGRpbmc6Ljc1ZW0gMDt0ZXh0LWRlY29yYXRpb246bm9uZX0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyLnVpLXN0YXRlLWFjdGl2ZSAvZGVlcC8gYVtyb2xlPXRhYl17Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2Q3ZDdkNztjb2xvcjojMzYzNjM2fS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnNlY3Rpb24tbm8taGVhZGVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlcntoZWlnaHQ6MXB4fS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnNlY3Rpb24tbm8taGVhZGVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlci51aS1zdGF0ZS1hY3RpdmUgL2RlZXAvIGFbcm9sZT10YWJde2JvcmRlci1ib3R0b206bm9uZX0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC5zZWN0aW9uLW5vLWhlYWRlciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgLnNlY3Rpb24tZWRpdC1hY3Rpb257Y3Vyc29yOnBvaW50ZXIhaW1wb3J0YW50fTpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gLnBpLnBpLWNhcmV0LWRvd24sOmhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyAucGkucGktY2FyZXQtcmlnaHR7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2ZvbnQtc2l6ZToxLjFlbTt0b3A6LjhlbTtsZWZ0Oi4xZW07Y29sb3I6Izc2NzY3NjttYXJnaW4tdG9wOjB9Omhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyLnVpLXN0YXRlLWRpc2FibGVkIC9kZWVwLyAuZmEsOmhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyLnVpLXN0YXRlLWRpc2FibGVkIC9kZWVwLyAucGl7ZGlzcGxheTpub25lfTpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gLnBpLnBpLWNhcmV0LXJpZ2h0OmJlZm9yZXtjb250ZW50OlwiXFxcXGUxZWRcIn06aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgL2RlZXAvIC5waS5waS1jYXJldC1kb3duOmJlZm9yZXtjb250ZW50OlwiXFxcXGUxZWZcIn1gXVxufSlcbmV4cG9ydCBjbGFzcyBTZWN0aW9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoaXMgc2VjdGlvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZXNjcmlwdGlvbiBvZiB0aGlzIHNlY3Rpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoaXMgc2VjdGlvbiBiZSBvcGVuZWQgYXQgdGhlIHN0YXJ0LiBEZWZhdWx0IGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9wZW5lZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2VjdGlvbiBjYW4gYmUgY2xvc2VkIG9yIG5vdC5cbiAgICAgKiovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlQ2xvc2U6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBzZWN0aW9uIGlzIGluIEVkaXRTdGF0ZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBXaGVuIGluIGVkaXRpbmcgc3RhdGUgYW5kIHdlIHNob3cgXCJDYW5jZWwgLyBTYXZlXCIgYnV0dG9uIGRldmVsb3BlciBuZWVkcyB1c2UgdGhpcyBiaW5kaW5nXG4gICAgICogdG8gY29udHJvbCB0aGUgc3RhdGUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0U3RhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBFZGl0aW5nIG1vZGUuIFRlbGxzIHRoZSBjb21wb25lbnRzIGlmIGl0cyBpdHMgZGVmYXVsdCBiZWhhdmlvciBvciBkcml2ZW4gYnlcbiAgICAgKiBhcHBsaWNhdGlvbiB1c2luZyB0aGlzIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIHtAc2VlIEVkaXRNb2RlfVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0TW9kZTogRWRpdE1vZGUgPSAnZGVmYXVsdCc7XG5cblxuICAgIC8qKlxuICAgICAqIERldmVsb3BlciBjYW4gcHJvdmlkZSBjdXN0b20gRWRpdCBhY3Rpb24gaWNvbiB0aGF0IHdpbGwgYXBwZWFyIGluIHRoZSByaWdodCB0b3AgY29ybmVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhY3Rpb25JY29uOiBzdHJpbmcgPSAnaWNvbi1lZGl0JztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBmdWxseSBvcGVuZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgc2VjdGlvbiBpcyBmdWxseSBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFZGl0IHN0YXRlIHRvIGJyb2FkY2FzdCBzdGF0ZSBvZiBjdXJyZW50IHNlY3Rpb25cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkVkaXQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGluIGVkaXRpbmcgc3RhdGUgYW5kIGRlZmF1bHQgYnV0dG9ucyBhcmUgcmVuZGVyZWQgb24gY2xpY2sgYnJvYWRjYXN0IENhbmNlbCBhY3Rpb25cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNhbmNlbEFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW4gZWRpdGluZyBzdGF0ZSBhbmQgZGVmYXVsdCBidXR0b25zIGFyZSByZW5kZXJlZCBvbiBjbGljayBicm9hZGNhc3QgU2F2ZSBhY3Rpb25cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNhdmVBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICBAT3V0cHV0KClcbiAgICBvbkVkaXRpbmdDb21wbGV0ZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCB2YXJpYWJsZSBvbiB3aGV0aGVyIHRoaXMgc2VjdGlvbiBpcyBleHBhbmRlZCBvciBub3QuXG4gICAgICogRGlmZmVycyBmcm9tICdvcGVuZWQnLiBvcGVuZWQgaXMgYW4gaW5wdXQgcGFyYW1ldGVyIGFuZCBpdCBkb2Vzbid0IHRyYWNrXG4gICAgICogY3VycmVudCBzZWN0aW9uIGV4cGFuZGVkIHN0YXRlLlxuICAgICAqL1xuICAgIGV4cGFuZGVkOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgYWNjb3JkaW9uVGFiXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnYWNjb3JkaW9uVGFiJylcbiAgICBwcml2YXRlIGFjY29yZGlvblRhYjogQWNjb3JkaW9uVGFiO1xuXG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHJlZmVyZW5jZSB0byBkZXZlbG9wZXIncyBkZWZpbmVkIGFjdGlvbnMgc28gaWYgd2UgY2FuIGhpZGUgZGVmYXVsdCBvbmVzXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChTZWN0aW9uQWN0aW9uc0NvbXBvbmVudClcbiAgICBjdXN0b21BY3Rpb25zOiBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgICAgIHRoaXMuZWRpdGFibGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICAvLyBJZiBJIGhhdmUgbm90IGhlYWRlciwgdGhlbiBJIGNhbid0IGNsb3NlIHRoZSBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuaXNIZWFkZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgSSBjYW4ndCBjbG9zZSB0aGUgc2VjdGlvbiwgdGhlbiBpdCBzaG91bGQgZGVmYXVsdCBvcGVuLlxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgZXhwYW5kZWQgc3RhdGUuXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0aGlzLm9wZW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb24ndCBkaXNwbGF5IGhlYWRlciBhcmVhIGlmIEkgZG9uJ3QgaGF2ZSB0aXRsZSBhbmQgZGVzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzSGVhZGVyRGlzcGxheWVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAoaXNQcmVzZW50KHRoaXMudGl0bGUpIHx8IGlzUHJlc2VudCh0aGlzLmRlc2NyaXB0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3NzIENsYXNzIHRoYXQgY29udHJvbCB0aGUgbG9vayBhbmQgZmVlbCBmb3Igc2VjdGlvbiBjb21wb25lbnQuXG4gICAgICovXG4gICAgYUNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhZGVyRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnc2VjdGlvbi1uby1oZWFkZXInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIGludHJvZHVjZWQgYnV0dG9ucyBhbmQgZWRpdFN0YXRlIHRoZSBkZWNpc2lvbiBvbiB3aGVuIHRvIGV4aXQgZWRpdGluZyBtb2RlXG4gICAgICogc2hvdWxkIGJlIG9uIHRoZSBkZXZlbG9wZXIgdXNpbmcgdGhpcyBjb21wb25lbnQgdGhlcmVmb3JlIG9ubHkgc3RhcnRFZGl0aW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkVkaXRBY3Rpb24oJGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIC8vIHdoZW4gaW4gZWRpdGluZyBtYWtlIHN1cmUgd2UgZG9udCBzd2l0Y2ggc3RhdGUgYXMgdGhlcmUgY2FuIGJlIHNvbWUgRm9ybSBlcnJvcnNcbiAgICAgICAgLy8gd2hpY2ggbmVlZHMgdG8gYmUgaGFuZGxlZCBieSBkZXZlbG9wZXIgYW5kIG9ubHkgdGhlbiBjaGFuZ2UgdGhlIGVkaXRTdGF0ZVxuICAgICAgICBpZiAoIXRoaXMuZWRpdFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRTdGF0ZSA9ICF0aGlzLmVkaXRTdGF0ZTtcbiAgICAgICAgICAgIGxldCBzdGF0ZTogc3RyaW5nID0gKHRoaXMuZWRpdFN0YXRlKSA/ICdpbkVkaXQnIDogJ25vdEluRWRpdCc7XG5cbiAgICAgICAgICAgIHRoaXMub25FZGl0LmVtaXQoc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSBvcmlnaW5hbCBldmVudCBmcm9tIGJ1YmJsaW5nIHVwLiBCZWNhdXNlIHRoZSBlZGl0IGljb24gaXMgaW5zaWRlXG4gICAgICAgIC8vIHRoZSBoZWFkZXIuIElmIHRoZSBjbGljayBldmVuIGlzIGJ1YmJsZWQgdXAsIHRoaXMgZXZlbnQgd2lsbCBjYXVzZSB0aGUgc2VjdGlvbiB0b1xuICAgICAgICAvLyBleHBhbmQgb3IgY29sbGFwc2UuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoJGV2ZW50LmV2ZW50KSkge1xuICAgICAgICAgICAgJGV2ZW50LmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgJGV2ZW50LmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYXNEZXNjcmlwdGlvbigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZGVzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhpcyBzZWN0aW9uLCBpZiBpdCdzIGFscmVhZHkgb3Blbiwgd2lsbCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIG9wZW4oZXZlbnQ/OiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIGlmICghdGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvcmRpb25UYWIudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoaXMgc2VjdGlvbiwgaWYgaXQncyBhbHJlYWR5IGNsb3NlLCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgY2xvc2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvblRhYi50b2dnbGUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFjY29yZGlvbiBpcyBvcGVuZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU2VjdGlvbk9wZW4oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCdvcGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGFjY29yZGlvbiBpcyBjbG9zZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uU2VjdGlvbkNsb3NlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCdjbG9zZScpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyB1cyBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhcHBsaWNhdGlvbiBkZWZpbmVkIGN1c3RvbSBhY3Rpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNDdXN0b21BY3Rpb25zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jdXN0b21BY3Rpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBlZGl0aW5nIHN0YXRlIGJhY2sgdG8gbm9uLWVkaXRhYmxlXG4gICAgICovXG4gICAgY29tcGxldGVFZGl0aW5nKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZWRpdFN0YXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25FZGl0aW5nQ29tcGxldGUuZW1pdCh0aGlzLmVkaXRTdGF0ZSk7XG4gICAgfVxufVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN1YnNlY3Rpb24nLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cInN1YnNlY3Rpb24tdGl0bGVcIj57e3RpdGxlfX08L2g0PlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgIGAsXG4gICAgc3R5bGVzOiBbJy5zdWJzZWN0aW9uLXRpdGxlIHtjb2xvcjogIzM2MzYzNjsgfSddXG59KVxuZXhwb3J0IGNsYXNzIFN1YlNlY3Rpb25Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIHN1YiBzZWN0aW9uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xufVxuXG5cbi8qKlxuICogRGVmaW5lcyBlZGl0aW5nIG1vZGVzIGZvciB0aGUgU2VjdGlvbnMuIERlZmF1bHQgbWVhbnMgd2Ugc2hvdyBjYW5jZWwgLyBzYXZlIGJ1dHRvbnMgYW5kIGhpZGVcbiAqIGVkaXQgaWNvbnMgd2hlbiBpbiBlZGl0aW5nLiBleHRlcm5hbCBpcyBkcml2ZW4gYnkgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0IHR5cGUgRWRpdE1vZGUgPSAnZGVmYXVsdCcgfCAnZXh0ZXJuYWwnO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0FyaWJhQ29yZU1vZHVsZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7QWNjb3JkaW9uTW9kdWxlLCBTaGFyZWRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge1NlY3Rpb25BY3Rpb25zQ29tcG9uZW50LCBTZWN0aW9uQ29tcG9uZW50LCBTdWJTZWN0aW9uQ29tcG9uZW50fSBmcm9tICcuL3NlY3Rpb24uY29tcG9uZW50JztcbmltcG9ydCB7QVdIeXBlcmxpbmtNb2R1bGV9IGZyb20gJy4uL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4uL2J1dHRvbi9idXR0b24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTdWJTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFjY29yZGlvbk1vZHVsZSxcbiAgICAgICAgQXJpYmFDb3JlTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIFNoYXJlZE1vZHVsZVxuICAgIF0sXG5cbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU3ViU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU2VjdGlvbkFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFN1YlNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU2VjdGlvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgSW5wdXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZX0gZnJvbSAnLi4vYXctZGF0YXRhYmxlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtCb29sZWFuV3JhcHBlciwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbmV4cG9ydCB0eXBlIERUSEFsaWdubWVudCA9ICdsZWZ0JyB8ICdjZW50ZXInIHwgJ3JpZ2h0JztcblxuXG4vKipcbiAqIERUQ29sdW1uIHJlcHJlc2VudCBzaW5nbGUgY29sdW1uIGluY2x1ZGluZyBoZWFkZXIgYW5kIGl0cyBib2R5LiBFYWNoIGNvbHVtbiBoYXMgaXRzIG93blxuICogcmVuZGVyZXJUZW1wbGF0ZSB3aGljaCBhIGVudHJ5IHRvIHRoaXMgY29tcG9uZW50LlxuICpcbiAqIEtlZXBpbmcgdGhpcyBzZXBhcmF0ZSBmcm9tIHRoZSBkYXRhdGFibGUgd2hlcmUgRFQgaXMgbm90IHJlYWxseSBhd2FyZSB3aGF0IGl0IGlzIHJlbmRlcmluZyxcbiAqIGl0IGFsbG93cyB1cyBtb3JlIGZsZXhpYmlsaXR5IGluIHRlcm1zIG9mIGRpZmZlcmVudCB0eXBlIG9mIGNvbHVtbiBpbmhlcml0aW5nIGZyb20gdGhpc1xuICogb25lLi4gU3VjaCBhczpcbiAqICBEVFJvd0RldGFpbCAgY29sdW1uXG4gKiAgRFRTaW5nbGVTZWxlY3Rpb24gY29sdW1uXG4gKiAgRFRNdWx0aVNlbGVjdGlvbiBjb2x1bW5cbiAqXG4gKiBUaGlzIHdheSB3ZSBkb24ndCBkbyBJRi9USEVOL0VMU0UgaW5zaWRlIHRoZSBkYXRhdGFibGUgYW5kIHRyeWluZyB0byBjcmVhdGUgZGlmZmVyZW50IGNhc2VzLlxuICpcbiAqICBUaGVuIGxhdGVyIG9uIHRoaXMgd2lsbCBsZXQgdXMgY3JlYXRlIGFkZGl0aW9uYWwgbG9naWMgZm9yIHRoZSBwaXZvdGFsIGxheW91dC4gQmVjYXVzZSBEVFxuICogIGRvZXMga25vdyBhbnl0aGluZyBhYm91dCB0aGUgdHlwZSBvZiB0aGUgY29sdW1uIHNvIHdoYXRldmVyIGlzIGFkZGVkIHRvIHRoZSBEVC5jb2x1bW5zIGl0XG4gKiAgd2lsbCBiZSByZW5kZXJlZC5cbiAqXG4gKlxuICogIENvbHVtbnMgY2FuIGJlIGFsc28gZnJvemVuIG1lYW5pbmcgaWYgdGhlIGNvbnRlbnQgb3ZlcmZsb3dzIHRoZXkgZG9udCBzY3JvbGwuIFRvIG1ha2UgdGhlXG4gKiAgY29sdW1uIGZyb3plbiB3ZSBuZWVkIHRvIHVzZSBbZnJvemVuXSBiaW5kaW5nIGFuZCBzZSBpdCB0byBUUlVFIHBsdXMgaXQgcmVxdWlyZXMgYSBbd2lkdGhdXG4gKiAgYmluZGluZyB0byBiZSBzZXQgKGluIHB4KS5cbiAqICBXZSBuZWVkIHRoaXMgdG8gYmUgYWJsZSB0byBwcm9wZXJseSBwb3NpdGlvbiB0aGUgc2Vjb25kIHRhYmxlIHdoaWNoIGlzIGNoYW5nZWQgdG8gYWJzb2x1dGVcbiAqICBwb3NpdGlvbmluZy5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1jb2x1bW4yJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBUbyBtYWtlIGl0IG1vcmUgcmVhZGFibGUgRWFjaCBDb2x1bW4gdHlwZSBoYXMgaXRzIG93biByZW5kZXJpbmcgdGVtcGxhdGUgaW5zdGVhZCBvZiBwdXR0aW5nXG4gICAgYWxsIHRoaXMgaW50byBkYXRhdGFibGUgYXMgdGhpcyBpcyBtb3JlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjb2x1bW4uIEFuZCB0aGUgbWFpbiBnb2FsXG4gICAgd2FzIHRyeSB0byBiZSBtb2R1bGFyIGFzIHBvc3NpYmxlLiBXaGVuIFRoZXJlIHdpbGwgYmUgZGlmZmVyZW50IHR5cGVzIG9mIGNvbHVtbnNcblxuICAgIC0gUmVndWxhciBEVENvbHVtbiAoY3VycmVudCBpbXBsZW1lbnRhdGlvbiksXG4gICAgLSBTZWxlY3Rpb25Db2x1bW4gKFNpbmdsZS9NdWx0aSBzZWxlY3QpIC0gdG9kbyxcbiAgICAtIERldGFpbFJvdyBjb2x1bW4sIHRoZW4gcGl2b3RhbCBjb2xsdW1uIHRvIHJlbmRlciByb3cvY29sdW1uL2RldGFpbCBhdHRyaWJ1dGVzIC0gdG9kby5cblxuICAgIFdoZW4gaW1wbGVtZW50aW5nIG5ldyBjb2x1bW4gdHlwZSB5b3UganVzdCBpbmhlcml0IHRoaXMgRFRDb2x1bW5Db21wb25lbnQgYW5kIHByb3ZpZGUgeW91clxuICAgIG93biByZW5kZXJpbmcgdGVtcGxhdGUgYW5kIERUIHRha2UgY2FyZSBvZiB0aGUgcmVzdC5cblxuICAgIHRvZG86IFdlIGhhdmUgU2luZ2xlU2VsZWN0LCBNdWx0aXNlbGVjdCByZW5kZXJpbmcgdGVtcGxhdGUgdGhhdCBpcyBBZGRlZCBwcm9ncmFtYXRpY2FsbHlcbiAgICB0b2RvOiBXZSBoYXZlIHBpdm90YWwgcmVuZGVyaW5nIHRlbXBsYXRlXG5cblxuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1pc0hlYWRlciBsZXQtaXNTdWJIZWFkZXI9XCJpc1N1YkhlYWRlclwiIGxldC1jb2x1bW49XCJjb2x1bW5cIlxuICAgICAgICAgICAgIGxldC1kYXRhVG9SZW5kZXI9XCJkYXRhXCJcbiAgICAgICAgICAgICBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiXG4gICAgICAgICAgICAgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sSGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGlzU3ViSGVhZGVyLCBjb2x1bW5JbmRleDpjb2x1bW5JbmRleCwgZGF0YTogZGF0YVRvUmVuZGVyLFxuICAgICAgICAgICAgICAgICByb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiIWlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sQm9keVwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBjb2x1bW4sIGRhdGE6ZGF0YVRvUmVuZGVyLHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG5cbjwhLS1cbiAgICBUZW1wbGF0ZXMgZm9yIGhlYWRlciBjb2x1bW5zLiBIZXJlIHdlIGFyZSByZW5kZXJpbmcgdHdvIHR5cGVzLiBIZWFkZXIgYW5kIFN1YmhlYWRlciB0aGF0IHdlXG4gICAgdXN1YWxseSB1c2UgaGVyZSBhcyBzb21lIGtpbmQgb2Ygc3VtbWFyeSBjb2x1bW5zLiBOb3QgcmVhbGx5IGhhdmluZyBzdW1tYXJ5IGF0IHRoZSBib3R0b20gbGlrZSBvdGhlclxuICAgIERULlxuXG4gICAgVEggY29sdW1uIGFuZCB0aGVpciB0ZXh0IGFyZSB1c3VhbGx5IHVuc2VsZWN0YWJsZSBhbmQgbW9zdCBvZiB0aGVzZSB3ZXJlIGluaGVyaXRlZCBmcm9tXG4gICAgb3JpZ2luYWwgUHJpbWVOZyBEVCBldmVuIG5vdCBtYW55IHRoaW5ncyBnb3QgbGVmdCBhZnRlciB3ZSByZWZhY3RvciB0aGlzIGJ1dCB0aGUgaWRlYSBpcyB0aGVcbiAgICBzYW1lLlxuXG4gICAgRWFjaCBjZWxsIGhhcyBpdHMgZHQtY2VsbC1kZWYgY2xhc3MgdGhhdCBzZXRzIGRlZmF1bHQgc3R5bGluZyBsaWtlIGZvbnQsIGJhY2tncm91bmQsIGFsaWdubWVudFxuICAgIHBhZGRpbmcsIGV0Y3MuLlxuXG5cbi0tPlxuPG5nLXRlbXBsYXRlICNjb2xIZWFkZXIgbGV0LWlzU3ViSGVhZGVyIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCIgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDx0aCAjaGVhZGVyQ2VsbDEgW2NsYXNzXT1cImhlYWRlclN0eWxlQ2xhc3N8fHN0eWxlQ2xhc3NcIiAqbmdJZj1cIiFpc1N1YkhlYWRlclwiXG4gICAgICAgIChjbGljayk9XCJoYW5kbGVIZWFkZXJDbGljaygkZXZlbnQsIGhlYWRlckNlbGwxKVwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtaXMtZGVmYXVsdCBkdC11LXVuc2VsZWN0YWJsZS10ZXh0JyA6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWNlbGwtZGVmJzogZHQuc2VsZWN0aW9uTW9kZSAhPT0gJ2NlbGwnIHx8ICghZHQuaXNPdXRsaW5lKCkgfHwgIWR0LnBpdm90YWxMYXlvdXQpLFxuICAgICAgICAgICAgICAgICAgICAnZHQtdS1zb3J0YWJsZSc6IHNvcnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtaXMtYWN0aXZlJzogaXNTb3J0ZWQoKSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFpc1Zpc2libGV9XCJcbiAgICAgICAgW2F0dHIud2lkdGhdPVwid2lkdGhcIlxuICAgICAgICBbYXR0ci5hbGlnbl09XCJhbGlnblwiXG4gICAgICAgIFthdHRyLnRhYmluZGV4XT1cInNvcnRhYmxlID8gMSA6IG51bGxcIlxuICAgICAgICBbZHRNYXhXaWR0aF09XCJtYXhXaWR0aFB4XCJcbiAgICA+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImR0LmhlYWRlckZpbHRlclRlbXBsYXRlICYmIGNvbHVtbkluZGV4ID09PSAwIFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImR0LmhlYWRlckZpbHRlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPCEtLVxuICAgICAgICAgICAgd2hlbiBjZWxsIGFyZSBzZWxlY3RhYmxlIHdlIG5lZWQgdHdvIHZlcnNpb24gd2hlcmUgb25lIHdyYXAgdGhlIGNlbGwgY29udGVudCBpbiBkaXZcbiAgICAgICAgLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc0hlYWRlclNlbGVjdGFibGUoKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInNlbGVjdGFibGVIZWFkZXJDZWxsOyBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzSGVhZGVyU2VsZWN0YWJsZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9uU2VsZWN0YWJsZUhlYWRlckNlbGw7IGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXN9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RoPlxuXG4gICAgPHRoICNoZWFkZXJDZWxsMiBbY2xhc3NdPVwiaGVhZGVyU3R5bGVDbGFzc3x8c3R5bGVDbGFzc1wiICpuZ0lmPVwiaXNTdWJIZWFkZXJcIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmFsaWduXT1cImFsaWduXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LWNlbGwtZGVmIGR0LXN1Yi1oZWFkZXIgZHQtdS11bnNlbGVjdGFibGUtdGV4dCc6dHJ1ZX1cIlxuICAgICAgICBbZHRNYXhXaWR0aF09XCJtYXhXaWR0aFB4XCI+XG5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtdGl0bGVcIiAqbmdJZj1cImR0LnNob3dTdWJIZWFkZXIgJiYgc3ViSGVhZGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdWJIZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L3RoPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48IS0tXG4gICAgVGVtcGxhdGUgZm9yIHRoZSBib2R5ID0gdGhlIFRELiBGb3IgdGhlIGJvZHkgYW5kIHdlIG1pZ2h0IHdhbnQgdG8gZG8gdGhlIHNhbWUgZm9yIGhlYWRlciB3ZVxuICAgIGFsbG93IHRvIGhhdmUgY2FsY3VsYXRlZCBib2R5IGNsYXNzIHRoYXQgY29tZXMgZnJvbSB0aGUgYXBwbGljYXRpb24uIFNvIGJhc2VkIG9uIHRoZSBkYXRhIHR5cGVzXG4gICAgeW91IG1pZ2h0IHdhbnQgdG8gYXBwbHkgZGlmZmVyZW50IGNsYXNzIGluIG9yZGVyIHRvIGFwcGx5IGN1c3RvbSBzdHlsaW5nLlxuLS0+XG48bmctdGVtcGxhdGUgI2NvbEJvZHkgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDx0ZCAjY2VsbCBbY2xhc3NdPVwiZHluYW1pY0JvZHlDbGFzcyhkYXRhKVwiXG4gICAgICAgIChjbGljayk9XCJkdC5vbkNlbGxTZWxlY3Rpb25DaGFuZ2UoY2VsbCwgdGhpcywgZGF0YSlcIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmFsaWduXT1cImFsaWduXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCc6IHRydWUsXG4gICAgICAgICdkdC1jZWxsLWRlZic6ICFpc0NlbGxTZWxlY3RhYmxlKGRhdGEpLFxuICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWlzVmlzaWJsZX1cIlxuICAgICAgICBbZHRNYXhXaWR0aF09XCJtYXhXaWR0aFB4XCJcbiAgICAgICAgPlxuXG4gICAgICAgIDwhLS1cbiAgICAgICAgICAgIFNpbmNlIHdlIG5lZWQgdG8gc3VwcG9ydCBjZWxsIHNlbGVjdGlvbiB3aGVuIHdlIG5lZWQgdG8gZHJhdyBib3JkZXIgYXJvdW5kIGl0XG4gICAgICAgICAgICBXZSBhcmUgd3JhcHBpbmcgc3VjaCBzZWxscyB3aXRoIGRpdiB3aGljaCBnaXZlcyB1cyBiZXR0ZXIgZmxleGliaWxpdHlcbiAgICAgICAgLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc0NlbGxTZWxlY3RhYmxlKGRhdGEpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic2VsZWN0YWJsZUJvZHlDZWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4IH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzQ2VsbFNlbGVjdGFibGUoZGF0YSlcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub25TZWxlY3RhYmxlQm9keUNlbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvdGQ+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tXG4gICAgVG9kbzogY3JlYXRlIGJldHRlciBzb2x1dGlvbiBpbnN0ZWFkIG9mIHVzaW5nIGRpZmZlcmVudCB0ZW1wbGF0ZSBjcmVhdGUgZGlyZWN0aXZlIHRoYXQgd3JhcHNcbiAgICBpdCB3aXRoIHRoZSBkaXYgY29uZGl0aW9uYWxseVxuLS0+XG48bmctdGVtcGxhdGUgI3NlbGVjdGFibGVIZWFkZXJDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtY2VsbC1kZWYtc2VsZWN0YWJsZVwiXG4gICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWNlbGwtc2VsZWN0ZWQnOiBkdC5pc0hlYWRlclNlbGVjdGVkKHRoaXMpfVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyQ2VsbENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI25vblNlbGVjdGFibGVIZWFkZXJDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlckNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2hlYWRlckNlbGxDb250ZW50IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtdGl0bGVcIiAqbmdJZj1cInNob3dDb2x1bW5MYWJlbCAmJiAhaGVhZGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICB7e2xhYmVsfX1cbiAgICA8L3NwYW4+XG5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC10aXRsZVwiICpuZ0lmPVwic2hvd0NvbHVtbkxhYmVsICYmIGhlYWRlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIHJvd0RhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleCB9XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cblxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLXNvcnRhYmxlLWljb24gc2FwLWljb24gaWNvbi1zb3J0XCIgKm5nSWY9XCJzb3J0YWJsZVwiXG4gICAgICAgICAgW25nQ2xhc3NdPVwieydpY29uLXNvcnQtZGVzY2VuZGluZyc6IChnZXRTb3J0T3JkZXIoKSA9PSAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnaWNvbi1zb3J0LWFzY2VuZGluZyc6IChnZXRTb3J0T3JkZXIoKSA9PSAxKX1cIj5cbiAgICA8L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjc2VsZWN0YWJsZUJvZHlDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPGRpdiBjbGFzcz1cImR0LWNlbGwtZGVmLXNlbGVjdGFibGVcIlxuICAgICAgICAgW25nQ2xhc3NdPVwieydkdC1jZWxsLXNlbGVjdGVkJzogZHQuaXNCb2R5Q2VsbFNlbGVjdGVkKHRoaXMsIGRhdGEpfVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keUNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNub25TZWxlY3RhYmxlQm9keUNlbGwgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keUNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2JvZHlDZWxsQ29udGVudCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgIDwhLS1cbiAgICAgICAgICAgd2hlbiBubyB0ZW1wbGF0ZSBpcyB1c2VkIHVzZSBvdXIgRmllbGRQYXRoIHRvIGFjY2VzcyB0aGUgb2JqZWN0IHZhbHVlIGJhc2VkIG9uIHRoZVxuICAgICAgICAgICBrZXkgYmluZGluZ1xuICAgICAgICAtLT5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC1jZWxsLWRhdGFcIiAqbmdJZj1cIiFib2R5VGVtcGxhdGVcIj5cbiAgICAgICAgICAgIHt7ZHQuZ2V0VmFsdWUoZGF0YSwga2V5KX19XG4gICAgICAgIDwvc3Bhbj5cblxuXG4gICAgPCEtLVxuICAgICAgICBJbiBjYXNlIGFwcGxpY2F0aW9uIHdhbnRzIHRvIHByb3ZpZGUgdGhlaXIgb3duIGNlbGwgY29tcG9uZW50IHRoZXkgdXNlXG4gICAgICAgICNib2R5IG5nLXRlbXBsYXRlIHRvIGRvIHNvLlxuICAgIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLWNlbGwtZGF0YVwiICpuZ0lmPVwiYm9keVRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVRlbXBsYXRlO1xuICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgLmR0LXNvcnRhYmxlLWNvbHtjdXJzb3I6cG9pbnRlcn0uZHQtY29sLXNvcnRhYmxlLWljb257ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6LjEyNWVtfXRoLmR0LWNlbGwtZGVme2ZvbnQtd2VpZ2h0OjQwMDtjb2xvcjojNGE0YTRhfXRoLmR0LWlzLWRlZmF1bHR7YmFja2dyb3VuZC1jb2xvcjojZjJmMmYyO3doaXRlLXNwYWNlOm5vd3JhcH10aC5kdC1pcy1kZWZhdWx0LmR0LWNlbGwtZGVmOm5vdCguZHQtc3ViLWhlYWRlcil7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZjJmMmYyfXRoLmR0LXN1Yi1oZWFkZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmfXRoIC5kdC1jZWxsLXNlbGVjdGVke2JvcmRlci1jb2xvcjojNThiOTU3fXRkIC5kdC1jZWxsLXNlbGVjdGVke2JvcmRlci1sZWZ0LWNvbG9yOiM0ZjlmY2Z9LmR0LXJvb3Qtc2VjdGlvbiAuZHQtc2VsZWN0aW9uLWNvbHVtbiwuZHQtc2VsZWN0aW9uLWNvbHVtbnt3aWR0aDo0NnB4O3BhZGRpbmc6MCAxMnB4fS5kdC1waXZvdC1sYXlvdXQgdGQuZHQtc2VsZWN0aW9uLWNvbHVtbix0aC5kdC1zZWxlY3Rpb24tY29sdW1ue2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH10aGVhZCB0cjpmaXJzdC1jaGlsZCB0aHtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50fXRib2R5IHRyOmxhc3QtY2hpbGQ6bm90KC5kdC1kcmFnLXJvdy1ib3R0b20pIHRke2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnR9dGQ6Zmlyc3QtY2hpbGQsdGg6Zmlyc3QtY2hpbGR7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnR9dGQ6bGFzdC1jaGlsZCx0aDpsYXN0LWNoaWxke2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH10Ym9keSAuZHQtZHJhZy1yb3ctdG9wPnRke2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KDBkZWcsI2ZmZiAwLCNmZmYgOTclLCMwMjcxZDIgMTAwJSl9dGJvZHkgLmR0LWRyYWctcm93LWJvdHRvbT50ZHtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgxODBkZWcsI2ZmZiAwLCNmZmYgOTclLCMwMjcxZDIgMTAwJSl9dGJvZHkgLmR0LWRyYWctcm93LWJvdGg+dGR7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMGRlZywjMDI3MWQyIDAsI2ZmZiAzJSwjZmZmIDk3JSwjMDI3MWQyIDEwMCUpfXRib2R5IC5kdC1yb3ctZHJhZ2dpbmc+dGR7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjO2NvbG9yOiNiOWI5Yjl9dGJvZHkgLmR0LXJvdy1kcmFnZ2luZyAudWktc3RhdGUtYWN0aXZle29wYWNpdHk6LjU7Y3Vyc29yOm5vdC1hbGxvd2VkfWBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVENvbHVtbjJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBoZWFkZXIgbGFiZWwuXG4gICAgICpcbiAgICAgKiBPciB5b3UgY2FuIHVzZSBoZWFkZXJUZW1wbGF0ZSB0byBkZWZpbmUgeW91ciBvd24gdGVtcGxhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGZpZWxkIG5hbWUgdG8gcmVhZCBmcm9tIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDZWxsIGFsaWdubWVudC4gSXQgaW5zZXJ0cyByZWd1bGFyIGFsaWduIGF0dHJpYnV0ZSB0byB0aGUgdGFibGUgY2VsbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbjogRFRIQWxpZ25tZW50ID0gJ2xlZnQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZHluYW1pYyBjbGFzcyBiYXNlZCBvbiBkYXRhIGFuZCB0aGVuIGl0cyBhZGRlZCB0byB0aGUgdGFibGUgY2VsbCBURFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElmIGZhbHNlIGFwcGxpZXMgZHQtaXMtaGlkZGVuIHN0eWxlIHRoYXQgaGlkZXMgdGhlIGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogTWFya3MgY29sdW1uIGFzIHNvcnRhYmxlIHdoaWNoIG1lYW5zIHNvcnRpbmcgaWNvbiBpcyBhZGRlZCB0byB0aGUgaGVhZGVyIHdpdGggc3BlY2lhbFxuICAgICAqIHNvcnRpbmcgaGFuZGxpbmdcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNvcnRhYmxlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0aW5nIGRpcmVjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzb3J0T3JkZXJpbmc6IHN0cmluZyA9ICdkZXNjZW5kaW5nJztcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSB0ZW1wbGF0ZSBpZiB3aGV0aGVyIHRvIHJlbmRlciBhIGxhYmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dDb2x1bW5MYWJlbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGljIGNsYXNzIHRoYXQgaXMgYWRkZWQgdG8gdGhlIFRIIGludG8gdGhlIGhlYWRlci4gSXQgZG9lcyBub3QgcmVseSBvbiBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlYWRlclN0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGljIGNsYXNzIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRkIGludG8gdGhlIGJvZHkuIEl0IGRvZXMgbm90IHJlbHkgb24gZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5U3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHRvZ2V0aGVyIHdpdGggY2VsbCBzZWxlY3Rpb25Nb2RlIHRvIHRlbGwgd2hpY2ggY29sdW1uIGlzIHNlbGVjdGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgSEVBREVSIHRlbXBsYXRlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgU3ViSGVhZGVyIHRlbXBsYXRlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxTdWJIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgYm9keSB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxCb2R5OiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGNvbHVtbiBpcyBkYXRhIGNvbHVtbiAgLSBpZiBpdCBpcyByZW5kZXJpbmcgZGF0YSBvciBqdXN0IGEgbGFiZWwgb3Igc29tZVxuICAgICAqIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IHdoZW4gY2FsY3VsYXRpbmcgYSBjb2x1bW4gc3BhbiBhbmQgd2UgbmVlZCB0byBrbm93IHdoaWNoIGNvbHVtbnMgYXJlIG9yXG4gICAgICogd2lsbCBiZSBqdXN0IGZvciBzZWxlY3Rpb24gY29udHJvbHMgYW5kIHdoaWNoIGhvbGRzIGRhdGFcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzRGF0YUNvbHVtbjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGNvbHVtbiB0aGF0IHdpbGwgbm90IHNjcm9sbCBob3Jpem9udGFsbHkgd2l0aCBvdGhlciBjb2x1bW5zLiBDb2x1bW4gaXNcbiAgICAgKiBmcm96ZW4uXG4gICAgICpcbiAgICAgKiBGb3Igc3VjaCBjb2x1bW5zIHRoYXQgYXJlIG1hcmtlZCBhcyBmcm96ZW4gYmluZGluZyBbd2lkdGhdIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1heCBXaWR0aCBmb3IgdGhlIFRELiBFdmVuIFREIGRvZXMgbm90IHN1cHBvcnQgd2UgY2FsY3VsYXRlIHRoZSBjb250ZW50IHdpZHRoXG4gICAgICogZm9yIGVhY2ggY2VsbCBhbmQgdGhlbiBkZWNpZGUgaWYgd2UgbmVlZCB0byBlbmxhcmdlIHRoZSBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBARXhwZXJpbWFudGFsIGJpbmRpbmcgdGhhdCBpcyBjdXJyZW50bHkgd29ya2luZyBpZiB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBpcyBpbmxpbmVcbiAgICAgKiBlbGVtZW50IHdoZXJlIHdlIGNhbiBjb250cm9sIHdoaXRlc3BhY2Ugd3JhcHBpbmcgaW4gb3JkZXIgdG8gZmluZCBvdXQgdGhlIHJlYWwgd2lkdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heFdpZHRoOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1pbldpZHRoIG9uIHRoZSBjZWxsLiBBZ2FpbiBqdXN0IGxpa2UgbWF4V2lkdGggY3NzIHByb3Blcmx5IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICAgKiB0aGUgdGFibGUgc28gdGhlcmUgaXMgYSB3b3JrYXJvdW5kIHdoZXJlIHdlIGNyZWF0ZSBhZGRpdGlvbmFsIHJvdyB0aGF0IHNldHMgcGFkZGluZyByaWdodFxuICAgICAqIGFuZCB0aGlzIHdpbGwgcHJldmVudCB0aGUgY29sdW1uIHRvIGNvbGxhcHNlIHVuZGVyIHNwZWNpZmllZCB3aWR0aFxuICAgICAqXG4gICAgICogdG9kbzogc3RpbGwgVEJEXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtaW5XaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTWFpbiByZW5kZXJpbmcgdGVtcGxhdGUgdXNlZCBieSBkYXRhdGFibGUgdG8gcmVuZGVyIGVhY2ggY29sdW1uLlxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3JlbmRlcmluZ1RlbXBsYXRlJylcbiAgICByZW5kZXJlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGhlYWRlciB0ZW1wbGF0ZS4gSXQgd2lsbCBvdmVycmlkZSBwcm92aWRlZCBsYWJlbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlcicpXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gc3ViSGVhZGVyIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ3N1YkhlYWRlcicpXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gYm9keSB0ZW1wbGF0ZSB0aGF0IHdpbGwgb3ZlcnJpZGUgcmVhZCB2YWx1ZSBmcm9tIHRoZSBba2V5XSBiaW5kaW5nXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4uLlxuICAgICAqL1xuICAgIHNvcnRPcmRlcjogbnVtYmVyO1xuICAgIG1heFdpZHRoUHg6IG51bWJlciA9IDA7XG4gICAgbWluV2lkdGhQeDogbnVtYmVyID0gMDtcbiAgICB3aWR0aFB4OiBudW1iZXIgPSAwO1xuICAgIHdpZGVzdENlbGw6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gRGF0YXRhYmxlIEltcGxlbWVudGF0aW9uc1xuICAgICAqL1xuICAgIGR0OiBBV0RhdGFUYWJsZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmtleSkgJiYgaXNCbGFuayh0aGlzLmxhYmVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGJpbmRpbmc6ICcgK1xuICAgICAgICAgICAgICAgICdba2V5XSBvciBbbGFiZWxdIGJpbmRpbmdzIG11c3QgYmUgdXNlZCBhdCBtaW5pbXVtJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBiZSBhYmxlIHRvIHBvc2l0aW9uIHNlY29uZCBEVCB3ZSByZXF1aXJlIFt3aWR0aF0gdG8gYmUgc2V0IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMuZnJvemVuICYmIGlzQmxhbmsodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBiaW5kaW5nIFt3aWR0aF06ICcgK1xuICAgICAgICAgICAgICAgICd3aGVuIFtmcm96ZW5dPXRydWUgdGhlbiBbd2lkdGhdIGJpbmRpbmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcblxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBuZWVkIHRvIGRlZmZlciB0aGlzIGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gb3RoZXJ3aXNlIEkgZ2V0XG4gICAgICAgIC8vIHZhbHVlIHdhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkIGVycm9yXG4gICAgICAgIC8vIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgLy8ge1xuXG4gICAgICAgIC8vIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBjZWxsIHNlbGVjdGlvbk1vZGUgaXMgZW5hYmxlZCB0aGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB3ZSBjbGljayBvbiBoZWFkZXIuXG4gICAgICogSXQgZGVsZWdhdGVzIHRoZSBjYWxsIHRvIHRoZSBEVCB3aGVyZSBpdCB0b2dnbGVzIGN1cnJlbnRseSBzZWxlY3RlZCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlSGVhZGVyQ2xpY2soZXZlbnQ6IGFueSwgZWxlbWVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHQub25IZWFkZXJTZWxlY3Rpb25DaGFuZ2UoZWxlbWVudCwgdGhpcyk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUb2RvOiBJbXBsZW1lbnQgb3VyIG93biBzb3J0aW5nIG1lY2hhbmlzbSBvbmNlIHdlIGV4dHJhY3QgdGhlIHNvcnRpbmcgbG9naWMgdG8gaXRzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgc29ydChldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmICh0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3ModGFyZ2V0Tm9kZSwgJ2R0LXUtc29ydGFibGUnKSB8fFxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHRhcmdldE5vZGUsICdkdC1jb2wtdGl0bGUnKSB8fFxuICAgICAgICAgICAgdGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHRhcmdldE5vZGUsICdkdC1jb2wtc29ydGFibGUtaWNvbicpKVxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmR0LnNvcnRDb2x1bW4ua2V5ID09PSB0aGlzLmtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyID0gdGhpcy5zb3J0T3JkZXIgKiAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRPcmRlcmluZyA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yTnVtYmVyKHRoaXMuc29ydE9yZGVyKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LnNvcnRDb2x1bW4gPSB0aGlzO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuc29ydEtleSA9IHRoaXMua2V5O1xuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLnNvcnRPcmRlciA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuc29ydE9yZGVyaW5nKTtcblxuICAgICAgICAgICAgdGhpcy5kdC5zb3J0U2luZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kdC51cGRhdGVEYXRhVG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIHN0eWxlIGNsYXNzIGJhc2VkIG9uIGRhdGFcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgZHluYW1pY0JvZHlDbGFzcyhpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgZHluQ2xhc3MgPSBpc1ByZXNlbnQodGhpcy5ib2R5Q2xhc3NGbilcbiAgICAgICAgICAgID8gdGhpcy5ib2R5Q2xhc3NGbi5hcHBseSh0aGlzLmR0LmNvbnRleHQsIFt0aGlzLCBpdGVtXSkgOiAnJztcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYm9keVN0eWxlQ2xhc3MpKSB7XG4gICAgICAgICAgICBkeW5DbGFzcyArPSAnICcgKyB0aGlzLmJvZHlTdHlsZUNsYXNzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIGR5bkNsYXNzICs9ICcgJyArIHRoaXMuc3R5bGVDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkeW5DbGFzcztcbiAgICB9XG5cblxuICAgIGlzUm93U2VsZWN0YWJsZShpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuaXNSb3dTZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHQuaXNSb3dTZWxlY3RhYmxlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlzQ2VsbFNlbGVjdGFibGUoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHQuc2VsZWN0aW9uTW9kZSA9PT0gJ2NlbGwnICYmIHRoaXMuaXNSb3dTZWxlY3RhYmxlKGl0ZW0pICYmIHRoaXMuc2VsZWN0YWJsZTtcblxuICAgIH1cblxuXG4gICAgaXNIZWFkZXJTZWxlY3RhYmxlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LnNlbGVjdGlvbk1vZGUgPT09ICdjZWxsJyAmJiB0aGlzLnNlbGVjdGFibGU7XG5cbiAgICB9XG5cblxuICAgIGdldFNvcnRPcmRlcigpXG4gICAge1xuICAgICAgICBsZXQgb3JkZXIgPSAwO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmtleSA9PT0gdGhpcy5kdC5zb3J0Q29sdW1uLmtleSkge1xuICAgICAgICAgICAgb3JkZXIgPSB0aGlzLmR0LnNvcnRDb2x1bW4uc29ydE9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG5cbiAgICBpc1NvcnRlZCgpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZHQuc29ydENvbHVtbikgJiYgdGhpcy5rZXkgPT09IHRoaXMuZHQuc29ydENvbHVtbi5rZXk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSh0YWJsZTogQVdEYXRhVGFibGUpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0ID0gdGFibGU7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LmluaXRpYWxTb3J0S2V5KSAmJiB0aGlzLmR0LmluaXRpYWxTb3J0S2V5ID09PSB0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuZHQuaW5pdGlhbFNvcnRPcmRlcik7XG4gICAgICAgICAgICB0aGlzLmR0LnNvcnRDb2x1bW4gPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5ib2R5VGVtcGxhdGUpICYmIHRoaXMudXNlR2xvYmFsQm9keSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5VGVtcGxhdGUgPSB0aGlzLmR0LmJvZHlUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuaGVhZGVyVGVtcGxhdGUpICYmIHRoaXMudXNlR2xvYmFsSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlclRlbXBsYXRlID0gdGhpcy5kdC5oZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3ViSGVhZGVyVGVtcGxhdGUpICYmIHRoaXMudXNlR2xvYmFsU3ViSGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YkhlYWRlclRlbXBsYXRlID0gdGhpcy5kdC5zdWJIZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuYm9keUNsYXNzRm4pKSB7XG4gICAgICAgICAgICB0aGlzLmJvZHlDbGFzc0ZuID0gdGhpcy5kdC5ib2R5Q2xhc3NGbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWF4V2lkdGhQeCA9IHRoaXMud2lkdGhUb1B4KHRoaXMubWF4V2lkdGgpO1xuICAgICAgICB0aGlzLm1pbldpZHRoUHggPSB0aGlzLndpZHRoVG9QeCh0aGlzLm1pbldpZHRoKTtcbiAgICAgICAgdGhpcy53aWR0aFB4ID0gdGhpcy53aWR0aFRvUHgodGhpcy53aWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHZpZXcgaW5pdCBjeWNsZSBmcm9tIHRoZSBkdC5uZ0FmdGVyVmlld0NoZWNrZWQuXG4gICAgICpcbiAgICAgKiBJbiBjYXNlIHdlIHVzZSBNYXhXaWR0aCBkaXJlY3RpdmUgd2Ugc2V0IG5ldyB3aWR0aCBvbmNlIGZvciBhbGwgY29sdW1zblxuICAgICAqL1xuICAgIHBvc3RJbml0aWFsaXplKG15SW5kZXg6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IGNvbEluZGV4ID0gbXlJbmRleCArIDE7XG4gICAgICAgIGxldCB0YWJsZTtcblxuICAgICAgICBpZiAodGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIHRhYmxlID0gKDxEYXRhdGFibGUyQ29tcG9uZW50PnRoaXMuZHQpLmVsXG4gICAgICAgICAgICAgICAgLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWJvZHktZnJvemVuIHRhYmxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWJsZSA9ICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0aGlzLndpZGVzdENlbGwgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWxsID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgndHIgdGg6bnRoLWNoaWxkKCcgKyBjb2xJbmRleCArICcpLCAnICtcbiAgICAgICAgICAgICAgICAndHIgdGQ6bnRoLWNoaWxkKCcgKyBjb2xJbmRleCArICcpJykuZm9yRWFjaCgobm9kZTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB0aGlzLndpZGVzdENlbGwgKyAncHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFlvdSBlaXRoZXIgdXNlIHRoaXMgYmluZGluZyBkaXJlY3RseSBhbmQgc2F5IGl0cyBkYXRhY29sdW1uIG9yIHdoZW4gdGhlcmUgaXMgYSBba2V5XVxuICAgICAqIGJpZGluZyB3ZSBrbm93IGl0IHJlZmVycyB0byBzb21lIGZpZWxkLlxuICAgICAqXG4gICAgICovXG4gICAgaXNWYWx1ZUNvbHVtbigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGlzUHJlc2VudCh0aGlzLmlzRGF0YUNvbHVtbikgJiYgQm9vbGVhbldyYXBwZXIuaXNUcnVlKHRoaXMuaXNEYXRhQ29sdW1uKSkgfHxcbiAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLmtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBhcmUgaW4gb3V0bGluZSBtb2RlICB3ZSBuZWVkIHRvIGFsc28gaW5kZW5kIGVhY2ggc2VsZWN0aW9uIGNvbnRyb2wgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBpbmRlbnQgLSAxID4gb25seSBvZmZzZXQgd2l0aFxuICAgICAqIGluZGVudFxuICAgICAqL1xuICAgIGluZGVudEZvckNvbnRyb2woY2VsbDogYW55LCBsZXZlbDogbnVtYmVyKTogYW55XG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5pc091dGxpbmUoKSAmJiBsZXZlbCA+IDAgJiYgY2VsbC5vZmZzZXRXaWR0aCA+IDBcbiAgICAgICAgICAgICYmIGlzUHJlc2VudChjZWxsLm5leHRFbGVtZW50U2libGluZykpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgbGV0IG91dGxpbmVOb2RlUGFkZGluZyA9XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShjZWxsLm5leHRFbGVtZW50U2libGluZykucGFkZGluZ0xlZnQpIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIDFzdCBsZXZlbCBpcyBwdXNoZWQgYXMgcm9vdFxuICAgICAgICAgICAgaWYgKHRoaXMuZHQucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChsZXZlbCA9PT0gMSkgPyBudWxsIDogKHRoaXMuZHQuaW5kZW50YXRpb25QZXJMZXZlbCAqIGxldmVsKVxuICAgICAgICAgICAgICAgICAgICAtIG91dGxpbmVOb2RlUGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmR0LmluZGVudGF0aW9uUGVyTGV2ZWwgKiBsZXZlbCkgKyBvdXRsaW5lTm9kZVBhZGRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEludGVybmFsXG4gICAgICovXG4gICAgcHJpdmF0ZSB3aWR0aFRvUHgod2lkdGg6IHN0cmluZyk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IHB4O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHdpZHRoKSkge1xuICAgICAgICAgICAgaWYgKHdpZHRoLmluZGV4T2YoJyUnKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub25QYyA9IHBhcnNlRmxvYXQod2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgICAgIHB4ID0gbm9uUGMgKiAoPERhdGF0YWJsZTJDb21wb25lbnQ+dGhpcy5kdCkuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBweDtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGRhdGF0YWJsZSBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIERhdGFUYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtaGVhZGVyMicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBEVEhlYWRlckNvbXBvbmVudDJcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZX0gZnJvbSAnLi4vLi4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqXG4gKiBDdXN0b20gY29sdW1uIGltcGxlbWVudGF0aW9uIHRvIHJlbmRlciBkZXRhaWwgcm93IHNwYW5pbmcgaXRzIGNvbHVtbiBhY3Jvc3Mgd2hvbGUgdGFibGUgd2lkdGguXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1kZXRhaWwtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBSZW5kZXJzIGFwcGxpY2F0aW9uIGRlZmluZWQgZGV0YWlsIGNvbHVtbi4gVGhpcyB0ZW1wbGF0ZSBqdXN0IHJlbmRlcnMgYSBkZXRhaWwgcm93IGFuZFxuICAgIG5vdCBleHBhbnNpb24gY29udHJvbC4gVGhpcyBpcyBpbXBsZW1lbnRlZCBieSBkaWZmZXJlbnQgRHRDb2x1bW4gaW1wbGVtZW50YXRpb24gYW5kIGl0cyBhZGRlZFxuICAgICh3aWxsIGJlKSBhZGRlZCBwcm9ncmFtbWF0aWNhbGx5IGR1cmluZyBjb2x1bW4gaW5pdGlhbGl6YXRpb25cbi0tPlxuPG5nLXRlbXBsYXRlICNyZW5kZXJpbmdUZW1wbGF0ZSBsZXQtY29sdW1uPVwiY29sdW1uXCIgbGV0LXJvd0RhdGE9XCJkYXRhXCI+XG5cbiAgICA8dHIgI2RldGFpbFJvd0VsZW1lbnQgY2xhc3M9XCJkdC1ib2R5LXJvdyBkdC1kZXRhaWwtcm93XCI+XG5cbiAgICAgICAgPHRkICpuZ0lmPVwiZHQuaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKClcIiB3aWR0aD1cIjFweFwiPjwvdGQ+XG4gICAgICAgIDx0ZCAqbmdJZj1cInZpc2libGVMZWFkaW5nQ29scygpID4gMFwiIGNvbHNwYW49XCJ2aXNpYmxlTGVhZGluZ0NvbHMoKVwiIHdpZHRoPVwiMXB4XCI+XG4gICAgICAgICAgICAmbmJzcDsmbmJzcDtcbiAgICAgICAgPC90ZD5cbiAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiZHQuc3RhcnRPZkZpcnN0RGF0YUNvbHVtblwiIFtjbGFzc109XCJkeW5hbWljQm9keUNsYXNzKHJvd0RhdGEpXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQgZHQtY2VsbC1kZWYnOiB0cnVlfVwiPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5VGVtcGxhdGU7IGNvbnRleHQ6eyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTpyb3dEYXRhfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvdGQ+XG4gICAgPC90cj5cbjwvbmctdGVtcGxhdGU+XG5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVERldGFpbFJvd0NvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXJyZW50IHZpc2liaWxpdHkgZm9yIGN1cnJlbnQgZGF0YSByb3cgdXNpbmcgbWV0aG9kIHJlZmVyZW5jZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Zpc2libGVGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogdGVsbHMgaWYgd2UgbmVlZCB0byByZW5kZXIgYSBsaW5lIGJldHdlZW4gaXRlbSByb3cgYW5kIGl0cyBkZXRhaWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1Jvd0xpbmU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8ganVzdCB0byBnZXQgYXJvdW5kIHRoZSBjaGVjayBpbiBwYXJlbnQgY2xhc3NcbiAgICAgICAgdGhpcy5rZXkgPSAnJztcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHdlIG5lZWQgdG8ga2VlcCBzb21lIGxlYWRpbmcgVERzXG4gICAgICpcbiAgICAgKi9cbiAgICB2aXNpYmxlTGVhZGluZ0NvbHMoKTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5udW1iZXJPZkNvbHNCZWZvcmVEYXRhIC0gKHRoaXMuZHQuaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCkgPyAxIDogMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHdlIGNhbiBzaG93IGRldGFpbCByb3cvY29sdW1uIHVzaW5nIGVpdGhlciBbaXNWaXNpYmxlXSBvciBbaXNWaXNpYmxlRm5dIGJpbmRpbmdzLlxuICAgICAqIEhlcmUgY2FuIGhvb2sgb24gYXBwbGljYXRpb24gbGV2ZWwgY3VzdG9tIG1ldGhvZCB0byBkZWNpZGUgaWYgY3VycmVudCBpdGVtIGhhcyBkZXRhaWwgcm93XG4gICAgICogb3Igbm90XG4gICAgICpcbiAgICAgKiBPciB3ZSBjYW4gdXNlIGlzVmlzaWJsZT10cnVlIHRvIHRlbGwgYWxsIHJvdyBoYXZlIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dEZXRhaWxSb3coaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaXNWaXNpYmxlRm4pKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZUZuLmFwcGx5KHRoaXMuZHQuY29udGV4dCwgW3RoaXMsIGl0ZW1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH1cblxuXG4gICAgaW5pdGlhbGl6ZSh0YWJsZTogQVdEYXRhVGFibGUpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKHRhYmxlKTtcblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9ICF0aGlzLmR0LmlzT3V0bGluZSgpIHx8ICF0aGlzLmR0LnBpdm90YWxMYXlvdXQ7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWRldGFpbC1jb2x1bW4tZXhwYW5kJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgIFNwZWNpYWwgY29sdW1uIHRoYXQgcmVuZGVycyBleHBhbmQvY29sbGFwc2UgY29udHJvbCBmb3IgZGV0YWlsIHJvdyB3aGVuIGRldGFpbCByb3cgaXMgZW5hYmxlZC5cblxuICAgSnVzdCBsaWtlIGZvciB0aGUgb3RoZXIgY29sdW1uIGl0IHJlbmRlcnMgaGVhZGVyIHNlY3Rpb24gYXMgd2VsbCBhcyBib2R5IHNlY3Rpb24gd2l0aFxuICAgZXhwYW5kIGNvbnRyb2wgdG8gdG9nZ2xlIHRoZSBleHBhbnNpb25cblxuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1pc0hlYWRlciBsZXQtaXNTdWJIZWFkZXI9XCJpc1N1YkhlYWRlclwiIGxldC1jb2x1bW49XCJjb2x1bW5cIlxuICAgICAgICAgICAgIGxldC1kYXRhVG9SZW5kZXI9XCJkYXRhXCIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNIZWFkZXIgJiYgIWlzU3ViSGVhZGVyXCI+XG4gICAgICAgIDx0aCAjaGVhZGVyQ2VsbDEgW2NsYXNzXT1cImhlYWRlclN0eWxlQ2xhc3N8fHN0eWxlQ2xhc3NcIlxuICAgICAgICAgICAgY2xhc3M9XCJkdC1yb3ctY2VsbC1leHBhbmRvXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtaXMtZGVmYXVsdCBkdC11LXVuc2VsZWN0YWJsZS10ZXh0IGR0LWNlbGwtZGVmJyA6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkdC1kZXQtcm93LWV4cGFuZGVkJzogZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuaXNFeHBhbmRlZChkYXRhVG9SZW5kZXIpfVwiPlxuICAgICAgICA8L3RoPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNIZWFkZXIgJiYgIWlzU3ViSGVhZGVyXCI+XG4gICAgICAgIDx0ZCAjY2VsbFxuICAgICAgICAgICAgY2xhc3M9XCJkdC1yb3ctY2VsbC1leHBhbmRvXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtY2VsbC1kZWYnOiAhaXNDZWxsU2VsZWN0YWJsZShkYXRhVG9SZW5kZXIpLFxuICAgICAgICAgICAgICAgICAgICAnZHQtZGV0LXJvdy1leHBhbmRlZCc6IGR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoZGF0YVRvUmVuZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWRldC1yb3ctd2l0aC1sbicgOiBkdC5yb3dEZXRhaWxDb2x1bW4uc2hvd1Jvd0xpbmV9XCI+XG5cbiAgICAgICAgICAgIDxzcGFuIChjbGljayk9XCJ0b2dnbGVFeHBhbnNpb24oJGV2ZW50LCBkYXRhVG9SZW5kZXIpXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZHQtZGV0LXJvdy1leHBhbmQgc2FwLWljb25cIlxuICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY2FsY3VsYXRlU3R5bGVDbGFzcyhkYXRhVG9SZW5kZXIpXCI+XG5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8L3RkPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG48L25nLXRlbXBsYXRlPlxuXG5gLFxuICAgIHN0eWxlczogW2AuZHQtcm93LWNlbGwtZXhwYW5kb3t3aWR0aDoxNHB4O3RleHQtYWxpZ246cmlnaHQ7cGFkZGluZzoxN3B4IDVweCAxN3B4IDE3cHg7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kdC1yb3ctY2VsbC1leHBhbmRvIC5kdC1kZXQtcm93LWV4cGFuZHtjdXJzb3I6cG9pbnRlcjtsaW5lLWhlaWdodDoyMXB4fXRkLmR0LWRldC1yb3ctZXhwYW5kZWQ6bm90KC5kdC1kZXQtcm93LXdpdGgtbG4pLHRkLmR0LWRldC1yb3ctZXhwYW5kZWQ6bm90KC5kdC1kZXQtcm93LXdpdGgtbG4pfnRke2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnR9YF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQgZXh0ZW5kcyBEVENvbHVtbjJDb21wb25lbnRcbntcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG5cbiAgICAgICAgLy8gd2UgZG9udCB3YW50IHRvIHNob3cgdGhlIHJvdy9jb2x1bW4gdW5sZXNzIGFwcGxpY2F0aW9uIHNheXMgc29cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8ganVzdCB0byBnZXQgYXJvdW5kIHRoZSBjaGVjayBpbiBwYXJlbnQgY2xhc3NcbiAgICAgICAgdGhpcy5rZXkgPSAnJztcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuICAgIHRvZ2dsZUV4cGFuc2lvbihldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLnRvZ2dsZShpdGVtKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlU3R5bGVDbGFzcyhpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoaXRlbSkgP1xuICAgICAgICAgICAgJ2ljb24tc2xpbS1hcnJvdy1kb3duJyA6ICdpY29uLXNsaW0tYXJyb3ctcmlnaHQnO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5cblxuaW1wb3J0IHtUZW1wbGF0ZVJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1NlbGVjdGlvbk1vZGV9IGZyb20gJy4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5pbXBvcnQge0RldGFpbFJvd0V4cGFuc2lvblN0YXRlLCBEVDJEYXRhU291cmNlfSBmcm9tICcuL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtPdXRsaW5lU3RhdGV9IGZyb20gJy4uL291dGxpbmUnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IGNvbnN0IERyYWdFdmVudHM6IHN0cmluZ1tdID0gWydtb3VzZWRvd24nLCAnZHJhZ3N0YXJ0JywgJ2RyYWdvdmVyJywgJ2RyYWdlbnRlcicsICdkcmFnbGVhdmUnLFxuICAgICdkcm9wJywgJ2RyYWdlbmQnXTtcblxuZXhwb3J0IGVudW0gRHJhZ0RpcmVjdGlvblxue1xuICAgIE5vbmUgPSAnbm9uZScsXG4gICAgVXAgPSAnZHQtZHJhZy1yb3ctdG9wJyxcbiAgICBEb3duID0gJ2R0LWRyYWctcm93LWJvdHRvbScsXG4gICAgTWlkZGxlID0gJ2R0LWRyYWctcm93LWJvdGgnXG59XG5cblxuZXhwb3J0IGVudW0gRHJvcFBvc2l0aW9uXG57XG4gICAgQmVmb3JlID0gJ2JlZm9yZScsXG4gICAgQWZ0ZXIgPSAnYWZ0ZXInLFxuICAgIEludG8gPSAnaW50bydcbn1cblxuXG4vKipcbiAqIEFic3RyYWN0IHR5cGUgdGhhdCBpcyBzaGFyYWJsZSBhbW9uZyBkZXBlbmRhbnQgRFQgb2JqZWN0IHN1Y2ggYXMgQ29sdW1ucywgRGF0YVNvdXJjZXMsXG4gKiBEaXJlY3RpdmVzIHRvIGJlIGFibGUgdG8gY29tbXVuaWNhdGUgYmFjayB0byB0aGUgZGF0YXRhYmxlIG1haW5seSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQVdEYXRhVGFibGVcbntcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyB5b3UgdG8gcGFzcyB5b3VyIG93biBkYXRhc291cmNlIHRvIG92ZXJyaWRlIGRlZmF1bHQgb25lLiBBbHNvIHdoZW4gZGF0YVNvdXJjZSBpc1xuICAgICAqIHVzZWQgdGhlIGRlc3RpbmF0aW9uQ2xhc3Mgb3IgbGlzdCBhcmUgaWdub3JlZFxuICAgICAqL1xuICAgIGRhdGFTb3VyY2U6IERUMkRhdGFTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIG91dGxpbmUgc3RhdGVzIGZvciBEYXRhdGFibGVzIHVzaW5nIG91dGxpbmUgY29udHJvbFxuICAgICAqL1xuICAgIG91dGxpbmVTdGF0ZTogT3V0bGluZVN0YXRlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIGhhdmUgZGV0YWlsIHJvdyByZW1lbWJlciBpdHMgZXhwYW5zaW9uIHN0YXRlXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5zaW9uU3RhdGU6IERldGFpbFJvd0V4cGFuc2lvblN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBjb2x1bW4gaXMgdXNlZCBhcyBmaXJzdCBmb3Igc29ydGluZ1xuICAgICAqL1xuICAgIGluaXRpYWxTb3J0S2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyB0byBjaGFuZ2Ugc29ydGluZyBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBpbml0aWFsU29ydE9yZGVyOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIERUIGlmIHdlIHN1cHBvcnQgY2VsbCBzZWxlY3Rpb24gb3Igcm93IGJhc2VkIHNlbGVjdGlvbiB3aGljaCBpcyByZWd1bGFyIERULlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZTtcblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugb2Ygc2luZ2xlIG9yIG11bHRpc2VsZWN0aW9uIHNob3cgY29udHJvbHNcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTZWxlY3Rpb25Db2x1bW46IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB3ZSB3YW50IHRvIHJlbmRlciBvbmUgc2VsZWN0aW9uIGNvbnRyb2wgaW4gdGhlIGhlYWRlciB0byBzZWxlY3QgYWxsIHRoZVxuICAgICAqIHJvd3MuIEFwcGxpY2FibGUgZm9yIG11bHRpc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93U2VsZWN0QWxsOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZnkgaWYgcm93IG9yIGNlbGwgaXMgc2VsZWN0YWJsZSBiYXNlZCBvbiBkYXRhXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RhYmxlOiAoaXRlbTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBFYWNoIERUQ29sdW1uIGhhdmUgaGF2ZSBpdHMgb3duIHRlbXBsYXRlIHRvIHByb3ZpZGUgY29udGVudCBmb3IgaGVhZGVyLCBzdWJoZWFkZXIgYW5kXG4gICAgICogYm9keSBidXQgaWYgdGhvc2UgdGVtcGxhdGUgYXJlIGlkZW50aWNhbCB0aGVyZSB3b3VsZCBiZSB0b28gbXVjaCBkdXBsaWNhdGUgY29kZSB0byByZXBsaWNhdGVcbiAgICAgKiBmb3IgZWFjaCBjb2x1bW4gdGhlIHNhbWUuIFRoZXJlZm9yZSB3ZSBoYXZlIHRoZXNlIGdsb2JhbCB0ZW1wbGF0ZXMgdGhhdCB5b3UgY2FuIGRlY2xhcmVcbiAgICAgKiBvbiBEVCBsZXZlbCAobm90IHVuZGVyIGNvbHVtbnMpIGFuZCBjb250ZW50IG9mIHRoZXNlIHRlbXBsYXRlIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBjb2x1bW5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gbWl4IHRoZW0gYXMgd2VsbC4gWW91IGNhbiBoYXZlIGdsb2JhbCB0ZW1wbGF0ZXMgYXMgd2VsbCBhcyB0ZW1wbGF0ZSBvbiB0aGUgQ29sdW1uXG4gICAgICogbGV2ZWwgd2hpY2ggd291bGQgb3ZlcnJpZGUgdGhlIGdsb2JhbCBvbmVcbiAgICAgKlxuICAgICAqL1xuICAgIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBzdWJIZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgaGVhZGVyRmlsdGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlbmRlciBhIHN1YkhlYWRlciB0ZW1wbGF0ZSBpZiBwcmVzZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBnbG9iYWwgc3R5bGUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgYm91bmQgdG8gdGFibGUgYW5kIHJlYWQgYnkgZWFjaCBjb2x1bW4uXG4gICAgICogVGhlIHNhbWUgeW91IGNhbiBzZWUgb24gdGhlIERUQ29sdW1uXG4gICAgICovXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbnRleHQgaXMgaW1wb3J0YW50IHdoZW4gd2UgZXhlY3V0ZSBhbnkgZnVuY3Rpb24gdGhhdCBpcyBwYXNzZWQgaW4gYXMgaW5wdXQuIFdlIG5lZWQgdG9cbiAgICAgKiBnaXZlIG9wdGlvbiB0byBiZSBleGVjdXRlZCB3aXRoaW4gdGhlIGNvbnRleHQgKHRoaXMpIG9mIHRoZSBjb2RlIHVzaW5nIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICovXG4gICAgY29udGV4dDogYW55O1xuXG4gICAgLy8gT3V0bGluZSBuZWVkZWQgcHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIG91dGxpbmVGb3Igc2VjdGlvbiBvbiB0aGUgbmV3IGxpbmUgYW5kIDJuZCBsZXZlbCBjaGlsZCBtYWtlIGl0IHJvb3QgZm9yIHRoaXNcbiAgICAgKiBzZWN0aW9uXG4gICAgICovXG4gICAgcHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBjaGFuZ2UgZGVmYXVsdCBpbmRlbnRhdGlvbiBmb3IgdGhlIG91dGxpbmUgbm9kZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGluZGVudGF0aW9uUGVyTGV2ZWw6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYWN0aXZlIGFwcGxpZXMgc3BlY2lhbCBzdHlsZXMgdG8gdGhlIERULiBMYXRlciBvbiBvbmNlIHBpdm90IGlzIGltcGxlbWVudGVkIHRoaXMgd2lsbFxuICAgICAqIGFsc28gYWRkIGFkZGl0aW9uYWwgYmVoYXZpb3IgdG8gdGhlIERUXG4gICAgICpcbiAgICAgKi9cbiAgICBwaXZvdGFsTGF5b3V0OiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNvcnRpbmcgaXMgZW5hYmxlZCB0aGlzIGlzIGN1cnJlbnQgYWN0aXZlIGNvbHVtbiBiZWluZyBzb3J0ZWQuXG4gICAgICpcbiAgICAgKiAgLSB3ZSBkb250IHN1cHBvcnQgbXVsdGlwbGUgY29sdW1uIHNvcnRpbmdcbiAgICAgKi9cbiAgICBzb3J0Q29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gYXctZHQtZGV0YWlsLWNvbHVtbiBpZiBwcmVzZW50IGRldGFpbCByb3cgaXMgcmVuZGVyZWQgZm9yIHNwZWNpZmllZFxuICAgICAqIGl0ZW1zXG4gICAgICovXG4gICAgcm93RGV0YWlsQ29sdW1uOiBEVERldGFpbFJvd0NvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHNwYW5pbmcgY2FsY3VsYXRpb24gb3IgZm9yIHRoZSBkZXRhaWwgcm93IHRvIGlkZW50aWZ5IGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiB0byBzcGFuLCB3aGVuIHRoZXkgYXJlIHNvbWUgbm9uLWRhdGEgY29sdW1uIChleHBhbnNpb24gY29udHJvbCwgc2luZ2xlL211bHRpIHNlbGVjdGlvbilcbiAgICAgKi9cbiAgICBudW1iZXJPZkNvbHNCZWZvcmVEYXRhOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqICB3aGF0IGlzIHRoZSBpbmRleCBvZiBmaXJzdCBkYXRhIGNvbHVtbnNcbiAgICAgKi9cbiAgICBzdGFydE9mRmlyc3REYXRhQ29sdW1uOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGluIGNlbGwgc2VsZWN0aW9uIG1vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2VsbFNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgY29sdW1uIHdoZSBoZWFkZXIgaXMgc2VsZWN0ZWQuIEN1cnJlbnQgd2UgYXNzdW1lIHRoZSBvbmx5IG9uZSBoZWFkZXIgY2FuIGJlXG4gICAgICogc2VsZWN0ZWQgYXQgdGhlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhlYWRlclNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50KTogdm9pZDtcblxuXG4gICAgb25IYW5kbGVSb3dDbGlja2VkKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhhbmRsZXMgcm93IHNlbGVjdGlvbiBsb2dpYyB3aGVyZSBpZiB0aGUgaXRlbSBpcyBmb3VuZCBpbnNpZGUgdGhlIHNlbGVjdGVkIGl0ZW1zLCB0aGVuXG4gICAgICogaXRzIHJlbW92ZWQgb3RoZXJ3aXNlIGl0cyBhZGRlZC5cbiAgICAgKlxuICAgICAqIFRvZG86IFN5bmMgJiByZWZhY3RvciB0aGlzIHdpdGggZHQub25DZWxsU2VsZWN0aW9uQ2hhbmdlIC0gcHJldHR5IHNpbWlsYXIgY29kZVxuICAgICAqXG4gICAgICogV2Ugd2FudCB0byBoYXZlIHJvd1RvZ2dsZSBhcyB3ZWxsIGFzIHdlIHdpbGwgaGF2ZSByb3dTZWxlY3Qgb3Igc29tZXRoaWduIHNpbWlsYXIgdG9cbiAgICAgKiBpZGVudGlmeSB3ZSBhcmUgZGVhbGluZyB3aXRoIG11bHRpc2VsZWN0IGFuZCBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICovXG4gICAgb25Sb3dUb2dnbGUoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBIYW5kbGVzIHJvdyBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBvblJvd1NlbGVjdChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWFsaW5nIHdpdGggb3V0bGluZSAodHJlZSkgd2UgbmVlZCB0byBtYWtlIHN1cmUgd2hlbiB3ZSBzZWxlY3Qgc29tZSByb290IGl0ZW0gaXRcbiAgICAgKiB3aWxsIGF1dG9tYXRpY2FsbHkgYWxzbyBzZWxlY3QgYWxsIGl0cyBjaGlsZHJlblxuICAgICAqXG4gICAgICovXG4gICAgb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBKdXN0IGxpa2UgZm9yIG9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4gdGhlIHNhbWUgYmVoYXZpb3IgbmVlZHMgdG8gYmUgYXBwbGllZCBmb3JcbiAgICAgKiB0b3dhcmRzIHVwLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbGxlZCBieSBEJkQgcm93IGRpcmVjdGl2ZSB0byB1cGRhdGUgdGhpcyBURCB0aGF0IHJvdyByZW9yZGVyaW5nIG5lZWRzIHRvIGhhcHBlbi4gV2VcbiAgICAgKiByZWNlaXZlIGFuIElOREVYIG9mIHJvdyB3ZSBhcmUgZHJhZ2dpbmcgYW5kIG5ldyBkcm9wIHBvc2l0aW9uLCBwbHVzIGluZm9ybWF0aW9uIGlmIGl0XG4gICAgICogbmVlZHMgdG8gYmUgZHJvcHBlZCBiZWZvcmUgbmV3IHJvdyBwb3NpdGlvbiBvciBhZnRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG5EUm93RHJvcChvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gZGV0YWlsIHJvdyBpcyBjb21iaW5lZCB3aXRoIG91dGxpbmUgY29udHJvbCB3ZSBuZWVkIG1ha2Ugc3VyZSB0aGF0IHdlIG1haW50YWluIHRoZVxuICAgICAqIGNvcnJlY3Qgc3RhdGUgZm9yIGl0ZW1zIHRoYXQgYXJlIGVsaWdpYmxlIGZvciBkZXRhaWwgcm93XG4gICAgICpcbiAgICAgKiBJbiB0aGlzIHNwZWNpZmljIGNhc2UgdGhlIGRldGFpbCByb3cgZG9lcyBub3QgaGF2ZSBpdHMgb3duIGV4cGFuZGVyIGJ1dCB1dGlsaXppbmcgdGhlXG4gICAgICogb3V0bGluZUNvbnRyb2xcbiAgICAgKi9cbiAgICBvbk91dGxpbmVFeHBhbmRDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgZm9yIHNpbmdsZSBjb2x1bW4gc29ydGluZ1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0U2luZ2xlKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRhdGEgY2hhbmdlcywgZWl0aGVyIHRoZXkgYXJlIGxhemlseSBmZXRjaGVkIG9yIEBJbnB1dCBMSVNUIGlzIHVwZGF0ZWQgd2UgbmVlZFxuICAgICAqIHJlc29ydCBvdXQgZGF0YSBiYXNlZCBvbiBjdXJyZW50IHN0YXRlIGFuZCB1cGRhdGUgaW50ZXJuYWwgbGlzdCBkYXRhVG9SZW5kZXIgc28gbmV3XG4gICAgICogZGF0YSBjYW4gcmUtcmVuZGVyZWQgKyB0cmlnZ2VycyBldmVudCB2YWx1ZUNoYW5nZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUNoYW5nZSgpOiB2b2lkO1xuXG4gICAgdXBkYXRlRGF0YVRvUmVuZGVyKGRhdGFzb3VyY2U/OiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb3IgdW5zZWxlY3QgYWxsIHJvd3MuIFVzZWQgYnkgaGVhZGVyIGNoZWNrYm94XG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVBbGxDb2x1bW5zKGV2ZW50OiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogTW9yZSBsaWtlIHV0aWxpdHkgbWV0aG9kcyB0byB0cmFuc2xhdGUgc3RyaW5nPC0tPm51bWJlciB2YWx1ZSBmb3Igc29ydGluZ1xuICAgICAqXG4gICAgICogQ3VycmVudGx5IHVzZWQgb25seSBieSBEVENvbHVtbi4gV2UgbWlnaHQgd2FudCB0byBtb3ZlIHRoaXMgaXRzIG93biBjb21wb25lbnQgZm9yXG4gICAgICogaGVhZGVyU29ydCBhbmQgb3JkZXJpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRPcmRlcmluZ0ZvclN0cmluZyhkaXJlY3Rpb246IHN0cmluZyk6IG51bWJlcjtcblxuICAgIHNvcnRPcmRlcmluZ0Zvck51bWJlcihkaXJlY3Rpb246IG51bWJlcik6IHN0cmluZztcblxuICAgIHZpc2libGVDb2x1bW5zKCk6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG4gICAgaGFzRnJvemVuQ29sdW1ucygpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIHNpbmdsZS9tdWx0aXNlbGVjdCBmdW5jdGlvbmFsaXR5IHdoZXJlIHdlIG5lZWQgdG8gdHJhY2sgaWZcbiAgICAgKiB3ZSBzdXBwb3J0IHNlbGVjdGlvbiBwbHVzIGhvdyBtYW55IGNvbHVtbiBpdCBvY2N1cGllcyBhbmQgaWYgdGhlIHNlbGVjdGlvbiBjb250cm9scyBhcmVcbiAgICAgKiB2aXNpYmxlIG9yIGhpZGRlbi5cbiAgICAgKi9cbiAgICBoYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQbGFjZWhvbGRlciB0byBpZGVudGlmeSBpZiB0aGV5IGFyZSBub24tdmFsdWUgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCk6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFRvIGNvbXBhcmUgdGhlIGRhdGEgaWYgd2UgdXNlIGRlZXAgb2JqZWN0IGVxdWFsaXR5IGFuZCB0aGlzIGlzIHVzZWQgd2l0aGluIHRoaXMgY2xhc3MgYXNcbiAgICAgKiB3ZWxsIGFzIGZyb20gdGhlIERUQ29sdW1uIHRvIGNvbmRpdGlvbmFsbHkgYWRkIGNsYXNzIHdoaWNoIHNlbGVjdCB0aGUgY2VsbFxuICAgICAqXG4gICAgICogV2UgbWlnaHQgd2FudCB0byBjaGFuZ2UgdG8gY2hlY2sgb25seSBhIGtleSBvZiB0aGUgb2JqZWN0IHNvbWUgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAgICovXG4gICAgaXNIZWFkZXJTZWxlY3RlZChpdGVtOiBEVENvbHVtbjJDb21wb25lbnQpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWMgY2VsbCBpcyBzZWxlY3RlZC4gV2UgbmVlZCB0d28gcG9pbnRzIHRvIGlkZW50aWZ5IGlmIGNlbGwgaXMgc2VsZWN0ZWRcbiAgICAgKiB0aGUgYWN0dWFsIEl0ZW0gdGhhdCBjb3VsZCByZXByZXNlbnQgd2hvbGUgcm93IGFuZCBDb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzQm9keUNlbGxTZWxlY3RlZChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqICBDaGVjayBpZiB0aGUgZ2l2ZW4gaXRlbSBpcyBhbW9uZyB0aGUgc2VsZWN0ZWQgb25lc1xuICAgICAqXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZChpdGVtOiBhbnkpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIFtjaGlsZHJlbl0gYmluZGluZyBpcyBwcmVzZW50IHRoZW4gaXQgbWVhbnMgd2UgbmVlZCB0byByZW5kZXIgaXQgYXMgYSB0cmVlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc091dGxpbmUoKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0aGUgY2hlY2tib3ggdG8gZWl0aGVyIHNlbGVjdGVkIGFuZCBub3Qgc2VsZWN0ZWQgZGVwZW5kZWQgb24gaW50ZXJuYWwgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzVG9nZ2xlQWxsQ29sdW1uU2VsZWN0ZWQoKTogYm9vbGVhbjtcblxuICAgIGlzVG9nZ2xlQWxsQ29sdW1uRGlzYWJsZWQoKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VzIGFyZSBmaWVsZCBwYXRoIHV0aWxpdHkgY2xhc3MgdG8gcmV0cmlldmUgZGF0YSBmcm9tIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmFsdWUoZGF0YTogYW55LCBmaWVsZDogc3RyaW5nKTogYW55O1xuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgYXNzZXJ0LFxuICAgIEVudGl0eSxcbiAgICBpc0JsYW5rLFxuICAgIGlzRW50aXR5LFxuICAgIGlzUHJlc2VudCxcbiAgICBpc1N0cmluZyxcbiAgICBMaXN0V3JhcHBlcixcbiAgICBNYXBXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGF0YVNvdXJjZSwgRFNJbml0UGFyYW1zfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgRGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXRGF0YVRhYmxlLCBEcm9wUG9zaXRpb259IGZyb20gJy4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqIENvbmNyZXRlIERhdGFTb3VyY2UgaW1wbGVtZW50YXRpb24gZm9yIERhdGF0YWJsZSB3aGljaCBkZWZpbmVzIHN0YXRlIGFuZCBjb2x1bW4gZGVmaW5pdGlvbiB0aGF0XG4gKiBjYW4gcHJvZ3JhbW1hdGljYWxseSBtb2RpZnkgcmVuZGVyZWQgY29sdW1ucyAoaWYgcHJvdmlkZWQpIGFuZCBtZXRob2QgZm9yIGluc2VydGluZyBhbmRcbiAqIGFuZCBkZWxldGluZyByZWNvcmRzO1xuICpcbiAqIEFsbCBvcGVyYXRpb25zIGRlYWxpbmcgd2l0aCBkYXRhIHVzZSBPYnNlcnZhYmxlPFQ+IGFuZCBpbnN0YW50KCkgbWV0aG9kIHRvIHJldHJpZXZlIGN1cnJlbnRcbiAqIHN0YXRlIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRFQyRGF0YVNvdXJjZSBleHRlbmRzIERhdGFTb3VyY2VcbntcbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4TGltaXQgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGluZyBkYXRhUHJvdmlkZXJzIGFuZCBmaW5kZXJzXG4gICAgICovXG4gICAgZGF0YVByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcbiAgICBkYXRhRmluZGVyOiBEYXRhRmluZGVyO1xuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiBjdXJyZW50IGRhdGF0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRlOiBEYXRhdGFibGUyU3RhdGU7XG4gICAgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBkZWJ1Z1RpbWU6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIG9iamVjdCBiZWluZyByZW5kZXJlZFxuICAgICAqL1xuICAgIHByaXZhdGUgZW50aXR5OiBFbnRpdHlEZWYyO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGFQcm92aWRlcnM/OiBEYXRhUHJvdmlkZXJzLCBwdWJsaWMgZmluZGVycz86IERhdGFGaW5kZXJzKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZGF0YVByb3ZpZGVycywgZmluZGVycyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IERhdGF0YWJsZTJTdGF0ZS5jcmVhdGUoKTtcblxuICAgICAgICB0aGlzLmRlYnVnVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cblxuXG4gICAgaW5pdCguLi5hcmdzOiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGFyZ3MpIHx8IGFyZ3MubGVuZ3RoICE9PSAxICYmICFpc0RUSW5pdFBhcmFtcyhhcmdzWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBpbml0aWFsaXplIERTIHdpdGggKERTQ2hvb3NlckluaXRQYXJhbXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXQ6IERURFNJbml0UGFyYW1zID0gYXJnc1swXTtcblxuICAgICAgICAvLyB1c2UgZXhpc3Rpbmcgb3IgZmluZCBiZXN0IG1hdGNoIGZvciBkYXRhUHJvdmlkZXJcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhUHJvdmlkZXIpID8gaW5pdC5kYXRhUHJvdmlkZXJcbiAgICAgICAgICAgIDogdGhpcy5kYXRhUHJvdmlkZXJzLmZpbmQoaW5pdC5vYmopO1xuXG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBvciBmaW5kIGJlc3QgbWF0Y2ggZm9yIGRhdGFGaW5kZXJcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YUZpbmRlcikgPyBpbml0LmRhdGFGaW5kZXJcbiAgICAgICAgICAgIDogdGhpcy5maW5kZXJzLmZpbmQodGhpcy5kYXRhUHJvdmlkZXIsIGluaXQucXVlcnlUeXBlKTtcblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuZGF0YVByb3ZpZGVyKSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhRmluZGVyKSxcbiAgICAgICAgICAgICdEYXRhU291cmNlIGluY29ycmVjdGx5IGluaXRpYWxpemVkLiAoRGF0YVByb3ZpZGVyLCBEYXRhRmluZGVyKSBtaXNzaW5nLiAnKTtcblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gaW5pdC5sb29rdXBLZXk7XG4gICAgICAgIGlmIChpc0JsYW5rKGluaXQuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IERhdGF0YWJsZTJTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXQuc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFzeW5jIGZldGNoIGRhdGEgcmVxdWVzdCBhbmQgcmVzdWx0IGlzIGdpdmVuIGJhY2sgdXNpbmcgZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaCh3aXRoUGFyYW1zPzogRGF0YXRhYmxlMlN0YXRlKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IG51bGw7XG4gICAgICAgIGlmIChpc1ByZXNlbnQod2l0aFBhcmFtcykpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IG5ldyBNYXAoKS5zZXQoJ29mZnNldCcsIHdpdGhQYXJhbXMub2Zmc2V0KVxuICAgICAgICAgICAgICAgIC5zZXQoJ2xpbWl0Jywgd2l0aFBhcmFtcy5saW1pdClcbiAgICAgICAgICAgICAgICAuc2V0KCdvcmRlcmJ5Jywgd2l0aFBhcmFtcy5zb3J0S2V5KVxuICAgICAgICAgICAgICAgIC5zZXQoJ3NlbGVjdG9yJywgd2l0aFBhcmFtcy5zb3J0T3JkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZmV0Y2gocGFyYW1zKS5zdWJzY3JpYmUoKHJlc3VsdDogYW55W10pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh3aXRoUGFyYW1zLm9mZnNldCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5jckRhdGEgPSBbLi4udGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuZ2V0VmFsdWUoKSwgLi4ucmVzdWx0XTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KGluY3JEYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCB1c2VzIHRoaXMgbWV0aG9kIHRvIG9wZW4gdXAgY29udGludW91cyBzdHJlYW0gdG8gbGlzdGVuIGZvciBhbnkgY2hhbmdlcyB3aGljaFxuICAgICAqIG5lZWQgdG8gYmUgcmVmbGVjdGVkIG9uIHRoZSBVSS5cbiAgICAgKlxuICAgICAqIERvbnQgZm9yZ2V0IHRvIHVuc3Vic2NyaWJlIHdoZW4gY29tcG9uZW50IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBvcGVuPFQ+KCk6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIElmIENSVUQgaXMgZW5hYmxlZCB3ZSBkZWxlZ2F0ZSBjYWxscyB0byBEYXRhUHJvdmlkZXIgdGhhdCBpcyByZXNwb25zaWJsZSB0byB0ZWxsIHRoZVxuICAgICAqIGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcyB0aGF0IGFyZSBuZXcgZGF0YS4gSWYgbm90IGVuYWJsZWQgd2UgaGF2ZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICogd2hpY2ggd29ya3Mgd2l0aCBsb2NhbCBhcnJheVxuICAgICAqXG4gICAgICovXG4gICAgaW5zZXJ0KG9iamVjdDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb3ZpZGVyLmNhbkNSVUQoKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuaW5zZXJ0KG9iamVjdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLm9mZlNjcmVlbkRhdGEucHVzaChvYmplY3QpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dCh0aGlzLmRhdGFQcm92aWRlci5vZmZTY3JlZW5EYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUGxlYXNlIHNlZSB7QGxpbmsgaW5zZXJ0fSBtZXRob2RcbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZShvYmplY3Q6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm92aWRlci5jYW5DUlVEKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLnJlbW92ZShvYmplY3QpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KHRoaXMuZGF0YVByb3ZpZGVyLm9mZlNjcmVlbkRhdGEsIG9iamVjdCk7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMuZGF0YVByb3ZpZGVyLm9mZlNjcmVlbkRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQcm92aWRlcyBhY2Nlc3MgdG8gRGF0YUZpbmRlciB3aGljaCBjYW4gYWNjZXB0IGVpdGhlciBwbGFpbiBzdHJpbmcgb3IgTWFwLlxuICAgICAqXG4gICAgICogVG8gYmUgYWJsZSB0byBwcm92aWRlIGNvcnJlY3QgaW5wdXQgd2UgbmVlZCB0byBhc2sgRGF0YUZpbmRlciBpZiBpdCBzdXBwb3J0cyBGdWxsVGV4dCBsaWtlXG4gICAgICogdHlwZSBxdWVyeSBvciBQcmVkaWNhdGUuIEluIGNhc2Ugb2YgUHJlZGljYXRlIHdlIGJ1aWxkIHRoZSBNYXAgd2l0aCBkaWZmZXJlbnQga2V5L3ZhbHVlXG4gICAgICogcGFpcnNcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgZmluZChwYXR0ZXJuPzogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsocGF0dGVybikgfHwgcGF0dGVybi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIHJlY2VpdmVkIGVtcHR5IHN0cmluZyByZXR1cm4gb3JnaW5hbCBsaXN0XG4gICAgICAgICAgICB0aGlzLmZldGNoKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlYXJjaFBhcmFtOiBhbnkgPSBwYXR0ZXJuO1xuICAgICAgICBpZiAodGhpcy5kYXRhRmluZGVyLmFjY2VwdHModGhpcy5kYXRhUHJvdmlkZXIsIFF1ZXJ5VHlwZS5QcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbSA9IG5ldyBNYXAoKS5zZXQoJ3F1ZXJ5JywgcGF0dGVybikuc2V0KCdsaW1pdCcsIERUMkRhdGFTb3VyY2UuTWF4TGltaXQpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbS5zZXQoJ29yZGVyYnknLCB0aGlzLnN0YXRlLnNvcnRLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbS5zZXQoJ3NlbGVjdG9yJywgdGhpcy5zdGF0ZS5zb3J0T3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KGlzU3RyaW5nKHBhdHRlcm4pLCAnQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB2YWx1ZSB0byBGdWxsVGV4dCBGaW5kZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5tYXRjaDxhbnk+KHNlYXJjaFBhcmFtKS5zdWJzY3JpYmUoKHJlc3VsdDogYW55W10pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERhdGEgc291cmNlIGRlbGVnYXRlcyB0aGUgcmVzcG9uc2liaWxpdHkgdG8gdGhlIGdpdmVuIGRhdGEgcHJvdmlkZXIgd2hpY2ggbmVlZHMgdG8gaW1wbGVtZW50XG4gICAgICogc3BlY2lmaWMgc29ydGluZyBtZWNoYW5pc21cbiAgICAgKlxuICAgICAqIFRvZG86IEV4dGVuZCB0byBzb3J0IGJ5IG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnQoa2V5OiBzdHJpbmcsIHNvcnRPcmRlcjogbnVtYmVyKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpKSB8fCB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0S2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnN0YXRlLnNvcnRPcmRlciA9IHNvcnRPcmRlcjtcbiAgICAgICAgdGhpcy5mZXRjaCh0aGlzLnN0YXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBlcnNpc3QgZGIgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKG9mZnNldDogbnVtYmVyLCBzb3J0RmllbGQ6IHN0cmluZywgc09yZGVyOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0S2V5ID0gc29ydEZpZWxkO1xuICAgICAgICB0aGlzLnN0YXRlLnNvcnRPcmRlciA9IHNPcmRlcjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogcmVzaHVmZmxlcyBjdXJyZW50IGFycmF5IGJhc2VkIG9uIG5ldyByb3cgRCZEIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIFNpbmNlIHRoZXJlIGlzIGEgZGlmZmVyZW5jZSBpZiB3ZSBtb3ZlIGl0ZW0gZnJvbSBib3R0b20gb3IgZnJvbSB0aGUgdG9wIGFuZCB0aGVuIGFjY29yZGluZ2x5XG4gICAgICogaGlnaGxpZ2h0aW5nIGEgc3BhY2UgYmV0d2VlbiByb3dzLiBXZSBuZWVkIHRvIHJlZmxlY3QgdGhpcyBpbiBoZXJlIGFzIHdlbGwuXG4gICAgICpcbiAgICAgKiBVc2VDYXNlIDE6XG4gICAgICpcbiAgICAgKiAxLiBZb3UgY2FuIGdyYWIgaXRlbSB3aXRoIGluZGV4IDAgYW5kIG1vdmUgaXQgZG93biBzbyB0aGF0IHlvdSBjYW4gc2VlIGEgZHJvcHBpbmcgbGluZVxuICAgICAqIGJldHdlZW4gcm93IHdpdGggaW5kZXggMiAtIDNcbiAgICAgKlxuICAgICAqIDIuIEluIHRoaXMgY2FzZSBzcGxpY2UoKSBzdGFydHMgZnJvbSBwb3NpdGlvbiAyIGFuZCBpbnNlcnQgYWxsIGVsZW1lbnRzIGFmdGVyIDJcbiAgICAgKiAgICAgIHNwbGljZShzdGFydDogbnVtYmVyLCBkZWxldGVDb3VudDogbnVtYmVyLCAuLi5pdGVtczogVFtdKTogVFtdO1xuICAgICAqXG4gICAgICogMy4gbm8gbmVlZCB0byB1cGRhdGUgbmV3UG9zXG4gICAgICpcbiAgICAgKiBVc2VDYXNlIDI6XG4gICAgICpcbiAgICAgKiAxLiBZb3UgY2FuIGdyYWIgaXRlbSB3aXRoIGluZGV4IDAgYW5kIG1vdmUgYWxsIHRoZSB3YXkgZG93biBvZiB0aGUgRFQgYW5kIG5vdyBtb3ZlIHRoZVxuICAgICAqIHJvdyB0b3dhcmQgVE9QIGFuZCBzcGFjZSBiZXR3ZWVuIHJvd3Mgd2l0aCBpbmRleCAyIC0gMyBpcyBoaWdobGlnaHRlZCBhZ2Fpbi5cbiAgICAgKlxuICAgICAqIDIuIEhlcmUgaXMgdGhlIGRpZmZlcmVuY2UsIGJlZm9yZSB3ZSBoaWdobGlnaHRlZCByb3cgIzIgd2l0aCBsaW5lIGF0IHRoZSBib3R0b20sIG5vd1xuICAgICAqIGl0IHNlZW1zIHRoZSBzYW1lIGJ1dCBpdHMgaGlnaGxpZ2h0ZWQgcm93ICMzIHdpdGggbGluZSBhdCB0aGUgVE9QLlxuICAgICAqXG4gICAgICogKiBUaGlzIGlzIHRoZSByZWFzb24gd2hleSB3ZSBuZWVkIHRvIGRvIG5ld1BvcyAtPSAxIG9yIG5ld1BvcyArPSAxOyBkZXBlbmRpbmcgb3VyIGRpcmVjdGlvblxuICAgICAqIHdoZXJlIHdoZXJlIHRoZSBsaW5lIGJldHdlZW4gcm93cyBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBXZSBkb24ndCBuZWVkIGFueSBjb21wbGljYXRlZCBjYWxjdWxhdGlvbiB0cnlpbmcgdG8gZmluZCBvdXQgaWYgd2UgYXJlIG9uIG9uZSBoYWxmIG9mIHRoZSByb3dcbiAgICAgKiBvciBzZWNvbmQgaGFsZiBhbmQgYmFzZWQgb24gdGhpcyB0cnkgdG8gYXBwbHkgY2VydGFpbiBzdHlsZS4gVGhpcyB3b3VsZCBub3QgZ2l2ZSBzbyBtdWNoXG4gICAgICogc3BhY2UgaWYgd2Ugd2FudCBkcm9wIHJvdyBpbnRvIHRoZSByb3cuIEFuZCB0aGUgY2FsY3VsYXRpb24gd2l0aCBjb29yZGluYXRlcyB3b3VkbCBiZSB0b29cbiAgICAgKiBjb21wbGljYXRlZC5cbiAgICAgKlxuICAgICAqIFdlIHNpbXBseSByZW1lbWJlciB0aGUgZGlyZWN0aW9uIHdlIGFyZSBtb3ZpbmcgYW5kIGJhc2VkIG9uIHRoaXMgd2UgYXBwbHkgc3R5bGUgdG9cbiAgICAgKiB0byBjcmVhdGUgYSBsaW5lIGF0IHRoZSBUT1AgaWYgd2UgYXJlIGdvaW5nIHVwd2FyZHMgb3IgYm90dG9tIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcmVvcmRlclJvd3Mob3JpZ1BvczogbnVtYmVyLCBuZXdQb3M6IG51bWJlciwgZHJvcFBvczogRHJvcFBvc2l0aW9uKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGFycmF5ID0gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gdGFrZSBzb21ldGhpbmcgZnJvbSB0b3AgYW5kIGRyYWcmZHJvcCB1bmRlclxuICAgICAgICBpZiAobmV3UG9zID4gb3JpZ1BvcyAmJiBkcm9wUG9zID09PSBEcm9wUG9zaXRpb24uQmVmb3JlICYmIG5ld1BvcyA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgbmV3UG9zIC09IDE7XG5cbiAgICAgICAgICAgIC8vIHRha2Ugc29tZXRoaW5nIGZyb20gYm90dG9tIGFuZCBkcmFnJmRyb3AgYWJvdmVcbiAgICAgICAgfSBlbHNlIGlmIChuZXdQb3MgPCBvcmlnUG9zICYmIGRyb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlciAmJiBuZXdQb3MgPj0gMCkge1xuICAgICAgICAgICAgbmV3UG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheS5zcGxpY2UobmV3UG9zLCAwLCAuLi5hcnJheS5zcGxpY2Uob3JpZ1BvcywgMSlbMF0pO1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KGFycmF5KTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBFbnRpdHkgZGVmaW5pdGlvbiB0byBiZSB1c2VkIHRvIGluaXRpYWxpemUgcHJvZ3JhbW1hdGljYWxseSBjb2x1bW5zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5RGVmMlxue1xuICAgIHByb3BlcnR5S2V5czogc3RyaW5nW107XG5cbiAgICBkZWZhdWx0Rm9ybWF0dGVyOiAoa2V5OiBhbnkpID0+IHN0cmluZztcblxuICAgIGRpc3BsYXlTdHJpbmdGb3JLZXk6IChrZXk6IHN0cmluZykgPT4gc3RyaW5nO1xuXG4gICAgZGVmYXVsdEFsaWdubWVudEZvcktleTogKGtleTogc3RyaW5nKSA9PiBzdHJpbmc7XG59XG5cbi8qKlxuICogS2VlcHMgY3VycmVudCBkYXRhdGFibGUgc3RhdGUgdGhlIHN0YXRlIHdoaWNoIGRyaXZlcnMgdGhlIHdheSB3aGlsZSBmZXRjaGluZyB0aGUgZGF0YSBhcyB3ZWxsXG4gKiBlbmNhcHN1bGF0ZSBzZXQgb2YgcHJvcGVydGllcyB0aGF0IG5lZWRzIHRvIGJlIHBlcnNpc3RldCBpbiBvcmRlciB0byByZWNvdmVyIGEgc3RhdGUgYWZ0ZXIgZS5nLlxuICogYnJvd3NlciByZWZyZXNoXG4gKlxuICpcbiAqIHRvZG86IENyZWF0ZSBtZXRob2RzIHRvIGNvbnZlcnQgdGhpcyBzdGF0ZSBmcm9tIGFuZCB0byBKU09OIGZvciBlYXNpZXIgc2VyaWFsaXphdGlvblxuICovXG5leHBvcnQgY2xhc3MgRGF0YXRhYmxlMlN0YXRlXG57XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBBc2NlbmRpbmcgPSAxO1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRGVzY2VuZGluZyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBmb3IgcGFnaW5nIGFuZCBmZXRjaGluZ1xuICAgICAqL1xuICAgIG9mZnNldDogbnVtYmVyID0gMDtcbiAgICBsaW1pdDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgZGVmYXVsdCB2YWx1ZSB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIE4gbnVtYmVyIG9mIHJvd3MgaW4gbm9uLWZ1bGxzY3JlZW5cbiAgICAgKiBtb2RlXG4gICAgICpcbiAgICAgKi9cbiAgICBkaXNwbGF5TGltaXQ6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHNvcnRpbmcgZmllbGRcbiAgICAgKi9cbiAgICBzb3J0S2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0aW5nIG9yZGVyIG9mIHRoZSBzb3J0IGZpZWxkLiBEYXRhVGFibGUgc3VwcG9ydCBzb3J0aW5nIGZvciBtdWx0aXBsZSBjb2x1bW4gYnV0IHdlXG4gICAgICogZG9udCBwZXJzaXN0IGl0IG5vdy4gTWF5YmUgaW4gdGhlIGZ1dHVyZVxuICAgICAqL1xuICAgIHNvcnRPcmRlcjogbnVtYmVyID0gRGF0YXRhYmxlMlN0YXRlLkFzY2VuZGluZztcblxuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSB1c2luZyBnbG9iYWwgZmlsdGVyIGZvciBjdXJyZW50IGRhdGF0YWJsZSB0aGVuIHNhdmUgaXQgaGVyZVxuICAgICAqL1xuICAgIGN1cnJlbnRTZWFyY2hRdWVyeTogc3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGlmIGFueSBwcmVzZWxlY3RlZCBmaWx0ZXJcbiAgICAgKi9cbiAgICBjdXJyZW50RmlsdGVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnQgY3VycmVudCBzZWxlY3Rpb24gZGVwZW5kaW5nIG9uIHNlbGVjdGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogQ3VycmVudCBzZWxlY3Rpb24gdXNlZCBib3RoIGZvciByb3cgc2VsZWN0aW9uIGFuZCBjZWxsIHNlbGVjdGlvbi4gUm93IHNlbGVjdGlvbiBpcyB1c2VkIHdoZW5cbiAgICAgKiBTaW5nbGVTZWxlY3QgYW5kIE11bHRpU2VsZWN0IG9uY2Ugd2UgaW1wbGVtZW50IHRoaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3Rpb246IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBoZWFkZXIgc2VsZWN0aW9uIGlzIGVuYWJsZWQgaXQgY2FwdHVyZXMgY3VycmVudGx5IHNlbGVjdGVkIGNvbHVtblxuICAgICAqL1xuICAgIGhlYWRlclNlbGVjdGlvbjogRFRDb2x1bW4yQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBIb2xkcyBjdXJyZW50IHN0YXRlIG9mIHRoZSBvdXRsaW5lIHRyZWUgaWYgdXNlZFxuICAgICAqXG4gICAgICovXG4gICAgb3V0bGluZVN0YXRlPzogTWFwPGFueSwgYm9vbGVhbj47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBIb2xkcyBjdXJyZW50IHN0YXRlIG9mIHRoZSBkZXRhaWwgcm93cyBpZiB1c2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbmRTdGF0ZT86IE1hcDxhbnksIGJvb2xlYW4+O1xuXG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLm91dGxpbmVTdGF0ZSA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgfVxuXG4gICAgc3RhdGljIGNyZWF0ZShvZmZzZXQ6IG51bWJlciA9IDAsIGxpbWl0OiBudW1iZXIgPSAxNSwgZGlzcGxheUxpbWl0OiBudW1iZXIgPSA1LFxuICAgICAgICAgICAgICAgICAgc29ydEZpZWxkOiBzdHJpbmcgPSAnJywgc09yZGVyOiBudW1iZXIgPSAwLCBzZWFyY2hRdWVyeT86IHN0cmluZywgZmlsdGVyPzogYW55LFxuICAgICAgICAgICAgICAgICAgb3V0bGluZVN0YXRlOiBNYXA8YW55LCBib29sZWFuPiA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpLFxuICAgICAgICAgICAgICAgICAgZGV0YWlsUm93U3RhdGU6IE1hcDxhbnksIGJvb2xlYW4+ID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCkpOiBEYXRhdGFibGUyU3RhdGVcbiAgICB7XG4gICAgICAgIGxldCBzID0gbmV3IERhdGF0YWJsZTJTdGF0ZSgpO1xuICAgICAgICBzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICBzLmRpc3BsYXlMaW1pdCA9IGRpc3BsYXlMaW1pdDtcbiAgICAgICAgcy5zb3J0S2V5ID0gc29ydEZpZWxkO1xuICAgICAgICBzLnNvcnRPcmRlciA9IHNPcmRlcjtcbiAgICAgICAgcy5jdXJyZW50U2VhcmNoUXVlcnkgPSBzZWFyY2hRdWVyeTtcbiAgICAgICAgcy5jdXJyZW50RmlsdGVyID0gZmlsdGVyO1xuICAgICAgICBzLm91dGxpbmVTdGF0ZSA9IG91dGxpbmVTdGF0ZTtcbiAgICAgICAgcy5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IGRldGFpbFJvd1N0YXRlO1xuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tSlNPTihkYXRhOiBzdHJpbmcpOiBEYXRhdGFibGUyU3RhdGVcbiAgICB7XG4gICAgICAgIGxldCBzdGF0ZTogRFRTdGF0ZVNlcmlhbGl6YWJsZUhlbHBlciA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIGxldCBkcyA9IG5ldyBEYXRhdGFibGUyU3RhdGUoKTtcbiAgICAgICAgZHMub2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBkcy5saW1pdCA9IHN0YXRlLmxpbWl0O1xuICAgICAgICBkcy5kaXNwbGF5TGltaXQgPSBzdGF0ZS5kaXNwbGF5TGltaXQ7XG4gICAgICAgIGRzLnNvcnRLZXkgPSBzdGF0ZS5zb3J0S2V5O1xuICAgICAgICBkcy5zb3J0T3JkZXIgPSBzdGF0ZS5zb3J0T3JkZXI7XG4gICAgICAgIGRzLmN1cnJlbnRTZWFyY2hRdWVyeSA9IHN0YXRlLmN1cnJlbnRTZWFyY2hRdWVyeTtcbiAgICAgICAgZHMub3V0bGluZVN0YXRlID0gTWFwV3JhcHBlci5jcmVhdGVGcm9tQW55TWFwPGJvb2xlYW4+KHN0YXRlLm91dGxpbmVTdGF0ZSk7XG4gICAgICAgIGRzLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gTWFwV3JhcHBlci5jcmVhdGVGcm9tQW55TWFwPGJvb2xlYW4+KHN0YXRlLmRldGFpbFJvd0V4cGFuZFN0YXRlKTtcblxuICAgICAgICByZXR1cm4gZHM7XG4gICAgfVxuXG5cbiAgICBzdGF0aWMgdG9KU09OKGRhdGE6IERhdGF0YWJsZTJTdGF0ZSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IHRvQ29udmVydDogRFRTdGF0ZVNlcmlhbGl6YWJsZUhlbHBlciA9IHtcbiAgICAgICAgICAgIG9mZnNldDogZGF0YS5vZmZzZXQsXG4gICAgICAgICAgICBsaW1pdDogZGF0YS5saW1pdCxcbiAgICAgICAgICAgIGRpc3BsYXlMaW1pdDogZGF0YS5kaXNwbGF5TGltaXQsXG4gICAgICAgICAgICBzb3J0S2V5OiBkYXRhLnNvcnRLZXksXG4gICAgICAgICAgICBzb3J0T3JkZXI6IGRhdGEuc29ydE9yZGVyLFxuICAgICAgICAgICAgY3VycmVudFNlYXJjaFF1ZXJ5OiBkYXRhLmN1cnJlbnRTZWFyY2hRdWVyeSxcbiAgICAgICAgICAgIG91dGxpbmVTdGF0ZTogTWFwV3JhcHBlci50b0FueU1hcChkYXRhLm91dGxpbmVTdGF0ZSksXG4gICAgICAgICAgICBkZXRhaWxSb3dFeHBhbmRTdGF0ZTogTWFwV3JhcHBlci50b0FueU1hcChkYXRhLmRldGFpbFJvd0V4cGFuZFN0YXRlKVxuXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b0NvbnZlcnQpO1xuICAgIH1cblxufVxuXG5cbi8qKlxuICogVGhpcyBuZWVkcyB0byBnbyB0byBEVERhdGFTb3VyY2UgdG8ga2VlcCBhbmQgbWFuYWdlIHRoZSBzdGF0ZSBvZiB0aGUgZGV0YWlsIHJvdy4gVGhlIGlkZWEgaXNcbiAqIHNpbXBsZSB3ZSBoYXZlIGEgbWFwIGhvbGRpbmcgaXRlbSByZWZlcmVuY2UgYXMgYSBrZXkgYW5kIGJvb2xlYW4gdmFsdWUgaW5kaWNhdGluZyBpZiB0aGVcbiAqIGRldGFpbCByb3cgaXMgdmlzaWJsZVxuICpcbiAqIFRvZG86IG1vdmUgdGhpcyBvdXQgdG8gRFNcbiAqL1xuZXhwb3J0IGNsYXNzIERldGFpbFJvd0V4cGFuc2lvblN0YXRlXG57XG5cbiAgICBleHBhbnNpb25TdGF0ZXM6IE1hcDxhbnksIGJvb2xlYW4+O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGR0OiBBV0RhdGFUYWJsZSlcbiAgICB7XG4gICAgfVxuXG4gICAgZ2V0IGRldGFpbEV4cGFuc2lvbkVuYWJsZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmV4cGFuc2lvblN0YXRlcyk7XG4gICAgfVxuXG4gICAgc2V0IGRldGFpbEV4cGFuc2lvbkVuYWJsZWQodmFsdWU6IGJvb2xlYW4pXG4gICAge1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZShpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgIGlmICghdGhpcy5pc0V4cGFuZGVkKGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gdGhpcy5leHBhbnNpb25TdGF0ZXM7XG4gICAgfVxuXG4gICAgaXNFeHBhbmRlZChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY29sbGFwc2UgcGFyZW50IG9mIHBhcmVudCB3aGlsZSBkZXRhaWwgcm93IGlzIGV4cGFuZGVkXG4gICAgICAgIGlmICh0aGlzLmR0LmlzT3V0bGluZSgpICYmICF0aGlzLmR0Lm91dGxpbmVTdGF0ZS5pc0V4cGFuZGVkKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzT3V0bGluZUV4cGFuZGVkID0gdGhpcy5kdC5pc091dGxpbmUoKSA/IHRoaXMuZHQub3V0bGluZVN0YXRlLmlzRXhwYW5kZWQoa2V5KSA6IHRydWU7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoa2V5KSAmJiB0aGlzLmV4cGFuc2lvblN0YXRlcy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGl0ZW1Ub0tleShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBpc0VudGl0eShpdGVtKSA/ICg8RW50aXR5Pml0ZW0pLmlkZW50aXR5KCkgOiBpdGVtO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyXG57XG4gICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgbGltaXQ6IG51bWJlcjtcbiAgICBkaXNwbGF5TGltaXQ6IG51bWJlcjtcbiAgICBzb3J0S2V5OiBzdHJpbmc7XG4gICAgc29ydE9yZGVyOiBudW1iZXI7XG4gICAgY3VycmVudFNlYXJjaFF1ZXJ5OiBzdHJpbmc7XG4gICAgY3VycmVudEZpbHRlcj86IGFueTtcbiAgICBvdXRsaW5lU3RhdGU6IGFueTtcbiAgICBkZXRhaWxSb3dFeHBhbmRTdGF0ZTogYW55O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RUSW5pdFBhcmFtcyhpbml0OiBEVERTSW5pdFBhcmFtcyk6IGluaXQgaXMgRFREU0luaXRQYXJhbXNcbntcbiAgICByZXR1cm4gaXNQcmVzZW50KGluaXQub2JqKSB8fCBpc1ByZXNlbnQoaW5pdC5xdWVyeVR5cGUpIHx8IGlzUHJlc2VudChpbml0LmVudGl0eSk7XG59XG5cbi8qKlxuICogVG8gbWFrZSBpbml0aWFsaXphdGlvbiBlYXNpZXIgd2UgaGF2ZSB0aGlzIGNvbW1vbiBmb3JtYXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRFREU0luaXRQYXJhbXMgZXh0ZW5kcyBEU0luaXRQYXJhbXNcbntcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgZGF0YVxuICAgICAqL1xuICAgIGVudGl0eT86IEVudGl0eURlZjI7XG5cbiAgICBzdGF0ZT86IERhdGF0YWJsZTJTdGF0ZTtcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDb2x1bW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBNdWx0aXNlbGVjdGlvbiB3aGVyZSB3ZSBzaG93IGNoZWNrYm94IGNvbnRyb2xcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LW11bHRpLXNlbGVjdC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIE1hbmFnZXMgbXVsdGkgc2VsZWN0aW9uIGFuZCByZW5kZXJzIGNoZWNrYm94ZXMgYm90aCBmb3IgaGVhZGVyIGluIGNhc2UgW3Nob3dTZWxlY3RBbGxdIGlzXG4gICAgZW5hYmxlZCBhcyB3ZWxsIGFzIGVhY2ggY2hlY2tib3ggcGVyIHJvd1xuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1pc0hlYWRlciBsZXQtaXNTdWJIZWFkZXI9XCJpc1N1YkhlYWRlclwiIGxldC1jb2x1bW49XCJjb2x1bW5cIlxuICAgICAgICAgICAgIGxldC1kYXRhVG9SZW5kZXI9XCJkYXRhXCJcbiAgICAgICAgICAgICBsZXQtbGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIlxuICAgICAgICAgICAgIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xIZWFkZXJcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXNTdWJIZWFkZXIsIGNvbHVtbkluZGV4OmNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICBsZXZlbDpsZXZlbH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiIWlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sQm9keVwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBjb2x1bW4sIGxldmVsOmxldmVsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOmRhdGFUb1JlbmRlcixyb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2NvbEhlYWRlciBsZXQtaXNTdWJIZWFkZXIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIj5cbiAgICA8dGggW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LXUtdW5zZWxlY3RhYmxlLXRleHQgZHQtc2VsZWN0aW9uLWNvbHVtbicgOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1jZWxsLWRlZic6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1zdWItaGVhZGVyJzogaXNTdWJIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICdkdC1pcy1oaWRkZW4nOiAhZHQuc2hvd1NlbGVjdGlvbkNvbHVtbn1cIiBhbGlnbj1cImNlbnRlclwiPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJkdC5zaG93U2VsZWN0QWxsXCI+XG4gICAgICAgICAgICA8YXctY2hlY2tib3ggW3R5cGVdPVwiJ2FjdGlvbidcIiAoYWN0aW9uKT1cImR0LnRvZ2dsZUFsbENvbHVtbnMoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImR0LmlzVG9nZ2xlQWxsQ29sdW1uU2VsZWN0ZWQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImR0LmlzVG9nZ2xlQWxsQ29sdW1uRGlzYWJsZWQoKVwiPlxuICAgICAgICAgICAgPC9hdy1jaGVja2JveD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWR0LnNob3dTZWxlY3RBbGxcIj4mbmJzcDtcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RoPlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjY29sQm9keSBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiICwgbGV0LWxldmVsPVwibGV2ZWxcIj5cblxuICAgIDx0ZCAjY2VsbCBbY2xhc3NdPVwiZHluYW1pY0JvZHlDbGFzcyhkYXRhKVwiXG4gICAgICAgIFtzdHlsZS5wYWRkaW5nLWxlZnQucHhdPVwiaW5kZW50Rm9yQ29udHJvbChjZWxsLCBsZXZlbClcIlxuICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQgZHQtc2VsZWN0aW9uLWNvbHVtbic6IHRydWUsXG4gICAgICAgICdkdC1jZWxsLWRlZic6IHRydWUsXG4gICAgICAgICdkdC1pcy1oaWRkZW4nOiAhZHQuc2hvd1NlbGVjdGlvbkNvbHVtbn1cIj5cblxuICAgICAgICA8YXctY2hlY2tib3ggW3R5cGVdPVwiJ2FjdGlvbidcIiBbdmFsdWVdPVwiZHQuaXNSb3dTZWxlY3RlZChkYXRhKVwiPlxuICAgICAgICA8L2F3LWNoZWNrYm94PlxuXG4gICAgPC90ZD5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2BgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBJbmplY3QsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogQ29sdW1uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgU2luZ2xlU2VsZWN0IHdoZXJlIHdlIHNob3cgY2hlY2tib3ggY29udHJvbFxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIE1hbmFnZXMgbXVsdGkgc2VsZWN0aW9uIGFuZCByZW5kZXJzIGNoZWNrYm94ZXMgYm90aCBmb3IgaGVhZGVyIGluIGNhc2UgW3Nob3dTZWxlY3RBbGxdIGlzXG4gICAgZW5hYmxlZCBhcyB3ZWxsIGFzIGVhY2ggY2hlY2tib3ggcGVyIHJvd1xuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1pc0hlYWRlciBsZXQtaXNTdWJIZWFkZXI9XCJpc1N1YkhlYWRlclwiIGxldC1jb2x1bW49XCJjb2x1bW5cIlxuICAgICAgICAgICAgIGxldC1kYXRhVG9SZW5kZXI9XCJkYXRhXCJcbiAgICAgICAgICAgICBsZXQtbGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIlxuICAgICAgICAgICAgIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xIZWFkZXJcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXNTdWJIZWFkZXIsIGNvbHVtbkluZGV4OmNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICBsZXZlbDpsZXZlbH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiIWlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sQm9keVwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBjb2x1bW4sIGxldmVsOmxldmVsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOmRhdGFUb1JlbmRlcixyb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2NvbEhlYWRlciBsZXQtaXNTdWJIZWFkZXIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIj5cbiAgICA8dGggW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LXUtdW5zZWxlY3RhYmxlLXRleHQgZHQtc2VsZWN0aW9uLWNvbHVtbicgOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1jZWxsLWRlZic6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1zdWItaGVhZGVyJzogaXNTdWJIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICdkdC1pcy1oaWRkZW4nOiAhZHQuc2hvd1NlbGVjdGlvbkNvbHVtbn1cIiBhbGlnbj1cImNlbnRlclwiPlxuICAgICAgICAmbmJzcDtcbiAgICA8L3RoPlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjY29sQm9keSBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiICwgbGV0LWxldmVsPVwibGV2ZWxcIj5cblxuICAgIDx0ZCAjY2VsbCBbY2xhc3NdPVwiZHluYW1pY0JvZHlDbGFzcyhkYXRhKVwiXG4gICAgICAgIFtzdHlsZS5wYWRkaW5nLWxlZnQucHhdPVwiaW5kZW50Rm9yQ29udHJvbChjZWxsLCBsZXZlbClcIlxuICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQgZHQtc2VsZWN0aW9uLWNvbHVtbic6IHRydWUsXG4gICAgICAgICdkdC1jZWxsLWRlZic6IHRydWUsXG4gICAgICAgICdkdC1pcy1oaWRkZW4nOiAhZHQuc2hvd1NlbGVjdGlvbkNvbHVtbn1cIj5cblxuICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ0RUUmFkaW8nXCIgW3ZhbHVlXT1cImRhdGFcIiBbKG5nTW9kZWwpXT1cImR0LmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0aW9uXCI+XG4gICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gICAgPC90ZD5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2BgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQgZXh0ZW5kcyBEVENvbHVtbjJDb21wb25lbnRcbntcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xcbiAgICAgICAgdGhpcy53aWR0aCA9ICc0NXB4JztcbiAgICB9XG5cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKiAgQG9yaWdpbmFsLWxpY2Vuc2VcbiAqICBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYtMjAxNyBQcmltZVRla1xuICpcbiAqICBDcmVkaXQ6IERlcml2ZWQgYW5kIGV4dGVuZGVkIGZyb20gUHJpbWUtbmcgZGF0YWJsZSB3aGVyZSB3ZSBuZWVkZWQgbW9yZSBtb2R1bGFyIHNvbHV0aW9uLlxuICogIFdlIHJldXNlZCB0aGUgY29yZSBzdHJ1Y3R1cmUgYW5kIGxheW91dCBidXQgaGFkIHRvIHJlZmFjdG9yIGJvdGggY29kZSBhbmQgdGVtcGxhdGUgdG8gbWF0Y2ggb3VyXG4gKiAgbmVlZHMuIE1vcmUgaW4gdGhlIGRlc2NyaXB0aW9uXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIEluamVjdG9yLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09iamVjdFV0aWxzfSBmcm9tICdwcmltZW5nL2NvbXBvbmVudHMvdXRpbHMvb2JqZWN0dXRpbHMnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtpc091dGxpbmVOb2RlLCBPdXRsaW5lU3RhdGV9IGZyb20gJy4uL291dGxpbmUvaW5kZXgnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgYXNzZXJ0LFxuICAgIEJvb2xlYW5XcmFwcGVyLFxuICAgIEVudmlyb25tZW50LFxuICAgIGVxdWFscyxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNCbGFuayxcbiAgICBpc1ByZXNlbnQsXG4gICAgTGlzdFdyYXBwZXJcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FXRGF0YVRhYmxlLCBEcm9wUG9zaXRpb259IGZyb20gJy4vYXctZGF0YXRhYmxlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7RFRIZWFkZXJDb21wb25lbnQyfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7RFREZXRhaWxSb3dDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL2RldGFpbC1yb3ctZXhwYW5kZXIvZHQtZGV0YWlsLXJvdy1leHBhbmRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEQVRBX1NPVVJDRX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGF0YWJsZTJTdGF0ZSwgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGUsIERUMkRhdGFTb3VyY2V9IGZyb20gJy4vZGF0YXRhYmxlMi1kYXRhLXNvdXJjZSc7XG5pbXBvcnQge1xuICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vbXVsdGktc2VsZWN0L2R0LW11bHRpLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vc2luZ2xlLXNlbGVjdC9kdC1zaW5nbGUtc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RlbEZvcm1hdH0gZnJvbSAnLi4vb3V0bGluZS9vdXRsaW5lLWZvci5jb21wb25lbnQnO1xuXG5cbmV4cG9ydCB0eXBlIFNlbGVjdGlvbk1vZGUgPSAnbXVsdGknIHwgJ3NpbmdsZScgfCAnY2VsbCcgfCAnbm9uZSc7XG5cbi8qKlxuICogRFQgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyB0aGUgZGF0YSBncmlkIHRoYXQgc2hvd3MgdGFidWxhciBkYXRhLiBFdmVuIHRoZSBiYXNpY1xuICogc3RydWN0dXJlIGlzIGJhc2VkIG9uIFByaW1lTkcgZGF0YXRhYmxlIGl0cyBjb21wbGV0ZWx5IHJlZmFjdG9yZWQgaW50byBzbWFsbGVyIHBpZWNlcyB0aGF0XG4gKiBhbGxvd3MgbW9yZSBleHRlbnNpYmlsaXR5IGFuZCB0cnlpbmcgdG8gc3RheSBhcyBjbG9zZSBhcyBwb3NzaWJsZSB0byBleGlzdGluZyBBV0wgaW1wbGVtZW50YXRpb25cbiAqXG4gKiBUaGVyZSBhcmUgMyBtYWluIHBpZWNlczpcbiAqXG4gKiAgVGFibGUgV3JhcHBlciAtIGZvY3VzZXMgb24gdGhlIG91dGVyIHN0cnVjdHVyZS4gQ29udGFpbmVyIHdpdGggYmFzaWMgZGF0YWJsZSBsYXlvdXQgcGx1c1xuICogIGNvbnRhaW5zIGFueSBhZGRpdGlvbmFsIHBhbmVscyB0aGF0IGRhdGF0YWJsZSBuZWVkcyBzdWNoIGFzIG91ciBuZXcgY29uY2VwdCBob3cgZWRpdGluZyB3aWxsXG4gKiAgd29yayAtIHNsaWRpbmcgcGFuZWwgZnJvbSB0aGUgYm90dG9tXG4gKlxuICogIERhdGF0YWJsZSBDb2x1bW4gLSBJbnN0ZWFkIG9mIHJlbmRlcmluZyBldmVyeXRoaW5nIGluc2lkZSBEVCBJIHNwbGl0IHRoZSBwYXJ0IHRoYXQgcmVuZGVyc1xuICogIGNvbHVtbiBpbnRvIHNlcGFyYXRlIGNvbXBvbmVudC4gVGhpcyB3YXkgY29tcG9uZW50IGNvbHVtbiBoYXMgaXRzIG93biByZW5kZXJlciB0ZW1wbGF0ZSB3aGljaFxuICogIGNhbiByZW5kZXIgYm90aCBoZWFkZXIgYW5kIGRhdGEgY2VsbHMuXG4gKiAgTGF0ZXIgb24gRFRDb2x1bW4gaXMgdGhlbiBleHRlbmRlZCB0byBzdXBwb3J0IG90aGVyIGFkZGl0aW9uYWwgY29sdW1uIHR5cGVzXG4gKiAgU2luZ2xlU2VsZWN0aW9uQ29sdW1uLCBNdWx0aVNlbGVjdGlvbkNvbHVtbiwgYm90aCByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHNlbGVjdGlvbiBjb250cm9scy5cbiAqXG4gKiBUbyBzdXBwb3J0IHBpdm90YWwgbGF5b3V0IHRoaXMgY2FuIGJlIGV4dGVuZGVkIGZvciBvdGhlciBhZGRpdGlvbmFsIGNvbHVtbnMgdGhhdCBpbXBsZW1lbnRzIHRoZWlyXG4gKiBvd24gcmVuZGVyaW5nIHRlbXBsYXRlc1xuICpcbiAqIERhdGF0YWJsZSAtIFRoZSBtYWluIGNvbXBvbmVudCB0aGF0IGlzIG9ubHkgZm9jdXMgb24gaGVhZGVyIGFuZCBib2R5IHJlbmRlcmluZyBhbmQgYmFzYWVkIG9uIHRoZVxuICogY29sdW1uIHR5cGUgaXQgd2lsbCByZW5kZXIgdGhlIGNvcnJlY3QgdGVtcGxhdGVcbiAqIGNvbHVtbiB0eXBlIGl0IHdpbGwgcmVuZGVyIHRoZSBjb3JyZWN0IHRlbXBsYXRlXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kYXRhdGFibGUyJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBUaGlzIHRlbXBsYXRlIGZvY3VzIG9ubHkgb24gaGVhZGVyIGFuZCBib2R5IHJlbmRlcmluZy5cblxuICAgIFRoaXMgZGF0YXRhYmxlIGFsc28gc3VwcG9ydHMgZnJvemVuIGNvbHVtbiBhbmQgZm9yIHRoaXMgcmVuZGVyaW5nIGl0IGlzIHByZXR0eSBtdWNoIHRyYW5zcGFyZW50XG4gICAgYXMgaXQgcmVjZWl2ZWQgc2V0cyBvZiBjb2x1bW4gdGhhdCBpdCBuZWVkcyB0byByZW5kZXIgZnJvbSB0aGUgVGFibGVXcmFwcGVyLlxuXG4gICAgVGFibGVXcmFwcGVyIGluIGNhc2Ugb2YgZnJvemVuIGNvbHVtbnMgY2FsbHMgI2hlYWRlclJvd3MgYW5kICNib2R5Um93cyB0ZW1wbGF0ZXMgdHdpY2UgdG9cbiAgICByZW5kZXIgdG8gc2VwYXJhdGUgdGFibGVzIHdoZXJlIG9uZSBoYXMgZnJvemVuIGNvbHVtbnMgYW5kIGFub3RoZXIgb25lIGhhcyB0aGUgcmVzdCBhbmQgaXRzXG4gICAgc2Nyb2xsYWJsZVxuLS0+XG5cbjxhdy1kdC13cmFwcGVyICNkdFdyYXBwZXI+XG4gICAgPG5nLXRlbXBsYXRlICNoZWFkaW5nQXJlYT5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctZHQtaGVhZGVyMlwiPjwvbmctY29udGVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICNoZWFkZXJSb3dzIGxldC1jb2xzVG9SZW5kZXIgbGV0LWZyb3plblZpZXc9XCJmcm96ZW5Db2x1bW5zXCI+XG4gICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyOyBjb250ZXh0OnskaW1wbGljaXQ6IGNvbHNUb1JlbmRlciwgZnJvemVuOmZyb3plblZpZXcgfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICNib2R5Um93cyBsZXQtY29sc1RvUmVuZGVyPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNPdXRsaW5lKClcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlPdXRsaW5lOyBjb250ZXh0OnskaW1wbGljaXQ6IGNvbHNUb1JlbmRlcn1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc091dGxpbmUoKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVBsYWluOyBjb250ZXh0OnskaW1wbGljaXQ6IGNvbHNUb1JlbmRlcn1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9hdy1kdC13cmFwcGVyPlxuXG5cbjwhLS1cbiAgICBFYWNoIHJlbmRlcmluZyBjb2x1bW4gaGFzIGl0cyBvd24gcmVuZGVyVGVtcGxhdGUgd2hpY2ggZGVmaW5lIGhvdyB0aGluZ3Mgc2hvdWxkIGJlIHJlbmRlci5cbiAgICBCYXNlZCBvbiBkaWZmZXJlbnQgY29sdW1uIHR5cGVzIHRoaXMgY29kZSBzaG91bGQgYmUgdHJhbnNwYXJlbnQgYXMgd2UgZG9udCBjYXJlIG9uIHRoaXNcbiAgICBsZXZlbCB3aGF0IGtpbmQgb2YgY29sdW1uIHdlIGFyZSByZW5kZXJpbmcuXG5cbiAgICBMYXRlciBvbiB3aGVuIHdlIHdpbGwgc3VwcG9ydCBzaW5nbGUvbXVsdGkgc2VsZWN0aW9uLCB0aGlzIHdpbGwgYmUganVzdCBhbm90aGVyIGNvbHVtbiBleHRlbmRpbmdcbiAgICBEVENvbHVtbiBhbmQgcHJvdmlkaW5nIGl0cyBvd24gdGVtcGxhdGVcblxuICAgIFdlIHBhc3MgaW50byB0aGlzIHRlbXBsYXRlIGlmIHdlIGFyZSByZW5kZXJpbmcgaGVhZGVyLCBzdWJIZWFkZXIsIG9yIGRhdGFcbi0tPlxuPG5nLXRlbXBsYXRlICNoZWFkZXIgbGV0LWNvbHNUb1JlbmRlciBsZXQtZnJvemVuPVwiZnJvemVuXCI+XG4gICAgPHRyPlxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbCBbbmdGb3JPZl09XCJjb2xzVG9SZW5kZXJcIiBsZXQtbGFzdENvbD1cImxhc3RcIlxuICAgICAgICAgICAgICAgICAgICAgbGV0LWNvbHVtbkluZGV4PVwiaW5kZXhcIj5cblxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbC5yZW5kZXJlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogdHJ1ZSwgaXNTdWJIZWFkZXI6ZmFsc2UsXG4gICAgICAgICAgICAgICAgY29sdW1uSW5kZXg6KGZyb3plbiA/IGNvbHVtbkluZGV4OiAoY29sdW1ucy5sZW5ndGggKyBjb2x1bW5JbmRleCkpfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC90cj5cblxuICAgIDx0ciAqbmdJZj1cInNob3dTdWJIZWFkZXJcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jb2wgW25nRm9yT2ZdPVwiY29sc1RvUmVuZGVyXCIgbGV0LWxhc3RDb2w9XCJsYXN0XCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiB0cnVlLCBpc1N1YkhlYWRlcjp0cnVlfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC90cj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNib2R5UGxhaW4gbGV0LWNvbHNUb1JlbmRlcj5cblxuICAgIDx0Ym9keSBbbmdDbGFzc109XCJ7J2R0LWNvbnRlbnQgZHQtZGF0YS1jZWxscyAnOiB0cnVlLCAnZHQtaXMtaG92ZXJhYmxlLXJvdyc6IHJvd0hvdmVyfVwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1yb3dEYXRhIFtuZ0Zvck9mXT1cImRhdGFUb1JlbmRlclwiIGxldC1ldmVuPVwiZXZlblwiIGxldC1vZGQ9XCJvZGRcIlxuICAgICAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJpbmRleFwiIFtuZ0ZvclRyYWNrQnldPVwicm93VHJhY2tCeVwiPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dUZW1wbGF0ZTsgY29udGV4dDp7JGltcGxpY2l0OiByb3dEYXRhLCBldmVuOmV2ZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZGQ6b2RkLCByb3dJbmRleDpyb3dJbmRleCwgY29sc1RvUmVuZGVyOmNvbHNUb1JlbmRlcn1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cInNob3dEZXRhaWxDb2x1bW4ocm93RGF0YSlcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dEZXRhaWxDb2x1bW4ucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiBmYWxzZSwgZGF0YTpyb3dEYXRhLCByb3dJbmRleDoocm93SW5kZXgpfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub0RhdGFcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L3Rib2R5PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2JvZHlPdXRsaW5lIGxldC1jb2xzVG9SZW5kZXI+XG4gICAgPHRib2R5ICNvdXRsaW5lRm9yIGF3T3V0bGluZUZvciBbbGlzdF09XCJkYXRhVG9SZW5kZXJcIlxuICAgICAgICAgICBbZm9ybWF0XT1cIm91dGxpbmVGb3JtYXRcIlxuICAgICAgICAgICBbY29udGV4dF09XCJjb250ZXh0XCJcbiAgICAgICAgICAgW2luZGVudGF0aW9uUGVyTGV2ZWxdPVwiaW5kZW50YXRpb25QZXJMZXZlbFwiXG4gICAgICAgICAgIFtwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmVdPVwicHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lXCJcbiAgICAgICAgICAgW2NoaWxkcmVuXT1cImNoaWxkcmVuXCIgW2V4cGFuZEFsbF09XCJleHBhbmRBbGxcIlxuICAgICAgICAgICBbc3RhdGVdPVwib3V0bGluZVN0YXRlXCJcbiAgICAgICAgICAgW25nQ2xhc3NdPVwieydkdC1jb250ZW50IGR0LWRhdGEtY2VsbHMgJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICdkdC1pcy1ob3ZlcmFibGUtcm93Jzogcm93SG92ZXJ9XCJcbiAgICAgICAgICAgKG9uRXhwYW5kQ2hhbmdlKT1cIm9uT3V0bGluZUV4cGFuZENoYW5nZSgkZXZlbnQpXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgI291dGxpbmUgbGV0LXJvd0RhdGEgbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiByb3dEYXRhLCBuZXN0aW5nTGV2ZWw6bmVzdGluZ0xldmVsLCBjb2xzVG9SZW5kZXI6Y29sc1RvUmVuZGVyfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic2hvd0RldGFpbENvbHVtbihyb3dEYXRhKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0RldGFpbENvbHVtbi5yZW5kZXJlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IGZhbHNlLCBkYXRhOnJvd0RhdGEsIHJvd0luZGV4Oihyb3dJbmRleCl9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5vRGF0YVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvdGJvZHk+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tXG4gICAgRGVmYXVsdCB0ZW1wbGF0ZSB0aGF0IGlzIGRpc3BsYXkgd2hlbiB0aGVyZSBhcmUgbm8gZGF0YVxuLS0+XG48bmctdGVtcGxhdGUgI25vRGF0YT5cbiAgICA8dHIgKm5nSWY9XCJpc0VtcHR5KClcIiBjbGFzcz1cIiBkdC1lbXB0eW1lc3NhZ2Utcm93XCJcbiAgICAgICAgW3N0eWxlLnZpc2liaWxpdHldPVwibG9hZGluZyA/ICdoaWRkZW4nIDogJ3Zpc2libGUnXCI+XG5cbiAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwidmlzaWJsZUNvbHVtbnMoKS5sZW5ndGhcIiBjbGFzcz1cImR0LWVtcHR5bWVzc2FnZVwiPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCIhZW1wdHlNZXNzYWdlVGVtcGxhdGVcIj57e2VtcHR5TWVzc2FnZX19PC9zcGFuPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImVtcHR5TWVzc2FnZVRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvdGQ+XG4gICAgPC90cj5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS1cbiAgICBUZW1wbGF0ZSB0aGF0IHJlbmRlcnMgYWN0dWFsIHJvdy4gUmVuZGVycyBib3RoIGhlYWRlciBhbmQgYm9keSBjb2x1bW4uIEVhY2ggcmVuZGVyZWRcbiAgICBjb2x1bW4gaGFzIGl0cyBvd24gdGVtcGxhdGUgY2FsbGVkIHJlbmRlcmVyVGVtcGxhdGUgdGhhdCBoYXMgYWxsIHRoaW5ncyB0aGF0IG5lZWRzIHRvIGJlXG4gICAgcmVuZGVyZWQgYW5kIHdlIGp1c3QgdGVsbCB0aGUgdGVtcGxhdGUgaWYgd2UgYXJlIHJlbmRlcmluZyBoZWFkZXIsIHN1YmhlYWRlciBvciBib2R5XG4tLT5cbjxuZy10ZW1wbGF0ZSAjcm93VGVtcGxhdGUgbGV0LXJvd0RhdGEgbGV0LWV2ZW49XCJldmVudFwiIGxldC1vZGQ9XCJvZGRcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1jb2xzVG9SZW5kZXI9XCJjb2xzVG9SZW5kZXJcIj5cblxuXG4gICAgPHRyICNyb3dFbGVtZW50IGR0RHJhZ2dhYmxlUm93IFtkbmRSb3dJbmRleF09XCJyb3dJbmRleFwiXG4gICAgICAgIGNsYXNzPVwiZHQtYm9keS1yb3dcIlxuICAgICAgICAoY2xpY2spPVwib25IYW5kbGVSb3dDbGlja2VkKCRldmVudCwgcm93RGF0YSlcIlxuICAgICAgICBbYXR0ci5uZXN0aW5nTGV2ZWxdPVwibmVzdGluZ0xldmVsXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydkdC1ldmVuLXJvdyc6IGV2ZW4sICdkdC1vZGQtcm93Jzogb2RkLFxuICAgICAgICAgICAgJ2R0LXJvdy1zZWxlY3RlZCc6IGlzUm93U2VsZWN0ZWQocm93RGF0YSksXG4gICAgICAgICAgICAnZHQtcm93LWRyYWdnYWJsZSc6IGRuZFJvd0VuYWJsZWQsXG4gICAgICAgICAgICAnZHQtcm9vdC1zZWN0aW9uJzogbmVzdGluZ0xldmVsID09PSAwIH1cIj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbCBbbmdGb3JPZl09XCJjb2xzVG9SZW5kZXJcIiBsZXQtY29sSW5kZXg9XCJpbmRleFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbC5yZW5kZXJlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IGZhbHNlLCBkYXRhOnJvd0RhdGEsIHJvd0luZGV4OnJvd0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBuZXN0aW5nTGV2ZWw6bmVzdGluZ0xldmVsfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC90cj5cbjwvbmctdGVtcGxhdGU+XG5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnctZGF0YXRhYmxle3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94fS53LWRhdGF0YWJsZSB0YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7d2lkdGg6MTAwJTt0YWJsZS1sYXlvdXQ6Zml4ZWR9LnctZGF0YXRhYmxlIHRib2R5LC53LWRhdGF0YWJsZSB0ZCwudy1kYXRhdGFibGUgdGh7b3V0bGluZTowfS5kdC1jZWxsLWRlZiwuZHQtY2VsbC1kZWYtc2VsZWN0YWJsZXtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O3BhZGRpbmc6MTdweCAxNnB4O2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZHQtY2VsbC1kZWYtc2VsZWN0YWJsZXtjdXJzb3I6cG9pbnRlcjt3aWR0aDoxMDAlO2hlaWdodDoxMDAlfXRoIC5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2JvcmRlci13aWR0aDo0cHggMXB4IDFweDtwYWRkaW5nOjE0cHggMTZweCAxN3B4fXRkIC5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2JvcmRlci13aWR0aDowIDFweCAwIDVweDtwYWRkaW5nOjE3cHggMTZweCAxN3B4IDEzcHh9LmR0LWRhdGEtY2VsbHMgdHIuZHQtaXMtaGlnaGxpZ2h0LC5kdC1kYXRhLWNlbGxzIHRyLmR0LWlzLWhvdmVye2JvcmRlci1jb2xvcjppbmhlcml0O2ZvbnQtd2VpZ2h0OmluaGVyaXQ7Y3Vyc29yOnBvaW50ZXJ9LnctZGF0YXRhYmxlLXJ0bHtkaXJlY3Rpb246cnRsfS53LWRhdGF0YWJsZS1ydGwudy1kYXRhdGFibGUtcnRsLnctZGF0YXRhYmxlIHRoZWFkIHRoe3RleHQtYWxpZ246cmlnaHR9LmR0LXJvb3Qtc2VjdGlvbiAuZHQtY2VsbC1kZWYsLmR0LXJvb3Qtc2VjdGlvbiAuZHQtY2VsbC1kZWYtc2VsZWN0YWJsZXtiYWNrZ3JvdW5kLWNvbG9yOiNmM2Y2Zjg7cGFkZGluZzoxMHB4IDE2cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmR0LXBsYWluLWxheW91dCAuZHQtaXMtYWN0aXZlLC5kdC1wbGFpbi1sYXlvdXQgLmR0LWlzLWRlZmF1bHQsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtaGlnaGxpZ2h0LC5kdC1wbGFpbi1sYXlvdXQgLmR0LWlzLWhvdmVyLC5kdC1wbGFpbi1sYXlvdXQgLmR0LWlzLWhvdmVyYWJsZS1yb3d7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kdC1pcy1hY3RpdmUsLmR0LWlzLWRlZmF1bHQsLmR0LWlzLWhpZ2hsaWdodCwuZHQtaXMtaG92ZXIsLmR0LWlzLWhvdmVyYWJsZS1yb3d7Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3O2JhY2tncm91bmQtY29sb3I6I2ZmZjtjb2xvcjojMzYzNjM2fS5kdC1yb3ctc2VsZWN0ZWQgdGR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzOCwyNTUsMjM4LC43MSl9LmR0LWlzLWFjdGl2ZXtib3JkZXItY29sb3I6IzA2NWQ5Yztjb2xvcjojMTk5ZGUwfS5kdC1pcy1oaWdobGlnaHR7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDY1LDExNyw1LC4xOCl9LmR0LWlzLWhpZGRlbntkaXNwbGF5Om5vbmV9LmR0LXUtdW5zZWxlY3RhYmxlLXRleHR7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstby11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmV9LmR0LXUtc29ydGFibGV7Y3Vyc29yOnBvaW50ZXJ9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIE9iamVjdFV0aWxzLFxuICAgICAgICBPdXRsaW5lU3RhdGUsXG4gICAgICAgIHtwcm92aWRlOiBEQVRBX1NPVVJDRSwgdXNlQ2xhc3M6IERUMkRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119LFxuICAgIF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuXG59KVxuZXhwb3J0IGNsYXNzIERhdGF0YWJsZTJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQVdEYXRhVGFibGUsIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJDb250ZW50SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogIExpc3Qgb2YgaXRlbXMgdG8gc2hvdyBpbiB0aGUgZGF0YXRhYmxlLlxuICAgICAqXG4gICAgICogIHRvZG86IGltcGxlbWVudCB0aGUgc2FtZSBEYXRhc291cmNlIGFuZCBsYXp5IGxvYWRpbmcganVzdCBsaWtlIEkgZGlkIGl0IGZvciBkYXRhdGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgZW50aXR5IGZvciB3aGljaCBEYXRhUHJvdmlkZXIgd2lsbCBiZSBsb2FkZWQuIFlvdSBjYW4gZWl0aGVyIHBhc3MgbGlzdCBvZiBpdGVtc1xuICAgICAqIG9yIHVzZSB0aGlzIGRlc3RpbmF0aW9uQ2xhc3MuIE5vdCBib3RoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgVGFibGVXcmFwcGVyIHRvIGFkZCB1c2VyIGRlZmluZWQgY2xhcyBpbnRvIHRoZSB0YWJsZSB0YWdcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFibGVTdHlsZUNsYXNzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNSb3dTZWxlY3RhYmxlOiAoaXRlbTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiAgSGlkZXMgb3Igc2hvd3MgdGFibGUgaGVhZGluZyB3aGVyZSB3ZSBoYXZlIGZpbHRlcnMgYW5kIHRvb2xzIG1lbnVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93VGFibGVIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGl2b3RhbExheW91dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5pdGlhbFNvcnRPcmRlcjogc3RyaW5nID0gJ2Rlc2NlbmRpbmcnO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbml0aWFsU29ydEtleTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIERUIGlzIGxvYWRlZCBpbiB0aGUgcGFnZSBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZnVsbCBzY3JlZW4gKGZ1bGwgcGFnZSBtb2RlKSwgdGhpc1xuICAgICAqIGlzIGh0ZSBudW1iZXIgb2YgbGluZXMgdGhhdCBEVCB3aWxsIHNob3dcbiAgICAgKlxuICAgICAqIHRvZG86IGNvbWUgdXAgd2l0aCBiZXR0ZXIgbmFtZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheVJvd1NpemU6IG51bWJlciA9IDEwO1xuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBwYWdpbmcgb24gbGF6eSBsb2FkaW5nIHVzaW5nIGluZmluaXRlIHNjcm9sbGVyIHRvIHNldCBpbml0aWFsIGZldGNoIGxpbWl0IHNpemVcbiAgICAgKlxuICAgICAqIHRvZG86IGNvbWUgdXAgd2l0aCBiZXR0ZXIgbmFtZSAhISFcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGFnZVNpemU6IG51bWJlciA9IDE1O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRhdGFTb3VyY2U6IERUMkRhdGFTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1lc3NhZ2Ugd2hlbiB0aGVyZSBhcmUgbm8gZGF0YSAuXG4gICAgICpcbiAgICAgKiB0b2RvOiBVc2UgaTE4biB2YWx1ZSBhbmQgY3JlYXRlIHJlc291cmNlIGZpbGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVtcHR5TWVzc2FnZTogc3RyaW5nID0gJ05vIHJlY29yZHMgZm91bmQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXZlbG9wZXIgY2FuIHByb3ZpZGUgY3VzdG9tIHRyYWNrQnkgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZVxuICAgICAqIHJlY29yZHNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd1RyYWNrQnk6IChpbmRleDogbnVtYmVyLCBpdGVtOiBhbnkpID0+IGFueTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSBhZGRzIGN1c3RvbSBob3ZlcmluZyBjbGFzcyB0byB0aGUgdGJvZHlcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd0hvdmVyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRG8gd2Ugc2hvdyBsb2FkaW5nIGluZGljYXRvclxuICAgICAqXG4gICAgICogVG9kbzogcmVuYW1lIHRvIHNob3dMb2FkaW5nXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsb2FkaW5nOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDYW4gcHJvdmlkZSBjdXN0b20gaWNvbi4gVGhlc2UgaWNvbnMgYXJlIG5vdCBhbmltYXRlZCBkaXZzLCB3ZSB1c2VkIGNzc1xuICAgICAqIHRyYW5zZm9ybWF0aW9uIHRvIHJvdGF0ZSB0aGVtLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsb2FkaW5nSWNvbjogc3RyaW5nID0gJ2ljb24tc3luY2hyb25pemUnO1xuXG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIGluZGVudCBjYW4gYmUgYWRkZWQgd2hlbiByZW5kZXJpbmcgZGV0YWlsIHJvd1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5kZW50RGV0YWlsUm93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyID0gMjU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBTdWJIZWFkZXIgaXMgdXNlZCB0byBzaG93IHN1bW1hcnkgY29sdW1ucywgd2hpY2ggaW4gb3VyIFVYIGlzIHNob3duIGF0IHRoZSB0b3AganVzdCB1bmRlclxuICAgICAqICB0aGUgcmVndWxhciB0YWJsZSBoZWFkZXJcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1N1YkhlYWRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIE91dGxpbmVGb3IgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqXG4gICAgICogTm90IHVzZWQgd2hlbiBbb3V0bGluZUZvcm1hdF09XCIndHJ1ZWUnXCJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNoaWxkcmVuOiAodmFsdWU6IGFueSkgPT4gYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFdlIG1pZ2h0IGhhdmUgdGhpcyBjb25kaXRpb25hbCBhcyB0aGlzIGNhbiBiZSBkeW5hbWljIGJhc2VkIG9uIHZhbHVlLCBzbyB0aGUgc2FtZVxuICAgICAqIGFzIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBTZWUgT3V0bGluZUZvciAtIG9ubHkgdXNlZCBpbiB0aGUgdHJlZSBtb2RlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93RXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZEFsbDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yICAtIGZvcm1hdCAtIG9ubHkgdXNlZCBpbiB0aGUgdHJlZSBtb2RlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvdXRsaW5lRm9ybWF0OiBNb2RlbEZvcm1hdCA9ICdmcmVlJztcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVyIG9yIGhpZGUgZXhwYW5zaW9uIGNvbnRyb2wgZm9yIHJvdyBkZXRhaWwgY29sdW1ucy4gRXhwYW5zaW9uIGNvbnRyb2wgbWFrZXMgc2Vuc2UgZm9yXG4gICAgICogc2ltcGxlIHRhYmxlLCB3aGVuIHVzaW5nIHRoaXMgaW5zaWRlIG91dGxpbmUgKHRyZWUgdGFibGUpLCBpdHMgZHJpdmVuIGJ5IG91dGxpbmUgY29udHJvbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1Jvd0RldGFpbEV4cGFuc2lvbkNvbnRyb2w6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTZWxlY3Rpb25Db2x1bW46IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1NlbGVjdEFsbDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFNob3cgb3IgaGlkZSBnbG9iYWwgc2VhcmNoIHRlcm0gaW5wdXQgZmllbGQgaW4gdGhlIGhlYWRlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0dsb2JhbFNlYXJjaDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgZnJvemVuIGNvbHVtbiBhcmUgdXNpbmcgd2UgY2FuIHNwZWNpZnkgb24gZ2xvYmFsIGxldmVsIHRvdGFsIHdpZHRoIG9mIHRoZSB0YWJsZSB0aGVcbiAgICAgKiBvdmVyZmxvd2luZyBjb250ZW50IG9yIHdpZHRoIGZvciBlYWNoIGNvbHVtbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNjcm9sbFdpZHRoOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgcm93IHJlb3JkZXJpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZG5kUm93RW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlcyBldmVudCB0aGF0IHNvcnRpbmcgaXMgZW5hYmxlZCBmb3IgY29sdW1uIGFuZCB3ZSB0cmlnZ2VyIHNvcnRpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU29ydDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIHNlbGVjdGlvbiBtb2RlIGl0IHRyaWdnZXJzIGV2ZW5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uUm93Q2xpY2s6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG11bHRpIG9yIHNpbmdsZSBzZWxlY3Rpb24gbW9kZSBpcyBlbmFibGVkIGl0IHdpbGwgdHJpZ2dlciBldmVudCB3aGVuIGNoZWNrYm94IG9yXG4gICAgICogcmFkaW8gYnV0dG9ucyBpcyBzZWxlY3RlZFxuICAgICAqXG4gICAgICogdG9kbzogaW1wbGVtZW50IFNpbmdsZVNlbGVjdGlvbkRUQ29sdW1uLCBNdWx0aVNlbGVjdGlvbkRUQ29sdW1uIHdpdGggdGhlaXIgcmVuZGVyZXJzXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Sb3dTZWxlY3Rpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNlbGwgYm9keSBzZWxlY3Rpb24gY2hhbmdlcyB3ZSBmaXJlIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNlbGxDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBjZWxsIGhlYWRlciBzZWxlY3Rpb24gY2hhbmdlcyB3ZSBmaXJlIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkhlYWRlclNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIEBDb250ZW50Q2hpbGQoRFRIZWFkZXJDb21wb25lbnQyKVxuICAgIGhlYWRlcjogRFRIZWFkZXJDb21wb25lbnQyO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1c3RvbSB0ZW1wbGF0ZSB0aGF0IGNhbiBiZSBpbXBsZW1lbnRlZCBieSBhcHBsaWNhdGlvbiB0byBzaG93IHdoZW4gdGhlcmUgYXJlXG4gICAgICogbm8gZGF0YSBpbiB0aGUgZGF0YWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ25vRGF0YVRlbXBsJylcbiAgICBlbXB0eU1lc3NhZ2VUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnZHRIZWFkZXInKVxuICAgIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnZHRTdWJIZWFkZXInKVxuICAgIHN1YkhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnZHRCb2R5JylcbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlckZpbHRlcicpXG4gICAgaGVhZGVyRmlsdGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3RzIHVzZWQgRFRDb2x1bW4gaW5zaWRlIGRhdGF0YWJsZSBhbmQgdGhlbiB0aGV5IGFyZSB1c2VkIGluc2lkZSB0aGUgdGVtcGxhdGUgdG9cbiAgICAgKiBpdGVyYXRlIG92ZXIgYW5kIHVzZSBpdHMgcmVuZGVyZXJUZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIFdoZW4gd2Ugd2lsbCBiZSBkZWZpbmluZyBuZXcgY29sdW1ucyBpdHMgaW1wb3J0YW50IHRoYXQgaXQgY2FuIGFsc28gbWF0Y2ggYWxsIHRoZVxuICAgICAqIGluaGVyaXRlZCBvbmVzLiBzbyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3ZSBkZWZpbmUgYSBwcm92aWRlciB0aG9zZSB0aG9zZSBjb2x1bW5zIHRvIHBvaW50XG4gICAgICogdG8gdGhlIERUQ29sdW1uQ29tcG9uZW50XG4gICAgICpcbiAgICAgKiBlLmcuOlxuICAgICAqXG4gICAgICoge3Byb3ZpZGU6IERUQ29sdW1uQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEZXRhaWxSb3dDb2x1bW4pfVxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihEVENvbHVtbjJDb21wb25lbnQpXG4gICAgY29sc1F1ZXJ5OiBRdWVyeUxpc3Q8RFRDb2x1bW4yQ29tcG9uZW50PjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChEVERldGFpbFJvd0NvbXBvbmVudClcbiAgICByb3dEZXRhaWxDb2x1bW46IERURGV0YWlsUm93Q29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRyaWdnZXJzIHdoZW4gaXRlbXMgaW4gdGhlIGxpc3QgYXJlIHVwZGF0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcblxuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gICAgY2xhc3NMaXN0OiBzdHJpbmcgPSAndy1kYXRhdGFibGUgJztcblxuXG4gICAgLyoqXG4gICAgICogRm9yIGludGVybmFsIHVzZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkYXRhc2V0IHRoYXQgaXMgYmVpbmcgcmVuZGVyZWQuIFNldCBmcm9tIHRoZSBbbGlzdF0gYmluZGluZyBvciBieSBsYXp5IGxvYWQgZnJvbVxuICAgICAqIGRhdGFzb3VyY2VcbiAgICAgKi9cbiAgICBwdWJsaWMgZGF0YVRvUmVuZGVyOiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIFdlIGNvbnZlcnQgUXVlcnlMaXN0PERUQ29sdW1uMkNvbXBvbmVudD4gdG8gdGhpcyBhcnJheSBmb3IgZWFzaWVyIG1hbmlwdWxhdGlvblxuICAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW5zOiBEVENvbHVtbjJDb21wb25lbnRbXTtcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZWNvbmRhcnkgbGlzdCBvZiBjb2x1bW5zIHdoaWNoIGlzIHVzZWQgaW4gY2FzZSB3ZSBoYXZlIGhhdmUgZW5hYmxlZFxuICAgICAqIGZyb3plbiBjb2x1bW5zLiBDb2x1bW5zIHRoYXQgYXJlIG1hcmtlZCBhcyBmcm96ZW4gbmVlZHMgdG8gYmUgcGxhY2VkIGludG8gc2VwYXJhdGUgYXJyYXlcbiAgICAgKiB0byBiZSByZW5kZXJlZCB3YXkgdGhhbiByZWd1bGFyIGNvbHVtbnMgd2hpY2ggYXJlIHN0b3JlZCBpbiB0aGUgY29sdW1ucyBhcnJheS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZnJvemVuQ29sdW1uczogRFRDb2x1bW4yQ29tcG9uZW50W107XG5cblxuICAgIC8qKlxuICAgICAqICBJbmRpY2F0ZXMgdGhhdCBjb2x1bW5zIHdlcmUgaW5pdGlhbGVkIEFsc28gdXNlZCB3aGVuIHdlIGhpZGUgYW5kIHNob3cgY29sdW1uIHRvIHRyaWdnZXJcbiAgICAgKiAgY2hhbmdlLlxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbnNDaGFuZ2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIHB1YmxpYyBzb3J0Q29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBjb2xzUXVlcnkgYW5kIGl0cyBjaGFuZ2VzIHNvIHdlIGNhbiBsYXRlciBvbiByZWxlYXNlIHRoZSBzdWJzY3JpcHRpb25cbiAgICAgKi9cbiAgICBjb2x1bW5zU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIGRldGFpbFJvd0V4cGFuc2lvblN0YXRlOiBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgbnVtYmVyT2ZDb2xzQmVmb3JlRGF0YTogbnVtYmVyID0gMDtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgc3RhcnRPZkZpcnN0RGF0YUNvbHVtbjogbnVtYmVyID0gMDtcblxuXG4gICAgLyoqXG4gICAgICogU2VjdGlvbiBmb3IgcHJvZ3JhbW1hdGljYWxseSBpbnN0YW50aWF0ZWQgY29sdW1ucyB0aGF0IGFyZSBhZGRlZCB0byB0aGUgbGlzdCBpZiBhZGRpdGlvbmFsXG4gICAgICogc3BhbiBvciBsb2dpYyBpcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBUbyBwcm9ncmFtbWF0aWNhbGx5IGluc2VydCBhIG5ldyBjb2x1bW4gaW50byBjb2x1bW5zIGFycmF5IGxpa2UgZXhwYW5kbyBjb2x1bW4gZm9yIGRldGFpbFxuICAgICAqIHJvdywgb3IgU2luZ2xlU2VsZWN0LCBNdWx0aVNlbGVjdCBjb2x1bW4gd2hlbiBzZWxlY3Rpb24gaXMgZW5hYmxlZCB3ZSBuZWVkIHRvIHVzZVxuICAgICAqIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBpbnN0YW50aWF0ZSBhIG5ldyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHJvd0RldGFpbEV4cGFuZENvbHVtbjogRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudDtcbiAgICBwcml2YXRlIG11bHRpU2VsZWN0Q29sdW1uOiBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50O1xuICAgIHByaXZhdGUgc2luZ2xlU2VsZWN0Q29sdW1uOiBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbiBjYXNlIG9mIG91dGxpbmUgdGFibGUgd2UgYXJlIGluamVjdCBPdXRsaW5lU3RhdGUgd2hpY2ggaXMgcHJvdmlkZWQgaW4gdGhlIERUIGNvbXBvbmVudFxuICAgICAqIGRlZmluaXRpb24uIFRoaXMgaXMgdXNlZCBieSBuZXN0ZWQgb3V0bGluZUZvciBjb21wb25lbnQgaXQgc2V0IGl0c2VsZiBhcyByZWZlcmVuY2UgYW5kXG4gICAgICogaW5pdGlhbGl6ZSB0aGUgc3RhdGUgc28gaXQgY2FuIGJlIHVzZWQgbGF0ZXIgb24gaW5zaWRlIE91dGxpbmVDb250cm9sXG4gICAgICpcbiAgICAgKlxuICAgICAqIEVhY2ggRGF0YXRhYmxlIGlzIHByZS1kZWZhdWx0ZWQgd2l0aCBpdHMgb3duIHZlcnNpb24gb2YgRGF0YVNvdXJjZSBzbyBhbGwgdGhlIG9ic2VydmVyc1xuICAgICAqIGluc2lkZSBhcmUgdW5pcXVlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBlbDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KERBVEFfU09VUkNFKSBwcml2YXRlIF9kZWZhdWx0RFM6IERUMkRhdGFTb3VyY2UsXG4gICAgICAgICAgICAgICAgcHVibGljIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgcHVibGljIG91dGxpbmVTdGF0ZTogT3V0bGluZVN0YXRlLFxuICAgICAgICAgICAgICAgIHB1YmxpYyB6b25lOiBOZ1pvbmUsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBpbmplY3RvcjogSW5qZWN0b3IpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuX2RlZmF1bHREUztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBzdGF0ZSBvdXQgdG8gYXBwbGljYXRpb24uIENhbiBiZSB1c2UgYXMgdHdvIHdheSBiaW5kaW5nc1xuICAgICAqXG4gICAgICogWyhzdGF0ZSldPWR0U3RhdGUocylcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHN0YXRlKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZTtcbiAgICB9XG5cbiAgICBzZXQgc3RhdGUodmFsOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUgPSB2YWw7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBiaW5kaW5ncyBbbGlzdF0gYW5kIFtkZXN0aW5hdGlvbkNsYXNzXSEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlID0gbmV3IERldGFpbFJvd0V4cGFuc2lvblN0YXRlKHRoaXMpO1xuXG4gICAgICAgIC8vIGluaXQgZGVmYXVsdCBjb2x1bW5zXG4gICAgICAgIHRoaXMucm93RGV0YWlsRXhwYW5kQ29sdW1uID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50KS5jcmVhdGUodGhpcy5pbmplY3RvcikuaW5zdGFuY2U7XG5cblxuICAgICAgICB0aGlzLm11bHRpU2VsZWN0Q29sdW1uID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50KS5jcmVhdGUodGhpcy5pbmplY3RvcikuaW5zdGFuY2U7XG5cbiAgICAgICAgdGhpcy5zaW5nbGVTZWxlY3RDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50KS5jcmVhdGUodGhpcy5pbmplY3RvcikuaW5zdGFuY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBkYXRhIGFyZSBub3QgZGVmZXJyZWQgYW5kIHdlIGdldCBsaXN0IGRpcmVjdGx5IHRoZW4gaXQgY3JlYXRlcyBEUy4gSWZcbiAgICAgICAgICogbmdPbkNoYW5nZXMgaXMgY2FsbGVkIGZpcnN0IHdlIHByb3Blcmx5IGluaXQgRFMgYW5kIGNsZWFuIHRoaXMubGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpIHx8IGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2luY2Ugd2Ugd29yayB3aXRoIHJlZmVyZW5jZXMgbGV0J3MgcGFzcyBjcmVhdGVkIG1hcCBpbnNpZGUgb3VyIHN0YXRlXG4gICAgICAgIHRoaXMub3V0bGluZVN0YXRlLmV4cGFuc2lvblN0YXRlcyA9IHRoaXMuc3RhdGUub3V0bGluZVN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGF0YSBhcnJpdmVzIGxhdGVyIG1heWJlIGR1ZSB0byBSRVNUIEFQSSBsYXRlbmN5LCBpbml0aWFsaXplIERTIG9ubHkgd2hlbiB3ZSBoYXZlIGFcbiAgICAgKiBkYXRhLCBvdGhlcndpc2UgaWYgZGF0YSBjaGFuZ2VkIHRocnUgdGhlIGJpbmRpbmdzIGp1c3QgdHJpZ2dlciBkYXRhQ2hhbmdlIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xpc3QnXSAmJiBpc1ByZXNlbnQoY2hhbmdlc1snbGlzdCddLmN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAgICYmICF0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpXG4gICAgICAgIHtcblxuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZSgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQodGhpcy5saXN0KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KClcbiAgICB7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGluaXQgYSBzdGF0ZSB3aGVuIGRldGFpbCBjb2x1bW4gaXMgcHJlc2VudFxuICAgICAgICAvLyB0b2RvOiBtb3ZlIHRoaXMgaW5pdGlhbGl6YXRpb24gdG8gZGF0YXNvdXJjZVxuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgPSBpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pO1xuXG4gICAgICAgIHRoaXMuaW5pdENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uID0gdGhpcy5jb2xzUXVlcnkuY2hhbmdlcy5zdWJzY3JpYmUoXyA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmluaXRDb2x1bW5zKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKVxuICAgIHtcbiAgICAgICAgLy8gYXNzaWduIGl0IHByb2dyYW1hdGljYWxseSBhcyB3ZSB3YW50IHRvIGhhdmUgYSBjb250ZXh0IGZvciB0aGUgZmlsdGVyXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pICYmIGlzUHJlc2VudCh0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvci5maWx0ZXJPdXQgPSB0aGlzLnNraXBPdXRsaW5lSXRlbS5iaW5kKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvci5jaGFuZ2VEZXRlY3Rvci5kZXRhY2goKTtcbiAgICAgICAgICAgIC8vIHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnNDaGFuZ2VkICYmIHRoaXMuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICAgICAgICAgIGNvbC5wb3N0SW5pdGlhbGl6ZShpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICAgICAgICAgIGNvbC5wb3N0SW5pdGlhbGl6ZShpbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5IGVudHJ5IG1ldGhvZCB0aGF0IGluaXRpYWxpemVkIG91ciBjb2x1bW5zLiBMYXRlciBvbiB3aGVuIHdlIHdpbGwgc3VwcG9ydCBzZWxlY3Rpb24gYW5kXG4gICAgICogbXVsdGlzZWxlY3Rpb24gd2Ugd2lsbCBwcm9ncmFtbWF0aWNhbGx5IGluc3RhbnRpYXRlIFNpbmdsZVNlbGVjdGlvbiwgTXVsdGlTZWxlY3Rpb24gY29sdW1uXG4gICAgICogY29tcG9uZW50cyBhbmQgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgc28gdGhleSBjYW4gYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBzbyB0aGUgaWRlYSBoZXJlIGlzOlxuICAgICAqXG4gICAgICogV2hlbiBEVCBjb21wb25lbnQgaW5pdGlhbGl6ZSBhbmQgd2UgYXJlIGluIGVkaXRpbmcgbW9kZSBhbmQgd2Ugc3VwcG9ydCBTaW5nbGUvTXVsdGkgc2VsZWN0aW9uXG4gICAgICogd2Ugd2lsbCB1c2UgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGNyZWF0ZSBjb21wb25lbnQgYW5kIGFkZCBpdCBhcyBmaXJzdCBpdGVtIHRvIHRoZSBsaXN0XG4gICAgICogYW5kIHRoZW4gaXQgd2lsbCBiZSByZW5kZXJlZCBqdXN0IGxpa2UgYW55dGhpZ24gZWxzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRDb2x1bW5zKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREZXRhaWxDb2x1bW5FeHBhbnNpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpU2VsZWN0Q29sdW1uLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLm11bHRpU2VsZWN0Q29sdW1uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdENvbHVtbi5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2godGhpcy5zaW5nbGVTZWxlY3RDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBleHBhbnNpb24gY29sdW1uIHdoZW4gZGV0YWlsIHJvdyBpcyBlbmFibGVkXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkICYmICF0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0RldGFpbEV4cGFuZENvbHVtbi5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2godGhpcy5yb3dEZXRhaWxFeHBhbmRDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xzUXVlcnlcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvbDE6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gIWNvbDEuZnJvemVuKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbC5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmluaXRGcm96ZW5Db2x1bW5zKCk7XG4gICAgICAgIHRoaXMuaW5pdENvbHVtbkluZm8oKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY3VycmVudCBjb2x1bW4gaXMgcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0ludGVybmFsQ29sdW1uKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGNvbCBpbnN0YW5jZW9mIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50IHx8XG4gICAgICAgICAgICBjb2wgaW5zdGFuY2VvZiBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50IHx8XG4gICAgICAgICAgICBjb2wgaW5zdGFuY2VvZiBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50O1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG5ldyBEYXRhc291cmNlIGJhc2VkIG9uIHBhc3NlZCB2YWx1ZXMuIEl0IHRyaWVzIHRvIGluaXRpYWxpemUgRFMgZm9yIGZpcnN0IHRpbWVcbiAgICAgKiBpbnNpZGUgdGhlIG5nSW5pdCBidXQgaW4gY2FzZSBEYXRhIGFycml2ZXMgbGF0ZXIgbWF5YmUgZHVlIHRvIHNvbWUgUkVTVCBBUEkgY2FsbHMgdGhpc1xuICAgICAqIGNhbiBiZSB0cmlnZ2VyZWQgYWxzbyBmcm9tIG5nT25DaGFuZ2VzLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdERhdGFzb3VyY2UoaW5pdGlhbGl6ZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IERhdGF0YWJsZTJTdGF0ZS5jcmVhdGUoMCwgdGhpcy5wYWdlU2l6ZSwgdGhpcy5kaXNwbGF5Um93U2l6ZSxcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxTb3J0S2V5LCB0aGlzLnNvcnRPcmRlcmluZ0ZvclN0cmluZyh0aGlzLmluaXRpYWxTb3J0T3JkZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubGltaXQgPSB0aGlzLnN0YXRlLmRpc3BsYXlMaW1pdCA9IHRoaXMuZGlzcGxheVJvd1NpemU7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaW5pdGlhbFNvcnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zb3J0S2V5ID0gdGhpcy5pbml0aWFsU29ydEtleTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnRPcmRlciA9IHRoaXMuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuaW5pdGlhbFNvcnRPcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdGlhbGl6ZSkge1xuXG4gICAgICAgICAgICBsZXQgcVR5cGUgPSAodGhpcy5pc091dGxpbmUoKSAmJiB0aGlzLm91dGxpbmVGb3JtYXQgPT09ICd0cmVlJykgP1xuICAgICAgICAgICAgICAgIFF1ZXJ5VHlwZS5GdWxsVGV4dE91dGxpbmUgOiBRdWVyeVR5cGUuRnVsbFRleHQ7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAgICAgICAgICAgICAgICBvYmo6IGlzUHJlc2VudCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpID8gdGhpcy5kZXN0aW5hdGlvbkNsYXNzIDogdGhpcy5saXN0LFxuICAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogcVR5cGUsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZmV0Y2godGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgLy8gcmVzZXQgbGlzdCB0byBtYWtlIHN1cmUgaXQgY29tZXMgZnJvbSBEYXRhUHJvdmlkZXIsIHdlIHVzZSBsaXN0ICB0byBpbml0aWFsaXplXG4gICAgICAgIHRoaXMubGlzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgRU5UUlkgcG9pbnQgZm9yIHRoZSBEQVRBIENIQU5HRVMuIEFsbCBhZGRpdGlvbiwgZWRpdHMsIGRlbGV0aW9uIGVuZHMgdXBcbiAgICAgICAgLy8gaGVyZS4gV2UgZG9udCB3b3JrIGRpcmVjdGx5IHdpdGggTElTVC4gQW55IGNoYW5nZSBpcyByZWFjdGl2ZSBhbmQgaGVyZSBpcyBsaXN0ZW5lclxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uub3BlbigpLnN1YnNjcmliZSgoZGF0YTogYW55W10pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGlzdChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZXRhaWxSb3cgY29sdW1uIGlzIHByZXNlbnQgd2UgaW5pdGlhbGl6ZSBhIHN0YXRlIGhvbGRpbmcgaW5mb3JtYXRpb24gd2hpY2ggaXRlbSBpc1xuICAgICAqIGV4cGFuZGVkLlxuICAgICAqXG4gICAgICogdG9kbzogVGhpcyBpcyB0ZW1wb3JhcnkgaGVyZSBhbmQgb25jZSB3ZSBzdXBvcnQgbGF6eSBsb2FkaW5nIG1vdmUgdGhpcyB0byBkYXRhc291cmNlLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUgZm9yIG91dGxpbmUgdHJlZSB0YWJsZSB3ZSBuZWVkIHRvIGNvbm5lY3QgYSBzdGF0ZSBmcm9tIG91dGxpbmUgd2l0aCBhIHN0YXRlIGluXG4gICAgICogaGVyZSBhcyB3ZSBhcmUgdXNpbmcgb3V0bGluZSBjb250cm9sIHRvIGV4cGFuZCBhbmQgY29sbGFwc2UgaXRlbXNcbiAgICAgKi9cbiAgICBpbml0RGV0YWlsQ29sdW1uRXhwYW5zaW9uKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pKSB7XG4gICAgICAgICAgICB0aGlzLnJvd0RldGFpbENvbHVtbi5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCA9IGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiZcbiAgICAgICAgICAgIEJvb2xlYW5XcmFwcGVyLmlzVHJ1ZSh0aGlzLnNob3dSb3dEZXRhaWxFeHBhbnNpb25Db250cm9sKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBleGVjdXRlZCBhZnRlciB3ZSBpbml0aWFsaXplIGFsbCB0aGUgY29sdW1ucyBpbiBvcmRlciB0byBjYWxjdWxhdGUgY29ycmVjdFxuICAgICAqIG51bWJlcnMgdXNlZCBmb3IgaW5kZW50YXRpb24gd2hpbGUgcmVuZGVyaW5nIHNlbGVjdGlvbiBjb2x1bW5zIGFzIHdlbGwgYXMgZGV0YWlsIHJvdyBjb2x1bW5zLlxuICAgICAqXG4gICAgICogSGVyZSB3ZSBuZWVkIHRvIGJlIGF3YXJlIGhvdyBtYW55IGNvbHVtbnMgdG8gc3BhblxuICAgICAqXG4gICAgICovXG4gICAgaW5pdENvbHVtbkluZm8oKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhID0gMDtcblxuICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICghY29sLmlzVmFsdWVDb2x1bW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pbmRlbnREZXRhaWxSb3cpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFydE9mRmlyc3REYXRhQ29sdW1uID0gdGhpcy5jb2x1bW5zLmxlbmd0aCAtIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2VsbFNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlICE9PSAnY2VsbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9va3VwS2V5ID0ge1xuICAgICAgICAgICAgY29sOiBjb2x1bW4ua2V5IHx8IGNvbHVtbi5sYWJlbCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiYgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGxvb2t1cEtleSk7XG4gICAgICAgICAgICBsZXQgaXNTZWxlY3RlZCA9IGZvdW5kSW5kZXggIT09IC0xO1xuXG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBmb3VuZEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGxvb2t1cEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtsb29rdXBLZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DZWxsQ2hhbmdlLmVtaXQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25IZWFkZXJTZWxlY3Rpb25DaGFuZ2UoY2VsbDogYW55LCBjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hlYWRlclNlbGVjdGVkKGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uID0gY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24gPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkhlYWRlclNlbGVjdGlvbi5lbWl0KHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICBvbkhhbmRsZVJvd0NsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gc3BlY2lhbCBhbHQga2V5IG1vZGlmaWVyLiBXaGVuIHVzZWQgd2l0aCByb3dzIGl0IGluZGljYXRlcyB0aGVyZSBpcyBhIEQmRCBlbmFibGVkXG4gICAgICAgIGlmIChldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aScpIHtcbiAgICAgICAgICAgIHRoaXMub25Sb3dUb2dnbGUoZXZlbnQsIGl0ZW0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgdGhpcy5vblJvd1NlbGVjdChldmVudCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uUm93VG9nZ2xlKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCByb3dTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pICYmIHRoaXMuc3RhdGUuc2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbSk7XG4gICAgICAgICAgICBsZXQgaXNTZWxlY3RlZCA9IGZvdW5kSW5kZXggIT09IC0xO1xuXG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBmb3VuZEluZGV4KTtcblxuICAgICAgICAgICAgICAgIHJvd1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yIHRoZSBvdXRsaW5lIGdvIHVwIGFuZCBkb3duIHRoZSBzeW5jIHdpdGggdHJlZWl0ZW1zXG4gICAgICAgICAgICBpZiAodGhpcy5pc091dGxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihpdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoaXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtpdGVtXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRsaW5lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oaXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMub0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUm93U2VsZWN0aW9uQ2hhbmdlLmVtaXQoe1xuICAgICAgICAgICAgaXNTZWxlY3RlZDogcm93U2VsZWN0ZWQsXG4gICAgICAgICAgICBpdGVtOiB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uUm93U2VsZWN0KGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gaXRlbTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5vblJvd1NlbGVjdGlvbkNoYW5nZS5lbWl0KGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuRm9yTm9kZSA9IHRoaXMuY2hpbGRyZW4uYXBwbHkodGhpcy5jb250ZXh0LCBbY3VycmVudEl0ZW1dKSB8fCBbXTtcblxuICAgICAgICBpZiAoY2hpbGRyZW5Gb3JOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIGlzIHNlbGVjdGVkIGN1cnJlbnRseSB0aGVuIHRvZ2dsZSB0byBvdGhlciBzdGF0ZVxuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjaGVja2luZyBhbGwgZnJvbSByb290LCBkZXNlbGVjdCBjaGlsZHJlbiBhbmQgYWRkIGFsbFxuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjdXJyZW50SXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIC4uLmNoaWxkcmVuRm9yTm9kZV07XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVhY2ggY2hpbGRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbkZvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gZm91bmRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcHBseSB0aGUgc2FtZSBmb3IgY2hpbGRyZW4gb2YgY2hpbGRyZW5cbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjaGlsZCwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBjdXJyZW50SXRlbS4kJHBhcmVudEl0ZW07XG4gICAgICAgIGlmIChpc1ByZXNlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkcmVuRm9yTm9kZSA9IHRoaXMuY2hpbGRyZW4uYXBwbHkodGhpcy5jb250ZXh0LCBbcGFyZW50XSkgfHwgW107XG5cbiAgICAgICAgICAgIGxldCBhbGxTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbkZvck5vZGUpIHtcbiAgICAgICAgICAgICAgICBhbGxTZWxlY3RlZCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGNoaWxkKSAhPT0gLTFcbiAgICAgICAgICAgICAgICAgICAgJiYgYWxsU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbi5wdXNoKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghYWxsU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhcmVudEluZGV4ID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gcGFyZW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChjdXJyZW50SXRlbS4kJHBhcmVudEl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRuRFJvd0Ryb3Aob3JpZ1BvczogbnVtYmVyLCBuZXdQb3M6IG51bWJlciwgZHJvcFBvczogRHJvcFBvc2l0aW9uKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRHJvcHBpbmcgcm93ICM6ICcsIG9yaWdQb3MgKyAnICcgKyBkcm9wUG9zICsgJyByb3cgIzogJyArIG5ld1Bvcyk7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UucmVvcmRlclJvd3Mob3JpZ1BvcywgbmV3UG9zLCBkcm9wUG9zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25PdXRsaW5lRXhwYW5kQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgaXRlbSA9IGV2ZW50Lml0ZW07XG5cbiAgICAgICAgLy8gV2UgZG9udCByZWFsbHkgbmVlZCB0byBzdG9yZSBhIHN0YXRlIGZvcm0gb3V0bGluZSBsb2NhbGx5IGFzIHdlIGFyZSB1c2luZyB0aGUgc2FtZSBvYmplY3RcbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIC8vIHRoaXMuc3RhdGUub3V0bGluZVN0YXRlID0gdGhpcy5vdXRsaW5lU3RhdGUuZXhwYW5zaW9uU3RhdGVzO1xuXG4gICAgICAgIGlmICh0aGlzLmNhblVzZUZvckRldGFpbFJvdyhpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS50b2dnbGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgc29ydFNpbmdsZSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgaXNQcmVzZW50KHRoaXMuc29ydENvbHVtbikpIHtcblxuICAgICAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLnNvcnRDb2x1bW4ua2V5KSwgJ0ludmFsaWQgY29sdW1uIHRvIHNvcnQnKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zb3J0KHRoaXMuc29ydENvbHVtbi5rZXksIHRoaXMuc29ydENvbHVtbi5zb3J0T3JkZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm9uU29ydC5lbWl0KHtcbiAgICAgICAgICAgICAgICBmaWVsZDogdGhpcy5zb3J0Q29sdW1uLmtleSxcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5zb3J0Q29sdW1uLnNvcnRPcmRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFuZ2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc29ydEtleSB8fCB0aGlzLnNvcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zb3J0Q29sdW1uICYmIHRoaXMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydENvbHVtbiA9IHRoaXMuY29sdW1ucy5maW5kKFxuICAgICAgICAgICAgICAgICAgICBjb2wgPT4gY29sLmtleSA9PT0gdGhpcy5zdGF0ZS5zb3J0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLmxpc3QpO1xuICAgIH1cblxuICAgIHVwZGF0ZURhdGFUb1JlbmRlcihkYXRhc291cmNlPzogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5kYXRhVG9SZW5kZXIgPSBkYXRhc291cmNlIHx8IHRoaXMubGlzdDtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNoaWxkcmVuKSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhVG9SZW5kZXIpXG4gICAgICAgICAgICAmJiB0aGlzLmRhdGFUb1JlbmRlci5sZW5ndGggPiAwICYmIGlzT3V0bGluZU5vZGUodGhpcy5kYXRhVG9SZW5kZXJbMF0pKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3JtYXQgPSAndHJlZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICByZXNldCgpXG4gICAge1xuICAgICAgICB0aGlzLnNvcnRDb2x1bW4gPSBudWxsO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIGlzSGVhZGVyU2VsZWN0ZWQoaXRlbTogRFRDb2x1bW4yQ29tcG9uZW50KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29sTWF0Y2hlZCA9IGl0ZW0ua2V5IHx8IGl0ZW0ubGFiZWw7XG4gICAgICAgIGxldCBjdXJyZW50Q29sID0gdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24ua2V5IHx8IHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uLmxhYmVsO1xuICAgICAgICByZXR1cm4gY29sTWF0Y2hlZCA9PT0gY3VycmVudENvbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNCb2R5Q2VsbFNlbGVjdGVkKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgbG9va3VwS2V5ID0ge1xuICAgICAgICAgICAgY29sOiBjb2x1bW4ua2V5IHx8IGNvbHVtbi5sYWJlbCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiZcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGxvb2t1cEtleSkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzUm93U2VsZWN0ZWQoaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmIGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtKSAhPT0gLTE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHModGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERvIHdlIGhhdmUgZGF0YSB0byByZW5kZXIgVXNlZCBpbnNpZGUgdGVtcGxhdGUgdG8gdGVsbCBpZiB3ZSBzaG91bGQgdXNlIHRoZSBOb0RhdGEgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRW1wdHkoKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzQmxhbmsodGhpcy5kYXRhVG9SZW5kZXIpIHx8ICh0aGlzLmRhdGFUb1JlbmRlci5sZW5ndGggPT09IDApO1xuICAgIH1cblxuICAgIGhhc0Zyb3plbkNvbHVtbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmZyb3plbkNvbHVtbnMpICYmIHRoaXMuZnJvemVuQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIGhhc0ludmlzaWJsZVNlbGVjdGlvbkNvbHVtbigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgIXRoaXMuc2hvd1NlbGVjdGlvbkNvbHVtbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlICE9PSAnbm9uZScgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlICE9PSAnY2VsbCc7XG4gICAgfVxuXG4gICAgdmlzaWJsZUNvbHVtbnMoKTogRFRDb2x1bW4yQ29tcG9uZW50W11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMgPyB0aGlzLmNvbHVtbnMuZmlsdGVyKGMgPT4gYy5pc1Zpc2libGUpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0T3JkZXJpbmdGb3JTdHJpbmcoZGlyZWN0aW9uOiBzdHJpbmcpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAnYXNjZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gJ2Rlc2NlbmRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogbG9nIGJhZCBrZXlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgc29ydE9yZGVyaW5nRm9yTnVtYmVyKGRpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Rlc2NlbmRpbmcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IGxvZyBiYWQga2V5XG4gICAgICAgIHJldHVybiAnYXNjZW5kaW5nJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUFsbENvbHVtbnMoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcbiAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0ID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24gfHwgW107XG4gICAgICAgIGlmIChzZWxlY3RlZE9iamVjdC5sZW5ndGggPj0gY3VycmVudEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW107XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi5jdXJyZW50SXRlbXNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzVG9nZ2xlQWxsQ29sdW1uU2VsZWN0ZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IGN1cnJlbnRJdGVtcyA9IHRoaXMuZGF0YVRvUmVuZGVyIHx8IFtdO1xuICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3QgPSB0aGlzLnN0YXRlLnNlbGVjdGlvbiB8fCBbXTtcblxuICAgICAgICByZXR1cm4gY3VycmVudEl0ZW1zLmxlbmd0aCA+IDAgJiYgc2VsZWN0ZWRPYmplY3QubGVuZ3RoID49IGN1cnJlbnRJdGVtcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5EaXNhYmxlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtcy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IHRlbXBsYXRlIHRvIGRlY2lkZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBEZXRhaWxSb3cgdGVtcGxhdGUuIFdlIG5lZWQgdG8gaGF2ZVxuICAgICAqIERldGFpbFJvdyBDb250ZW50Q2hpbGQgYW5kIHVzaW5nIERldGFpbFJvdyBjb21wb25lbnQgW2lzVmlzaWJsZUZuXSBmdW5jdGlvbiBiaW5kaW5nIHdlXG4gICAgICogY2hlY2sgaWYgdGhlIGl0ZW0gdGhhdCBpcyBhYm91dCB0byBiZSByZW5kZXJlZCBpcyBlbGlnaWJsZSBmb3IgZGV0YWlsIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd0RldGFpbENvbHVtbihpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5jYW5Vc2VGb3JEZXRhaWxSb3coaXRlbSkgJiYgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5pc0V4cGFuZGVkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzT3V0bGluZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY2hpbGRyZW4pIHx8IHRoaXMub3V0bGluZUZvcm1hdCA9PT0gJ3RyZWUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBkZWFsaW5nIHdpdGggZGV0YWlsIGNvbHVtbiAoZGV0YWlsIHJvdykgYW5kIG91dGxpbmUgYWxsIHRvZ2V0aGVyIHdlIG5lZWQgaGF2ZSBhXG4gICAgICogbWVjaGFuaXNtIHRvIHRlbGwgdG8gdGhlIG91dGxpbmUgXCJkb24ndCByZW5kZXIgdGhlIG5leHQgbGV2ZWwgb2YgaXRlbXNcIiBhbmQgdXNlIGRldGFpbCByb3cuXG4gICAgICogU28gY2VydGFpbiBpdGVtIHR5cGUgbmVlZHMgdG8gYmUgc2tpcHBlZC5cbiAgICAgKlxuICAgICAqIFRoZSB3YXkgd2Ugc2tpcCB0aG9zZSBpdGVtIGlzIHdlIHVzZSBpc1Zpc2libGVGbiBjb25kaXRpb24gb2YgdGhlIGRldGFpbCByb3cgYW5kIGxvb2sgYWhlYWRcbiAgICAgKiBpZiB3ZSBzaG91bGQgc2tpcCBuZXh0IGxldmVsLlxuICAgICAqXG4gICAgICovXG4gICAgc2tpcE91dGxpbmVJdGVtKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhblVzZUZvckRldGFpbFJvdyhpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGdldFZhbHVlKGRhdGE6IGFueSwgZmllbGQ6IHN0cmluZyk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIEZpZWxkUGF0aC5nZXRGaWVsZFZhbHVlKGRhdGEsIGZpZWxkKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhhdCB3ZSBhbHNvIGluY2x1ZGUgcHJvZ3JhbW1hdGljIGNvbHVtbiBpZiBwcmVzZW50LiBNb3ZlIHRoZW0gdG8gdGhlIGNvcnJlY3RcbiAgICAgKiBhcnJheVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0RnJvemVuQ29sdW1ucygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmNvbHNRdWVyeVxuICAgICAgICAgICAgLmZpbHRlcigoY29sMTogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiBjb2wxLmZyb3plbilcbiAgICAgICAgICAgIC5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb2wuaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMucHVzaChjb2wpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5mcm96ZW5Db2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGZpbmQgbGFzdCBpbmRleCBvZiBjb2x1bW4gdGhhdCBpcyBpbnRlcm5hbCAvIHByb2dyYW1tYXRpY1xuXG4gICAgICAgICAgICBsZXQgbGFzdElueCA9IHRoaXMuY29sdW1ucy5zbGljZSgpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5maW5kSW5kZXgoKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiB0aGlzLmlzSW50ZXJuYWxDb2x1bW4oY29sKSk7XG5cbiAgICAgICAgICAgIGlmIChsYXN0SW54ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBpZHggPSB0aGlzLmNvbHVtbnMubGVuZ3RoIC0gMSAtIGxhc3RJbng7XG4gICAgICAgICAgICAgICAgbGV0IGludGVybmFsQ29scyA9IHRoaXMuY29sdW1ucy5zcGxpY2UoMCwgaWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zID0gWy4uLmludGVybmFsQ29scywgLi4udGhpcy5mcm96ZW5Db2x1bW5zXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaGFzVmFsaWRDb2xzID0gdGhpcy5jb2x1bW5zXG4gICAgICAgICAgICAgICAgLmZpbmRJbmRleCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IGlzQmxhbmsoY29sLndpZHRoKSkgPT09IC0xO1xuXG4gICAgICAgICAgICBhc3NlcnQoaGFzVmFsaWRDb2xzIHx8IGlzUHJlc2VudCh0aGlzLnNjcm9sbFdpZHRoKSxcbiAgICAgICAgICAgICAgICAnV2hlbiB1c2luZyBbZnJvemVuXSBiaW5kaW5nIHlvdSBuZWVkIHNwZWNpZnkgW3dpZHRoXSBmb3IgZWFjaCAnICtcbiAgICAgICAgICAgICAgICAnY29sdW1uIG9yIFtzY3JvbGxXaWR0aF0gb24gZGF0YXRhYmxlIScpO1xuXG5cbiAgICAgICAgICAgIGFzc2VydChpc0JsYW5rKHRoaXMucm93RGV0YWlsQ29sdW1uKSxcbiAgICAgICAgICAgICAgICAnWW91IGNhbm5vdCBjb21iaW5lIGF3LWR0LWRldGFpbC1jb2x1bW4gd2l0aCBmcm96ZW4gY29sdW1ucyEnKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjdXJyZW50IGltbXV0YWJsZSBsaXN0IGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uIE5lZWQgdG8gd3JhcCBpdCB3aXRoXG4gICAgICogc2V0VGltZW91dCBhcyB0aGUgY2hhbmdlIGNhbiBlYXNpbHkgY29tZSBhZnRlciB2aWV3IGNoZWNrZWQgYW5kIHRoaXMgd291bGQgcmVzdWx0IHNvbWUgZXJyb3JzXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUxpc3QobmV3TGlzdDogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYW5Vc2VGb3JEZXRhaWxSb3coaXRlbTogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiZcbiAgICAgICAgICAgICg8RFREZXRhaWxSb3dDb21wb25lbnQ+dGhpcy5yb3dEZXRhaWxDb2x1bW4pLnNob3dEZXRhaWxSb3coaXRlbSk7XG4gICAgfVxufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgUExBVEZPUk1fSUQsXG4gICAgUmVuZGVyZXIyLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7U3ViamVjdCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBvZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2RlYm91bmNlVGltZSwgZGlzdGluY3RVbnRpbENoYW5nZWQsIHN3aXRjaE1hcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtpc1BsYXRmb3JtQnJvd3Nlcn0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5maW5pdGVTY3JvbGxDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvaW5maXRlLXNjcm9sbC9pbmZpdGUtc2Nyb2xsLmNvbXBvbmVudCc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi4vLi4vLi4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogUGxlYXNlIHNlZSBkYXRhdGFibGUgZm9yIG1vcmUgZGV0YWlsIGRlc2NyaXB0aW9uLiBCdXQgdGhlIG1haW4gZ29hbCBvZiB0aGlzIHdyYXBwZXIgdG8gcmVtb3ZlXG4gKiBhbGwgdGhlIGNvbW1vbiBzdXJyb3VuZGluZyBwYXJ0cyBhcm91bmQgdGhlIGRhdGF0YWJsZSBhbmQgbWFrZSBzdXJlIERUIGNhbiBmb2N1cyBvbmx5IGFjdHVhbFxuICogaGVhZGVyIGFuZCBib2R5IHN0cnVjdHVyZVxuICpcbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgd3JhcHBlciBhbHNvIHByb3ZpZGVzIHNvbWUgY29kZSBmb3IgdGhlIHNsaWRpbmcgdXAgcGFuZWwgY29udGFpbmluZ1xuICogYnV0dG9ucyBhbmQgb3RoZXIgYWN0aW9ucyB0aGF0IHdpbGwgYmUgdXNlZCBkdXJpbmcgZWRpdGluZ1xuICpcbiAqXG4gKiBUb2RvOiBFeHRyYWN0IHRoZSBleHBhbmQgbG9naWMgb3V0IGludG8gc29tZSBkaXJlY3RpdmUgb3IgY29tcG9uZW50IG9yIGp1c3QgYSBjbGFzc1xuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC13cmFwcGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgW25nQ2xhc3NdPVwiZHQuc3R5bGVDbGFzc1wiIFtjbGFzcy5kdC1mdWxsLXNjcmVlbi1tb2RlXT1cImlzRnVsbFNjcmVlbk1vZGVcIlxuICAgICBbc3R5bGUud2lkdGhdPVwiZHQud2lkdGhcIlxuPlxuICAgIDxkaXYgY2xhc3M9XCJkdC1sb2FkaW5nLW92ZXJsYXlcIiAqbmdJZj1cImR0LmxvYWRpbmdcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtbG9hZGluZy1jb250ZW50XCIgKm5nSWY9XCJkdC5sb2FkaW5nXCI+XG4gICAgICAgIDxpIFtjbGFzc109XCInc2FwLWljb24gdS1kdC1zcGluLWljb24gJyArIGR0LmxvYWRpbmdJY29uXCI+PC9pPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImR0LWhlYWRlclwiICpuZ0lmPVwiZHQuc2hvd1RhYmxlSGVhZGVyXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImR0LmhlYWRlcjsgdGhlbiBhcHBEZWZpbmVkSGVhZGVyIGVsc2UgZGVmYXVsdEhlYWRlclwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIERUIEJPRFkgd2l0aCB0YWJsZSBoZWFkZXJzIGFuZCB2YWx1ZXMgLS0+XG4gICAgPGRpdiBjbGFzcz1cImR0LWJvZHktd3JhcHBlci12aWV3XCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICAgICAgKm5nSWY9XCJkdC5oYXNGcm96ZW5Db2x1bW5zKCk7IHRoZW4gZHRCb2R5V2l0aEZyb3plbkNvbHVtbnMgZWxzZSBkdEJvZHlOb0Zyb3plbkNvbHVtbnNcIj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS08ZGl2IGNsYXNzPVwiZHQtZm9vdGVyXCIgKm5nSWY9XCJmb290ZXJcIj4tLT5cbiAgICA8IS0tJmx0OyEmbmRhc2g7IGZvb3RlckFyZWEmbmRhc2g7Jmd0Oy0tPlxuICAgIDwhLS08bmctY29udGVudCBzZWxlY3Q9XCJhdy1kdC1mb290ZXJcIj48L25nLWNvbnRlbnQ+LS0+XG4gICAgPCEtLTwvZGl2Pi0tPlxuPC9kaXY+XG5cbjwhLS0gdG9kbzogZG9udCBhY3RpdmF0ZSB0aGlzIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCBvZiBsaXN0IC0gLS0+XG48YXctaW5maW5pdGUtc2Nyb2xsICNpbmZpbml0ZVNjcm9sbCAqbmdJZj1cImlzRnVsbFNjcmVlbk1vZGVcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzdGFuY2VdPVwiJzEwJSdcIlxuICAgICAgICAgICAgICAgICAgICBbZmV0Y2hTaXplXT1cImR0LnN0YXRlLmxpbWl0XCJcbiAgICAgICAgICAgICAgICAgICAgKG9uTG9hZCk9XCJvbkxhenlMb2FkKCRldmVudClcIj5cbjwvYXctaW5maW5pdGUtc2Nyb2xsPlxuXG5cbjxuZy10ZW1wbGF0ZSAjYXBwRGVmaW5lZEhlYWRlcj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGluZztcIj48L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEhlYWRlcj5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtZ2xvYmFsLWZpbHRlclwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInNhcC1pY29uIGljb24tZmlsdGVyXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImR0LWdsb2JhbC1hY3Rpb25zXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJkdC1hY3Rpb24tY29tYm9cIj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwic3VwcG9ydEZ1bGxTY3JlZW5cIiBjbGFzcz1cInNhcC1pY29uIGljb24tcmVzaXplXCJcbiAgICAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVGdWxsU2NyZWVuKCRldmVudClcIj48L3NwYW4+XG5cbiAgICAgICAgICAgIDxhdy1pbnB1dC1maWVsZCAqbmdJZj1cImR0LnNob3dHbG9iYWxTZWFyY2hcIiBzdHlsZUNsYXNzPVwiZHQtdGFibGUtc2VhcmNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cImR0LnN0YXRlLmN1cnJlbnRTZWFyY2hRdWVyeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VIb2xkZXI9XCJzZWFyY2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGljb249XCJpY29uLXNlYXJjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwic2VhcmNoVGVybXMubmV4dCgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8L2F3LWlucHV0LWZpZWxkPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhcmliYS1pY29uIGljb24tbW9yZVwiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tXG4gICAgRWFjaCBzZWN0aW9uIGZyb3plbi9ub24tZnJvemVuIGlzIGNhbGN1bGF0ZWQgaW5zaWRlIHRhYmxlLXdyYXBwZXIgaW4gdGhlIG5nQWZ0ZXJWaWV3Q2hlY2tlZCwgd2hlcmUgd2Ugc2V0XG4gICAgcHJvcGVyIHdpZHRoIGZvciBlYWNoIGZyYW1lIGFzIHdlbGwgYXMgbGVmdCBjb29yZGluYXRlcyBmb3IgdGhlIHJpZ2h0IG9uZVxuLS0+XG48bmctdGVtcGxhdGUgI2R0Qm9keU5vRnJvemVuQ29sdW1ucz5cbiAgICA8IS0tXG4gICAgICAgIEZvciBub24tZnJvemVuIGNhc2Ugd2UgYWxzbyBuZWVkIHRvIHNldCBUUlVFIGFzIHRoZSB2aWV3IGlzIGFjdHVhbGx5IGZyb3plbiBhbmQgZG9lcyBub3RcbiAgICAgICAgc2Nyb2xsLlxuICAgICAgICBXZSB1c2UgdGhpcyBmcm96ZW5Db2x1bW5zIGZsYWcgaW5zaWRlIERUIHRvIHByb3Blcmx5IHNldCBjb2x1bW4gaW5kZXggb24gdGhlIGhlYWRlciBsZXZlbFxuICAgICAgICBjb2x1bW5JbmRleDooZnJvemVuID8gY29sdW1uSW5kZXg6IChjb2x1bW5zLmxlbmd0aCArIGNvbHVtbkluZGV4KSlcblxuICAgICAgICB0aGVyZWZvcmUgd2UgbmVlZCB0byBzZXQgdHJ1ZSBldmVuIGluIHRoaXMgY2FzZSB0byByZXR1cm4gcmVhbCBjb2x1bW5JbmRleCBzaW5jZSB3ZSBkb250XG4gICAgICAgIGhhdmUgdGhlIHNlY29uZCB0YWJsZS5cbiAgICAtLT5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHRCb2R5OyBjb250ZXh0OnskaW1wbGljaXQ6IGR0LmNvbHVtbnMsIGZyb3plbkNvbHVtbnM6IHRydWUgfVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkdEJvZHlXaXRoRnJvemVuQ29sdW1ucz5cbiAgICA8bmctY29udGFpbmVyXG4gICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHRCb2R5OyBjb250ZXh0OnskaW1wbGljaXQ6IGR0LmZyb3plbkNvbHVtbnMsIGZyb3plbkNvbHVtbnM6IHRydWUgfVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJkdEJvZHk7IGNvbnRleHQ6eyRpbXBsaWNpdDogZHQuY29sdW1ucywgZnJvemVuQ29sdW1uczogZmFsc2UgfVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2R0Qm9keSBsZXQtY29sdW1ucyBsZXQtZnJvemVuQ29sdW1ucz1cImZyb3plbkNvbHVtbnNcIj5cblxuICAgIDxkaXYgI2R0Q29udGFpbmVyIGNsYXNzPVwiZHQtYm9keS13cmFwcGVyXCJcbiAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJ0aGlzLmNhbGN1bGF0ZUZyb3plbldpZHRoKClcIlxuICAgICAgICAgW2NsYXNzLmR0LWJvZHktdW5mcm96ZW5dPVwiZHQuaGFzRnJvemVuQ29sdW1ucygpICYmICFmcm96ZW5Db2x1bW5zXCJcbiAgICAgICAgIFtjbGFzcy5kdC1ib2R5LWZyb3plbl09XCJkdC5oYXNGcm96ZW5Db2x1bW5zKCkgJiYgZnJvemVuQ29sdW1uc1wiXG4gICAgPlxuXG4gICAgICAgIDx0YWJsZSBbbmdDbGFzc109XCJkdC50YWJsZVN0eWxlQ2xhc3NcIlxuICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoXT1cImZyb3plbkNvbHVtbnMgPyBudWxsIDogZHQuc2Nyb2xsV2lkdGhcIlxuICAgICAgICAgICAgICAgW2NsYXNzLmR0LXBpdm90LWxheW91dF09XCJkdC5waXZvdGFsTGF5b3V0XCJcbiAgICAgICAgICAgICAgIFtjbGFzcy5kdC1wbGFpbi1sYXlvdXRdPVwiIWR0LnBpdm90YWxMYXlvdXQgJiYgIWR0LmlzT3V0bGluZSgpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gUmVuZGVyIFRIIGhlYWRlciByb3dzLS0+XG4gICAgICAgICAgICA8dGhlYWQgY2xhc3M9XCJkdC10aGVhZFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlclJvd3M7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sdW1ucyxmcm96ZW5Db2x1bW5zOmZyb3plbkNvbHVtbnMgfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L3RoZWFkPlxuXG4gICAgICAgICAgICA8IS0tXG4gICAgICAgICAgICAgICAgUmVuZGVyIGRhdGEgcm93cy4gRm9yIGRhdGEgcm93cyB3ZSBuZWVkIHRvIGtlZXAgdGJvZHkgdGFnIGluc2lkZSBEVCB0YWJsZVxuICAgICAgICAgICAgICAgIGR1ZSB0byBPdXRsaW5lXG4gICAgICAgICAgICAgLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVJvd3M7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sdW1ucywgIGZyb3plbkNvbHVtbnM6ZnJvemVuQ29sdW1ucyB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC90YWJsZT5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPGRpdiAjZHRGdWxsU2NyZWVuT3ZlcmxheSBjbGFzcz1cImR0LWZ1bGwtc2NyZWVuLW92ZXJsYXkgdS1mdWxsLXNjcmVlbi1lbGVtZW50XCI+PC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2AuZHQtZm9vdGVyLC5kdC1oZWFkZXJ7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzouNWVtIC43NWVtO2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZHQtZm9vdGVye2JvcmRlci10b3A6MH0uZHQtdGhlYWQgdHJ7Ym9yZGVyLXdpZHRoOjB9LmR0LWJvZHktd3JhcHBlci12aWV3e3Bvc2l0aW9uOnJlbGF0aXZlfS5kdC1ib2R5LXdyYXBwZXJ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjoxcHggc29saWQgI2Q3ZDdkN30uZHQtYm9keS13cmFwcGVyLmR0LWJvZHktdW5mcm96ZW57Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7b3ZlcmZsb3cteDphdXRvfS5kdC1sb2FkaW5nLW92ZXJsYXl7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojOWI5YjliO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3BhY2l0eTouMTt6LWluZGV4OjF9LmR0LWxvYWRpbmctY29udGVudHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6MjUlO3otaW5kZXg6Mn0uZHQtaGVhZGVye3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2ZsZXgtZmxvdzpyb3cgbm93cmFwO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2NvbG9yOiMzNjM2MzY7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2YxZjFmMTttYXJnaW4tYm90dG9tOjMwcHh9LmR0LWhlYWRlciAuZHQtZ2xvYmFsLWZpbHRlcntmbGV4OjAgMDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2ZvbnQtc2l6ZToxOHB4fS5kdC1oZWFkZXIgLmR0LWdsb2JhbC1hY3Rpb25ze2ZsZXg6MCAwO2FsaWduLWl0ZW1zOmZsZXgtZW5kfS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ib3tkaXNwbGF5OmZsZXg7ZmxleC1mbG93OnJvdyBub3dyYXA7Y29sb3I6IzdkN2Q3ZH0uZHQtaGVhZGVyIC5kdC1hY3Rpb24tY29tYm8gLmFyaWJhLWljb24sLmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJvIC5zYXAtaWNvbnttYXJnaW4tbGVmdDoxNXB4O2ZvbnQtc2l6ZToyMHB4O2FsaWduLXNlbGY6Y2VudGVyO2N1cnNvcjpwb2ludGVyfS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ibyAuZHQtdGFibGUtc2VhcmNoe2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ibyAuaWNvbi1yZXNpemV7Y29sb3I6IzRhNGE0YTtmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoxOHB4O21hcmdpbi1yaWdodDoxNXB4fS51LWR0LXNwaW4taWNvbntkaXNwbGF5OmlubGluZS1ibG9jazstd2Via2l0LWFuaW1hdGlvbjoycyBsaW5lYXIgaW5maW5pdGUgZG9TcGluO2FuaW1hdGlvbjoycyBsaW5lYXIgaW5maW5pdGUgZG9TcGlufUAtd2Via2l0LWtleWZyYW1lcyBkb1NwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9MTAwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgZG9TcGluezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwKTt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX0uZHQtZnVsbC1zY3JlZW4tb3ZlcmxheXtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwMDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCU7dHJhbnNpdGlvbjphbGwgLjRzIGVhc2UtaW4tb3V0fS5kdC1mdWxsLXNjcmVlbnt3aWR0aDo5OHZ3O3otaW5kZXg6MTIwO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxNXB4O3BvaW50ZXItZXZlbnRzOmFsbDt0cmFuc2l0aW9uOm9wYWNpdHkgLjVzIGVhc2UtaW4tb3V0fS51LWZzLWVsZW1lbnQtb3V0e2Rpc3BsYXk6bm9uZX1gXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRXcmFwcGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWRcbntcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRoYXQgaXMgdXNlZCBieSBmdWxsIHNjcmVlbiBkaXYgb3ZlcmxheSB0byBjcmVhdGUgZXhwYW5kaW5nIGVmZmVjdCB3aGljaCBuZWVkcyB0byBoYXZlXG4gICAgICogbGl0dGxlIHRlbnQ7XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZENvbG9yRnJvbTogc3RyaW5nID0gJyNmM2YzZjMnO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0aGF0IGlzIHVzZWQgdG8gc2V0IGFmdGVyIHdlIGFyZSBpbiB0aGUgZnVsbCBzY3JlZW4gc28gb3VyIG92ZXJsYXkgZGl2IGhpZGUgZXZlcnl0aGluZ1xuICAgICAqIG9uIHRoZSBwYWdlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZENvbG9yVG86IHN0cmluZyA9ICcjRkZGRkZGJztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUYWJsZSBoZWFkaW5nIGFyZWEgb2ZmZXJzIGRldmVsb3BlciB0byBjb21wbGV0ZWx5IG92ZXJyaWRlIHRoZSB0b3AgYmFyIHdoZXJlIHdlIGhhdmUgZmlsdGVyc1xuICAgICAqIGFuZCBvdGhlcnMgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRpbmdBcmVhJylcbiAgICBoZWFkaW5nOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRhYmxlIGhlYWRlcnMgYW5kIHdyYXBzIHRoZW0gd2l0aGluIHRoZWFkIHRhZ1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlclJvd3MnKVxuICAgIGhlYWRlclJvd3M6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGFibGUgYm9keVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2JvZHlSb3dzJylcbiAgICBib2R5Um93czogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgaGVhZGluZyB0ZW1wbGF0ZS4gV2UgbmVlZCB0byByZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHByaW1lTkcgc28gZmFyIGl0IGlzIHVzaW5nXG4gICAgICogcC1mb290ZXJcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdmb290ZXJBcmVhJylcbiAgICBmb290ZXI6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIERpdiB1c2VkIHRvIG1ha2UgdGhlIGZ1bGwgc2NyZWVuIGV4cGFuc2lvbiBlZmZlY3RcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkdEZ1bGxTY3JlZW5PdmVybGF5JylcbiAgICBkdEZ1bGxTY3JlZW5PdmVybGF5OiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gaW5maXRlIHNjcm9sbC4gV2UgYXJlIHVzaW5nIHRoaXMgdG8gdHJpZ2dlciBsb2FkaW5nIGZpbmlzaCBldmVudCBzbyB3ZSBjYW5cbiAgICAgKiBoaWRlIGxvYWRpbmcgYW5pbWF0aW9uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaW5maW5pdGVTY3JvbGwnKVxuICAgIGluZmluaXRlU2Nyb2xsOiBJbmZpbml0ZVNjcm9sbENvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gZGVib3VuY2UgdGhlIHR5cGluZyB3ZSBuZWVkIHRvIHVzZSBzdWJqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hUZXJtcyA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuXG4gICAgLyoqXG4gICAgICogIFNwZWNpZmllcyBpZiB3ZSBhcmUgaW4gdmlld2luZy9lZGl0aW5nIG1vZGUgdGhhdCBjYW4gYnJvd3NlIHdob2xlIGRhdGFzZXQgbGF6aWx5XG4gICAgICpcbiAgICAgKi9cbiAgICBpc0Z1bGxTY3JlZW5Nb2RlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB3ZSBjYW4gc3VwcG9ydCBmdWxsIHNjcmVlbiBtb2RlIC0gb25seSBhdmFpbGFibGUgZm9yIHRoZSBicm93c2VyXG4gICAgICpcbiAgICAgKi9cbiAgICBzdXBwb3J0RnVsbFNjcmVlbjogYm9vbGVhbiA9IHRydWU7XG4gICAgcXVlcnlTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBsb2FkaW5nU3ViOiBTdWJzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogIFNhdmVzIG9yaWdpbmFsIGJvdW5kaW5nIHJlY3QgY29vcmRpbmF0ZXMgYmVmb3JlIHdlIGV4cGFuZCB0aGUgRFQgdG8gZnVsbCBzY3JlZW5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHRCb3VuZGluZ0NsaWVudFJlY3Q6IGFueTtcbiAgICAvKipcbiAgICAgKiBSZW1lbWJlcnMgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uIGJlZm9yZSB3ZSBzd2l0Y2ggdG8gZnVsbCBzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIHByaXZhdGUgb3JpZ2luYWxTY3JvbGxQb3NpdGlvbjogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRoaXNFbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgZG9tVXRpbHM6IERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICAgICAgICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YXRhYmxlMkNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHVibGljIGR0OiBEYXRhdGFibGUyQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5xdWVyeVN1YnNjcmlwdGlvbiA9IHRoaXMuc2VhcmNoVGVybXMucGlwZShcbiAgICAgICAgICAgIC8vIHdhaXQgMzAwbXMgYWZ0ZXIgZWFjaCBrZXlzdHJva2UgYmVmb3JlIGNvbnNpZGVyaW5nIHRoZSB0ZXJtXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMzAwKSxcblxuICAgICAgICAgICAgLy8gaWdub3JlIG5ldyB0ZXJtIGlmIHNhbWUgYXMgcHJldmlvdXMgdGVybVxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcblxuICAgICAgICAgICAgc3dpdGNoTWFwKCh0ZXJtOiBzdHJpbmcpID0+IG9mKHRlcm0pKVxuICAgICAgICApLnN1YnNjcmliZSgodGVybTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRlcm0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZpbmQodGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubG9hZGluZ1N1YiA9IHRoaXMuZHQudmFsdWVDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGRhdGE6IGFueSkgPT4gdGhpcy5sb2FkaW5nRmluaXNoZWQoKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb2x1bW5zIG1hcmtlZCBhcyBmcm96ZW4gYW5kIHJldHJpZXZlIGEgd2lkdGggc28gd2UgY2FuIHVwZGF0ZVxuICAgICAqIHBhcmVudCBkaXZcbiAgICAgKlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUZyb3plbldpZHRoKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmR0Lmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZldpZHRoID0gMDtcbiAgICAgICAgdGhpcy5kdC5mcm96ZW5Db2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoY29sLm1heFdpZHRoUHggPiAwKSB7XG4gICAgICAgICAgICAgICAgZldpZHRoICs9IGNvbC53aWRlc3RDZWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmV2lkdGggKz0gcGFyc2VJbnQoY29sLndpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZXaWR0aDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaGF2aW5nIHR3byBzZXBhcmF0ZSB0YWJsZXMgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCByb3dzIG9mIHRoZSB0YWJsZXMgYXJlIGFsaWduZWQuXG4gICAgICpcbiAgICAgKiBUaGVyZWZvcmUgdGhpcyBtZXRob2QgdGFrZXMgZmlyc3QgY29sdW1uIGZyb20gZWFjaCB0YWJsZSByZWFkIHRoZSBoZWlnaHQgb2YgdGhlIHJvd3MgYW5kIHNldFxuICAgICAqIHRoZSBtYXggaGVpZ2h0IHRvIGJvdGggcm93cy5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgYWxpZ25UYWJsZXNIZWlnaHRzKGZyb3plblZpZXc6IGFueSwgdW5Gcm96ZW5WaWV3OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KGZyb3plblZpZXcpICYmIGlzUHJlc2VudChmcm96ZW5WaWV3KSxcbiAgICAgICAgICAgICdDYW50IGFsaWduIHRhYmxlIHZpZXdzIGFzIG9uZSBvZiB0aGUgdmlldyBpcyB1bmRlZmluZWQnKTtcblxuICAgICAgICBsZXQgZnJvemVuUm93czogYW55W10gPSBmcm96ZW5WaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRyJyk7XG4gICAgICAgIGxldCB1bkZyb3plblJvd3M6IGFueVtdID0gdW5Gcm96ZW5WaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRyJyk7XG5cbiAgICAgICAgYXNzZXJ0KGZyb3plblJvd3MubGVuZ3RoID09PSB1bkZyb3plblJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgJ0Zyb3plbiBDb2x1bW46IFR3byB0YWJsZXMgZG9lcyBub3QgbXVjaCEnKTtcblxuICAgICAgICBBcnJheS5mcm9tKGZyb3plblJvd3MpLmZvckVhY2goKGZyb3plbjogYW55LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaCA9IE1hdGgubWF4KGZyb3plbi5vZmZzZXRIZWlnaHQsIHVuRnJvemVuUm93c1tpbmRleF0ub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZyb3plbi5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgICAgIHVuRnJvemVuUm93c1tpbmRleF0uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmluaXRGdWxsU2NyZWVuKCk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAodGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGxldCBmcm96ZW5WaWV3ID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LWZyb3plbicpO1xuICAgICAgICAgICAgbGV0IHVuRnJvemVuVmlldyA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtYm9keS11bmZyb3plbicpO1xuXG4gICAgICAgICAgICBsZXQgZnJvemVuV2lkdGggPSB0aGlzLmNhbGN1bGF0ZUZyb3plbldpZHRoKCk7XG5cbiAgICAgICAgICAgIGZyb3plblZpZXcuc3R5bGUud2lkdGggPSBmcm96ZW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHVuRnJvemVuVmlldykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGJvcmRlciBhbmQgY3JlYXRlIGluZGVudCBlZmZlY3QgYnkgaGF2aW5nIDFweCB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHVuRnJvemVuVmlldy5zdHlsZS5sZWZ0ID0gKGZyb3plbldpZHRoICsgMikgKyAncHgnO1xuICAgICAgICAgICAgICAgIHVuRnJvemVuVmlldy5zdHlsZS53aWR0aCA9IHVuRnJvemVuVmlldy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIC0gZnJvemVuVmlldy5vZmZzZXRXaWR0aCArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFsaWduVGFibGVzSGVpZ2h0cyhmcm96ZW5WaWV3LCB1bkZyb3plblZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucXVlcnlTdWJzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubG9hZGluZ1N1YikpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ1N1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGVUxMIFNDUkVFTiBNT0RFIG1ldGhvZHNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBmdWxsc2NyZWVuIGZ1bmN0aW9uYWxpdHkgaXMgZW5hYmxlZCB0aGlzIG1ldGhvZCBzd2l0Y2hlcyBiZXR3ZWVuIG5vcm1sIGFuZCBmdWxsIHNjcmVlblxuICAgICAqIG1vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUZ1bGxTY3JlZW4oZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzRnVsbFNjcmVlbk1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGdWxsU2NyZWVuKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkZ1bGxTY3JlZW4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcHVzaCB0aGlzIGNvbXBvbmVudCB0byBmdWxsIHNjcmVlbiBtb2RlIG9yIG1heWJlIGZ1bGwgcGFnZSBtb2RlIHdlIG5lZWQgcnVuIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqICAtIEV4ZWN1dGUgZXhwYW5kIHRyYW5zZm9ybWF0aW9uLCB3aGVyZSB3ZSBoYXZlIGFkZGl0aW9uYWwgb3ZlcmxheSBkaXYgdGhhdCB3ZSBzbG93bHkgZXhwYW5kXG4gICAgICogIGFuZCB0aGlzIGNyZWF0ZXMgaW1wcmVzc2lvbiB0aGUgRFQgaXMgZXhwYW5kaW5nXG4gICAgICpcbiAgICAgKiAgLSBhcHBseSBmdWxsLXNjcmVlbiBjbGFzcyBvbiB0b3AgaG9zdCBlbGVtZW50ICAtIGluIHRoaXMgY2FzZSBpdHMgRGF0YVRhYmxlIHRvIHN3aXRjaFxuICAgICAqICB0byBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAqXG4gICAgICogIC0gbWFrZSBzdXJlIHdlIGFyZSBzY3JvbGxlZCBhbGwgdGhlIHdheSB1cFxuICAgICAqXG4gICAgICogIC0gaGlkZSBhbGwgdGhlIGVsZW1lbnRzIG9uIHRoZSBwYWdlIHNvIHRoZWlyIGRpbWVuc2lvbiBkb24ndCBpbnRlcmZlcmUgd2l0aCB0aGlzIHRhYmxlLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuRnVsbFNjcmVlbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pc0Z1bGxTY3JlZW5Nb2RlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJ1bkV4cGFuZEVmZmVjdCgpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbk9uRFQodHJ1ZSk7XG5cblxuICAgICAgICAvLyBtYXJrIG15IGVsZW1lbnQgaW4gdGhlIHBhdGggdGhhdCBuZWVkcyB0byBzdGF5XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZS50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZCgndS1mdWxsLXNjcmVlbi1lbGVtZW50Jyk7XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZU5vbkZ1bGxTY3JlZW5FbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICAgIHRoaXMuZHQuc3RhdGUubGltaXQgPSBNYXRoLnJvdW5kKHRoaXMuY2FsY3VsYXRlTGltaXQoKSk7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LnN0YXRlKTtcblxuICAgICAgICAvLyBvbmNlIGxvYWRlZCBzZXQgYmFjayBjb3JyZWN0IHBhZ2Ugc2l6ZSB3ZSB1c2Ugd2hlbiBsb2FkaW5nIGRhdGFcbiAgICAgICAgdGhpcy5kdC5zdGF0ZS5saW1pdCA9IHRoaXMuZHQucGFnZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgc2FtZSBsaWtlIGFib3ZlIG1ldGhvZCAob3BlbkZ1bGxTY3JlZW4pIGJ1dCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VGdWxsU2NyZWVuKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmlzRnVsbFNjcmVlbk1vZGUgPSBmYWxzZTtcblxuICAgICAgICB0aGlzLnNob3dOb25GdWxsU2NyZWVuRWxlbWVudCgpO1xuICAgICAgICB0aGlzLnJ1bkNvbGxhcHNlRWZmZWN0KCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbk9uRFQoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5saW1pdCA9IHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5kaXNwbGF5TGltaXQ7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5vZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmV0Y2godGhpcy5kdC5kYXRhU291cmNlLnN0YXRlKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgdGhpcy5vcmlnaW5hbFNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHNldCBvZiBzZXQgb2YgY3NzIHByb3BlcnRpZXMgdG8gbWFrZSB0aGUgRFQgbWFpbiBjb21wb25lbnQgb24gdGhlIHBhZ2UgZXhwYW5kIHRvXG4gICAgICogZnVsbCBwYWdlIG1vZGUgYW5kIGJhY2tcbiAgICAgKlxuICAgICAqIFdlIHdhbnQgdG8gbWFrZSBpdCB3aXRoIGxpdHRsZSBkZWxheSB0byBsZXQgb3RoZXIgYW5pbWF0aW9uIGZpbmlzaFxuICAgICAqL1xuICAgIHRvZ2dsZUZ1bGxTY3JlZW5PbkRUKGZ1bGxTY3JlZW46IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0LmVsLm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmNsYXNzTGlzdCArPSAnZHQtZnVsbC1zY3JlZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmNsYXNzTGlzdCA9IHRoaXMuZHQuY2xhc3NMaXN0LnJlcGxhY2UoJ2R0LWZ1bGwtc2NyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgaW5maW5pdGUgc2Nyb2xsIGV2ZW50IGFuZCByZXF1ZXN0IG5ldyBkYXRhIGZyb20gZGF0YSBzb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTGF6eUxvYWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChldmVudC5pc0xvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHQuc3RhdGUub2Zmc2V0ID0gZXZlbnQub2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZldGNoKHRoaXMuZHQuc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRhdGFQcm92aWRlciA9IHRoaXMuZHQuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXI7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoZGF0YS5zbGljZSgwLCBldmVudC5vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5pbWF0aW9uIGVmZmVjdCB0byBtYWtlIGl0IGZlZWwgbGlrZSB0aGUgZWxlbWVudCAoaW4gdGhpcyBjYXNlIERUKSBpcyBleHBhbmRpbmdcbiAgICAgKiBmcm9tIHRoZSBtaWRkbGUgdG8gdGhlIGZ1bGwgcGFnZSBtb2RlLlxuICAgICAqXG4gICAgICogV2UgdGFrZSB0aGUgZGltZW5zaW9uIG9mIHRoZSB0YWJsZSB0aGVuIGl0IGlzIHNjYWxlZCBzbG93bHkgdG8gdGhlIGZ1bGwgcGFnZVxuICAgICAqL1xuICAgIHByaXZhdGUgcnVuRXhwYW5kRWZmZWN0KClcbiAgICB7XG4gICAgICAgIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZXhwYW5kQ29sb3JGcm9tO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5leHBhbmRDb2xvclRvO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIHRyYW5zZm9ybWF0aW9uIGFuZCBzY2FsZSB0aGUgaGVscGVyIGRpdiAob3ZlcmxheSkgZG93biB0byBtYWtlIGl0IGxvb2sgbGlrZVxuICAgICAqIGl0IGNvbGxhcHNlc1xuICAgICAqL1xuICAgIHByaXZhdGUgcnVuQ29sbGFwc2VFZmZlY3QoKVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbihmYWxzZSk7XG5cblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgfSwgMjAwKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCh0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQsIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9LCA0MDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERGUyAgLSB0byBnbyB0aHJ1IGFsbCB0aGUgZWxlbWVudCB1bmRlciBCT0RZIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBoaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQocGFyZW50RWxlbWVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlID09PSBwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRUcmF2ZXJzZURvd24oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVOb25GdWxsU2NyZWVuRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2R0LWZ1bGwtc2NyZWVuJykpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3UtZnMtZWxlbWVudC1vdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1dCBhbGwgdGhlIGVsZW1lbnQgdGhhdCB3ZXJlIHByZXZpb3VzbHkgcmVtb3ZlZCBieSBoaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQoKSBiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93Tm9uRnVsbFNjcmVlbkVsZW1lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudS1mcy1lbGVtZW50LW91dCcpKVxuICAgICAgICAgICAgLmZvckVhY2goKGVsZW06IGFueSkgPT4gZWxlbS5jbGFzc0xpc3QucmVtb3ZlKCd1LWZzLWVsZW1lbnQtb3V0JykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBJbnRlcm5hbFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBuZWVkVHJhdmVyc2VEb3duKGVsZW1lbnQ6IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoZWxlbWVudCkgJiYgZWxlbWVudC50YWdOYW1lICE9PSAnU0NSSVBUJyAmJlxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3UtZnVsbC1zY3JlZW4tZWxlbWVudCcpICYmXG4gICAgICAgICAgICAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2R0LWZ1bGwtc2NyZWVuJyk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGVudGVyIGZ1bGwgc2NyZWVuIC9wYWdlIG1vZGUgd2hlbiBuZWVkIHRvIGNhbGN1bGF0ZSBob3cgbWFueSByb3dzIHRvIGxvYWQgaW5pdGlhbGx5XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGN1bGF0ZUxpbWl0KCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IGJyb3dzZXJIID0gdGhpcy5kb21VdGlscy5icm93c2VyRGltZW50aW9ucygpLmhlaWdodDtcbiAgICAgICAgbGV0IHJvd0ggPSB0aGlzLmR0LmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHkgdHI6Zmlyc3QtY2hpbGQnKS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQocm93SCkgJiYgcm93SCA+IDApID8gKGJyb3dzZXJIIC8gcm93SCkgKyAyMCA6IDUwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBJbnRlcm5hbFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVFbGVtZW50KGw6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHc6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGg6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGwgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSB0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGx5VHJhbnNmb3JtYXRpb24oZXhwYW5kOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHgsIHksIHR4LCB0eTtcbiAgICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICAgICAgeCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aDtcbiAgICAgICAgICAgIHkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHR4ID0gKHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGggLyAyXG4gICAgICAgICAgICAgICAgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQpIC8geDtcbiAgICAgICAgICAgIHR5ID0gKHdpbmRvdy5pbm5lckhlaWdodCAvIDIgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAvIDJcbiAgICAgICAgICAgICAgICAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wKSAvIHk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSAxO1xuICAgICAgICAgICAgeSA9IDE7XG4gICAgICAgICAgICB0eCA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIHR5ID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAgICAgJ3NjYWxlWCgnICsgeCArICcpIHNjYWxlWSgnICsgeSArICcpIHRyYW5zbGF0ZTNkKCcgKyAodHgpICsgJ3B4LCAnICsgKHR5KSArICdweCwgMHB4KSc7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJTkZJTklURSBTQ1JPTExJTkcgTUVUSE9EU1xuICAgICAqL1xuXG4gICAgcHJpdmF0ZSBpbml0RnVsbFNjcmVlbigpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydEZ1bGxTY3JlZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVuZGVyLmFwcGVuZENoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGxvYWRpbmcgaXMgZmluaXNoZWQgbWFyayBsb2FkaW5nIGljb24gaXMgZG9uZSBzbyB3ZSBjYW4gaGlkZSBpdC4gSSBhbSB1c2luZyBsaXR0bGVcbiAgICAgKiBkZWxheSB0byBtYWtlIHRoZSBhbmltYXRpb24gdmlzaWJsZVxuICAgICAqL1xuICAgIHByaXZhdGUgbG9hZGluZ0ZpbmlzaGVkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pbmZpbml0ZVNjcm9sbCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5pbmZpbml0ZVNjcm9sbC5jb21wbGV0ZSgpLCAyMDApO1xuXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQge0FmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uSW5pdCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIHJlc3BvbnNpYmxlIGZvciBjaGVja2luZyBhbmQgc2V0dGluZyB0aGUgd2lkZXN0IGNvbnRlbnQgd2lkdGggb250b1xuICogQ29sdW1uIGNvbXBvbmVudCBhcyB0aGUgd2lkZXN0Q2VsbCBwcm9wZXJ0eS5cbiAqXG4gKiBXZSB1c2UgdGhpcyBkaXJlY3RpdmUgaW5zaWRlIGR0LWNvbHVtbi5jb21wb25lbnQgdG8gc3RvcmUgYSBjdXJyZW50IHdpZHRoIGZvciBlYWNoIHRkLHRoXG4gKlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZHRNYXhXaWR0aF0nXG59KVxuZXhwb3J0IGNsYXNzIFNldENlbGxNYXhXaWR0aERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdFxue1xuXG4gICAgQElucHV0KClcbiAgICBkdE1heFdpZHRoOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgICBwcml2YXRlIHRkOiBEVENvbHVtbjJDb21wb25lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcblxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ2VsbCBNYXggV2lkdGg6ICcgKyB0aGlzLmR0TWF4V2lkdGgsIHRoaXMuZHRNYXhXaWR0aCA+IDApO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHRNYXhXaWR0aCkgJiYgdGhpcy5kdE1heFdpZHRoID4gMCkge1xuICAgICAgICAgICAgbGV0IGlubGluZURhdGEgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtY29sLWNlbGwtZGF0YScpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpbmxpbmVEYXRhKSkge1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBpbmxpbmVEYXRhLm9mZnNldFdpZHRoOyAvLyB0ZFxuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5UaHJlc0hvbGQoY2VsbFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICs9IHRoaXMudGRQYWRkaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxXaWR0aCA+IHRoaXMudGQud2lkdGhQeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbFdpZHRoIDwgdGhpcy5kdE1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRkLndpZGVzdENlbGwgPSBjZWxsV2lkdGggPiB0aGlzLnRkLndpZGVzdENlbGwgPyBjZWxsV2lkdGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbDtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNlbGxXaWR0aCA+PSB0aGlzLmR0TWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbCA9ICh0aGlzLmR0TWF4V2lkdGggPiB0aGlzLnRkLndpZGVzdENlbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmR0TWF4V2lkdGggOiB0aGlzLnRkLndpZGVzdENlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIHRoZSBuZXcgd2lkdGggdGhlIHNhbWUgYXMgdGhlIG9uZSBhbHJlYWR5IHNldCBvbiB0aGUgY29sdW1uPyBJZiB5ZXMgdGhlbiBwcm9iYWJseVxuICAgICAqIG5ldyBjb250ZW50IGRvZXMgbm90IGRpZmZlciB0aGF0IG11Y2guIFdlIHN0aWxsIGtlZXAgY2VydGFpbiB0aHJlc2hvbGQgYXMgdGhlIG5ldyBjb250ZW50XG4gICAgICogd2lkdGggbWlnaHQgZGlmZmVyIDEgb3IgMiBwaXhlcyBkZXBlbmRpbmcgaG93IHNldCB0aGUgY3NzLlxuICAgICAqXG4gICAgICogVG8gbWFrZSBzdXJlIHdlIHJlc2l6ZSBjb2x1bW4gb25seSBpZiBuZWNlc3NhcnkgYmVjYXVzZSBpdCBjb3VsZCBiZSBvcmlnaW5hbCBzaXplXG4gICAgICogaXMgNDAwcHggYnV0IHRoZSBuZXcgb25lIGlzIDQwMXB4IHNpbmNlIHNvbWV3aGVyZSBhZGQgc29tZSBleHRyYSBib3JkZXIgd2UgaGF2ZSB0aGlzXG4gICAgICogc2FmZSB0aHJlc2hvbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW5UaHJlc0hvbGQobmV3V2lkdGg6IG51bWJlcik6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnRkLndpZGVzdENlbGwgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy50ZC53aWRlc3RDZWxsIC0gbmV3V2lkdGgpID4gMyAmJiBuZXdXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdGRQYWRkaW5nKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgbGV0IGNlbGwgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0KSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0KSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCkgfHwgMDtcbiAgICAgICAgY2VsbCArPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCkgfHwgMDtcblxuICAgICAgICAvLyBwbHVzIGdpdmUgaXQgc29tZSBsaXR0bGUgc3BhY2UgYXJvdW5kIHRoZSB0ZXh0IHNvIGl0IG5vdHMgcHggdG8gcHggaW5uZXIgd2lkdGggb2YgdGhlIHRkXG4gICAgICAgIC8vIGN1eiBpdCBjb3VsZCB3cmFwXG4gICAgICAgIGNlbGwgKz0gNTtcblxuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cblxuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LFxuICAgIE9uSW5pdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEcmFnRGlyZWN0aW9uLCBEcmFnRXZlbnRzLCBEcm9wUG9zaXRpb259IGZyb20gJy4uL2F3LWRhdGF0YWJsZSc7XG5cblxuLyoqXG4gKiBEaXJlY3RpdmUgdXNlZCBpbnNpZGUgRFQgaW4gb3JkZXIgdG8gc3VwcG9ydCB0YWJsZSByb3dzIHJlLW9yZGVyaW5nLiBUaGlzIG1hbmFnZXMgYWxsIHRoZVxuICogRCZEIG5lY2Vzc2FyeSBsb2dpYyBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFtkdERyYWdnYWJsZVJvd10gaXMgdXNlZCBpbnNpZGUgdGhlIGByb3dUZW1wbGF0ZWAgbGlrZSB0aGlzOlxuICpcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogPG5nLXRlbXBsYXRlICNyb3dUZW1wbGF0ZSBsZXQtcm93RGF0YSBsZXQtZXZlbj0nZXZlbnRcIiBsZXQtb2RkPVwib2RkXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIlxuICogICAgICAgICAgICAgIGxldC1uZXN0aW5nTGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIiBsZXQtY29sc1RvUmVuZGVyPVwiY29sc1RvUmVuZGVyXCI+XG4gKlxuICogICAgIDx0ciAjcm93RWxlbWVudCBkdERyYWdnYWJsZVJvdyBbZG5kUm93SW5kZXhdPVwicm93SW5kZXhcIlxuICogICAgICAgICAgY2xhc3M9XCJkdC1ib2R5LXJvd1wiXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiB3aGljaCBlbmFibGVkIG9yIGRpc2FibGVzIGJhc2VkIG9uIHRoZSB1c2VkIERUIGJpbmRpbmcgW2RuZFJvd0VuYWJsZWRdLiBCeSBkZWZhdWx0IGl0cyBkaXNhYmxlZC5cbiAqXG4gKlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZHREcmFnZ2FibGVSb3ddJ1xufSlcbmV4cG9ydCBjbGFzcyBEVERyYWdnYWJsZVJvd0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95XG57XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHRoZSBkaXJlY3RpdmUgaWYgd2UgZW5hYmxlIG1pZGRsZSByb3cgem9uZSB0byBjcmVhdGUgYW4gZWZmZWN0IHRoYXQgd2UgYXJlIGRyb3BwaW5nXG4gICAgICogaW50byB0aGUgcm93LiBVc2VkIGZvciBvdXRsaW5lIERUIG1haW5seS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZHJvcEludG9FbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IFRSIGluZGV4IG51bWJlclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkbmRSb3dJbmRleDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IG91ciBkcmFnZ2luZyBkaXJlY3Rpb24gVVAgYW5kIERPV04gaW4gb3JkZXIgdG8gYXNzaWduIGNvcnJlY3Qgc3R5bGVcbiAgICAgKiB0aGF0IGhpZ2hsaWdodHMgdGhlIHJvdyBhdCB0aGUgdG9wIG9yIGJvdHRvbVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnRGlyOiBEcmFnRGlyZWN0aW9uID0gRHJhZ0RpcmVjdGlvbi5Ob25lO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgd2UgZHJhZ2dlZCBvdXIgcm93IGFuZCBzdG9wcGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIG90aGVyIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbk1pZGRsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDdXJyZW50IGRyYWcgWSBjb29yZGluYXRlcyB3aGljaCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggdGhlIGRyYWdEaXIgd2hlbiBhc3NpbmdpbmcgZHJhZ2dpbmdcbiAgICAgKiBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRyYWdZOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogbGlzdGVuZXJzIGhhbmRsZXJzIGhlcmUgLSB0aGUgcmV0dXJuIGZyb20gLmJpbmQodGhpcykuXG4gICAgICovXG4gICAgcHJpdmF0ZSBldmVudEhhbmRsZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YXRhYmxlMkNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkdDogRGF0YXRhYmxlMkNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRvbVV0aWxzOiBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSlcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5kbmRSb3dFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZHQuZG5kUm93RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBsaXN0ZW5lcnMgYW5kIHJldHVybnMgaGFuZGxlIHRvIHRoZW0gc28gd2UgY2FuIGxhdGVyIG9uIHVuc3Vic2NyaWJlLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0dXBFdmVudExpc3RlbmVycygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snbW91c2Vkb3duJ10gPSB0aGlzLm9uTW91c2VEb3duRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydtb3VzZWRvd24nXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ3N0YXJ0J10gPSB0aGlzLm9uRHJhZ1N0YXJ0RXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnc3RhcnQnXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ292ZXInXSA9IHRoaXMub25EcmFnT3ZlckV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnb3ZlciddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnbGVhdmUnXSA9IHRoaXMub25EcmFnTGVhdmVFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2xlYXZlJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdsZWF2ZSddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcm9wJ10gPSB0aGlzLm9uRHJvcEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2Ryb3AnXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2VuZCddID0gdGhpcy5vbkRyYWdFbmRFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnZW5kJ10pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgY3JlYXRlZCBsaXN0ZW5lcnMgaW5zaWRlIGRlc3Ryb3koKSBjYWxsYmFja1xuICAgICAqL1xuICAgIHByaXZhdGUgcmVsZWFzZUV2ZW50TGlzdGVuZXJzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIERyYWdFdmVudHMuZm9yRWFjaCgobmFtZTogc3RyaW5nKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCduYW1lJywgdGhpcy5ldmVudEhhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZmlyc3QgZXZlbnQgd2hlcmUgd2U6XG4gICAgICpcbiAgICAgKiAgLSBNYXJrIGVsZW1lbnQgZHJhZ2dhYmxlIHRvIGVuYWJsZSBEJkRcbiAgICAgKiAgLSBTZXQgY2xpY2sgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgY3VycmVudCByb3dcbiAgICAgKiAgICAgIFRoaXMgaXMgbWFpbmx5IG5lZWRlZCB3aGVuIHdlIGFyZSB0cnlpbmcgdG8gY2FsY3VsYXRlIHNvbWV0aGluZyBmb3JcbiAgICAgKiAgICAgIGRyb3BJbnRvIHJvdyAob3V0bGluZSlcbiAgICAgKlxuICAgICAqIGV2ZW50LnRhcmdldCB1c3VhbGx5IGNvbnRhaW5zIHJlZmVyZW5jZSB0byBURCBlbGVtZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBvbk1vdXNlRG93bkV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIHRoaXMuZG9tVXRpbHMuaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgJy5kdC1yb3ctZHJhZ2dhYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZWxUb0JlRHJhZ2dlZCA9IHRoaXMuZG9tVXRpbHMuZWxlbWVudERpbWVuc2lvbnMoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuZHQuZW52LnNldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnLCAoZWxUb0JlRHJhZ2dlZC5oZWlnaHQgLyAyKSAtIGV2ZW50Lm9mZnNldFkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZWNvbmQgdHJpZ2dlcmVkIGV2ZW50IHdoZW4gdGhlIGFjdHVhbCBkcmFnZ2luZyBzdGFydHMuIEhlcmUgd2UgbmVlZCB0byBkaXNhYmxlXG4gICAgICogZHJhZ2dlZCByb3cgYW5kIHNhdmUgaW5mb3JtYXRpb24gdGhhdCBhcmUgY29tbW9uIHRvIGEgdGFibGUuXG4gICAgICpcbiAgICAgKiBNYXJraW5nIHJvdyBkaXNhYmxlZCB3aXRoIHRoZSBzdHlsZSAuZHQtcm93LWRyYWdnaW5nIHVzaW5nIHNldFRpbWVvdXQgaXMgbmVlZGVkIGFzXG4gICAgICogaWYgd2Ugd291bGQgZ28gd2l0aG91dCBpdCB0aGVuIEQmRCBmcmFtZXdvcmsgd291bGQgY3JlYXRlIGEgY29weSBvZiByb3cgaW4gZGlzYWJsZWQgc3RhdGUuXG4gICAgICogTm93IHdlIGdyYWIgYSByb3cgd2l0aCBhY3RpdmUgc3RhdGUgYW5kIGFmdGVyIGEgMjAwbXMgZGVsYXkgd2UgZGlzYWJsZSB0aGUgb3JpZ2luYWwgcm93LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdTdGFydEV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LmFkZCgnZHQtcm93LWRyYWdnaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG5cbiAgICAgICAgdGhpcy5kdC5lbnYuc2V0VmFsdWUoJ2lzRHJhZ2dpbmcnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuc2V0VmFsdWUoJ2RuZElkJywgdGhpcy5kbmRSb3dJbmRleCk7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5zZXREYXRhKCd0ZXh0JywgdGhpcy5kbmRSb3dJbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50cyBoYXBwZW5zIGFueXRpbWUgYXMgd2UgZHJhZyBvdmVyIHJvd3MuIFRoaXMgZXZlbnQgdHJpZ2dlcmVkIGFmdGVyIGNlcnRhaW5cbiAgICAgKiBkZWxheS4gSW4gaGVyZSB3ZSBjYWxjdWxhdGUgdGhlIG1vdXNlIG1vdmVtZW50IHRvIGlkZW50aWZ5IGlmIHdlIGFyZSBnb2luZyBVUCBvciBET1dOLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBtYWlubHkgbmVlZGVkIHRvIG1hcmsgYSByb3cgd2l0aCB0aGUgY29ycmVjdCBsaW5lIG9uIFRPUCBvciBCT1RUT00gdG8gdmlzdWFsbHlcbiAgICAgKiBzaG93IGEgdXNlciB3aGVyZSB3ZSBhcmUuXG4gICAgICpcbiAgICAgKiBPbmNlIHdlIGtub3cgdGhlIGRpcmVjdGlvbiBhbmQgdGhlIGRyb3AgdGFyZ2V0IGlzIHZhbGlkIHdlIG1hcmsgdGhlIHJvdyB3aXRoIGNvcnJlY3QgY2xhc3NcbiAgICAgKiB0aGF0IGRvZXMgdGhlIHRyaWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdPdmVyRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgICAgICBpZiAodGhpcy5kcmFnWSA8IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLkRvd247XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnWSA+IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLlVwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbnQgc2V0IGFnYWluIHVubGVzcyBpdHMgZGlmZmVyZW50XG4gICAgICAgIGlmICh0aGlzLmRyYWdZICE9PSBldmVudC5wYWdlWSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERyb3BUYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0b2RvIHRlc3QgdGhpcyBwcmV2ZW50RGVmYXVsdCgpIHNvIGl0IGRvZXMgbm90IGNyZWF0ZSBzb21lIHNpZGVlZmZlY3RcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtSb3dXaXRoQ2xhc3MoZXZlbnQsIHRoaXMuZG9tVXRpbHMuY2xvc2VzdChldmVudC50YXJnZXQsICd0cicpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZmluaXNoaW5nIGV2ZW50IGp1c3QgYmVmb3JlIEQmRCBpcyBkb25lLiBJdCB0YWtlcyBjdXJyZW50IGluZm9ybWF0aW9uIGFuZFxuICAgICAqIGJyb2FkY2FzdCB0aGVtIHRvIHRoZSBEVCBzbyBEVCBjYW4gZG8gbmVjZXNzYXJ5IHJvdyByZW9yZGVyaW5nXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25Ecm9wRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBsZXQgb3JpZ0luZHggPSB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgbGV0IGRyb3BQb3M6IERyb3BQb3NpdGlvbiA9IHRoaXMuaW5NaWRkbGUgPyBEcm9wUG9zaXRpb24uSW50byA6IChcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5VcCA/IERyb3BQb3NpdGlvbi5CZWZvcmUgOiBEcm9wUG9zaXRpb24uQWZ0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kdC5vbkRuRFJvd0Ryb3Aob3JpZ0luZHgsIHRoaXMuZG5kUm93SW5kZXgsIGRyb3BQb3MpO1xuXG4gICAgICAgIHRoaXMuaW5NaWRkbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnWSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlcnkgdGltZSB3ZSBkcmFnIG92ZXIgdGhlIGVsZW1lbnQgd2UgYXBwbHkgc29tZSBjbGFzc2VzIHRvIHRoZSBpdC4gdGhpcyBtZXRob2QgZG9lcyB0aGVcbiAgICAgKiBvcHBvc2l0ZSB3aGljaCBpcyB0byByZW1vdmUgZXZlcnl0aGluZyBzbyB3ZSBhcmUgcmVhZHkgZm9yIHRoZSBuZXh0IHJvd1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ0xlYXZlRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB0ciA9IHRoaXMuZG9tVXRpbHMuY2xvc2VzdChldmVudC50YXJnZXQsICd0cicpO1xuICAgICAgICB0aGlzLmNsZWFyQ2xhc3Nlcyh0cik7XG5cbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RuZE9uSG9sZEluZGV4Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGxhc3QgZXZlbnQgd2l0aGluIEQmRCBmbG93LiBNYWlubHkgdXNlZCB0byBjbGVhbiB1cCBhbGwgdGhlIHJlc291cmNlIHRoYXQgaGFzIG5vdFxuICAgICAqIGJlZW4gY2xlYW4gdXAgYWxyZWFkeSBpbnNpZGUgb25Ecm9wRXZlbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ0VuZEV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGV2ZW50LnRhcmdldC5jbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHQtcm93LWRyYWdnaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyQ2xhc3NlcyhldmVudC50YXJnZXQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2lzRHJhZ2dpbmcnKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIHRoaXMuZHQuZW52LmRlbGV0ZVZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBDU1MgY2xhc3NlcyB0byB0aGUgcm93IHRvIGNyZWF0ZSBhbiBoaWdobGlnaHRpbmcgZWZmZWN0IHRvIGNhcHR1cmUgY3VycmVudCBwb3NpdGlvblxuICAgICAqIGZvciB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEJhc2VkIG9uIHRoZSBEcmFnIGRpcmVjdGlvbiB3ZSBlaXRoZXIgYXBwbHlcbiAgICAgKiBjc3MgY2xhc3MgdGhhdCBjcmVhdGVzIGEgbGluZSBvbiB0b3Agb3IgYm90dG9tLiAgT25seSBmb3IgdGhlIGRyb3BJbnRvIGZ1bmN0aW9uYWxpdHkgd2VcbiAgICAgKiBuZWVkIHRvIGNhbGN1bGF0ZSBzb21lIG1vcmUgdG8gaWRlbnRpZnkgaWYgd2UgYXJlIHJlYWxseSBpbiB0aGUgbWlkZGxlIG9mIHRoZSByb3cuXG4gICAgICpcbiAgICAgKiBEcm9wSW50bzpcbiAgICAgKiAtLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIEluaXRpYWxseSB3ZSBjYXB0dXJlZCBhIHBvc2l0aW9uIChpbiBtb3VzZWRvd24pIHRoZSBkaXN0YW5jZSB0byB0aGUgbWlkZGxlIG9mIHRoZSByb3cgYW5kXG4gICAgICogdGhpcyB3ZSBhcmUgdXNpbmcgaGVyZSB3aXRoIHNvbWUgdGhyZXNob2xkIG9mIDIgcGl4ZXMgc28gd2UgZG9udCBoYXZlIHRvIGJlIGV4YWN0bHkgb24gcGl4ZWxcbiAgICAgKiBwZXJmZWN0LlxuICAgICAqXG4gICAgICogLSBsZXQgY3VycmVudFRyQ2VudGVyID0gdGhpcy5kb21VdGlscy5lbGVtZW50RGltZW5zaW9ucyhhY3RpdmVSb3cpLmhlaWdodCAvIDI7XG4gICAgICogICAgICBSZWFkIGNlbnRlciBvZiBjdXJyZW50IHJvd1xuICAgICAqXG4gICAgICogLSBsZXQgZHJhZ2dlZFRyQ2VudGVyID0gZXZlbnQub2Zmc2V0WSArIHRoaXMuZHQuZW52LmdldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcbiAgICAgKiAgICAgIFJlYWQgbW91c2UgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY3VycmVudCByb3cvdGQgYW5kIGFkZCB0byBpdCBvdXIgZGV2aWF0aW9uLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hcmtSb3dXaXRoQ2xhc3MoZXZlbnQ6IGFueSwgYWN0aXZlUm93OiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGFjdGl2ZVJvdyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZHJhZyBpdGVtIGlzIGluIHRoZSBtaWRkbGUgb2Ygb3RoZXIgcm93XG4gICAgICAgIGxldCBjdXJyZW50VHJDZW50ZXIgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGFjdGl2ZVJvdykuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGV0IGRyYWdnZWRUckNlbnRlciA9IGV2ZW50Lm9mZnNldFkgKyB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZGRDbGlja0RldmlhbmNlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJvcEludG9FbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluTWlkZGxlID0gTWF0aC5hYnMoY3VycmVudFRyQ2VudGVyIC0gZHJhZ2dlZFRyQ2VudGVyKSA8IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbk1pZGRsZSkge1xuICAgICAgICAgICAgYWN0aXZlUm93LmNsYXNzTGlzdC5hZGQoRHJhZ0RpcmVjdGlvbi5NaWRkbGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVSb3cuY2xhc3NMaXN0LmFkZCh0aGlzLmRyYWdEaXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEcm9wIHRhcmdldCBtdXN0IGJlIG9ubHkgYW5vdGhlciBUUiBhbmQgaXQgY2Fubm90IGJlIHRoZSBlbGVtZW50IGl0c2VsZiB0aGUgb25lIHdlIGFyZVxuICAgICAqIGRyYWdnaW5nIGFuZCBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIGFsbG93IHRvIGRyb3AgdG8gdGhlIHNhbWUgcG9zaXRpb24gd2Ugc3RhcnRlZCBmcm9tXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzVmFsaWREcm9wVGFyZ2V0KGV2ZW50OiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgb3JpZ0lueCA9IHRoaXMuZHQuZW52LmdldFZhbHVlKCdkbmRJZCcpO1xuICAgICAgICBsZXQgc2libGluZ1JvdyA9IHRoaXMuZG5kUm93SW5kZXggLSBvcmlnSW54O1xuXG4gICAgICAgIHJldHVybiBldmVudC50YXJnZXQucGFyZW50RWxlbWVudC50YWdOYW1lID09PSAnVFInICYmIHRoaXMuZG5kUm93SW5kZXggIT09IG9yaWdJbnggJiZcbiAgICAgICAgICAgICEoc2libGluZ1JvdyA9PT0gMSAmJiB0aGlzLmRyYWdEaXIgPT09IERyYWdEaXJlY3Rpb24uVXApICYmXG4gICAgICAgICAgICAhKHNpYmxpbmdSb3cgPT09IC0xICYmIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5Eb3duKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBwcml2YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNsZWFyQ2xhc3Nlcyh0cjogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdHIuY2xhc3NMaXN0LnJlbW92ZSgnZHQtZHJhZy1yb3ctdG9wJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5yZW1vdmUoJ2R0LWRyYWctcm93LWJvdHRvbScpO1xuICAgICAgICB0ci5jbGFzc0xpc3QucmVtb3ZlKCdkdC1kcmFnLXJvdy1ib3RoJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHJhZ0RpclRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmRyYWdEaXIpIHtcbiAgICAgICAgICAgIGNhc2UgRHJhZ0RpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VwJztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0RpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiAnRG93bic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnTm90IFN1cmUnO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV091dGxpbmVGb3JNb2R1bGV9IGZyb20gJy4uL291dGxpbmUvb3V0bGluZS1mb3IubW9kdWxlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUV3JhcHBlcn0gZnJvbSAnLi90YWJsZS13cmFwcGVyL3RhYmxlLXdyYXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdJbnB1dEZpZWxkTW9kdWxlfSBmcm9tICcuLi9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUnO1xuaW1wb3J0IHtEVEhlYWRlckNvbXBvbmVudDJ9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy1leHBhbmRlci9kdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vbXVsdGktc2VsZWN0L2R0LW11bHRpLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveE1vZHVsZX0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5pbXBvcnQge1xuICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL3NpbmdsZS1zZWxlY3QvZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9kdC1jZWxsLWRpcmVjdGl2ZXMnO1xuaW1wb3J0IHtEVERyYWdnYWJsZVJvd0RpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEYXRhdGFibGUyQ29tcG9uZW50LFxuICAgICAgICBEVFdyYXBwZXIsXG4gICAgICAgIERUQ29sdW1uMkNvbXBvbmVudCxcbiAgICAgICAgRFRIZWFkZXJDb21wb25lbnQyLFxuICAgICAgICBEVERldGFpbFJvd0NvbXBvbmVudCxcbiAgICAgICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCxcbiAgICAgICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIERURHJhZ2dhYmxlUm93RGlyZWN0aXZlLFxuICAgICAgICBTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQsXG4gICAgICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERhdGF0YWJsZTJDb21wb25lbnQsXG4gICAgICAgIERUQ29sdW1uMkNvbXBvbmVudCxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBEVEhlYWRlckNvbXBvbmVudDIsXG4gICAgICAgIERURGV0YWlsUm93Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXRGF0YXRhYmxlMk1vZHVsZVxue1xufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gY29uZmlybWF0aW9uIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29uZmlybWF0aW9uQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24taGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBjb25maXJtYXRpb24gaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBDb25maXJtYXRpb25Db21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbi1mb290ZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7Q29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBDb25maXJtYXRpb24gQ29tcG9uZW50IGlzIGEgc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGUgZGlhbG9nIHdoZXJlIGl0IHN1cHBvcnRzIGNvbmZpcm0gYW5kIGNhbmNlbFxuICogZnVuY3Rpb25hbGl0eS4gSXQgYmVoYXZlcyBsaWtlIGEgZGlhbG9nLCBpcyBtb2RhbCwgYW5kIG5vdCBjbG9zYWJsZSBieSBkZWZhdWx0LlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBwb3B1cC5cbiAqICAgMS4gIGEgcmVndWxhciBkaWFsb2cgYm94IHRoYXQgaGFzIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyLiBJdCdzIHRoZSBtb3N0IGN1c3RvbWl6YWJsZS5cbiAqICAgMi4gIGEgY29uZmlybWF0aW9uIGJveCBpcyBzaW1pbGFyIHRvIGEgZGlhbG9nIGJveCBidXQgaGFzIGFjY2VwdCBhbmQgcmVqZWN0IGFjdGlvbiBidXR0b25zLlxuICogICAzLiAgYSBvdmVybGF5LCB3aGljaCBpcyBhIHZlcnkgYmFzaWMgcG9wdXAgd2l0aCB3aGF0IHlvdSBwdXQgaW5zaWRlLlxuICogICAgICAgSXQgZG9lc24ndCBoYXZlIGhlYWRlciBhbmQgZm9vdGVyLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgYW55IHBvcHVwIGNvbXBvbmVudC5cbiAqICAgMS4gIEVpdGhlciBkaXJlY3RseSBieSB1c2luZyBjb21wb25lbnQsIGF3LWRpYWxvZywgYXctY29uZmlybWF0aW9uIG9yIGF3LW92ZXJsYXlcbiAqICAgMi4gIG9yIHRoZSBNb2RhbFNlcnZpY2UgIHNlcnZpY2Uub3Blbig8Q29uZmlybWF0aW9uQ29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIE1vZGFsU2VydmljZSBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoaXMgdXNhZ2UgaXMgYSBxdWljayB3YXkgdG8gc2hvd1xuICogICAgICAgIGEgY29uZmlybWF0aW9uIHRvIHRoZSB1c2VyLlxuICpcbiAqICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48Q29uZmlybWF0aW9uQ29tcG9uZW50PihDb25maXJtYXRpb25Db21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDb25maXJtYXRpb24nLFxuICogICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgIEFyZSB5b3Ugc3VyZSA/IGAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzMDAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29uZmlybTogKCkgPT4ge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24oKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6ICgpID0+IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb24oKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWNvbmZpcm1hdGlvbiBbdGl0bGVdPVwiJ0NvbmZpcm1hdGlvbidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsodmlzaWJsZSldPVwiZGlzcGxheVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25Db25maXJtKT1cImNvbmZpcm1BY3Rpb24oKVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNhbmNlbCk9XCJjYW5jZWxBY3Rpb24oKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cInNhcC1pY29uIGljb24tYWxlcnRcIj48L2k+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgeW91ciBoYXJkIGRyaXZlP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1jb25maXJtYXRpb24+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIChjbGljayk9XCJvcGVuKClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BlbiBDb25maXJtYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1BY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW4oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gKiAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1BY3Rpb24oKSAge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24gPSBcImNvbmZpcm1lZFwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gZmFsc2U7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbiA9IFwiY2FuY2VsZWRcIjtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24nLFxuICAgIHRlbXBsYXRlOiBgPGF3LWRpYWxvZyBbdGl0bGVdPVwidGl0bGVcIiBbKHZpc2libGUpXT1cInZpc2libGVcIlxuICAgICAgICAgICBbbW9kYWxdPVwidHJ1ZVwiIFtjbG9zYWJsZV09XCJjbG9zYWJsZVwiIFt3aWR0aF09XCJ3aWR0aFwiIFtoZWlnaHRdPVwiaGVpZ2h0XCJcbiAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFthcHBlbmRUb109XCJhcHBlbmRUb1wiIChvbk9wZW4pPVwib3BlbigpXCIgKG9uQ2xvc2UpPVwiY2xvc2UoKVwiPlxuXG4gICAgPGF3LWRpYWxvZy1oZWFkZXIgKm5nSWY9XCJoYXNIZWFkZXIoKVwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jb25maXJtYXRpb24taGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvYXctZGlhbG9nLWhlYWRlcj5cblxuICAgIHt7Ym9keX19XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG5cbiAgICA8YXctZGlhbG9nLWZvb3RlciAqbmdJZj1cImhhc0Zvb3RlcigpOyBlbHNlIGRlZmF1bHRGb290ZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY29uZmlybWF0aW9uLWZvb3RlclwiPjwvbmctY29udGVudD5cbiAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG5cbiAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRGb290ZXI+XG4gICAgICAgIDxhdy1kaWFsb2ctZm9vdGVyPlxuICAgICAgICAgICAgPGF3LWJ1dHRvbiBuYW1lPVwiY29uZmlybVwiIFtzdHlsZV09XCIncHJpbWFyeSdcIiAoYWN0aW9uKT1cImNvbmZpcm0oKVwiPlxuICAgICAgICAgICAgICAgIHt7Y29uZmlybUFjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uIG5hbWU9XCJjYW5jZWxcIiBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIiAoYWN0aW9uKT1cImNhbmNlbCgpXCI+XG4gICAgICAgICAgICAgICAge3tjYW5jZWxBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuICAgICAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuPC9hdy1kaWFsb2c+XG5gLFxuICAgIHN0eWxlczogW2AuY29uZmlybWF0aW9uLWZvb3Rlci1zZXBhcmF0b3J7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkNztoZWlnaHQ6MTRweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Db21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lclxue1xuICAgIC8qKlxuICAgICAqIFRpdGxlIGZvciB0aGUgRGlhbG9nLiAgaWYgdGl0bGUgYW5kICdUaXRsZVRlbXBsYXRlJyBhcmUgYm90aCBzZXQsIHRpdGxlVGVtcGxhdGUgdGFrZXNcbiAgICAgKiBwcmVjZWRlbmNlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEJvZHkgc2VjdGlvbiBmb3IgRGlhbG9nLiBDYWxsZXIgc2hvdWxkIHVzZSBlaXRoZXIgdGhlIGJvZHkgc3RyaW5nLCBvciBjb250ZW50IHByb2plY3Rpb25cbiAgICAgKiB0byBhZGQgdmFsdWVzIHRvIHRoZSBkaWFsb2cuIElmIGJvdGggYXJlIHVzZWQsIHRoZXkgd2lsbCBib3RoIHNob3cgdXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBPSyBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbmZpcm1BY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gQ2FuY2VsIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2FuY2VsQWN0aW9uTGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc3VwcG9ydCB0d28gd2F5IGRhdGEgYmluZGluZyBvbiB2aXNpYmxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSdzIGFuIHggYXQgdGhlIHRvcCByaWdodCB0aGF0IG1ha2VzIHRoZSBkaWFsb2cgY2xvc2FibGUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjbG9zYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaWFsb2cuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGRpYWxvZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHVzZXIgY2xpY2tlZCBvbiBjb25maXJtIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNvbmZpcm06IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB1c2VyIGNsaWNrZWQgb24gY2FuY2VsIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNhbmNlbDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgY29tcG9uZW50LiBVc3VhbGx5IGNvbnRhaW5zIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCkgaGVhZGVyOiBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgZm9vdGVyLiBVc3VhbGx5IGNvbnRhaW5zIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudCkgZm9vdGVyOiBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gNDAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgLy8gVG9kbzogaW50ZXJuYXRpb25hbGl6ZS5cbiAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uTGFiZWwgPSAnQ29uZmlybSc7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uTGFiZWwgPSAnQ2FuY2VsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvcGVuIGNvbmZpcm1hdGlvbi5cbiAgICAgKi9cbiAgICBvcGVuKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcblxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSBjb25maXJtYXRpb24uXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG5cbiAgICAgICAgLy8gSW1wb3J0YW50IHRvIG1ha2Ugc3VyZSBjaGFuZ2UgaXMgc2V0IG9uIHBhcmVudCBiaW5kaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YXJpYWJsZSBhbmQgZGlhbG9nIG9wZW4vY2xvc2Ugc3RhdGUgY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBzeW5jIGFuZCB3ZSB3b3VsZG4ndCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBjb25maXJtYXRpb24gaGF2ZSBoZWFkZXIgY29udGVudD9cbiAgICAgKi9cbiAgICBoYXNIZWFkZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmhlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgY29uZmlybWF0aW9uIGhhdmUgZm9vdGVyIGNvbnRlbnQ/XG4gICAgICovXG4gICAgaGFzRm9vdGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5mb290ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpcm0gYWN0aW9uLlxuICAgICAqL1xuICAgIGNvbmZpcm0oKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ29uZmlybS5lbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFjdGlvbi5cbiAgICAgKi9cbiAgICBjYW5jZWwoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ2FuY2VsLmVtaXQoKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50JztcbmltcG9ydCB7TW9kYWxDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC9tb2RhbC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RpYWxvZ01vZHVsZX0gZnJvbSAnLi4vZGlhbG9nL2RpYWxvZy5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ29uZmlybWF0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIENvbnRhaW5lciBwYW5lbCBwcm92aWRpbmcgc2Nyb2xsaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIGl0cyBjaGlsZHJlbi4gWW91IGNhbiBjb25maWd1cmUgdGhpc1xuICogY29udGFpbmVyIHRvIGxldCBpdCB0byBzY3JvbGwgaXRzIGNvbnRlbnQgZWl0aGVyIGhvcml6b250YWxseSwgdmVydGljYWxseSBvciBsZXQgdGhlIGNvbnRlbnRcbiAqIHdyYXAuXG4gKlxuICpcbiAqIFVzYWdlIGlzIHByZXR0eSBzaW1wbGU6XG4gKlxuICogICMjIyBFeGFtcGxlIHVzaW5nIGhvcml6b250YWwgc2Nyb2xsIChkZWZhdWx0IGJlaGF2aW9yKTpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAyPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDM8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNDwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA1PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDY8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA4PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDk8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgIDwvYXctc2Nyb2xsYWJsZT5cbiAqXG4gKiAgYGBgXG4gKlxuICogICMjIyBFeGFtcGxlIHVzaW5nIHZlcnRpY2FsIHNjcm9sbDpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlIFtkaXJlY3Rpb25dPVwiJ3ZlcnRpY2FsJ1wiIFtoZWlnaHRdPVwiJzQwdmgnXCI+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAxPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDI8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA0PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDU8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA3PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDg8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgOTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgPC9hdy1zY3JvbGxhYmxlPlxuICpcbiAqIGBgYFxuICpcbiAqICAjIyMgRXhhbXBsZSBzY3JvbGxpbmcgaXMgZGlzYWJsZWQgYW5kIGNvbnRlbnQgd3JhcHMgYW5kIGNlbnRlcnM6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZSBbZGlyZWN0aW9uXT1cIidub25lJ1wiIFthbGlnbm1lbnRdPVwiJ2NlbnRlcidcIj5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDE8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAzPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDQ8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA2PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDc8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgODwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA5PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICA8L2F3LXNjcm9sbGFibGU+XG4gKiAgYGBgXG4gKlxuICogIyMjIEhlaWdodCBwcm9wZXJ0eTpcbiAqXG4gKiBXaGVuIHVzaW5nIFwiaG9yaXpvbnRhbCBzY3JvbGxpbmdcIiBpdCBzZXQgXCJmbGV4Ym94LWRpcmVjdGlvblwiIHRvIFwicm93XCIgd2hlcmUgaGVpZ2h0XG4gKiBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgY29udGVudC4gVGhlIGhlaWdodCBzaG91bGQgYmUgYWx3YXlzIDEwMCUgd2hlbiB1c2luZ1xuICogdGhpcyBpbiBwYXJlbnQgY29udGFpbmVyLlxuICpcbiAqIElmIFwidmVydGljYWwgc2Nyb2xsaW5nXCIgaXMgdXNlZCB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdDpcbiAqICAgLSB5b3VyIHBhcmVudCBjb250YWluZXIgc2V0cyB0aGUgYm91bmRhcmllcyB3aXRoIGNvcnJlY3RseSBzZXQgd2lkdGggYW5kIGhlaWdodFxuICogICBvdGhlcndpc2UgaXQgd2lsbCB1c2UgMTAwJSBvZiB0aGUgdmlld3BvcnRcbiAqICAgLSBpZiB1c2VkIGFzIHN0YW5kYWxvbmUgeW91IG5lZWQgdG8gbGltaXQgdGhlIGhlaWdodCBvdGhlcndpc2UgaXQgd2lsbCBleHBhbmQgdG8gMTAwJSBvZlxuICogICB0aGUgZG9jdW1lbnRcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2Nyb2xsYWJsZScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidy1zY3JvbGxhYmxlXCIgW25nQ2xhc3NdPVwibGF5b3V0Q2xhc3NcIiBbc3R5bGUud2lkdGhdPVwid2lkdGhcIlxuICAgICBbc3R5bGUuaGVpZ2h0XT1cImhlaWdodFwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnctc2Nyb2xsYWJsZXtkaXNwbGF5OmZsZXg7ZGlzcGxheTotd2Via2l0LWZsZXg7YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjt3aWxsLWNoYW5nZTpvdmVyZmxvd30udy1zY3JvbGxhYmxlIC9kZWVwLz4qe2ZsZXg6MCAwIGF1dG87LXdlYmtpdC1mbGV4OjAgMCBhdXRvOy1tcy1mbGV4OjAgMCBhdXRvO21hcmdpbjoxMHB4fS51LXNjcm9sbGFibGUtZmh7ZmxleC1mbG93OnJvdyBub3dyYXA7b3ZlcmZsb3cteDphdXRvO292ZXJmbG93LXk6aGlkZGVufS51LXNjcm9sbGFibGUtZnZ7ZmxleC1mbG93OmNvbHVtbiBub3dyYXA7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvfS51LXNjcm9sbGFibGUtZmJ7ZmxleC1mbG93OnJvdyBub3dyYXA7b3ZlcmZsb3cteDphdXRvO292ZXJmbG93LXk6YXV0b30udS1zY3JvbGxhYmxlLWZ2LXJvd3tmbGV4LWZsb3c6cm93IHdyYXA7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvfS51LXNjcm9sbGFibGUtZm57ZmxleC1mbG93OnJvdyB3cmFwfS51LXNjcm9sbGFibGUtYWx7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0udS1zY3JvbGxhYmxlLWFye2p1c3RpZnktY29udGVudDpmbGV4LWVuZDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LWVuZH0udS1zY3JvbGxhYmxlLWFje2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS51LXNjcm9sbGFibGUtYWosLnUtc2Nyb2xsYWJsZS1hai1hcm91bmR7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn1gXVxufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHNjcm9sbGluZyBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5lciBtZWFuaW5nIHRlbGxzIHdoaWNoIG92ZXJmbG93IGF4aWVzIHdpbGwgYmVcbiAgICAgKiBkaXNhYmxlZCBvciBlbmFibGVkLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBcImhvcml6b250YWxcIjogSGVyZSB3ZSBsb2NrIG92ZXJmbG93LXkgYW5kIG92ZXJmbG93LXggc2V0IHRvIGF1dG8uXG4gICAgICpcbiAgICAgKiBXaGVuIHNjcm9sbGluZyBkaXJlY3Rpb24gaXMgXCJ2ZXJ0aWNhbFwiIHBsZWFzZSBtYWtlIHN1cmUgeW91IG1haW50YWluIGNvcnJlY3QgaGVpZ2h0IGFuZFxuICAgICAqIHdpZHRoLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXJlY3Rpb246IFNjcm9sbGluZ0RpcmVjdGlvbiA9ICdob3Jpem9udGFsJztcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaG93IGZsZXhib3ggY29udGFpbmVyIGl0ZW1zIHNob3VsZCBiZSBhbGlnbmVkLiBEZWZhdWx0IGJlaGF2aW9yIGlzIExFRlRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxpZ25tZW50OiBDb250YWluZXJJdGVtc0FsaWdubWVudCA9ICdsZWZ0JztcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgcHJvcGVydGllcyBmb3IgY2FsY3VsYXRlZCBjbGFzcyBsaXN0XG4gICAgICovXG5cbiAgICBsYXlvdXRDbGFzczogc3RyaW5nO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLndpZHRoID0gJzEwMCUnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdERlZmF1bHQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB3ZSByZS1pbml0aWFsaXplIGRlZmF1bHQgd2hlbiBJbnB1dCBCaW5kaW5ncyBjaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0RGVmYXVsdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkZWZhdWx0IHZhbHVlcyBhbmQgQ2FsY3VsYXRlcyBsYXlvdXQgYW5kIGFsaWdubWVudCBjbGFzcy4gVGhlIHJlYXNvbiBmb3IgdXNpbmdcbiAgICAgKiB0aGVzZSB1dGlsaXR5IGNsYXNzZXMgaXMgdGhhdCB3ZSBjYW4gY2hhbmdlIHRoZSBiZWhhdmlvciBhbnl0aW1lIGFzIGNvbXBhcmVkIHRvIHVzaW5nXG4gICAgICogZGlyZWN0bHkgW3N0eWxlLnh4eF0gYmluZGluZ3MuXG4gICAgICpcbiAgICAgKiAjIyMgRGlyZWN0aW9uIGZsb3cgY2xhc3M6XG4gICAgICogIC0gdS1zY3JvbGxhYmxlLWY8ZGlyZWN0aW9uPlxuICAgICAqXG4gICAgICogIyMjIEFsaWdubWVudCBjbGFzczpcbiAgICAgKiAgLSB1LXNjcm9sbGFibGUtYTxhbGlnbm1lbnQ+XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXREZWZhdWx0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZoJztcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mdic7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbC1yb3cnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mdi1yb3cnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdib3RoJykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZmInO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdub25lJykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZm4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyArPSAnIHUtc2Nyb2xsYWJsZS1hJyArIHRoaXMuYWxpZ25tZW50LnN1YnN0cmluZygwLCAxKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgKz0gYCAke3RoaXMuc3R5bGVDbGFzc31gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRlZmF1bHQgd2lkdGggYW5kIGhlaWdodCB0byBzb21lIHZhbHVlIGluIGNhc2Ugc29tZWJvZHkgcGFzc2VzIG51bGxcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzSG9yaXpvbnRhbFNjcm9sbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnctc2Nyb2xsYWJsZScpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFdpZHRoID4gc2Nyb2xsQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNWZXJ0aWNhbFNjcm9sbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnctc2Nyb2xsYWJsZScpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodCA+IHNjcm9sbENvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFNjcm9sbGluZ0RpcmVjdGlvbiBpcyBhIG5ldyB0eXBlIHRoYXQgZHJpdmVzIHNjcm9sbGluZyBiZWhhdmlvcjpcbiAqICAtIGhvcml6b250YWwgPT4gb3ZlcmZsb3cteDogYXV0bywgb3ZlcmZsb3cteTpoaWRkZW5cbiAqICAtIHZlcnRpY2FsID0+IG92ZXJmbG93LXg6IGhpZGRlbiwgb3ZlcmZsb3cteTphdXRvXG4gKiAgLSB2ZXJ0aWNhbC1yb3cgPT4gb3ZlcmZsb3cteDogaGlkZGVuLCBvdmVyZmxvdy15OmF1dG87IGZsb3c6IHJvdyB3cmFwXG4gKiAgLSBib3RoID0+IG92ZXJmbG93LXg6IGF1dG8sIG92ZXJmbG93LXk6YXV0b1xuICogIC0gbm9uZSA9PiBzZXRzIGZsb3ctZmxvdyB0byByb3cgd3JhcFxuICovXG5leHBvcnQgdHlwZSBTY3JvbGxpbmdEaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnIHwgJ3ZlcnRpY2FsLXJvdycgfCAnYm90aCcgfCAnbm9uZSc7XG5cblxuLyoqXG4gKlxuICogQ29udHJvbHMgdGhlIGp1c3RpZnktY29udGVudCBwcm9wZXJ0eTpcbiAqXG4gKiAtIGxlZnQgPT4gZmxleC1zdGFydFxuICogLSByaWdodCA9PiBmbGV4LWVuZFxuICogLSBjZW50ZXIgPT4gY2VudGVyXG4gKiAtIGp1c3RpZnkgPT4gc3BhY2UtYmV0d2VlblxuICpcbiAqL1xuZXhwb3J0IHR5cGUgQ29udGFpbmVySXRlbXNBbGlnbm1lbnQgPSAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicgfCAnanVzdGlmeSc7XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7U2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudH0gZnJvbSAnLi9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7TGlzdGJveCwgU2VsZWN0SXRlbX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7Q2hlY2tib3hDb21wb25lbnR9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IGNvbnN0IExCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuLyoqXG4gKlxuICogVGhlIExpc3QgY29tcG9uZW50IHJlcHJlc2VudCBhIHN0cnVjdHVyZSB3aGljaCBjb250YWlucyBhIGxpc3Qgb2Ygc2VsZWN0YWJsZSBpdGVtcy4gSXRlbXNcbiAqIHNlbGVjdGlvbiBjYW4gYmUgY29uZmlndXJlZCBpbiBzaW5nbGUtc2VsZWN0aW9uLCBtdWx0aS1zZWxlY3Rpb24gb3IgbXVsdGktc2VsZWN0aW9uIHdpdGggdmlzaWJsZVxuICogY2hlY2tib3hlcyBtb2RlLlxuICogSW4gYWRkaXRpb24gaXQgY2FuIGRpc3BsYXkgZGF0YSBpbnNpZGUgMyB6b25lcyBMRUZULCBNSURETEUgYW5kIFJJR0hUIGluIG9yZGVyIHRvIHByb3ZpZGVcbiAqIGVhc3kgd2F5IGZvciBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gbGF5b3V0IGl0cyBvd24gY3VzdG9tIGNvbnRlbnQgb3IgZXZlbiBjaGFuZ2Ugb3V0IG9mIGJveFxuICogYmVoYXZpb3IuXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZXNcbiAqXG4gKiAgMS4gUmVuZGVyIHNpbXBsZSBzaW5nbGUgc2VsZWN0aW9uIGxpc3RcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgICAgPGF3LWxpc3QgW2xpc3RdPVwibGlzdFwiPjwvYXctbGlzdD5cbiAqXG4gKiAgYGBgXG4gKiAgMi4gUmVuZGVyIGxpc3QgLSBtdWx0aSBzZWxlY3Rpb24gd2l0aCBjdXN0b20gUklHSFQgY29udGVudCB0byBzaG93IGEgQ2hlY2tNYXJrIHdoZW4gaXRlbVxuICogIGlzIHNlbGVjdGVkXG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgIDxhdy1saXN0ICNhd2xpc3QgW2xpc3RdPVwibGlzdFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PVwiMTUwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMjUwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25Nb2RlXT1cIidtdWx0aSdcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjcmlnaHQgbGV0LWl0ZW0+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzYXAtaWNvblwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7J2ljb24tYWNjZXB0JzogYXdsaXN0LnBMaXN0Qm94LmlzU2VsZWN0ZWQoaXRlbSksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJzogIWF3bGlzdC5wTGlzdEJveC5pc1NlbGVjdGVkKGl0ZW0pfVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9hdy1saXN0PlxuICpcbiAqICBgYGBcbiAqXG4gKiAzLiBSZW5kZXIgbGlzdCAtIG11bHRpIHNlbGVjdGlvbiB3aXRoIHZpc2libGUgY2hlY2tib3hlcyBhbmQgY3VzdG9tIE1JRERMRSBjb250ZW50IHRvIGNoYW5nZVxuICogIHRoZSB3YXkgaXRlbSBuYW1lIGlzIHJlbmRlcmVkXG4gKlxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgPGF3LWxpc3QgW2xpc3RdPVwibGlzdFwiIGhlaWdodD1cIjE4MHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjIwMHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGlvblwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbk1vZGVdPVwiJ211bHRpV2l0aENoZWNrYm94J1wiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNtaWRkbGUgbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICAgICAgICAgICBYWC17e2l0ZW0udmFsdWV9fVxuICogICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgPC9hdy1saXN0PlxuICpcbiAqICBgYGBcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDxwLWxpc3Rib3ggI2xpc3Rib3ggW29wdGlvbnNdPVwiaW50ZXJuYWxMaXN0XCIgW211bHRpcGxlXT1cImlzTXVsdGlwbGVcIiBbY2hlY2tib3hdPVwic2hvd0NoZWNrYm94XCJcbiAgICAgICAgICAgWyhuZ01vZGVsKV09XCJzZWxlY3Rpb25cIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIiBbc3R5bGVdPVwibGlzdFN0eWxlXCIgW3Nob3dUb2dnbGVBbGxdPVwiZmFsc2VcIlxuICAgICAgICAgICAob25DaGFuZ2UpPVwib25JdGVtU2VsZWN0ZWQoJGV2ZW50KVwiIChvbkRibENsaWNrKT1cImFjdGlvbi5lbWl0KCRldmVudC52YWx1ZSlcIlxuICAgICAgICAgICBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCI+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBsZXQtaXRlbSBwVGVtcGxhdGU9XCJpdGVtXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3LWxpLXdyYXBwZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LWxpLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJoYXNMZWZ0VGVtcGwoKTsgZWxzZSBkZWZhdWx0TGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxab25lVGVtcGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXRlbX1cIj48L25nLXRlbXBsYXRlPlxuXG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRMZWZ0PlxuICAgICAgICAgICAgICAgICAgICA8YXctY2hlY2tib3ggI2NoZWNrICpuZ0lmPVwiaXNNdWx0aXBsZSAmJiBzaG93Q2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwibGlzdGJveC5pc1NlbGVjdGVkKGl0ZW0pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJpdGVtQ2xpY2tlZCgkZXZlbnQsIGl0ZW0sIGNoZWNrKVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2F3LWNoZWNrYm94PlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInctbGktbWlkZGxlXCIgKGNsaWNrKT1cIml0ZW1DbGlja2VkKCRldmVudCwgaXRlbSwgbnVsbClcIj5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImhhc01pZGRsZVRlbXBsKCk7IGVsc2UgZGVmYXVsdE1pZGRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm1ab25lVGVtcGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXRlbX1cIj48L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0TWlkZGxlPlxuICAgICAgICAgICAgICAgICAgICB7e2l0ZW0ubGFiZWx9fVxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy1saS1yaWdodFwiICpuZ0lmPVwiaGFzUmlnaHRUZW1wbCgpXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInJab25lVGVtcGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXRlbX1cIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvcC1saXN0Ym94PlxuYCxcbiAgICBzdHlsZXM6IFtgOjpuZy1kZWVwIC51aS1saXN0Ym94LWl0ZW0+LnVpLWNoa2JveHtkaXNwbGF5Om5vbmV9OjpuZy1kZWVwIC51aS1saXN0Ym94LWl0ZW0gLnVpLWNoa2JveHttYXJnaW4tcmlnaHQ6MWVtfS53LWxpLXdyYXBwZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9LnctbGktd3JhcHBlciAudy1saS1sZWZ0LC53LWxpLXdyYXBwZXIgLnctbGktcmlnaHR7ZmxleDowIDEgYXV0b30udy1saS13cmFwcGVyIC53LWxpLW1pZGRsZXtmbGV4OjEgMSBhdXRvfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBMQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExpc3RDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTGlzdENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG9wdGlvbiB0aGF0IHdpbGwgc2hvdyBpbiB0aGUgbGlzdC4gUGxlYXNlIG5vdCB0aGF0IHRoaXMgbGlzdCBpcyBjdXJyZW50IHVzZWQgdG9cbiAgICAgKiBzaG93IGxpbWl0ZWQgbnVtYmVyIG9mIGl0ZW1zLiBJdCBkb2VzIG5vdCBoYXZlIGFueSBzY3JvbGxpbmcgZmVhdHVyZSBhbmQgbGF6eSBsb2FkaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogSXRlbXMgd2hpY2ggd2FzIHNlbGVjdGVkIGFzIGEgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHJlY29nbml6ZXMgMyBtb2Rlczogc2luZ2xlLCBtdWx0aSwgbXVsdGkgd2l0aCB2aXNpYmxlIGNoZWNrYm94ZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbk1vZGU6IFNlbGVjdGlvbk1vZGUgPSAnc2luZ2xlJztcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHVzZWQgdG8gZm9ybWF0IGVhY2ggc2VsZWN0aW9uIGZvciBkaXNwbGF5LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZVRyYW5zZm9ybWVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB3aGVuIGRlYWxpbmcgd2l0aCBvYmplY3QgdG8gaWRlbnRpZnkgc3BlY2lmaWMgZmllbGQgb24gdGhlIG9iamVjdCBmb3Jjb21wYXJpc29uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmaWVsZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBEb24ndCByZW5kZXIgTGlzdGJveCBib3JkZXIuIFVzZWQgZm9yIGVtYmVkZGluZyB0aGlzIGluc2lkZSBvdGhlciBjb21wb25lbnRzXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvcmRlcmxlc3M6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHdlIGRvdWJsZSBjbGljayBvbiB0aGUgbGlzdCBJdGVtXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB3ZSB3YW50IHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3Igb3IgTGVmdCB6b25lLiBXZSBleHBvc2UgdGhpcyBsaXN0Qm94IGluIG9yZGVyIHRvXG4gICAgICogaGF2ZSBhY2Nlc3MgcHJpbWVOZyBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2xpc3Rib3gnKVxuICAgIHBMaXN0Qm94OiBMaXN0Ym94O1xuXG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gdGVtcGxhdGVzIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IuIFRoZSBsaXN0IGl0ZW0gaXMgZGl2aWRlZCBpbnRvIDMgem9uZXNcbiAgICAgKlxuICAgICAqXG4gICAgICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAgICAgKiAgfCAgIEwgICB8ICAgICAgICAgICAgIE0gICAgICAgICAgICAgICAgICAgICB8ICAgUiAgICB8XG4gICAgICogIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICAgICAqICB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAgICAgKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2xlZnQnKVxuICAgIGxab25lVGVtcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAQ29udGVudENoaWxkKCdtaWRkbGUnKVxuICAgIG1ab25lVGVtcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAQ29udGVudENoaWxkKCdyaWdodCcpXG4gICAgclpvbmVUZW1wbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsXG4gICAgICovXG4gICAgaW50ZXJuYWxMaXN0OiBTZWxlY3RJdGVtW107XG5cbiAgICBsaXN0U3R5bGU6IHtbbmFtZTogc3RyaW5nXTogYW55fSA9IHt9O1xuXG4gICAgaXNNdWx0aXBsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHNob3dDaGVja2JveDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5pc011bHRpcGxlID0gdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknIHx8XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aVdpdGhDaGVja2JveCc7XG4gICAgICAgIHRoaXMuc2hvd0NoZWNrYm94ID0gdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGlXaXRoQ2hlY2tib3gnO1xuXG4gICAgICAgIC8vIGNhbm5vdCBoYXZlIGJvdGggZWl0aGVyIHdlIHVzZSBmaWVsZCB0byBnZXQgZGlzcGxheSB2YWx1ZSBvciB2YWx1ZVRyYW5zZm9ybWVyXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5maWVsZCkgJiYgaXNQcmVzZW50KHRoaXMudmFsdWVUcmFuc2Zvcm1lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBoYXZlIGVpdGhlciBbZmllbGRdIG9yIFt2YWx1ZVRyYW5zZm9ybWVyXS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0TGlzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFtsaXN0XSBiaW5kaW5nLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxzbyBhZGQgb3ZlcmZsb3dZIHRvIG1ha2Ugc3VyZSBpdCBjYW4gc2Nyb2xsIGFuZCBkb2VzIG5vdCBleHBhbmQgYmFzZWQgb24gaXRzIGNvbnRlbnRcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWydoZWlnaHQnXSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ292ZXJmbG93LXknXSA9ICdhdXRvJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWyd3aWR0aCddID0gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJvcmRlcmxlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWydib3JkZXItY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2luY2Ugd2UgYXJlIHVzaW5nIDxhdy1jaGVja2JveD4gd2UgbmVlZCB0byBoYXZlIGN1c3RvbSBoYW5kbGluZyBib3RoIHdoZW4gY2xpY2tpbmcgb24gdGhlXG4gICAgICogY2hlY2tib3ggYXMgd2VsbCBhcyBpdGVtIHRleHQuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGl0ZW1DbGlja2VkKGV2ZW50OiBhbnksIGl0ZW06IGFueSwgY2hlY2tib3g6IENoZWNrYm94Q29tcG9uZW50KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGVja2JveCkpIHtcbiAgICAgICAgICAgIHRoaXMucExpc3RCb3gub25DaGVja2JveENsaWNrKGV2ZW50LCBpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnBMaXN0Qm94KSkge1xuICAgICAgICAgICAgdGhpcy5wTGlzdEJveC5vbk9wdGlvbkNsaWNrKGV2ZW50LCBpdGVtKTtcblxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1JpZ2h0VGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnJab25lVGVtcGwpO1xuICAgIH1cblxuICAgIGhhc0xlZnRUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubFpvbmVUZW1wbCk7XG4gICAgfVxuXG5cbiAgICBoYXNNaWRkbGVUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubVpvbmVUZW1wbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VyZWQgYnkgcC1saXN0Ym94IGNvbXBvbmVudCB3aGVuIGl0ZW0gaXMgc2VsZWN0ZWQuIFdoZW4gc3RhdGUgaXMgbWFuYWdlZCBpbnRlcm5hbGx5XG4gICAgICogd2UgYWxzbyB1cGRhdGUgRm9ybUNvbnRyb2wgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkl0ZW1TZWxlY3RlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZXZlbnQudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQoZXZlbnQudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUoZXZlbnQudmFsdWUsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKGV2ZW50LnZhbHVlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIWVxdWFscyh2YWx1ZSwgdGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGV4dGVybmFsIGZvcm0gb2YgdGhlIGxpc3QgaW50byBQcmltZU5HIGV4cGVjdGVkIGZvcm1hdCB3aGVyZSBpdCB1c2VzXG4gICAgICogU2VsZWN0aW9uSXRlbSBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRMaXN0KClcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3QubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogdGhpcy5kaXNwbGF5VmFsdWUoaXRlbSksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgR2VuZXJhdGVzIGxhYmVsIHZhbHVlIGZvciB0aGUgbGlzdCBib3guXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRpc3BsYXlWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFsID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmllbGQpKSB7XG4gICAgICAgICAgICB2YWwgPSBpdGVtW3RoaXMuZmllbGRdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMudmFsdWVUcmFuc2Zvcm1lcikpIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMudmFsdWVUcmFuc2Zvcm1lcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0IHN1cHBvcnQgdGhlc2UgdGhyZWUgc2VsZWN0aW9uIG1vZGVzXG4gKlxuICovXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ3NpbmdsZScgfCAnbXVsdGknIHwgJ211bHRpV2l0aENoZWNrYm94JztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TGlzdGJveE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7TGlzdENvbXBvbmVudH0gZnJvbSAnLi9saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgTGlzdGJveE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZVxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBMaXN0Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0xpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBAYXV0aG9yIGFtYW51bC5jaG93ZGh1cnlcbiAqIENvcHlyaWdodCAyMDE4IFNBUCBBcmliYVxuICpcbiAqIFdpemFyZFByb2dyZXNzQ29tcG9uZW50IGNhbiBiZSB1c2VkIGFzIGEgc3RlcCBwcm9ncmVzc1xuICogaW4gYSBwYWdlIHRoYXQgaGFzIG11bHRpcGxlIHN0ZXBzXG4gKiBgPGF3LXdpemFyZC1wcm9ncmVzc1xuICogIFtzdGVwc109XCJzdGVwc1wiXG4gKiAgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCJcbiAqICAoc3RlcENoYW5nZWQpPVwib25TdGVwQ2hhbmdlZCgkZXZlbnQpXCI+XG4gKiA8L2F3LXdpemFyZC1wcm9ncmVzcz5gXG4gKi9cblxuaW1wb3J0IHtDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RlcFxue1xuICAgIGNvbXBsZXRlOiBib29sZWFuO1xuICAgIGN1cnJlbnQ6IGJvb2xlYW47XG4gICAgdGl0bGU/OiBzdHJpbmc7XG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctd2l6YXJkLXByb2dyZXNzJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJzdGVwLWluZGljYXRvclwiPnt7Y3VycmVudFN0ZXAgKyAxfX0ve3t0b3RhbFN0ZXBzfX08L2Rpdj5cbjxkaXYgY2xhc3M9XCJhdy1zdGVwLXByb2dyZXNzXCI+XG4gICAgPGRpdiBjbGFzcz1cImF3LXN0ZXAtcHJvZ3Jlc3NfX2l0ZW1cIiAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGkgPSBpbmRleDtcIlxuICAgICAgICAgW25nQ2xhc3NdPVwieyAnYXctc3RlcC1wcm9ncmVzc19faXRlbS0taXMtYWN0aXZlJzogc3RlcC5jdXJyZW50ID09PSB0cnVlIH1cIlxuICAgICAgICAgKGNsaWNrKT1cImdvVG9TdGVwKGkpO1wiPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2A6aG9zdHtkaXNwbGF5OmJsb2NrfS5zdGVwLWluZGljYXRvcnt3aWR0aDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtd2VpZ2h0OjYwMDtwYWRkaW5nLWJvdHRvbTouM3JlbX0uYXctc3RlcC1wcm9ncmVzc3tkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246cm93O3BhZGRpbmc6LjJyZW07anVzdGlmeS1jb250ZW50OmNlbnRlcn0uYXctc3RlcC1wcm9ncmVzc19faXRlbXtjdXJzb3I6cG9pbnRlcjtsaXN0LXN0eWxlOm5vbmU7d2lkdGg6MS4ycmVtO21hcmdpbjowIC4ycmVtO2JvcmRlci1yYWRpdXM6LjNyZW07aGVpZ2h0Oi40cmVtO2JhY2tncm91bmQtY29sb3I6I2VhZWFlYX0uYXctc3RlcC1wcm9ncmVzc19faXRlbTpsYXN0LWNoaWxke21hcmdpbi1yaWdodDowfS5hdy1zdGVwLXByb2dyZXNzX19pdGVtOmZpcnN0LWNoaWxke21hcmdpbi1sZWZ0OjB9LmF3LXN0ZXAtcHJvZ3Jlc3NfX2l0ZW0tLWlzLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiMwOWE3YWZ9YF1cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbntcbiAgICBASW5wdXQoKVxuICAgIHN0ZXBzOiBBcnJheTxTdGVwPjtcblxuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0ZXA6IG51bWJlciA9IDA7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzdGVwQ2hhbmdlZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIHRvdGFsU3RlcHM6IG51bWJlciA9IDA7XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXBzKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuc3RlcHMuZmlsdGVyKHN0ZXAgPT4gc3RlcC5jdXJyZW50KVswXSk7XG4gICAgICAgICAgICB0aGlzLnRvdGFsU3RlcHMgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudFN0ZXAofmN1cnJlbnRJbmRleCA/IGN1cnJlbnRJbmRleCA6IDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudFN0ZXAoaW5kZXg6IG51bWJlciA9IDApXG4gICAge1xuICAgICAgICB0aGlzLnN0ZXBzW2luZGV4XS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RlcCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2VkLmVtaXQoe2N1cnJlbnQ6IHRoaXMuY3VycmVudFN0ZXB9KTtcbiAgICB9XG5cbiAgICBnb1RvU3RlcChpbmRleDogbnVtYmVyKVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0ZXBzW2luZGV4XS5jb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLnN0ZXBzLmZpbHRlcihzdGVwID0+IHN0ZXAuY3VycmVudClbMF0pO1xuICAgICAgICB0aGlzLnN0ZXBzW2N1cnJlbnRJbmRleF0uY3VycmVudCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2V0Q3VycmVudFN0ZXAoaW5kZXgpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1dpemFyZFByb2dyZXNzQ29tcG9uZW50fSBmcm9tICcuL3dpemFyZC1wcm9ncmVzcy5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgV2l6YXJkUHJvZ3Jlc3NDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkUHJvZ3Jlc3NNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBSZW5kZXJzIGEgVG9nZ2xlIFN3aXRjaFxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICpcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ215VG9nZ2xlU2VjdGlvbicgLFxuICogICAgICAgICAgdGVtcGxhdGU6ICc8YXctdG9nZ2xlIFttb2RlbF09XCJpbnB1dFZhbHVlXCIgW2xhYmVsVGV4dF09XCJsYWJlbFRleHRcIiA+XG4gKiAgICAgICAgICAgICAgPC9hdy10b2dnbGU+J1xuICogICAgICB9KVxuICogICAgICBleHBvcnQgY2xhc3MgTXlOb3RlQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIGlucHV0VmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcbiAqICAgICAgICAgIGxhYmVsVGV4dDogc3RyaW5nID0gJ215IGxhYmVsJztcbiAqICAgICAgfVxuICpcbiAqIGBgYFxuICovXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctdG9nZ2xlJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LXRvZ2dsZVwiPlxuICAgIDxsYWJlbCBjbGFzcz1cInctdG9nZ2xlX19sYWJlbFwiICpuZ0lmPVwibGFiZWxUZXh0XCI+XG4gICAgICAgIHt7IGxhYmVsVGV4dCB9fVxuICAgIDwvbGFiZWw+XG4gICAgPGRpdiBjbGFzcz1cInNsaWRlclwiIChjbGljayk9XCJjaGFuZ2VIYW5kbGVyKClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNsaWRlcl9fYnV0dG9uXCIgW25nQ2xhc3NdPVwieyAnc2xpZGVyX19idXR0b24tLWlzLWFjdGl2ZSc6IG1vZGVsID09PSB0cnVlIH1cIj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgOmhvc3R7ZGlzcGxheTpibG9ja30udy10b2dnbGUgaW5wdXR7ZGlzcGxheTpub25lfS53LXRvZ2dsZV9fbGFiZWx7Y29sb3I6Izk5OTttYXJnaW4tcmlnaHQ6LjJyZW19LnctdG9nZ2xlIC5zbGlkZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0Oi42cmVtO3dpZHRoOjEuNXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNkOGQ4ZDg7Ym9yZGVyLXJhZGl1czouOXJlbTtkaXNwbGF5OmlubGluZS1ibG9jaztib3JkZXItdG9wOjFweCBzb2xpZCAjN2U3ZTdlO2JvcmRlci1sZWZ0OjFweCBzb2xpZCAjYjViNWI1O2JvcmRlci1yaWdodDoxcHggc29saWQgI2I1YjViNX0udy10b2dnbGUgLnNsaWRlcl9fYnV0dG9ue2xlZnQ6LS4xcmVtO3RyYW5zaXRpb246bGVmdCAuMXMgZWFzZS1vdXQ7Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246YWJzb2x1dGU7aGVpZ2h0OjFyZW07d2lkdGg6MXJlbTtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kLWNvbG9yOiNlYWVhZWE7dG9wOi0uMnJlbX0udy10b2dnbGUgLnNsaWRlcl9fYnV0dG9uLS1pcy1hY3RpdmV7bGVmdDpjYWxjKDEwMCUgLSAuOHJlbSk7YmFja2dyb3VuZC1jb2xvcjojMDlhN2FmfWBdXG59KVxuXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIHRvZ2dsZSBtb2RlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpIG1vZGVsOiBib29sZWFuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogbGFiZWwgdGV4dFxuICAgICAqL1xuICAgIEBJbnB1dCgpIGxhYmVsVGV4dDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsaWNrIGhhbmRsZXIgZm9yIHRvZ2dsZVxuICAgICAqL1xuICAgIGNoYW5nZUhhbmRsZXIoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9ICF0aGlzLm1vZGVsO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtUb2dnbGVTd2l0Y2hDb21wb25lbnR9IGZyb20gJy4vdG9nZ2xlLXN3aXRjaC5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVG9nZ2xlU3dpdGNoQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFRvZ2dsZVN3aXRjaENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBUb2dnbGVTd2l0Y2hDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgVG9nZ2xlU3dpdGNoTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7T3ZlcmxheVBhbmVsfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogT3ZlcmxheSBDb21wb25lbnQgaXMgYSBzaW1wbGUgdmVyc2lvbiBvZiB0aGUgZGlhbG9nIHdoZXJlIHRoZXJlJ3Mgb25seSBjb250ZW50LlxuICogT3ZlcmxheSB3aWxsIGFwcGVhciBhdCB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGFjdGlvbiBwZXJmb3JtZWQgdHJpZ2dlciBhbiBvdmVybGF5LlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBwb3B1cC5cbiAqICAgMS4gIGEgcmVndWxhciBkaWFsb2cgYm94IHRoYXQgaGFzIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyLiBJdCdzIHRoZSBtb3N0IGN1c3RvbWl6YWJsZS5cbiAqICAgMi4gIGEgY29uZmlybWF0aW9uIGJveCBpcyBzaW1pbGFyIHRvIGEgZGlhbG9nIGJveCBidXQgaGFzIGFjY2VwdCBhbmQgcmVqZWN0IGFjdGlvbiBidXR0b25zLlxuICogICAzLiAgYSBvdmVybGF5LCB3aGljaCBpcyBhIHZlcnkgYmFzaWMgcG9wdXAgd2l0aCB3aGF0IHlvdSBwdXQgaW5zaWRlLlxuICogICAgICAgSXQgZG9lc24ndCBoYXZlIGhlYWRlciBhbmQgZm9vdGVyLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgYW55IHBvcHVwIGNvbXBvbmVudC5cbiAqICAgMS4gIEVpdGhlciBkaXJlY3RseSBieSB1c2luZyBjb21wb25lbnQsIGF3LWRpYWxvZywgYXctY29uZmlybWF0aW9uIG9yIGF3LW92ZXJsYXlcbiAqICAgMi4gIG9yIHRoZSBNb2RhbFNlcnZpY2UgIHNlcnZpY2Uub3Blbig8T3ZlcmxheUNvbXBvbmVudD4pLCBzZXJ2aWNlLmNsb3NlKClcbiAqXG4gKiBVc2FnZTpcbiAqICAgIDEuICBVc2luZyBNb2RhbFNlcnZpY2UgZGlyZWN0bHkgdG8gZGlzcGxheSBhIG1vZGFsIHBvcHVwLiBUaGUgdXNhZ2UgaXMgYSBsaXR0bGUgdHJpY2t5XG4gKiAgICAgICAgYmVjYXVzZSBhbmd1bGFyIGN1cnJlbnRseSBkb2Vzbid0IHN1cHBvcnQgZHluYW1pYyBjb250ZW50IHByb2plY3Rpb24uXG4gKlxuICogICAgICAgICAgbGV0IG92ZXJsYXkgPSB0aGlzLm1vZGFsU2VydmljZS5vcGVuPE92ZXJsYXlDb21wb25lbnQ+KE92ZXJsYXlDb21wb25lbnQsIHt9KTtcbiAqXG4gKiAgICAgICAgICAgIC8vIEFkZCBjb250ZW50LiBUaGVyZSdzIG5vdCBzdXBwb3J0IGZvciBkeW5hbWljIGNvbnRlbnQgcHJvamVjdGlvbiB5ZXQuXG4gKiAgICAgICAgICAgIC8vIFNvIGhhdmUgYWRkIGNvbnRlbnQgZGlyZWN0bHkuXG4gKiAgICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHRoZSBiZXN0IHdheS5cbiAqICAgICAgICAgIG92ZXJsYXkuaW5zdGFuY2Uub3ZlcmxheS5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudWktb3ZlcmxheXBhbmVsLWNvbnRlbnRcIilcbiAqICAgICAgICAgICAgICAgLmlubmVySFRNTCA9IGA8aW1nIHN0eWxlPSd3aWR0aDozMDBweDsnIHNyYz1cInNhbGVzLnBuZ1wiIGFsdD1cIlNhbGVzIENoYXJ0XCIgLz5gO1xuICpcbiAqICAgICAgICAgIC8vIGRlbGF5IHRoZSBvcGVuaW5nIGFmdGVyIG5nIGxpZmVjeWNsZSBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAqICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBvdmVybGF5Lmluc3RhbmNlLm9wZW4oZXZlbnQpOyB9LCAxKTtcbiAqXG4gKlxuICogICAyLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLlxuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LW92ZXJsYXkgI292ZXJsYXkgKG9uT3Blbik9XCJvdmVybGF5QWN0aW9uPSdvcGVuJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uQ2xvc2UpPVwib3ZlcmxheUFjdGlvbj0nY2xvc2UnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJzYWxlcy5wbmdcIiBhbHQ9XCJDaGFydFwiLz5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LW92ZXJsYXk+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIChjbGljayk9XCJvdmVybGF5Lm9wZW4oJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGVuIE92ZXJsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlBY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqICAgICAgIH1cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW92ZXJsYXknLFxuICAgIHRlbXBsYXRlOiBgPHAtb3ZlcmxheVBhbmVsIFtkaXNtaXNzYWJsZV09XCJkaXNtaXNzYWJsZVwiIFtzaG93Q2xvc2VJY29uXT1cInNob3dDbG9zZUljb25cIlxuICAgICAgICAgICAgICAgIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbYXBwZW5kVG9dPVwiYXBwZW5kVG9cIlxuICAgICAgICAgICAgICAgIChvbkFmdGVySGlkZSk9XCJvbkNsb3NlZCgkZXZlbnQpXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9wLW92ZXJsYXlQYW5lbD5cbmAsXG4gICAgc3R5bGVzOiBbYDo6bmctZGVlcCAudWktb3ZlcmxheXBhbmVse2JvcmRlcjoxcHggc29saWQgI2Q3ZDdkNztib3gtc2hhZG93OjAgMnB4IDRweCAwIHJnYmEoMCwwLDAsLjIpfTo6bmctZGVlcCAudWktb3ZlcmxheXBhbmVsLWNvbnRlbnR7cGFkZGluZzoyZW0gMy40ZW0gLjZlbSAxLjQzZW19OjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWwtY2xvc2V7Ym9yZGVyLXJhZGl1czowO3RvcDouNWVtO3JpZ2h0Oi41ZW19OjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWwtY2xvc2UudWktc3RhdGUtZGVmYXVsdHtib3JkZXI6bm9uZX1gXVxufSlcbmV4cG9ydCBjbGFzcyBPdmVybGF5Q29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXIgaW1wbGVtZW50cyBPbkluaXRcbntcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGhpZGUgb3ZlcmxheSB3aGVuIG91dHNpZGUgaXMgY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc21pc3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBjbG9zZSBpY29uICd4JyBhdCB0b3Agb2YgcmlnaHQgY29ybmVyLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0Nsb3NlSWNvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgb3ZlcmxheS4gXCJib2R5XCIgb3IgbG9jYWwgbmctdGVtcGxhdGUgdmFyaWFibGUgYXJlIHZhbGlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kVG86IGFueTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gb3ZlcmxheSBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBvdmVybGF5IGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIG92ZXJsYXkgcGFuZWwuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZChPdmVybGF5UGFuZWwpXG4gICAgb3ZlcmxheTogT3ZlcmxheVBhbmVsO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBPdmVybGF5XG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb3BlbihldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnNob3coZXZlbnQpO1xuICAgICAgICB0aGlzLm9uT3BlbmVkKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIE92ZXJsYXlcbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICB0aGlzLm92ZXJsYXkuaGlkZSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xlIG9wZW4gYW5kIGNsb3NlLlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIHRvZ2dsZShldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnRvZ2dsZShldmVudCk7XG4gICAgfVxuXG5cbiAgICBvbk9wZW5lZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgb25DbG9zZWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KGV2ZW50KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdmVybGF5Q29tcG9uZW50fSBmcm9tICcuLi9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50JztcblxuXG4vKipcbiAqIERlZmluZXMgd2hlcmUgdGhlIENhcmQgaXMgcG9zaXRpb25lZC4gSXQgY2FuIGJlIGVpdGhlcjpcbiAqICAgIC0gYWJvdmUgdGhlIHRyaWdnZXJpbmcgbGlua1xuICogICAgLSB1bmRlciB0aGUgdHJpZ2dlcmluZyBsaW5rXG4gKiAgICAtIGNvbXBsZXRlbHkgb24gdG9wIG9mIGl0IC0gY292ZXJpbmcgaXQuIEZvciB0aGlzIGNhc2UgdGhlcmUgaXMgbm9uZSBhcyBubyBzdHlsZSBpcyBhcHBsaWVkXG4gKi9cbmV4cG9ydCBlbnVtIEhDQ2FyZFBvc2l0aW9uIHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIG5vbmVcbn1cblxuLyoqXG4gKiBEZWZpbmVzIHdoZXJlIHRoZSBDYXJkIGlzIHBvc2l0aW9uZWQgYnkgZGVmYXVsdC4gTWVhbmluZyB3aGVyZSBwcmltZU5HIGNvZGUgcHV0IGl0LlxuICpcbiAqIFdoZW4gdGhlcmUgaXMgYWxsb3Qgb2Ygc3BhY2Ugb24gdGhlIHNpZGVzID49ICAoTGVmdCBvciBSaWdodCkgaXMgdXNlZFxuICogKHBhZGRlZExlZnQsIHBhZGRlZFJpZ2h0KSBvdGhlcndpc2UuIFdoZW4gdGhlcmUgaXMgbm90IG11Y2ggc3BhY2UgYW5kIGNhcmQgY29udGFpbmVyXG4gKiAgaXMgbm90IGFsaWduZWQgKGxlZnQsIHJpZ2h0KSB3aXRoIHRoZSB0cmlnZXJpbmcgaWNvbiBidXQgaXQgaXMgc2hpZnRlZCB0byBmaXQgaW50byB0aGUgc2NyZWVuXG4gKi9cbmVudW0gSENDYXJkQWxpZ25tZW50IHtcbiAgICBsZWZ0LFxuICAgIHBhZGRlZExlZnQsXG4gICAgcmlnaHQsXG4gICAgcGFkZGVkUmlnaHQsXG4gICAgZGVmYXVsdFxufVxuXG4vKipcbiAqIE1hcHMgcG9zaXRpb24gdG8gc3R5bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIENhcmQgY29udGFpbmVyLiBUaGlzIGlzIGp1c3QgdG8gbWFrZSBpdCBlYXNpZXJcbiAqIGFzIHdlIGFyZSB3b3JraW5nIHdpdGggZW51bWVyYXRpb25zIGFuZCBoYXZlIGFscmVhZHkgZW51bSB0eXBlLlxuICpcbiAqIHUtaGMtYXJyb3ctYjogQXJyb3cgd2lsbCBhcHBlYXIgYXQgdGhlIGJvdHRvbVxuICogdS1oYy1hcnJvdy10OiBBcnJvdyB3aWxsIGFwcGVhciBhdCB0aGUgdG9wXG4gKlxuICogdS1oYy1zaGFkb3ctdDogQm9yZGVyIHNoYWRvdyB3aWxsIGFwcGVhciBhdCB0aGUgdG9wXG4gKiB1LWhjLXNoYWRvdy1iOiBCb3JkZXIgc2hhZG93IHdpbGwgYXBwZWFyIGF0IHRoZSBib3R0b21cbiAqL1xuY29uc3QgUG9zaXRpb25Ub1N0eWxlID0ge1xuICAgIHRvcDogJyB3LWhjLXBhbmVsLWFycm93IHUtaGMtYXJyb3ctYiB1LWhjLXNoYWRvdy10JyxcbiAgICBib3R0b206ICcgdy1oYy1wYW5lbC1hcnJvdyB1LWhjLWFycm93LXQgdS1oYy1zaGFkb3ctYicsXG4gICAgbm9uZTogJydcbn07XG5cblxuLyoqXG4gKlxuICogTWFwcyBhbGlnbmVkIENhcmQgY29udGFpbmVyIHRvIGN1c3RvbSBzdHlsZXMgaW4gb3JkZXIgdG8gYXBwbHkgY29ycmVjdCBhcnJvd1xuICpcbiAqIC1sbDogU3RhbmRzIGZvciBMYXJnZSBMZWZ0IChsYXJnZTogdGhlcmUgaXMgcGxlbnR5IG9mIHNwYWNlIGFyb3VuZCApXG4gKiAtbHI6IFN0YW5kcyBmb3IgTGFyZ2UgcmlnaHRcbiAqIC1zbDogU3RhbmRzIGZvciBTbWFsbCBsZWZ0IChTbWFsbCBhbmQgcmVzaXplZCBzY3JlZW4gd2hlcmUgd2UgdHJ5IHRvIGZpdCBjYXJkIGNvbnRhaW5lclxuICogc29tZXdoZXJlIGluIGJldHdlZW4pXG4gKiAtc3I6IFN0YW5kcyBmb3IgTGFyZ2UgcmlnaHRcbiAqXG4gKi9cbmNvbnN0IEFsaWdubWVudFRvU3R5bGUgPSB7XG4gICAgbGVmdDogJyB1LWhjLWFycm93LWxsJyxcbiAgICByaWdodDogJyB1LWhjLWFycm93LWxyJyxcbiAgICBwYWRkZWRMZWZ0OiAnIHUtaGMtYXJyb3ctc2wnLFxuICAgIHBhZGRlZFJpZ2h0OiAnIHUtaGMtYXJyb3ctc3InLFxuICAgIGRlZmF1bHQ6ICcgdS1oYy1hcnJvdy1sbCcsXG59O1xuXG4vKipcbiAqIFRoZSBIb3ZlckNhcmQgY29tcG9uZW50cyBhZGRzIGhvdmVyIGJlaGF2aW9yIHRvIHRleHQsIHRoZSBzcGVjaWZpZWQgY29udGVudCBpcyBsb2FkZWRcbiAqIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG9kbzogZXh0ZW5kcyBzbyB3ZSBjYW4gd3JhcCBhbnkgZWxlbWVudCBhbmQgYW55IGVsZW1lbnQgY2FuIGJlIHRyaWdnZXJpbmcgdGhpcy4gTm90IG9ubHlcbiAqIGxpbmtUaXRsZVxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqXG4gKiAgIDxhdy1ob3Zlci1jYXJkIFtsaW5rVGl0bGVdPVwiJ0ZyYW5rIGtvbGFyJ1wiPlxuICogICAgICAgPGgzPk15IENhcmQgVGl0bGU8L2gzPlxuICogICAgICAgPGRpdj5cbiAqXG4gKiAgICAgICAgICAgVGhpcyBpcyBteSBjb250ZW50c1xuICpcbiAqICAgICAgIDwvZGl2PlxuICpcbiAqXG4gKiAgICA8L2F3LWhvdmVyLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0IHRoZXJlIGlzIFtmb3JjZUNsb3NlXT10cnVlIHdoaWNoIGZvcmNlcyB0aGUgdXNlciB0byB1c2UgWCBjbG9zZSBpY29uXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaG92ZXItY2FyZCcsXG4gICAgdGVtcGxhdGU6IGA8c3BhbiBjbGFzcz1cInctaGNcIj5cbiAgICA8c3BhbiBjbGFzcz1cInctaGMtdGl0bGVcIj5cbiAgICAgICAgPGF3LXN0cmluZyBbdmFsdWVdPVwibGlua1RpdGxlXCI+PC9hdy1zdHJpbmc+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb24gaWNvbi1zbGltLWFycm93LWRvd25cIiAobW91c2VvdmVyKT1cIm9wZW5DYXJkKCRldmVudClcIj48L3NwYW4+XG4gICAgPC9zcGFuPlxuXG4gICAgPGRpdiBjbGFzcz1cInctaGMtYm9keVwiPlxuXG4gICAgICAgICA8YXctb3ZlcmxheSAjb3ZlcmxheSBbc2hvd0Nsb3NlSWNvbl09XCJmb3JjZUNsb3NlXCIgW2Rpc21pc3NhYmxlXT1cIiFmb3JjZUNsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZUNsYXNzXT1cImFycm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICAgW2FwcGVuZFRvXT1cImFwcGVuZFRvXCJcbiAgICAgICAgICAgICAgICAgICAgIChvbk9wZW4pPVwiY2FyZE9wZW5lZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgIChvbkNsb3NlKT1cImNhcmRDbG9zZWQoJGV2ZW50KVwiPlxuXG4gICAgICAgIDwhLS0gdGhpcyBpcyB3b3JrYXJvdW5kIHRvIGNyZWF0ZSBhIF9uZ2NvbnRlbnQtSU5ERVggcmVmZXJlbmNlIHNvIHdlIGNhblxuICAgICAgICByZWZlciB0byB0aGlzIG5nLWNvbnRlbnQuIEFuZ3VsYXIgZG9lcyBub3QgaGF2ZSBhbnkgd2F5IHJpZ2h0IG5vdyB0byB0cmFjayB0aGlzXG4gICAgICAgIC0tPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInUtbmdjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgPC9hdy1vdmVybGF5PlxuXG4gICAgPC9kaXY+XG48L3NwYW4+XG5cblxuPCEtLTxuZy10ZW1wbGF0ZSAjY29udGVudFRvQm9keT4tLT5cbiAgICA8IS0tPGF3LW92ZXJsYXkgI292ZXJsYXkgW3Nob3dDbG9zZUljb25dPVwiZm9yY2VDbG9zZVwiIFtkaXNtaXNzYWJsZV09XCIhZm9yY2VDbG9zZVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLVtzdHlsZUNsYXNzXT1cImFycm93Q2xhc3NcIi0tPlxuICAgICAgICAgICAgICAgIDwhLS1bYXBwZW5kVG9dPVwiYXBwZW5kVG9cIi0tPlxuICAgICAgICAgICAgICAgIDwhLS0ob25PcGVuKT1cImNhcmRPcGVuZWQoJGV2ZW50KVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbkNsb3NlKT1cImNhcmRDbG9zZWQoJGV2ZW50KVwiPi0tPlxuXG4gICAgICAgIDwhLS0mbHQ7ISZuZGFzaDsgdGhpcyBpcyB3b3JrYXJvdW5kIHRvIGNyZWF0ZSBhIF9uZ2NvbnRlbnQtSU5ERVggcmVmZXJlbmNlIHNvIHdlIGNhbi0tPlxuICAgICAgICA8IS0tcmVmZXIgdG8gdGhpcyBuZy1jb250ZW50LiBBbmd1bGFyIGRvZXMgbm90IGhhdmUgYW55IHdheSByaWdodCBub3cgdG8gdHJhY2sgdGhpcy0tPlxuICAgICAgICA8IS0tJm5kYXNoOyZndDstLT5cbiAgICAgICAgPCEtLTxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj4tLT5cbiAgICAgICAgICAgICAgICA8IS0tPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pi0tPlxuICAgICAgICAgICAgPCEtLTwvc3Bhbj4tLT5cblxuICAgIDwhLS08L2F3LW92ZXJsYXk+LS0+XG5cbjwhLS08L25nLXRlbXBsYXRlPi0tPlxuXG5cbjwhLS08bmctdGVtcGxhdGUgI2NvbnRlbnRUb092ZXJsYXk+LS0+XG5cbiAgICA8IS0tPGF3LW92ZXJsYXkgI292ZXJsYXkgW3Nob3dDbG9zZUljb25dPVwiZm9yY2VDbG9zZVwiIFtkaXNtaXNzYWJsZV09XCIhZm9yY2VDbG9zZVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLVtzdHlsZUNsYXNzXT1cImFycm93Q2xhc3NcIi0tPlxuICAgICAgICAgICAgICAgIDwhLS0ob25PcGVuKT1cImNhcmRPcGVuZWQoJGV2ZW50KVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbkNsb3NlKT1cImNhcmRDbG9zZWQoJGV2ZW50KVwiPi0tPlxuXG4gICAgICAgIDwhLS0mbHQ7ISZuZGFzaDsgdGhpcyBpcyB3b3JrYXJvdW5kIHRvIGNyZWF0ZSBhIF9uZ2NvbnRlbnQtSU5ERVggcmVmZXJlbmNlIHNvIHdlIGNhbi0tPlxuICAgICAgICA8IS0tcmVmZXIgdG8gdGhpcyBuZy1jb250ZW50LiBBbmd1bGFyIGRvZXMgbm90IGhhdmUgYW55IHdheSByaWdodCBub3cgdG8gdHJhY2sgdGhpcy0tPlxuICAgICAgICA8IS0tJm5kYXNoOyZndDstLT5cbiAgICAgICAgPCEtLTxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj4tLT5cbiAgICAgICAgICAgICAgICA8IS0tPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pi0tPlxuICAgICAgICAgICAgPCEtLTwvc3Bhbj4tLT5cblxuICAgIDwhLS08L2F3LW92ZXJsYXk+LS0+XG48IS0tPC9uZy10ZW1wbGF0ZT4tLT5cblxuXG5gLFxuICAgIHN0eWxlczogW2Audy1oYy10aXRsZXtwYWRkaW5nLXJpZ2h0OjEuNGVtO3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcH0udy1oYy10aXRsZSAuc2FwLWljb257Zm9udC1zaXplOjFlbTtjb2xvcjojMDA2NzllO3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmctdG9wOi4yZW07cmlnaHQ6MH06Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3cudS1oYy1zaGFkb3ctYntib3gtc2hhZG93OjAgMnB4IDRweCAwIHJnYmEoMCwwLDAsLjIpfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdy51LWhjLXNoYWRvdy10e2JveC1zaGFkb3c6MCAtMnB4IDRweCAwIHJnYmEoMCwwLDAsLjIpfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdzphZnRlciw6Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3c6YmVmb3Jle2xlZnQ6MjUlO2JvcmRlcjpzb2xpZCB0cmFuc3BhcmVudDtjb250ZW50OlwiIFwiO2hlaWdodDowO3dpZHRoOjA7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6bm9uZX06Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3c6YWZ0ZXJ7Ym9yZGVyLWNvbG9yOnJnYmEoMTM2LDE4MywyMTMsMCk7Ym9yZGVyLXdpZHRoOi43ZW07bWFyZ2luLWxlZnQ6LS43ZW19OjpuZy1kZWVwIC53LWhjLXBhbmVsLWFycm93OmJlZm9yZXtib3JkZXItY29sb3I6cmdiYSgyNTUsMTM2LDU2LDApO2JvcmRlci13aWR0aDouOGVtO21hcmdpbi1sZWZ0Oi0uOGVtfTo6bmctZGVlcCAudS1oYy1hcnJvdy1sbDphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctbGw6YmVmb3Jle2xlZnQ6MjUlfTo6bmctZGVlcCAudS1oYy1hcnJvdy1scjphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctbHI6YmVmb3Jle2xlZnQ6NzUlfTo6bmctZGVlcCAudS1oYy1hcnJvdy1zbDphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctc2w6YmVmb3Jle2xlZnQ6MTAlfTo6bmctZGVlcCAudS1oYy1hcnJvdy1zcjphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctc3I6YmVmb3Jle2xlZnQ6OTAlfTo6bmctZGVlcCAudS1oYy1hcnJvdy10OmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy10OmJlZm9yZXtib3R0b206MTAwJX06Om5nLWRlZXAgLnUtaGMtYXJyb3ctdDphZnRlcntib3JkZXItYm90dG9tLWNvbG9yOiNmZmZ9OjpuZy1kZWVwIC51LWhjLWFycm93LXQ6YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6I2Q3ZDdkN306Om5nLWRlZXAgLnUtaGMtYXJyb3ctYjphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctYjpiZWZvcmV7dG9wOjEwMCV9OjpuZy1kZWVwIC51LWhjLWFycm93LWI6YWZ0ZXJ7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfTo6bmctZGVlcCAudS1oYy1hcnJvdy1iOmJlZm9yZXtib3JkZXItdG9wLWNvbG9yOiNkN2Q3ZDd9YF1cbn0pXG5leHBvcnQgY2xhc3MgSG92ZXJDYXJkQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0NoZWNrZWQge1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBwYWRkaW5nIHJlcHJlc2VudGluZyBhIGhlaWdodCBvZiB0aGUgQXJyb3cgZm9yIHdoaWNoIHdlIG5lZWQgdG8gdmVydGljYWxseSBhZGp1c3RcbiAgICAgKiBDYXJkIGNvbnRhaW5lclxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBBcnJvd1BhZCA9IDEwO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBzYWZlIHRocmVzaG9sZCB3aGVyZSB0aGVyZSBtaWdodCBub3QgYmUgZW5vdWdoIHNwYWNlIGFyb3VuZCBvciBDYXJkIGlzIGFsaWduZWQgd2l0aFxuICAgICAqIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGZvciB3aGljaCB3ZSBuZWVkIHRvIHBvc2l0aW9uIHRoZSBBcnJvdyBjbG9zZXIgdG8gdGhlXG4gICAgICogc2lkZSBvZiB0aGUgY2FyZFxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBTcGFjaW5nTGltaXQgPSA1MDtcblxuXG4gICAgQElucHV0KClcbiAgICBsaW5rVGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB3ZSBrZWVwIHRoZSBob3ZlciBjYXJkIG9wZW4gYW5kIGZvcmNlIHVzZXIgdG8gbWFudWFsbHkgY2xvc2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9yY2VDbG9zZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBjdXJyZW50IHdvcmthcm91bmQgdW50aWwgd2UgZmluZCBiZXR0ZXIgc29sdXRpb24uIFByaW1lTkcgb3ZlcmxheXMgb3BlcmF0ZXMgd2l0aGluXG4gICAgICogaXRzIHJlbGF0aXZlIGVsZW1lbnQgc28gaWYgdGhlIG92ZXJsYXkgaXMgd3JhcHBlZCBpbnNpZGUgc29tZSBvdGhlciByZWxhdGl2ZSBjb250YWluZXJcbiAgICAgKiB0aGUgb3ZlcmxheSBjb250ZW50IGlzIGNyb3BlZCBieSBpdHMgcGFyZW50IGFuZCBjb250ZW50IGlzIG5vdCB2aXNpYmxlLlxuICAgICAqXG4gICAgICogVGhleSBoYXZlIFthcHBlbmRUb10gYmluZGluZyB3aGljaCB3ZSBuZWVkIHRvIHVzZSBmb3IgdGhpcyBwdXJwb3NlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZENvbnRlbnRUb0JvZHk6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIE92ZXJsYXlDb21wb25lbnQgdG8gY2FuIGFjY2VzcyBQcmltZU5HIGNvbXBvbmVudCBhcyB3ZWxsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnb3ZlcmxheScpXG4gICAgYXdPdmVybGF5OiBPdmVybGF5Q29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEludGVybmFsIHN0eWxlIGNsYXNzIHRvIHVzZSB0byBhcHBseSBhZGRpdGlvbmFsIHN0eWxlcyB3aGVuIGl0IG5lZWRzIHRvIHNob3cgYSBBcnJvdyBvbiB0aGVcbiAgICAgKiBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBhcnJvd0NsYXNzOiBzdHJpbmcgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgcHJvcGVydGllcyB0byByZWZlcmVuY2VzIHRlbXBsYXRlIGVsZW1lbnRzIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbmluZ1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB0aXRsZUFyZWFSZWN0OiBhbnk7XG4gICAgdHJpZ1JlY3Q6IGFueTtcbiAgICB0cmlnSWNvbk1pZGRsZTogYW55O1xuXG4gICAgb3BlbmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgYXBwZW5kVG86ICdib2R5JztcblxuICAgIGN1cnJyZW50UG9zaXRpb246IEhDQ2FyZFBvc2l0aW9uID0gSENDYXJkUG9zaXRpb24ubm9uZTtcblxuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW06IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmxpbmtUaXRsZSksICdZb3UgbXVzdCBwcm92aWRlIFtsaW5rVGl0bGVdIGJpbmRpbmcgIScpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBvcGVuIEhDIHdoZW4gd2Ugc3RhcnQgbmV3IGNvbXBvbmVudFxuICAgICAgICB0aGlzLmVudi5kZWxldGVWYWx1ZSgnaGMtb3BlbicpO1xuXG4gICAgICAgIGlmICghdGhpcy5hcHBlbmRDb250ZW50VG9Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXMgb2YgQW5ndWxhciA1IHdlIGhhdmUgdG8gaW50cm9kdWNlIHRoaXMgVmlld0NoZWNrZWQgYXMgUHJpbWVORyBkb2VzIGZpbmFsIGNhbGN1bGF0aW9uXG4gICAgICogZHVyaW5nIHRoaXMgcGhhc2UuXG4gICAgICpcbiAgICAgKiBTbyBub3cgaXRzIGJyb2tlbiBkb3duIGludG8gdHdvIHBhcnRzOlxuICAgICAqICAgLSBBcHBseSBjbGFzcyBzdHlsZXNcbiAgICAgKiAgIC0gUG9zaXRpb24gaXQuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vcGVuaW5nKSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS5jb250YWluZXI7XG5cbiAgICAgICAgICAgIGxldCBjbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycnJlbnRQb3NpdGlvbiAhPT0gSENDYXJkUG9zaXRpb24ubm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FyZChjb250YWluZXIsIGNudFJlY3QsIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdCBlbGVtZW50cyBCb3VuZGluZ0NsaWVudFJlY3QgdGhhdCB3ZSB1c2UgZm9yIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0RWxlbWVudHMoKTogdm9pZCB7XG4gICAgICAgIGxldCB0aXRsZUVsZW0gPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1oYy10aXRsZScpO1xuICAgICAgICBsZXQgdHJpZ2dlckVsZW0gPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuc2FwLWljb24nKTtcbiAgICAgICAgdGhpcy50aXRsZUFyZWFSZWN0ID0gdGl0bGVFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnRyaWdSZWN0ID0gdHJpZ2dlckVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudHJpZ0ljb25NaWRkbGUgPSB0aGlzLnRyaWdSZWN0LndpZHRoIC8gMjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZXMgd2hlbiB1c2VyIG1vdXNlIG92ZXIgdGhlIHRyaWdnZXJpbmcgaWNvbiBhbmQgb3BlbnMgdXAgb3ZlcmxheSBjb21wb25lbnQuIFRvIG1ha2Ugc3VyZVxuICAgICAqIG9ubHkgb25lIENhcmQgaXMgb3BlbmVkIGF0IHRoZSB0aW1lIGl0IHVzZXMgRW52aXJvbm1lbnQgdG8gc2F2ZSBleHRyYSBpbmZvcm1hdGlvbiBmb3IgaXRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgb3BlbkNhcmQoZXZlbnQ6IGFueSk6IGFueSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5hd092ZXJsYXkpICYmICF0aGlzLmVudi5oYXNWYWx1ZSgnaGMtb3BlbicpKSB7XG4gICAgICAgICAgICB0aGlzLmF3T3ZlcmxheS5vcGVuKGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5lbnYuc2V0VmFsdWUoJ2hjLW9wZW4nLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVuaW5nIGN5Y2xlIHdoZW4gYWxsIGlzIGluaXRpYWxpemVkIGFuZCB0aGUgY2FyZCBpcyBhYm91dCB0b1xuICAgICAqIGZhZGUgaW4uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBzaW11bGF0ZXMgZGlzcGxheWluZyBjYXJkIGJ5IHNldHRpbmcgZGlzcGxheTpibG9jayBhbmRcbiAgICAgKiBkb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24gc28gd2UgY2FuIHJlYWQgZGltZW5zaW9ucyBhbmQgdGhlbiBsYXRlciBvbiBwb3NpdGlvbiB0aGUgY2FyZFxuICAgICAqIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICovXG4gICAgY2FyZE9wZW5lZChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmNvbnRhaW5lcjtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkudGFyZ2V0O1xuICAgICAgICB0aGlzLm9wZW5Gb3JBZGp1c3RtZW50cyhjb250YWluZXIpO1xuXG4gICAgICAgIC8vIHByZS1ydW4gcG9zaXRpb25pbmcgc28gd2UgY2FuIGNhbGN1bGF0ZSBuZXcgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5hd092ZXJsYXkub3ZlcmxheS5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24oY29udGFpbmVyLCB0YXJnZXQpO1xuICAgICAgICBsZXQgY250UmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5jdXJycmVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkZvckNhcmQoY29udGFpbmVyLCBjbnRSZWN0KTtcblxuICAgICAgICB0aGlzLmFwcGx5U3R5bGVDbGFzcyhjb250YWluZXIsIGNudFJlY3QsIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2VGb3JBZGp1c3RtZW50cyhjb250YWluZXIpO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNhcmQgaXMgY2xvc2VkIHdlIG5lZWQgdG8gcmVsZWFzZSBpdCBhbmQgZGVsZXRlIGFsbCB0aGUgcmVmZXJlbmNlcyBmcm9tIEVudmlyb25tZW50XG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGNhcmRDbG9zZWQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmVudi5kZWxldGVWYWx1ZSgnaGMtb3BlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQXBwbGllcyBzdHlsZS5UT1AgYW5kIHN0eWxlLkxFRlQgdG8gdGhlIGNvbnRhaW5lciBpbiBvcmRlciB0byByZXBvc2l0aW9uIGl0IGFuZCBhZGRcbiAgICAgKiBleHRyYSBhcnJvdy5cbiAgICAgKlxuICAgICAqIEZpcnN0IGJhc2VkIG9uIHRoZSBpbml0aWFsIHBvc2l0aW9uIHdlIGFwcGx5IHN0eWxlLlRPUCBhbmQgZGVwZW5kaW5nIGlmIGl0cyBvbiB0aGVcbiAgICAgKiB0b3Agb3IgYm90dG9tIHdlIGFwcGx5IGVpdGhlciAtSG92ZXJDYXJkQ29tcG9uZW50LkFycm93UGFkIG9yICtIb3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQuXG4gICAgICpcbiAgICAgKiBUaGVuIGZvciBwb3NpdGlvbmluZyBob3Jpem9udGFsbHkgd2UgdXNlIHR3byB0eXBlcy5cbiAgICAgKiAgLSBXaGVuIHRoZXJlIGlzIGFsbG90IG9mIHNwYWNlIHRoZSBhcnJvdyBpcyAyNSUgZnJvbSB0aGUgZWRnZVxuICAgICAqXG4gICAgICogICAgLS0tLS1eLS0tLS0tLS0tLS0tICAgb3IgICAgICAgLS0tLS0tLS0tLS1eLS0tLVxuICAgICAqXG4gICAgICpcbiAgICAgKiAgLSBXaGVuIHRoZXJlIGlzIGxlc3Mgb3Igbm9uZSBzcGFjZSB3ZSBoYXZlIG9ubHkgMTAlIGZhciBhd2F5IGZvcm0gdGhlIGVkZ2VcbiAgICAgKlxuICAgICAqICAgIC0tXi0tLS0tLS0tLS0tLSAgIG9yICAgICAgIC0tLS0tLS0tLS0tXi0tXG4gICAgICpcbiAgICAgKiAgT25jZSB3ZSBwaWNrIHRoZSBjb3JyZWN0IHBvc2l0aW9uaW5nICgyNSUsIDEwJSkgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBhbmQgc2hpZnQgdGhlIGNhcmRcbiAgICAgKiAgZWl0aGVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuICAgICAqXG4gICAgICovXG4gICAgYWRqdXN0Q2FyZChjb250YWluZXI6IGFueSwgY29udGFpbmVyUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBkaWZmID0gKHRoaXMuY3VycnJlbnRQb3NpdGlvbiA9PT0gSENDYXJkUG9zaXRpb24uYm90dG9tKSA/IDEgOiAtMTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IG1vZGFsQ29udGFpbmVyLmRvbUhhbmRsZXIuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGxldCBwb3NXaXRoU2Nyb2xsID0gY29udGFpbmVyUmVjdC50b3AgKyBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSAocG9zV2l0aFNjcm9sbCArIChIb3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQgKiBkaWZmKSkgKyAncHgnO1xuXG4gICAgICAgIGxldCBhbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudEZvckNhcmQoY29udGFpbmVyUmVjdCwgbW9kYWxDb250YWluZXIpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IHRoaXMuY2FsY0xlZnRGb3JBbGlnbm1lbnQoY29udGFpbmVyUmVjdCwgYWxpZ25tZW50KSArICdweCc7XG4gICAgfVxuXG5cbiAgICBhcHBseVN0eWxlQ2xhc3MoY29udGFpbmVyOiBhbnksIGNvbnRhaW5lclJlY3Q6IGFueSwgbW9kYWxDb250YWluZXI6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJyZW50UG9zaXRpb24gIT09IEhDQ2FyZFBvc2l0aW9uLm5vbmUpIHtcbiAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudEZvckNhcmQoY29udGFpbmVyUmVjdCwgbW9kYWxDb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAoPGFueT5Qb3NpdGlvblRvU3R5bGUpWyg8YW55PkhDQ2FyZFBvc2l0aW9uKVt0aGlzLmN1cnJyZW50UG9zaXRpb25dXTtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyArPSAoPGFueT5BbGlnbm1lbnRUb1N0eWxlKVsoPGFueT5IQ0NhcmRBbGlnbm1lbnQpW2FsaWdubWVudF1dO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGV0ZWN0cyBpZiB0aGUgY2FyZCBpcyBnb2luZyB0byBiZSBzaG93biBvbiB0aGUgdG9wIG9mIHRoZSBMaW5rIGxhYmVsIG9yIHVuZGVyLiBPciBpZlxuICAgICAqIGl0cyBjb3ZlcmluZyBpdC5cbiAgICAgKlxuICAgICAqL1xuICAgIHBvc2l0aW9uRm9yQ2FyZChjb250YWluZXI6IGFueSwgYm91bmRpbmdSZWN0OiBhbnkpOiBIQ0NhcmRQb3NpdGlvbiB7XG4gICAgICAgIC8vIHNlY3VyZSB0aGlzIGluIGNhc2Ugb2YgSUUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICBsZXQgYm9yZGVyV2lkdGggPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikuYm9yZGVyV2lkdGg7XG4gICAgICAgIGxldCBjbnRXaWR0aCA9IHBhcnNlRmxvYXQoYm9yZGVyV2lkdGggfHwgJzAnKTtcbiAgICAgICAgbGV0IHBvcyA9IEhDQ2FyZFBvc2l0aW9uLm5vbmU7XG5cbiAgICAgICAgaWYgKHRoaXMudHJpZ1JlY3QuYm90dG9tIDwgYm91bmRpbmdSZWN0LnRvcCkge1xuICAgICAgICAgICAgcG9zID0gSENDYXJkUG9zaXRpb24uYm90dG9tO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJpZ1JlY3QudG9wID4gKGJvdW5kaW5nUmVjdC5ib3R0b20gLSBjbnRXaWR0aCkpIHtcbiAgICAgICAgICAgIHBvcyA9IEhDQ2FyZFBvc2l0aW9uLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERldGVjdCBob3Jpem9udGFsIGFsaWdubWVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgYWxpZ25tZW50Rm9yQ2FyZChib3VuZGluZ1JlY3Q6IGFueSwgbW9kYWxDb250YWluZXI6IGFueSk6IEhDQ2FyZEFsaWdubWVudCB7XG4gICAgICAgIGxldCBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQubGVmdDtcbiAgICAgICAgbGV0IHZpZXdQb3J0ID0gbW9kYWxDb250YWluZXIuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdSZWN0LmxlZnQudG9GaXhlZCgwKSA9PT0gYm91bmRpbmdSZWN0LmxlZnQudG9GaXhlZCgwKSAmJlxuICAgICAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgPiBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQubGVmdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kaW5nUmVjdC5sZWZ0IDwgSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnBhZGRlZExlZnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICgodmlld1BvcnQud2lkdGggLSBib3VuZGluZ1JlY3QucmlnaHQpIDwgSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnBhZGRlZFJpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnUmVjdC5yaWdodC50b0ZpeGVkKDApID09PSBib3VuZGluZ1JlY3QucmlnaHQudG9GaXhlZCgwKSB8fFxuICAgICAgICAgICAgKHZpZXdQb3J0LndpZHRoIC0gYm91bmRpbmdSZWN0LnJpZ2h0KSA+IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5yaWdodDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWdubWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR1cm4gb24gdGVtcG9yYXJ5IGRpc3BsYXkgdG8gQkxPQ0sgc28gd2UgY2FuIHJlYWQgZGltZW5zaW9uc1xuICAgICAqXG4gICAgICovXG4gICAgb3BlbkZvckFkanVzdG1lbnRzKGNvbnRhaW5lcjogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICB0aGlzLmluaXRFbGVtZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUdXJuIG9mZiBkaXNwbGF5IGJhY2sgTk9ORVxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VGb3JBZGp1c3RtZW50cyhjb250YWluZXI6IGFueSk6IHZvaWQge1xuICAgICAgICBjb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgLy8gY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbGN1bGF0ZXMgcG9zaXRpb25pbmcgZm9yIHN0eWxlLkxFRlQuIEFzIGFscmVhZHkgc2FpZCB0aGV5IGFyZSB0d28gdHlwZXMgb2YgdHJpYW5nbGVzIHRoYXRcbiAgICAgKiBhcmUgYXBwbGllcyBmb3IgdGhlc2UgY2FzZTpcbiAgICAgKlxuICAgICAqXG4gICAgICogYSkgTGFyZ2UgbGVmdCwgTGFyZ2UgcmlnaHRcbiAgICAgKlxuICAgICAqICBQcmltZU5HIGFsaWducyB0aGUgY2FyZCB3aXRoIGVpdGhlciB0aGUgcmlnaHQgc2lkZSBvciBsZWZ0IHNpZGUgb2YgdGhlIHRyaWdnZXJpbmcgaWNvblxuICAgICAqXG4gICAgICpcbiAgICAgKiAgViAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogIC4uLi4uLl4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gb3IgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXi4uLi4uLlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogIGIpIFNtYWxsIGxlZnQgLCBzbWFsbCByaWdodFxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYW5kIFByaW1lTkcgcG9zaXRpb24gdGhlIGNhcmQgb2ZmIHRvIHRoZVxuICAgICAqICB0cmlnZ2VyaW5nIGljb25zLCBzbyBldmVuIHByaW1lTmcgZG9lcyBub3QgaGF2ZSBzcGFjZSB0byBhbGlnbiBpdCB3aXRoIHRoZSBWXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuICAgICAqICAuLi4uXi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvciAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5eLi4uLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBjKUFsaWduZWQgd2l0aCB0aGUgZWRnZSBvZiBicm93c2VyXG4gICAgICpcbiAgICAgKiBPbiB0aGUgcmlnaHQgc2lkZSB0aGlzIGlzIHByb2JsZW0gYXMgd2UgY2Fubm90IGNhbGN1bGF0ZSBmdWxsIGZ1dHVyZSB3aWR0aCBvZiB0aGUgY2FyZC5cbiAgICAgKiBidXQgd2UgYXBwbGx5IGZvciB0aGlzIGNhc2UgI2IgKGFycm93IDEwJSApXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjTGVmdEZvckFsaWdubWVudChib3VuZGluZ1JlY3Q6IGFueSwgYWxpZ25tZW50OiBIQ0NhcmRBbGlnbm1lbnQpOiBudW1iZXIge1xuICAgICAgICAvLyB3aWR0aCBmb3Igd2hpY2ggd2UgbmVlZCB0byBzaGlmdCBjYXJkLiAyNSUgb3IgMTAlIG9mIHRoZSBjb250YWluZXIgd2lkdGhcbiAgICAgICAgbGV0IHdMYXJnZVRyaWFuZ2xlID0gYm91bmRpbmdSZWN0LndpZHRoICogMC4yNTtcbiAgICAgICAgbGV0IHdTbWFsbFRyaWFuZ2xlID0gYm91bmRpbmdSZWN0LndpZHRoICogMC4xMDtcblxuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQucmlnaHQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0UmlnaHQgPSBib3VuZGluZ1JlY3QubGVmdCArIHdMYXJnZVRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIGxldCB0cmlnUmlnaHQgPSB0aGlzLnRyaWdSZWN0LnJpZ2h0IC0gdGhpcy50cmlnSWNvbk1pZGRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRSaWdodCAtIChib3VuZGluZ1JlY3QucmlnaHQgLSB0cmlnUmlnaHQpO1xuXG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5wYWRkZWRSaWdodDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRSaWdodFMgPSBib3VuZGluZ1JlY3QubGVmdCArIHdTbWFsbFRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIGxldCB0cmlnUmlnaHRTID0gdGhpcy50cmlnUmVjdC5yaWdodCAtIHRoaXMudHJpZ0ljb25NaWRkbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0UmlnaHRTIC0gKGJvdW5kaW5nUmVjdC5yaWdodCAtIHRyaWdSaWdodFMpO1xuXG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LnBhZGRlZExlZnQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0TGVmdFBhZCA9IGJvdW5kaW5nUmVjdC5sZWZ0IC0gd1NtYWxsVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0TGVmdFBhZCArIHRoaXMudHJpZ0ljb25NaWRkbGU7XG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LmxlZnQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdExlZnQgPSBib3VuZGluZ1JlY3QubGVmdCAtIHdMYXJnZVRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdExlZnQgKyB0aGlzLnRyaWdJY29uTWlkZGxlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudENoZWNrZWQsXG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIERvQ2hlY2ssXG4gICAgRWxlbWVudFJlZixcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBTaW1wbGVDaGFuZ2Vcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudCwgcHJpbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU3B5IGxpZmVjeWNsZSBkaXJlY3RpdmUgaXMgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIHRvIHRyYWNrIGxpZmVjeWNsZSBjYWxsYmFja1xuICpcbiAqICMjI1VzYWdlXG4gKlxuICogYGBgXG4gKiAgIDxteS1kaXJlY3RpdmUgc3B5aG9va3M+PG15LWRpcmVjdGl2ZT5cbiAqXG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbc3B5SG9va3NdJ30pXG5leHBvcnQgY2xhc3MgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCwgRG9DaGVjaywgT25DaGFuZ2VzLFxuICAgIEFmdGVyQ29udGVudEluaXQsIEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWRcbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZilcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCdvbkluaXQnKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCdvbkRlc3Ryb3knKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHtbIHByb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2V9KVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdPbkNoYW5nZXMgPSAnICsgY2hhbmdlcyk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nRG9DaGVjaycpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyQ29udGVudEluaXQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKVxuICAgIHtcblxuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyQ29udGVudENoZWNrZWQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlclZpZXdJbml0Jyk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJWaWV3Q2hlY2tlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9nSXQobXNnOiBzdHJpbmcpXG4gICAge1xuICAgICAgICBsZXQgbGV2ZWwgPSAwO1xuICAgICAgICBsZXQgbWUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHRhZ0JvZHkgPSBtZTtcblxuICAgICAgICB3aGlsZSAoKHRhZ0JvZHkgPSB0YWdCb2R5LnBhcmVudE5vZGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICBpZiAodGFnQm9keS50YWdOYW1lID09PSAnQVBQLVJPT1QnIHx8IGxldmVsID09PSA2KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGVudCA9ICcnO1xuICAgICAgICBsZXQgaW5kZW50TnVtYmVyID0gbGV2ZWw7XG4gICAgICAgIHdoaWxlIChsZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnXFx0JztcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxldCBwYXJhbXMgPSAnJztcbiAgICAgICAgaWYgKGlzUHJlc2VudChtZS5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF0dHI6IEF0dHIgPSBtZS5hdHRyaWJ1dGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWdub3JlKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHBhcmFtcyArPSAnKCcgKyBhdHRyLm5hbWUgKyAnPScgKyBhdHRyLnZhbHVlICsgJyksICAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByaW50KGluZGVudCArIG1lLnRhZ05hbWUgKyAnKCcgKyBpbmRlbnROdW1iZXIgKyAnKTogJyArIG1zZyArICcgPT4gJyArIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpZ25vcmUobmFtZTogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuaW5kZXhPZignX25nJykgPiAtMSB8fFxuICAgICAgICAgICAgbmFtZS5pbmRleE9mKCduZy0nKSA+IC0xIHx8XG4gICAgICAgICAgICBuYW1lLmluZGV4T2YoJ3NweWhvb2tzJykgPiAtMTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge092ZXJsYXlDb21wb25lbnR9IGZyb20gJy4vb3ZlcmxheS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdmVybGF5UGFuZWxNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudCxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXT3ZlcmxheU1vZHVsZVxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIb3ZlckNhcmRDb21wb25lbnR9IGZyb20gJy4vaG92ZXItY2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV092ZXJsYXlNb2R1bGV9IGZyb20gJy4uL292ZXJsYXkvb3ZlcmxheS5tb2R1bGUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEhvdmVyQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0hvdmVyQ2FyZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBUFBfSU5JVElBTElaRVIsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgIEJ1dHRvbk1vZHVsZSxcbiAgICBDYWxlbmRhck1vZHVsZSxcbiAgICBDaGVja2JveCxcbiAgICBDaGVja2JveE1vZHVsZSxcbiAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgRGlhbG9nLFxuICAgIERpYWxvZ01vZHVsZSxcbiAgICBEcm9wZG93bk1vZHVsZSxcbiAgICBFZGl0b3JNb2R1bGUsXG4gICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgTWVudU1vZHVsZSxcbiAgICBPdmVybGF5UGFuZWxNb2R1bGUsXG4gICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgIFBhbmVsTW9kdWxlLFxuICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZSxcbiAgICBUYWJNZW51TW9kdWxlLFxuICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgVHJlZU1vZHVsZVxufSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBcmliYUNvcmVNb2R1bGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZX0gZnJvbSAnLi9zcHktbGlmZWN5Y2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQge0VtYmVkZGVkSXRlbURpcmVjdGl2ZX0gZnJvbSAnLi9jb3JlL2VtYmVkZGVkLWl0ZW0nO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi9lbnRyeS1jb21wb25lbnRzJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUnO1xuaW1wb3J0IHtBV0NoZWNrQm94TGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7QVdDaG9vc2VyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29uZmlybWF0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0N1cnJlbmN5TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlJztcbmltcG9ydCB7QVdEYXRlQW5kVGltZU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0RpYWxvZ01vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQge0FXR2VuZXJpY0Nob29zZXJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9nZW5lcmljLWNob29zZXIvZ2VuZXJpYy1jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0lucHV0RmllbGRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUnO1xuaW1wb3J0IHtBV091dGxpbmVGb3JNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZSc7XG5pbXBvcnQge0FXT3ZlcmxheU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VXcmFwcGVyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2Utd3JhcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JhZGlvLWJ1dHRvbi1saXN0L3JhZGlvLWJ1dHRvbi1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXUmljaFRleHRBcmVhTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlJztcbmltcG9ydCB7QVdIb3ZlckNhcmRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQubW9kdWxlJztcbmltcG9ydCB7XG4gICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlXG59IGZyb20gJy4vd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUnO1xuaW1wb3J0IHtBV1NlY3Rpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zZWN0aW9uL3NlY3Rpb24ubW9kdWxlJztcbmltcG9ydCB7QVdTdGVwcGVyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FXVGV4dEFyZWFNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy90ZXh0LWFyZWEvdGV4dC1hcmVhLm1vZHVsZSc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0Zvcm1UYWJsZU1vZHVsZX0gZnJvbSAnLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS10YWJsZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0xpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9saXN0L2xpc3QubW9kdWxlJztcbmltcG9ydCB7QVdDYXJkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZSc7XG5pbXBvcnQge0FXRGF0YXRhYmxlMk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5tb2R1bGUnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge01vZGFsU2VydmljZX0gZnJvbSAnLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwuc2VydmljZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0Vycm9yTWFuYWdlclNlcnZpY2V9IGZyb20gJy4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHtBd05hbWVTdG9yZX0gZnJvbSAnLi9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZSc7XG5pbXBvcnQge0RhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1dpemFyZFByb2dyZXNzTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvd2l6YXJkLXByb2dyZXNzL3dpemFyZC1wcm9ncmVzcy5tb2R1bGUnO1xuaW1wb3J0IHtUb2dnbGVTd2l0Y2hNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy90b2dnbGUtc3dpdGNoL3RvZ2dsZS1zd2l0Y2gubW9kdWxlJztcblxuLyoqXG4gKiBDb21wb25lbnQgbW9kdWxlIGlzIGNvcmUgbW9kdWxlIGZvciB0aGUgY29tbW9uIGxheW91dHMgYW5kIHdpZGdldHMgbGlicmFyaWVzLlxuICpcbiAqIHRvZG86IFRoZXJlIGFyZSBzb21lIHRoaW5ncyB0aGF0IEkgc3RpbGwgbmVlZCB0byByZXNvbHZlIC0gcGxlYXNlIHNlZSBhbmQgbm90aWNlcyBARHVwbGljYXRlc1xuICoganNkb2MgSSB3YW50IHRvIGtlZXAgdGhpcyB0aGVyZSB0byByZW1pbmQgbWUgdGhhdCBJIG5lZWQgdG8gcmVmYWN0b3IgdGhpcyBhcyBvZiBub3cgdGhlcmUgYXJlXG4gKiBub3QgbXVjaCBvcHRpb24gd2l0aCBhbmd1bGFyLlxuICpcbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEFyaWJhQ29yZU1vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcblxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXQmFzaWNOYXZpZ2F0b3JNb2R1bGUsXG4gICAgICAgIEFXQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveExpc3RNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgIEFXQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdDb25maXJtYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXQ3VycmVuY3lNb2R1bGUsXG4gICAgICAgIEFXRGF0ZUFuZFRpbWVNb2R1bGUsXG4gICAgICAgIEFXRGlhbG9nTW9kdWxlLFxuICAgICAgICBBV0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdJbnB1dEZpZWxkTW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlLFxuICAgICAgICBBV1BhZ2VXcmFwcGVyTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZSxcbiAgICAgICAgQVdSaWNoVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZSxcbiAgICAgICAgQVdTZWN0aW9uTW9kdWxlLFxuICAgICAgICBBV1N0ZXBwZXJNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXRm9ybVRhYmxlTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdIb3ZlckNhcmRNb2R1bGUsXG4gICAgICAgIEFXTGlzdE1vZHVsZSxcbiAgICAgICAgQVdEYXRhdGFibGUyTW9kdWxlLFxuICAgICAgICBXaXphcmRQcm9ncmVzc01vZHVsZSxcbiAgICAgICAgVG9nZ2xlU3dpdGNoTW9kdWxlLFxuXG4gICAgICAgIC8vIFByaW1lTkcgcmVtb3ZlIHdoZW4gYWxsIEFXIGFyZSBpbXBvcnRlZFxuICAgICAgICBQYW5lbE1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dGFyZWFNb2R1bGUsXG4gICAgICAgIEF1dG9Db21wbGV0ZU1vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZSxcbiAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIFNoYXJlZE1vZHVsZSxcbiAgICAgICAgRGlhbG9nTW9kdWxlLFxuICAgICAgICBNZW51TW9kdWxlLFxuICAgICAgICBUYWJNZW51TW9kdWxlLFxuICAgICAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgRGF0YVRhYmxlTW9kdWxlLFxuICAgICAgICBQYWdpbmF0b3JNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZSxcbiAgICAgICAgVHJlZU1vZHVsZVxuXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUsXG4gICAgICAgIC8vIDN0aCBwYXJ0eSBkZWNsYXJhdGlvblxuICAgIF0sXG4gICAgYm9vdHN0cmFwOiBbXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcblxuICAgICAgICAvLyBQcmltZU5HXG4gICAgICAgIENoZWNrYm94LFxuICAgICAgICBEaWFsb2dcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFNweUxpZmVDeWNsZUhvb2tzRGlyZWN0aXZlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXQmFzaWNOYXZpZ2F0b3JNb2R1bGUsXG4gICAgICAgIEFXQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveExpc3RNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGUsXG4gICAgICAgIEFXQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdDb25maXJtYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXQ3VycmVuY3lNb2R1bGUsXG4gICAgICAgIEFXRGF0ZUFuZFRpbWVNb2R1bGUsXG4gICAgICAgIEFXRGlhbG9nTW9kdWxlLFxuICAgICAgICBBV0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdJbnB1dEZpZWxkTW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXT3ZlcmxheU1vZHVsZSxcbiAgICAgICAgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlLFxuICAgICAgICBBV1BhZ2VXcmFwcGVyTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZSxcbiAgICAgICAgQVdSaWNoVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZSxcbiAgICAgICAgQVdTZWN0aW9uTW9kdWxlLFxuICAgICAgICBBV1N0ZXBwZXJNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXVGV4dEFyZWFNb2R1bGUsXG4gICAgICAgIEFXRm9ybVRhYmxlTW9kdWxlLFxuICAgICAgICBFbWJlZGRlZEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0hvdmVyQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdMaXN0TW9kdWxlLFxuICAgICAgICBBV0RhdGF0YWJsZTJNb2R1bGUsXG4gICAgICAgIFdpemFyZFByb2dyZXNzTW9kdWxlLFxuICAgICAgICBUb2dnbGVTd2l0Y2hNb2R1bGUsXG5cbiAgICAgICAgLy8gUHJpbWVOR1xuICAgICAgICBTaGFyZWRNb2R1bGUsXG4gICAgICAgIFBhbmVsTW9kdWxlLFxuICAgICAgICBCdXR0b25Nb2R1bGUsXG4gICAgICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlLFxuICAgICAgICBSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgRGlhbG9nTW9kdWxlLFxuICAgICAgICBNZW51TW9kdWxlLFxuICAgICAgICBUYWJNZW51TW9kdWxlLFxuICAgICAgICBFZGl0b3JNb2R1bGUsXG4gICAgICAgIERhdGFUYWJsZU1vZHVsZSxcbiAgICAgICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgICAgICBPdmVybGF5UGFuZWxNb2R1bGVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFyaWJhQ29tcG9uZW50c01vZHVsZVxue1xuXG5cbiAgICBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzXG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFyaWJhQ29tcG9uZW50c01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1vZGFsU2VydmljZSxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBFcnJvck1hbmFnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBEYXRhRmluZGVycyxcbiAgICAgICAgICAgICAgICBBd05hbWVTdG9yZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcmVnaXN0ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbQ29tcG9uZW50UmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRzKGNvbXBSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnkpOiBGdW5jdGlvblxue1xuICAgIHJldHVybiBjb21wUmVnaXN0cnkuaW5pdGlhbGl6ZS5iaW5kKGNvbXBSZWdpc3RyeSwgY29tcG9uZW50cyk7XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FQUF9JTklUSUFMSVpFUiwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi9lbnRyeS1jb21wb25lbnRzJztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtNb2RhbFNlcnZpY2V9IGZyb20gJy4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZXJyb3ItbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7QXdOYW1lU3RvcmV9IGZyb20gJy4vY29yZS9hdy1uYW1lL2F3LW5hbWUuc3RvcmUnO1xuaW1wb3J0IHtEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG5cbi8qKlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIHVzZWQgbWFpbmx5IGZvciB0ZXN0cyBhcyBpbXBvcnRpbmcgYSBtb2R1bGUgd2l0aCBhbGwgdGhlIGNvbXBvbmVudHMgYW5kIHlvdVxuICogdXNlIG9ubHkgMSBvciB0d28gaGFzIGEgYmlnIGltcGFjdCBvbiB0aGUgcGVyZm9ybWFuY2UgZXhlY3V0aW9uLiBlLmcuIGZyb20gZXhlY3V0aW5nIGNvdXBsZVxuICogdGVzdHMgdW5kZXIgMSBzZWMgY2FuIGdvIHVwIHRvIDEwc2VjIGlmIHlvdSBpbXBvcnQgYWxsIHRoZSB0aGluZ3MgdGhhdCB5b3UgYXJlIG5vdCB1c2luZy5cbiAqXG4gKiBJIGhhdmVudCBub3RpY2VkIGFueXRoaW5nIHNpbWlsYXIgaW4gYXBwbGljYXRpb24gaXRzIG9ubHkgamFzbWluZS9rYXJtYSB0aGF0IG5lZWRzIHRvIGluaXRcbiAqIGNvbXBvbmVudHMgZm9yIGV2ZXJ5IHRlc3QuXG4gKlxuICovXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFyaWJhQ29tcG9uZW50c1Rlc3RQcm92aWRlck1vZHVsZSB7XG5cblxuICAgIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFyaWJhQ29tcG9uZW50c1Rlc3RQcm92aWRlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1vZGFsU2VydmljZSxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBFcnJvck1hbmFnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBEYXRhRmluZGVycyxcbiAgICAgICAgICAgICAgICBBd05hbWVTdG9yZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcmVnaXN0ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbQ29tcG9uZW50UmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRzKGNvbXBSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnkpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuIGNvbXBSZWdpc3RyeS5pbml0aWFsaXplLmJpbmQoY29tcFJlZ2lzdHJ5LCBjb21wb25lbnRzKTtcbn1cblxuXG4iXSwibmFtZXMiOlsib2JzZXJ2YWJsZU9mIiwiSW5wdXRUZXh0TW9kdWxlIiwic3RhdGUiLCJyZWdpc3RlckNvbXBvbmVudHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnRUE7Ozs7SUFrQkksWUFBb0IsY0FBZ0M7UUFBaEMsbUJBQWMsR0FBZCxjQUFjLENBQWtCO0tBRW5EOzs7OztJQVpELElBQ0ksSUFBSSxDQUFDLElBQVM7UUFFZCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQztLQUM5Qjs7Ozs7O0lBYUQsV0FBVyxDQUFDLE9BQXNCO1FBRTlCLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUMxQixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztTQUMxRTtRQUVELElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRTtZQUM5QixxQkFBSSxPQUFPLEdBQUcsSUFBSSxXQUFXLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1lBQ25ELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQ3RGO0tBQ0o7OztZQXBDSixTQUFTLFNBQUMsRUFBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUM7Ozs7WUF4RG5DLGdCQUFnQjs7OzJCQThEZixLQUFLO21CQUdMLEtBQUs7Ozs7OztBQW1DVjs7OztJQUVJLFlBQW1CLFNBQWM7UUFBZCxjQUFTLEdBQVQsU0FBUyxDQUFLO0tB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