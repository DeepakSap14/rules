import { Directive, Input, ViewContainerRef, Component, ElementRef, Renderer2, forwardRef, Inject, Optional, SkipSelf, Injectable, ChangeDetectorRef, ComponentFactoryResolver, ViewChild, Pipe, EventEmitter, Output, NgZone, NgModule, InjectionToken, HostBinding, ContentChild, ContentChildren, ViewEncapsulation, ChangeDetectionStrategy, Injector, PLATFORM_ID, APP_INITIALIZER } from '@angular/core';
import { isPresent, isBlank, MapWrapper, AppConfig, Environment, noop, uuid, isStringMap, assert, StringWrapper, isType, objectToName, FieldPath, isArray, isString, isFunction, isJsObject, unimplemented, ListWrapper, equals, isBoolean, isDate, isEntity, RoutingService, AribaCoreModule, BooleanWrapper, print } from '@aribaui/core';
import { __extends, __spread, __values } from 'tslib';
import { FormControl, FormGroup, Validators, FormsModule, ReactiveFormsModule, NG_VALUE_ACCESSOR } from '@angular/forms';
import { DomSanitizer } from '@angular/platform-browser';
import { CurrencyPipe, CommonModule, DecimalPipe, isPlatformBrowser } from '@angular/common';
import { BehaviorSubject, of, Subject } from 'rxjs';
import { InputTextModule } from 'primeng/components/inputtext/inputtext';
import { distinctUntilChanged, debounceTime, switchMap } from 'rxjs/operators';
import { ButtonModule, ToolbarModule, CheckboxModule, AutoComplete, AutoCompleteModule, DropdownModule, InputTextModule as InputTextModule$1, CalendarModule, DialogModule, RadioButtonModule, InputTextareaModule, EditorModule, AccordionTab, AccordionModule, SharedModule, DomHandler, Listbox, ListboxModule, OverlayPanel, TreeDragDropService, ConfirmationService, Header, Footer, PrimeTemplate, Column, Row, HeaderColumnGroup, FooterColumnGroup, Accordion, AUTOCOMPLETE_VALUE_ACCESSOR, BlockUI, BlockUIModule, Breadcrumb, BreadcrumbModule, ButtonDirective, Button, Captcha, CaptchaModule, CALENDAR_VALUE_ACCESSOR, Calendar, Card, CardModule, Carousel, CarouselModule, UIChart, ChartModule, CHECKBOX_VALUE_ACCESSOR, Checkbox, CHIPS_VALUE_ACCESSOR, Chips, ChipsModule, CodeHighlighter, CodeHighlighterModule, COLORPICKER_VALUE_ACCESSOR, ColorPicker, ColorPickerModule, ConfirmDialog, ConfirmDialogModule, ContextMenuSub, ContextMenu, ContextMenuModule, DataGrid, DataGridModule, DataList, DataListModule, DataScroller, DataScrollerModule, DTRadioButton, DTCheckbox, ColumnHeaders, ColumnFooters, TableBody, ScrollableView, DataTable, DataTableModule, DeferredLoader, DeferModule, Dialog, Draggable, Droppable, DragDropModule, DROPDOWN_VALUE_ACCESSOR, Dropdown, EDITOR_VALUE_ACCESSOR, Editor, Fieldset, FieldsetModule, FileUpload, FileUploadModule, Galleria, GalleriaModule, GMap, GMapModule, Growl, GrowlModule, InplaceDisplay, InplaceContent, Inplace, InplaceModule, INPUTMASK_VALUE_ACCESSOR, InputMask, InputMaskModule, INPUTSWITCH_VALUE_ACCESSOR, InputSwitch, InputSwitchModule, InputText, InputTextarea, KEYFILTER_VALIDATOR, KeyFilter, KeyFilterModule, Lightbox, LightboxModule, LISTBOX_VALUE_ACCESSOR, MegaMenu, MegaMenuModule, MenuItemContent, Menu, MenuModule, MenubarSub, Menubar, MenubarModule, Messages, MessagesModule, UIMessage, MessageModule, MULTISELECT_VALUE_ACCESSOR, MultiSelect, MultiSelectModule, OrderList, OrderListModule, OrganizationChartNode, OrganizationChart, OrganizationChartModule, OverlayPanelModule, Paginator, PaginatorModule, Panel, PanelModule, BasePanelMenuItem, PanelMenuSub, PanelMenu, PanelMenuModule, Password, PasswordModule, PickList, PickListModule, ProgressBar, ProgressBarModule, ProgressSpinner, ProgressSpinnerModule, RADIO_VALUE_ACCESSOR, RadioButton, RATING_VALUE_ACCESSOR, Rating, RatingModule, Schedule, ScheduleModule, ScrollPanel, ScrollPanelModule, SELECTBUTTON_VALUE_ACCESSOR, SelectButton, SelectButtonModule, SlideMenuSub, SlideMenu, SlideMenuModule, SLIDER_VALUE_ACCESSOR, Slider, SliderModule, Sidebar, SidebarModule, SPINNER_VALUE_ACCESSOR, Spinner, SpinnerModule, SplitButton, SplitButtonModule, Steps, StepsModule, TabViewNav, TabPanel, TabView, TabViewModule, TabMenu, TabMenuModule, Terminal, TerminalModule, TieredMenuSub, TieredMenu, TieredMenuModule, TOGGLEBUTTON_VALUE_ACCESSOR, ToggleButton, ToggleButtonModule, Toolbar, Tooltip, TooltipModule, UITreeNode, Tree, TreeModule, TreeTableService, TreeTable, TTBody, TTScrollableView, TTSortableColumn, TTSortIcon, TTResizableColumn, TTReorderableColumn, TTSelectableRow, TTSelectableRowDblClick, TTContextMenuRow, TTCheckbox, TTHeaderCheckbox, TTEditableColumn, TreeTableCellEditor, TreeTableToggler, TreeTableModule, TRISTATECHECKBOX_VALUE_ACCESSOR, TriStateCheckbox, TriStateCheckboxModule } from 'primeng/primeng';
import { animate, AnimationBuilder, state, style, transition, trigger } from '@angular/animations';
import { RouterModule } from '@angular/router';
import { ObjectUtils } from 'primeng/components/utils/objectutils';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * When we have a custom component like dropdown, radiobuttonlist and
 * many more we want to provide a custom content to it like so:
 *
 * ```
 *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
 *      {{item.userName}}
 *
 *   <aw-dropdown
 *
 * ```
 * Who else would know how to render list of objects..
 *
 * But its not possible in current form. if I do not provide Angular some as they call it this
 * syntactic sugar *,
 *
 *
 * ```
 *  <aw-dropdown *mySugerDirective=.....>
 *      {{item.userName}}
 *
 *   <aw-dropdown
 * ```
 *
 *
 * then angular will not know  inside is a template and I wont be able to get hold of TemplateRef
 * inside the component
 *
 * So the only way I found (expecting I do not want to change anything in terms of bindings and the
 * signature I use it. I have to use it like this:
 *
 * ```
 *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
 *      <ng-template let-item> {{item.userName}}</ng-template>
 *
 *   <aw-dropdown
 *
 * ```
 *
 *  This way it could work. Since I am inside ngFor I want to render the item into the correct
 * viewContainer of ngFor's current item.
 *
 *  This way I can also expose item outside using Angular's special local variable called:
 * $implicit.
 *
 * This gets even more complex if we try to pass this template 2 levels down, like in case of
 * RadioButtonList. But later on I might want to refactor this into custom NG FOR
 *
 * @deprecated in favor of ngTemplateOutlet (will be removed in the next version)
 *
 */
var EmbeddedItemDirective = /** @class */ (function () {
    function EmbeddedItemDirective(_viewContainer) {
        this._viewContainer = _viewContainer;
    }
    Object.defineProperty(EmbeddedItemDirective.prototype, "item", {
        set: /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this._implicitValue = item;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    /**
     *
     * @param {?} changes
     * @return {?}
     */
    EmbeddedItemDirective.prototype.ngOnChanges = /**
     *
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (isPresent(this._viewRef)) {
            this._viewContainer.remove(this._viewContainer.indexOf(this._viewRef));
        }
        if (isPresent(this.embeddedItem)) {
            var /** @type {?} */ context = new EmbededItem(this._implicitValue);
            this._viewRef = this._viewContainer.createEmbeddedView(this.embeddedItem, context);
        }
    };
    EmbeddedItemDirective.decorators = [
        { type: Directive, args: [{ selector: '[embeddedItem]' },] },
    ];
    /** @nocollapse */
    EmbeddedItemDirective.ctorParameters = function () { return [
        { type: ViewContainerRef }
    ]; };
    EmbeddedItemDirective.propDecorators = {
        embeddedItem: [{ type: Input }],
        item: [{ type: Input }]
    };
    return EmbeddedItemDirective;
}());
/**
 * Wrapper class around Angular's EmbeddedViewRef.context()
 *
 */
var  /**
 * Wrapper class around Angular's EmbeddedViewRef.context()
 *
 */
EmbededItem = /** @class */ (function () {
    function EmbededItem($implicit) {
        this.$implicit = $implicit;
    }
    return EmbededItem;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * GenericContainerComponent is used by include-component.directive to dynamically create an
 * HTMLElement and use this element to wrap a child component. This is very useful when we want to
 * modify a child by wrapping it with a border, a background, or bold its text.
 *
 * The wrapper element is dynamically created. It's element is specified by the tagName property in
 * the bindings \@Input.
 *
 *  ### Example.  Directly in html
 *
 *   app.html
 *      <aw-generic-container tagName="tagName" bindings="bindings">
 *          <my-component ..bindings..></my-component>
 *      </aw-generic-container>
 *
 *   app.component.ts
 *
 *       tagName = (bBold) ? 'h1' : 'span';
 *       bindings = {  style: 'background-color: red' }
 *
 */
var GenericContainerComponent = /** @class */ (function () {
    /**
     * param renderer - Renderer is used to create 'tagName' element.
     */
    function GenericContainerComponent(renderer, element) {
        this.renderer = renderer;
        this.element = element;
        this.nativeElement = element.nativeElement;
    }
    /**
     * During the initialization, verify that at least one input has been set.
     */
    /**
     * During the initialization, verify that at least one input has been set.
     * @return {?}
     */
    GenericContainerComponent.prototype.ngOnInit = /**
     * During the initialization, verify that at least one input has been set.
     * @return {?}
     */
    function () {
        // If there's no input, this component wouldn't know what to do and throw exception.
        if (isBlank(this.bindings) && isBlank(this.tagName)) {
            throw new Error('GenericContainerComponent input bindings or tagName ' +
                'have not been set.');
        }
        // If the tagName is blank, the get it from bindings.
        if (isBlank(this.tagName)) {
            this.tagName = this.bindings.get('tagName');
            if (isBlank(this.tagName)) {
                this.tagName = GenericContainerComponent.DefaultTagName;
            }
        }
        // Save first added
        this.childElement = this.nativeElement.firstChild;
        this.doRender();
    };
    /**
     * @return {?}
     */
    GenericContainerComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (isPresent(this.childElement) &&
            this.childElement.parentNode !== this.nativeElement.firstChild) {
            this.nativeElement.firstChild.appendChild(this.childElement);
        }
    };
    /**
     * After content has been initialized. Create the tagName element. Apply all the bindings on to
     * the element as attribute. Finally, move the child element, <ng-content>, to inside the
     * wrapper component.
     * @return {?}
     */
    GenericContainerComponent.prototype.doRender = /**
     * After content has been initialized. Create the tagName element. Apply all the bindings on to
     * the element as attribute. Finally, move the child element, <ng-content>, to inside the
     * wrapper component.
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ el = this.renderer.createElement(this.tagName);
        if (isPresent(this.nativeElement)) {
            this.renderer.appendChild(this.nativeElement, el);
        }
        // Loop through all the bindings and add them to the element.
        MapWrapper.iterable(this.bindings).forEach(function (v, k) {
            _this.renderer.setStyle(el, k, v);
        });
        // Attach the component to this divElement.
        el.appendChild(this.childElement);
    };
    /**
     * Default tagName if none is specified inside bindings.
     *
     */
    GenericContainerComponent.DefaultTagName = 'div';
    GenericContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-generic-container',
                    template: '<ng-content></ng-content>',
                    styles: []
                },] },
    ];
    /** @nocollapse */
    GenericContainerComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef }
    ]; };
    GenericContainerComponent.propDecorators = {
        bindings: [{ type: Input }],
        tagName: [{ type: Input }]
    };
    return GenericContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  Base component shares common functionality among all the components (layouts, widgets).
 *
 * @abstract
 */
var BaseComponent = /** @class */ (function () {
    function BaseComponent(env) {
        this.env = env;
        /**
         * Adds disabled flag to the component
         *
         */
        this.disabled = false;
        /**
         * Weather this component is visible
         * Default is false;
         */
        this.visible = false;
        /**
         * Tell  the component if we are in editing mode.
         *
         */
        this.editable = true;
        /**
         * Removes padding from the component. Usually used when we are nesting other component with
         * its own grid.
         */
        this.omitPadding = false;
        /**
         * Prefix for the correct asset path
         */
        this.assetFolder = 'assets';
        this.extBindings = new Map();
        this.omitPadding = false;
    }
    /**
     * @return {?}
     */
    BaseComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.assetFolder = this.env.getValue(AppConfig.AssetFolder);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    BaseComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
    };
    /**
     * @return {?}
     */
    BaseComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    BaseComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
    };
    BaseComponent.propDecorators = {
        disabled: [{ type: Input }],
        visible: [{ type: Input }],
        editable: [{ type: Input }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        styleClass: [{ type: Input }],
        omitPadding: [{ type: Input }]
    };
    return BaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var WidgetSizeColumns = {
    xsmall: 1,
    small: 3,
    medium: 6,
    large: 9,
    xlarge: 12,
};
WidgetSizeColumns[WidgetSizeColumns.xsmall] = "xsmall";
WidgetSizeColumns[WidgetSizeColumns.small] = "small";
WidgetSizeColumns[WidgetSizeColumns.medium] = "medium";
WidgetSizeColumns[WidgetSizeColumns.large] = "large";
WidgetSizeColumns[WidgetSizeColumns.xlarge] = "xlarge";
/**
 *  BaseFormComponnet extends BaseComponent for add specific form behavior
 *
 * @abstract
 */
var BaseFormComponent = /** @class */ (function (_super) {
    __extends(BaseFormComponent, _super);
    /**
     * Some of the BaseFormComponent can wrap other component and in these cases we want to
     * inherit some of the behavior from parent
     *
     * @Inject(Environment) public env: Environment : is tem a workaround as without inject
     * on this specific component it complains that Environment is unresolved symbol
     *
     */
    function BaseFormComponent(env, parentContainer) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         *
         * Is current element visible
         */
        _this.hidden = false;
        /**
         * Renders required flex around the component
         *
         */
        _this.required = false;
        /**
         *  a text displayed when value is empty or NULL
         */
        _this.placeHolder = '';
        /**
         * Identify if this control is used directly or if its part of some other control
         * e.g. GenericChooser and managed by this control.
         * Meaning State is mananged outside of this component
         *
         */
        _this.isStandalone = true;
        _this.onModelChanged = noop;
        _this.onModelTouched = noop;
        return _this;
    }
    /**
     * @return {?}
     */
    BaseFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isPresent(this.parentContainer)) {
            this.formGroup = this.parentContainer.formGroup;
            this.editable = this.parentContainer.editable;
        }
        this.checkInitForm();
    };
    /**
     * Make sure that we have available formGroup and Name and ID
     *
     */
    /**
     * Make sure that we have available formGroup and Name and ID
     *
     * @return {?}
     */
    BaseFormComponent.prototype.checkInitForm = /**
     * Make sure that we have available formGroup and Name and ID
     *
     * @return {?}
     */
    function () {
        if (isBlank(this.env.currentForm)) {
            this.env.currentForm = new FormGroup({});
        }
        /**
                 * Todo: Right now I just need to initialize name , but ideally it needs to be generated
                 * number basedon some semantics app.page.component if there are more component on the page
                 * then app.page.componentNumber. Simple solution is to is to get Elementref and query it.
                 */
        if (isBlank(this.name)) {
            this.name = uuid();
        }
        if (isBlank(this.id)) {
            this.id = uuid();
        }
    };
    /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    BaseFormComponent.prototype.doRegister = /**
     * @param {?} name
     * @param {?} value
     * @return {?}
     */
    function (name, value) {
        var /** @type {?} */ fControl;
        if (isBlank(this.formGroup.controls[name])) {
            this.formGroup.registerControl(name, new FormControl(value));
            fControl = /** @type {?} */ (this.formGroup.controls[name]);
        }
        else {
            fControl = /** @type {?} */ (this.formGroup.controls[name]);
            var /** @type {?} */ updatedValue = isPresent(fControl.value) ? fControl.value : value;
            fControl.patchValue(updatedValue, { onlySelf: true, emitEvent: false });
        }
        return fControl;
    };
    /**
     * When we are dealing with Forms this is a helper method to register control
     *
     *
     * @param value default value to be pre-set
     */
    /**
     * When we are dealing with Forms this is a helper method to register control
     *
     *
     * @param {?} value default value to be pre-set
     * @return {?}
     */
    BaseFormComponent.prototype.registerFormControl = /**
     * When we are dealing with Forms this is a helper method to register control
     *
     *
     * @param {?} value default value to be pre-set
     * @return {?}
     */
    function (value) {
        this.formControl = this.doRegister(this.name, value);
        if (this.disabled) {
            this.formControl.disable();
        }
    };
    Object.defineProperty(BaseFormComponent.prototype, "formGroup", {
        get: /**
         * @return {?}
         */
        function () {
            return isPresent(this._formGroup) ? this._formGroup : this.env.currentForm;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._formGroup = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates if we can pass field type as a binding to the components. e.g. InputField need
     * such type to correctly render input type=text, number
     *
     * todo: is this needed? can we maybe pass this to the formRow?
     */
    /**
     * Indicates if we can pass field type as a binding to the components. e.g. InputField need
     * such type to correctly render input type=text, number
     *
     * todo: is this needed? can we maybe pass this to the formRow?
     * @return {?}
     */
    BaseFormComponent.prototype.canSetType = /**
     * Indicates if we can pass field type as a binding to the components. e.g. InputField need
     * such type to correctly render input type=text, number
     *
     * todo: is this needed? can we maybe pass this to the formRow?
     * @return {?}
     */
    function () {
        return false;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    BaseFormComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    BaseFormComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onModelChanged = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    BaseFormComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onModelTouched = fn;
    };
    /*
         *  Supported layout constants. It is expected there will be more options as we currently
         *  support only these two there will be other variations of it. e.g. for stacked it will not
         *  be 1 columns like it is now but multiple columns
         *
         */
    BaseFormComponent.LayoutStacked = 'stacked';
    BaseFormComponent.LayoutInline = 'inline';
    /** @nocollapse */
    BaseFormComponent.ctorParameters = function () { return [
        { type: Environment, decorators: [{ type: Inject, args: [Environment,] }] },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    BaseFormComponent.propDecorators = {
        name: [{ type: Input }],
        id: [{ type: Input }],
        hidden: [{ type: Input }],
        required: [{ type: Input }],
        placeHolder: [{ type: Input }],
        isStandalone: [{ type: Input }],
        formGroup: [{ type: Input }]
    };
    return BaseFormComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Simple component rendering values in the read only mode. Just needed some component used
 * to render Strings in read only mode
 *
 *
 *  ### Example
 *
 * Using it inside form container along with label
 *
 *
 *  ```
 * \@Component({
 *              selector: 'userInfo' ,
 *              template: `
 *                      <aw-form-table [editable]="false" >
 *                          <aw-form-row [name]="fieldName"  [label]="label">
 *                                 <aw-string [value]="inputValue" ></aw-string>
 *                           </aw-form-row>
 *                      </aw-form-table>
 *
 *                  `
 *          })
 *          export class UserProfileComponent
 *          {
 *              inputValue: string = 'Some text';
 *              inputType: string = 'string';
 *              fieldName: string = 'firstName';
 *              label: string = 'My Name';
 *              required: boolean = true;
 *              editing: boolean = true;
 *              labelsOnTop: boolean = false;
 *
 *          }
 *
 *  ```
 *
 * You can also pass html tags.
 *
 */
var StringComponent = /** @class */ (function (_super) {
    __extends(StringComponent, _super);
    function StringComponent(env, sanitizer, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.sanitizer = sanitizer;
        _this.parentContainer = parentContainer;
        /**
         *  Value to be interpolated
         *
         */
        _this._value = '';
        return _this;
    }
    Object.defineProperty(StringComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this.sanitizer.bypassSecurityTrustHtml(this._value);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    StringComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-string',
                    template: "\n        <span class=\"w-string-field\" [innerHTML]=\"value\"></span>\n    ",
                    styles: [".w-string-field{display:inline-block}"]
                },] },
    ];
    /** @nocollapse */
    StringComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: DomSanitizer },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    StringComponent.propDecorators = {
        value: [{ type: Input }]
    };
    return StringComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A class holding a references to components. The methods are self-explanatory.
 *
 */
var ComponentRegistry = /** @class */ (function () {
    function ComponentRegistry(env) {
        this.env = env;
        this._nameToType = new Map();
    }
    /**
     * @param {?} references
     * @return {?}
     */
    ComponentRegistry.prototype.initialize = /**
     * @param {?} references
     * @return {?}
     */
    function (references) {
        this.registerTypes(references);
        var /** @type {?} */ promise = new Promise(function (resolve) {
            resolve(true);
        });
        return promise;
    };
    /**
     * @param {?} name
     * @param {?} type
     * @return {?}
     */
    ComponentRegistry.prototype.registerType = /**
     * @param {?} name
     * @param {?} type
     * @return {?}
     */
    function (name, type) {
        if (!this.nameToType.has(name)) {
            this._nameToType.set(name, type);
        }
    };
    /**
     * @param {?} references
     * @return {?}
     */
    ComponentRegistry.prototype.registerTypes = /**
     * @param {?} references
     * @return {?}
     */
    function (references) {
        var _this = this;
        if (!isStringMap(references)) {
            return;
        }
        Object.keys(references).forEach(function (name) {
            _this.registerType(name, references[name]);
        });
    };
    Object.defineProperty(ComponentRegistry.prototype, "nameToType", {
        get: /**
         * @return {?}
         */
        function () {
            return this._nameToType;
        },
        enumerable: true,
        configurable: true
    });
    ComponentRegistry.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ComponentRegistry.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    return ComponentRegistry;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  `IncludeComponent` directive dynamically instantiate and insert a components into the screen
 * based on the name. It can accepts bindings as well which will be automatically bound and applied
 * to the component
 *
 *  ### usage:
 *
 *  Instead of inserting component in the way:
 *
 *  ```
 *    <textfield value="some value">
 *
 *  ```
 *
 *  you can do so dynamically like this:
 *
 * ```
 *  <aw-include-component 'TextfieldComponent' [bindings]=bindings ></aw-include-component>
 * ```
 *
 * This is the main building block to dynamically generated UI.
 *
 *
 * Todo: Currently the way Angular API work and we use it to create programatically components
 * is too complext we need to create everything 3 different calls to place a component to the
 * container. What I want is is to create some kind of representation of ContainerElement and this
 * can be also parent for our BaseComponent with method add and remove content. Then we could have
 * some AWContent.
 *
 * e.g.: to replace applyContentElementIfAny where we have several calls to create and add
 * component to the view.
 *
 * ```ts
 *  let containerElement = AWConcreteTemplate(viewContainer, factoryResolver)
 *  containerElement.add('Clck Me')
 * ```
 *
 * To assemble different components together - not only adding string content
 *
 * ```ts
 *  let content = new AWContent(ButtonComponent, bindingsMap)
 *  content.add('Click Me');
 *  containerElement.add(content)
 *
 * ```
 *
 * add more component hierarchy:
 *
 * ```ts
 *  let content = new AWContent(HoverCardComponnets, bindingsMap)
 *  content.add(createLayout();
 *  containerElement.add(content)
 *
 * ```
 *
 *
 *
 *
 */
var IncludeComponentDirective = /** @class */ (function () {
    function IncludeComponentDirective(viewContainer, factoryResolver, cd, compRegistry) {
        this.viewContainer = viewContainer;
        this.factoryResolver = factoryResolver;
        this.cd = cd;
        this.compRegistry = compRegistry;
        /**
         * I use this flag to identify that component is rendering for first time or its updated during
         * change detection
         *
         */
        this.initRenderInProgress = false;
        /**
         * Not sure if we need this, but want to keep it here or maybe move it to some service so we
         * can cache created components and maybe reuse them.
         *
         */
        this.componentReferences = new Map();
        this.bindings = new Map();
    }
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initRenderInProgress = true;
        // todo: check if this the right lifecycle callback, this is called only once and you want
        // to probably listen for changes, and change dection decide there is some change and we
        // need to re-draw the view
        this.viewContainer.clear();
        this.doRenderComponent();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (isPresent(changes['name']) &&
            (changes['name'].currentValue !== changes['name'].previousValue)) {
            this.viewContainer.clear();
            this.doRenderComponent();
        }
    };
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        this.initRenderInProgress = false;
    };
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // check to see if we need to render and reposition DOM element both for wrapper and
        // content
        this.createWrapperElementIfAny();
        this.createContentElementIfAny();
    };
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * Handles a case where we need to resolve additional component and wrap the current one.
     * Just like reateContentElementIfAny() this method needs to be executed after all
     * is created and initialized (inside the ngAfterViewInit() )
     *
     */
    /**
     * Handles a case where we need to resolve additional component and wrap the current one.
     * Just like reateContentElementIfAny() this method needs to be executed after all
     * is created and initialized (inside the ngAfterViewInit() )
     *
     * @return {?}
     */
    IncludeComponentDirective.prototype.createWrapperElementIfAny = /**
     * Handles a case where we need to resolve additional component and wrap the current one.
     * Just like reateContentElementIfAny() this method needs to be executed after all
     * is created and initialized (inside the ngAfterViewInit() )
     *
     * @return {?}
     */
    function () {
    };
    /**
     * Renders a component into actual View Container. The process goes as this.
     *  1. We retrieve component Type based on the component name, which creates componentRef
     *  2. Place the component onto the screen
     *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
     *  4. Manually spin change detection to update the screen. Mainly for case where I need to
     * redraw a screen
     */
    /**
     * Renders a component into actual View Container. The process goes as this.
     *  1. We retrieve component Type based on the component name, which creates componentRef
     *  2. Place the component onto the screen
     *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
     *  4. Manually spin change detection to update the screen. Mainly for case where I need to
     * redraw a screen
     * @return {?}
     */
    IncludeComponentDirective.prototype.doRenderComponent = /**
     * Renders a component into actual View Container. The process goes as this.
     *  1. We retrieve component Type based on the component name, which creates componentRef
     *  2. Place the component onto the screen
     *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
     *  4. Manually spin change detection to update the screen. Mainly for case where I need to
     * redraw a screen
     * @return {?}
     */
    function () {
        var _this = this;
        this.placeTheComponent();
        // this.currentComponent.changeDetectorRef.detach();
        this.applyBindings(this.componentReference(), this.currentComponent, this.bindings);
        // this.currentComponent.changeDetectorRef.detectChanges();
        // Still not sure about this what all I should release here.
        this.currentComponent.onDestroy(function () {
            // this.bindings.clear();
            // this.bindings = undefined;
            //
            // this.componentReferences.clear();
            // this.componentReferences = undefined;
            // this.bindings.clear();
            // this.bindings = undefined;
            //
            // this.componentReferences.clear();
            // this.componentReferences = undefined;
            _this.destroy();
        });
    };
    /**
     * Place actual component onto the screen using ViewContainerRef
     *
     */
    /**
     * Place actual component onto the screen using ViewContainerRef
     *
     * @return {?}
     */
    IncludeComponentDirective.prototype.placeTheComponent = /**
     * Place actual component onto the screen using ViewContainerRef
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ reference = this.componentReference();
        this.currentComponent = this.viewContainer.createComponent(reference.resolvedCompFactory);
    };
    /**
     * When inserting Component that needs to have a content like e.g. hyperlink or button
     *
     * ```
     *   <button> MY NG CONTENT </button>
     *
     * ```
     *  this method applies and insert a child content into the main component. This method insert
     * a simple string. We are not wrapping existing component with another component here.
     *
     * @return need to run detect changes ? default is false
     */
    /**
     * When inserting Component that needs to have a content like e.g. hyperlink or button
     *
     * ```
     *   <button> MY NG CONTENT </button>
     *
     * ```
     *  this method applies and insert a child content into the main component. This method insert
     * a simple string. We are not wrapping existing component with another component here.
     *
     * @return {?} need to run detect changes ? default is false
     */
    IncludeComponentDirective.prototype.createContentElementIfAny = /**
     * When inserting Component that needs to have a content like e.g. hyperlink or button
     *
     * ```
     *   <button> MY NG CONTENT </button>
     *
     * ```
     *  this method applies and insert a child content into the main component. This method insert
     * a simple string. We are not wrapping existing component with another component here.
     *
     * @return {?} need to run detect changes ? default is false
     */
    function () {
        var /** @type {?} */ detectChanges = false;
        var /** @type {?} */ ngContent = this.ngContent();
        var /** @type {?} */ ngContentElement = this.ngContentElement();
        if (isPresent(ngContent)) {
            var /** @type {?} */ awContentComponent = this.factoryResolver.resolveComponentFactory(StringComponent);
            var /** @type {?} */ component = this.viewContainer.createComponent(awContentComponent, 0);
            (/** @type {?} */ (component.instance)).value = ngContent;
            var /** @type {?} */ awContentContainer = this.currentComponent.location.nativeElement.firstChild;
            awContentContainer.appendChild(component.location.nativeElement);
            detectChanges = true;
        }
        else if (isPresent(ngContentElement)) ;
        return detectChanges;
    };
    /**
     *
     * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
     * applying other bindings.
     *
     */
    /**
     *
     * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
     * applying other bindings.
     *
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngContent = /**
     *
     * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
     * applying other bindings.
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ content;
        if (isPresent(content = this.bindings.get(IncludeComponentDirective.NgContent))) {
            this.bindings.delete(IncludeComponentDirective.NgContent);
        }
        return content;
    };
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngContentElement = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ content;
        if (isPresent(content = this.bindings.get(IncludeComponentDirective.NgContentElement))) {
            this.bindings.delete(IncludeComponentDirective.NgContentElement);
        }
        return content;
    };
    /**
     * We need to convert a component name to actual a type and then use ComponentFactoryResolver
     * to instantiate a a component and save its information into our component references. The
     * reason why we have this component reference is we need to store Angular's component metadata
     * so we can iterate thru all the inputs and bind them to the context.
     *
     * returns {ComponentReference} a reference representing a compoent currently being rendered
     */
    /**
     * We need to convert a component name to actual a type and then use ComponentFactoryResolver
     * to instantiate a a component and save its information into our component references. The
     * reason why we have this component reference is we need to store Angular's component metadata
     * so we can iterate thru all the inputs and bind them to the context.
     *
     * returns {ComponentReference} a reference representing a compoent currently being rendered
     * @return {?}
     */
    IncludeComponentDirective.prototype.componentReference = /**
     * We need to convert a component name to actual a type and then use ComponentFactoryResolver
     * to instantiate a a component and save its information into our component references. The
     * reason why we have this component reference is we need to store Angular's component metadata
     * so we can iterate thru all the inputs and bind them to the context.
     *
     * returns {ComponentReference} a reference representing a compoent currently being rendered
     * @return {?}
     */
    function () {
        if (isPresent(this.resolvedComponentRef)) {
            return this.resolvedComponentRef;
        }
        var /** @type {?} */ currType = this.resolveComponentType();
        var /** @type {?} */ componentFactory = this.factoryResolver
            .resolveComponentFactory(currType);
        var /** @type {?} */ componentMeta = this.resolveDirective(componentFactory);
        var /** @type {?} */ compReference = {
            metadata: componentMeta,
            resolvedCompFactory: componentFactory,
            componentType: currType,
            componentName: this.name
        };
        this.resolvedComponentRef = compReference;
        return compReference;
    };
    /**
     * Iterates thru ComponentMetadata @Inputs() and check if we have available binding inside the
     * 'this.bindings'
     */
    /**
     * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
     * 'this.bindings'
     * @param {?} cRef
     * @param {?} component
     * @param {?} bindings
     * @return {?}
     */
    IncludeComponentDirective.prototype.applyBindings = /**
     * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
     * 'this.bindings'
     * @param {?} cRef
     * @param {?} component
     * @param {?} bindings
     * @return {?}
     */
    function (cRef, component, bindings) {
        var /** @type {?} */ inputs = cRef.metadata.inputs;
        if (isBlank(inputs) || inputs.length === 0) {
            return;
        }
        // should we do any type conversion?
        MapWrapper.iterable(bindings).forEach(function (v, k) {
            if (isPresent(component.instance[k])) {
                component.instance[k] = v;
            }
        });
    };
    /**
     * Resolves a component Type based on the string literal
     *
     * @returns component type used by `ComponentFactoryResolver`
     *
     * todo: rename the method so its clear that it returns component type based on string.
     */
    /**
     * Resolves a component Type based on the string literal
     *
     * @return {?} component type used by `ComponentFactoryResolver`
     *
     * todo: rename the method so its clear that it returns component type based on string.
     */
    IncludeComponentDirective.prototype.resolveComponentType = /**
     * Resolves a component Type based on the string literal
     *
     * @return {?} component type used by `ComponentFactoryResolver`
     *
     * todo: rename the method so its clear that it returns component type based on string.
     */
    function () {
        var /** @type {?} */ componentType = this.compRegistry.nameToType.get(this.name);
        if (isBlank(componentType)) {
            assert(false, this.name + ' component does not exists. Create Dummy Component instead' +
                ' of throwing this error');
            return;
        }
        return componentType;
    };
    /**
     * @param {?} compFactory
     * @return {?}
     */
    IncludeComponentDirective.prototype.resolveDirective = /**
     * @param {?} compFactory
     * @return {?}
     */
    function (compFactory) {
        var /** @type {?} */ compMeta = {
            inputs: [],
            outputs: []
        };
        if (isPresent(compFactory.inputs) && compFactory.inputs.length > 0) {
            compFactory.inputs.forEach(function (input) {
                compMeta.inputs.push(input.propName);
            });
        }
        if (isPresent(compFactory.outputs) && compFactory.outputs.length > 0) {
            compFactory.outputs.forEach(function (output) {
                compMeta.outputs.push(output.propName);
            });
        }
        return compMeta;
    };
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (isPresent(this.currentComponent)) {
            this.currentComponent.destroy();
            this.currentComponent = undefined;
        }
        if (isPresent(this.viewContainer)) {
            this.viewContainer.clear();
        }
    };
    /**
     * @return {?}
     */
    IncludeComponentDirective.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (isPresent(this.currentComponent)) {
            this.currentComponent = null;
            this.resolvedComponentRef = null;
        }
    };
    IncludeComponentDirective.NgContent = 'ngcontent';
    IncludeComponentDirective.NgContentElement = 'ngcontentElement';
    IncludeComponentDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'aw-include-component'
                },] },
    ];
    /** @nocollapse */
    IncludeComponentDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: ComponentRegistry }
    ]; };
    IncludeComponentDirective.propDecorators = {
        name: [{ type: Input }],
        bindings: [{ type: Input }]
    };
    return IncludeComponentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Error Manager is a service used by Forms components to map error codes into meaningful messages.
 * Currently it does not have much but once we plug in localization it will make more sense
 *
 *
 * todo: Once ng-translate is implemented replace this with ng-translate functionality so we can
 * externalize these messages into locale files.
 *
 */
var ErrorManagerService = /** @class */ (function () {
    function ErrorManagerService() {
        this.messages = {
            'required': 'Required field',
            'minlength': 'Field does not meet minimum length',
            'maxlength': 'Field does not meet maximum length',
            'customMsg': '%s',
            'metavalid': '%s'
        };
    }
    /**
     * @param {?} validatorName
     * @param {?=} validatorValue
     * @return {?}
     */
    ErrorManagerService.prototype.errorMessage = /**
     * @param {?} validatorName
     * @param {?=} validatorValue
     * @return {?}
     */
    function (validatorName, validatorValue) {
        var /** @type {?} */ message = this.messages[validatorName];
        if (StringWrapper.contains(message, '%s')) {
            // todo: use ng-translate with proper message formatting
            return StringWrapper.replace(message, '%s', validatorValue.msg);
        }
        return message;
    };
    ErrorManagerService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ErrorManagerService.ctorParameters = function () { return []; };
    return ErrorManagerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * ErrorMessagesComponent is used by form's component like FormRow to print its validation errors.
 * Its  based on ModelDriven (Reactive forms) and it reads errors from FormControl
 *
 *
 *
 */
var ErrorMessagesComponent = /** @class */ (function () {
    function ErrorMessagesComponent(errManager) {
        this.errManager = errManager;
    }
    /**
     * @return {?}
     */
    ErrorMessagesComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    ErrorMessagesComponent.prototype.hasMessage = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ msg = this.errorMsg;
        return isPresent(msg);
    };
    Object.defineProperty(ErrorMessagesComponent.prototype, "errorMsg", {
        /**
         * Retrieve a messages if any registered by added validators
         *
         */
        get: /**
         * Retrieve a messages if any registered by added validators
         *
         * @return {?}
         */
        function () {
            for (var /** @type {?} */ propertyName in this.control.errors) {
                if (this.control.errors.hasOwnProperty(propertyName) && this.control.touched) {
                    return this.errManager.errorMessage(propertyName, this.control.errors[propertyName]);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * Show errors? We currently shows errors if the control is not valid, it was touched by user.
     * Most of the type on blur event  and at last its not pristine anymore (its dirty)
     *
     */
    /**
     *
     * Show errors? We currently shows errors if the control is not valid, it was touched by user.
     * Most of the type on blur event  and at last its not pristine anymore (its dirty)
     *
     * @return {?}
     */
    ErrorMessagesComponent.prototype.showErrors = /**
     *
     * Show errors? We currently shows errors if the control is not valid, it was touched by user.
     * Most of the type on blur event  and at last its not pristine anymore (its dirty)
     *
     * @return {?}
     */
    function () {
        return !this.control.valid && !this.control.pristine && this.control.touched;
    };
    ErrorMessagesComponent.decorators = [
        { type: Component, args: [{
                    selector: 'a-error-messages',
                    template: "\n            <div class=\"ui-g\">\n                    <small *ngIf=\"hasMessage()\"\n                        class=\"ui-g-12 ui-message ui-messages-error ui-corner-all\">\n                        {{ errorMsg }}\n                    </small>\n            </div>\n    ",
                    styles: [""]
                },] },
    ];
    /** @nocollapse */
    ErrorMessagesComponent.ctorParameters = function () { return [
        { type: ErrorManagerService }
    ]; };
    ErrorMessagesComponent.propDecorators = {
        control: [{ type: Input }]
    };
    return ErrorMessagesComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Modal service is used to to create modal dialogs. It creates modal dialogs dynamically.
 * The service also keeps track of the created modal dialog and can close it by calling the
 * service's close()
 *
 * Modal service requires a ViewContainer to insert newly created modals. This is taken care
 * by the ModalComponent.
 *
 * Usage:
 *     Add   <aw-modal></aw-modal>  into your application main html. It needs to be on every
 *     page where a modal dialog will appear.
 *
 *    1.  Popup a dialog without creating your own component.
 *        Use the existing DialogComponent in widgets.
 *
 *             this.modalService.open<DialogComponent>(DialogComponent, {
 *                     title: 'My Popup Title',
 *                     body: 'My Popup Body'
 *              });
 *
 *
 *   2.   Creating your own Dialog Component to popup.
 *
 *         let componentRef = this.modalService.open<MyDialogComponent>(MyDialogComponent,
 * {inputs});
 *
 * \@Component({
 *                selector: 'aw-mydialog' ,
 *                           template: `
 *                                         <aw-dialog (onClose)="closePopup()">
 *                                              <ng-template #titleTemplate>
 *                                                 <span><i class="fa fa-envira" ></i>This is my
 *     Title </span>
 *                                              </ng-template>
 *                                              <ng-template #bodyTemplate>
 *                                                 <span><i class="fa fa-envira" ></i>This is my
 *     Body </span>
 *                                              </ng-template>
 *                                        </aw-dialog>
 *                                     `
 *         })
 *         export class MyDialogComponent extends DialogComponent implements OnInit {
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     closePopup() {
 *                            this.modalService.close();
 *                      }
 *         }
 */
var ModalService = /** @class */ (function () {
    /**
     * DI ComponentFactoryResolver to be used to create modal component.
     *
     * @param cfr
     */
    function ModalService(cfr) {
        this.cfr = cfr;
    }
    /**
     *  PlaceHolder for modal to be inserted.
     *
     * @param vcRef
     */
    /**
     *  PlaceHolder for modal to be inserted.
     *
     * @param {?} vcRef
     * @return {?}
     */
    ModalService.prototype.registerViewContainerRef = /**
     *  PlaceHolder for modal to be inserted.
     *
     * @param {?} vcRef
     * @return {?}
     */
    function (vcRef) {
        this.vcRef = vcRef;
    };
    /**
     * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
     *
     */
    /**
     * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
     *
     * @template T
     * @param {?} component
     * @param {?=} parameters
     * @return {?}
     */
    ModalService.prototype.open = /**
     * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
     *
     * @template T
     * @param {?} component
     * @param {?=} parameters
     * @return {?}
     */
    function (component, parameters) {
        var /** @type {?} */ cf = this.cfr.resolveComponentFactory(component);
        var /** @type {?} */ componentRef = this.vcRef.createComponent(cf);
        // Auto set visiblity to true. So that the Dialog will display
        parameters = (parameters) ? parameters : {};
        parameters['visible'] = true;
        // Handle output parameters.
        ModalService.OUTPUT_PARAMETERS.forEach(function (param) {
            if (parameters[param]) {
                (/** @type {?} */ (componentRef.instance))[param].subscribe(parameters[param]);
                delete parameters[param];
            }
        });
        Object.assign(componentRef.instance, parameters);
        // had to cast it in order to avoid any index Error
        // Attach a destroy method to the newly created component.
        (/** @type {?} */ (componentRef.instance))['destroy'] = function () {
            componentRef.destroy();
        };
        // Save the instance, so it can be destroyed later.
        this.instance = componentRef;
        return componentRef;
    };
    /**
     * Calling close() will remove the modal from view.
     */
    /**
     * Calling close() will remove the modal from view.
     * @return {?}
     */
    ModalService.prototype.close = /**
     * Calling close() will remove the modal from view.
     * @return {?}
     */
    function () {
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
    };
    /**
     * This is a static list of output parameter from Dialog, Confirmation components
     * that needs to be handled.
     *
     */
    ModalService.OUTPUT_PARAMETERS = ['onClose', 'onConfirm', 'onCancel'];
    ModalService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ModalService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver }
    ]; };
    return ModalService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Place holder for all modal dialogs. This component works with the modalService by providing
 * a place holder for it to inject Dialog component into.
 */
var ModalComponent = /** @class */ (function () {
    function ModalComponent(modalService) {
        this.modalService = modalService;
    }
    /**
     * @return {?}
     */
    ModalComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.modalService.registerViewContainerRef(this.viewContainerRef);
    };
    ModalComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-modal',
                    template: "<div #modal></div>\n",
                    styles: [""]
                },] },
    ];
    /** @nocollapse */
    ModalComponent.ctorParameters = function () { return [
        { type: ModalService }
    ]; };
    ModalComponent.propDecorators = {
        viewContainerRef: [{ type: ViewChild, args: ['modal', { read: ViewContainerRef },] }]
    };
    return ModalComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This currency formatter will ignore null and empty string for value.
 * Issue : https://github.com/angular/angular/issues/8694  DI fails when extends other classes
 */
var CurrencyFormatPipe = /** @class */ (function () {
    function CurrencyFormatPipe(currencyPipe) {
        this.currencyPipe = currencyPipe;
    }
    /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    CurrencyFormatPipe.prototype.transform = /**
     * @param {?} value
     * @param {...?} args
     * @return {?}
     */
    function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // Default values
        var /** @type {?} */ currencyCode = 'USD', /** @type {?} */ symbolDisplay = true, /** @type {?} */ digits = '1.0-2';
        if (!value || value.length === 0) {
            return value;
        }
        if (args && args.length > 0) {
            var /** @type {?} */ code = args[0];
            if (code && code.length > 0) {
                currencyCode = code;
            }
        }
        return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
    };
    CurrencyFormatPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'currencyFormat',
                    pure: false
                },] },
    ];
    /** @nocollapse */
    CurrencyFormatPipe.ctorParameters = function () { return [
        { type: CurrencyPipe }
    ]; };
    return CurrencyFormatPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Simple utility directive that is used by NG For cycle in situation where we need to call a
 * or execute some logic after each iteration
 */
var NgForSetDirective = /** @class */ (function () {
    function NgForSetDirective() {
        this.onItem = new EventEmitter();
    }
    /**
     * @return {?}
     */
    NgForSetDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.onItem.emit('--');
    };
    NgForSetDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngForSet]'
                },] },
    ];
    /** @nocollapse */
    NgForSetDirective.ctorParameters = function () { return []; };
    NgForSetDirective.propDecorators = {
        onItem: [{ type: Output }]
    };
    return NgForSetDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Simple convenient service to work with the dom. All the future logic related to DOM manipulation
 * or traversal should be put into this service
 *
 */
var DomUtilsService = /** @class */ (function () {
    function DomUtilsService() {
    }
    /**
     * goes all the way up to the body and checks if there is a element identified by a 'selector'
     *
     */
    /**
     * goes all the way up to the body and checks if there is a element identified by a 'selector'
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    DomUtilsService.prototype.hasParent = /**
     * goes all the way up to the body and checks if there is a element identified by a 'selector'
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    function (nativeElement, selector) {
        return isPresent(this.closest(nativeElement, selector));
    };
    /**
     *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
     * not found
     *
     */
    /**
     *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
     * not found
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    DomUtilsService.prototype.closest = /**
     *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
     * not found
     *
     * @param {?} nativeElement
     * @param {?} selector
     * @return {?}
     */
    function (nativeElement, selector) {
        var /** @type {?} */ firstChar = selector.charAt(0);
        var /** @type {?} */ parentNode = nativeElement;
        while (isPresent((parentNode = parentNode.parentNode))) {
            if (firstChar === '.' && parentNode.classList.contains(selector.substr(1))) {
                return parentNode;
            }
            if (firstChar === '#' && parentNode.id === selector.substr(1)) {
                return parentNode;
            }
            // If selector is a tag
            if (parentNode.nodeType === 1 && parentNode.tagName.toLowerCase() === selector) {
                return parentNode;
            }
            if (parentNode.nodeType === 1 && parentNode.tagName === 'BODY') {
                return null;
            }
        }
        return null;
    };
    /**
     * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
     * which always corresponds with _nghost_INDEX, this works fine if we have actual component
     * that is already rendered. If we are creating component programatically there is no way to
     * identify where the actual ng-content is placed within the component
     *
     * e.g. Consider following example:
     *
     *
     * Button Component Template:
     *
     * ```
     *  <span class=mybuttonTitle><ng-content></ng-content></span>
     * ```
     *
     * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
     *
     * ```
     * <aw-button _nghost_123>
     *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
     * </aw-button>
     * ```
     *
     * But with programmatic API you instantiate Button and since it created without a Content it
     * looks like this;
     *
     *  ```
     * <aw-button _nghost_123>
     *  <span class=mybuttonTitle></span>
     * </aw-button>
     * ```
     *
     * Where do you place you child (content component)? Therefore utility css class was created
     * to wrap <ng-content> to get around this limitation.
     *
     *  ```
     *   <span class="u-ngcontent">
     *      <ng-content></ng-content>
     *   </span>
     *  ````
     *
     *
     *
     *
     */
    /**
     * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
     * which always corresponds with _nghost_INDEX, this works fine if we have actual component
     * that is already rendered. If we are creating component programatically there is no way to
     * identify where the actual ng-content is placed within the component
     *
     * e.g. Consider following example:
     *
     *
     * Button Component Template:
     *
     * ```
     *  <span class=mybuttonTitle><ng-content></ng-content></span>
     * ```
     *
     * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
     *
     * ```
     * <aw-button _nghost_123>
     *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
     * </aw-button>
     * ```
     *
     * But with programmatic API you instantiate Button and since it created without a Content it
     * looks like this;
     *
     *  ```
     * <aw-button _nghost_123>
     *  <span class=mybuttonTitle></span>
     * </aw-button>
     * ```
     *
     * Where do you place you child (content component)? Therefore utility css class was created
     * to wrap <ng-content> to get around this limitation.
     *
     *  ```
     *   <span class="u-ngcontent">
     *      <ng-content></ng-content>
     *   </span>
     *  ````
     *
     *
     *
     *
     * @param {?} parentNativeEl
     * @param {?} childNativeEl
     * @return {?}
     */
    DomUtilsService.prototype.insertIntoParentNgContent = /**
     * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
     * which always corresponds with _nghost_INDEX, this works fine if we have actual component
     * that is already rendered. If we are creating component programatically there is no way to
     * identify where the actual ng-content is placed within the component
     *
     * e.g. Consider following example:
     *
     *
     * Button Component Template:
     *
     * ```
     *  <span class=mybuttonTitle><ng-content></ng-content></span>
     * ```
     *
     * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
     *
     * ```
     * <aw-button _nghost_123>
     *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
     * </aw-button>
     * ```
     *
     * But with programmatic API you instantiate Button and since it created without a Content it
     * looks like this;
     *
     *  ```
     * <aw-button _nghost_123>
     *  <span class=mybuttonTitle></span>
     * </aw-button>
     * ```
     *
     * Where do you place you child (content component)? Therefore utility css class was created
     * to wrap <ng-content> to get around this limitation.
     *
     *  ```
     *   <span class="u-ngcontent">
     *      <ng-content></ng-content>
     *   </span>
     *  ````
     *
     *
     *
     *
     * @param {?} parentNativeEl
     * @param {?} childNativeEl
     * @return {?}
     */
    function (parentNativeEl, childNativeEl) {
        // default behavior is to insert it as child to parentNativeEl
        var /** @type {?} */ ngContentParent = parentNativeEl;
        var /** @type {?} */ foundNgContent = parentNativeEl.querySelector('.u-ngcontent');
        if (isPresent(foundNgContent)) {
            // we don't cover a case where there could be multiple ngcontents
            ngContentParent = foundNgContent;
        }
        ngContentParent.appendChild(childNativeEl);
    };
    /**
     *
     * Retrieves current browser window width and height
     *
     */
    /**
     *
     * Retrieves current browser window width and height
     *
     * @return {?}
     */
    DomUtilsService.prototype.browserDimentions = /**
     *
     * Retrieves current browser window width and height
     *
     * @return {?}
     */
    function () {
        return {
            width: (window.innerWidth || document.documentElement.clientWidth
                || document.body.clientWidth),
            height: (window.innerHeight || document.documentElement.clientHeight
                || document.body.clientHeight)
        };
    };
    /**
     *
     * Retrieves elemements dimensions
     *
     */
    /**
     *
     * Retrieves elemements dimensions
     *
     * @param {?} element
     * @return {?}
     */
    DomUtilsService.prototype.elementDimensions = /**
     *
     * Retrieves elemements dimensions
     *
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (isPresent(element.getBoundingClientRect)) {
            return element.getBoundingClientRect();
        }
        return { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0, width: 0, height: 0 };
    };
    DomUtilsService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DomUtilsService.ctorParameters = function () { return []; };
    return DomUtilsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The Infinite Scroll allows you to perform an action when the user
 * scrolls a specified distance from the bottom or top of the page.
 *
 * The expression assigned to the `infinite` event is called when
 * the user scrolls to the specified distance. When this expression
 * has finished its tasks, it should call the `complete()` method
 * on the infinite scroll instance.
 *
 * ## Usage
 *
 * ```html
 *
 *  <div  *ngFor="let item of items">{{item}} </div>
 *   <aw-infinite-scroll (onLoad)="doInfinite($event)">
 *  </aw-infinite-scroll>
 *
 * ```
 *
 *
 * You can also set a threshold to change the distance when the lazy load kicks
 * in.
 * ## Usage
 *
 * ```html
 *
 *  <div  *ngFor="let item of items">{{item}} </div>
 *   <aw-infinite-scroll (onLoad)="doInfinite($event)"  [distance]="'15%'">
 *  </aw-infinite-scroll>
 *
 * ```
 */
var InfiniteScrollComponent = /** @class */ (function () {
    function InfiniteScrollComponent(_render, _zone, domUtils, _cd) {
        this._render = _render;
        this._zone = _zone;
        this.domUtils = domUtils;
        this._cd = _cd;
        this._lastCheck = 0;
        this._lastScrollTop = 0;
        this._thr = '10%';
        this._thrPx = 0;
        this._thrPc = 0.10;
        this._init = false;
        /**
         * \@internal
         */
        this.state = STATE_ENABLED;
        /**
         * \@output {event} Emitted when the scroll reaches
         * the threshold distance. From within your infinite handler,
         * you must call the infinite scroll's `complete()` method when
         * your async operation has completed.
         */
        this.onLoad = new EventEmitter();
        /**
         *
         * Lazy load current numbers. tell the app starting point and what is the size of loaded
         * list
         *
         */
        this.fetchSize = 0;
        this.loadOffset = 0;
    }
    Object.defineProperty(InfiniteScrollComponent.prototype, "distance", {
        /**
         * @input {string} The threshold distance from the bottom
         * of the content to call the `onLoad` output event when scrolled.
         * The threshold value can be either a percent, or
         * in pixels. For example, use the value of `10%` for the `infinite`
         * output event to get called when the user has scrolled 10%
         * from the bottom of the page. Use the value `100px` when the
         * scroll is within 100 pixels from the bottom of the page.
         * Default is `15%`.
         */
        get: /**
         * \@input {string} The threshold distance from the bottom
         * of the content to call the `onLoad` output event when scrolled.
         * The threshold value can be either a percent, or
         * in pixels. For example, use the value of `10%` for the `infinite`
         * output event to get called when the user has scrolled 10%
         * from the bottom of the page. Use the value `100px` when the
         * scroll is within 100 pixels from the bottom of the page.
         * Default is `15%`.
         * @return {?}
         */
        function () {
            return this._thr;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._thr = val;
            if (val.indexOf('%') > -1) {
                this._thrPx = 0;
                this._thrPc = (parseFloat(val) / 100);
            }
            else {
                this._thrPx = parseFloat(val);
                this._thrPc = 0;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollComponent.prototype, "enabled", {
        /**
         * @input {boolean} If true, Whether or not the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         */
        set: /**
         * \@input {boolean} If true, Whether or not the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @param {?} shouldEnable
         * @return {?}
         */
        function (shouldEnable) {
            this.enable(shouldEnable);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._render.addClass(document.body, 'has-infinite-scroll');
    };
    /**
     * @param {?} ev
     * @return {?}
     */
    InfiniteScrollComponent.prototype._onScroll = /**
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
            return;
        }
        // must throttle the class by 100ms
        if (this._lastCheck + 100 > ev.timeStamp) {
            // no need to check less than every XXms
            return;
        }
        this._lastCheck = ev.timeStamp;
        var /** @type {?} */ scrollTop = this.scrollTop();
        var /** @type {?} */ winHeight = this.domUtils.browserDimentions().height;
        var /** @type {?} */ height = Math.max(this._docBody.scrollHeight, this._docBody.offsetHeight, winHeight, this._content.scrollHeight, this._content.offsetHeight);
        if (!height) {
            // if there is no height of this element then do nothing
            return;
        }
        var /** @type {?} */ threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
        var /** @type {?} */ distanceFromInfinite = this._content.scrollHeight - winHeight - scrollTop - threshold;
        // console.log('Document height (' + height + ') , Distance from bottom '
        // + distanceFromInfinite + ',  => threshold = ' +
        //     this.distance + ' (' + threshold + ')');
        if (distanceFromInfinite < 0 && this._lastScrollTop < scrollTop) {
            this.fireOnLazyLoad();
        }
        else if (this._lastScrollTop > scrollTop && scrollTop < winHeight
            && this.loadOffset !== this.fetchSize) {
            this.fireOnLazyUnLoad();
        }
        this._lastScrollTop = scrollTop;
        return;
    };
    /**
     * Todo: refactor to one method
     * @return {?}
     */
    InfiniteScrollComponent.prototype.fireOnLazyLoad = /**
     * Todo: refactor to one method
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.run(function () {
            if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                _this.state = STATE_LOADING;
                _this.onLoad.emit({
                    isLoad: true,
                    limit: _this.fetchSize,
                    offset: _this.loadOffset
                });
                // start on the next record
                // start on the next record
                _this.loadOffset += _this.fetchSize;
            }
        });
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.fireOnLazyUnLoad = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.run(function () {
            if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                _this.state = STATE_LOADING;
                // start on the next record
                // start on the next record
                _this.loadOffset = _this.fetchSize;
                _this.onLoad.emit({
                    isLoad: false,
                    limit: _this.fetchSize,
                    offset: _this.loadOffset
                });
            }
        });
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.scrollTop = /**
     * @return {?}
     */
    function () {
        return (window.pageYOffset || this._content.scrollTop);
    };
    /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     */
    /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     * @return {?}
     */
    InfiniteScrollComponent.prototype.complete = /**
     * Call `complete()` within the `infinite` output event handler when
     * your async operation has completed. For example, the `loading`
     * state is while the app is performing an asynchronous operation,
     * such as receiving more data from an AJAX request to add more items
     * to a data list. Once the data has been received and UI updated, you
     * then call this method to signify that the loading has completed.
     * This method will change the infinite scroll's state from `loading`
     * to `enabled`.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.state !== STATE_LOADING) {
            return;
        }
        setTimeout(function () {
            _this.state = STATE_ENABLED;
            // need to trigger extra detect changes to rerender loading icon
            // need to trigger extra detect changes to rerender loading icon
            _this._cd.detectChanges();
        }, 100);
    };
    /**
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     * @param shouldEnable  If the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     */
    /**
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     * @param {?} shouldEnable  If the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     * @return {?}
     */
    InfiniteScrollComponent.prototype.enable = /**
     * Call `enable(false)` to disable the infinite scroll from actively
     * trying to receive new data while scrolling. This method is useful
     * when it is known that there is no more data that can be added, and
     * the infinite scroll is no longer needed.
     * @param {?} shouldEnable  If the infinite scroll should be
     * enabled or not. Setting to `false` will remove scroll event listeners
     * and hide the display.
     * @return {?}
     */
    function (shouldEnable) {
        this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
        this._setListeners(shouldEnable);
    };
    /**
     * Subscribes to native windows scroll event
     */
    /**
     * Subscribes to native windows scroll event
     * @param {?} shouldListen
     * @return {?}
     */
    InfiniteScrollComponent.prototype._setListeners = /**
     * Subscribes to native windows scroll event
     * @param {?} shouldListen
     * @return {?}
     */
    function (shouldListen) {
        var _this = this;
        if (this._init) {
            if (shouldListen) {
                if (!this._scLsn) {
                    this._zone.runOutsideAngular(function () {
                        _this._scLsn = _this._onScroll.bind(_this);
                        window.addEventListener('scroll', _this._scLsn);
                    });
                }
            }
            else {
                if (isPresent(this._scLsn)) {
                    window.removeEventListener('scroll', this._scLsn);
                    this._scLsn = null;
                }
            }
        }
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.isLoading = /**
     * @return {?}
     */
    function () {
        return this.state === STATE_LOADING;
    };
    /**
     * @return {?}
     */
    InfiniteScrollComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this._init = true;
        this._docBody = document.body;
        this._content = document.documentElement;
        this._setListeners(this.state !== STATE_DISABLED);
        if (this.loadOffset === 0) {
            this.fireOnLazyLoad();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    InfiniteScrollComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._setListeners(false);
    };
    InfiniteScrollComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-infinite-scroll',
                    template: "<div class=\"w-infinite-loader-panel\" *ngIf=\"isLoading()\">\n    <span class=\"sap-icon icon-synchronize u-spin-icon\"></span>\n</div>\n",
                    styles: [".w-infinite-loader-panel{display:flex;align-items:center;justify-content:center;background-color:#fff;width:100%;height:100px;z-index:300;bottom:100px}.w-infinite-loader-panel span{color:#4a4a4a;font-size:2em}"],
                },] },
    ];
    /** @nocollapse */
    InfiniteScrollComponent.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: NgZone },
        { type: DomUtilsService },
        { type: ChangeDetectorRef }
    ]; };
    InfiniteScrollComponent.propDecorators = {
        distance: [{ type: Input }],
        enabled: [{ type: Input }],
        onLoad: [{ type: Output }],
        loadPanel: [{ type: ViewChild, args: ['loadinPanel',] }],
        fetchSize: [{ type: Input }]
    };
    return InfiniteScrollComponent;
}());
var /** @type {?} */ STATE_ENABLED = 'enabled';
var /** @type {?} */ STATE_DISABLED = 'disabled';
var /** @type {?} */ STATE_LOADING = 'loading';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AwNameStore = /** @class */ (function () {
    function AwNameStore() {
        this.store = new Map();
    }
    /**
     * @param {?} name
     * @param {?} el
     * @return {?}
     */
    AwNameStore.prototype.add = /**
     * @param {?} name
     * @param {?} el
     * @return {?}
     */
    function (name, el) {
        if (this.collides(name)) {
            throw new Error('Name is not unique!');
        }
        return this.store.set(name, el);
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AwNameStore.prototype.remove = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return this.store.delete(name);
    };
    /**
     * @param {?} name
     * @return {?}
     */
    AwNameStore.prototype.collides = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return this.store.has(name);
    };
    /**
     * @return {?}
     */
    AwNameStore.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.store.clear();
    };
    AwNameStore.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    AwNameStore.ctorParameters = function () { return []; };
    return AwNameStore;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The 'awName' directive attaches a identifier to decorated element to aid selectors for testing
 * purposes. The 'awName' directive tries to generate a unique identifier based on contextual data
 * and inherant immutable element attributes.
 *
 * **Generating the Base Name**
 *
 * The 'awName' directive generates a base name from element tag name and attributes which are
 * static by nature.
 *
 *     Example:
 *         <button name="order" awName>
 *
 *     Result:
 *         <button name="order" awname="button_order">
 *
 * If the element has an 'id', that value takes precedent and is used instead of a generated
 * name.
 *
 *     Example:
 *         <button name="order" id="myOrderButton" awName>
 *
 *     Result:
 *         <button name="order" id="myOrderButton" awname="button_myOrderButton">
 *
 *
 * **Repeated Elements and the 'ext' Parameter**
 *
 * There are many cases where elements are generated dynamically in the code as lists or tables.
 * In such cases, it may not be easy to distinguish individual elements by standard HTML
 * attributes, so the 'awName' directive allows custom extentions to the base name to be provided
 * using the 'ext' attribute.
 *
 *    Example:
 *        fruits = ['apple', 'banana', 'orange'];
 *
 *        <ul>
 *            <li *ngFor="let fruit of fruits" awName ext="{{fruit}}">{{fruit}}</li>
 *        </ul>
 *
 *   Result:
 *       <ul>
 *           <li awname="li_apple">apple</li>
 *           <li awname="li_banana">banana</li>
 *           <li awname="li_orane">orange</li>
 *       </ul>
 *
 * **Adding Context Through Ancestor Inspection**
 *
 * In order to provide context to the element naming, the 'awName' directive loops through the
 * parent ancestry and searches for any unique element 'id' to prepend to the base name.
 *
 *     Example:
 *         <form id="applicant">
 *            <input type="text" name="firstName" awName>
 *            <input type="text" name="lastName" awName>
 *         </form>
 *         <form id="spouse">
 *            <input type="text" name="firstName" awName>
 *            <input type="text" name="lastName" awName>
 *         </form>
 *
 *     Result:
 *         <form id="applicant">
 *            <input type="text" name="firstName" awname="applicant_input_firstName">
 *            <input type="text" name="lastName" awname="applicant_input_lastName">
 *         </form>
 *         <form id="spouse">
 *            <input type="text" name="firstName" awname="spouse_input_firstName">
 *            <input type="text" name="lastName" awname="spouse_input_lastname">
 *         </form>
 *
 * **Uniqueness Check**
 *
 * 'awName' keeps track of the names it creates by adding them to a map store. Whenever it
 * creates a new name during the `ngOnInit` phase it checks it against the existing map,
 * and will throw an error if it encounters a duplicate. Moreover during the element destruction
 * phase, `ngOnDestroy`, 'awName' removes the generated name from the store.
 *
 *
 * **In Production**
 *
 * Using 'awName' adds a small bit of rendering overhead for each element it is used on. In
 * a production environment, 'awName' serves no functionality to the end user, but may have
 * a performance impact on the application. As such, 'awName' takes into account the
 * `AppConfig` settings and disables name generation when `AppConfig.isProductionMode()`
 * is `true`.
 *
 * In your application, you can turn on production mode by setting `devmode.enabled` to
 * `false` when configuring `AribaCoreModule`:
 *
 *     AribaCoreModule.forRoot({
 *         'devmode.enabled': false
 *     })
 *
 */
var AwNameDirective = /** @class */ (function () {
    function AwNameDirective(el, store, config) {
        this.el = el;
        this.store = store;
        this.config = config;
        this.separator = '_';
    }
    /**
     * @return {?}
     */
    AwNameDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.config.isProductionMode()) {
            this.name = this.createName(this.el);
            this.addElementToStore(this.name, this.el);
            this.el.nativeElement.setAttribute('awname', this.name);
        }
    };
    /**
     * @return {?}
     */
    AwNameDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.store.remove(this.name);
    };
    /**
     * Add element name/id and reference to map store. If name/id already
     * exists in store then it throws an error.
     *
     */
    /**
     * Add element name/id and reference to map store. If name/id already
     * exists in store then it throws an error.
     *
     * @param {?} name
     * @param {?} elem
     * @return {?}
     */
    AwNameDirective.prototype.addElementToStore = /**
     * Add element name/id and reference to map store. If name/id already
     * exists in store then it throws an error.
     *
     * @param {?} name
     * @param {?} elem
     * @return {?}
     */
    function (name, elem) {
        try {
            this.store.add(name, elem);
        }
        catch (/** @type {?} */ e) {
            console.error(e.message + (". \"" + name + "\" is already in use."), elem.nativeElement);
            return;
        }
    };
    /**
     * Generate name/id for element.
     *
     * param elem Reference to element
     * @return String Name/ID
     */
    /**
     * Generate name/id for element.
     *
     * param elem Reference to element
     * @param {?} elem
     * @return {?} String Name/ID
     */
    AwNameDirective.prototype.createName = /**
     * Generate name/id for element.
     *
     * param elem Reference to element
     * @param {?} elem
     * @return {?} String Name/ID
     */
    function (elem) {
        var /** @type {?} */ tagName = this.getTagName(elem);
        // Initialize array of string parts
        var /** @type {?} */ parts = [];
        // Find ancestor tag id, if there is one
        var /** @type {?} */ parentID = this.getAncestorId(elem);
        if (parentID) {
            parts.push(parentID);
        }
        // Check the tag type
        if (tagName === 'option') {
            var /** @type {?} */ parentName = this.getParentName(elem);
            if (parentName) {
                parts.push(parentName);
            }
        }
        // Get tagname
        parts.push(tagName);
        // Choose id property if it exists
        if (elem.nativeElement.id) {
            parts.push(elem.nativeElement.id);
            // Otherwise build extension from tag properties
        }
        else {
            // check for a name attribute
            if (elem.nativeElement.hasAttribute('name')) {
                parts.push(elem.nativeElement.name);
            }
            // check for value attribute if 'option' tag
            if (tagName === 'option') {
                if (elem.nativeElement.hasAttribute('value')) {
                    parts.push(this.spacesToUnderscore(elem.nativeElement.value));
                }
            }
        }
        // Add custom extension if it exists
        if (this.ext) {
            parts.push(this.spacesToUnderscore(this.ext));
        }
        return parts.join(this.separator);
    };
    /**
     * Get tag name from element reference.
     * @param elem Reference to element
     */
    /**
     * Get tag name from element reference.
     * @param {?} elem Reference to element
     * @return {?}
     */
    AwNameDirective.prototype.getTagName = /**
     * Get tag name from element reference.
     * @param {?} elem Reference to element
     * @return {?}
     */
    function (elem) {
        return elem.nativeElement.tagName.toLowerCase();
    };
    /**
     * Traverse element ancestry and return first id attribute
     * encountered.
     * @param elem Reference to element
     */
    /**
     * Traverse element ancestry and return first id attribute
     * encountered.
     * @param {?} elem Reference to element
     * @return {?}
     */
    AwNameDirective.prototype.getAncestorId = /**
     * Traverse element ancestry and return first id attribute
     * encountered.
     * @param {?} elem Reference to element
     * @return {?}
     */
    function (elem) {
        var /** @type {?} */ parent = elem.nativeElement.parentNode;
        var /** @type {?} */ id = '';
        while (parent && !id) {
            if (parent.id) {
                id = parent.id;
            }
            parent = parent.parentNode;
        }
        return id;
    };
    /**
     * Get name attribute from parent if name attribute exists.
     * @param elem Reference to element
     */
    /**
     * Get name attribute from parent if name attribute exists.
     * @param {?} elem Reference to element
     * @return {?}
     */
    AwNameDirective.prototype.getParentName = /**
     * Get name attribute from parent if name attribute exists.
     * @param {?} elem Reference to element
     * @return {?}
     */
    function (elem) {
        var /** @type {?} */ parent = elem.nativeElement.parentNode;
        return (parent.name && !parent.id) ? parent.name : null;
    };
    /**
     * @param {?} str
     * @return {?}
     */
    AwNameDirective.prototype.spacesToUnderscore = /**
     * @param {?} str
     * @return {?}
     */
    function (str) {
        return str.replace(/\s+/g, '_');
    };
    AwNameDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[awName]',
                },] },
    ];
    /** @nocollapse */
    AwNameDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: AwNameStore },
        { type: AppConfig }
    ]; };
    AwNameDirective.propDecorators = {
        ext: [{ type: Input }]
    };
    return AwNameDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWCoreComponentModule = /** @class */ (function () {
    function AWCoreComponentModule() {
    }
    AWCoreComponentModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        EmbeddedItemDirective,
                        IncludeComponentDirective,
                        GenericContainerComponent,
                        ErrorMessagesComponent,
                        ModalComponent,
                        CurrencyFormatPipe,
                        NgForSetDirective,
                        InfiniteScrollComponent,
                        AwNameDirective
                    ],
                    imports: [
                        CommonModule
                    ],
                    entryComponents: [
                        GenericContainerComponent,
                        ModalComponent
                    ],
                    exports: [
                        EmbeddedItemDirective,
                        IncludeComponentDirective,
                        GenericContainerComponent,
                        ErrorMessagesComponent,
                        ModalComponent,
                        CurrencyFormatPipe,
                        NgForSetDirective,
                        InfiniteScrollComponent,
                        AwNameDirective
                    ]
                },] },
    ];
    return AWCoreComponentModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Parent class for all modal dialogs. Provides defaults functionality for all modals.
 */
var  /**
 * Parent class for all modal dialogs. Provides defaults functionality for all modals.
 */
ModalContainer = /** @class */ (function (_super) {
    __extends(ModalContainer, _super);
    function ModalContainer(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * Override function.
         */
        _this.destroy = noop;
        return _this;
    }
    /**
     * function that closes the dialog by calling destroy on the component reference.
     * Method inherited by all its children.
     */
    /**
     * function that closes the dialog by calling destroy on the component reference.
     * Method inherited by all its children.
     * @return {?}
     */
    ModalContainer.prototype.closeModal = /**
     * function that closes the dialog by calling destroy on the component reference.
     * Method inherited by all its children.
     * @return {?}
     */
    function () {
        this.destroy();
    };
    return ModalContainer;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DataTypeProviderRegistry aggregates different DataProviders per type.
 */
var DataTypeProviderRegistry = /** @class */ (function () {
    function DataTypeProviderRegistry() {
        this.registryByProvider = new Map();
        this.registryNameToClass = new Map();
    }
    /**
     * For every single registered DataProvider implementation we also need store its prototype
     * in order to be able to support some kind of inheritance. You can register a provider for
     * a parent class if needed
     *
     */
    /**
     * For every single registered DataProvider implementation we also need store its prototype
     * in order to be able to support some kind of inheritance. You can register a provider for
     * a parent class if needed
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    DataTypeProviderRegistry.prototype.registerProvider = /**
     * For every single registered DataProvider implementation we also need store its prototype
     * in order to be able to support some kind of inheritance. You can register a provider for
     * a parent class if needed
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    function (target, provider) {
        if (isBlank(target) || (!isStringMap(target) && !isType(target))) {
            throw new Error(' Cannot register non-object');
        }
        var /** @type {?} */ name = isType(target) ? target.prototype.constructor.name : target.constructor.name;
        this.registryByProvider.set(name, provider);
        var /** @type {?} */ prototype = Object.getPrototypeOf(target);
        this.registryNameToClass.set(name, prototype);
    };
    /**
     * Search for best matching provider. If not found then use object prototype to get hold of its
     * parent and see if there is a provider registered on this level
     *
     */
    /**
     * Search for best matching provider. If not found then use object prototype to get hold of its
     * parent and see if there is a provider registered on this level
     *
     * @template T
     * @param {?} className
     * @return {?}
     */
    DataTypeProviderRegistry.prototype.bestMatchForClass = /**
     * Search for best matching provider. If not found then use object prototype to get hold of its
     * parent and see if there is a provider registered on this level
     *
     * @template T
     * @param {?} className
     * @return {?}
     */
    function (className) {
        var /** @type {?} */ registeredClassName = className;
        var /** @type {?} */ classProto = this.registryNameToClass.get(className);
        while (isPresent(registeredClassName)) {
            var /** @type {?} */ provider = this.registryByProvider.get(registeredClassName);
            if (isPresent(provider)) {
                provider.type = className;
                return provider;
            }
            // Go up to parent
            if (isPresent(classProto)) {
                classProto = Object.getPrototypeOf(classProto);
                var /** @type {?} */ parentName = objectToName(classProto);
                registeredClassName =
                    (isPresent(parentName) && parentName !== registeredClassName) ? parentName
                        : null;
            }
            else {
                return null;
            }
        }
        return null;
    };
    /**
     * The same as bestMatchForClass() with the difference to pass a type. If you want to
     * support object inheritance you need this.
     *
     *
     */
    /**
     * The same as bestMatchForClass() with the difference to pass a type. If you want to
     * support object inheritance you need this.
     *
     *
     * @template T
     * @param {?} type
     * @return {?}
     */
    DataTypeProviderRegistry.prototype.bestMatchForType = /**
     * The same as bestMatchForClass() with the difference to pass a type. If you want to
     * support object inheritance you need this.
     *
     *
     * @template T
     * @param {?} type
     * @return {?}
     */
    function (type) {
        var /** @type {?} */ name = objectToName(type);
        this.registryNameToClass.set(name, type);
        return this.bestMatchForClass(name);
    };
    DataTypeProviderRegistry.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DataTypeProviderRegistry.ctorParameters = function () { return []; };
    return DataTypeProviderRegistry;
}());
/**
 * Provider is a data driver that can access data and retrieve them. It knows how to get 1
 * or more records, maybe do paging and some other things.
 *
 * @abstract
 * @template T
 */
var  /**
 * Provider is a data driver that can access data and retrieve them. It knows how to get 1
 * or more records, maybe do paging and some other things.
 *
 * @abstract
 * @template T
 */
DataProvider = /** @class */ (function () {
    function DataProvider() {
        /**
         * Notifies all the listeners in case of data are available or if they changed due to some user
         * interaction  (search, adding or removing).
         *
         */
        this.dataChanges = new BehaviorSubject([]);
    }
    /**
     *  Return size of the source
     *
     */
    /**
     *  Return size of the source
     *
     * @param {?=} params
     * @return {?}
     */
    DataProvider.prototype.expectedCount = /**
     *  Return size of the source
     *
     * @param {?=} params
     * @return {?}
     */
    function (params) {
        return -1;
    };
    /**
     *
     * Returns non-async current state of data
     */
    /**
     *
     * Returns non-async current state of data
     * @return {?}
     */
    DataProvider.prototype.data = /**
     *
     * Returns non-async current state of data
     * @return {?}
     */
    function () {
        return this.dataChanges.getValue();
    };
    /**
     * Tells if this DataProvider supports INSERT, REMOVE
     *
     */
    /**
     * Tells if this DataProvider supports INSERT, REMOVE
     *
     * @return {?}
     */
    DataProvider.prototype.canCRUD = /**
     * Tells if this DataProvider supports INSERT, REMOVE
     *
     * @return {?}
     */
    function () {
        return false;
    };
    /**
     * Tells if this DataProvider supports query capability
     *
     */
    /**
     * Tells if this DataProvider supports query capability
     *
     * @return {?}
     */
    DataProvider.prototype.canQuery = /**
     * Tells if this DataProvider supports query capability
     *
     * @return {?}
     */
    function () {
        return false;
    };
    /**
     * Implement to support insertion. After record is inserted emit event for dataChanges to
     * inform all subscribers
     *
     */
    /**
     * Implement to support insertion. After record is inserted emit event for dataChanges to
     * inform all subscribers
     *
     * @param {?} obj
     * @return {?}
     */
    DataProvider.prototype.insert = /**
     * Implement to support insertion. After record is inserted emit event for dataChanges to
     * inform all subscribers
     *
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
    };
    /**
     * Implement to support record removal. After record is removed emit event for dataChanges to
     * inform all subscribers.
     *
     */
    /**
     * Implement to support record removal. After record is removed emit event for dataChanges to
     * inform all subscribers.
     *
     * @param {?} obj
     * @return {?}
     */
    DataProvider.prototype.remove = /**
     * Implement to support record removal. After record is removed emit event for dataChanges to
     * inform all subscribers.
     *
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
    };
    /**
     * Implement to provide access to low level searcg API.
     *
     */
    /**
     * Implement to provide access to low level searcg API.
     *
     * @param {?} params
     * @return {?}
     */
    DataProvider.prototype.query = /**
     * Implement to provide access to low level searcg API.
     *
     * @param {?} params
     * @return {?}
     */
    function (params) {
    };
    return DataProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default implementation for Arrays.
 * @template T
 */
var  /**
 * Default implementation for Arrays.
 * @template T
 */
ArrayDataProvider = /** @class */ (function (_super) {
    __extends(ArrayDataProvider, _super);
    function ArrayDataProvider(values) {
        var _this = _super.call(this) || this;
        _this.values = values;
        _this.type = Array;
        _this.dataChanges.next(_this.values);
        return _this;
    }
    /**
     * @param {?=} params
     * @return {?}
     */
    ArrayDataProvider.prototype.expectedCount = /**
     * @param {?=} params
     * @return {?}
     */
    function (params) {
        return this.values.length;
    };
    /**
     * @param {?=} params
     * @return {?}
     */
    ArrayDataProvider.prototype.dataForParams = /**
     * @param {?=} params
     * @return {?}
     */
    function (params) {
        if (isBlank(params)) {
            return this.values;
        }
        var /** @type {?} */ data = this.values;
        if (isPresent(params) && params.has('offset') && params.has('limit')) {
            var /** @type {?} */ offset = params.get('offset');
            var /** @type {?} */ limit = params.get('limit');
            if (data.length > (offset + limit)) {
                data = data.slice(offset, offset + limit);
            }
            else {
                data = data.slice(offset, data.length);
            }
        }
        if (params.has('orderby') && params.has('selector')) {
            this.sort(data, params.get('orderby'), params.get('selector'));
        }
        return data;
    };
    /**
     * @param {?} params
     * @return {?}
     */
    ArrayDataProvider.prototype.fetch = /**
     * @param {?} params
     * @return {?}
     */
    function (params) {
        return of(this.dataForParams(params));
    };
    /**
     * Provides default implementation for sorting current dataset by one column / key
     *
     * for sortOrdering please see Datatable and its sortOrderingForNumber()
     *
     *      1  = ascending
     *      -1 = descending
     * @param {?} arrayToSort
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    ArrayDataProvider.prototype.sort = /**
     * Provides default implementation for sorting current dataset by one column / key
     *
     * for sortOrdering please see Datatable and its sortOrderingForNumber()
     *
     *      1  = ascending
     *      -1 = descending
     * @param {?} arrayToSort
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    function (arrayToSort, key, sortOrder) {
        arrayToSort.sort(function (data1, data2) {
            var /** @type {?} */ value1 = FieldPath.getFieldValue(data1, key);
            var /** @type {?} */ value2 = FieldPath.getFieldValue(data2, key);
            var /** @type {?} */ result = null;
            if (value1 == null && value2 != null) {
                result = -1;
            }
            else if (value1 != null && value2 == null) {
                result = 1;
            }
            else if (value1 == null && value2 == null) {
                result = 0;
            }
            else if (typeof value1 === 'string' && typeof value2 === 'string') {
                result = value1.localeCompare(value2);
            }
            else {
                result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
            }
            return (sortOrder * result);
        });
    };
    return ArrayDataProvider;
}(DataProvider));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Provides top level accessor class in order to make {\@link DataProvider} retrieval process easier.
 * Using {\@link DataTypeProviderRegistry} we either retrieve registered instance of concrete
 * provider or instantiate our implicit provider for native types such as Array.
 *
 *
 */
var DataProviders = /** @class */ (function () {
    function DataProviders(registry) {
        this.registry = registry;
    }
    /**
     * Finds the best matching  DataProvider or create new one in case of Array
     * More room to register and instantiate some other implicit Providers
     */
    /**
     * Finds the best matching  DataProvider or create new one in case of Array
     * More room to register and instantiate some other implicit Providers
     * @param {?} target
     * @return {?}
     */
    DataProviders.prototype.find = /**
     * Finds the best matching  DataProvider or create new one in case of Array
     * More room to register and instantiate some other implicit Providers
     * @param {?} target
     * @return {?}
     */
    function (target) {
        if (isArray(target)) {
            return new ArrayDataProvider(target);
        }
        else if (isString(target)) {
            return this.registry.bestMatchForClass(target);
        }
        return this.registry.bestMatchForType(target);
    };
    /**
     * Registers new provider within DataTypeProviderRegistry
     *
     */
    /**
     * Registers new provider within DataTypeProviderRegistry
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    DataProviders.prototype.register = /**
     * Registers new provider within DataTypeProviderRegistry
     *
     * @template T
     * @param {?} target
     * @param {?} provider
     * @return {?}
     */
    function (target, provider) {
        this.registry.registerProvider(target, provider);
    };
    DataProviders.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DataProviders.ctorParameters = function () { return [
        { type: DataTypeProviderRegistry }
    ]; };
    return DataProviders;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Provides a registry of different data Finders used mostly by DataSources. All Finders are
 * registered by this class as we don't have any needs right now to expose this to developer.
 *
 */
var DataFinders = /** @class */ (function () {
    function DataFinders() {
        this.findersByType = new Map();
        this.initFinders();
    }
    /**
     * Finds the best matching DataFinder based on the object type and queryType.
     */
    /**
     * Finds the best matching DataFinder based on the object type and queryType.
     * @param {?} forProvider
     * @param {?} forType
     * @return {?}
     */
    DataFinders.prototype.find = /**
     * Finds the best matching DataFinder based on the object type and queryType.
     * @param {?} forProvider
     * @param {?} forType
     * @return {?}
     */
    function (forProvider, forType) {
        var /** @type {?} */ finderMatch;
        this.findersByType.forEach(function (v, k) {
            if (k.accepts(forProvider, forType)) {
                finderMatch = v;
                return true;
            }
        });
        if (isPresent(finderMatch)) {
            var /** @type {?} */ copy = new finderMatch();
            copy.forData(forProvider);
            return copy;
        }
        return null;
    };
    /**
     * @return {?}
     */
    DataFinders.prototype.initFinders = /**
     * @return {?}
     */
    function () {
        // create a prototype for each
        this.findersByType.set(new FullTextArrayDataFinder(), FullTextArrayDataFinder);
    };
    DataFinders.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DataFinders.ctorParameters = function () { return []; };
    return DataFinders;
}());
/** @enum {number} */
var QueryType = {
    FullText: 0,
    Predicate: 1,
    FullTextAndPredicate: 2,
};
QueryType[QueryType.FullText] = "FullText";
QueryType[QueryType.Predicate] = "Predicate";
QueryType[QueryType.FullTextAndPredicate] = "FullTextAndPredicate";
/**
 * This class provides matching capability for given DataProvider.
 * @abstract
 */
var  /**
 * This class provides matching capability for given DataProvider.
 * @abstract
 */
DataFinder = /** @class */ (function () {
    function DataFinder() {
    }
    /**
     * In order to find concrete DataFinder we need to know the target type and the query type
     *
     */
    /**
     * In order to find concrete DataFinder we need to know the target type and the query type
     *
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    DataFinder.prototype.accepts = /**
     * In order to find concrete DataFinder we need to know the target type and the query type
     *
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    function (forData, forType) {
        return false;
    };
    /**
     * @template T
     * @param {?} query
     * @param {?=} max
     * @return {?}
     */
    DataFinder.prototype.match = /**
     * @template T
     * @param {?} query
     * @param {?=} max
     * @return {?}
     */
    function (query, max) {
        if (max === void 0) { max = -1; }
        return unimplemented();
    };
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    DataFinder.prototype.matchWithSelections = /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    function (selections, query, max) {
        return unimplemented();
    };
    return DataFinder;
}());
/**
 * Simple FullText implementation based on infix string matching which works on top of
 * ArrayDataProvider.
 *
 *
 */
var  /**
 * Simple FullText implementation based on infix string matching which works on top of
 * ArrayDataProvider.
 *
 *
 */
FullTextArrayDataFinder = /** @class */ (function (_super) {
    __extends(FullTextArrayDataFinder, _super);
    function FullTextArrayDataFinder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.accepts = /**
     * @param {?} forData
     * @param {?} forType
     * @return {?}
     */
    function (forData, forType) {
        return forData instanceof ArrayDataProvider && forType === QueryType.FullText;
    };
    /**
     * @param {?} provider
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.forData = /**
     * @param {?} provider
     * @return {?}
     */
    function (provider) {
        this._provider = provider;
        return this;
    };
    Object.defineProperty(FullTextArrayDataFinder.prototype, "lookupKey", {
        set: /**
         * @param {?} key
         * @return {?}
         */
        function (key) {
            this._keyPath = isPresent(key) ? new FieldPath(key) : null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.instantMatch = /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    function (query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        var /** @type {?} */ list = this._provider.dataForParams(new Map().set('limit', max));
        return this.instantMatchWithSelections(list, query, max);
    };
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.instantMatchWithSelections = /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    function (selections, query, max) {
        assert(isPresent(this._provider), 'Missing DataProvider');
        if (isBlank(query)) {
            return selections;
        }
        var /** @type {?} */ result = [];
        var /** @type {?} */ toLowerPattern = query.toLowerCase();
        for (var /** @type {?} */ i = 0; i < selections.length; i++) {
            var /** @type {?} */ item = selections[i];
            if (this.matches(item, toLowerPattern)) {
                result.push(item);
                if (result.length >= max) {
                    break;
                }
            }
        }
        return result;
    };
    /**
     *
     * Warning: If you dont supply search Key and you want fulltext search and you use this
     * default implementation be aware that it can  perform poorly as it is naive implementaion
     * that does not do deep compare.
     *
     */
    /**
     *
     * Warning: If you dont supply search Key and you want fulltext search and you use this
     * default implementation be aware that it can  perform poorly as it is naive implementaion
     * that does not do deep compare.
     *
     * @template T
     * @param {?} item
     * @param {?} pattern
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.matches = /**
     *
     * Warning: If you dont supply search Key and you want fulltext search and you use this
     * default implementation be aware that it can  perform poorly as it is naive implementaion
     * that does not do deep compare.
     *
     * @template T
     * @param {?} item
     * @param {?} pattern
     * @return {?}
     */
    function (item, pattern) {
        var /** @type {?} */ val = (isPresent(this._keyPath)) ? this._keyPath.getFieldValue(item) : item;
        if (isFunction(val)) {
            val = val.call(item);
        }
        else if (isJsObject(item)) {
            return Object.keys(item).filter(function (key) {
                return isPresent(item[key]) && isString(item[key]) && item[key]
                    .toLowerCase().indexOf(pattern) !== -1;
            })
                .length > 0;
        }
        else {
            return isBlank(pattern) ||
                isPresent(val) && val.toString().toLowerCase().indexOf(pattern) > -1;
        }
    };
    /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.match = /**
     * @template T
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    function (query, max) {
        return of(this.instantMatch(query, max));
    };
    /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    FullTextArrayDataFinder.prototype.matchWithSelections = /**
     * @template T
     * @param {?} selections
     * @param {?} query
     * @param {?} max
     * @return {?}
     */
    function (selections, query, max) {
        return of(this.instantMatchWithSelections(selections, query, max));
    };
    return FullTextArrayDataFinder;
}(DataFinder));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DATA_SOURCE = new InjectionToken('DATA_SOURCE');
/**
 * DataSource describes basic functionality for handling stream of data specific to component
 *
 * It is expected that DataSource will be defined as component provider using
 *
 * \@Components ({
 *      ...
 *      providers:[
 *
 *          provide: DATA_SOURCE, useClass: ChooserDataSourcePlainArrayExample,
 * deps: [DataProviders, DataFinders]
 *      ]
 *
 * })
 *
 *
 * so all the dependencies (DataProviders, DataFinders) are properly injected.
 *
 * DataProvider uses open() method to broadcast changes to all the subscribers in reactive way.
 * Or you can use instant() method to retrieve current state of this DataSource (sync)
 *
 * @abstract
 */
var DataSource = /** @class */ (function () {
    /**
     *
     * Each DataSource have injected DataProviders and DataFinders to retrieve concrete
     * implementation
     *
     */
    function DataSource(dataProviders, finders) {
        this.dataProviders = dataProviders;
        this.finders = finders;
    }
    /**
     * Returns a data instantly from the internal state of DataProvider
     */
    /**
     * Returns a data instantly from the internal state of DataProvider
     * @template T
     * @return {?}
     */
    DataSource.prototype.instant = /**
     * Returns a data instantly from the internal state of DataProvider
     * @template T
     * @return {?}
     */
    function () {
        return unimplemented();
    };
    DataSource.MaxLength = 10;
    DataSource.MaxRecentSelected = 5;
    return DataSource;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
var TopZoneComponent = /** @class */ (function () {
    function TopZoneComponent() {
        this.classList = 'ui-g-12 ui-g-nopad ';
    }
    TopZoneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-top',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    TopZoneComponent.propDecorators = {
        classList: [{ type: HostBinding, args: ['class',] }]
    };
    return TopZoneComponent;
}());
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
var LeftZoneComponent = /** @class */ (function () {
    function LeftZoneComponent() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
    LeftZoneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-left',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    LeftZoneComponent.propDecorators = {
        classList: [{ type: HostBinding, args: ['class',] }]
    };
    return LeftZoneComponent;
}());
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
var MiddleZoneComponent = /** @class */ (function () {
    function MiddleZoneComponent() {
        this.classList = 'ui-g-12 ui-md-6 ui-lg-4 ui-g-nopad';
    }
    MiddleZoneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-middle',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    MiddleZoneComponent.propDecorators = {
        classList: [{ type: HostBinding, args: ['class',] }]
    };
    return MiddleZoneComponent;
}());
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
var RightZoneComponent = /** @class */ (function () {
    function RightZoneComponent() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
    RightZoneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-right',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    RightZoneComponent.propDecorators = {
        classList: [{ type: HostBinding, args: ['class',] }]
    };
    return RightZoneComponent;
}());
/**
 * Common class used used for Five Zone layout. Used for the ng-content selector
 */
var BottomZoneComponent = /** @class */ (function () {
    function BottomZoneComponent() {
        this.classList = 'ui-g-12 ui-g-nopad';
    }
    BottomZoneComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-bottom',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    BottomZoneComponent.propDecorators = {
        classList: [{ type: HostBinding, args: ['class',] }]
    };
    return BottomZoneComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Used by FormTable to layout fields into Rows. Each FormTable row is reasonable for not only to
 * include actual component such is DropDown or InputField but mainly provides a enough context for
 * the component to specify the size, how it should layout, whether we need to show required flag,
 * to show/hide labels in case if we have no label layout and much more.
 *
 * FormRow component also registers angular validator for the current row/field. As already
 * mentioned We treat our widgets with minimal responsibility as possible to present and retrive
 * information to/from user and let somebody else to figure out where it appear and how.
 *
 * todo: Move under FormTable
 */
var FormRowComponent = /** @class */ (function (_super) {
    __extends(FormRowComponent, _super);
    function FormRowComponent(env, 
    // Event this creates CI depends. Need to have a reference to parent
    // I need to refactor more parent to not use this child and refactor layouting
    parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         * Hides the label
         *
         */
        _this.noLabelLayout = false;
        /**
         * Renders row with highlighted background
         *
         */
        _this.highlightRow = false;
        /**
         *
         *  Field label that should appear above or next to the control
         *
         */
        _this.label = '';
        /**
         *
         * For single column layout without zones we need to apply grid directly to the FormRow tag
         * so we don't need to introduce extra div level
         *
         */
        _this.classList = '';
        _this._size = 'ui-g-12 ui-md-' + WidgetSizeColumns.medium;
        return _this;
    }
    /**
     * Right now we just initialize this once and use the values we do not expect now to react to
     * changes
     */
    /**
     * Right now we just initialize this once and use the values we do not expect now to react to
     * changes
     * @return {?}
     */
    FormRowComponent.prototype.ngOnInit = /**
     * Right now we just initialize this once and use the values we do not expect now to react to
     * changes
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        _super.prototype.registerFormControl.call(this, null);
        this.registerValidators();
        this.omitPadding = this.parentContainer.omitPadding;
        this.classList += isPresent(this.parentContainer) ? ' ui-g-12 ' : '';
        this.classList = this.highlightRow ? this.classList + ' highlight-row ' : this.classList;
        this.classList = this.omitPadding ? this.classList + ' ui-g-nopad ' : this.classList;
    };
    Object.defineProperty(FormRowComponent.prototype, "size", {
        /**
         * Just a size getter
         *
         */
        get: /**
         * Just a size getter
         *
         * @return {?}
         */
        function () {
            return this._size;
        },
        /**
         *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
         * right now. but we should extend this for other screen sizes
         *
         *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
         *
         *  Also check if this is dynamic size that should vary based on the how many number of columns
         * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
         * small.
         */
        set: /**
         *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
         * right now. but we should extend this for other screen sizes
         *
         *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
         *
         *  Also check if this is dynamic size that should vary based on the how many number of columns
         * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
         * small.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var /** @type {?} */ isDynVal = false;
            if (StringWrapper.startsWidth(value, 'd-')) {
                isDynVal = true;
                value = value.substr(2, value.length - 1);
            }
            if (isPresent(value)) {
                this._size = value;
                var /** @type {?} */ dSize = this.dynSize(value, isDynVal);
                this._size = 'ui-g-12 ui-md-' + dSize;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    FormRowComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngDoCheck.call(this);
        if (isPresent(this.parentContainer) && this.editable !== this.parentContainer.editable) {
            this.editable = this.parentContainer.editable;
        }
    };
    /**
     * Push out of box angular validator as well as custom one to current FormControl
     * @return {?}
     */
    FormRowComponent.prototype.registerValidators = /**
     * Push out of box angular validator as well as custom one to current FormControl
     * @return {?}
     */
    function () {
        var /** @type {?} */ validators = [];
        if (isPresent(this.maxLength)) {
            validators.push(Validators.maxLength(this.maxLength));
        }
        if (isPresent(this.minLength)) {
            validators.push(Validators.minLength(this.minLength));
        }
        if (isPresent(this.required) && this.required) {
            validators.push(Validators.required);
        }
        if (isPresent(this.pattern)) {
            validators.push(Validators.pattern(this.pattern));
        }
        if (isPresent(this.customValidators)) {
            ListWrapper.addAll(validators, this.customValidators);
        }
        if (validators.length === 1) {
            this.formControl.setValidators(validators[0]);
        }
        else if (validators.length > 1) {
            this.formControl.setValidators(Validators.compose(validators));
        }
        if (isPresent(this.customAsyncValidators) && this.customAsyncValidators.length === 1) {
            this.formControl.setAsyncValidators(this.customAsyncValidators[0]);
        }
        else if (isPresent(this.customAsyncValidators) && this.customAsyncValidators.length > 1) {
            this.formControl.setAsyncValidators(Validators.composeAsync(this.customAsyncValidators));
        }
    };
    Object.defineProperty(FormRowComponent.prototype, "labelsOnTop", {
        /**
         *
         * Do we have labels on TOP, try to read this from Parent
         *
         */
        get: /**
         *
         * Do we have labels on TOP, try to read this from Parent
         *
         * @return {?}
         */
        function () {
            if (isBlank(this._labelsOnTop) && isPresent(this.parentContainer)) {
                return (/** @type {?} */ (this.parentContainer)).isLabelsOnTop();
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * Can refactor all into 1 line but its hard to debug so this is just for read
     *
     * @param {?} value
     * @param {?} isDynValue
     * @return {?}
     */
    FormRowComponent.prototype.dynSize = /**
     *
     * Can refactor all into 1 line but its hard to debug so this is just for read
     *
     * @param {?} value
     * @param {?} isDynValue
     * @return {?}
     */
    function (value, isDynValue) {
        var /** @type {?} */ normalizeSize = value.toLowerCase().replace('-', '');
        if (isPresent(this.parentContainer) &&
            (/** @type {?} */ (this.parentContainer)).hasTwoColumn && isDynValue) {
            var /** @type {?} */ enumValues = Object.keys(WidgetSizeColumns);
            normalizeSize = enumValues[enumValues.indexOf(normalizeSize) + 1];
        }
        return (/** @type {?} */ (WidgetSizeColumns))[normalizeSize];
    };
    FormRowComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-form-row',
                    template: "<div *ngIf=\"!hidden\"\n     class=\"w-form-row ui-g\"\n     [class.highlight-row]=\"highlightRow\"\n     [class.required]=\"required\"\n     [class.label-on-top]=\"labelsOnTop\"\n     [class.label-on-side]=\"!labelsOnTop\"\n     [class.has-danger]=\"!formControl.valid && !formControl.pristine \"\n     [ngClass]=\"styleClass\">\n\n    <div class=\"control-label ui-g-12 ui-g-nopad\"\n         *ngIf=\"!noLabelLayout\"\n         [class.ui-md-3]=\"!labelsOnTop\">\n        <label [class.sr-only]=\"noLabelLayout\">{{label}}</label>\n    </div>\n\n    <div class=\"control-value ui-g-nopad\" [ngClass]=\"size\"\n         [class.read-only]=\"!editable\">\n        <ng-content></ng-content>\n        <a-error-messages [control]=\"formControl\"></a-error-messages>\n    </div>\n</div>\n",
                    styles: [".required label:after{content:\"*\";color:red}/deep/ .highlight-row{background-color:#f7f8fa}.w-form-row.highlight-row{background-color:#f7f8fa}.w-form-row.label-on-top{padding-bottom:13px}.w-form-row.label-on-top .control-label,.w-form-row.label-on-top .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-top .control-label{padding-bottom:12px}.w-form-row.label-on-side .control-label,.w-form-row.label-on-side .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-side .control-label ::ng-deep .w-string-field,.w-form-row.label-on-side .control-value ::ng-deep .w-string-field{line-height:36px}.w-form-row.label-on-side .control-label ::ng-deep .sap-icon,.w-form-row.label-on-side .control-value ::ng-deep .sap-icon{line-height:26px}.w-form-row.label-on-side .control-label label,.w-form-row.label-on-side .control-value label{line-height:36px}.w-form-row.label-on-side .control-label .fa,.w-form-row.label-on-side .control-value .fa{line-height:18px}.control-label{color:#636363}.u-validation-error{border-color:red}"],
                    providers: [
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return FormRowComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    FormRowComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: FormTableComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormTableComponent; }),] }] }
    ]; };
    FormRowComponent.propDecorators = {
        noLabelLayout: [{ type: Input }],
        highlightRow: [{ type: Input }],
        label: [{ type: Input }],
        maxLength: [{ type: Input }],
        minLength: [{ type: Input }],
        pattern: [{ type: Input }],
        customAsyncValidators: [{ type: Input }],
        customValidators: [{ type: Input }],
        classList: [{ type: HostBinding, args: ['class',] }],
        size: [{ type: Input }]
    };
    return FormRowComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * FormTable is a specific layout component for rendering Labels and its controls in two columns
 * and 5 different zones.
 *
 * We support LEFT, MIDDLE, RIGHT, TOP, BOTTOM zone where we can place our component or widgets.
 * This
 * component is used as primary layout to wrap all the common use cases. E.g. When we lay out
 * fields in the form I do not want controls to be aware of error validation, size, labels, and
 * some other things. Control such INPUT is just responsible for retrieve user value but not how it
 * appear on the page.
 *
 * This way we can be flexible how we treat widgets for different kinds of situation depending
 * where they appear
 * FormTable just like the rest of the components are using Model driven approach how to work with
 * data, mean we are using FormGroup, FormControl etc. FormGroup can be passed into the FormTable,
 * otherwise its automatically created when the FormTable is instantiated.
 *
 * FormGroup is saved insode Environment where we are using this to pass this around the pages and
 * components.
 *
 * ### Example
 *
 * Simple Layout fields and its control
 *
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: `
 *  			<aw-form-table [formGroup]="formGroup" (onSubmit)=>
 *  				<aw-form-row [label]="'name'" [name]="'name'">
 *  					<aw-input-field [type]="'string'"></aw-input-field>
 *  				</aw-form-row>
 *
 *  				<aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
 *  					<aw-checkbox-list [list]="checkBoxListValues"
 *  					                 [selections]="selectedValues"
 *  					                 [layout]="'inline'"
 *  					                 (onSelection)="onCBClick($event)">
 *  					</aw-checkbox-list>
 *  				</aw-form-row>
 *  				<aw-form-row [label]="'Gender'" [name]="'gender'">
 *
 *  					<aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
 *
 *  					</aw-radiobutton-list>
 *
 *  				</aw-form-row>
 *  				<aw-form-row [label]="'My birthdate'" [name]="'birthDate'" [size]="'small'">
 *
 *  					<aw-date-time [value]="date" [editable]="editable" [showTime]="showTime">
 *  					</aw-date-time>
 *  				</aw-form-row>
 *  			</aw-form-table>
 *    `
 *  })
 *  export class ShowUserInfoComponent
 *  {
 *       checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' , 'silver'
 *     , 'black' , 'Green'
 *     , 'Gray' , 'Navy' ,
 *          'Olive' , 'Aqua' , 'Purple'];
 *      selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
 *      rbValues: string[] = ['male' , 'female' , 'other'];
 *      rbSelection: string = 'male';
 *      editable: boolean = true;
 *      showTime: boolean = true;
 *
 *      formGroup: FormGroup = new FormGroup({});
 *
 *
 *      onCBClick (event): void
 *      {
 *          console.log('onCBClick = ' + event);
 *      }
 *
 *      onSubmit (model: any): void
 *      {
 *         console.log(model)
 *
 *         // will print { name:null, myColors:['blue' , 'Olive' , 'Aqua' , 'Purple'], gender:
 *     male}
 *      }
 *
 *  }
 *
 *  ```
 *
 *  Or you can use zone to layout these fields into two columns:
 *
 *  Current zones are implement with <ng-content SELECT> which is just a selector to searches for
 *     specific pattern. In our case instead of creating extra wrapper custom component use simple
 *     CSS class
 *
 *
 *  ```
 *            <aw-form-table #metaFormTable [editable]="editing"
 *                          [useFiveZone]="isFiveZoneLayout"
 *                          (onSubmit)="onSaveAction($event)">
 *
 *                <aw-left  *ngIf="canShowZone('zLeft')">
 *
 *                        <aw-form-row [label]="'name'" [name]="'name'">
 *                            <aw-input-field [type]="'string'"></aw-input-field>
 *                        </aw-form-row>
 *
 *                        <aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
 *                            <aw-checkbox-list [list]="checkBoxListValues"
 *                                             [selections]="selectedValues"
 *                                             [layout]="'inline'"
 *                                             (onSelection)="onCBClick($event)">
 *                            </aw-checkbox-list>
 *                        </aw-form-row>
 *                </aw-left>
 *
 *
 *                <aw-right  *ngIf="canShowZone('zRight')">
 *                        <aw-form-row [label]="'Gender'" [name]="'gender'">
 *                                <aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
 *                                </aw-radiobutton-list>
 *                        </aw-form-row>
 *
 *                        <aw-form-row [label]="'My birthdate'" [name]="'birthDate'"
 *     [size]="'small'">
 *                            <aw-date-time [value]="date" [editable]="editable"
 *     [showTime]="showTime">
 *                            </aw-date-time>
 *                        </aw-form-row>
 *                </<aw-right>
 *            </aw-form-table>
 *
 *  ```
 *
 *  todo: remove my css selectors for zones and replace it with real component even just a tag
 *  todo: would work file
 *
 */
var FormTableComponent = /** @class */ (function (_super) {
    __extends(FormTableComponent, _super);
    function FormTableComponent(env) {
        var _this = _super.call(this, env, null) || this;
        _this.env = env;
        /**
         * Used for the form layout to see if we need to render labels stacked  or side by side next to
         * the control
         *
         */
        _this.labelsOnTop = false;
        /**
         *
         * Is this a 4 zone layout
         *
         */
        _this.useFiveZone = false;
        /**
         * For certain usecase we dont want to set automatically this to all children
         */
        _this.editabilityCheck = true;
        /**
         *  Triggers when the <form> is submitted. onSubmit we emit the whole formController objects
         *
         *
         */
        _this.onSubmit = new EventEmitter();
        /**
         * Cache calculated properties when init this component
         *
         */
        _this.hasOneColumn = false;
        _this.hasTwoColumn = false;
        _this.hasThreeColumn = false;
        return _this;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    FormTableComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (isPresent(changes['editable']) &&
            changes['editable'].previousValue !== changes['editable'].currentValue) {
            this.updateFormFields();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FormTableComponent.prototype.onSubmitForm = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onSubmit.emit(event);
    };
    /**
     *
     * Are labels on top
     *
     */
    /**
     *
     * Are labels on top
     *
     * @return {?}
     */
    FormTableComponent.prototype.isLabelsOnTop = /**
     *
     * Are labels on top
     *
     * @return {?}
     */
    function () {
        return this.labelsOnTop;
    };
    /**
     *
     * Used by child component to inherit editability
     *
     */
    /**
     *
     * Used by child component to inherit editability
     *
     * @return {?}
     */
    FormTableComponent.prototype.isFormEditable = /**
     *
     * Used by child component to inherit editability
     *
     * @return {?}
     */
    function () {
        return this.editable;
    };
    /**
     * @return {?}
     */
    FormTableComponent.prototype.applyColumns = /**
     * @return {?}
     */
    function () {
        if (!this.useFiveZone && this.hasAnyZones()) {
            throw new Error('Zones detected in the FormTable but useFiveZone option is false');
        }
        this.hasOneColumn = !isPresent(this.rightZone) && !isPresent(this.middleZone);
        this.hasTwoColumn = isPresent(this.leftZone) && isPresent(this.rightZone) &&
            !isPresent(this.middleZone);
        this.hasThreeColumn = isPresent(this.leftZone) && isPresent(this.rightZone) &&
            isPresent(this.middleZone);
        if (this.hasTwoColumn && !this.isTwoZoneReady()) {
            this.leftZone.classList += ' ui-md-6 ui-lg-6';
            this.rightZone.classList += ' ui-md-6 ui-lg-6';
        }
        if (this.hasThreeColumn && !this.isThreeZoneReady()) {
            this.leftZone.classList += ' ui-md-6 ui-lg-4';
            this.rightZone.classList += ' ui-md-6 ui-lg-4';
        }
    };
    /**
     * @return {?}
     */
    FormTableComponent.prototype.hasAnyZones = /**
     * @return {?}
     */
    function () {
        return isPresent(this.leftZone) || isPresent(this.rightZone) || isPresent(this.middleZone)
            || isPresent(this.topZone) || isPresent(this.bottomZone);
    };
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     */
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    FormTableComponent.prototype.isTwoZoneReady = /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    function () {
        return this.leftZone.classList.indexOf('ui-lg-6') > 0 &&
            this.leftZone.classList.indexOf('ui-lg-6') > 0;
    };
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     */
    /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    FormTableComponent.prototype.isThreeZoneReady = /**
     * Helper method to check if we already initialized the classList.
     * the
     *
     * TODO: Probably string array would be easier
     * @return {?}
     */
    function () {
        return this.leftZone.classList.indexOf('ui-lg-4') > 0 &&
            this.leftZone.classList.indexOf('ui-lg-4') > 0;
    };
    /**
     * @return {?}
     */
    FormTableComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // problem since Angular 4.2, ngAfterContentInit
        // without this I get error that value was changed after view was checked
        // todo: refactor  - mainly our zones left, right middle
        setTimeout(function () {
            _this.applyColumns();
            _this.updateFormFields();
            _this.adjustLayout();
        });
    };
    /**
     * @return {?}
     */
    FormTableComponent.prototype.updateFormFields = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.editabilityCheck && isPresent(this.formFields) && this.formFields.length > 0) {
            this.formFields.forEach(function (item) {
                item.editable = _this.editable;
                // item.formGroup = this.formGroup;
            });
        }
    };
    /**
     * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
     * form row.
     * @return {?}
     */
    FormTableComponent.prototype.adjustLayout = /**
     * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
     * form row.
     * @return {?}
     */
    function () {
        if (isPresent(this.rows) && this.rows.length > 0) {
            if (this.hasThreeColumn) {
                this.rows.forEach(function (item) { return item.size = 'large'; });
            }
        }
    };
    FormTableComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-form-table',
                    template: "<form class=\"w-form-table ui-g ui-fluid\" [formGroup]=\"formGroup\"\n      [ngClass]=\"styleClass\"\n      (ngSubmit)=\"onSubmitForm(formGroup.value)\" novalidate>\n\n    <div class=\"ui-g-12 ui-g-nopad\">\n\n        <div class=\"ui-g\">\n            <ng-content></ng-content>\n        </div>\n\n    </div>\n</form>\n\n",
                    styles: [".page-container>form{margin-top:1em}.w-form-table button{float:right}"],
                    providers: [
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return FormTableComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    FormTableComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    FormTableComponent.propDecorators = {
        labelsOnTop: [{ type: Input }],
        useFiveZone: [{ type: Input }],
        editabilityCheck: [{ type: Input }],
        onSubmit: [{ type: Output }],
        leftZone: [{ type: ContentChild, args: [LeftZoneComponent,] }],
        middleZone: [{ type: ContentChild, args: [MiddleZoneComponent,] }],
        rightZone: [{ type: ContentChild, args: [RightZoneComponent,] }],
        topZone: [{ type: ContentChild, args: [TopZoneComponent,] }],
        bottomZone: [{ type: ContentChild, args: [BottomZoneComponent,] }],
        formFields: [{ type: ContentChildren, args: [BaseFormComponent, { descendants: true },] }],
        rows: [{ type: ContentChildren, args: [forwardRef(function () { return FormRowComponent; }), { descendants: true },] }]
    };
    return FormTableComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWFormTableModule = /** @class */ (function () {
    function AWFormTableModule() {
    }
    AWFormTableModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        FormTableComponent,
                        FormRowComponent,
                        TopZoneComponent,
                        LeftZoneComponent,
                        RightZoneComponent,
                        MiddleZoneComponent,
                        BottomZoneComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        InputTextModule,
                        AWCoreComponentModule
                    ],
                    entryComponents: [
                        FormTableComponent,
                        FormRowComponent,
                        TopZoneComponent,
                        LeftZoneComponent,
                        RightZoneComponent,
                        MiddleZoneComponent,
                        BottomZoneComponent
                    ],
                    exports: [
                        FormTableComponent,
                        FormRowComponent,
                        TopZoneComponent,
                        LeftZoneComponent,
                        RightZoneComponent,
                        MiddleZoneComponent,
                        BottomZoneComponent
                    ]
                },] },
    ];
    return AWFormTableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This component represent a Input field and it can  accept different types of values such as
 * text, number.
 *
 *
 *
 * ### Example
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: '<aw-input-field [value]="inputValue" [type]="inputType"></aw-input-field>'
 *  })
 *  export class TestInputComponent
 *  {
 *      inputValue: string = 'Some text';
 *
 *      // by default input type is text, you can pass string, String, or text
 *      inputType: string = 'string';
 *  }
 *
 * ```
 *
 *
 *
 * ### Example wher input field is initialized with ngModel
 *
 * ```typescript
 * \@Component({
 *      selector: 'wrapper-comp' ,
 *      template: '<aw-input-field [value]="inputValue" [(ngModel)]="inputType"></aw-input-field>'
 *  })
 *  export class TestInputComponent
 *  {
 *      inputValue: string = 'Some text';
 *
 *      // by default input type is text, you can pass string, String, or text
 *      inputType: string = 'string';
 *  }
 *
 * ```
 *
 *  Note: if you are using this outside of FormTable please provide your own FormGroup
 *
 */
var /** @type {?} */ INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return InputFieldComponent; }),
    multi: true
};
var InputFieldComponent = /** @class */ (function (_super) {
    __extends(InputFieldComponent, _super);
    function InputFieldComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         *
         * A value used to save and read  when rendering and updating a component
         *
         */
        _this.value = '';
        /**
         * Input field type. Currently we support either Number or text
         */
        _this._type = 'string';
        _this.decimalPipe = new DecimalPipe(env.locale);
        return _this;
    }
    /**
     * @return {?}
     */
    InputFieldComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        _super.prototype.registerFormControl.call(this, this.bigDecimal);
        this.vchSubscriber = this.formControl.valueChanges
            .pipe(distinctUntilChanged())
            .subscribe(function (val) {
            setTimeout(function () { return _this.value = val; });
            // this.value = val;
            // this.value = val;
            _this.onModelChanged(_this.value);
        });
    };
    Object.defineProperty(InputFieldComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this._type;
        },
        /**
         *
         * generated setter to check for value and normalizing into expected either number or text
         *
         */
        set: /**
         *
         * generated setter to check for value and normalizing into expected either number or text
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value.toLowerCase() === 'string' || value.toLowerCase() === 'text') {
                this._type = 'text';
            }
            else if (value.toLowerCase() === 'number') {
                this._type = 'number';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputFieldComponent.prototype, "displayValue", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.bigDecimal) {
                this._displayValue = this.formatNumber(this.bigDecimal);
            }
            else {
                this._displayValue = this.value;
            }
            return this._displayValue;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InputFieldComponent.prototype.canSetType = /**
     * @return {?}
     */
    function () {
        return true;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    InputFieldComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.bigDecimal && !equals(value, this.bigDecimal)) {
            this.bigDecimal = value;
            this.formControl.setValue(this.bigDecimal);
            return;
        }
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value, { onlySelf: true });
        }
    };
    /**
     * Format the number object according to its precision.
     *
     */
    /**
     * Format the number object according to its precision.
     *
     * @param {?} value
     * @return {?}
     */
    InputFieldComponent.prototype.formatNumber = /**
     * Format the number object according to its precision.
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // The default precision is 2. For example, 10.23.
        var /** @type {?} */ digits = '1.0-2';
        // If precision is present, use it for format the bigDecimal value for display.
        if (isPresent(this.precision) &&
            this._type === 'number') {
            digits = '1.0-' + this.precision;
            return this.decimalPipe.transform(value, digits);
        }
        return value;
    };
    /**
     * @return {?}
     */
    InputFieldComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        if (isPresent(this.vchSubscriber)) {
            this.vchSubscriber.unsubscribe();
        }
    };
    InputFieldComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-input-field',
                    template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\" class=\"w-input-wrapper\">\n\n    <input pInputText\n\n           [attr.name]=\"name\"\n           [attr.type]=\"type\"\n           class=\"w-input-field\"\n           [ngClass]=\"styleClass\"\n           [class.has-icon]=\"icon\"\n           placeholder=\"{{placeHolder}}\"\n           [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n           formControlName=\"{{name}}\"\n           [value]=\"displayValue\">\n        <span *ngIf=\"icon\" class=\"sap-icon\" [ngClass]=\"icon\"></span>\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"displayValue\"></aw-string>\n</ng-template>\n",
                    styles: [".w-input-wrapper{position:relative}.w-input-field~span{top:13px;position:absolute;right:15px}"],
                    providers: [
                        INPUT_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return InputFieldComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    InputFieldComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    InputFieldComponent.propDecorators = {
        value: [{ type: Input }],
        precision: [{ type: Input }],
        bigDecimal: [{ type: Input }],
        icon: [{ type: Input }],
        type: [{ type: Input }]
    };
    return InputFieldComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWStringFieldModule = /** @class */ (function () {
    function AWStringFieldModule() {
    }
    AWStringFieldModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        StringComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule
                    ],
                    entryComponents: [
                        StringComponent
                    ],
                    exports: [
                        StringComponent
                    ],
                    providers: []
                },] },
    ];
    return AWStringFieldModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWInputFieldModule = /** @class */ (function () {
    function AWInputFieldModule() {
    }
    AWInputFieldModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        InputFieldComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        InputTextModule,
                        AWStringFieldModule
                    ],
                    entryComponents: [
                        InputFieldComponent
                    ],
                    exports: [
                        InputFieldComponent,
                        AWStringFieldModule,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWInputFieldModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * basic navigation bar provide a main action buttons for its content (page level buttons).
 * This is not the Top level application navigation. This component provides by default action OK,
 * CANCEL and you are free to modify how the OK or CANCEL will be call as well as subscribe to the
 * event. Or you can provide your own buttons template which will be used instead of this default
 * one.
 *
 *
 *
 *
 *
 * ### Example 1:
 *
 * In order to use navigation bar in its basic usage you can do following:
 * this will render buttons on the top as well as on the bottom around the content.
 *
 *
 *  ```html
 *
 *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
 *
 *            <div class="container">
 *                <form>
 *                    User name: <input type=text value="peter.pan">
 *                </<form>>
 *            </div>
 *      </aw-basic-navigator>
 *
 *
 * ```
 *
 *  if you do not want button on the top or bottom you can say thi using binding showTop or
 * showBottom.
 *
 *
 * ### Example 2:
 *  In this example we are providing custom buttons as well as brank section
 *
 *
 *  ```html
 *
 *
 *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
 *            <ng-template #buttons>
 *                <ul class="nav navbar-nav float-md-right collapse navbar-toggleable-xs">
 *                    <li class="nav-item ">
 *                        <button class="btn btn-secondary" type="button"
 * (click)="onSaveAction($evemt)">Cancel</button>
 *                    </li>
 *                    <li class="nav-item active">
 *                        <button class="btn btn-primary" type="button"
 * (click)="onCancelAction($event)"> Save
 *                        </button>
 *                    </li>
 *                </ul>
 *            </ng-template>
 *
 *            <ng-template #brand>
 *                <span class="brand-title">Ariba</span>
 *            </ng-template>
 *
 *
 *            <div class="container">
 *                <form>
 *                    User name: <input type=text value="peter.pan">
 *                </<form>>
 *            </div>
 *      </aw-basic-navigator>
 *
 *
 * ```
 *
 */
var BasicNavigatorComponent = /** @class */ (function (_super) {
    __extends(BasicNavigatorComponent, _super);
    function BasicNavigatorComponent(env, appConfig) {
        var _this = _super.call(this, env) || this;
        /**
         * Indicates that buttons will be rendered on the top
         *
         * Default value is TRUE
         *
         */
        _this.showTop = true;
        /**
         * Indicates that buttons will be rendered on the bottom
         *
         * Default value is TRUE
         *
         */
        _this.showBottom = true;
        /**
         * Indicates that brand section that is on the left side and only in the top bar is visible
         *
         * Default value is TRUE
         *
         */
        _this.showBrand = true;
        /**
         *
         * EventEmitter that is triggered when you click on default OK Action
         *
         */
        _this.onOKAction = new EventEmitter();
        /**
         *
         * EventEmitter that is triggered when you click on default CANCEL Action
         *
         */
        _this.onCancelAction = new EventEmitter();
        // todo: load this from resource file using ngTranslate service
        // todo: load this from resource file using ngTranslate service
        _this.okActionLabel = 'OK';
        _this.cancelActionLabel = 'Cancel';
        _this.brandImg = 'images/aribalogobal.png';
        return _this;
    }
    /**
     * @return {?}
     */
    BasicNavigatorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isBlank(this.showCancelButton)) {
            this.showCancelButton = this.editable || (this.onCancelAction.observers.length > 0
                && this.onOKAction.observers.length > 0);
        }
    };
    /**
     * Returns if buttonsTemplate is available
     *
     */
    /**
     * Returns if buttonsTemplate is available
     *
     * @return {?}
     */
    BasicNavigatorComponent.prototype.hasButtonTemplate = /**
     * Returns if buttonsTemplate is available
     *
     * @return {?}
     */
    function () {
        return isPresent(this.buttonsTemplate);
    };
    /**
     * Returns if brandTemplate is available
     *
     */
    /**
     * Returns if brandTemplate is available
     *
     * @return {?}
     */
    BasicNavigatorComponent.prototype.hasBrandTemplate = /**
     * Returns if brandTemplate is available
     *
     * @return {?}
     */
    function () {
        return isPresent(this.brandTemplate);
    };
    BasicNavigatorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-basic-navigator',
                    template: "<p-toolbar *ngIf=\"showTop\" [class]=\"'w-basic-navigator'\">\n    <div class=\"ui-toolbar-group-left\">\n\n        <a class=\"nav-brand\" href=\"#\" *ngIf=\"showBrand\">\n            <ng-template [ngIf]=\"!hasBrandTemplate()\">\n                <img src=\"{{assetFolder}}/{{brandImg}}\" height=\"30\" alt=\"\">\n                <span class=\"nav-brand-title\">Ariba</span>\n            </ng-template>\n\n            <ng-template [embeddedItem]=\"brandTemplate\" [item]=\"context\"\n                         *ngIf=\"hasBrandTemplate()\"></ng-template>\n        </a>\n\n    </div>\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n\n\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n<ng-content></ng-content>\n\n<p-toolbar *ngIf=\"showBottom\">\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n\n\n",
                    styles: ["a.nav-brand{vertical-align:middle;line-height:inherit;text-decoration:none;color:#2d353c}a.nav-brand:focus,a.nav-brand:hover{text-decoration:none}a.nav-brand span{vertical-align:middle}.nav-brand img{display:inline-block;vertical-align:middle;padding:3px}"]
                },] },
    ];
    /** @nocollapse */
    BasicNavigatorComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: AppConfig }
    ]; };
    BasicNavigatorComponent.propDecorators = {
        showTop: [{ type: Input }],
        showBottom: [{ type: Input }],
        showBrand: [{ type: Input }],
        brandImg: [{ type: Input }],
        okActionLabel: [{ type: Input }],
        cancelActionLabel: [{ type: Input }],
        context: [{ type: Input }],
        showCancelButton: [{ type: Input }],
        onOKAction: [{ type: Output }],
        onCancelAction: [{ type: Output }],
        buttonsTemplate: [{ type: ContentChild, args: ['buttons',] }],
        brandTemplate: [{ type: ContentChild, args: ['brand',] }]
    };
    return BasicNavigatorComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Button component that implements consistent styling, behavior. Button can be rendered either as
 * a button or as a link. It could be standalone or be part of a form.
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *   <aw-form-table >
 *       <aw-form-row [label]="'Amount'" [name]="'amount'" [size]="'small'">
 *
 *           <aw-button [type]="'submit'" [name]="'button'"
 *                     (action)="onClicked($event)" [value]="command"
 *                     [style]="'warning'" >Button</aw-button>
 *       </aw-form-row>
 *   </aw-form-table>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        command:boolean;
 *
 *        constructor ()
 *        {
 *        }
 *
 *        onClicked(value:string) {
 *           if (value) {
 *              // submit form.
 *           }
 *        }
 *    }
 */
var ButtonComponent = /** @class */ (function (_super) {
    __extends(ButtonComponent, _super);
    function ButtonComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        /**
         * Button types  [ button | submit | reset ]
         *
         */
        _this.type = 'button';
        /**
         * styling for this button. See ButtonStyle for all supported styles.
         */
        _this.style = 'primary';
        /**
         * sizing for this button. [large, normal, small].
         */
        _this.size = 'normal';
        /**
         * Event fired when user select a item
         */
        _this.action = new EventEmitter();
        // Default button class is secondary.
        // Default button class is secondary.
        _this.buttonClass = 'ui-button-secondary';
        // Default disabled
        // Default disabled
        _this.disabled = false;
        return _this;
    }
    /**
     * @return {?}
     */
    ButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        // How to style this button.
        if (isPresent(this.style)) {
            if (this.style === 'primary') {
                // Default .ui-button and .ui-button-primary get the same style.
                // .ui-button-primary is necessary because button style can be overridden
                // when included inside other widgets. So specify primary
                this.buttonClass = 'ui-button-primary';
            }
            else {
                this.buttonClass = 'ui-button-' + this.style;
            }
        }
        // Determine the button class based on input size.
        if (this.size) {
            switch (this.size) {
                case 'large':
                    this.buttonClass += ' btn-lg';
                    break;
                case 'normal':
                    this.buttonClass += ' btn-mid';
                    break;
                case 'small':
                    this.buttonClass += ' btn-sm';
                    break;
            }
        }
    };
    /**
     * This is little hacky hackity hack as currently primeng button directive does not work with
     * ngcontent projection but it has a label bindings, which is not the way developers work with
     * button. you want to
     *
     * <button> MY CONTENT</button instead of <button label='MyContent'></button>
     *
     *
     * @Todo: Change this until the time keep a test that check that they are still using ui-button
     *     that we are expecting and replacing
     */
    /**
     * This is little hacky hackity hack as currently primeng button directive does not work with
     * ngcontent projection but it has a label bindings, which is not the way developers work with
     * button. you want to
     *
     * <button> MY CONTENT</button instead of <button label='MyContent'></button>
     *
     *
     * \@Todo: Change this until the time keep a test that check that they are still using ui-button
     *     that we are expecting and replacing
     * @return {?}
     */
    ButtonComponent.prototype.ngAfterViewInit = /**
     * This is little hacky hackity hack as currently primeng button directive does not work with
     * ngcontent projection but it has a label bindings, which is not the way developers work with
     * button. you want to
     *
     * <button> MY CONTENT</button instead of <button label='MyContent'></button>
     *
     *
     * \@Todo: Change this until the time keep a test that check that they are still using ui-button
     *     that we are expecting and replacing
     * @return {?}
     */
    function () {
        if (isPresent(this.element)) {
            var /** @type {?} */ button = this.element.nativeElement.querySelector('button');
            var /** @type {?} */ buttonTitle = button.children[0];
            button.children[0].textContent = this.element.nativeElement.textContent.trim()
                .replace('ui-button', '').replace('ui-btn', '');
            button.classList.remove('ui-button-text-empty');
            button.textContent = '';
            button.appendChild(buttonTitle);
        }
    };
    /**
     *  Action clicked. Call parent action.
     */
    /**
     *  Action clicked. Call parent action.
     * @param {?} $event
     * @return {?}
     */
    ButtonComponent.prototype.clicked = /**
     *  Action clicked. Call parent action.
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.action.emit(isBlank(this.value) ? $event : this.value);
    };
    ButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-button',
                    template: "<button\n    pButton\n    [attr.type]=\"type\"\n    [attr.name]=\"name\"\n    [ngClass]=\"buttonClass\"\n    [disabled]=\"disabled\"\n    [attr.value]=\"value\"\n    (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</button>\n",
                    styles: [".ui-button-link{color:#337ab7;font-weight:400;border-radius:0;background-color:transparent}.ui-button-link,.ui-button-link.active,.ui-button-link:active,.ui-button-link:focus,.ui-button-link:hover,.ui-button-link[disabled]{border-color:transparent}.ui-button-link:focus,.ui-button-link:hover{color:#337ab7;-webkit-text-decoration:#337ab7;text-decoration:#337ab7;background-color:transparent}.ui-button-link[disabled]:focus,.ui-button-link[disabled]:hover{color:#2399e5;text-decoration:none}.ui-button{margin-right:5px}.btn-mid{height:36px;padding:5px 10px}.btn-lg{height:42px;font-size:16px;padding:5px 12px}.btn-sm{height:30px;font-size:12px;padding:5px 10px}"]
                },] },
    ];
    /** @nocollapse */
    ButtonComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    ButtonComponent.propDecorators = {
        type: [{ type: Input }],
        name: [{ type: Input }],
        style: [{ type: Input }],
        size: [{ type: Input }],
        target: [{ type: Input }],
        value: [{ type: Input }],
        action: [{ type: Output }]
    };
    return ButtonComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWButtonModule = /** @class */ (function () {
    function AWButtonModule() {
    }
    AWButtonModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ButtonComponent
                    ],
                    imports: [
                        CommonModule,
                        ButtonModule,
                    ],
                    entryComponents: [
                        ButtonComponent
                    ],
                    exports: [
                        ButtonComponent
                    ],
                    providers: []
                },] },
    ];
    return AWButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWBasicNavigatorModule = /** @class */ (function () {
    function AWBasicNavigatorModule() {
    }
    AWBasicNavigatorModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        BasicNavigatorComponent
                    ],
                    imports: [
                        CommonModule,
                        ToolbarModule,
                        AWButtonModule,
                        AWCoreComponentModule
                    ],
                    exports: [
                        BasicNavigatorComponent
                    ],
                    providers: []
                },] },
    ];
    return AWBasicNavigatorModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CardZoneTopComponent = /** @class */ (function () {
    function CardZoneTopComponent() {
    }
    CardZoneTopComponent.decorators = [
        { type: Directive, args: [{
                    selector: "aw-card-top",
                    host: {
                        'class': 'w-card-ztop'
                    }
                },] },
    ];
    return CardZoneTopComponent;
}());
var CardZoneBottomComponent = /** @class */ (function () {
    function CardZoneBottomComponent() {
    }
    CardZoneBottomComponent.decorators = [
        { type: Directive, args: [{
                    selector: "aw-card-bottom",
                    host: {
                        'class': 'w-card-zbottom'
                    }
                },] },
    ];
    return CardZoneBottomComponent;
}());
/**
 *
 * Card component is a container rendering its content inside 3 different zones.
 *
 *  ------------------------------------------
 *  |   TITLE                       | ACTION |
 *  |-----------------------------------------
 *  |                                        |
 *  |   TOP                                  |
 *  |                                        |
 *  ------------------------------------------
 *  |                                        |
 *  |   BOTTOM                               |
 *  |                                        |
 *  |                                        |
 *  ------------------------------------------
 *
 *
 *  There are 3 zones  + 1 placeholder for the actionIcon
 *
 *  Cards can be selectable which means when you click on it there will be rendered a border with
 *  a check mark inside Action zone (this is default behavior).
 *  You can use [selectable] binding to disable this, in such case card will have just a border
 *  without any check mark.
 *
 *  Cards can also contain custom Action which is rendered inside ACTION zone and on the
 *  application level you can listen for (click) events as well as you can provide your own action
 *  icon
 *
 *  Besides ACTION, TITLE, TOP and BOTTOM content zones cards support hover overlay effect and
 *  when its activated there is a overlay displayed on top of the card with Icon in the middle.
 *  Please note when [hasHover] is TRUE all the actions and selectability are disabled as there is
 *  only one action which click on the hover overlay.
 *
 *
 * ###example 1:
 *  Basic hover card which by default support selectable mode
 *
 * ```
 *          <aw-card #card1 [hasAction]="false" [width]="'202px'" [height]="'154px'">
 *
 *                 <aw-card-title [align]="'bottom-left'">
 *                     <span class="a-supplier-tag">
 *                         Preferred
 *                     </span>
 *                 </aw-card-title>
 *
 *                 <aw-card-top>
 *                     <div class="supplierName">
 *                         Haight Pumps
 *                     </div>
 *                     <div class="supplierLocation">
 *                         Palo Alto, CA, USA
 *                     </div>
 *                 </aw-card-top>
 *
 *                 <aw-card-bottom class="w-card-zbottom">
 *                     some text about the supplier and his parents<br/>
 *                     and some contacts
 *                 </aw-card-bottom>
 *
 *             </aw-card>
 *
 * ```
 *
 *  ###example 2:
 *   Hover card with custom action. when unselected action will appear and user can click on it.
 *
 * ```
 *          <aw-card #card1 [selectable]="true" [actionIcon]="'icon-question-mark'"
 *                     (onAction)="onAction(3, $event)">
 *
 *                 <aw-card-title [align]="'bottom-left'">
 *                     <span class="a-supplier-tag">
 *                         Preferred
 *                     </span>
 *                 </aw-card-title>
 *
 *                 <aw-card-top>
 *                     <div class="supplierName">
 *                         Haight Pumps
 *                     </div>
 *                     <div class="supplierLocation">
 *                         Palo Alto, CA, USA
 *                     </div>
 *                 </aw-card-top>
 *
 *                 <aw-card-bottom class="w-card-zbottom">
 *                     some text about the supplier and his parents<br/>
 *                     and some contacts
 *                 </aw-card-bottom>
 *
 *             </aw-card>
 *
 * ```
 *
 *
 *
 */
var CardComponent = /** @class */ (function (_super) {
    __extends(CardComponent, _super);
    function CardComponent(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * Tells if we should explicitly hide the action
         *
         */
        _this.hasAction = false;
        /**
         *
         * Is selectable mode supported? Saying Yes, card will have by default check-mark in the
         * ACTION zone when selected
         *
         */
        _this.selectable = true;
        /**
         * Option to pass custom "Card Selected" Icon
         *
         */
        _this.selectedIcon = 'icon-accept';
        /*
             * Enable and disables hover effect on top of the card
             */
        _this.hasHover = false;
        /**
         *
         * Default icon name for the hover overlay. This icons shows up in the middle over the card
         * vertically and horizontally centered
         *
         */
        _this.hoverIcon = 'icon-add';
        /**
         *  Selection state
         *
         */
        _this.selected = true;
        /**
         * Fired when the card is selected.
         *
         */
        _this.onSelect = new EventEmitter();
        /**
         * Fired when action icon is clicked.
         *
         */
        _this.onAction = new EventEmitter();
        /**
         * Fired when the user clicks on the hover overlay.
         *
         */
        _this.onHoverAction = new EventEmitter();
        /**
         * Usually when template is provided we want to use it and replace internal one but in this
         * case it will be always conditional and application developer can switch between default
         * template with zones and custom one provided by developer.
         *
         */
        _this.useBodyTemplate = false;
        // sets default value
        // sets default value
        _this.width = '202px';
        _this.height = '154px';
        return _this;
    }
    /**
     * @return {?}
     */
    CardComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        // If application wants to use action it must provide actionIcon
        if (isBlank(this.actionIcon) && this.hasAction) {
            throw new Error('You need to provide action icon');
        }
    };
    /**
     * @return {?}
     */
    CardComponent.prototype.showBottomSection = /**
     * @return {?}
     */
    function () {
        return isPresent(this.bottom);
    };
    /**
     * fires select and unselect event.
     */
    /**
     * fires select and unselect event.
     * @param {?} event
     * @return {?}
     */
    CardComponent.prototype.toggleSelect = /**
     * fires select and unselect event.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.selectable) {
            event.preventDefault();
            event.stopPropagation();
        }
        else {
            this.selected = !this.selected;
            this.onSelect.emit(this.selected);
        }
    };
    /**
     *
     * Only fired when action is rendered and user clicks on custom actionIcon
     *
     */
    /**
     *
     * Only fired when action is rendered and user clicks on custom actionIcon
     *
     * @param {?} event
     * @return {?}
     */
    CardComponent.prototype.onActionClick = /**
     *
     * Only fired when action is rendered and user clicks on custom actionIcon
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.hasAction && (!this.selected || !this.selectable)) {
            this.onAction.emit(this.selected);
        }
    };
    /**
     * Triggered  when hover effect is on + user click on the card
     *
     */
    /**
     * Triggered  when hover effect is on + user click on the card
     *
     * @param {?} isEnter
     * @return {?}
     */
    CardComponent.prototype.onHover = /**
     * Triggered  when hover effect is on + user click on the card
     *
     * @param {?} isEnter
     * @return {?}
     */
    function (isEnter) {
        if (isPresent(this.hoverDiv)) {
            this.hoverDiv.nativeElement.style.opacity = isEnter ? 0.5 : 0;
        }
    };
    /**
     *
     * Used to decide if we should render implicit card template with our zones or
     * user provided template
     *
     */
    /**
     *
     * Used to decide if we should render implicit card template with our zones or
     * user provided template
     *
     * @return {?}
     */
    CardComponent.prototype.showBodyTemplate = /**
     *
     * Used to decide if we should render implicit card template with our zones or
     * user provided template
     *
     * @return {?}
     */
    function () {
        return isPresent(this.bodyTemplate) && this.useBodyTemplate;
    };
    CardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-card',
                    template: "<div class=\"w-card\" [style.width]=\"width\" [style.height]=\"height\"\n     [class.u-is-hover]=\"hasHover\"\n     (mouseenter)=\"onHover(true)\"\n     (mouseleave)=\"onHover(false)\"\n     [class.u-card-selected]=\"selected\"\n     [class.u-card-unselected]=\"!selected\"\n     [ngClass]=\"styleClass\"\n>\n\n    <div class=\"card-body ui-g\"  *ngIf=\"!showBodyTemplate()\">\n        <!-- Hover element that is triggered by mouseenter, mouseleave events-->\n        <div #hoverDiv *ngIf=\"hasHover\" class=\"u-card-hover\" (click)=\"onHoverAction.emit($event)\">\n            <span [style.width]=\"'100%'\" class=\"sap-icon\" [ngClass]=\"hoverIcon\"></span>\n        </div>\n        <!-- HEADER HAVING TITLE AND ICONS/ACTIONS-->\n        <div class=\"ui-g-12 ui-g-nopad w-card-header\">\n            <div class=\"w-card-ztitle ui-g-nopad\" (click)=\"toggleSelect($event)\"\n                 [class.u-card-pointer]=\"selectable\"\n                 [ngClass]=\"{'ui-g-9': hasAction || selectable, 'ui-g-11': !hasAction && !selectable}\">\n                <ng-content select=\"aw-card-title\"></ng-content>\n            </div>\n\n            <div *ngIf=\"hasAction || selectable\" class=\"w-card-zaction ui-g-nopad ui-g-3\">\n\n                <span *ngIf=\"selected && selectable\" class=\"sap-icon selection\"\n                      [class.u-card-pointer]=\"selectable\"\n                      [class.u-card-action-bg]=\"selected\"\n                      (click)=\"toggleSelect($event)\"\n                      [ngClass]=\"selectedIcon\"></span>\n\n\n                <span *ngIf=\"hasAction && (!selected || !selectable) \"\n                      class=\"sap-icon action\"\n                      [class.u-card-pointer]=\"true\"\n                      (click)=\"onActionClick($event)\"\n                      [ngClass]=\"actionIcon\"\n                ></span>\n            </div>\n        </div>\n\n        <!--TOP CARD SECTION-->\n        <div class=\"w-card-ztop ui-g-nopad ui-g-12 \"\n             (click)=\"toggleSelect($event)\"\n             [class.u-card-pointer]=\"selectable\">\n            <ng-content select=\"aw-card-top\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-g-nopad w-card-line-divider  \" *ngIf=\"showBottomSection()\"></div>\n        <!--BOTTOM CARD SECTION-->\n        <div *ngIf=\"showBottomSection()\" class=\"ui-g-12 ui-g-nopad w-card-zbottom\"\n             [class.u-card-pointer]=\"selectable\"\n             (click)=\"toggleSelect($event)\">\n            <ng-content select=\"aw-card-bottom\"></ng-content>\n        </div>\n    </div>\n\n    <div *ngIf=\"showBodyTemplate()\" class=\"w-card-user-cnt\" >\n        <ng-container *ngTemplateOutlet=\"bodyTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n",
                    styles: [".w-card{border:2px solid #0076cb;display:inline-block;overflow:hidden;color:#636363;box-sizing:border-box}.w-card-header{position:relative;height:30px;padding-left:1em}.w-card-ztitle{height:100%;padding-top:3px}.w-card-ztitle ::ng-deep .w-card-title{height:100%;width:100%;display:flex}.w-card-ztitle ::ng-deep .w-card-title>*{flex:0 1}.w-card-zaction{height:100%;display:inline-block;text-align:right}.w-card-zaction .sap-icon{width:29px;height:29px;text-align:center;display:inline-block;font-size:1.5em;line-height:1.4em}.w-card-zaction .sap-icon.selection{color:#fff}.w-card-zaction .sap-icon.action{color:#969696}.w-card-zbottom,.w-card-ztop{padding:1em}.w-card-line-divider{border-top:1px solid #d6d6d6;margin:0 14px}.w-card-user-cnt{width:100%;height:100%;position:relative;background-color:#eee}.u-card-hover{position:absolute;height:100%;width:100%;opacity:0;transition:.5s ease;background-color:#0076cb;z-index:100}.u-card-hover .sap-icon{text-align:center;display:inline-block;font-size:4em;color:#fff;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.u-card-action-bg{background:#0076cb}.u-is-hover{position:relative}.u-card-selected{border-color:#0076cb}.u-card-unselected{border-color:#d7d7d7}.u-card-hover,.u-card-pointer{cursor:pointer}"]
                },] },
    ];
    /** @nocollapse */
    CardComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    CardComponent.propDecorators = {
        hasAction: [{ type: Input }],
        selectable: [{ type: Input }],
        selectedIcon: [{ type: Input }],
        actionIcon: [{ type: Input }],
        hasHover: [{ type: Input }],
        hoverIcon: [{ type: Input }],
        selected: [{ type: Input }],
        onSelect: [{ type: Output }],
        onAction: [{ type: Output }],
        onHoverAction: [{ type: Output }],
        bottom: [{ type: ContentChild, args: [CardZoneBottomComponent,] }],
        bodyTemplate: [{ type: ContentChild, args: ['body',] }],
        hoverDiv: [{ type: ViewChild, args: ['hoverDiv',] }]
    };
    return CardComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Maps our internal alignment value to real css values
 *
 */
var /** @type {?} */ VAlignMap = {
    'top-left': 'flex-start',
    'top-center': 'flex-start',
    'top-right': 'flex-start',
    'center-left': 'center',
    'center-center': 'center',
    'center-right': 'center',
    'bottom-left': 'flex-end',
    'bottom-center': 'flex-end',
    'bottom-right': 'flex-end'
};
var /** @type {?} */ HAlignMap = {
    'top-left': 'flex-start',
    'top-center': 'center',
    'top-right': 'flex-end',
    'center-left': 'flex-start',
    'center-center': 'center',
    'center-right': 'flex-end',
    'bottom-left': 'flex-start',
    'bottom-center': 'center',
    'bottom-right': 'flex-end'
};
/**
 * Title zone provides a content placeholder for the Title Area. This zone is adding ability
 * to align its content into 9 different position.
 *
 * You can use this Title zone within <aw-card> as:
 *
 *
 * ```html
 *
 *  <aw-card  [width]="'202px'" [height]="'154px'" [hasHover]="true"
 *                       [selectable]="false" [hasAction]="false"
 *                  (onHoverAction)="onAction(7, $event)" >
 *
 *                  <aw-card-title [align]="'bottom-left'">
 *                      <span class="a-supplier-tag">
 *                          Preferred
 *                      </span>
 *                  </aw-card-title>
 *
 *   </aw-card>
 *
 * ```
 * Default alignment is top-left
 *
 *
 *
 *
 */
var CardZoneTitleComponent = /** @class */ (function (_super) {
    __extends(CardZoneTitleComponent, _super);
    function CardZoneTitleComponent(env, elem) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.elem = elem;
        /**
         * Special property which is used to apply flex properties for aligning content vertically
         * as well as horizontally
         *
         */
        _this.align = 'top-left';
        return _this;
    }
    /**
     * @return {?}
     */
    CardZoneTitleComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.elem.nativeElement.style.alignItems = VAlignMap[this.align];
        this.elem.nativeElement.style.justifyContent = HAlignMap[this.align];
    };
    CardZoneTitleComponent.decorators = [
        { type: Directive, args: [{
                    selector: "aw-card-title",
                    host: {
                        'class': 'w-card-title'
                    }
                },] },
    ];
    /** @nocollapse */
    CardZoneTitleComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: ElementRef }
    ]; };
    CardZoneTitleComponent.propDecorators = {
        align: [{ type: Input }]
    };
    return CardZoneTitleComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWCardModule = /** @class */ (function () {
    function AWCardModule() {
    }
    AWCardModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        CardComponent,
                        CardZoneTitleComponent,
                        CardZoneTopComponent,
                        CardZoneBottomComponent
                    ],
                    entryComponents: [
                        CardComponent
                    ],
                    exports: [
                        CardComponent,
                        CardZoneTitleComponent,
                        CardZoneTopComponent,
                        CardZoneBottomComponent
                    ],
                    providers: []
                },] },
    ];
    return AWCardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Implements standard HTML checkbox on top of PrimeNG. There are 2 types of
 * {\@link CheckboxComponent}: form and action checkbox as described above.
 *
 *
 * Usage: Basic example having red checkbox checked
 *
 * ```HTML
 *        <aw-checkbox [name]="'color'" [value]="'red'" [label]="'Red'"
 *                                        [(ngModel)]="model">
 *        </aw-checkbox>
 *        <aw-checkbox [name]="'color'" [value]="'blue'" [label]="'Blue'"
 *                                        [(ngModel)]="model">
 *       </aw-checkbox>
 *
 * ```
 *
 * ```ts
 *
 *
 *   class CBBasicWithNgModelComponent
 *   {
 *
 *       model: string[] = ['red'];
 *
 *       constructor()
 *       {
 *       }
 *   }
 *
 * ```
 *
 * For more examples please see a playground or unit test.
 *
 */
var /** @type {?} */ CB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return CheckboxComponent; }),
    multi: true
};
var CheckboxComponent = /** @class */ (function (_super) {
    __extends(CheckboxComponent, _super);
    function CheckboxComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         *
         * A value associated with this checkbox
         *
         */
        _this.value = '';
        /**
         * Type of checkbox. Form based updates model and Action based only fires click events
         *
         */
        _this.type = 'form';
        /**
         * Trigger click event.
         *
         */
        _this.action = new EventEmitter();
        /**
         * PrimeNG has this type called binary which works only with Boolean meaning it does not add or
         * remove values.
         *
         * In our case Checktype = Action is always binary or when this.value is boolean
         *
         */
        _this.isBinary = false;
        return _this;
    }
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.model = this.value;
        this.type = this.action.observers.length > 0 ? 'action' : this.type;
        if (this.isFormType()) {
            _super.prototype.ngOnInit.call(this);
            if (this.isStandalone) {
                _super.prototype.registerFormControl.call(this, this.value);
                this.model = this.formControl.value;
                this.onModelChanged(this.model);
            }
            else {
                // get control from parent
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
        // When value is boolean we are dealing with PrimeNg Binary checkbox
        // which only sets TRUE/FALSE and does not add or remove values
        this.isBinary = isBoolean(this.value);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CheckboxComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (isPresent(changes['value']) &&
            (changes['value'].currentValue !== changes['value'].previousValue)) {
            this.model = changes['value'].currentValue;
        }
    };
    /**
     * Called when Checkbox is clicked and it either fire action or updates the model.
     *
     */
    /**
     * Called when Checkbox is clicked and it either fire action or updates the model.
     *
     * @param {?} event
     * @return {?}
     */
    CheckboxComponent.prototype.onChange = /**
     * Called when Checkbox is clicked and it either fire action or updates the model.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isFormType()) {
            this.onModelChanged(this.model);
            if (this.isStandalone) {
                this.formControl.setValue(this.model);
            }
        }
        else {
            this.action.emit(event);
        }
    };
    /**
     *
     * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
     * applicable for certain type.
     *
     */
    /**
     *
     * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
     * applicable for certain type.
     *
     * @return {?}
     */
    CheckboxComponent.prototype.isFormType = /**
     *
     * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
     * applicable for certain type.
     *
     * @return {?}
     */
    function () {
        return this.type === 'form';
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    CheckboxComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.model && this.isFormType()) {
            this.model = value;
            if (this.isStandalone) {
                this.onModelChanged(this.model);
                this.formControl.setValue(this.model);
            }
        }
    };
    CheckboxComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-checkbox',
                    template: "<span class=\"w-checkbox\">\n\n    <ng-template [ngIf]=\"editable && isFormType()\">\n        <p-checkbox [name]=\"name\" [value]=\"value\" [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    [binary]=\"isBinary\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\"\n                    [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        >\n        </p-checkbox>\n    </ng-template>\n\n\n    <ng-template [ngIf]=\"!isFormType()\">\n        <p-checkbox [binary]=\"isBinary\"\n                    [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\">\n        </p-checkbox>\n\n    </ng-template>\n</span>\n",
                    styles: ["/deep/ .ui-chkbox .ui-chkbox-box{width:22px;height:22px}/deep/ .ui-chkbox .pi{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.07em;line-height:1.42em}/deep/ .ui-chkbox .pi.pi-check:before{content:'\\e05b'}"],
                    providers: [
                        CB_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return CheckboxComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    CheckboxComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    CheckboxComponent.propDecorators = {
        value: [{ type: Input }],
        type: [{ type: Input }],
        label: [{ type: Input }],
        action: [{ type: Output }]
    };
    return CheckboxComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWCheckBoxModule = /** @class */ (function () {
    function AWCheckBoxModule() {
    }
    AWCheckBoxModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        CheckboxComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        CheckboxModule
                    ],
                    entryComponents: [
                        CheckboxComponent
                    ],
                    exports: [
                        CheckboxComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWCheckBoxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  Checkbox list is a wrapper class around 'Checkbox' component to simply assembly of multi choice
 * component
 *
 * In Addition it adds ability to work with complex object. PrimeNG checkboxes work only with
 * primitive values.
 *
 * @see {\@link check-box/check-box.component.ts}
 *
 *
 * ### Example
 *
 *
 * \@Component({
 *       selector: 'showCheckBoxList' ,
 *       template: `
 *           <aw-checkbox-list [list]="checkBoxListValues" [selections]="selectedValues"
 *
 *            [name]="'myColors'" [formGroup]="formGroup" (onSelection)="onCBClick">
 *           </aw-checkbox-list>
 *       `
 *
 *       })
 *        class MyShowCLComponent
 *        {
 *            checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' ,
 *     'silver' , 'black' ,
 *            'Green' , 'Gray' , 'Navy' , 'Olive' , 'Aqua' , 'Purple'];
 *
 *            selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
 *
 *
 *            formGroup: FormGroup = new FormGroup({});
 *
 *
 *            onCBClick (event): void
 *            {
 *                console.log('onCBClick = ' + event);
 *            }
 *
 *        }
 * *
 */
var /** @type {?} */ CB_LIST_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return CheckBoxListComponent; }),
    multi: true
};
var CheckBoxListComponent = /** @class */ (function (_super) {
    __extends(CheckBoxListComponent, _super);
    function CheckBoxListComponent(env, cd, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.cd = cd;
        _this.parentContainer = parentContainer;
        /**
         * Fires event when checkbox is selected/clicked. Emits current clicked checkboxed. not the
         * actuall internal model value in this case array of choices
         *
         */
        _this.onSelection = new EventEmitter();
        /**
         * Internal model
         */
        _this.model = [];
        return _this;
    }
    /**
     * @return {?}
     */
    CheckBoxListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isBlank(this.selections)) {
            this.selections = [];
        }
        this.registerFormControl(this.selections);
        this.updateModel(this.selections);
        this.onModelChanged(this.selections);
    };
    /**
     * @return {?}
     */
    CheckBoxListComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ updatedModel = [];
        this.model.forEach(function (index) { return updatedModel.push(_this.list[index]); });
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
        this.cd.detectChanges();
    };
    /**
     * Label is extracted into this method so in the future we can play more how we want to display
     * the value. Since I want to support formatters for each components we might have a chance to
     * decide how label will look like.
     *
     */
    /**
     * Label is extracted into this method so in the future we can play more how we want to display
     * the value. Since I want to support formatters for each components we might have a chance to
     * decide how label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    CheckBoxListComponent.prototype.labelValue = /**
     * Label is extracted into this method so in the future we can play more how we want to display
     * the value. Since I want to support formatters for each components we might have a chance to
     * decide how label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isPresent(this.labelFormatter)) {
            return this.labelFormatter(item);
        }
        return item.toString();
    };
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     */
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     * @param {?} item
     * @return {?}
     */
    CheckBoxListComponent.prototype.value = /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item;
    };
    /**
     * Delegate event outside of this component and convert indexed model to original objects
     *
     */
    /**
     * Delegate event outside of this component and convert indexed model to original objects
     *
     * @param {?} event
     * @return {?}
     */
    CheckBoxListComponent.prototype.onChange = /**
     * Delegate event outside of this component and convert indexed model to original objects
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        var /** @type {?} */ updatedModel = [];
        this.model.forEach(function (index) {
            updatedModel.push(_this.list[index]);
        });
        this.onSelection.emit(updatedModel);
        this.onModelChanged(updatedModel);
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
    };
    /**
     * Since we might be dealing with complex object store only INDEXes number in the model.
     *
     */
    /**
     * Since we might be dealing with complex object store only INDEXes number in the model.
     *
     * @param {?} sourceList
     * @return {?}
     */
    CheckBoxListComponent.prototype.updateModel = /**
     * Since we might be dealing with complex object store only INDEXes number in the model.
     *
     * @param {?} sourceList
     * @return {?}
     */
    function (sourceList) {
        var _this = this;
        sourceList.forEach(function (item) {
            var /** @type {?} */ index = _this.list.findIndex(function (elem) {
                return equals(item, elem);
            });
            _this.model.push(index);
        });
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    CheckBoxListComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (isPresent(this.model) && isPresent(value)) {
            var /** @type {?} */ newModel = value;
            this.updateModel(newModel);
            // this.cd.markForCheck();
        }
    };
    CheckBoxListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-checkbox-list',
                    template: "<div *ngFor=\"let item of list; let i = index\" class=\"ui-g\">\n\n    <!-- in the future we should be able to to support inline and stack-->\n    <div class=\"ui-g-12\">\n        <aw-checkbox [(ngModel)]=\"model\"\n                     (ngModelChange)=\"onChange($event)\"\n                     [editable]=\"editable\"\n                     [isStandalone]=\"false\"\n                     [name]=\"name\"\n                     [value]=\"i\"\n                     [label]=\"labelValue(item)\">\n\n        </aw-checkbox>\n    </div>\n\n</div>\n\n",
                    styles: [""],
                    providers: [
                        CB_LIST_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return CheckBoxListComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    CheckBoxListComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: ChangeDetectorRef },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    CheckBoxListComponent.propDecorators = {
        list: [{ type: Input }],
        selections: [{ type: Input }],
        onSelection: [{ type: Output }],
        labelFormatter: [{ type: Input }]
    };
    return CheckBoxListComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWCheckBoxListModule = /** @class */ (function () {
    function AWCheckBoxListModule() {
    }
    AWCheckBoxListModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        CheckBoxListComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        AWCheckBoxModule
                    ],
                    exports: [
                        CheckBoxListComponent
                    ],
                    providers: []
                },] },
    ];
    return AWCheckBoxListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Hyperlink component that implements consistent styling, behavior. Hyperlink supports all of the
 * native link functionality. In addition, it supports navigation to components through the action
 * binding.
 *
 *
 * for more info please see class Doc of the:
 * @see {\@link button/button.component.ts}
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *           <aw-hyperlink  [type]="'text/html'" [name]="'link'"
 *                        (action)="onClicked($event)" [value]="customerId"
 *                        [size]="'large'" >my link</aw-hyperlink>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        command:boolean;
 *
 *        constructor ()
 *        {
 *        }
 *
 *        onClicked(customerId:string) {
 *           if (customerId) {
 *              // display customer details component.
 *           }
 *        }
 *    }
 */
var HyperlinkComponent = /** @class */ (function (_super) {
    __extends(HyperlinkComponent, _super);
    function HyperlinkComponent(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * sizing for this link. [large, normal, small].
         */
        _this.size = 'normal';
        /**
         * Event fired when user select a item
         */
        _this.action = new EventEmitter();
        /**
         * Internal CSS class that styles this hyperlink based on input 'size'
         */
        _this.linkClass = 'link';
        return _this;
    }
    /**
     * @return {?}
     */
    HyperlinkComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        // Determine the link class based on input size.
        if (this.size) {
            switch (this.size) {
                case 'large':
                    this.linkClass += ' link-lg';
                    break;
                case 'normal':
                    this.linkClass += ' link-mid';
                    break;
                case 'small':
                    this.linkClass += ' link-sm';
                    break;
            }
        }
        // If I have an action tag, and no href. We add default styling and behavior.
        if (this.action.observers.length > 0) {
            this.linkClass += ' link-bh';
        }
    };
    /**
     *  Action clicked. Call parent action.
     */
    /**
     *  Action clicked. Call parent action.
     * @param {?} event
     * @return {?}
     */
    HyperlinkComponent.prototype.clicked = /**
     *  Action clicked. Call parent action.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.action.emit({
            event: event,
            value: this.value
        });
    };
    HyperlinkComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-hyperlink',
                    template: "<a [attr.type]=\"type\"\n   [attr.href]=\"href\"\n   [attr.rel]=\"rel\"\n   [attr.target]=\"target\"\n   [ngClass]=\"linkClass\"\n   [class.disabled]=\"disabled\"\n   (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</a>\n",
                    styles: [".link{color:#0275d8;cursor:pointer}.link.link-bh{color:#0275d8}.link.link-bh:hover{text-decoration:underline;cursor:pointer}.link-sm{font-size:.875em}.link-mid{font-size:1em}.link-lg{font-size:1.25em}.link.disabled{pointer-events:none;cursor:default;color:#ddd}"]
                },] },
    ];
    /** @nocollapse */
    HyperlinkComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    HyperlinkComponent.propDecorators = {
        type: [{ type: Input }],
        href: [{ type: Input }],
        rel: [{ type: Input }],
        size: [{ type: Input }],
        target: [{ type: Input }],
        value: [{ type: Input }],
        action: [{ type: Output }]
    };
    return HyperlinkComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWHyperlinkModule = /** @class */ (function () {
    function AWHyperlinkModule() {
    }
    AWHyperlinkModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        HyperlinkComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    entryComponents: [
                        HyperlinkComponent
                    ],
                    exports: [
                        HyperlinkComponent
                    ],
                    providers: []
                },] },
    ];
    return AWHyperlinkModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Selection State for the chooser in order to be able to comunicate with the parent object using a
 * chooser. If I would have to manage only single values with no addional methods i would user
 * emitters to do the job, but in this case we need this interface (abstract class) between a
 * chooser and actual object.
 *
 *
 * @abstract
 */
var  /**
 * Selection State for the chooser in order to be able to comunicate with the parent object using a
 * chooser. If I would have to manage only single values with no addional methods i would user
 * emitters to do the job, but in this case we need this interface (abstract class) between a
 * chooser and actual object.
 *
 *
 * @abstract
 */
ChooserSelectionState = /** @class */ (function () {
    function ChooserSelectionState() {
    }
    /**
     *
     * Set selection state is usually triggered by selecting and unselecting a item (in case of
     * multiselect) and it should update its list of objects with either settings/adding item or
     * removing it.
     *
     *
     */
    /**
     *
     * Set selection state is usually triggered by selecting and unselecting a item (in case of
     * multiselect) and it should update its list of objects with either settings/adding item or
     * removing it.
     *
     *
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    ChooserSelectionState.prototype.setSelectionState = /**
     *
     * Set selection state is usually triggered by selecting and unselecting a item (in case of
     * multiselect) and it should update its list of objects with either settings/adding item or
     * removing it.
     *
     *
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    function (selection, selected) {
    };
    /**
     * The most recent selection . Null if last action was a deselection. Usually used by Chooser
     * or ChooserState to get cuurent value.
     *
     */
    /**
     * The most recent selection . Null if last action was a deselection. Usually used by Chooser
     * or ChooserState to get cuurent value.
     *
     * @return {?}
     */
    ChooserSelectionState.prototype.selectedObject = /**
     * The most recent selection . Null if last action was a deselection. Usually used by Chooser
     * or ChooserState to get cuurent value.
     *
     * @return {?}
     */
    function () {
        return unimplemented();
    };
    /**
     * The most recent selections.
     *
     */
    /**
     * The most recent selections.
     *
     * @return {?}
     */
    ChooserSelectionState.prototype.selectedObjects = /**
     * The most recent selections.
     *
     * @return {?}
     */
    function () {
        return unimplemented();
    };
    /**
     *
     * Check if the item selection items is in the selectedObjects
     */
    /**
     *
     * Check if the item selection items is in the selectedObjects
     * @param {?} selection
     * @return {?}
     */
    ChooserSelectionState.prototype.isSelected = /**
     *
     * Check if the item selection items is in the selectedObjects
     * @param {?} selection
     * @return {?}
     */
    function (selection) {
        return unimplemented();
    };
    return ChooserSelectionState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
 * selection as well as it can broadcast any updates.
 *
 *
 */
var  /**
 * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
 * selection as well as it can broadcast any updates.
 *
 *
 */
ChooserState = /** @class */ (function () {
    function ChooserState(chooserSelectionState, isMulti) {
        if (isMulti === void 0) { isMulti = true; }
        /**
         * Indicates if there are any validation like entered value does not much with the source list.
         *
         */
        this.isInvalid = false;
        /**
         *
         * indicates that we started to some editing e.g. starting to type in something into the
         * filter, or removing already selected items
         */
        this.addMode = false;
        this.recentSelectedDisplayed = 0;
        /**
         * When this option is active we do not show all selected items, but max number that is
         * defined. User is able to toggle to expand the view to see all selections and hide them as
         * well
         */
        this.showAllRecentlySelected = false;
        this.selectionState = chooserSelectionState;
        this.multiselect = isMulti;
        if (isBlank(this.selectionState)) {
            this.selectionState = new DefaultSelectionState(this.multiselect);
        }
    }
    /**
     *
     * It will select and persist an item using ChooserSelectionState provider.
     *
     */
    /**
     *
     * It will select and persist an item using ChooserSelectionState provider.
     *
     * @param {?} item
     * @return {?}
     */
    ChooserState.prototype.updatedSelectedObjects = /**
     *
     * It will select and persist an item using ChooserSelectionState provider.
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isBlank(item)) {
            item = this.currentItem;
        }
        if (!this.multiselect) {
            this.setSelectionState(item, true);
        }
        else {
            var /** @type {?} */ selectedObject = this.selectedObject();
            var /** @type {?} */ selectedObjects = this.selectedObjects();
            if (this.addMode) {
                if (this.isInvalid) {
                    if (isPresent(selectedObject)) {
                        this.setSelectionState(selectedObject, false);
                    }
                }
                this.setSelectionState(item, !ListWrapper.containsComplex(selectedObjects, item));
            }
            else {
                if (isPresent(selectedObject)) {
                    this.setSelectionState(selectedObject, false);
                }
                this.setSelectionState(item, true);
            }
        }
    };
    /**
     * When user selection is large we use this method to check if we need to show all selected
     * items or only MaxRecentSelected
     */
    /**
     * When user selection is large we use this method to check if we need to show all selected
     * items or only MaxRecentSelected
     * @return {?}
     */
    ChooserState.prototype.toggleAllSelected = /**
     * When user selection is large we use this method to check if we need to show all selected
     * items or only MaxRecentSelected
     * @return {?}
     */
    function () {
        this.showAllRecentlySelected = !this.showAllRecentlySelected;
    };
    Object.defineProperty(ChooserState.prototype, "recentSelectedObjects", {
        /**
         *
         * Renders user's selection under the input field
         *
         */
        get: /**
         *
         * Renders user's selection under the input field
         *
         * @return {?}
         */
        function () {
            if (!this.multiselect) {
                return [];
            }
            var /** @type {?} */ recentSelectedObjects = [];
            this.recentSelectedDisplayed = 0;
            var /** @type {?} */ selectedObjects = this.selectedObjects();
            var /** @type {?} */ size = selectedObjects.length;
            var /** @type {?} */ maxCount = DataSource.MaxRecentSelected;
            if (size > DataSource.MaxRecentSelected && !this.showAllRecentlySelected) {
                maxCount -= 1;
            }
            if (this.showAllRecentlySelected) {
                maxCount = size;
            }
            for (var /** @type {?} */ i = size - 1; i >= 0 && (this.recentSelectedDisplayed < maxCount); i--) {
                var /** @type {?} */ selection = selectedObjects[i];
                recentSelectedObjects.push(selection);
                this.recentSelectedDisplayed++;
            }
            return recentSelectedObjects;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ChooserState.prototype.selectedObject = /**
     * @return {?}
     */
    function () {
        return this.selectionState.selectedObject();
    };
    /**
     * @return {?}
     */
    ChooserState.prototype.selectedObjects = /**
     * @return {?}
     */
    function () {
        return this.selectionState.selectedObjects();
    };
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    ChooserState.prototype.setSelectionState = /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    function (selection, selected) {
        if (isPresent(selection)) {
            this.selectionState.setSelectionState(selection, selected);
        }
    };
    return ChooserState;
}());
/**
 * Dummy implementation ChooserSelectionState
 */
var  /**
 * Dummy implementation ChooserSelectionState
 */
DefaultSelectionState = /** @class */ (function (_super) {
    __extends(DefaultSelectionState, _super);
    function DefaultSelectionState(multiSelect) {
        var _this = _super.call(this) || this;
        _this.multiSelect = multiSelect;
        return _this;
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    DefaultSelectionState.prototype.setSelectionState = /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    function (selection, selected) {
        if (selected) {
            this._selectedObject = selection;
            if (this.multiSelect && !ListWrapper.containsComplex(this.selectedObjects(), selection)) {
                this.selectedObjects().push(selection);
            }
        }
        else {
            if (this.multiSelect) {
                ListWrapper.removeIfExist(this.selectedObjects(), selection);
            }
        }
    };
    /**
     * @return {?}
     */
    DefaultSelectionState.prototype.selectedObject = /**
     * @return {?}
     */
    function () {
        return this._selectedObject;
    };
    /**
     * @return {?}
     */
    DefaultSelectionState.prototype.selectedObjects = /**
     * @return {?}
     */
    function () {
        if (isBlank(this._selectedObjects)) {
            this._selectedObjects = [];
        }
        return this._selectedObjects;
    };
    /**
     * @param {?} selection
     * @return {?}
     */
    DefaultSelectionState.prototype.isSelected = /**
     * @param {?} selection
     * @return {?}
     */
    function (selection) {
        return _super.prototype.isSelected.call(this, selection);
    };
    return DefaultSelectionState;
}(ChooserSelectionState));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
 *
 * 1) You can use default DataSource injected inside component constructor and just call
 * initialize to configure it with correct DataProvider and DataFinder:
 *
 *
 * ```
 *   this.dataSource.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 * and then you can use it to simply retrieve data or run queries.
 *
 * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
 * binding
 *
 * ```
 *
 *   this.ds = new ChooserDataSource(this.data, this.finders);
 *   this.ds.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 *
 */
var  /**
 * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
 *
 * 1) You can use default DataSource injected inside component constructor and just call
 * initialize to configure it with correct DataProvider and DataFinder:
 *
 *
 * ```
 *   this.dataSource.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 * and then you can use it to simply retrieve data or run queries.
 *
 * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
 * binding
 *
 * ```
 *
 *   this.ds = new ChooserDataSource(this.data, this.finders);
 *   this.ds.init({
 *               obj: this.list,
 *               queryType: QueryType.FullText,
 *               state: null,
 *               multiselect: this.multiselect
 *           });
 *
 * ```
 *
 *
 */
ChooserDataSource = /** @class */ (function (_super) {
    __extends(ChooserDataSource, _super);
    function ChooserDataSource(dataProviders, finders) {
        var _this = _super.call(this, dataProviders, finders) || this;
        _this.dataProviders = dataProviders;
        _this.finders = finders;
        return _this;
    }
    /**
     * To initialize this DataSource with current DataFinder and Provider as well as state we use
     * an interface DSChooserInitParams to have all init values typed checked
     *
     *
     */
    /**
     * To initialize this DataSource with current DataFinder and Provider as well as state we use
     * an interface DSChooserInitParams to have all init values typed checked
     *
     *
     * @param {...?} args
     * @return {?}
     */
    ChooserDataSource.prototype.init = /**
     * To initialize this DataSource with current DataFinder and Provider as well as state we use
     * an interface DSChooserInitParams to have all init values typed checked
     *
     *
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (isBlank(args) || args.length !== 1 && !isDSChooserInitParams(args[0])) {
            throw new Error('You need to initialize DS with (DSChooserInitParams)');
        }
        var /** @type {?} */ init = args[0];
        this.dataProvider = isPresent(init.dataProvider) ? init.dataProvider
            : this.dataProviders.find(init.obj);
        this.dataFinder = isPresent(init.dataFinder) ? init.dataFinder
            : this.finders.find(this.dataProvider, init.queryType);
        assert(isPresent(this.dataProvider) && isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
        if (isPresent(init.state)) {
            this.state = init.state;
        }
        else {
            this.state = new ChooserState(null, init.multiselect);
        }
        this.dataFinder.lookupKey = init.lookupKey;
        this.state.lookupKey = init.lookupKey;
    };
    /**
     * @param {?} pattern
     * @param {?} max
     * @return {?}
     */
    ChooserDataSource.prototype.find = /**
     * @param {?} pattern
     * @param {?} max
     * @return {?}
     */
    function (pattern, max) {
        var _this = this;
        this.state.pattern = pattern;
        this.state.lastFullMatchPattern = pattern;
        if (pattern.length === 0) {
            return;
        }
        if (pattern === '*') {
            // query everything
            pattern = '';
        }
        // make sure we dataFinder has expected lookup key
        var /** @type {?} */ origKey = this.dataFinder.lookupKey;
        this.dataFinder.lookupKey = this.state.lookupKey;
        this.dataFinder.forData(this.dataProvider).match(pattern, max)
            .subscribe(function (result) {
            _this.state.matches = result;
            if (_this.state.multiselect) {
                for (var /** @type {?} */ i = 0; i < _this.state.selectedObjects().length; i++) {
                    var /** @type {?} */ item = _this.state.selectedObjects()[i];
                    ListWrapper.removeIfExist(_this.state.matches, item);
                }
            }
            _this.dataFinder.lookupKey = origKey;
        });
    };
    /**
     *
     * When multiselect this method checks if we need to show SHOW MORE label under the selected
     * items. We do not want show e.g. 50 selection under the chooser that would take up whole
     * page.
     *
     */
    /**
     *
     * When multiselect this method checks if we need to show SHOW MORE label under the selected
     * items. We do not want show e.g. 50 selection under the chooser that would take up whole
     * page.
     *
     * @return {?}
     */
    ChooserDataSource.prototype.showMoreSelected = /**
     *
     * When multiselect this method checks if we need to show SHOW MORE label under the selected
     * items. We do not want show e.g. 50 selection under the chooser that would take up whole
     * page.
     *
     * @return {?}
     */
    function () {
        return this.state.selectedObjects().length >= DataSource.MaxRecentSelected;
    };
    /**
     * @template T
     * @return {?}
     */
    ChooserDataSource.prototype.open = /**
     * @template T
     * @return {?}
     */
    function () {
        return this.dataProvider.dataChanges.asObservable();
    };
    /**
     * @return {?}
     */
    ChooserDataSource.prototype.close = /**
     * @return {?}
     */
    function () {
        this.dataProvider = null;
        this.dataFinder = null;
        this.state = null;
    };
    /**
     * @template T
     * @return {?}
     */
    ChooserDataSource.prototype.instant = /**
     * @template T
     * @return {?}
     */
    function () {
        return this.dataProvider.data();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ChooserDataSource.prototype.updateValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.state.addMode = true;
        if (isArray(value)) {
            var /** @type {?} */ items = value;
            items.forEach(function (item) { return _this.state.updatedSelectedObjects(item); });
        }
        else {
            this.state.updatedSelectedObjects(value);
        }
        this.state.addMode = false;
    };
    Object.defineProperty(ChooserDataSource.prototype, "lookupKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dataFinder.lookupKey;
        },
        enumerable: true,
        configurable: true
    });
    return ChooserDataSource;
}(DataSource));
/**
 * @param {?} init
 * @return {?}
 */
function isDSChooserInitParams(init) {
    return isPresent(init.obj) || isPresent(init.queryType);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Typeahead chooser that supports both single and multi-select. Not like Dropdown, this chooser
 * requires little bit different setup. It requires at minimum \@Input dataSource or
 * destinationClass
 *
 *
 * By default chooser is multi-select. If you want single select then you must provide multi-select
 * with \@Input.
 *
 * ### Example
 *
 * In simple scenario you can use Chooser like so:
 *
 *
 * ```
 * \@Component({
 *      selector: 'chooser-app' ,
 *      template: `<aw-chooser  [formGroup]="formGroup" name="color"'
 *                      [dataSource]="ds"></aw-chooser>`
 *  })
 *  export class MyChooserApp
 *  {
 *
 *      ds: ChooserDataSource;
 *
 *     constructor(private data: DataProviders, private finders: DataFinders){
 *          this.ds = new ChooserDataSource(this.data, this.finders);
 *
 *       this.ds.init({
 *           obj: ['blue', 'red', 'yellow'], queryType: QueryType.FullText, state: null,
 *            multiselect: true
 *       });
 *
 *     }
 *  }
 *
 * ````
 *  Above example will use provided dataSource and render multi-select chooser. With default
 *  implementation  selected values will appear as a tags under the input box
 *
 *
 *
 * * ### Example
 *
 *  In this example we provide custom template to change the way how chooser's MenuItem are
 *     rendered as well as template for the selection item looks like
 *
 * ```
 * \@Component({
 *      selector: 'chooser-app' ,
 *      template: `<aw-chooser  name="commodity"' [dataSource]="ds">
 *
 *          <ng-template #menuItem let-item>
 *             	<span>
 *             		<i class="fa fa-envira " ></i>
 *             		{{item}}
 *             	</span>
 *
 *          </ng-template>
 *
 *          <ng-template #selectionItem let-item>
 *             	<span class="tag tag-circle">
 *             		item: {{item }}
 *             		<i class="fa fa-close" (click)="chooser.removeValue(item)"></i>
 *             	</span>
 *
 *
 *          </ng-template>
 *
 *
 *          </aw-chooser>
 *      `
 *      style: [`
 *              .tag-circle {
 *              	border-radius: 6rem;
 *              	height: 7rem;
 *              	color: #e8eef1;
 *              	background-color: rgba(53, 56, 58, 0.67);
 *              	line-height: 6rem;
 *              }
 *      `]
 *  })
 *
 * ````
 *
 *  In above example we change how the chooser's menu item look like as well as we define custom
 *     template for selection item to turn all selection to circles with text in the middle.
 *
 *
 *
 */
var /** @type {?} */ CHOOSER_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return ChooserComponent; }),
    multi: true
};
var ChooserComponent = /** @class */ (function (_super) {
    __extends(ChooserComponent, _super);
    function ChooserComponent(env, elemementRef, _defaultDS, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.elemementRef = elemementRef;
        _this._defaultDS = _defaultDS;
        _this.parentContainer = parentContainer;
        /**
         * Max number of items return at single Match so we do not return 1000 items at single time.
         *
         */
        _this.maxLength = 10;
        /**
         * Max number of items return at single Match so we do not return 1000 items at single time.
         *
         */
        _this.minLenForSearch = 1;
        /**
         * Is this multiselect
         *
         */
        _this.multiselect = true;
        _this.delay = 300;
        /**
         * Event fired when user select a item
         */
        _this.onSelection = new EventEmitter();
        if (isBlank(_this.placeHolder)) {
            // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
            // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
            _this.placeHolder = 'Search';
        }
        // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
        // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
        _this.hideLink = 'Hide';
        return _this;
    }
    /**
     * @return {?}
     */
    ChooserComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isBlank(this.dataSource)) {
            this.dataSource = this._defaultDS;
            this.initDatasource();
        }
        if (isPresent(this.formControl) && isPresent(this.formControl.value)) {
            this.dataSource.updateValue(this.formControl.value);
        }
        this.initInternalModel();
        if (this.isStandalone) {
            _super.prototype.registerFormControl.call(this, this.internalChooserModel);
        }
        else {
            if (isPresent(this.name)) {
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
    };
    /**
     * Add Search icon in case of multiselect.
     * todo: Once PrimeNG will provide a template to override default behavior remove it
     *
     */
    /**
     * Add Search icon in case of multiselect.
     * todo: Once PrimeNG will provide a template to override default behavior remove it
     *
     * @return {?}
     */
    ChooserComponent.prototype.ngAfterViewInit = /**
     * Add Search icon in case of multiselect.
     * todo: Once PrimeNG will provide a template to override default behavior remove it
     *
     * @return {?}
     */
    function () {
        if (!this.dataSource.state.multiselect) {
            return;
        }
        var /** @type {?} */ searchInput = this.elemementRef.nativeElement.querySelector('.ui-autocomplete-input-token');
        if (isPresent(searchInput)) {
            var /** @type {?} */ iconElement = document.createElement('span');
            iconElement.className = 'search-icon-right fa fa-fw fa-search';
            searchInput.appendChild(iconElement);
        }
        if (isPresent(this.selectionAppendTo) && isPresent(this.selectionViewElem)) {
            var /** @type {?} */ parentElem = this.selectionAppendTo instanceof ElementRef ?
                this.selectionAppendTo.nativeElement : this.selectionAppendTo;
            parentElem.appendChild(this.selectionViewElem.nativeElement);
        }
    };
    /**
     * Need to change current behavior since we want to show selection under the chooser. K
     *
     */
    /**
     * Need to change current behavior since we want to show selection under the chooser. K
     *
     * @return {?}
     */
    ChooserComponent.prototype.ngAfterViewChecked = /**
     * Need to change current behavior since we want to show selection under the chooser. K
     *
     * @return {?}
     */
    function () {
        if (!this.dataSource.state.multiselect) {
            return;
        }
        var /** @type {?} */ tokens = this.elemementRef.nativeElement.querySelectorAll('.ui-autocomplete .ui-autocomplete-token');
        if (isPresent(tokens) && tokens.length > 0) {
            tokens.forEach(function (item) {
                item.remove();
            });
        }
    };
    /**
     *
     * When value is entered into search box, we ask our DataSource to match this pattern
     * against data repository. It will retrieve all possible matches limited by MaxLen and this
     * is again filtered so it does not include already selected items.
     *
     *  the matched resulted is saved in the: this.dataSource.state.matches
     */
    /**
     *
     * When value is entered into search box, we ask our DataSource to match this pattern
     * against data repository. It will retrieve all possible matches limited by MaxLen and this
     * is again filtered so it does not include already selected items.
     *
     *  the matched resulted is saved in the: this.dataSource.state.matches
     * @param {?} pattern
     * @return {?}
     */
    ChooserComponent.prototype.match = /**
     *
     * When value is entered into search box, we ask our DataSource to match this pattern
     * against data repository. It will retrieve all possible matches limited by MaxLen and this
     * is again filtered so it does not include already selected items.
     *
     *  the matched resulted is saved in the: this.dataSource.state.matches
     * @param {?} pattern
     * @return {?}
     */
    function (pattern) {
        var /** @type {?} */ maxLen = this.maxLength ? this.maxLength : ChooserDataSource.MaxLength;
        this.dataSource.find(pattern, maxLen);
        // fix: for tests: In version 4 we need to explicitly focus input otherwise autocomplete
        // doesn't give us any popup panel
        if (this.env.inTest && isPresent(this.autoCompleteComponent)) {
            this.autoCompleteComponent.focusInput();
        }
    };
    /**
     *
     * Invoked by Dropdown button in case of single select and here we want to invoke match
     * to retrieve all suggestions without any filter
     *
     */
    /**
     *
     * Invoked by Dropdown button in case of single select and here we want to invoke match
     * to retrieve all suggestions without any filter
     *
     * @param {?} event
     * @return {?}
     */
    ChooserComponent.prototype.onDropdownClick = /**
     *
     * Invoked by Dropdown button in case of single select and here we want to invoke match
     * to retrieve all suggestions without any filter
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.match('*');
        setTimeout(function () {
            _this.match('*');
        }, 100);
    };
    /**
     *
     * Chooser state is updated  with user selection. Please see writeValue. When do not need
     * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
     * shares the same references so its important that we first save reference to
     * this.chooserState.selectedObjects() and then back to internalChooserModel
     *
     */
    /**
     *
     * Chooser state is updated  with user selection. Please see writeValue. When do not need
     * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
     * shares the same references so its important that we first save reference to
     * this.chooserState.selectedObjects() and then back to internalChooserModel
     *
     * @param {?} item
     * @return {?}
     */
    ChooserComponent.prototype.selectItem = /**
     *
     * Chooser state is updated  with user selection. Please see writeValue. When do not need
     * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
     * shares the same references so its important that we first save reference to
     * this.chooserState.selectedObjects() and then back to internalChooserModel
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.onSelection.emit(this.internalChooserModel);
        this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
        this.formControl.markAsDirty({ onlySelf: true });
        this.dataSource.state.addMode = true;
        this.onModelChanged(this.internalChooserModel);
        this.dataSource.state.updatedSelectedObjects(item);
        this.dataSource.state.addMode = true;
        if (!this.dataSource.state.multiselect) {
            this.autoCompleteComponent.inputEL.nativeElement.value =
                this.displayItem(this.internalChooserModel);
        }
    };
    /**
     *
     * Unselect item
     *
     */
    /**
     *
     * Unselect item
     *
     * @param {?} item
     * @return {?}
     */
    ChooserComponent.prototype.removeValue = /**
     *
     * Unselect item
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.dataSource.state.addMode = true;
        this.dataSource.state.updatedSelectedObjects(item);
        this.dataSource.state.addMode = false;
        this.internalChooserModel = this.dataSource.state.selectedObjects();
        this.onSelection.emit(this.internalChooserModel);
        this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
        this.formControl.markAsDirty({ onlySelf: true });
        this.onModelChanged(this.internalChooserModel);
        if (isPresent(this.autoCompleteComponent)) {
            this.autoCompleteComponent.focusInput();
        }
    };
    /**
     *
     * Convert a object if any into the string representation
     *
     * todo: implement better way how to work with objects
     *
     */
    /**
     *
     * Convert a object if any into the string representation
     *
     * todo: implement better way how to work with objects
     *
     * @param {?} item
     * @return {?}
     */
    ChooserComponent.prototype.displayItem = /**
     *
     * Convert a object if any into the string representation
     *
     * todo: implement better way how to work with objects
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isBlank(item)) {
            return null;
        }
        this.dataSource.state.currentItem = item;
        if (isPresent(this.valueTransformer)) {
            return this.valueTransformer(item);
        }
        else if (isPresent(this.dataSource.lookupKey)) {
            return item[this.dataSource.lookupKey];
        }
        else {
            return item.toString();
        }
    };
    /**
     *
     * Returns a label that is shown under the selected item when user selection is >
     * MaxRecentSelected
     *
     */
    /**
     *
     * Returns a label that is shown under the selected item when user selection is >
     * MaxRecentSelected
     *
     * @return {?}
     */
    ChooserComponent.prototype.moreSelectString = /**
     *
     * Returns a label that is shown under the selected item when user selection is >
     * MaxRecentSelected
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ moreSelected = this.dataSource.state.selectedObjects().length -
            this.dataSource.state.recentSelectedDisplayed;
        if (moreSelected < 2 && !this.dataSource.state.showAllRecentlySelected) {
            return '';
        }
        if (this.dataSource.state.showAllRecentlySelected) {
            return this.hideLink;
        }
        return moreSelected + " more selected...";
    };
    /**
     * In case of multiselect = false check if we want to show a selected value inside the input
     * field
     *
     */
    /**
     * In case of multiselect = false check if we want to show a selected value inside the input
     * field
     *
     * @return {?}
     */
    ChooserComponent.prototype.singleValueSelected = /**
     * In case of multiselect = false check if we want to show a selected value inside the input
     * field
     *
     * @return {?}
     */
    function () {
        return !this.dataSource.state && isPresent(this.dataSource.state.currentItem)
            && !this.dataSource.state.addMode;
    };
    /**
     * @return {?}
     */
    ChooserComponent.prototype.hasMenuTemplate = /**
     * @return {?}
     */
    function () {
        return isPresent(this.menuTemplate);
    };
    /**
     * @return {?}
     */
    ChooserComponent.prototype.hasSelectionTemplate = /**
     * @return {?}
     */
    function () {
        return isPresent(this.selectionTemplate);
    };
    /**
     * Internal. Please see ControlValueAccessor
     * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
     * initialization once we have a value and we only accept []
     *
     *
     * ? Should we do some deeper comparision?
     */
    /**
     * Internal. Please see ControlValueAccessor
     * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
     * initialization once we have a value and we only accept []
     *
     *
     * ? Should we do some deeper comparision?
     * @param {?} value
     * @return {?}
     */
    ChooserComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
     * initialization once we have a value and we only accept []
     *
     *
     * ? Should we do some deeper comparision?
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (isBlank(value)) {
            return;
        }
        if (isPresent(this.dataSource)) {
            this.dataSource.updateValue(value);
        }
        else {
            var /** @type {?} */ selState = new DefaultSelectionState(this.multiselect);
            var /** @type {?} */ chState = new ChooserState(selState, this.multiselect);
            this.initDatasource(chState);
            this.dataSource.updateValue(value);
        }
        this.initInternalModel();
    };
    /**
     * @param {?=} chooserState
     * @return {?}
     */
    ChooserComponent.prototype.initDatasource = /**
     * @param {?=} chooserState
     * @return {?}
     */
    function (chooserState) {
        assert(isPresent(this.destinationClass), 'You need to provide destinationClass or custom DataSource');
        this.dataSource.init({
            obj: this.destinationClass,
            queryType: QueryType.FullText,
            lookupKey: this.field,
            state: chooserState,
            multiselect: this.multiselect
        });
    };
    /**
     *
     * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
     * ngModel property
     *
     * @return {?}
     */
    ChooserComponent.prototype.initInternalModel = /**
     *
     * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
     * ngModel property
     *
     * @return {?}
     */
    function () {
        if (this.dataSource.state.multiselect) {
            this.internalChooserModel = this.dataSource.state.selectedObjects();
        }
        else {
            this.internalChooserModel = this.dataSource.state.selectedObject();
        }
        if (isPresent(this.formControl)) {
            this.formControl.setValue(this.internalChooserModel);
        }
    };
    ChooserComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-chooser',
                    template: "<div class=\"w-chooser \">\n\n    <p-autoComplete #autoCompplete [(ngModel)]=\"internalChooserModel\"\n                    [suggestions]=\"dataSource.state.matches\"\n                    [multiple]=\"dataSource.state.multiselect\"\n                    [dropdown]=\"!dataSource.state.multiselect\"\n                    [minLength]=\"minLenForSearch\"\n                    [placeholder]=\"placeHolder\"\n                    [delay]=\"delay\"\n                    [disabled]=\"disabled\"\n                    (onDropdownClick)=\"onDropdownClick($event)\"\n                    (completeMethod)=\"match($event.query)\"\n                    (onSelect)=\"selectItem($event)\"\n                    (onUnselect)=\"removeValue($event)\">\n\n\n        <ng-template let-internalChooserModel pTemplate=\"item\">\n            <ng-template [ngIf]=\"!hasMenuTemplate()\">\n                {{ displayItem(internalChooserModel) }}\n            </ng-template>\n            <ng-template [embeddedItem]=\"menuTemplate\" [item]=\"internalChooserModel\"\n                         *ngIf=\"hasMenuTemplate()\"></ng-template>\n        </ng-template>\n    </p-autoComplete>\n\n    <!--\n        Wrap whole selection with one extra element so we can move it around\n\n         see: selectionAppendTo\n    -->\n    <span #selectionView>\n        <div class=\"w-chooser-selections\"\n             *ngIf=\"multiselect && dataSource.state.recentSelectedObjects.length > 0\">\n\n        <ng-template [ngIf]=\"!hasSelectionTemplate()\">\n\n            <!-- no selection template render it as it is from CORE-->\n            <ul class=\"ui-autocomplete-multiple-container ui-widget ui-state-default \"\n                [ngClass]=\"{'ui-state-disabled':disabled,'ui-state-focus':autoCompleteComponent.focus}\">\n\n                <li #token *ngFor=\"let item of dataSource.state.recentSelectedObjects\"\n                    class=\"ui-autocomplete-token ui-state-highlight ui-corner-all\" tabindex=\"0\"\n                    (keyup.delete)=\"removeValue(item)\"\n                    (keyup.backspace)=\"removeValue(item)\">\n\t\t\t\t\t<span class=\"ui-autocomplete-token-icon sap-icon icon-decline\"\n                          (click)=\"removeValue(item)\"></span>\n                    <span class=\"ui-autocomplete-token-label\">{{ displayItem(item) }}</span>\n                </li>\n            </ul>\n        </ng-template>\n\n            <!--Yes there is selection template let's iterate and push each item to be rendered-->\n        <ng-template ngFor [ngForOf]=\"dataSource.state.recentSelectedObjects\" let-item>\n            <ng-template [embeddedItem]=\"selectionTemplate\" [item]=\"item\"\n                         *ngIf=\"hasSelectionTemplate()\"></ng-template>\n        </ng-template>\n\n        <ng-template [ngIf]=\"dataSource.showMoreSelected()\">\n\t\t\t<span class=\"more-selected\">\n\t\t\t\t<aw-hyperlink [size]=\"'small'\" (action)=\"dataSource.state.toggleAllSelected()\">\n\t\t\t\t\t{{moreSelectString()}}\n\t\t\t\t</aw-hyperlink>\n\t\t\t</span>\n        </ng-template>\n    </div>\n    </span>\n\n\n</div>\n\n",
                    styles: ["/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-input,/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-multiple-container{width:100%}/deep/ .w-chooser .ui-autocomplete-multiple{line-height:normal}/deep/ .w-chooser .ui-autocomplete-input{width:100%}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button{right:0;position:absolute;border:0;width:30px;background:0 0}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button input{padding-right:30px}/deep/ .w-chooser .ui-autocomplete-input-token{padding:0;margin:0;vertical-align:baseline;width:inherit}/deep/ .w-chooser .ui-autocomplete-input-token .fa{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.2em}/deep/ .w-chooser .ui-autocomplete-input-token .fa-search:before{content:'\\e00d'}/deep/ .w-chooser .ui-autocomplete-input-token input{width:inherit;padding-right:25px}/deep/ .w-chooser .ui-autocomplete-input-token span{position:absolute;right:5px;top:0;padding-top:.6em}/deep/ .w-chooser .ui-autocomplete-dropdown{height:36px}/deep/ .w-chooser .ui-autocomplete-panel .ui-autocomplete-list-item{padding:.65em 2em .65em .64em;margin:0}/deep/ body .ui-autocomplete.ui-autocomplete-multiple .ui-autocomplete-multiple-container{padding:.4em .5em .4em 1em}.w-chooser-selections{margin-top:2px}.w-chooser-selections ul{margin:0;padding:0}.w-chooser-selections .ui-autocomplete-multiple-container{border:0}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token{font-size:.85em;letter-spacing:.1px;font-weight:400;padding:0;background:#e0f2ff;margin-right:5px;margin-bottom:5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-label{padding:4px 21px 4px 5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-icon{font-size:.78em;padding-right:.28em}.w-chooser-selections .ui-autocomplete-multiple-container .sap-icon{line-height:inherit}.w-chooser-selections .more-selected{display:inline-block}"],
                    providers: [
                        CHOOSER_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return ChooserComponent; }) },
                        { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                    ]
                },] },
    ];
    /** @nocollapse */
    ChooserComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: ElementRef },
        { type: ChooserDataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    ChooserComponent.propDecorators = {
        maxLength: [{ type: Input }],
        minLenForSearch: [{ type: Input }],
        valueTransformer: [{ type: Input }],
        multiselect: [{ type: Input }],
        dataSource: [{ type: Input }],
        selectionAppendTo: [{ type: Input }],
        delay: [{ type: Input }],
        destinationClass: [{ type: Input }],
        field: [{ type: Input }],
        onSelection: [{ type: Output }],
        menuTemplate: [{ type: ContentChild, args: ['menuItem',] }],
        selectionTemplate: [{ type: ContentChild, args: ['selectionItem',] }],
        autoCompleteComponent: [{ type: ViewChild, args: ['autoCompplete',] }],
        selectionViewElem: [{ type: ViewChild, args: ['selectionView',] }]
    };
    return ChooserComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWChooserModule = /** @class */ (function () {
    function AWChooserModule() {
    }
    AWChooserModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ChooserComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        AutoCompleteModule,
                        AWHyperlinkModule,
                        AWCoreComponentModule
                    ],
                    entryComponents: [
                        ChooserComponent
                    ],
                    exports: [
                        ChooserComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWChooserModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * A popup like component rendering list of values as. Based on PrimeNG component and one of the
 * main reason why we need to wrap this is to extend its capabilities to accept almost any
 * data type without using Primens's specific SelectItem type.
 *
 *
 * ### Example
 *
 * ```
 * \@Component({
 *      selector: 'showDropDown' ,
 *      template: '<aw-dropdown [list]="testItemSmall"
 *     (onSelection)="onSelection($event)"></aw-dropdown>'
 *  })
 *  export class MyDropComponent
 *  {
 *      testItemSmall: string[] = ['view' , 'edit'];
 *
 *      // when you switch list binding to refert to large item fiilter automatically is shown and
 *     max 10 items are
 *      // visible
 *      testItemLarge: string[] = ['view' , 'edit' , 'frank' , 'kolar' , 'The Sun' , 'Dog' ,
 *     'Computer' , 'A Desk' ,
 *      'My Car' , 'Pencil' , 'This Page' , 'Yesterday' , 'Monday' , 'Tuesday' , 'BMW R1200 GS' ,
 *     'Czech Republic' ,
 *      'Last Item'];
 *
 *
 *      itemSelected: string = 'view';
 *      itemSelectedLg: string = 'Monday';
 *
 *      noselString: string = '(no selection)';
 *
 *
 *      onSelection (event): void
 *      {
 *          this.itemSelected = event;
 *
 *      }
 *  }
 *
 *  ```
 *
 */
var /** @type {?} */ DD_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return DropdownComponent; }),
    multi: true
};
var DropdownComponent = /** @class */ (function (_super) {
    __extends(DropdownComponent, _super);
    function DropdownComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         * Event fired when user select a item
         */
        _this.onSelection = new EventEmitter();
        return _this;
    }
    /**
     * Todo: Put back the scrolling option once we decide so. Currently the requirements are
     * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
     * search filter.
     */
    /**
     * Todo: Put back the scrolling option once we decide so. Currently the requirements are
     * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
     * search filter.
     * @return {?}
     */
    DropdownComponent.prototype.ngOnInit = /**
     * Todo: Put back the scrolling option once we decide so. Currently the requirements are
     * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
     * search filter.
     * @return {?}
     */
    function () {
        if (this.isStandalone) {
            _super.prototype.ngOnInit.call(this);
            _super.prototype.registerFormControl.call(this, this.selection);
        }
        else {
            if (isPresent(this.name)) {
                this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
            }
        }
        // transform a value to PrimeNg Format, we are not really be using a label field only a
        // value.
        this.internalList = [];
        // if (isPresent(this.noSelectionString)) {
        //     this.internalList.push({
        //         label: this.noSelectionString,
        //         value: null
        //     });
        //
        //     if (isBlank(this.selection)) {
        //         this.selection = this.noSelectionString;
        //     }
        // }
        if (isPresent(this.list) && this.list.length >= DropdownComponent.MaxNumShown) {
            this.internalList = this.list.slice(0, DropdownComponent.MaxNumShown).map(function (item) {
                return { label: item.toString(), value: item };
            });
        }
        else if (isPresent(this.list)) {
            this.internalList = this.list.slice(0).map(function (item) {
                return { label: item.toString(), value: item };
            });
        }
    };
    /**
     * @return {?}
     */
    DropdownComponent.prototype.hasEmbeddedTemplate = /**
     * @return {?}
     */
    function () {
        return isPresent(this.itemTemplate);
    };
    /**
     * Check to prevent Empty item to be rendered
     *
     * todo: Report this on PrimeNg
     *
     */
    /**
     * Check to prevent Empty item to be rendered
     *
     * todo: Report this on PrimeNg
     *
     * @param {?} item
     * @return {?}
     */
    DropdownComponent.prototype.itemExist = /**
     * Check to prevent Empty item to be rendered
     *
     * todo: Report this on PrimeNg
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return isPresent(item);
    };
    /**
     * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
     * input field
     */
    /**
     * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
     * input field
     * @return {?}
     */
    DropdownComponent.prototype.showFilter = /**
     * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
     * input field
     * @return {?}
     */
    function () {
        return false;
        // return isPresent(this.list) && this.list.length > DropdownComponent.MaxNumShown;
    };
    /**
     *
     * Updates internal models of current selections and triggers onSelection event
     *
     */
    /**
     *
     * Updates internal models of current selections and triggers onSelection event
     *
     * @param {?} value
     * @return {?}
     */
    DropdownComponent.prototype.onItemSelection = /**
     *
     * Updates internal models of current selections and triggers onSelection event
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.selection = value.value;
        this.onSelection.emit(value.value);
        if (this.isStandalone) {
            this.formControl.setValue(this.selection);
            this.formControl.markAsDirty({ onlySelf: true });
        }
        this.onModelChanged(value.value);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    DropdownComponent.prototype.displayItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return isPresent(item) ? item.label : 'No Selection';
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    DropdownComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!equals(value, this.selection)) {
            this.selection = value;
            this.formControl.setValue(value);
        }
    };
    DropdownComponent.MaxNumShown = 10;
    DropdownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dropdown',
                    template: "<div class=\"w-dropdown\" [formGroup]=\"formGroup\">\n\n    <ng-template [ngIf]=\"isStandalone\">\n        <p-dropdown [options]=\"internalList\"\n                    [formControlName]=\"name\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n\n                </ng-template>\n            </ng-template>\n\n\n        </p-dropdown>\n    </ng-template>\n</div>\n\n\n<!-- no formControl Name here. ngModel cannot have formGroup around -->\n<ng-template [ngIf]=\"!isStandalone\">\n    <div class=\"w-dropdown\">\n        <p-dropdown [options]=\"internalList\"\n                    [(ngModel)]=\"selection\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n                </ng-template>\n            </ng-template>\n        </p-dropdown>\n    </div>\n</ng-template>\n",
                    styles: ["/deep/ .ui-dropdown-panel .ui-dropdown-items-wrapper{max-height:none!important}/deep/ .ui-dropdown-panel .ui-dropdown-item{padding:.65em 2em .65em .64em;margin:0}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container{width:100%}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container .fa{top:1.2em}/deep/ .ui-dropdown-panel .ui-dropdown-list{padding:1em 0}/deep/ .w-dropdown:not(.ng-dirty) label{color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger.ui-corner-right{border-left:none;color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-dropdown .ui-dropdown-trigger .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-dropdown .ui-dropdown-label{padding-right:2.4em}"],
                    providers: [
                        DD_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return DropdownComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    DropdownComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    DropdownComponent.propDecorators = {
        list: [{ type: Input }],
        selection: [{ type: Input }],
        noSelectionString: [{ type: Input }],
        onSelection: [{ type: Output }],
        itemTemplate: [{ type: ContentChild, args: ['itemTemplate',] }]
    };
    return DropdownComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWDropdownModule = /** @class */ (function () {
    function AWDropdownModule() {
    }
    AWDropdownModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        DropdownComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        DropdownModule,
                        AWCoreComponentModule
                    ],
                    entryComponents: [
                        DropdownComponent
                    ],
                    exports: [
                        DropdownComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWDropdownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Lightweight and configurable Currency component based on the ng bootstrap directive. This
 * component combines an input and currency code dropdown.
 *
 *
 * for more info please see class Doc of the:
 * @see {\@link currency/currency.component.ts}
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'amount' ,
 *    template: `
 *
 *      <aw-currency [money]="price" [currencies]="currencies" [name]="'currency'">
 *      </aw-currency>
 *
 *    `
 *    })
 *    export class MyComponent
 *    {
 *        amount: number = 1000;
 *        currencies: string[] = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
 *        currencyCode: string = this.currencies[0];
 *
 *        constructor ()
 *        {
 *        }
 *    }
 */
var /** @type {?} */ CURRENCY_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return CurrencyComponent; }),
    multi: true
};
var CurrencyComponent = /** @class */ (function (_super) {
    __extends(CurrencyComponent, _super);
    function CurrencyComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         * Disable user to change Money's currency code and still
         * allow user to edit Money's amount.
         */
        _this.readonlyCurrencyCode = false;
        // Initialize currencies.
        // Initialize currencies.
        _this.initCurrencies();
        _this.currencyPipe = new CurrencyPipe(env.locale);
        env.onLocaleChange.subscribe(function (locale) {
            _this.currencyPipe = new CurrencyPipe(locale);
            if (isPresent(_this.money)) {
                _this.displayValue = _this.formatCurrency(_this.money.amount);
            }
        });
        return _this;
    }
    /**
     * @return {?}
     */
    CurrencyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        _super.prototype.registerFormControl.call(this, this.money);
        this.initCurrencies();
        if (isBlank(this.currencySelection)) {
            this.currencySelection = this._currencies[0];
        }
        // ready the money field if it exists. and override the existing values.
        if (this.money) {
            this.currencySelection = this.money.currency;
        }
        else {
            this.money = new Money(null, this.currencySelection);
        }
        this.displayValue = this.formatCurrency(this.money.amount);
    };
    /**
     * @return {?}
     */
    CurrencyComponent.prototype.initCurrencies = /**
     * @return {?}
     */
    function () {
        if (!this._currencies || this._currencies.length === 0) {
            this._currencies = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
        }
    };
    /**
     * Display the real value when the user clicks in the currency widget. Then he can modify the
     * value without seeing the formatting.
     *
     * @param el
     */
    /**
     * Display the real value when the user clicks in the currency widget. Then he can modify the
     * value without seeing the formatting.
     *
     * @param {?} el
     * @return {?}
     */
    CurrencyComponent.prototype.onFocus = /**
     * Display the real value when the user clicks in the currency widget. Then he can modify the
     * value without seeing the formatting.
     *
     * @param {?} el
     * @return {?}
     */
    function (el) {
        if (isPresent(this.money) && isPresent(this.money.amount)) {
            this.displayValue = this.money.amount.toString();
        }
    };
    /**
     * display the formatted currency value when the user navigates away.
     * @param el
     */
    /**
     * display the formatted currency value when the user navigates away.
     * @param {?} el
     * @return {?}
     */
    CurrencyComponent.prototype.onBlur = /**
     * display the formatted currency value when the user navigates away.
     * @param {?} el
     * @return {?}
     */
    function (el) {
        this.money = this.money.clone({ amount: Number(el.value) });
        this.displayValue = this.formatCurrency(this.money.amount);
        this.onModelChanged(this.money);
    };
    /**
     * @param {?} currency
     * @return {?}
     */
    CurrencyComponent.prototype.onSelection = /**
     * @param {?} currency
     * @return {?}
     */
    function (currency) {
        this.currencySelection = currency;
        this.displayValue = this.formatCurrency(this.money.amount);
    };
    /**
     * Function will check to see if currency is a valid number before formatting.
     * @param {?} val
     * @return {?}
     */
    CurrencyComponent.prototype.formatCurrency = /**
     * Function will check to see if currency is a valid number before formatting.
     * @param {?} val
     * @return {?}
     */
    function (val) {
        if (!val || val.length === 0) {
            return val;
        }
        if (isNaN(val)) {
            return val;
        }
        var /** @type {?} */ code = 'USD';
        if (this.currencySelection) {
            code = this.currencySelection;
        }
        this.money = this.money.clone({ currency: this.currencySelection });
        // By default, the precision is 2. For example, 10.23 USD.
        var /** @type {?} */ digits = '1.0-2';
        // If precision is present, use it for format the money value for display.
        if (isPresent(this.precision)) {
            digits = '1.0-' + this.precision;
        }
        return this.currencyPipe.transform(val, code, 'symbol', digits);
    };
    /**
     * @return {?}
     */
    CurrencyComponent.prototype.getMoneyCurrency = /**
     * @return {?}
     */
    function () {
        if (isPresent(this.displayValue) && this.displayValue.length > 0) {
            return this.currencySelection;
        }
        return '';
    };
    Object.defineProperty(CurrencyComponent.prototype, "currencies", {
        get: /**
         * @return {?}
         */
        function () {
            return this._currencies;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (isPresent(value)) {
                this._currencies = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    CurrencyComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if ((value instanceof Money) && !equals(value, this.money)) {
            this.money = value;
            if (isPresent(this.money.currency)) {
                this.currencySelection = this.money.currency;
            }
            this.displayValue = this.formatCurrency(this.money.amount);
            this.formControl.setValue(this.money);
        }
    };
    CurrencyComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-currency',
                    template: "<ng-template [ngIf]=\"editable\">\n    <div class=\"w-currency-field ui-fluid\" [formGroup]=\"formGroup\">\n        <div class=\"ui-g \">\n            <div class=\"ui-g-8 ui-g-nopad \">\n                <input #currencyInput\n                       pInputText\n                       type=\"text\" class=\"w-text-field currency-format\"\n                       [attr.name]=\"name\"\n                       [attr.placeholder]=\"placeHolder\"\n                       [value]=\"displayValue\"\n                       (focus)=\"onFocus(currencyInput)\"\n                       (blur)=\"onBlur(currencyInput)\"\n                       [disabled]=\"disabled\">\n            </div>\n            <div class=\"ui-g-4 ui-g-nopad w-cc-field\">\n                <aw-dropdown *ngIf=\"!readonlyCurrencyCode\"\n                             [isStandalone]=\"false\" [list]=\"currencies\"\n                             [selection]=\"money.currency\"\n                             (onSelection)=\"onSelection($event)\"\n                             [disabled]=\"disabled\">\n\n                </aw-dropdown>\n                <div *ngIf=\"readonlyCurrencyCode\" class=\"w-cc-readonly-field\">{{money.currency}}</div>\n            </div>\n        </div>\n    </div>\n</ng-template>\n\n<!-- currency:'USD':true -->\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{displayValue}} {{ getMoneyCurrency() }}\"></aw-string>\n</ng-template>\n",
                    styles: [".w-currency-field [readonly],.w-currency-type-field [readonly]{background-color:#fff}.w-currency-field input,.w-currency-type-field input{min-width:80px}.w-currency-field i.fa,.w-currency-type-field i.fa{cursor:pointer}.w-currency-field{margin-top:0}.w-currency-field /deep/ .ui-dropdown{min-width:80px}.w-cc-field{display:flex;align-items:center}.w-cc-readonly-field{padding-left:5px;color:#969696}.no-gutter>[class*=ui-g-]{padding-right:0;padding-left:0}"],
                    providers: [
                        CURRENCY_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return CurrencyComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    CurrencyComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    CurrencyComponent.propDecorators = {
        money: [{ type: Input }],
        readonlyCurrencyCode: [{ type: Input }],
        currencySelection: [{ type: Input }],
        precision: [{ type: Input }],
        currencies: [{ type: Input }]
    };
    return CurrencyComponent;
}(BaseFormComponent));
/**
 * Money object is represented as a value, locale, and currencyCode
 */
var  /**
 * Money object is represented as a value, locale, and currencyCode
 */
Money = /** @class */ (function () {
    function Money(amount, currency, locale) {
        if (amount === void 0) { amount = 0; }
        if (currency === void 0) { currency = 'USD'; }
        if (locale === void 0) { locale = 'en_US'; }
        this.amount = amount;
        this.currency = currency;
        this.locale = locale;
    }
    /**
     * @return {?}
     */
    Money.prototype.getTypes = /**
     * @return {?}
     */
    function () {
        return {
            amount: Number,
            currency: String,
            locale: String
        };
    };
    /**
     * @return {?}
     */
    Money.prototype.className = /**
     * @return {?}
     */
    function () {
        return 'Money';
    };
    /**
     * @return {?}
     */
    Money.prototype.$proto = /**
     * @return {?}
     */
    function () {
        return new Money(1, '23', '33');
    };
    /**
     * @return {?}
     */
    Money.prototype.toString = /**
     * @return {?}
     */
    function () {
        return this.amount + ', locale: ' + this.locale + ', code:  ' + this.currency;
    };
    /**
     * @param {?=} data
     * @return {?}
     */
    Money.prototype.clone = /**
     * @param {?=} data
     * @return {?}
     */
    function (data) {
        if (data === void 0) { data = {}; }
        return new Money(isPresent(data.amount) ? data.amount : this.amount, isPresent(data.currency) ? data.currency : this.currency, isPresent(data.locale) ? data.locale : this.locale);
    };
    return Money;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWCurrencyModule = /** @class */ (function () {
    function AWCurrencyModule() {
    }
    AWCurrencyModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        CurrencyComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        InputTextModule$1,
                        DropdownModule,
                        AWDropdownModule,
                        AWStringFieldModule,
                        AWCoreComponentModule
                    ],
                    entryComponents: [
                        CurrencyComponent
                    ],
                    exports: [
                        CurrencyComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: [CurrencyPipe]
                },] },
    ];
    return AWCurrencyModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Lightweight and configurable Date and Time component based on the primeng. This
 * component combines both date picker as well as time picker
 *
 *
 *  ### Example
 *  ```
 *
 * \@Component({
 *    selector: 'myTimer' ,
 *    template: `
 *    <aw-date-time [value]="date" [editable]="editable"  [name]="'dueDate'">
 *    </aw-date-time>
 *
 *    `
 *    })
 *    export class MyTimmerComponet
 *    {
 *
 *        date: Date = new Date();
 *
 *
 *        constructor ()
 *        {
 *            this.date.setFullYear(2016 , 10 , 3);
 *            this.date.setHours(10 , 10 , 10);
 *        }
 *    }
 *
 * ```
 *
 * By default you will see date field and time field is hidden to show both you just do following:
 *
 *  ```
 *
 * \@Component({
 *    selector: 'myTimer' ,
 *    template: `
 *
 *    <aw-date-time [value]="date"  [showTime]="showTime" [editable]="editable"  [name]="'bbdd'">
 *    </aw-date-time>
 *
 *    `
 *    })
 *    export class MyTimmerComponet
 *    {
 *        date: Date = new Date();
 *        showTime = true;
 *
 *        constructor ()
 *        {
 *            this.date.setFullYear(2016 , 10 , 3);
 *            this.date.setHours(10 , 10 , 10);
 *        }
 *    }
 *
 * ```
 *
 *
 *
 */
var /** @type {?} */ DATETIME_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return DateAndTimeComponent; }),
    multi: true
};
var DateAndTimeComponent = /** @class */ (function (_super) {
    __extends(DateAndTimeComponent, _super);
    function DateAndTimeComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         * Default date format pattern used if none is passed
         *
         */
        _this.formatPattern = 'mm/dd/yy';
        /**
         * Special workaround as formatters in the primeNG and angular are different so until its
         * fixed we need to keep this extra pattern.
         */
        _this.formatPatternNG = 'MM/dd/yy';
        /**
         * Shows and hides navigation bar with year and months selections
         */
        _this.showNavigation = false;
        /**
         * Shows and hides navigation bar with year and months selections
         */
        _this.showIcon = true;
        /**
         * Whether to show timepicker
         */
        _this.showTime = false;
        /**
         * Whether to show DatePicker. Even we can hide it. it should be for most of the case always
         * true
         */
        _this.showDate = true;
        /**
         *
         * Tells the date picker what format it should use when presenting time. When hourFormat is 12,
         * it shows the AM, PM
         *
         */
        _this.hourFormat = '24';
        /**
         * Triggers event when specific date is clicked inside DatePicker
         *
         */
        _this.onChange = new EventEmitter();
        /**
         * Set the date to highlight on first opening if the field is blank.
         *
         */
        _this.defaultDate = new Date();
        _this.timePlaceHolder = 'hh:ss';
        return _this;
    }
    /**
     * @return {?}
     */
    DateAndTimeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        _super.prototype.registerFormControl.call(this, this.value);
        // default to dateTime pattern which is defined in resource files
        if (this.hourFormat !== '12' && this.hourFormat !== '24') {
            this.hourFormat = '24';
        }
        this.timePlaceHolder = (this.hourFormat === '12') ?
            " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(function (val) {
            _this.value = val;
            _this.onModelChanged(_this.value);
        });
        this.initTranslations();
        this.env.onLocaleChange.subscribe(function (locale) {
            _this.initTranslations();
        });
    };
    /**
     * Need to refactor this as this really get complicated trying to cover usecase with time
     * and date and every format we have. We should probably have separate patterns for
     * dates only and date + time
     * @return {?}
     */
    DateAndTimeComponent.prototype.initTranslations = /**
     * Need to refactor this as this really get complicated trying to cover usecase with time
     * and date and every format we have. We should probably have separate patterns for
     * dates only and date + time
     * @return {?}
     */
    function () {
        this.formatNameWithTime = this.formatPattern;
        if (!this.showDate) {
            this.formatPatternNG = this.formatPattern += (this.hourFormat === '12') ?
                " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
        }
        if (this.showTime) {
            var /** @type {?} */ timeStarts = this.formatPattern.indexOf('h');
            if (timeStarts !== -1) {
                this.formatNameWithTime = this.formatPattern.substring(0, timeStarts);
            }
            this.formatPatternNG += (this.hourFormat === '12') ?
                " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
        }
        this.i18n = {
            firstDayOfWeek: 0,
            dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
                'Saturday'],
            dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
            dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
            monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
                'September', 'October', 'November', 'December'],
            monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                'Nov', 'Dec']
        };
    };
    /**
     * Fired when dates changes. Here we update  this.value - > date and also update value inside
     * formController
     *
     */
    /**
     * Fired when dates changes. Here we update  this.value - > date and also update value inside
     * formController
     *
     * @param {?} event
     * @return {?}
     */
    DateAndTimeComponent.prototype.onDateChange = /**
     * Fired when dates changes. Here we update  this.value - > date and also update value inside
     * formController
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (isBlank(event)) {
            // throw some error ?
            return;
        }
        this.value = isDate(event) ? event : new Date(event);
        this.formControl.setValue(this.value, { onlySelf: false, emitEvent: true });
        this.onModelChanged(this.value);
        this.onChange.emit(this.value);
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    DateAndTimeComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value);
        }
    };
    DateAndTimeComponent.NgTime12 = 'hh:mm a';
    DateAndTimeComponent.NgTime24 = 'HH.mm a';
    DateAndTimeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-date-time',
                    template: "<ng-template [ngIf]=\"editable\">\n\n    <div class=\"w-datetime \" [class.has-time]=\"showTime\" [formGroup]=\"formGroup\">\n\n        <p-calendar formControlName=\"{{name}}\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    dateFormat=\"{{showTime ? formatNameWithTime : formatPattern}}\"\n                    [yearNavigator]=\"showNavigation\"\n                    [monthNavigator]=\"showNavigation\"\n                    [yearRange]=\"yearRange\"\n                    placeholder=\"{{showTime ? formatNameWithTime.toUpperCase() : formatPattern.toUpperCase()}}\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [timeOnly]=\"!showDate\"\n                    [readonlyInput]=\"true\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n        <p-calendar *ngIf=\"showTime\"\n                    icon=\"icon-history\"\n                    formControlName=\"{{name}}\"\n                    [hourFormat]=\"hourFormat\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    [timeOnly]=\"showTime\"\n                    [showTime]=\"showTime\"\n                    [placeholder]=\"timePlaceHolder\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n    </div>\n</ng-template>\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{value | date: formatPatternNG}}\"></aw-string>\n</ng-template>\n",
                    styles: ["/deep/ .w-datetime .ui-calendar button{border:0;width:0}/deep/ .w-datetime .ui-calendar.ui-calendar-w-btn .ui-inputtext{width:100%}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.4em}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.pi-calendar:before{content:'\\e0e0'}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.icon-history:before{content:'\\e02d'}/deep/ .ui-datepicker{width:24.28em;line-height:25px;padding:0;border-color:#979797;box-shadow:none}/deep/ .ui-datepicker .ui-datepicker-header{padding:.92em 0;font-weight:400;color:#000;font-size:1em}/deep/ .ui-datepicker .ui-datepicker-next,/deep/ .ui-datepicker .ui-datepicker-prev{top:1em}/deep/ .ui-datepicker .ui-datepicker-prev{left:.2em}/deep/ .ui-datepicker .ui-datepicker-next{right:.2em}/deep/ .ui-datepicker table{font-size:1em;margin:0 0 1.5em}/deep/ .ui-datepicker th{font-weight:400;background-color:#ececec;color:#363636;padding:.786em 1.07em}/deep/ .ui-datepicker td{padding:.1em}/deep/ .ui-datepicker td a{text-align:center;width:2.7em;height:2.7em;line-height:2.7em;padding:0;border-radius:50%}/deep/ .ui-datepicker td a.ui-state-default{border-color:transparent}/deep/ .ui-datepicker td a.ui-state-active{background-color:#199de0;color:#fff}/deep/ .ui-datepicker .pi{font-size:1em}/deep/ .ui-datepicker .pi.pi-chevron-left:before{content:'\\e1ee'}/deep/ .ui-datepicker .pi.pi-chevron-right:before{content:'\\e1ed'}/deep/ .ui-datepicker .ui-datepicker-calendar td:not(.ui-state-disabled) a:hover{border-color:transparent;background-color:rgba(25,157,224,.7);opacity:.75;color:#363636}/deep/ .ui-datepicker-timeonly{width:100%}/deep/ .ui-timepicker{font-size:1.14em;color:#767676;font-weight:400}/deep/ .ui-timepicker .pi{font-size:1em}/deep/ .ui-timepicker .pi.pi-chevron-up:before{content:'\\e1f0'}/deep/ .ui-timepicker .pi.pi-chevron-down:before{content:'\\e1ef'}/deep/ .ui-timepicker>div{margin-left:0}/deep/ .ui-timepicker .ui-separator{width:.1em;min-width:.1em}/deep/ .ui-timepicker .ui-separator .pi{font-size:0}/deep/ .ui-datepicker-trigger{background-color:transparent}/deep/ .ui-datepicker-trigger.ui-button:enabled:hover,/deep/ .ui-datepicker-trigger.ui-button:focus{background-color:transparent}/deep/ .has-time{display:flex;flex-wrap:nowrap}/deep/ .has-time p-calendar:first-child{width:55%;margin-right:14px}/deep/ .has-time p-calendar:last-child{width:45%}/deep/ .has-time p-calendar:last-child .ui-datepicker{padding:0}/deep/ .has-time .ui-button-icon-left{line-height:18px}"],
                    providers: [
                        DATETIME_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return DateAndTimeComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    DateAndTimeComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    DateAndTimeComponent.propDecorators = {
        value: [{ type: Input }],
        formatPattern: [{ type: Input }],
        formatPatternNG: [{ type: Input }],
        showNavigation: [{ type: Input }],
        yearRange: [{ type: Input }],
        showIcon: [{ type: Input }],
        showTime: [{ type: Input }],
        showDate: [{ type: Input }],
        hourFormat: [{ type: Input }],
        onChange: [{ type: Output }]
    };
    return DateAndTimeComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWDateAndTimeModule = /** @class */ (function () {
    function AWDateAndTimeModule() {
    }
    AWDateAndTimeModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        DateAndTimeComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        CalendarModule,
                        AWStringFieldModule
                    ],
                    entryComponents: [
                        DateAndTimeComponent
                    ],
                    exports: [
                        DateAndTimeComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ]
                },] },
    ];
    return AWDateAndTimeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An dialog header area.
 *
 * See {\@link DialogComponent} for more explanation.
 */
var DialogHeaderComponent = /** @class */ (function () {
    function DialogHeaderComponent() {
    }
    DialogHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dialog-header',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    return DialogHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An dialog header area.
 *
 * See {\@link DialogComponent} for more explanation.
 */
var DialogFooterComponent = /** @class */ (function () {
    function DialogFooterComponent() {
    }
    DialogFooterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dialog-footer',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    return DialogFooterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Dialog Component that provides the look and feel for a modal dialog. This component has three
 * sections: header, body, and footer. It can be used by itself or extended.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<DialogComponent>), service.close()
 *
 * Usage:
 *    1.  Using Dialog directly to display a modal popup. This usage is a quick way to show a
 * message to the user.
 *
 *             this.modalService.open<DialogComponent>( DialogComponent, {
 *                     title: 'My Popup Title',
 *                     body: 'My Popup Body'
 *              });
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                              <aw-dialog [(visible)]="display" [modal]="true"
 *                                        (onOpen)="openAction()" (onClose)="closeAction()">
 *
 *                                    <aw-dialog-header>Dialog Header</aw-dialog-header>
 *
 *                                     Dialog Body: Creating a dialog using the dialog component
 *
 *                                    <aw-dialog-footer>
 *                                      <aw-button [size]="'small'" [style]="'primary'"
 *                                                 (click)="close()">OK</aw-button>
 *                                    </aw-dialog-footer>
 *                              </aw-dialog>
 *
 *                          <aw-button [size]="'small'" (click)="open()">Open Dialog</aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     display: boolean = false;
 *
 *                     dialogAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     open() {
 *                        this.display = true;
 *                     }
 *
 *                     openAction()  {
 *                        this.dialogAction = "open";
 *                      }
 *       }
 *
 *
 */
var DialogComponent = /** @class */ (function (_super) {
    __extends(DialogComponent, _super);
    function DialogComponent(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * support two way data binding on visible property.
         */
        _this.visibleChange = new EventEmitter();
        /**
         * whether this dialog blocks the rest of the page or not when displayed.
         */
        _this.modal = true;
        /**
         * Whether there's an x at the top right that makes the dialog closable.
         */
        _this.closable = true;
        /**
         * Event fired when dialog is closed.
         */
        _this.onClose = new EventEmitter();
        /**
         * Event fired when the dialog is opened.
         */
        _this.onOpen = new EventEmitter();
        _this.width = 300;
        _this.height = 'auto';
        return _this;
    }
    /**
     * Open this dialog.
     */
    /**
     * Open this dialog.
     * @return {?}
     */
    DialogComponent.prototype.open = /**
     * Open this dialog.
     * @return {?}
     */
    function () {
        this.visible = true;
        this.onOpen.emit();
        // visible is a 2-way binding variable.
        this.visibleChange.emit(true);
    };
    /**
     * close the dialog
     */
    /**
     * close the dialog
     * @return {?}
     */
    DialogComponent.prototype.close = /**
     * close the dialog
     * @return {?}
     */
    function () {
        this.visible = false;
        this.onClose.emit();
        // Important to make sure change is set on parent binding.
        // Otherwise, the variable and dialog open/close state can be out
        // of sync and we wouldn't trigger change detection.
        this.visibleChange.emit(false);
    };
    /**
     * Does this dialog have header.
     *
     */
    /**
     * Does this dialog have header.
     *
     * @return {?}
     */
    DialogComponent.prototype.hasHeader = /**
     * Does this dialog have header.
     *
     * @return {?}
     */
    function () {
        return isPresent(this.header);
    };
    /**
     * Does this dialog have footer.
     *
     */
    /**
     * Does this dialog have footer.
     *
     * @return {?}
     */
    DialogComponent.prototype.hasFooter = /**
     * Does this dialog have footer.
     *
     * @return {?}
     */
    function () {
        return isPresent(this.footer);
    };
    DialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dialog',
                    template: "<p-dialog [header]=\"title\" [(visible)]=\"visible\"\n          [modal]=\"modal\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n          [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onShow)=\"open()\" (onHide)=\"close()\">\n\n    <p-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-dialog-header\"></ng-content>\n    </p-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n    <p-footer *ngIf=\"hasFooter()\">\n        <div class=\"dialog-footer-separator\"></div>\n        <ng-content select=\"aw-dialog-footer\"></ng-content>\n    </p-footer>\n</p-dialog>\n",
                    styles: ["::ng-deep .ui-dialog .ui-dialog-titlebar{background-color:#f2f2f2;padding:15px 20px}::ng-deep .ui-dialog .ui-dialog-titlebar .ui-dialog-titlebar-icon:hover{border-color:transparent}::ng-deep .ui-widget-header{font-weight:400;font-size:16px}::ng-deep .ui-dialog .ui-dialog-content{padding:15px 20px;line-height:1.3em}::ng-deep .ui-dialog .ui-widget-content{border:none}::ng-deep .ui-dialog.ui-widget-content{border:none;box-shadow:0 2px 10px 0 rgba(0,0,0,.3)}::ng-deep .ui-dialog .dialog-footer-separator{border-top:1px solid #d7d7d7;height:14px}::ng-deep .ui-dialog .ui-dialog-footer{padding:0 20px 15px}"]
                },] },
    ];
    /** @nocollapse */
    DialogComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    DialogComponent.propDecorators = {
        title: [{ type: Input }],
        body: [{ type: Input }],
        visibleChange: [{ type: Output }],
        modal: [{ type: Input }],
        closable: [{ type: Input }],
        appendTo: [{ type: Input }],
        onClose: [{ type: Output }],
        onOpen: [{ type: Output }],
        header: [{ type: ContentChild, args: [DialogHeaderComponent,] }],
        footer: [{ type: ContentChild, args: [DialogFooterComponent,] }]
    };
    return DialogComponent;
}(ModalContainer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWDialogModule = /** @class */ (function () {
    function AWDialogModule() {
    }
    AWDialogModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        DialogComponent,
                        DialogHeaderComponent,
                        DialogFooterComponent
                    ],
                    imports: [
                        CommonModule,
                        AWCoreComponentModule,
                        DialogModule
                    ],
                    entryComponents: [
                        ModalComponent,
                        DialogComponent,
                        DialogHeaderComponent,
                        DialogFooterComponent
                    ],
                    exports: [
                        DialogComponent,
                        DialogHeaderComponent,
                        DialogFooterComponent,
                        AWCoreComponentModule
                    ],
                    providers: []
                },] },
    ];
    return AWDialogModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Convenient wrapper class around controls such as radiobuttons, dropdown, checkboxes,
 * Chooser. The type of the chooser may be determined dynamically based on the number of items in
 * the data source list, or can be specified explicitly via the "type" binding.
 *
 *
 *
 */
var GenericChooserComponent = /** @class */ (function (_super) {
    __extends(GenericChooserComponent, _super);
    function GenericChooserComponent(env, _viewContainer, dataSource, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this._viewContainer = _viewContainer;
        _this.dataSource = dataSource;
        _this.parentContainer = parentContainer;
        /**
         *  Is this a List property, or a to-one.
         */
        _this.multiselect = false;
        return _this;
    }
    /**
     * @return {?}
     */
    GenericChooserComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isBlank(this.object)) {
            this.object = (/** @type {?} */ (this._viewContainer.injector)).view.context;
        }
        this.keyPath = new FieldPath(this.key);
        var /** @type {?} */ defaultDataProvider = null;
        if (isPresent(this.list)) {
            defaultDataProvider = this.dataSource.dataProviders.find(this.list);
        }
        else {
            defaultDataProvider = this.dataSource.dataProviders.find(this.destinationClass);
        }
        var /** @type {?} */ projectedSize = defaultDataProvider.expectedCount(this.choiceProviderParams);
        this.initType(projectedSize);
        if (this.type === 'Chooser') {
            this.dataSource.init({
                dataProvider: defaultDataProvider,
                queryType: QueryType.FullText,
                lookupKey: this.displayKey,
                state: new ChooserState(new GCChooserState(this), this.multiselect),
                multiselect: this.multiselect
            });
        }
        else {
            // do we need to read this value in async?
            this.list = defaultDataProvider.data();
        }
        _super.prototype.registerFormControl.call(this, this.selection);
        this.validateRequired();
        if (isBlank(this.selection)) {
            // this.noSelectionString = this.i18n.instant('Widgets.gchooser.noSelString');
            this.noSelectionString = 'Select a Item';
        }
    };
    /**
     *
     * When \@Input type is not passed we try to guess and select the best type for current data
     *
     * @param {?} projectedSize
     * @return {?}
     */
    GenericChooserComponent.prototype.initType = /**
     *
     * When \@Input type is not passed we try to guess and select the best type for current data
     *
     * @param {?} projectedSize
     * @return {?}
     */
    function (projectedSize) {
        if (isBlank(this.type)) {
            if (this.multiselect) {
                this.type = (projectedSize <= 0 || projectedSize > 8) ? 'Chooser' : 'Checkbox';
            }
            else {
                this.type = (projectedSize <= 0 || projectedSize > 20) ? 'Chooser'
                    : (projectedSize < 6) ? 'Radio' :
                        'Dropdown';
            }
        }
    };
    /**
     * There are certain properties which are required by this component. As already mentioned
     * above GenericChooser works with references and thefore two key properties are object and key
     * so we can access an object
     *
     *
     * @return {?}
     */
    GenericChooserComponent.prototype.validateRequired = /**
     * There are certain properties which are required by this component. As already mentioned
     * above GenericChooser works with references and thefore two key properties are object and key
     * so we can access an object
     *
     *
     * @return {?}
     */
    function () {
        if (isBlank(this.object)) {
            throw Error('Cannot continue without a object');
        }
        if (isBlank(this.key)) {
            throw Error('Cannot continue without a key binding');
        }
        if (isBlank(this.list) && isBlank(this.destinationClass)) {
            throw Error('Cannot continue without having either list of values or destinationClass');
        }
        if (isPresent(this.type) &&
            (this.type !== 'Radio' && this.type !== 'Checkbox' && this.type !== 'Dropdown' &&
                this.type !== 'Chooser')) {
            throw Error('Cannot instantiate GenericChooser  - invalid type');
        }
        if (isBlank(this.displayKey)) {
            this.displayKey = 'toString';
        }
    };
    /**
     *
     * Used when displaying value both from primitive type as well complex object. If you want to
     * control how item is displayed you can provide display key, which is can be a  method or
     * property of the object you are displaying.
     *
     * Todo: think about formatters as well
     *
     */
    /**
     *
     * Used when displaying value both from primitive type as well complex object. If you want to
     * control how item is displayed you can provide display key, which is can be a  method or
     * property of the object you are displaying.
     *
     * Todo: think about formatters as well
     *
     * @param {?} item
     * @return {?}
     */
    GenericChooserComponent.prototype.displayValue = /**
     *
     * Used when displaying value both from primitive type as well complex object. If you want to
     * control how item is displayed you can provide display key, which is can be a  method or
     * property of the object you are displaying.
     *
     * Todo: think about formatters as well
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isBlank(this.displayKey)) {
            return item;
        }
        var /** @type {?} */ fieldValue = FieldPath.getFieldValue(item, this.displayKey);
        if (isFunction(fieldValue)) {
            return fieldValue.call(item);
        }
        return fieldValue;
    };
    Object.defineProperty(GenericChooserComponent.prototype, "selection", {
        /**
         *  Retrieve a current value from the parent/target object
         *
         */
        get: /**
         *  Retrieve a current value from the parent/target object
         *
         * @return {?}
         */
        function () {
            return this.keyPath.getFieldValue(this.object);
        },
        /**
         *  set value back to the object
         *
         */
        set: /**
         *  set value back to the object
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.keyPath.setFieldValue(this.object, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    GenericChooserComponent.prototype.onSelection = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.selection = value;
        this.formControl.setValue(this.selection);
        this.formControl.markAsDirty();
    };
    GenericChooserComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-generic-chooser',
                    template: "<ng-container [ngSwitch]=\"type\">\n\n    <ng-template [ngSwitchCase]=\"'Checkbox'\">\n        <aw-checkbox-list [list]=\"list\"\n                          [editable]=\"editable\"\n                          [selections]=\"selection\"\n                          [name]=\"name\"\n                          [disabled]=\"disabled\"\n                          [labelFormatter]=\"displayValue\"\n                          (onSelection)=\"onSelection($event)\">\n        </aw-checkbox-list>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Radio'\">\n        <aw-radiobutton-list [list]=\"list\"\n                             [selection]=\"selection\"\n                             [editable]=\"editable\"\n                             [name]=\"name\"\n                             [disabled]=\"disabled\"\n                             [labelFormatter]=\"displayValue\"\n                             (onSelection)=\"onSelection($event)\">\n        </aw-radiobutton-list>\n    </ng-template>\n\n    <ng-template [ngSwitchCase]=\"'Dropdown'\">\n        <aw-dropdown [list]=\"list\"\n                     [isStandalone]=\"false\"\n                     [editable]=\"editable\"\n                     [noSelectionString]=\"noSelectionString\"\n                     [selection]=\"selection\"\n                     [disabled]=\"disabled\"\n                     [name]=\"name\"\n                     (onSelection)=\"onSelection($event)\">\n            <ng-template #itemTemplate let-item>\n\n                <!-- todo: allow to pass a PIPE to do some additional formatting -->\n                {{ displayValue(item.value) }}\n            </ng-template>\n        </aw-dropdown>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Chooser'\">\n        <aw-chooser #chooser\n                    [editable]=\"editable\"\n                    [isStandalone]=\"false\"\n                    [name]=\"name\"\n                    [multiselect]=\"multiselect\"\n                    [dataSource]=\"dataSource\"\n                    [valueTransformer]=\"displayValue\"\n                    [disabled]=\"disabled\">\n\n        </aw-chooser>\n\n    </ng-template>\n\n</ng-container>\n",
                    styles: [""],
                    providers: [
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return GenericChooserComponent; }) },
                        { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                    ]
                },] },
    ];
    /** @nocollapse */
    GenericChooserComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: ViewContainerRef },
        { type: ChooserDataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    GenericChooserComponent.propDecorators = {
        list: [{ type: Input }],
        object: [{ type: Input }],
        key: [{ type: Input }],
        destinationClass: [{ type: Input }],
        choiceProviderParams: [{ type: Input }],
        multiselect: [{ type: Input }],
        type: [{ type: Input }],
        displayKey: [{ type: Input }],
        noSelectionString: [{ type: Input }]
    };
    return GenericChooserComponent;
}(BaseFormComponent));
/**
 * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
 *
 */
var  /**
 * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
 *
 */
GCChooserState = /** @class */ (function (_super) {
    __extends(GCChooserState, _super);
    function GCChooserState(gChooser) {
        var _this = _super.call(this) || this;
        _this.gChooser = gChooser;
        return _this;
    }
    /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    GCChooserState.prototype.setSelectionState = /**
     * @param {?} selection
     * @param {?} selected
     * @return {?}
     */
    function (selection, selected) {
        if (selected === this.isSelected(selection)) {
            return;
        }
        if (this.gChooser.multiselect) {
            // Check if we can implement smarter and more generic way how we use it in java
            // RelationshipField.addTo(_object, _keyPath, selection);
            var /** @type {?} */ multiRel = this.gChooser.keyPath.getFieldValue(this.gChooser.object);
            if (isBlank(multiRel)) {
                multiRel = [];
            }
            else if (isPresent(multiRel) && !isArray(multiRel)) {
                throw new Error('I can not store multiselect value into non-array object');
            }
            if (selected) {
                multiRel.push(selection);
                this.gChooser.selection = multiRel;
            }
            else {
                ListWrapper.removeIfExist(multiRel, selection);
            }
        }
        else {
            if (!selection) {
                selection = null;
            }
            this.gChooser.selection = selection;
        }
    };
    /**
     * @return {?}
     */
    GCChooserState.prototype.selectedObject = /**
     * @return {?}
     */
    function () {
        if (this.gChooser.multiselect) {
            var /** @type {?} */ objects = this.selectedObjects();
            return (isBlank(objects) || ListWrapper.isEmpty(objects)) ? null : ListWrapper.last(objects);
        }
        return this.gChooser.selection;
    };
    /**
     * @return {?}
     */
    GCChooserState.prototype.selectedObjects = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ selection = this.gChooser.selection;
        if (this.gChooser.multiselect && isBlank(selection)) {
            selection = [];
        }
        return (this.gChooser.multiselect && isArray(selection)) ? selection : [selection];
    };
    /**
     * @param {?} selection
     * @return {?}
     */
    GCChooserState.prototype.isSelected = /**
     * @param {?} selection
     * @return {?}
     */
    function (selection) {
        if (this.gChooser.multiselect) {
            return ListWrapper.containsComplex(this.selectedObjects(), selection);
        }
        var /** @type {?} */ curValue = this.selectedObject();
        return equals(curValue, selection);
    };
    return GCChooserState;
}(ChooserSelectionState));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Wrapper class for RadioButton component providing convenient way to to render RadioButton Groups
 *
 *
 * ### Example
 *
 *
 * ```
 * \@Component({
 *          selector: 'gender-selector' ,
 *          template: `
 *              <aw-radiobutton-list [list]="rbListValues" [layout]="layout"
 *     [selection]="selectedValue" [name]="'name'">
 *               </aw-radiobutton-list>
 *      `
 *      })
 *      export class GenderSelectorComponent
 *      {
 *          rbListValues: string[] = ['male' , 'female' , 'other'];
 *          selectedValue: string = 'other';
 *          layout: string = 'stacked';
 *
 *
 *          formGroup: FormGroup = new FormGroup({});
 *
 *
 *          onCBClick (event): void
 *          {
 *              console.log('onCBClick = ' + event);
 *          }
 *
 *      }
 *
 * ```
 */
var /** @type {?} */ RB_LIST_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return RadioButtonListComponent; }),
    multi: true
};
var RadioButtonListComponent = /** @class */ (function (_super) {
    __extends(RadioButtonListComponent, _super);
    function RadioButtonListComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         *
         * Fires an event when radio button is selected
         *
         */
        _this.onSelection = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    RadioButtonListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isPresent(this.selection)) {
            this.model = 0;
        }
        this.updateModel(this.selection);
        this.onModelChanged(this.selection);
        this.registerFormControl(this.selection);
    };
    /**
     * Label is extracted into a method so in the future we can play how we want to display the
     * value. Since I want to support formatters for each components we might have a chance to
     * decide how the label will look like.
     *
     */
    /**
     * Label is extracted into a method so in the future we can play how we want to display the
     * value. Since I want to support formatters for each components we might have a chance to
     * decide how the label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    RadioButtonListComponent.prototype.labelValue = /**
     * Label is extracted into a method so in the future we can play how we want to display the
     * value. Since I want to support formatters for each components we might have a chance to
     * decide how the label will look like.
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isPresent(this.labelFormatter)) {
            return this.labelFormatter(item);
        }
        return item.toString();
    };
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     *
     *
     */
    /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     *
     *
     * @param {?} item
     * @return {?}
     */
    RadioButtonListComponent.prototype.value = /**
     * In this version of checkboxes we still expect only primitive types. Keep this functionality
     * in extra method so we can work with it even now we just return the same value back
     *
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item;
    };
    /**
     *
     * On NGModel change retrieve actual record based on the INDEX and propagate it to both
     * ngModel as well as FormGroup.
     *
     */
    /**
     *
     * On NGModel change retrieve actual record based on the INDEX and propagate it to both
     * ngModel as well as FormGroup.
     *
     * @param {?} event
     * @return {?}
     */
    RadioButtonListComponent.prototype.onChange = /**
     *
     * On NGModel change retrieve actual record based on the INDEX and propagate it to both
     * ngModel as well as FormGroup.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ updatedModel = this.list[this.model];
        this.onSelection.emit(updatedModel);
        this.onModelChanged(updatedModel);
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
    };
    /**
     * Since we might be dealing with complex object store only INDEX number in the model.
     *
     */
    /**
     * Since we might be dealing with complex object store only INDEX number in the model.
     *
     * @param {?} souceItem
     * @return {?}
     */
    RadioButtonListComponent.prototype.updateModel = /**
     * Since we might be dealing with complex object store only INDEX number in the model.
     *
     * @param {?} souceItem
     * @return {?}
     */
    function (souceItem) {
        var /** @type {?} */ index = this.list.findIndex(function (elem) {
            return souceItem === elem;
        });
        this.model = index === -1 ? 0 : index;
    };
    /**
     * @return {?}
     */
    RadioButtonListComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ updatedModel = this.list[this.model];
        this.formControl.setValue(updatedModel, {
            emitEvent: true,
            emitViewToModelChange: false
        });
        // this.cd.detectChanges();
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    RadioButtonListComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.value) {
            var /** @type {?} */ newModel = value;
            this.updateModel(newModel);
        }
    };
    RadioButtonListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-radiobutton-list',
                    template: "<div *ngFor=\"let item of list;  let i = index\" class=\"ui-g\">\n\n    <div class=\"ui-g-12\">\n        <aw-radiobutton\n            [(ngModel)]=\"model\"\n            (ngModelChange)=\"onChange($event)\"\n            [isStandalone]=\"false\"\n            [name]=\"name\"\n            [value]=\"i\"\n            [label]=\"labelValue(item)\">\n        </aw-radiobutton>\n    </div>\n\n</div>\n",
                    styles: [""],
                    providers: [
                        RB_LIST_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return RadioButtonListComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    RadioButtonListComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    RadioButtonListComponent.propDecorators = {
        list: [{ type: Input }],
        selection: [{ type: Input }],
        labelFormatter: [{ type: Input }],
        onSelection: [{ type: Output }]
    };
    return RadioButtonListComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Implements standard HTML radio button on top of PrimeNG with ariba styling
 *
 * ### Example
 *
 * 1. Basic usage using ngModel pre-selected first radio
 *
 *  ```ts
 *
 * \@Component({
 *          selector: 'demo-comp',
 *          template: `
 *              <aw-radiobutton [name]="'color'" [value]="'red'" [label]="'Red'"
 *                             [(ngModel)]="model">
 *             </aw-radiobutton>
 *              <aw-radiobutton [name]="'color'" [value]="'blue'" [label]="'Blue'"
 *                      [(ngModel)]="model">
 *              </aw-radiobutton>
 *      `
 *      })*
 *      class BasicWithNgModelComponent
 *      {
 *          model: string[] = ['red'];
 *
 *          constructor()
 *          {
 *          }
 *      }
 *
 *  ```
 *
 *
 * 2. Basic usage with formGroup
 *
 *
 * ```ts
 * \@Component({
 *           selector: 'demo-comp',
 *           template: `
 *          <div [formGroup]="env.currentForm">
 *               <aw-radiobutton [name]="'color2'" [value]="'red'" [label]="'Red'"
 *               (onChange)="onChange($event)">
 *               </aw-radiobutton>
 *               <aw-radiobutton [name]="'color2'" [value]="'blue'" [label]="'Blue'"
 *               (onChange)="onChange($event)">
 *               </aw-radiobutton>
 *
 *       </div>
 *       `
 *       })
 *       class BasicWithFormGroupComponent implements OnInit
 *       {
 *           model: string = 'blue';
 *
 *           constructor(public env: Environment)
 *           {
 *           }
 *
 *           ngOnInit(): void
 *           {
 *               this.env.currentForm = new FormGroup({});
 *               this.env.currentForm.registerControl('color2', new FormControl(this.model));
 *           }
 *
 *
 *           onChange(event: any): void
 *           {
 *               this.modelSet = event;
 *           }
 *
 *       }
 *  ````
 *
 *
 *
 *
 */
var /** @type {?} */ RAB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return RadioButtonComponent; }),
    multi: true
};
var RadioButtonComponent = /** @class */ (function (_super) {
    __extends(RadioButtonComponent, _super);
    function RadioButtonComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         *
         * A value associated with this radio
         *
         */
        _this.value = '';
        /**
         * Trigger click event with currrent selected value
         *
         */
        _this.onChange = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    RadioButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (this.isStandalone) {
            _super.prototype.registerFormControl.call(this, this.value);
            this.model = this.formControl.value;
            this.onModelChanged(this.model);
        }
        else {
            this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
        }
    };
    /**
     * Called when radio is clicked. Not using PrimeNG click event as it is fired before
     * the model is changed. Therefore need to listen on (ngModelChange)
     *
     */
    /**
     * Called when radio is clicked. Not using PrimeNG click event as it is fired before
     * the model is changed. Therefore need to listen on (ngModelChange)
     *
     * @param {?} newVal
     * @return {?}
     */
    RadioButtonComponent.prototype.onModelChange = /**
     * Called when radio is clicked. Not using PrimeNG click event as it is fired before
     * the model is changed. Therefore need to listen on (ngModelChange)
     *
     * @param {?} newVal
     * @return {?}
     */
    function (newVal) {
        this.onModelChanged(this.model);
        if (this.isStandalone) {
            this.formControl.setValue(this.model, { emitEvent: true });
        }
        this.onChange.emit(this.model);
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    RadioButtonComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.model) {
            this.model = value;
            if (this.isStandalone) {
                this.formControl.setValue(this.model, { emitEvent: true });
            }
            this.onModelChanged(this.model);
        }
    };
    RadioButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-radiobutton',
                    template: "<span class=\"w-radiobutton\">\n\n    <ng-template [ngIf]=\"editable \">\n        <p-radioButton [name]=\"name\"\n                       [value]=\"value\"\n                       [label]=\"label\"\n                       [(ngModel)]=\"model\"\n                       [disabled]=\"disabled\"\n                       (ngModelChange)=\"onModelChange($event)\"\n                       [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\">\n        </p-radioButton>\n    </ng-template>\n</span>\n",
                    styles: ["/deep/ .w-radiobutton .ui-radiobutton-box{width:23px;height:23px;line-height:23px}/deep/ .w-radiobutton .ui-radiobutton-icon{font-size:1.5em;line-height:1em}"],
                    providers: [
                        RAB_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return RadioButtonComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    RadioButtonComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    RadioButtonComponent.propDecorators = {
        value: [{ type: Input }],
        label: [{ type: Input }],
        onChange: [{ type: Output }]
    };
    return RadioButtonComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWRadioButtonModule = /** @class */ (function () {
    function AWRadioButtonModule() {
    }
    AWRadioButtonModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        RadioButtonComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        RadioButtonModule
                    ],
                    entryComponents: [
                        RadioButtonComponent
                    ],
                    exports: [
                        RadioButtonComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWRadioButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWRadioButtonListModule = /** @class */ (function () {
    function AWRadioButtonListModule() {
    }
    AWRadioButtonListModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        RadioButtonListComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        AWRadioButtonModule
                    ],
                    entryComponents: [
                        RadioButtonListComponent
                    ],
                    exports: [
                        RadioButtonListComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWRadioButtonListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWGenericChooserModule = /** @class */ (function () {
    function AWGenericChooserModule() {
    }
    AWGenericChooserModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        GenericChooserComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        AWCoreComponentModule,
                        AWDropdownModule,
                        AWCheckBoxListModule,
                        AWChooserModule,
                        AWRadioButtonListModule
                    ],
                    entryComponents: [
                        GenericChooserComponent
                    ],
                    exports: [
                        ReactiveFormsModule,
                        FormsModule,
                        GenericChooserComponent
                    ]
                },] },
    ];
    return AWGenericChooserModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * OutlineState is the key gluing part for the OutlineFor and OutlineController components. It
 * holds all important information for the current outline tree and manages expansion states in form
 * of so called expansionPath and expansionStates
 *
 * We need to have a way how to work with generic data structure in order not to hold UI specific
 * information on the domain object model just like we had it before, where we had an interface
 * called OutlineNode, with fields (expanded, selected, etc.. )
 *
 *
 * `expansionPath`: Holds an array of currently selected and expanded nodes. This is filled by
 * OutlineController.
 *
 *
 * If we are dealing with Entity or anything that has identity then we have easier situation as we
 * can ask for ID and it is more efficient for serialization
 */
var OutlineState = /** @class */ (function () {
    function OutlineState() {
        /**
         *
         * When outline is rendered for first time or re-rendered and we set default value for the
         * expansionStates. This way we can pretty easily execute CollapseAll, ExpandAll
         *
         */
        this.globalState = false;
        /**
         *
         * Holds current level during tree node rendering so we can apply correct indentation
         *
         */
        this.currentLevel = -1;
        this.expansionStates = new Map();
    }
    /**
     * For the collapseAll and expandAll we are using simple mechanism where we clean up all
     * selection and then set the global expand state, this whey isExpand method returns the same
     * state for all items
     */
    /**
     * For the collapseAll and expandAll we are using simple mechanism where we clean up all
     * selection and then set the global expand state, this whey isExpand method returns the same
     * state for all items
     * @return {?}
     */
    OutlineState.prototype.collapseAll = /**
     * For the collapseAll and expandAll we are using simple mechanism where we clean up all
     * selection and then set the global expand state, this whey isExpand method returns the same
     * state for all items
     * @return {?}
     */
    function () {
        this.expansionStates.clear();
        this.globalState = false;
    };
    /**
     * @return {?}
     */
    OutlineState.prototype.expandAll = /**
     * @return {?}
     */
    function () {
        this.expansionStates.clear();
        this.globalState = true;
    };
    Object.defineProperty(OutlineState.prototype, "expansionPath", {
        get: /**
         * @return {?}
         */
        function () {
            if (isBlank(this._expansionPath)) {
                this._expansionPath = [];
            }
            return this._expansionPath;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._expansionPath = value;
            if (isBlank(this._expansionPath)) {
                return;
            }
            this._expansionPath.forEach(function (item) {
                _this.setExpansionState(item, true);
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} currentPath
     * @param {?=} chidren
     * @return {?}
     */
    OutlineState.prototype.toggleExpansion = /**
     * @param {?} currentPath
     * @param {?=} chidren
     * @return {?}
     */
    function (currentPath, chidren) {
        var _this = this;
        if (isBlank(currentPath)) {
            return;
        }
        var /** @type {?} */ item = ListWrapper.last(currentPath);
        var /** @type {?} */ itemChildren = chidren || [];
        var /** @type {?} */ newState = !this.isExpanded(item);
        this.setExpansionState(item, newState);
        if (!newState) {
            ListWrapper.removeLast(currentPath);
            itemChildren.forEach(function (child) {
                _this.setExpansionState(child, newState);
            });
        }
        this.setExpansionPath(currentPath);
    };
    /**
     * @param {?} item
     * @param {?} isExpanded
     * @return {?}
     */
    OutlineState.prototype.setExpansionState = /**
     * @param {?} item
     * @param {?} isExpanded
     * @return {?}
     */
    function (item, isExpanded) {
        var /** @type {?} */ key = this.itemToKey(item);
        if (isExpanded === this.globalState) {
            this.expansionStates.delete(key);
        }
        else {
            this.expansionStates.set(key, (isExpanded) ? true : false);
        }
    };
    /**
     * To improve state persisting lets check if we are dealing with an Object that has Identity
     * so we can extract an ID otherwise use object to compare by reference
     *
     *
     * @param {?} item
     * @return {?}
     */
    OutlineState.prototype.itemToKey = /**
     * To improve state persisting lets check if we are dealing with an Object that has Identity
     * so we can extract an ID otherwise use object to compare by reference
     *
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return isEntity(item) ? (/** @type {?} */ (item)).identity() : item;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OutlineState.prototype.setExpansionPath = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        this.expansionPath = item;
        item.forEach(function (node) {
            _this.setExpansionState(node, true);
        });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OutlineState.prototype.isExpanded = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ key = this.itemToKey(item);
        if (!this.expansionStates.has(key)) {
            return this.globalState;
        }
        return this.expansionStates.get(key);
    };
    OutlineState.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    OutlineState.ctorParameters = function () { return []; };
    return OutlineState;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * OutlineForComponent is like ngFor, but for hierarchical (outline/tree) structures -- i.e. in
 * those cases where an item may have children.
 *
 *
 * It uses outline `<aw-outline-control>` to provide expanding functionality, indentation
 * and other things.
 *
 *
 * This component has minimal styling to make sure it can be changed easily.
 *
 * ### Example rendering tree section, where based on the type we format the out plus
 * for the main root section we always render little popup menu.
 *
 * ```
 *
 *   <aw-outline-for [list]="list" [hasChildren]="hasChildren">
 *
 *       <ng-template #outline let-item>
 *
 *           <div class="my-section">
 *               <div class="outline">
 *                   <aw-outline-control>
 *                       <ng-container [ngSwitch]="item.type">
 *                           <ng-template [ngSwitchCase]="'text'">
 *                               <div class="as-paragraf">
 *                                   {{item?.content}}
 *                               </div>
 *                           </ng-template>
 *
 *
 *                           <ng-template ngSwitchDefault>
 *                               {{item?.content}}
 *                           </ng-template>
 *
 *
 *                       </ng-container>
 *
 *
 *                   </aw-outline-control>
 *               </div>
 *
 *               <div class="filters" *ngIf="item.type === 'section'" >
 *
 *                   <aw-hover-card [linkTitle]="'Filter Items'">
 *                       <aw-list [list]="filterItems" [borderless]="true"></aw-list>
 *                   </aw-hover-card>
 *
 *               </div>
 *           </div>
 *     </ng-template>`
 *   </aw-outline-for>
 *
 * ```
 *
 *
 * We can use it also in embedded mode where we use the `awOutlineFor` directive
 *
 * ## Example
 *
 *
 * ````
 *  <table  class="tree-table" >
 *      <thead>
 *          <tr>
 *              <th>Name</th>
 *              <th>Type</th>
 *          </tr>
 *      </thead>
 *      <tbody #ooo2 awOutlineFor [list]="list"
 *             [hasChildren]="hasChildren"
 *             class="outline-table"
 *      >
 *          <ng-template #outline let-item>
 *              <tr>
 *                  <td class="item-name outline-animation">
 *                      <div><aw-outline-control>
 *                          {{item?.content}}
 *                      </aw-outline-control></div>
 *                  </td>
 *                  <td class="item-type outline-animation">
 *                      <div>{{item.type}}</div>
 *                  </td>
 *              </tr>
 *          </ng-template>
 *      </tbody>
 *  </table>
 *
 * ```
 *
 * I was thinking maybe for first time we don't need the same animation like expanding and
 * collapsing. Maybe we need fade-in. In such case I would probably apply \@section anim only
 * on items where level > 0 (in the template I keep levels) and if level == 0 then I would
 * execute the same rendering just without [\@section]
 *
 *
 * Todo: Think about how to do animation for the table case. Must also write unitest - due to
 * AribaLive aggressive schedule we are skipping them for now
 *
 */
var OutlineForComponent = /** @class */ (function (_super) {
    __extends(OutlineForComponent, _super);
    function OutlineForComponent(env, _viewContainer, builder, element) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this._viewContainer = _viewContainer;
        _this.builder = builder;
        _this.element = element;
        /**
         * Tells the component not to render expansion control, in such case we expandAll as a
         * default behavior
         *
         */
        _this.showExpansionControl = true;
        /**
         * Opens all tree nodes.
         *
         */
        _this.expandAll = false;
        /**
         *
         * Set indentation size to be used for each level
         *
         */
        _this.indentationPerLevel = 25;
        _this.pushRootSectionOnNewLine = false;
        /**
         *
         * Used when in selection mode to push current selected Item to the application
         *
         */
        _this.onItemSelected = new EventEmitter();
        /**
         *
         * This event is triggered by OutlineControl when node is expanded or collapsed
         *
         */
        _this.onExpandChange = new EventEmitter();
        _this.embedded = false;
        /**
         * Flag that tells us that component is fully rendered
         *
         */
        _this.viewInitialized = false;
        return _this;
    }
    /**
     * @return {?}
     */
    OutlineForComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isBlank(this.state)) {
            this.state = new OutlineState();
        }
        if (isBlank(this.state.outlineFor)) {
            this.state.outlineFor = this;
        }
        if (this.expandAll) {
            this.showExpansionControl = false;
        }
        this.state.globalState = this.expandAll;
        // in case we want to render content of tree outside of outlineFor
        if (isPresent(this.externalTemplate)) {
            this.controlTemplate = this.externalTemplate;
        }
        this.embedded = this.element.nativeElement.hasAttribute('awoutlinefor');
        if (isBlank(this.context)) {
            this.context = this;
        }
        // // when root section needs to be on new line, then automatically expand second level
        // if (this.pushRootSectionOnNewLine) {
        //     this.list.forEach((item: any) => {
        //         let currentItem = ListWrapper.last(this.state.currentPath);
        //         this.state.toggleExpansion(item);
        //     })
        // }
    };
    /**
     * @return {?}
     */
    OutlineForComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngDoCheck.call(this);
    };
    /**
     * Used by template and OutlineControl to identify which item is expanded and collapsed
     *
     */
    /**
     * Used by template and OutlineControl to identify which item is expanded and collapsed
     *
     * @param {?} item
     * @param {?=} currentLevel
     * @return {?}
     */
    OutlineForComponent.prototype.isExpanded = /**
     * Used by template and OutlineControl to identify which item is expanded and collapsed
     *
     * @param {?} item
     * @param {?=} currentLevel
     * @return {?}
     */
    function (item, currentLevel) {
        if (currentLevel === void 0) { currentLevel = -1; }
        return (currentLevel === 0 && this.pushRootSectionOnNewLine)
            ? true : this.state.isExpanded(item);
    };
    /**
     *
     * Since we have currently two ways how to pass children items we need have this method to
     * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
     * we expect current object to have `children` field
     *
     */
    /**
     *
     * Since we have currently two ways how to pass children items we need have this method to
     * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
     * we expect current object to have `children` field
     *
     * @param {?} item
     * @return {?}
     */
    OutlineForComponent.prototype.childrenForItem = /**
     *
     * Since we have currently two ways how to pass children items we need have this method to
     * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
     * we expect current object to have `children` field
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.hasChildren(item) ? this.doGetChildren(item) : [];
    };
    /**
     *
     * Check if the current item has a children and needs to be rendered
     *
     */
    /**
     *
     * Check if the current item has a children and needs to be rendered
     *
     * @param {?} item
     * @return {?}
     */
    OutlineForComponent.prototype.hasChildren = /**
     *
     * Check if the current item has a children and needs to be rendered
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isBlank(this.children) && isBlank(item.children)) {
            assert(false, 'Missing [children] method binding');
        }
        return this.doGetChildren(item).length > 0;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    OutlineForComponent.prototype.doGetChildren = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.children.apply(this.context, [item]);
    };
    /**
     *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
     *  put together inside `OutlineControl` where we iterate all the way to the root and add
     *  each item to the `currentPath` array. This way we collect list of item representing current
     *  current expansionPath.
     *
     *
     */
    /**
     *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
     *  put together inside `OutlineControl` where we iterate all the way to the root and add
     *  each item to the `currentPath` array. This way we collect list of item representing current
     *  current expansionPath.
     *
     *
     * @return {?}
     */
    OutlineForComponent.prototype.toggleExpansion = /**
     *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
     *  put together inside `OutlineControl` where we iterate all the way to the root and add
     *  each item to the `currentPath` array. This way we collect list of item representing current
     *  current expansionPath.
     *
     *
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.animationInProgress) {
            // backup procedure in case onAnimationDone fails
            setTimeout(function () {
                if (_this.animationInProgress) {
                    // change only if its fails
                    _this.animationInProgress = false;
                }
            }, 200);
            return;
        }
        if (!this.embedded) {
            this.animationInProgress = true;
        }
        var /** @type {?} */ currentItem = ListWrapper.last(this.state.currentPath);
        this.state.toggleExpansion(this.state.currentPath, this.childrenForItem(currentItem));
        if (this.embedded) ;
    };
    /**
     * Angular anim. callback that sets back the flag to make sure we don't trigger animations
     * when one is in progress.
     *
     */
    /**
     * Angular anim. callback that sets back the flag to make sure we don't trigger animations
     * when one is in progress.
     *
     * @param {?} event
     * @return {?}
     */
    OutlineForComponent.prototype.onAnimationDone = /**
     * Angular anim. callback that sets back the flag to make sure we don't trigger animations
     * when one is in progress.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.animationInProgress = false;
    };
    /**
     * Calculated indentation used to shift the nested section to the right or later on to the
     * left when RTL is supported
     *
     *
     */
    /**
     * Calculated indentation used to shift the nested section to the right or later on to the
     * left when RTL is supported
     *
     *
     * @param {?} currentLevel
     * @return {?}
     */
    OutlineForComponent.prototype.indentation = /**
     * Calculated indentation used to shift the nested section to the right or later on to the
     * left when RTL is supported
     *
     *
     * @param {?} currentLevel
     * @return {?}
     */
    function (currentLevel) {
        if (this.pushRootSectionOnNewLine && currentLevel > 0) {
            currentLevel -= 1;
        }
        return (currentLevel === 0 && this.pushRootSectionOnNewLine)
            ? 0 : (this.indentationPerLevel * currentLevel);
    };
    /**
     * Not all rows are visible by default, there can be a case where you dont want to render items
     * using outline. e.g. Datatable with detail row.
     */
    /**
     * Not all rows are visible by default, there can be a case where you dont want to render items
     * using outline. e.g. Datatable with detail row.
     * @param {?} item
     * @return {?}
     */
    OutlineForComponent.prototype.isVisible = /**
     * Not all rows are visible by default, there can be a case where you dont want to render items
     * using outline. e.g. Datatable with detail row.
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isPresent(this.filterOut)) {
            return !this.filterOut(item);
        }
        return true;
    };
    OutlineForComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-outline-for, [awOutlineFor]',
                    template: "<!--\n    Starts with the list, where nestingLevel is -1.\n    call template outlineItems to iterate and render each item\n-->\n<ng-container [ngIf]=\"list\" *ngTemplateOutlet=\"outlineItems;\n            context:{ $implicit: list, nestingLevel: 0, parentItem: null, expanded: true}\">\n</ng-container>\n\n<!--\n    Main Entry point for the recursion. this is called by the block above as well as byt the inner\n    piece that calls this template recursively again when an item has children\n-->\n<ng-template #outlineItems let-children let-nestingLevel=\"nestingLevel\"\n             let-parent=\"parentItem\" let-expanded=\"expanded\">\n\n    <ng-template ngFor let-item [ngForOf]=\"children\"  let-rowIndex=\"index\">\n\n        <ng-container *ngTemplateOutlet=\"outlineItem;\n            context:{ $implicit: item, nestingLevel: nestingLevel, parentItem: parent,\n            expanded: expanded, rowIndex:rowIndex}\">\n        </ng-container>\n\n        <!--\n\n            Recursion piece:\n\n            For non embedded case when even if its not expanded we need to iterate children\n            as we want to apply animation that should go with ngIf which inside the outineItem\n            template\n\n            Dont recurse/ render items that are not visible.\n        -->\n\n        <ng-template [ngIf]=\"hasChildren(item) && (isExpanded(item, nestingLevel) || !embedded) && isVisible(item)\">\n            <ng-container *ngTemplateOutlet=\"outlineItems;\n                        context:{ $implicit: childrenForItem(item),\n                                nestingLevel: nestingLevel+1,\n                                expanded: isExpanded(item, nestingLevel),\n                                parentItem:item }\">\n            </ng-container>\n        </ng-template>\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Renders actual outline node and applies animation while expanding and collapsing\n\n    [@section]=\"expanded || isExpanded(item) ? 'visible' : 'hidden'\"\n-->\n<ng-template #outlineItem let-item let-nestingLevel=\"nestingLevel\" let-parent=\"parentItem\"\n             let-rowIndex=\"rowIndex\"\n             let-expanded=\"expanded\">\n\n    <div class=\"w-outline-item\"\n         *ngIf=\"!embedded && expanded\"\n         [style.padding-left.px]=\"indentation(nestingLevel)\"\n         initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n         [setCurrrentItem]=\"item\"\n         [@section]\n         (@section.done)=\"onAnimationDone($event)\">\n\n        <ng-container *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex }\">\n        </ng-container>\n    </div>\n\n    <!--\n        When outline control is used as embedded meaning its inside e..g datatable we\n        cannot have any tags around it.\n\n        Todo: Refactor this in the way so we can do animation when table lines are\n        expanded. Since its embedded we can not have any wrapping element around, the template\n        is fully responsible\n    -->\n    <ng-template [ngIf]=\"embedded && expanded\"\n                 initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n                 [setCurrrentItem]=\"item\"\n    >\n        <ng-container #renderedItem *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex  }\">\n        </ng-container>\n    </ng-template>\n\n</ng-template>\n\n\n",
                    styles: [".is-outline-animation>div,::ng-deep .w-outline-item{overflow:hidden}"],
                    animations: [
                        trigger('section', [
                            state('*', style({
                                'overflow-y': 'hidden',
                                'height': '*',
                                'opacity': '1'
                            })),
                            state('void', style({
                                'height': '0',
                                'opacity': '0',
                                'overflow-y': 'hidden'
                            })),
                            transition('* => void', animate('200ms ease-out')),
                            transition('void => *', animate('200ms ease-in'))
                        ]),
                    ]
                },] },
    ];
    /** @nocollapse */
    OutlineForComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: ViewContainerRef },
        { type: AnimationBuilder },
        { type: ElementRef }
    ]; };
    OutlineForComponent.propDecorators = {
        list: [{ type: Input }],
        showExpansionControl: [{ type: Input }],
        children: [{ type: Input }],
        filterOut: [{ type: Input }],
        expandAll: [{ type: Input }],
        state: [{ type: Input }],
        indentationPerLevel: [{ type: Input }],
        externalTemplate: [{ type: Input }],
        context: [{ type: Input }],
        pushRootSectionOnNewLine: [{ type: Input }],
        onItemSelected: [{ type: Output }],
        onExpandChange: [{ type: Output }],
        controlTemplate: [{ type: ContentChild, args: ['outline',] }],
        outlineItem: [{ type: ViewChild, args: ['renderedItem',] }]
    };
    return OutlineForComponent;
}(BaseComponent));
/**
 *
 * Since we can not directly set `*ngTemplateOutlet` context variables to the typescript class we
 * use this directive to do the Job
 *
 */
var InitNestingDirective = /** @class */ (function () {
    function InitNestingDirective(outline) {
        this.outline = outline;
    }
    /**
     * @return {?}
     */
    InitNestingDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (isPresent(this.setLevel)) {
            this.outline.state.currentLevel = this.setLevel;
        }
        if (isPresent(this.setCurrrentItem)) {
            this.outline.currentItem = this.setCurrrentItem;
        }
        if (isPresent(this.setParentItem)) {
            this.outline.currentItem['$$parentItem'] = this.setParentItem;
        }
    };
    InitNestingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[initNesting]'
                },] },
    ];
    /** @nocollapse */
    InitNestingDirective.ctorParameters = function () { return [
        { type: OutlineForComponent }
    ]; };
    InitNestingDirective.propDecorators = {
        setLevel: [{ type: Input }],
        setCurrrentItem: [{ type: Input }],
        setParentItem: [{ type: Input }]
    };
    return InitNestingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * OutlineControlComponent renders the indentation, arrow, and text for a node in an outline.
 * It should be used either in the body of an OutlineFor component, or inside datatable
 *
 *
 * ##Usage inside body:
 *
 *  Here you can see that we need to wrap out content inside ng-template which will push us
 *  give us current item item and then we can place OutlineControlComponent to control
 *  the tree.
 *
 * ```
 *  <aw-outline-for2 #ooo [list]="list" [hasChildren]="hasChildren">
 *
 *      <ng-template #outline let-item>
 *          <div class="my-section">
 *              <div class="outline">
 *                  <aw-outline-control>
 *                      {{item?.content}}
 *                  </aw-outline-control>
 *              </div>*
 *          </div>
 *      </ng-template>
 *  </aw-outline-for2>
 *
 *
 * ```
 *
 * We can
 *
 *
 */
var OutlineControlComponent = /** @class */ (function (_super) {
    __extends(OutlineControlComponent, _super);
    function OutlineControlComponent(env, outlineState, parentControl, outlineFor) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.outlineState = outlineState;
        _this.parentControl = parentControl;
        _this.outlineFor = outlineFor;
        /**
         *
         *  If TRUE it changes the behavior of the outline node text which click is triggered
         *  it selects the item and broadcast the `onItemSelected` event
         *
         */
        _this.allowSelection = false;
        /**
         *
         * Triggers action when outline item is expanded
         *
         */
        _this.action = new EventEmitter();
        _this.isRootItem = false;
        return _this;
    }
    /**
     * @return {?}
     */
    OutlineControlComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.prepareControl();
    };
    /**
     *
     * We dont show expansion icons when there no children
     *
     */
    /**
     *
     * We dont show expansion icons when there no children
     *
     * @return {?}
     */
    OutlineControlComponent.prototype.hasExpansionControl = /**
     *
     * We dont show expansion icons when there no children
     *
     * @return {?}
     */
    function () {
        return this.outlineFor.hasChildren(this.item) && this.outlineFor.showExpansionControl;
    };
    /**
     * @return {?}
     */
    OutlineControlComponent.prototype.isSelected = /**
     * @return {?}
     */
    function () {
        return this.outlineFor.state.selectedItem === this.item;
    };
    /**
     * @return {?}
     */
    OutlineControlComponent.prototype.calculateStyleClass = /**
     * @return {?}
     */
    function () {
        if (!this.hasExpansionControl() ||
            (this.outlineFor.pushRootSectionOnNewLine && isBlank(this.item.$$parentItem))) {
            return '';
        }
        if (this.outlineFor.embedded) {
            return this.outlineFor.isExpanded(this.item) ? 'icon-slim-arrow-down'
                : 'icon-slim-arrow-right';
        }
        else {
            return this.outlineFor.isExpanded(this.item)
                ? 'icon-slim-arrow-right outline-icon-expanded' : 'icon-slim-arrow-right';
        }
    };
    /**
     * Collapses and expands current node
     *
     */
    /**
     * Collapses and expands current node
     *
     * @param {?} event
     * @return {?}
     */
    OutlineControlComponent.prototype.toggleExpansion = /**
     * Collapses and expands current node
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.outlineFor.state.currentPath = [];
        var /** @type {?} */ currentPath = this.item;
        while (isPresent(currentPath)) {
            this.outlineFor.state.currentPath.unshift(currentPath);
            currentPath = currentPath.$$parentItem;
        }
        this.outlineFor.toggleExpansion();
        var /** @type {?} */ payload = {
            item: this.item,
            expanded: this.outlineFor.state.isExpanded(this.item)
        };
        this.action.emit(payload);
        this.outlineFor.onExpandChange.emit(payload);
        event.stopPropagation();
    };
    /**
     * @return {?}
     */
    OutlineControlComponent.prototype.select = /**
     * @return {?}
     */
    function () {
        this.outlineFor.state.selectedItem = this.item;
        this.outlineFor.onItemSelected.emit(this.item);
    };
    /**
     * @return {?}
     */
    OutlineControlComponent.prototype.prepareControl = /**
     * @return {?}
     */
    function () {
        if (isBlank(this.outlineFor) && isPresent(this.outlineState)) {
            this.outlineFor = this.outlineState.outlineFor;
        }
        assert(isPresent(this.outlineFor), 'Missing outlineFor component');
        if (this.outlineFor.embedded) {
            var /** @type {?} */ level = this.outlineFor.state.currentLevel;
            if (this.outlineFor.pushRootSectionOnNewLine && level > 0) {
                level -= 1;
            }
            this.indentation = (this.outlineFor.indentationPerLevel * level);
        }
        this.item = this.outlineFor.currentItem;
        this.isRootItem = isBlank(this.item.$$parentItem);
    };
    OutlineControlComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-outline-control',
                    template: "<!--\n    Control is just the two flex box items for displaying expand/collapse icon and content\n\n    Since we animate only standalone/non-embedded case now then we need to also animate the icon\n    so we use only icon-slim-arrow-right and do tranformation on top of this to make it rotate.\n\n    If embedded case we use both icons icon-slim-arrow-right / icon-slim-arrow-down\n-->\n<div class=\"w-outline-control\"\n     [ngClass]=\"{'outline-u-unselectable-text': outlineFor.pushRootSectionOnNewLine && !item.$$parentItem}\">\n    <div class=\"outline-icon sap-icon\"\n         *ngIf=\"!outlineFor.pushRootSectionOnNewLine || !isRootItem\"\n         (click)=\"toggleExpansion($event)\"\n         [style.margin-left.px]=\"indentation\"\n         [ngClass]=\"calculateStyleClass()\">\n    </div>\n\n    <ng-container *ngIf=\"allowSelection; then withSelection else withoutSelection\">\n    </ng-container>\n</div>\n\n<!--\n We support two case for the content\n\n Selection: When you click on the content it will add extra class so you can style currently\n selected item as well as broadcast event outside so developer can hook in some custom logic\n\n If we dont support selection: Then clicking on the content is just like clicking on expandable\n icon, it toggles the state\n-->\n\n<ng-template #withSelection>\n     <span class=\"outline-content outline-content-selected\" *ngIf=\"isSelected()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span class=\"outline-content\" *ngIf=\"!isSelected()\" (click)=\"select()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n\n</ng-template>\n\n\n<ng-template #withoutSelection>\n    <span class=\"outline-content\" (click)=\"toggleExpansion($event)\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n</ng-template>\n\n\n<ng-template #ngContent>\n    <ng-content></ng-content>\n</ng-template>\n\n",
                    styles: [".w-outline-control{overflow:hidden;display:flex;flex-wrap:nowrap;cursor:pointer}.w-outline-control .outline-icon{flex:0 0 15px;color:#ababab;font-size:14px;font-weight:700;min-width:11px;align-self:center;transition:-webkit-transform 50ms ease-in;transition:transform 50ms ease-in;transition:transform 50ms ease-in,-webkit-transform 50ms ease-in;-webkit-transform-origin:25% 65%;transform-origin:25% 65%;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.w-outline-control .outline-icon.outline-icon-expanded{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.w-outline-control .outline-content{flex:1 1 auto;flex-wrap:wrap;padding:0 4px}.w-outline-control .outline-content.outline-content-selected{cursor:default;font-weight:700}.outline-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;cursor:auto}"],
                },] },
    ];
    /** @nocollapse */
    OutlineControlComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: OutlineState, decorators: [{ type: Optional }, { type: Inject, args: [forwardRef(function () { return OutlineState; }),] }] },
        { type: OutlineControlComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return OutlineControlComponent; }),] }] },
        { type: OutlineForComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return OutlineForComponent; }),] }] }
    ]; };
    OutlineControlComponent.propDecorators = {
        title: [{ type: Input }],
        allowSelection: [{ type: Input }],
        action: [{ type: Output }]
    };
    return OutlineControlComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWOutlineForModule = /** @class */ (function () {
    function AWOutlineForModule() {
    }
    AWOutlineForModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        OutlineForComponent,
                        OutlineControlComponent,
                        InitNestingDirective
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        AWCoreComponentModule
                    ],
                    exports: [
                        OutlineForComponent,
                        OutlineControlComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWOutlineForModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Renders html text area component
 *
 * ### Example
 *
 * ```typescript
 *
 * \@Component({
 *          selector: 'myNote' ,
 *          template: '<aw-text-area [value]="inputValue" [autoResize]="autoResize" >
 *              </aw-text-area>'
 *      })
 *      export class MyNoteComponent
 *      {
 *          inputValue: string = 'Some really long text';
 *          autoResize: false;
 *      }
 *
 * ```
 *  Note: if you are using this outside of FormTable please provide your own FormGroup
 */
var /** @type {?} */ TEXTAREA_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return TextAreaComponent; }),
    multi: true
};
var TextAreaComponent = /** @class */ (function (_super) {
    __extends(TextAreaComponent, _super);
    function TextAreaComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         *
         * A value used to store and read user input
         *
         */
        _this.value = '';
        /**
         * Spefifies visible number of lines
         */
        _this.rows = 2;
        /**
         * Specifies visible width
         */
        _this.columns = 20;
        /**
         * when this option is TRUE and user starts typing it will maximize textarea's width and height
         */
        _this.autoResize = true;
        return _this;
    }
    /**
     * @return {?}
     */
    TextAreaComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        _super.prototype.registerFormControl.call(this, this.value);
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(function (val) {
            _this.value = val;
            _this.onModelChanged(_this.value);
        });
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    TextAreaComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value, { onlySelf: true });
        }
    };
    TextAreaComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-text-area',
                    template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\">\n\n\t<textarea\n        pInputTextarea\n        [attr.name]=\"name\"\n        class=\"w-text-area\"\n        [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        [class.disabled]=\"disabled\"\n        formControlName=\"{{name}}\"\n        [rows]=\"rows\"\n        [cols]=\"columns\"\n        [autoResize]=\"autoResize\"\n        [attr.placeholder]=\"placeHolder\"\n\n    ></textarea>\n\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                    styles: [""],
                    providers: [
                        TEXTAREA_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return TextAreaComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    TextAreaComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    TextAreaComponent.propDecorators = {
        value: [{ type: Input }],
        rows: [{ type: Input }],
        columns: [{ type: Input }],
        autoResize: [{ type: Input }]
    };
    return TextAreaComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWTextAreaModule = /** @class */ (function () {
    function AWTextAreaModule() {
    }
    AWTextAreaModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        TextAreaComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        InputTextareaModule,
                        AWStringFieldModule
                    ],
                    entryComponents: [
                        TextAreaComponent
                    ],
                    exports: [
                        TextAreaComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWTextAreaModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Page-Notification component that implements a notification system for the user regarding
 * the current object he's working on. Typical notification are:
 *      Success - saved.
 *      Warning - Sourcing request requires 3 suppliers.
 *      Error   - cannot connect to server, check internet connection.
 *
 *
 *
 * Usage 1:  As part of page wrapper.
 *
 * \@Component({
 *    selector: 'MyPage' ,
 *    template: `
 *       <aw-object-page-wrapper
 *                        [title]="MyPage"
 *                        [objectType]="MyType"
 *                        [notification]="pageNotification">
 *             page content
 *          `
 *       </aw-object-pager-wrapper>
 *    })
 *    export class MyPage
 *    {
 *
 *        pageNotification: PageNotification = new PageNotification("warn",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *    }
 *
 * Usage 2: directly into the page.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *      <
 *      aw-header></aw-header>
 *        Page Header
 *
 *        <ng-template [ngIf]="hasNotifications()">
 *          <div class="ui-g-12 u-nopadding">
 *            <aw-page-notification [notification]="notification"></aw-page-notification>
 *          </div>
 *        </ng-template>
 *
 *      <aw-footer></aw-footer>
 *    `
 *    })
 *    export class MyPage
 *    {
 *
 *        notification: PageNotification = new PageNotification("warning",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *    }
 *
 */
var PageNotificationComponent = /** @class */ (function (_super) {
    __extends(PageNotificationComponent, _super);
    function PageNotificationComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        return _this;
    }
    /**
     * @return {?}
     */
    PageNotificationComponent.prototype.notificationClass = /**
     * @return {?}
     */
    function () {
        return "notification-" + this.notification.type;
    };
    /**
     * @return {?}
     */
    PageNotificationComponent.prototype.notificationIcon = /**
     * @return {?}
     */
    function () {
        return "ariba-icon icon-" + this.notification.type;
    };
    PageNotificationComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-page-notification',
                    template: "<div class=\"page-notification\">\n    <div [class]=\"notificationClass()\">\n        <i [class]=\"notificationIcon()\"></i>\n        <span class=\"content\">\n              <span class=\"title\">{{notification.title}}</span>\n              <span class=\"description\">\n                    <ng-template *ngIf=\"notification.hasTemplate(); else description\"\n                                 [ngTemplateOutlet]=\"notification.contentTmpl\">\n                    </ng-template>\n                    <ng-template #description>{{notification.description}}</ng-template>\n              </span>\n      </span>\n    </div>\n</div>\n",
                    styles: [".page-notification{margin:0 0 5px}.notification-error,.notification-info,.notification-success,.notification-warning{padding:9px 8px}.notification-error i,.notification-info i,.notification-success i,.notification-warning i{font-size:24px;margin:10px}.notification-success i{color:#58b957}.notification-info i{color:#199de0}.notification-warning i{color:#f90}.notification-error i{color:#c00}.notification-success{background-color:#f1f9f1;border:1px solid rgba(88,185,87,.5)}.notification-info{background-color:#edf8fd;border:1px solid rgba(25,157,224,.5)}.notification-warning{background-color:#fff8dd;border:1px solid rgba(255,153,0,.5)}.notification-error{background-color:#ffebeb;border:1px solid rgba(204,0,0,.5)}.icon-error:before{content:\"\\EA9D\"}.icon-warning:before{content:\"\\EA9C\"}.content{vertical-align:super}.title{font-weight:700;margin-right:10px}"]
                },] },
    ];
    /** @nocollapse */
    PageNotificationComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    PageNotificationComponent.propDecorators = {
        notification: [{ type: Input }]
    };
    return PageNotificationComponent;
}(BaseComponent));
/**
 * Page Notification are messages for this page only. It displays in the center of the page
 * right under page title. Typical page notifications are 'save confirmation',
 * 'error during submit', warnings of field requirements, etc.
 */
var  /**
 * Page Notification are messages for this page only. It displays in the center of the page
 * right under page title. Typical page notifications are 'save confirmation',
 * 'error during submit', warnings of field requirements, etc.
 */
PageNotification = /** @class */ (function () {
    function PageNotification(type, title, description, contentTmpl) {
        this.type = type;
        this.title = title;
        this.description = description;
        this.contentTmpl = contentTmpl;
    }
    /**
     * @return {?}
     */
    PageNotification.prototype.hasTemplate = /**
     * @return {?}
     */
    function () {
        return isPresent(this.contentTmpl);
    };
    /**
     * @return {?}
     */
    PageNotification.prototype.toString = /**
     * @return {?}
     */
    function () {
        return this.type + ', title: ' + this.title + ', description:  ' + this.description;
    };
    return PageNotification;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWPageNotificationModule = /** @class */ (function () {
    function AWPageNotificationModule() {
    }
    AWPageNotificationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        PageNotificationComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    entryComponents: [
                        PageNotificationComponent
                    ],
                    exports: [
                        PageNotificationComponent
                    ],
                    providers: []
                },] },
    ];
    return AWPageNotificationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Represents an event triggered when a page has been initialized.
 *
 */
var  /**
 * Represents an event triggered when a page has been initialized.
 *
 */
PageInitialized = /** @class */ (function () {
    function PageInitialized(title) {
        this.title = title;
    }
    /**
     * @return {?}
     */
    PageInitialized.prototype.toString = /**
     * @return {?}
     */
    function () {
        return "PageInitializied(title: " + this.title + ")";
    };
    return PageInitialized;
}());
/**
 * Represents an event triggered when a page has been destroyed.
 *
 */
var  /**
 * Represents an event triggered when a page has been destroyed.
 *
 */
PageDestroyed = /** @class */ (function () {
    function PageDestroyed(title) {
        this.title = title;
    }
    /**
     * @return {?}
     */
    PageDestroyed.prototype.toString = /**
     * @return {?}
     */
    function () {
        return "PageDestroyed(title: " + this.title + ")";
    };
    return PageDestroyed;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Page LifeCycle Service monitors all page initialization and destructions.
 * The purpose of this service is to help the application monitor page lifecycle, subscribe
 * to lifecycle events and execute actions such as user analytics.
 *
 * Usage:
 *
 *    1.  Inject PageLifeCycleService into your constructor
 *
 *    constructor(pageLifecycle:PageLifeCycleService) {
 *        pageLifecycle.pageEvents.subscribe(event:Event => {
 *            if(event instanceof PageInitialized) {
 *            }
 *            // PageDestroyed
 *
 *        });
 *     }
 */
var PageLifeCycleService = /** @class */ (function () {
    /**
     *
     */
    function PageLifeCycleService() {
        /**
         * Page event queue when all page lifecycle events: init, destroy are emitted.
         * Listeners can subscribe to these events.
         */
        this.pageEvents = new Subject();
    }
    /**
     * Called when page is initialized.
     * @param {?} pageTitle
     * @return {?}
     */
    PageLifeCycleService.prototype.onPageInit = /**
     * Called when page is initialized.
     * @param {?} pageTitle
     * @return {?}
     */
    function (pageTitle) {
        this.pageEvents.next(new PageInitialized(pageTitle));
    };
    /**
     * Call when page has been destroyed
     * @param {?} pageTitle
     * @return {?}
     */
    PageLifeCycleService.prototype.onPageDestroy = /**
     * Call when page has been destroyed
     * @param {?} pageTitle
     * @return {?}
     */
    function (pageTitle) {
        this.pageEvents.next(new PageDestroyed(pageTitle));
    };
    PageLifeCycleService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    PageLifeCycleService.ctorParameters = function () { return []; };
    return PageLifeCycleService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var PageType = {
    Init: 0,
    // Init Page type
    Login: 1,
    // Login Page
    Object: 2,
    // Object detail page
    List: 3,
    // List Page
    MasterDetail: 4,
    // MasterDetail
    Dashboard: 5,
    // Dashboard page
    Modal: 6,
};
PageType[PageType.Init] = "Init";
PageType[PageType.Login] = "Login";
PageType[PageType.Object] = "Object";
PageType[PageType.List] = "List";
PageType[PageType.MasterDetail] = "MasterDetail";
PageType[PageType.Dashboard] = "Dashboard";
PageType[PageType.Modal] = "Modal";
/**
 *  Page wrapper is the base class for all pages. The idea is that there are different page types
 *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
 *  a object page will render one object in detail.
 *
 *  They share common attributes such as page type and page id.
 *
 *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
 *  destroyed, it'll be complete.
 * @abstract
 */
var  /**
 *  Page wrapper is the base class for all pages. The idea is that there are different page types
 *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
 *  a object page will render one object in detail.
 *
 *  They share common attributes such as page type and page id.
 *
 *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
 *  destroyed, it'll be complete.
 * @abstract
 */
PageWrapper = /** @class */ (function (_super) {
    __extends(PageWrapper, _super);
    function PageWrapper(env, pageType, componentRegistry, pageLifecycleService) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.componentRegistry = componentRegistry;
        _this.pageLifecycleService = pageLifecycleService;
        /**
         * What type of page this is.
         *
         */
        _this.pageType = PageType.Init;
        _this.pageType = pageType;
        return _this;
    }
    /**
     * Get the unique Id for this page.
     *
     * @return {?}
     */
    PageWrapper.prototype.getId = /**
     * Get the unique Id for this page.
     *
     * @return {?}
     */
    function () {
        if (this.id) {
            return this.id;
        }
        this.id = this.generatePageId();
    };
    return PageWrapper;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *  This is a temporary implementation for the page header component.
 *  When the real implementation of side menu is done, PageHeaderComponent will
 *  be swaped to use it.
 *
 */
var SidenavComponent = /** @class */ (function (_super) {
    __extends(SidenavComponent, _super);
    function SidenavComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        return _this;
    }
    /**
     * @return {?}
     */
    SidenavComponent.prototype.getSidenavClass = /**
     * @return {?}
     */
    function () {
        // Only show if I have items
        return (this.show && this.items) ? 'sidenav sidenav-active' : 'sidenav';
    };
    /**
     * @return {?}
     */
    SidenavComponent.prototype.open = /**
     * @return {?}
     */
    function () {
        this.show = true;
    };
    /**
     * @return {?}
     */
    SidenavComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.show = false;
    };
    /**
     * @return {?}
     */
    SidenavComponent.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.show = !this.show;
    };
    SidenavComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-sidenav',
                    template: "<div [ngClass]=\"getSidenavClass()\">\n    <div class=\"sidenav-content\">\n        <a *ngFor=\"let item of items\" [routerLink]=\"item.link\">\n            <span class=\"sidenav-icon\"><i [ngClass]=\"'sap-icon ' + item.icon\"></i></span>\n            {{item.label}}\n        </a>\n    </div>\n</div>\n",
                    styles: [".sidenav{height:100%;width:0;position:fixed;z-index:1;top:50px;left:0;background-color:#363636;overflow-x:hidden;padding-top:20px;transition:.5s}.sidenav-active{width:250px}.sidenav a{padding:8px 8px 8px 32px;text-decoration:none;font-size:16px;color:#fff;display:block;transition:.3s}.sidenav a:hover{background-color:#111}.sidenav-icon{font-size:30px;color:#ccc;margin-right:10px}"]
                },] },
    ];
    /** @nocollapse */
    SidenavComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    SidenavComponent.propDecorators = {
        items: [{ type: Input }],
        show: [{ type: Input }]
    };
    return SidenavComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Header component that implements consistent styling, behavior for an Ariba page.
 * Header includes a menu, user profile, and alerts.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *                <aw-page-header [showBackAction]="true" userName="Chad Noll"
 *                                 [menuItems]="menuItems" [notifications]="userNotifications">
 *                     <div class="page-header-center">
 *                           <a class="navbar-brand" tabindex="0" href="/">
 *                               <img class="navbar-logo" src="./images/SAP_Ariba_DB.png"
 *                                   alt="Go to homepage" data-pin-nopin="true">
 *                          </a>
 *                     </div>
 *                </aw-page-header>
 *
 *    `
 *    })
 *    export class MyPage
 *    {
 *      menuItems: PageMenuItem[] = [new PageMenuItem('icon-home', 'Home', '/play/'),
 *                                  new PageMenuItem('icon-expense-report', 'Reports',
 *                                                     '/play/pageheader'),
 *                                  new PageMenuItem('icon-sales-order', 'Purchase Order',
 *                                                       '/play/pageheader'),
 *                                  new PageMenuItem('icon-account', 'Accounts',
 *                                                     '/play/pageheader')];
 *
 *     userNotifications: UserNotification[] = [
 *       new UserNotification('icon-expense-report', 'Expense report EXP453 has been approved.',
 *                             '/play/'),
 *         new UserNotification('icon-sales-order', 'Sales Order SO1234 has been created.',
 *                             '/play/'),
 *           new UserNotification('icon-account', 'Supplier account SA1234 has been updated.',
 *                               '/play/')
 *        ];
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
var PageHeaderComponent = /** @class */ (function (_super) {
    __extends(PageHeaderComponent, _super);
    function PageHeaderComponent(element, env, routing) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        _this.routing = routing;
        /**
         * Should the user notification icon be hidden. Default it to show the icon even
         * if there's no notifications.
         *
         */
        _this.hideNotification = false;
        /**
         * displays the back link that navigates user to the previous page when clicked.
         */
        _this.showBackAction = false;
        _this.showNotificationPanel = false;
        return _this;
    }
    /**
     * @return {?}
     */
    PageHeaderComponent.prototype.backAction = /**
     * @return {?}
     */
    function () {
        this.routing.goBack();
    };
    /**
     * Do i have any menu items.
     *
     */
    /**
     * Do i have any menu items.
     *
     * @return {?}
     */
    PageHeaderComponent.prototype.hasMenuItems = /**
     * Do i have any menu items.
     *
     * @return {?}
     */
    function () {
        return (this.menuItems && this.menuItems.length > 0);
    };
    /**
     * Toggle the side navigation menu.
     */
    /**
     * Toggle the side navigation menu.
     * @return {?}
     */
    PageHeaderComponent.prototype.showHideMenu = /**
     * Toggle the side navigation menu.
     * @return {?}
     */
    function () {
        this.sidenav.toggle();
    };
    /**
     * Do I have any notifications.
     *
     */
    /**
     * Do I have any notifications.
     *
     * @return {?}
     */
    PageHeaderComponent.prototype.hasNotifications = /**
     * Do I have any notifications.
     *
     * @return {?}
     */
    function () {
        return isPresent(this.notifications) && this.notifications.length > 0;
    };
    /**
     * toggling wheather notification panel is displayed or not.
     */
    /**
     * toggling wheather notification panel is displayed or not.
     * @return {?}
     */
    PageHeaderComponent.prototype.toggleNotificationPanel = /**
     * toggling wheather notification panel is displayed or not.
     * @return {?}
     */
    function () {
        this.showNotificationPanel = !this.showNotificationPanel;
    };
    PageHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-page-header',
                    template: "<nav class=\"navbar page-header\" role=\"navigation\">\n\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-4 navbar-left\">\n\n        <span *ngIf=\"hasMenuItems()\">\n            <a (click)=\"showHideMenu()\">\n                <i class=\"sap-icon icon-paging\"></i>\n            </a>\n\n            <!-- Side menu -->\n            <aw-sidenav #sidemenu [items]=\"menuItems\"></aw-sidenav>\n        </span>\n            <!-- End Hamburger menu. -->\n\n            <!--  back action -->\n            <span class=\"back-action\">\n            <a (click)=\"backAction()\">\n                <i *ngIf=\"showBackAction\" class=\"sap-icon icon-arrow-left\" role=\"button\"></i>\n            </a>\n        </span>\n\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-center\">\n\n            <!-- central section.  Application can add Ariba-logo, search box, etc -->\n            <ng-content select=\".page-header-center\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-right\">\n        <span *ngIf=\"userName\">\n            <img id=\"userProfilePicture\" class=\"profile-logo\" aria-hidden=\"true\"\n                 [title]=\"userName\" src=\"{{assetFolder}}/images/default_image_small.png\">\n            <span class=\"profile-user\" title=\"{{userName}}\">{{userName}}</span>\n        </span>\n\n            <span *ngIf=\"!hideNotification\" class=\"notification-container\">\n\n            <i #notificationIcon class=\"ariba-icon icon-notification\"\n               (click)=\"toggleNotificationPanel()\"></i>\n            <span *ngIf=\"hasNotifications()\" class=\"notification-badge\" aria-hidden=\"true\">{{notifications.length}}</span>\n\n                <!-- Originally I was using p-overlay-panel, however, it doesn't position correctly under the notification icon.\n                     The positioning logic in prime ng needs some more investigation. So for now, use a div instead-->\n            <div *ngIf=\"showNotificationPanel\" class=\"notification-panel\">\n\n                <div class=\"notification-header\">\n                     Notifications\n                </div>\n\n                <ul class=\"notification-content\">\n                    <li *ngFor=\"let noti of notifications\" class=\"notification-item\">\n                        <a [routerLink]=\"noti.link\">\n                            <span class=\"notification-item-icon\"><i\n                                [ngClass]=\"'sap-icon ' + noti.icon\"></i></span>\n                            {{noti.label}}\n                        </a>\n                    </li>\n                </ul>\n            </div>\n        </span>\n        </div>\n\n\n    </div>\n</nav>\n",
                    styles: [".page-header i{font-size:32px}.page-header .icon-paging{font-size:30px;position:relative;top:2px}.back-action{display:inline-block;margin-left:15px}.back-action i{position:relative;top:3px}.navbar{background:#000;color:#fff}.navbar-left{padding-left:15px;height:50px}.navbar-center{text-align:center;height:50px}.navbar-right{text-align:right;height:50px}.profile-logo{width:30px;height:30px;position:relative;top:2px}.profile-user{vertical-align:super;margin-right:30px}.icon-notification:before{content:\"\\eA14\"}.navbar #sidebar-menu-icon{position:relative;top:.5em}.notification-container{position:relative;margin-right:20px;display:inline-block}.notification-badge{display:inline-block;padding:2px 5px;font-size:12px;font-weight:700;color:#fff;background-color:#c00;border-radius:10px;position:absolute;top:0;left:16px}.notification-panel{position:absolute;right:-27px;top:45px;width:350px;color:#767676;box-shadow:0 2px 10px 0 rgba(0,0,0,.13);background-color:#fff;overflow:hidden;transition:all .3s ease-in-out}.notification-panel .notification-header{background-color:#f3f3f3;font-size:16px;height:50px;line-height:50px;text-align:center}.notification-panel .notification-content{padding:0;margin:0}.notification-panel .notification-item{height:50px;border-top:1px solid #d7d7d7;padding:15px 10px;white-space:nowrap;text-overflow:ellipsis}.notification-panel .notification-item a{color:#767676;text-decoration:none;line-height:35px}.notification-panel .notification-item:hover{background-color:#f7f8fa}.notification-panel .notification-item-icon{margin-right:15px;color:#767676;display:inline-block;margin-top:10px;vertical-align:middle}"]
                },] },
    ];
    /** @nocollapse */
    PageHeaderComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment },
        { type: RoutingService }
    ]; };
    PageHeaderComponent.propDecorators = {
        menuItems: [{ type: Input }],
        notifications: [{ type: Input }],
        hideNotification: [{ type: Input }],
        showBackAction: [{ type: Input }],
        userName: [{ type: Input }],
        sidenav: [{ type: ViewChild, args: ['sidemenu',] }]
    };
    return PageHeaderComponent;
}(BaseComponent));
/**
 * PageMenuItem represents an item in the page menu structure.
 */
var  /**
 * PageMenuItem represents an item in the page menu structure.
 */
PageMenuItem = /** @class */ (function () {
    /**
     * @param icon    - Icon of this menu item.
     * @param label   - label of this item.
     * @param link    - link to the destination when user clicks on it.
     */
    function PageMenuItem(icon, label, link) {
        this.icon = icon;
        this.label = label;
        this.link = link;
    }
    /**
     * @return {?}
     */
    PageMenuItem.prototype.toString = /**
     * @return {?}
     */
    function () {
        return "PageMenuItem: (label, " + this.label + ")";
    };
    return PageMenuItem;
}());
/**
 * notification for the current logged in user.
 * Ex:  PR2049 has been approved.
 *      Order PO518 received.
 */
var  /**
 * notification for the current logged in user.
 * Ex:  PR2049 has been approved.
 *      Order PO518 received.
 */
UserNotification = /** @class */ (function () {
    /**
     * @param icon   - alert notification icon
     * @param label  - alert notification label
     * @param link   - link
     */
    function UserNotification(icon, label, link) {
        this.icon = icon;
        this.label = label;
        this.link = link;
    }
    /**
     * @return {?}
     */
    UserNotification.prototype.toString = /**
     * @return {?}
     */
    function () {
        return "PageUserNotification: (label, " + this.label + ")";
    };
    return UserNotification;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Footer component that implements consistent styling, behavior.
 * This footer component self contained.
 *
 * \@Component({
 *    selector: 'registration' ,
 *    template: `
 *
 *          <aw-page-footer>
 *               <div class="page-footer-logo">
 *                   <img src="images/ariba_logo_white_bkgd.png">
 *               </div>
 *               <div class="page-footer-user-info">
 *                   Chad Noll (cnoll) last visit {{last_visited | date:'MM/dd/yyyy h:mma' }}
 *                   | Buyer Organization
 *               </div>
 *               <span class="page-footer-copyright" #copyright>
 *                   <p>© 2020–2028 The Future, Inc. All rights reserved</p>
 *               </span>
 *           </aw-page-footer>
 *    `
 *    })
 *    export class MyPage
 *    {
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
var PageFooterComponent = /** @class */ (function (_super) {
    __extends(PageFooterComponent, _super);
    function PageFooterComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        /**
         * show default copyright. If copyright is passed in, then show the passed in one.
         */
        _this.showDefaultCopyright = true;
        return _this;
    }
    /**
     * @return {?}
     */
    PageFooterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    PageFooterComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.showDefaultCopyright = !isPresent(this.copyright);
    };
    PageFooterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-page-footer',
                    template: "<div class=\"page-footer\">\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-8\">\n\n            <ng-content select=\".page-footer-logo\"></ng-content>\n\n            <div class=\"user-info\">\n                <ng-content select=\".page-footer-user-info\"></ng-content>\n            </div>\n\n            <ul class=\"footer-links\">\n                <li role=\"presentation\"><a href=\"http://www.ariba.com/legal/ariba_tou.cfm\">Terms of\n                    Use</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_security_policy.cfm\">Security\n                    Disclosure</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_privacy_statement.cfm\">Privacy\n                    Statement</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Cookie Statement</a>\n                </li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Participant\n                    Statement</a></li>\n            </ul>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4\">\n            <div class=\"u-bottom-align\"></div>\n            <div class=\"u-hright copyright\">\n                <ng-content select=\".page-footer-copyright\"></ng-content>\n            </div>\n\n            <!-- Default Copyright -->\n            <div *ngIf=\"showDefaultCopyright\" class=\"u-hright copyright\">\n                <p>\u00A9 1996\u20132017 Ariba, Inc. All rights reserved</p>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                    styles: [".page-footer{background:#fff;padding:15px 0 0;font-size:11px;border-top:1px solid #d7d7d7}.page-footer .user-info{color:#ccc}.page-footer .ui-g{margin:0 auto}.page-footer .copyright{color:#ccc}.footer-links{list-style:none;margin:0 -15px;padding:0;font-size:10px}.footer-links li{float:left}.footer-links:after,.footer-links:before{content:\" \";display:table}.footer-links:after{clear:both}.footer-links>li,.footer-links>li>a{position:relative;display:block}.footer-links>li>a{padding:10px 15px;color:#199de0}"]
                },] },
    ];
    /** @nocollapse */
    PageFooterComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    PageFooterComponent.propDecorators = {
        copyright: [{ type: ContentChild, args: ['copyright',] }]
    };
    return PageFooterComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Object Page Wrapper Component renders any object instance in detail. It has a uniform layout,
 * Header, Page title, Page notification, actions, content, and Footer.
 *
 *
 *  Usage:
 *
 * \@Component({
 *    selector: 'RFXPage' ,
 *    template: `
 *       <aw-object-page-wrapper
 *                        [title]="rfxEntity.headerInfo.title"
 *                        [objectType]="rfxEntity.headerInfo.eventTypeString"
 *                        [notification]="pageNotification">
 *
 *
 *           <aw-page-actions>
 *               <aw-button [type]="'submit'" [name]="'edit'" [value]="edit" [style]="'primary'">
 *                   Edit
 *                </aw-button>
 *               <aw-button [type]="'button'" [name]="'cancel'" [value]="cancel"
 *                                                         [style]="'secondary'">
 *                  Cancel
 *               </aw-button>
 *           </aw-page-actions>
 *
 *           <aw-page-content>
 *             <aw-section title="Sourcing request info" (onStateChanged)="onStateChange($event)">
 *
 *                   <m-context [object]="rfxEntity.headerInfo"
 *                              [operation]="this.editabilityState.headerInfoOp"
 *                              layout="Inspect"
 *                              uiGroup="HeaderGeneral"
 *                   >
 *                       <m-include-component></m-include-component>
 *                   </m-context>
 *
 *             </aw-section>
 *           </aw-page-content>
 *       </aw-object-page-wrapper>
 *    `
 *    })
 *    export class RFXPage
 *    {
 *       // To keep track what section is editable and which read only
 *       editabilityState: EditabilityState;
 *
 *       // Current RFX event
 *       rfxEntity: RfxEventEntity;
 *
 *       // Notifications
 *       notification: PageNotification = new PageNotification("warn",
 *                              "Policy Warning", "This request requires 3 bids.");
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 */
var ObjectPageWrapperComponent = /** @class */ (function (_super) {
    __extends(ObjectPageWrapperComponent, _super);
    function ObjectPageWrapperComponent(element, env, componentRegistry, pageLifecycleService) {
        var _this = _super.call(this, env, PageType.Object, componentRegistry, pageLifecycleService) || this;
        _this.element = element;
        _this.env = env;
        /**
         * Set true if page should not include any header. Need to set to true even no header
         * object is passed in. Otherwise, a default Header component will be added.
         */
        _this.hideHeader = false;
        /**
         * Set true if page should not include any footer. Need to set to true even no footer
         * object is passed in. Otherwise, a default Footer component will be added.
         */
        _this.hideFooter = false;
        /**
         * The positioning of the page actions (page buttons)
         *   'top' :    page buttons are placed at the top of the page, below the title, to the right.
         *   'bottom' : page buttons are placed at the bottom of the page, above the footer.
         *   'both'   : page buttons are placed at both top and bottom.
         *
         */
        _this.pageActionPosition = 'top';
        /**
         * This flag is driven by pageActionPosition. The default position is top.
         * Value is true for both 'top' and 'both' of pageActionPosition.
         */
        _this.hasTopPageActions = true;
        _this.objectStateIndex = 0;
        // Setting Default header component
        // Setting Default header component
        _this.header = PageHeaderComponent;
        _this.footer = PageFooterComponent;
        return _this;
    }
    /**
     * Generate a unique Id for this object.
     *
     */
    /**
     * Generate a unique Id for this object.
     *
     * @return {?}
     */
    ObjectPageWrapperComponent.prototype.generatePageId = /**
     * Generate a unique Id for this object.
     *
     * @return {?}
     */
    function () {
        return this.objectType + '_' + this.title + (this.id) ? ('_' + this.id) : '';
    };
    /**
     * Does my page have page notification?
     *
     */
    /**
     * Does my page have page notification?
     *
     * @return {?}
     */
    ObjectPageWrapperComponent.prototype.hasNotifications = /**
     * Does my page have page notification?
     *
     * @return {?}
     */
    function () {
        return (this.notifications && this.notifications.length > 0);
    };
    /**
     * @return {?}
     */
    ObjectPageWrapperComponent.prototype.hasObjectStates = /**
     * @return {?}
     */
    function () {
        return isPresent(this.objectStates);
    };
    /**
     * Initialize my local components
     */
    /**
     * Initialize my local components
     * @return {?}
     */
    ObjectPageWrapperComponent.prototype.ngOnInit = /**
     * Initialize my local components
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        // New Component types that are used in c-include-component
        if (this.header) {
            this.componentRegistry.registerType(this.header.name, this.header);
        }
        // New Component types that are used in c-include-component
        if (this.footer) {
            this.componentRegistry.registerType(this.footer.name, this.footer);
        }
        /** notify subscribers of the page lifecycle service  */
        this.pageLifecycleService.onPageInit(this.title);
        // Setting the page action position.
        if (this.pageActionPosition === 'bottom') {
            this.hasTopPageActions = false;
            this.hasBottomPageActions = true;
        }
        else if (this.pageActionPosition === 'both') {
            this.hasTopPageActions = true;
            this.hasBottomPageActions = true;
        }
        if (isPresent(this.objectStates) && this.objectStates.length > 1
            && isPresent(this.currentState)) {
            this.objectStateIndex = this.objectStates.indexOf(this.currentState);
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ObjectPageWrapperComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (isPresent(changes['currentState']) &&
            changes['currentState'].currentValue !== changes['currentState'].previousValue) {
            // we dont need to check if objectStates exists
            this.objectStateIndex = this.objectStates.indexOf(this.currentState);
        }
    };
    /**
     * @return {?}
     */
    ObjectPageWrapperComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.pageLifecycleService.onPageDestroy(this.title);
    };
    ObjectPageWrapperComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-object-page-wrapper',
                    template: "<div class=\"page-wrapper\">\n    <ng-template [ngIf]=\"!hideHeader\">\n        <aw-include-component [name]='header.name'></aw-include-component>\n    </ng-template>\n\n    <div class=\"arc-object-detail\">\n\n        <div class=\"ui-g\">\n\n            <!-- page header -->\n            <div class=\"ui-g-12 page-title\">\n\n                <!-- page title -->\n                <div class=\"ui-g-8 ui-md-8 page-title-text\">{{title}}</div>\n\n                <div class=\"ui-g-4 ui-md-4 page-status\">\n                    <span class=\"object-status-label\">{{objectStatusLabel}} &nbsp;</span>\n                    <span class=\"object-status\">{{objectStatus}}</span>\n                </div>\n            </div>\n\n            <!-- page actions -->\n            <div class=\"ui-g-12 page-actions\" *ngIf=\"hasTopPageActions\">\n                <ng-template [embeddedItem]=\"actionsTemplate\"\n                             *ngIf=\"hasTopPageActions\"></ng-template>\n            </div>\n\n            <!-- object states  displays only if state exists. -->\n            <div class=\"ui-g-12 page-state\">\n                <div class=\"ui-g-3 page-state-left\" [class.content]=\"hasObjectStates()\">\n                    <ng-content select=\".page-state-left\"></ng-content>\n                </div>\n                <div class=\"ui-g-6 page-state-center\">\n                    <ng-container *ngIf=\"hasObjectStates()\">\n                        <aw-stepper [steps]=\"objectStates\"\n                                    [currentStep]=\"objectStateIndex\"></aw-stepper>\n                    </ng-container>\n                </div>\n                <div class=\"ui-g-3 page-state-right\">\n                    <ng-content select=\".page-state-right\"></ng-content>\n                </div>\n            </div>\n\n\n            <!-- Page Notification -->\n            <ng-template [ngIf]=\"hasNotifications()\">\n                <div class=\"ui-g-12 u-nopadding\">\n\n                    <aw-page-notification *ngFor=\"let notification of notifications\"\n                                          [notification]=\"notification\"></aw-page-notification>\n                </div>\n            </ng-template>\n\n            <!-- additional content -->\n            <ng-content select=\"aw-page-content\"></ng-content>\n\n        </div>\n\n    </div>\n\n    <!-- page actions -->\n    <div class=\"ui-g-12 page-actions-bottom\" *ngIf=\"hasBottomPageActions\">\n        <ng-template [embeddedItem]=\"actionsTemplate\"\n                     *ngIf=\"hasBottomPageActions\"></ng-template>\n\n    </div>\n\n    <div class=\"page-push\"></div>\n</div>\n\n<ng-template [ngIf]=\"!hideFooter\">\n    <aw-include-component [name]='footer.name'></aw-include-component>\n</ng-template>\n",
                    styles: [".page-wrapper{background-color:#f2f2f2;min-height:100%;margin-bottom:-100px}.arc-object-detail{padding:20px}.page-title-text{font-size:22px;color:#000;padding:14px 0}.page-title{padding:5px 0;border-bottom:1px solid #d7d7d7}.page-actions{padding:15px 0 5px}.page-actions-bottom{padding:0 20px}.page-state,.page-state-center,.page-state-left,.page-state-right{padding:0}.content::after{content:'\\x000a0';font-size:0}.page-title /deep/ .ui-button{min-width:100px}.page-status{text-align:right;padding:18px 0}.page-status .object-status-label{color:#767676}.page-status .object-status{font-weight:700;color:#038719}.page-push{height:100px}"]
                },] },
    ];
    /** @nocollapse */
    ObjectPageWrapperComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment },
        { type: ComponentRegistry },
        { type: PageLifeCycleService }
    ]; };
    ObjectPageWrapperComponent.propDecorators = {
        title: [{ type: Input }],
        objectType: [{ type: Input }],
        objectStatusLabel: [{ type: Input }],
        objectStatus: [{ type: Input }],
        objectStates: [{ type: Input }],
        currentState: [{ type: Input }],
        header: [{ type: Input }],
        hideHeader: [{ type: Input }],
        footer: [{ type: Input }],
        hideFooter: [{ type: Input }],
        pageActionPosition: [{ type: Input }],
        actionsTemplate: [{ type: ContentChild, args: ['pageActions',] }],
        notifications: [{ type: Input }]
    };
    return ObjectPageWrapperComponent;
}(PageWrapper));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Page actions is a wrapper for all page actions, buttons, links, menus that interacts it with the
 * page. The wrapper use the ability to position it as needed.
 */
var PageActionsComponent = /** @class */ (function (_super) {
    __extends(PageActionsComponent, _super);
    function PageActionsComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        return _this;
    }
    PageActionsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-page-actions',
                    template: "<div class=\"page-actions\">\n    <ng-content></ng-content>\n</div>\n",
                    styles: [".page-actions{text-align:right;padding-top:0;padding-right:0}"]
                },] },
    ];
    /** @nocollapse */
    PageActionsComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    return PageActionsComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Page content is a wrapper for page content.
 * Currently, it's pretty bare, but as we add more interactions on the page, like a side bar,
 * the page content area will likely get affected.
 */
var PageContentComponent = /** @class */ (function (_super) {
    __extends(PageContentComponent, _super);
    function PageContentComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        return _this;
    }
    PageContentComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-page-content',
                    template: '<ng-content></ng-content>',
                    styles: [':host {width: 100%; padding: 0 .5em;}']
                },] },
    ];
    /** @nocollapse */
    PageContentComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    return PageContentComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ STEPPER_COMPLETED_STEP_COLOR = '#58b957';
var /** @type {?} */ STEPPER_CURRENT_STEP_COLOR = '#0076CB';
var /** @type {?} */ STEPPER_REMAINING_STEP_COLOR = '#D7D7D7';
/**
 * Stepper component displays a list of steps for user to follow. It can be used as a checklist
 * to indicate completed, current and remaining items. It could be also be used to indicate
 * the state of an document, created, submitted, approved, etc...
 *
 *
 * Usage:
 *   1.   Use the component inside your template. provide a list of steps and the current step.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                <aw-stepper [steps]="steps" [currentStep]="currentStep"></aw-stepper>
 *
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     steps: string[] = ['Monitor', 'Add Supplier', 'Get Quote'];
 *                     currentStep: number = 1;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *       }
 *
 *   2.  Override the default colors.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                            <aw-stepper [steps]="steps" [stepColorCurrent]="'#ff9900'"
 *                                        [stepColorRemaining]="'#CC0000'"
 *                                        [stepColorCompleted]="'#97a822'"
 *                                        [currentStep]="currentStep">
 *                            </aw-stepper>
 *                  `
 */
var StepperComponent = /** @class */ (function (_super) {
    __extends(StepperComponent, _super);
    function StepperComponent(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * Local variable to indicate whether to use the colors array or not.
         */
        _this.bUseColorArray = false;
        /**
         * The current step that's on. If not provided default to the first step.
         */
        _this.currentStep = 0;
        // Initial color for the different stages of steps.
        // Initial color for the different stages of steps.
        _this.stepColorCompleted = STEPPER_COMPLETED_STEP_COLOR;
        _this.stepColorCurrent = STEPPER_CURRENT_STEP_COLOR;
        _this.stepColorRemaining = STEPPER_REMAINING_STEP_COLOR;
        return _this;
    }
    /**
     * @return {?}
     */
    StepperComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // Calculate the connector width based on how many steps
        if (isPresent(this.steps) && this.steps.length > 1) {
            // (100% - 20% (side margins)) / (NumOfSteps -1)
            this.connectorWidth = Math.ceil(80 / (this.steps.length - 1)) + '%';
        }
        /**
                 * Use the color array if it's defined.
                 */
        if (isPresent(this.colors)) {
            this.bUseColorArray = true;
            if (this.colors.length !== this.steps.length) {
                throw new Error("The size of the steps and colors don't match:\n                  (steps.length = " + this.steps.length + "), (colors.length = " + this.colors.length);
            }
        }
    };
    /**
     * Getting the color of the step for the current index
     *
     * @param index
     */
    /**
     * Getting the color of the step for the current index
     *
     * @param {?} index
     * @return {?}
     */
    StepperComponent.prototype.getStepColor = /**
     * Getting the color of the step for the current index
     *
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // Color Array overrides everything else.
        if (this.bUseColorArray) {
            return this.colors[index];
        }
        if (index < this.currentStep) {
            return this.stepColorCompleted;
        }
        else if (index === this.currentStep) {
            return this.stepColorCurrent;
        }
        else {
            return this.stepColorRemaining;
        }
    };
    /**
     * The connector colors are driven by the step colors.
     *
     */
    /**
     * The connector colors are driven by the step colors.
     *
     * @param {?} index
     * @return {?}
     */
    StepperComponent.prototype.getConnectorColor = /**
     * The connector colors are driven by the step colors.
     *
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // Color Array overrides everything else.
        if (this.bUseColorArray) {
            return this.colors[index];
        }
        if (index < this.currentStep) {
            return this.stepColorCompleted;
        }
        else {
            return this.stepColorRemaining;
        }
    };
    /**
     * Next step.
     */
    /**
     * Next step.
     * @return {?}
     */
    StepperComponent.prototype.nextStep = /**
     * Next step.
     * @return {?}
     */
    function () {
        this.currentStep++;
    };
    /**
     * previous step.
     */
    /**
     * previous step.
     * @return {?}
     */
    StepperComponent.prototype.prevStep = /**
     * previous step.
     * @return {?}
     */
    function () {
        this.currentStep--;
    };
    StepperComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-stepper',
                    template: "<div class=\"stepper-container\">\n    <div class=\"steps\">\n        <div class=\"step-spacing\"></div>\n\n        <ng-container *ngFor=\"let step of steps; let i=index; let last=last;\">\n            <div class=\"step\">\n                <aw-step [title]=\"step\" [color]=\"getStepColor(i)\"></aw-step>\n            </div>\n            <div *ngIf=\"!last\" class=\"step-connector\" [style.width]=\"connectorWidth\">\n                <div class=\"connector\" [style.borderBottomColor]=\"getConnectorColor(i)\"></div>\n            </div>\n        </ng-container>\n\n        <div class=\"step-spacing\"></div>\n    </div>\n\n    <div class=\"step-labels\"></div>\n</div>\n\n\n",
                    styles: [".stepper-container{display:table;table-layout:fixed;width:100%}.steps{display:table-row}.step-spacing{display:table-cell;width:10%}.step{display:table-cell;width:32px}.step-connector{display:table-cell;vertical-align:middle}.connector{height:1px;border-bottom:3px solid #58b957}.step-labels{display:table-row;height:50px}"]
                },] },
    ];
    /** @nocollapse */
    StepperComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    StepperComponent.propDecorators = {
        steps: [{ type: Input }],
        colors: [{ type: Input }],
        stepColorCompleted: [{ type: Input }],
        stepColorCurrent: [{ type: Input }],
        stepColorRemaining: [{ type: Input }],
        currentStep: [{ type: Input }]
    };
    return StepperComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Renders html step component
 *
 *  * Usage:
 *       Straight forward to use. But mostly it would be used as part of the stepper component.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                           <aw-step [title]="step" [color]="color"></aw-step>
 *                           `
 */
var /** @type {?} */ DEFAULT_COLOR = '#58b957';
var StepComponent = /** @class */ (function () {
    function StepComponent(env) {
        this.env = env;
    }
    /**
     * @return {?}
     */
    StepComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (isBlank(this.color)) {
            this.color = DEFAULT_COLOR;
        }
    };
    StepComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-step',
                    template: "<div class=\"step-container\">\n    <div class=\"outer-circle\" [style.borderColor]=\"color\">\n        <div class=\"inner-circle\" [style.borderColor]=\"color\" [style.backgroundColor]=\"color\"></div>\n    </div>\n\n    <div class=\"step-title\">{{title}}</div>\n</div>\n\n",
                    styles: [".step-container{position:relative;width:32px}.outer-circle{width:26px;height:26px;border-radius:50%;background-color:#fff;border:3px solid #58b957;position:relative}.inner-circle{width:8px;height:8px;border-radius:50%;border:2px solid #58b957;background-color:#58b957;margin:0 auto;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.step-title{position:absolute;width:150px;top:40px;left:-60px;text-align:center}"]
                },] },
    ];
    /** @nocollapse */
    StepComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    StepComponent.propDecorators = {
        color: [{ type: Input }],
        title: [{ type: Input }]
    };
    return StepComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWStepperModule = /** @class */ (function () {
    function AWStepperModule() {
    }
    AWStepperModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        StepComponent,
                        StepperComponent
                    ],
                    imports: [
                        CommonModule,
                        AWCoreComponentModule,
                    ],
                    entryComponents: [
                        StepComponent,
                        StepperComponent
                    ],
                    exports: [
                        StepComponent,
                        StepperComponent
                    ],
                    providers: []
                },] },
    ];
    return AWStepperModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWPageWrapperModule = /** @class */ (function () {
    function AWPageWrapperModule() {
    }
    AWPageWrapperModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ObjectPageWrapperComponent,
                        PageActionsComponent,
                        PageContentComponent,
                        PageFooterComponent,
                        PageHeaderComponent,
                        SidenavComponent
                    ],
                    imports: [
                        CommonModule,
                        RouterModule,
                        AWCoreComponentModule,
                        AWStepperModule,
                        AWPageNotificationModule
                    ],
                    entryComponents: [
                        PageFooterComponent,
                        PageActionsComponent,
                        PageContentComponent,
                        PageHeaderComponent
                    ],
                    exports: [
                        ObjectPageWrapperComponent,
                        PageActionsComponent,
                        PageContentComponent,
                        PageFooterComponent,
                        PageHeaderComponent,
                        SidenavComponent
                    ],
                    providers: [PageLifeCycleService]
                },] },
    ];
    return AWPageWrapperModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var EditorType = {
    Default: 0,
    // Default Editor supports Minimal set of functionality
    // [ bold | italic | underline | ordered | bullet | alignment]
    Full: 1,
    // The full list of functionality,
    TextFormat: 2,
    // Functionalities that affects text formatting.
    Custom: 3,
};
EditorType[EditorType.Default] = "Default";
EditorType[EditorType.Full] = "Full";
EditorType[EditorType.TextFormat] = "TextFormat";
EditorType[EditorType.Custom] = "Custom";
var /** @type {?} */ EDITOR_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return RichTextAreaComponent; }),
    multi: true
};
var RichTextAreaComponent = /** @class */ (function (_super) {
    __extends(RichTextAreaComponent, _super);
    function RichTextAreaComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         * A value used to save and read when rendering and updating this component
         */
        _this.value = '';
        /**
         * Expose editorType so that it can be used in this components template.
         */
        _this.EditorType = EditorType;
        _this.type = EditorType.Default;
        _this.styleClass = 'default-editor';
        return _this;
    }
    /**
     * @return {?}
     */
    RichTextAreaComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        _super.prototype.registerFormControl.call(this, this.value);
        this.formControl.valueChanges.pipe(distinctUntilChanged()).subscribe(function (val) {
            _this.value = val;
            _this.onModelChanged(_this.value);
        });
    };
    /**
     * Internal. Please see ControlValueAccessor
     */
    /**
     * Internal. Please see ControlValueAccessor
     * @param {?} value
     * @return {?}
     */
    RichTextAreaComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.value) {
            this.value = value;
            this.formControl.setValue(value);
        }
    };
    RichTextAreaComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-richtextarea',
                    template: "<ng-template [ngIf]=\"editable\">\n\n    <!-- Basic editor, also the default, which the most used features enabled. -->\n    <div *ngIf=\"type === EditorType.Default\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                    <span class=\"ql-formats\">\n                        <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                        <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                        <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                        <button class=\"ql-list\" value=\"ordered\"></button>\n                        <button class=\"ql-list\" value=\"bullet\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                            <button value=\"left\" selected></button>\n                            <button value=\"center\"></button>\n                            <button value=\"right\"></button>\n                            <button value=\"justify\"></button>\n                    </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Editor with all the features enabled -->\n    <div *ngIf=\"type === EditorType.Full\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\"></p-editor>\n    </div>\n\n    <!-- Editor with all Text formatting  -->\n    <div *ngIf=\"type === EditorType.TextFormat\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n            <span class=\"ql-format-group\">\n              <select title=\"Font\" class=\"ql-font\">\n                <option value=\"sans-serif\" selected=\"\">Sans Serif</option>\n                <option value=\"serif\">Serif</option>\n                <option value=\"monospace\">Monospace</option>\n              </select>\n              <select title=\"Size\" class=\"ql-size\">\n                <option value=\"10px\">Small</option>\n                <option value=\"13px\" selected=\"\">Normal</option>\n                <option value=\"18px\">Large</option>\n                <option value=\"32px\">Huge</option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                    <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                    <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                </span>\n                <span class=\"ql-format-group\">\n              <select title=\"Text Color\" class=\"ql-color\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\" selected=\"\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n              <span class=\"ql-format-separator\"></span>\n              <select title=\"Background Color\" class=\"ql-background\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\" selected=\"\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                <button class=\"ql-list\" value=\"ordered\"></button>\n                <button class=\"ql-list\" value=\"bullet\"></button>\n            </span>\n                <span class=\"ql-formats\">\n                    <button value=\"left\" selected></button>\n                    <button value=\"center\"></button>\n                    <button value=\"right\"></button>\n                    <button value=\"justify\"></button>\n            </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Custom header Text Editor -->\n    <div *ngIf=\"type === EditorType.Custom\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                <ng-content select=\"custom-header\"></ng-content>\n            </p-header>\n        </p-editor>\n    </div>\n\n</ng-template>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                    styles: ["/deep/ .ui-editor-toolbar{background-color:#f5f5f5;border:1px solid #d7d7d7}/deep/ p-editor:active /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow{border-color:#199de0}/deep/ p-editor:active /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-content.ql-container.ql-snow{border-color:#199de0}"],
                    providers: [
                        EDITOR_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return RichTextAreaComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    RichTextAreaComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return FormRowComponent; }),] }] }
    ]; };
    RichTextAreaComponent.propDecorators = {
        type: [{ type: Input }],
        value: [{ type: Input }]
    };
    return RichTextAreaComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWRichTextAreaModule = /** @class */ (function () {
    function AWRichTextAreaModule() {
    }
    AWRichTextAreaModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        RichTextAreaComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        EditorModule,
                        AWStringFieldModule
                    ],
                    entryComponents: [
                        RichTextAreaComponent
                    ],
                    exports: [
                        RichTextAreaComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWRichTextAreaModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Allow developer to override default actions. Must have this declared before class when we
 * want to have this declaration inside the same file.
 */
var SectionActionsComponent = /** @class */ (function () {
    function SectionActionsComponent() {
    }
    SectionActionsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-section-actions',
                    template: "<ng-content></ng-content> ",
                },] },
    ];
    return SectionActionsComponent;
}());
/**
 *
 * Section component that implements a section of the page. It's an outline box that
 * has the ability to expand and hide its content.
 *
 * ```ts
 * \@Component({
 *    selector: 'rfx-details' ,
 *    template: `
 *         <aw-section title="Sourcing request info" (onEdit)="onStateChange($event)"
 *                          [editable]="true">
 *
 *                <m-context [object]="rfxEntity.headerInfo"
 *                          [operation]="this.editabilityState.headerInfoOp"
 *                          layout="Inspect"
 *                          uiGroup="HeaderGeneral">
 *                   <m-include-component></m-include-component>
 *               </m-context>
 *           </aw-section>
 *
 *
 *           <aw-section #supplierSection title="Selected suppliers" (onOpen)="onOpen()"
 *                [opened]="false">
 *               <supplier-profile-card></supplier-profile-card>
 *           </aw-section>
 *
 *           <aw-section title="RFQ Details"
 *                       description="Review and update information for suppliers to respond."
 *                       [disableClose]="true">
 *
 *               <aw-subsection title="Event timeline">
 *                   <aw-form-table [useFiveZone]="false" [editable]="true">
 *
 *                       <aw-form-row [label]="'Start Date'" [name]="'startDate'" [size]="'small'"
 *                                   [highlightRow]="true">
 *                           <aw-date-time
 *                               formatName="dateTime"
 *                               name="startDate" [value]="rfxEntity.created"
 *                               [showTime]="true"></aw-date-time>
 *                       </aw-form-row>
 *                   </aw-form-table>
 *               </aw-subsection>
 *          </aw-section>
 *    `
 *    })
 *    export class MyPage
 *    {
 *
 *        constructor ()
 *        {
 *        }
 *
 *    }
 *
 * ```
 *
 * Section component also supports editability modes and if enabled it will render action buttons
 * in the footer. Developer can also override default behavior and provide custom actions.
 *
 *
 * e.g:
 *
 * ```
 *      <aw-section [title]="title" [editable]="true"
 *                          (onCancelAction)="someHandler1($event)"
 *                          (onSaveAction)="someHandler2($event)" >
 *              section content
 *
 *
 *   </aw-section>
 *
 * ```
 *
 * or custom action buttons:
 *
 *
 * ```html
 *
 *       <aw-section-actions>
 *                      <aw-button >
 *                            ButtonTest1
 *                      </aw-button>
 *                      <aw-button>
 *                            ButtonTest2
 *                      </aw-button>
 *     </aw-section-actions>
 *
 * ```
 *
 *
 * There are two edit modes
 *  # Default
 *      Renders action buttons in the footers and emit actions to the application
 *
 *  # External
 *     No action buttons are shown in the footer and behavior is handled by application. Only event
 *     is emited.
 *
 *
 *  e.g:
 *
 *  ```ts
 *
 *      <aw-section title="User Information" (onEdit)="onAddSomething($event)"
 *                  [editable]="true" [editMode]="'external'" >
 *                  <div>
 *                      Content
 *                  </div>
 *      </aw-section>
 *
 *  ```
 *
 * Note: When using editing mode you have to call at the end of the editing cycle method
 * `completeEditing()` to commit editing which changes internal state of the Section.
 *
 *
 *
 */
var SectionComponent = /** @class */ (function (_super) {
    __extends(SectionComponent, _super);
    function SectionComponent(element, env) {
        var _this = _super.call(this, env) || this;
        _this.element = element;
        _this.env = env;
        /**
         * Should this section be opened at the start. Default is opened.
         */
        _this.opened = true;
        /**
         * Whether this section can be closed or not.
         *
         */
        _this.disableClose = false;
        /**
         * Whether this section is in EditState or not.
         *
         * When in editing state and we show "Cancel / Save" button developer needs use this binding
         * to control the state.
         */
        _this.editState = false;
        /**
         * Current Editing mode. Tells the components if its its default behavior or driven by
         * application using this component.
         *
         * {\@see EditMode}
         *
         */
        _this.editMode = 'default';
        /**
         * Developer can provide custom Edit action icon that will appear in the right top corner
         */
        _this.actionIcon = 'icon-edit';
        /**
         * Event emitted when the section is fully opened.
         */
        _this.onOpen = new EventEmitter();
        /**
         * Event emitted when the section is fully closed.
         */
        _this.onClose = new EventEmitter();
        /**
         * Edit state to broadcast state of current section
         */
        _this.onEdit = new EventEmitter();
        /**
         * When in editing state and default buttons are rendered on click broadcast Cancel action
         */
        _this.onCancelAction = new EventEmitter();
        /**
         * When in editing state and default buttons are rendered on click broadcast Save action
         */
        _this.onSaveAction = new EventEmitter();
        _this.onEditingComplete = new EventEmitter();
        _this.editable = false;
        return _this;
    }
    /**
     * @return {?}
     */
    SectionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        // If I have not header, then I can't close the section.
        if (!this.isHeaderDisplayed()) {
            this.disableClose = true;
        }
        // If I can't close the section, then it should default open.
        if (this.disableClose) {
            this.opened = true;
        }
        // initialize the expanded state.
        this.expanded = this.opened;
    };
    /**
     * Don't display header area if I don't have title and description.
     *
     * @return {?}
     */
    SectionComponent.prototype.isHeaderDisplayed = /**
     * Don't display header area if I don't have title and description.
     *
     * @return {?}
     */
    function () {
        return (isPresent(this.title) || isPresent(this.description));
    };
    /**
     * Css Class that control the look and feel for section component.
     */
    /**
     * Css Class that control the look and feel for section component.
     * @return {?}
     */
    SectionComponent.prototype.aClass = /**
     * Css Class that control the look and feel for section component.
     * @return {?}
     */
    function () {
        if (!this.isHeaderDisplayed()) {
            return 'section-no-header';
        }
        return '';
    };
    /**
     * Since we introduced buttons and editState the decision on when to exit editing mode
     * should be on the developer using this component therefore only startEditing
     *
     */
    /**
     * Since we introduced buttons and editState the decision on when to exit editing mode
     * should be on the developer using this component therefore only startEditing
     *
     * @param {?} $event
     * @return {?}
     */
    SectionComponent.prototype.onEditAction = /**
     * Since we introduced buttons and editState the decision on when to exit editing mode
     * should be on the developer using this component therefore only startEditing
     *
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        // when in editing make sure we dont switch state as there can be some Form errors
        // which needs to be handled by developer and only then change the editState
        if (!this.editState) {
            this.editState = !this.editState;
            var /** @type {?} */ state$$1 = (this.editState) ? 'inEdit' : 'notInEdit';
            this.onEdit.emit(state$$1);
            this.open();
        }
        // prevent the original event from bubbling up. Because the edit icon is inside
        // the header. If the click even is bubbled up, this event will cause the section to
        // expand or collapse.
        if (isPresent($event.event)) {
            $event.event.stopPropagation();
            $event.event.preventDefault();
        }
    };
    /**
     * @return {?}
     */
    SectionComponent.prototype.hasDescription = /**
     * @return {?}
     */
    function () {
        return isPresent(this.description);
    };
    /**
     * Open this section, if it's already open, will do nothing.
     */
    /**
     * Open this section, if it's already open, will do nothing.
     * @param {?=} event
     * @return {?}
     */
    SectionComponent.prototype.open = /**
     * Open this section, if it's already open, will do nothing.
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        if (!this.expanded) {
            this.accordionTab.toggle(event);
        }
    };
    /**
     * Close this section, if it's already close, will do nothing.
     */
    /**
     * Close this section, if it's already close, will do nothing.
     * @param {?} event
     * @return {?}
     */
    SectionComponent.prototype.close = /**
     * Close this section, if it's already close, will do nothing.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.expanded) {
            this.accordionTab.toggle(event);
        }
    };
    /**
     * Callback to be invoked when accordion is opened
     *
     */
    /**
     * Callback to be invoked when accordion is opened
     *
     * @param {?} event
     * @return {?}
     */
    SectionComponent.prototype.onSectionOpen = /**
     * Callback to be invoked when accordion is opened
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.expanded = true;
        this.onOpen.emit('open');
    };
    /**
     * Callback to be invoked when accordion is closed
     *
     */
    /**
     * Callback to be invoked when accordion is closed
     *
     * @param {?} event
     * @return {?}
     */
    SectionComponent.prototype.onSectionClose = /**
     * Callback to be invoked when accordion is closed
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.expanded = false;
        this.onClose.emit('close');
    };
    /**
     *
     * Tells us if we need to render application defined custom actions
     *
     */
    /**
     *
     * Tells us if we need to render application defined custom actions
     *
     * @return {?}
     */
    SectionComponent.prototype.hasCustomActions = /**
     *
     * Tells us if we need to render application defined custom actions
     *
     * @return {?}
     */
    function () {
        return isPresent(this.customActions);
    };
    /**
     * Emit the editing state back to non-editable
     */
    /**
     * Emit the editing state back to non-editable
     * @return {?}
     */
    SectionComponent.prototype.completeEditing = /**
     * Emit the editing state back to non-editable
     * @return {?}
     */
    function () {
        this.editState = false;
        this.onEditingComplete.emit(this.editState);
    };
    SectionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-section',
                    template: "<div class=\"ui-g-12 section-container\"\n     [class.editing]=\"editable && editState && editMode === 'default'\">\n\n    <p-accordion (onOpen)=\"onSectionOpen($event)\" (onClose)=\"onSectionClose($event)\"\n                 [styleClass]=\"aClass()\">\n        <p-accordionTab #accordionTab [selected]=\"opened\" [disabled]=\"disableClose\">\n            <p-header>\n                <!-- title and description -->\n                <div class=\"section-header-container\">\n                    <div class=\"section-title\">{{title}}</div>\n                    <div *ngIf=\"hasDescription()\" class=\"section-description\">{{description}}</div>\n\n                    <!-- actions: Hide when in editing and editMode is default -->\n                    <div *ngIf=\"(editable && !editState && editMode === 'default') ||\n                        (editable && editMode === 'external')\"\n                         class=\"section-actions\">\n                        <aw-hyperlink (action)=\"onEditAction($event)\">\n                            <i class=\"sap-icon section-edit-action\" [ngClass]=\"actionIcon\"></i>\n                        </aw-hyperlink>\n                    </div>\n                </div>\n            </p-header>\n\n            <ng-content></ng-content>\n        </p-accordionTab>\n    </p-accordion>\n    <!--\n        need to put it outside of p-accordion otherwise button will inherit different\n        color scheme\n    -->\n    <div class=\"section-footer-container\" *ngIf=\"editable && editState &&\n            editMode === 'default'\">\n        <div class=\"footer-actions\">\n\n            <ng-template [ngIf]=\"!hasCustomActions()\">\n                <aw-button [style]=\"'secondary'\" size=\"small\"\n                           (action)=\"onCancelAction.emit($event)\">\n                    Cancel\n                </aw-button>\n                <aw-button size=\"small\" (action)=\"onSaveAction.emit($event)\">\n                    Save\n                </aw-button>\n            </ng-template>\n\n            <ng-content select=\"aw-section-actions\"></ng-content>\n        </div>\n    </div>\n</div>\n",
                    styles: [".section-header-container{position:relative}.section-container{margin:10px 0;background-color:#fff;padding:.2em .5em;border:2px dashed transparent}.section-container.editing{border-color:#199de0}.section-container ::ng-deep .ui-accordion-header>a{display:flex}.section-container ::ng-deep .ui-accordion-header>a .ui-accordion-toggle-icon{flex:0 0 30px;padding-top:2px}.section-container ::ng-deep .ui-accordion-header>a p-header{flex:1 0}.section-container /deep/ .ui-accordion-header.ui-state-disabled{opacity:1}.section-title{font-size:1.1em}.section-description{font-size:.9em;padding:.6em 0 .2em}.section-footer-container{margin:1em 2em 0;padding:.8em 0 1.5em .8em;border-top:1px solid #d7d7d7}.section-footer-container .footer-actions{display:inline-block;text-align:right;width:100%}.section-actions{position:absolute;top:0;right:0;z-index:1}.section-actions /deep/ a.link,.section-actions /deep/ a.link:hover{padding:0;text-decoration:none}.section-edit-action{font-size:1.5em;position:relative;padding:.1em 0 .1em .5em;cursor:pointer}.section-edit-action.icon-edit{font-size:1.4em}.section-container /deep/ .ui-accordion-header{color:#363636;border:none;background:#fff!important;padding:0 1em}.section-container /deep/ .ui-accordion-content{border:none;padding:1em 2em}.section-container /deep/ .ui-accordion-header /deep/ a[role=tab]{padding:.75em 0;text-decoration:none}.section-container /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:1px solid #d7d7d7;color:#363636}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header{height:1px}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:none}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header .section-edit-action{cursor:pointer!important}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down,:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right{font-family:\"SAP icon fonts\";font-size:1.1em;top:.8em;left:.1em;color:#767676;margin-top:0}:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .fa,:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .pi{display:none}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right:before{content:\"\\e1ed\"}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down:before{content:\"\\e1ef\"}"]
                },] },
    ];
    /** @nocollapse */
    SectionComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment }
    ]; };
    SectionComponent.propDecorators = {
        title: [{ type: Input }],
        description: [{ type: Input }],
        opened: [{ type: Input }],
        disableClose: [{ type: Input }],
        editState: [{ type: Input }],
        editMode: [{ type: Input }],
        actionIcon: [{ type: Input }],
        onOpen: [{ type: Output }],
        onClose: [{ type: Output }],
        onEdit: [{ type: Output }],
        onCancelAction: [{ type: Output }],
        onSaveAction: [{ type: Output }],
        onEditingComplete: [{ type: Output }],
        accordionTab: [{ type: ViewChild, args: ['accordionTab',] }],
        customActions: [{ type: ContentChild, args: [SectionActionsComponent,] }]
    };
    return SectionComponent;
}(BaseComponent));
var SubSectionComponent = /** @class */ (function () {
    function SubSectionComponent() {
    }
    SubSectionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-subsection',
                    template: "\n                    <h4 class=\"subsection-title\">{{title}}</h4>\n                    <ng-content></ng-content>\n                 ",
                    styles: ['.subsection-title {color: #363636; }']
                },] },
    ];
    SubSectionComponent.propDecorators = {
        title: [{ type: Input }]
    };
    return SubSectionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWSectionModule = /** @class */ (function () {
    function AWSectionModule() {
    }
    AWSectionModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        SectionComponent,
                        SubSectionComponent,
                        SectionActionsComponent
                    ],
                    imports: [
                        CommonModule,
                        AccordionModule,
                        AribaCoreModule,
                        AWStringFieldModule,
                        AWHyperlinkModule,
                        AWButtonModule,
                        SharedModule
                    ],
                    entryComponents: [
                        SectionComponent,
                        SubSectionComponent,
                        SectionActionsComponent
                    ],
                    exports: [
                        SectionComponent,
                        SectionActionsComponent,
                        SubSectionComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWSectionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DTColumn represent single column including header and its body. Each column has its own
 * rendererTemplate which a entry to this component.
 *
 * Keeping this separate from the datatable where DT is not really aware what it is rendering,
 * it allows us more flexibility in terms of different type of column inheriting from this
 * one.. Such as:
 *  DTRowDetail  column
 *  DTSingleSelection column
 *  DTMultiSelection column
 *
 * This way we don't do IF/THEN/ELSE inside the datatable and trying to create different cases.
 *
 *  Then later on this will let us create additional logic for the pivotal layout. Because DT
 *  does know anything about the type of the column so whatever is added to the DT.columns it
 *  will be rendered.
 *
 *
 *  Columns can be also frozen meaning if the content overflows they dont scroll. To make the
 *  column frozen we need to use [frozen] binding and se it to TRUE plus it requires a [width]
 *  binding to be set (in px).
 *  We need this to be able to properly position the second table which is changed to absolute
 *  positioning.
 *
 *
 *
 */
var DTColumn2Component = /** @class */ (function (_super) {
    __extends(DTColumn2Component, _super);
    function DTColumn2Component(env, domHandler) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.domHandler = domHandler;
        /**
         *
         * Cell alignment. It inserts regular align attribute to the table cell
         *
         */
        _this.align = 'left';
        /**
         *
         * If false applies dt-is-hidden style that hides the column
         *
         */
        _this.isVisible = true;
        /**
         * Sorting direction
         *
         */
        _this.sortOrdering = 'descending';
        /**
         * Tells the template if whether to render a label
         *
         */
        _this.showColumnLabel = true;
        /**
         *
         * See AWDataTable
         *
         */
        _this.showSubHeader = false;
        /**
         *
         * Used together with cell selectionMode to tell which column is selectable
         *
         */
        _this.selectable = false;
        /**
         * Use globally defined HEADER template for current column
         *
         */
        _this.useGlobalHeader = true;
        /**
         * Use globally defined SubHeader template for current column
         *
         */
        _this.useGlobalSubHeader = true;
        /**
         * Use globally defined body template
         *
         */
        _this.useGlobalBody = true;
        /**
         * Tells if the column is data column  - if it is rendering data or just a label or some
         * control
         *
         * This is important when calculating a column span and we need to know which columns are or
         * will be just for selection controls and which holds data
         */
        _this.isDataColumn = true;
        /**
         * Identifies column that will not scroll horizontally with other columns. Column is
         * frozen.
         *
         * For such columns that are marked as frozen binding [width] is required.
         *
         */
        _this.frozen = false;
        _this.maxWidthPx = 0;
        _this.minWidthPx = 0;
        _this.widthPx = 0;
        _this.widestCell = 0;
        return _this;
    }
    /**
     * @return {?}
     */
    DTColumn2Component.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
        if (isBlank(this.bodyTemplate) && this.useGlobalBody) {
            this.bodyTemplate = this.dt.bodyTemplate;
        }
        if (isBlank(this.headerTemplate) && this.useGlobalHeader) {
            this.headerTemplate = this.dt.headerTemplate;
        }
        if (isBlank(this.subHeaderTemplate) && this.useGlobalSubHeader) {
            this.subHeaderTemplate = this.dt.subHeaderTemplate;
        }
        if (isBlank(this.bodyClassFn)) {
            this.bodyClassFn = this.dt.bodyClassFn;
        }
        if (isBlank(this.key) && isBlank(this.label)) {
            throw new Error('Missing required binding: ' +
                '[key] or [label] bindings must be used at minimum');
        }
        // To be able to position second DT we require [width] to be set as well
        if (this.frozen && isBlank(this.width)) {
            throw new Error('Missing required binding [width]: ' +
                'when [frozen]=true then [width] binding needs to be specified.');
        }
    };
    /**
     * @return {?}
     */
    DTColumn2Component.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    DTColumn2Component.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // need to deffer this and trigger change detection otherwise I get
        // value was changed after it was checked error
        setTimeout(function () {
            _this.maxWidthPx = _this.widthToPx(_this.maxWidth);
            _this.minWidthPx = _this.widthToPx(_this.minWidth);
            _this.widthPx = _this.widthToPx(_this.width);
        });
    };
    /**
     *
     * When cell selectionMode is enabled this method is triggered when we click on header.
     * It delegates the call to the DT where it toggles currently selected value
     *
     */
    /**
     *
     * When cell selectionMode is enabled this method is triggered when we click on header.
     * It delegates the call to the DT where it toggles currently selected value
     *
     * @param {?} event
     * @param {?} element
     * @return {?}
     */
    DTColumn2Component.prototype.handleHeaderClick = /**
     *
     * When cell selectionMode is enabled this method is triggered when we click on header.
     * It delegates the call to the DT where it toggles currently selected value
     *
     * @param {?} event
     * @param {?} element
     * @return {?}
     */
    function (event, element) {
        if (this.isHeaderSelectable()) {
            this.dt.onHeaderSelectionChange(element, this);
        }
        else if (this.sortable) {
            this.sort(event);
        }
        event.preventDefault();
    };
    /**
     *
     * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
     *
     */
    /**
     *
     * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
     *
     * @param {?} event
     * @return {?}
     */
    DTColumn2Component.prototype.sort = /**
     *
     * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.sortable) {
            return;
        }
        var /** @type {?} */ targetNode = event.target;
        if (this.domHandler.hasClass(targetNode, 'dt-u-sortable') ||
            this.domHandler.hasClass(targetNode, 'dt-col-title') ||
            this.domHandler.hasClass(targetNode, 'dt-col-sortable-icon')) {
            if (isPresent(this.dt.sortColumn) && this.dt.sortColumn.key === this.key) {
                this.sortOrder = this.sortOrder * -1;
                this.sortOrdering = this.dt.sortOrderingForNumber(this.sortOrder);
            }
            else {
                this.dt.sortColumn = this;
            }
            this.dt.dataSource.state.sortKey = this.key;
            this.dt.dataSource.state.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
            this.dt.sortSingle();
        }
        this.dt.updateDataToRender();
    };
    /**
     * Calculated style class based on data
     *
     *
     */
    /**
     * Calculated style class based on data
     *
     *
     * @param {?} item
     * @return {?}
     */
    DTColumn2Component.prototype.dynamicBodyClass = /**
     * Calculated style class based on data
     *
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ dynClass = isPresent(this.bodyClassFn)
            ? this.bodyClassFn.apply(this.dt.context, [this, item]) : '';
        if (isPresent(this.bodyStyleClass)) {
            dynClass += ' ' + this.bodyStyleClass;
        }
        else if (isPresent(this.styleClass)) {
            dynClass += ' ' + this.styleClass;
        }
        return dynClass;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    DTColumn2Component.prototype.isRowSelectable = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isPresent(this.dt.isRowSelectable)) {
            return this.dt.isRowSelectable(item);
        }
        return false;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    DTColumn2Component.prototype.isCellSelectable = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.dt.selectionMode === 'cell' && this.isRowSelectable(item) && this.selectable;
    };
    /**
     * @return {?}
     */
    DTColumn2Component.prototype.isHeaderSelectable = /**
     * @return {?}
     */
    function () {
        return this.dt.selectionMode === 'cell' && this.selectable;
    };
    /**
     * @return {?}
     */
    DTColumn2Component.prototype.getSortOrder = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ order = 0;
        if (isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key) {
            order = this.dt.sortColumn.sortOrder;
        }
        return order;
    };
    /**
     * @return {?}
     */
    DTColumn2Component.prototype.isSorted = /**
     * @return {?}
     */
    function () {
        if (!this.sortable) {
            return false;
        }
        return isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key;
    };
    /**
     * @param {?} table
     * @return {?}
     */
    DTColumn2Component.prototype.initialize = /**
     * @param {?} table
     * @return {?}
     */
    function (table) {
        this.dt = table;
        if (isPresent(this.dt.initialSortKey) && this.dt.initialSortKey === this.key) {
            this.sortable = true;
            this.sortOrder = this.dt.sortOrderingForString(this.dt.initialSortOrder);
            this.dt.sortColumn = this;
        }
    };
    /**
     * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
     *
     * In case we use MaxWidth directive we set new width once for all columsn
     */
    /**
     * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
     *
     * In case we use MaxWidth directive we set new width once for all columsn
     * @param {?} myIndex
     * @return {?}
     */
    DTColumn2Component.prototype.postInitialize = /**
     * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
     *
     * In case we use MaxWidth directive we set new width once for all columsn
     * @param {?} myIndex
     * @return {?}
     */
    function (myIndex) {
        var _this = this;
        var /** @type {?} */ colIndex = myIndex + 1;
        var /** @type {?} */ table;
        if (this.dt.hasFrozenColumns()) {
            table = (/** @type {?} */ (this.dt)).el
                .nativeElement.querySelector('.dt-body-frozen table');
        }
        else {
            table = (/** @type {?} */ (this.dt)).el.nativeElement.querySelector('table');
        }
        if (this.widestCell > 0) {
            var /** @type {?} */ all = table.querySelectorAll('tr th:nth-child(' + colIndex + '), ' +
                'tr td:nth-child(' + colIndex + ')').forEach(function (node) {
                node.style.width = _this.widestCell + 'px';
            });
        }
    };
    /**
     * You either use this binding directly and say its datacolumn or when there is a [key]
     * biding we know it refers to some field.
     *
     */
    /**
     * You either use this binding directly and say its datacolumn or when there is a [key]
     * biding we know it refers to some field.
     *
     * @return {?}
     */
    DTColumn2Component.prototype.isValueColumn = /**
     * You either use this binding directly and say its datacolumn or when there is a [key]
     * biding we know it refers to some field.
     *
     * @return {?}
     */
    function () {
        return (isPresent(this.isDataColumn) && BooleanWrapper.isTrue(this.isDataColumn)) ||
            isPresent(this.key);
    };
    /**
     * When we are in outline mode  we need to also indend each selection control accordingly.
     *
     * indent - 1 > only offset with
     * indent
     */
    /**
     * When we are in outline mode  we need to also indend each selection control accordingly.
     *
     * indent - 1 > only offset with
     * indent
     * @param {?} cell
     * @param {?} level
     * @return {?}
     */
    DTColumn2Component.prototype.indentForControl = /**
     * When we are in outline mode  we need to also indend each selection control accordingly.
     *
     * indent - 1 > only offset with
     * indent
     * @param {?} cell
     * @param {?} level
     * @return {?}
     */
    function (cell, level) {
        if (this.dt.isOutline() && level > 0 && cell.offsetWidth > 0
            && isPresent(cell.nextElementSibling)) {
            var /** @type {?} */ outlineNodePadding = parseInt(getComputedStyle(cell.nextElementSibling).paddingLeft) || 0;
            // 1st level is pushed as root
            if (this.dt.pushRootSectionOnNewLine) {
                return (level === 1) ? null : (this.dt.indentationPerLevel * level)
                    - outlineNodePadding;
            }
            else {
                return (this.dt.indentationPerLevel * level) + outlineNodePadding;
            }
        }
        return null;
    };
    /**
     *
     * Internal
     * @param {?} width
     * @return {?}
     */
    DTColumn2Component.prototype.widthToPx = /**
     *
     * Internal
     * @param {?} width
     * @return {?}
     */
    function (width) {
        var /** @type {?} */ px;
        if (isPresent(width)) {
            if (width.indexOf('%') > 0) {
                var /** @type {?} */ nonPc = parseFloat(width) / 100;
                px = nonPc * (/** @type {?} */ (this.dt)).el.nativeElement.offsetWidth;
            }
            else {
                px = parseFloat(width);
            }
        }
        return px;
    };
    DTColumn2Component.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-column2',
                    template: "<!--\n    To make it more readable Each Column type has its own rendering template instead of putting\n    all this into datatable as this is more responsibility of the column. And the main goal\n    was try to be modular as possible. When There will be different types of columns\n\n    - Regular DTColumn (current implementation),\n    - SelectionColumn (Single/Multi select) - todo,\n    - DetailRow column, then pivotal collumn to render row/column/detail attributes - todo.\n\n    When implementing new column type you just inherit this DTColumnComponent and provide your\n    own rendering template and DT take care of the rest.\n\n    todo: We have SingleSelect, Multiselect rendering template that is Added programatically\n    todo: We have pivotal rendering template\n\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex, data: dataToRender,\n                 rowIndex:rowIndex}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Templates for header columns. Here we are rendering two types. Header and Subheader that we\n    usually use here as some kind of summary columns. Not really having summary at the bottom like other\n    DT.\n\n    TH column and their text are usually unselectable and most of these were inherited from\n    original PrimeNg DT even not many things got left after we refactor this but the idea is the\n    same.\n\n    Each cell has its dt-cell-def class that sets default styling like font, background, alignment\n    padding, etcs..\n\n\n-->\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\" let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <th #headerCell1 [class]=\"headerStyleClass||styleClass\" *ngIf=\"!isSubHeader\"\n        (click)=\"handleHeaderClick($event, headerCell1)\"\n        [ngClass]=\"{'dt-is-default dt-u-unselectable-text' :true,\n                    'dt-cell-def': dt.selectionMode !== 'cell' || (!dt.isOutline() || !dt.pivotalLayout),\n                    'dt-u-sortable': sortable,\n                    'dt-is-active': isSorted(),\n                    'dt-is-hidden': !isVisible}\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [attr.tabindex]=\"sortable ? 1 : null\"\n        [maxWidth]=\"maxWidthPx\"\n    >\n\n        <ng-template [ngIf]=\"dt.headerFilterTemplate && columnIndex === 0 \">\n            <ng-container *ngTemplateOutlet=\"dt.headerFilterTemplate\">\n            </ng-container>\n        </ng-template>\n        <!--\n            when cell are selectable we need two version where one wrap the cell content in div\n        -->\n        <ng-template [ngIf]=\"isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"selectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n    </th>\n\n    <th #headerCell2 [class]=\"headerStyleClass||styleClass\" *ngIf=\"isSubHeader\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{'dt-is-default dt-cell-def dt-sub-header dt-u-unselectable-text':true}\"\n        [maxWidth]=\"maxWidthPx\">\n\n        <span class=\"dt-col-title\" *ngIf=\"dt.showSubHeader && subHeaderTemplate\">\n            <ng-container *ngTemplateOutlet=\"subHeaderTemplate;\n                    context: {$implicit: this, rowData: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </span>\n    </th>\n</ng-template>\n\n\n<!--\n    Template for the body = the TD. For the body and we might want to do the same for header we\n    allow to have calculated body class that comes from the application. So based on the data types\n    you might want to apply different class in order to apply custom styling.\n-->\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        (click)=\"dt.onCellSelectionChange(cell, this, data)\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{ 'dt-is-default': true,\n        'dt-cell-def': !isCellSelectable(data),\n        'dt-is-hidden': !isVisible}\"\n        [maxWidth]=\"maxWidthPx\">\n\n        <!--\n            Since we need to support cell selection when we need to draw border around it\n            We are wrapping such sells with div which gives us better flexibility\n        -->\n        <ng-template [ngIf]=\"isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"selectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex }\">\n            </ng-container>\n\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </ng-template>\n\n    </td>\n</ng-template>\n\n<!--\n    Todo: create better solution instead of using different template create directive that wraps\n    it with the div conditionally\n-->\n<ng-template #selectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isHeaderSelected(this)}\">\n        <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #headerCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && !headerTemplate\">\n                {{label}}\n    </span>\n\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && headerTemplate\">\n                    <ng-container *ngTemplateOutlet=\"headerTemplate;\n                        context: {$implicit: this, rowData: data, rowIndex: rowIndex }\">\n                    </ng-container>\n    </span>\n\n    <span class=\"dt-col-sortable-icon sap-icon icon-sort\" *ngIf=\"sortable\"\n          [ngClass]=\"{'icon-sort-descending': (getSortOrder() == -1),\n                           'icon-sort-ascending': (getSortOrder() == 1)}\">\n    </span>\n</ng-template>\n\n\n<ng-template #selectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isBodyCellSelected(this, data)}\">\n        <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #bodyCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <!--\n           when no template is used use our FieldPath to access the object value based on the\n           key binding\n        -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"!bodyTemplate\">\n            {{dt.getValue(data, key)}}\n        </span>\n\n\n    <!--\n        In case application wants to provide their own cell component they use\n        #body ng-template to do so.\n    -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"bodyTemplate\">\n            <ng-container *ngTemplateOutlet=\"bodyTemplate;\n            context: {$implicit: this, rowData: data, rowIndex: rowIndex}\"></ng-container>\n        </span>\n</ng-template>\n",
                    styles: [".dt-sortable-col{cursor:pointer}.dt-col-sortable-icon{display:inline-block;margin-left:.125em}th.dt-cell-def{font-weight:400;color:#4a4a4a}th.dt-is-default{background-color:#f2f2f2;white-space:nowrap}th.dt-is-default.dt-cell-def:not(.dt-sub-header){border-bottom-color:#f2f2f2}th.dt-sub-header{background-color:#fff}th .dt-cell-selected{border-color:#58b957}td .dt-cell-selected{border-left-color:#4f9fcf}.dt-root-section .dt-selection-column,.dt-selection-column{width:46px;padding:0 12px}.dt-pivot-layout td.dt-selection-column,th.dt-selection-column{border-right-color:transparent}thead tr:first-child th{border-top-color:transparent}tbody tr:last-child:not(.dt-drag-row-bottom) td{border-bottom-color:transparent}td:first-child,th:first-child{border-left-color:transparent}td:last-child,th:last-child{border-right-color:transparent}tbody .dt-drag-row-top>td{background:linear-gradient(0deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-bottom>td{background:linear-gradient(180deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-both>td{background:linear-gradient(0deg,#0271d2 0,#fff 3%,#fff 97%,#0271d2 100%)}tbody .dt-row-dragging>td{background-color:#ececec;color:#b9b9b9}tbody .dt-row-dragging .ui-state-active{opacity:.5;cursor:not-allowed}"],
                    encapsulation: ViewEncapsulation.None,
                    providers: [DomHandler]
                },] },
    ];
    /** @nocollapse */
    DTColumn2Component.ctorParameters = function () { return [
        { type: Environment },
        { type: DomHandler }
    ]; };
    DTColumn2Component.propDecorators = {
        label: [{ type: Input }],
        key: [{ type: Input }],
        align: [{ type: Input }],
        bodyClassFn: [{ type: Input }],
        isVisible: [{ type: Input }],
        sortable: [{ type: Input }],
        sortOrdering: [{ type: Input }],
        showColumnLabel: [{ type: Input }],
        showSubHeader: [{ type: Input }],
        headerStyleClass: [{ type: Input }],
        bodyStyleClass: [{ type: Input }],
        selectable: [{ type: Input }],
        useGlobalHeader: [{ type: Input }],
        useGlobalSubHeader: [{ type: Input }],
        useGlobalBody: [{ type: Input }],
        isDataColumn: [{ type: Input }],
        frozen: [{ type: Input }],
        maxWidth: [{ type: Input }],
        minWidth: [{ type: Input }],
        rendererTemplate: [{ type: ViewChild, args: ['renderingTemplate',] }],
        headerTemplate: [{ type: ContentChild, args: ['header',] }],
        subHeaderTemplate: [{ type: ContentChild, args: ['subHeader',] }],
        bodyTemplate: [{ type: ContentChild, args: ['body',] }]
    };
    return DTColumn2Component;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An datatable header area.
 *
 * See {\@link DataTableComponent} for more explanation.
 */
var DTHeaderComponent2 = /** @class */ (function () {
    function DTHeaderComponent2() {
    }
    DTHeaderComponent2.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-header2',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    return DTHeaderComponent2;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Custom column implementation to render detail row spaning its column across whole table width.
 *
 *
 */
var DTDetailRowComponent = /** @class */ (function (_super) {
    __extends(DTDetailRowComponent, _super);
    function DTDetailRowComponent(env, domHandler) {
        var _this = _super.call(this, env, domHandler) || this;
        _this.env = env;
        _this.domHandler = domHandler;
        /**
         *
         * tells if we need to render a line between item row and its detail
         *
         */
        _this.showRowLine = true;
        return _this;
    }
    /**
     * @return {?}
     */
    DTDetailRowComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // just to get around the check in parent class
        this.key = '';
        this.isVisible = !this.dt.isOutline() || !this.dt.pivotalLayout;
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * Check if we need to keep some leading TDs
     *
     */
    /**
     * Check if we need to keep some leading TDs
     *
     * @return {?}
     */
    DTDetailRowComponent.prototype.visibleLeadingCols = /**
     * Check if we need to keep some leading TDs
     *
     * @return {?}
     */
    function () {
        return this.dt.numberOfColsBeforeData - (this.dt.hasInvisibleSelectionColumn() ? 1 : 0);
    };
    /**
     *
     * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
     * Here can hook on application level custom method to decide if current item has detail row
     * or not
     *
     * Or we can use isVisible=true to tell all row have detail row
     *
     */
    /**
     *
     * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
     * Here can hook on application level custom method to decide if current item has detail row
     * or not
     *
     * Or we can use isVisible=true to tell all row have detail row
     *
     * @param {?} item
     * @return {?}
     */
    DTDetailRowComponent.prototype.showDetailRow = /**
     *
     * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
     * Here can hook on application level custom method to decide if current item has detail row
     * or not
     *
     * Or we can use isVisible=true to tell all row have detail row
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ isVisible = this.isVisible;
        if (isPresent(this.isVisibleFn)) {
            isVisible = this.isVisibleFn.apply(this.dt.context, [this, item]);
        }
        return isVisible;
    };
    DTDetailRowComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-detail-column',
                    template: "<!--\n    Renders application defined detail column. This template just renders a detail row and\n    not expansion control. This is implemented by different DtColumn implementation and its added\n    (will be) added programmatically during column initialization\n-->\n<ng-template #renderingTemplate let-column=\"column\" let-rowData=\"data\">\n\n    <tr #detailRowElement class=\"dt-body-row dt-detail-row\">\n\n        <td *ngIf=\"dt.hasInvisibleSelectionColumn()\" width=\"1px\"></td>\n        <td *ngIf=\"visibleLeadingCols() > 0\" colspan=\"visibleLeadingCols()\" width=\"1px\">\n            &nbsp;&nbsp;\n        </td>\n        <td [attr.colspan]=\"dt.startOfFirstDataColumn\" [class]=\"dynamicBodyClass(rowData)\"\n            [ngClass]=\"{ 'dt-is-default dt-cell-def': true}\">\n\n            <ng-container\n                *ngTemplateOutlet=\"bodyTemplate; context:{$implicit: this, rowData:rowData}\">\n            </ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n",
                    styles: [""],
                    encapsulation: ViewEncapsulation.None,
                    providers: [DomHandler]
                },] },
    ];
    /** @nocollapse */
    DTDetailRowComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: DomHandler }
    ]; };
    DTDetailRowComponent.propDecorators = {
        isVisibleFn: [{ type: Input }],
        showRowLine: [{ type: Input }]
    };
    return DTDetailRowComponent;
}(DTColumn2Component));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 *
 *
 *
 */
var DTDetailRowExpanderComponent = /** @class */ (function (_super) {
    __extends(DTDetailRowExpanderComponent, _super);
    function DTDetailRowExpanderComponent(env, domHandler) {
        var _this = _super.call(this, env, domHandler) || this;
        _this.env = env;
        _this.domHandler = domHandler;
        // we dont want to show the row/column unless application says so
        // we dont want to show the row/column unless application says so
        _this.isVisible = false;
        // default width of the selection control
        // default width of the selection control
        _this.width = '45px';
        return _this;
    }
    /**
     * @return {?}
     */
    DTDetailRowExpanderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // just to get around the check in parent class
        this.key = '';
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    DTDetailRowExpanderComponent.prototype.toggleExpansion = /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    function (event, item) {
        this.dt.detailRowExpansionState.toggle(item);
        event.stopPropagation();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    DTDetailRowExpanderComponent.prototype.calculateStyleClass = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.dt.detailRowExpansionState.isExpanded(item) ?
            'icon-slim-arrow-down' : 'icon-slim-arrow-right';
    };
    DTDetailRowExpanderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-detail-column-expand',
                    template: "<!--\n   Special column that renders expand/collapse control for detail row when detail row is enabled.\n\n   Just like for the other column it renders header section as well as body section with\n   expand control to toggle the expansion\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\" let-columnIndex=\"columnIndex\" let-rowIndex=\"rowIndex\">\n\n\n    <ng-template [ngIf]=\"isHeader && !isSubHeader\">\n        <th #headerCell1 [class]=\"headerStyleClass||styleClass\"\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-cell-def' :true,\n                        'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender)}\">\n        </th>\n\n    </ng-template>\n\n    <ng-template [ngIf]=\"!isHeader && !isSubHeader\">\n        <td #cell\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{ 'dt-is-default': true,\n                    'dt-cell-def': !isCellSelectable(dataToRender),\n                    'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender),\n                    'dt-det-row-with-ln' : dt.rowDetailColumn.showRowLine}\">\n\n            <span (click)=\"toggleExpansion($event, dataToRender)\"\n                  class=\"dt-det-row-expand sap-icon\"\n                  [ngClass]=\"calculateStyleClass(dataToRender)\">\n\n            </span>\n\n        </td>\n\n    </ng-template>\n\n\n</ng-template>\n\n",
                    styles: [".dt-row-cell-expando{width:14px;text-align:right;padding:17px 5px 17px 17px;border-right-color:transparent}.dt-row-cell-expando .dt-det-row-expand{cursor:pointer;line-height:21px}td.dt-det-row-expanded:not(.dt-det-row-with-ln),td.dt-det-row-expanded:not(.dt-det-row-with-ln)~td{border-bottom-color:transparent}"],
                    encapsulation: ViewEncapsulation.None,
                    providers: [DomHandler]
                },] },
    ];
    /** @nocollapse */
    DTDetailRowExpanderComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: DomHandler }
    ]; };
    return DTDetailRowExpanderComponent;
}(DTColumn2Component));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * @license
 * Copyright 2017 SAP Ariba
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *
 *
 */
var /** @type {?} */ DragEvents = ['mousedown', 'dragstart', 'dragover', 'dragenter', 'dragleave',
    'drop', 'dragend'];
/** @enum {string} */
var DragDirection = {
    None: 'none',
    Up: 'dt-drag-row-top',
    Down: 'dt-drag-row-bottom',
    Middle: 'dt-drag-row-both',
};
/** @enum {string} */
var DropPosition = {
    Before: 'before',
    After: 'after',
    Into: 'into',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Concrete DataSource implementation for Datatable which defines state and column definition that
 * can programmatically modify rendered columns (if provided) and method for inserting and
 * and deleting records;
 *
 * All operations dealing with data use Observable<T> and instant() method to retrieve current
 * state is not implemented.
 *
 *
 */
var DT2DataSource = /** @class */ (function (_super) {
    __extends(DT2DataSource, _super);
    function DT2DataSource(dataProviders, finders) {
        var _this = _super.call(this, dataProviders, finders) || this;
        _this.dataProviders = dataProviders;
        _this.finders = finders;
        _this.initialized = false;
        _this.state = Datatable2State.create();
        _this.debugTime = new Date().getTime();
        return _this;
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    DT2DataSource.prototype.init = /**
     * @param {...?} args
     * @return {?}
     */
    function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (isBlank(args) || args.length !== 1 && !isDTInitParams(args[0])) {
            throw new Error('You need to initialize DS with (DSChooserInitParams)');
        }
        var /** @type {?} */ init = args[0];
        // use existing or find best match for dataProvider
        this.dataProvider = isPresent(init.dataProvider) ? init.dataProvider
            : this.dataProviders.find(init.obj);
        // use existing or find best match for dataFinder
        this.dataFinder = isPresent(init.dataFinder) ? init.dataFinder
            : this.finders.find(this.dataProvider, init.queryType);
        assert(isPresent(this.dataProvider) && isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
        this.dataFinder.lookupKey = init.lookupKey;
        if (isBlank(init.state)) {
            this.state = new Datatable2State();
        }
        else {
            this.state = init.state;
        }
        this.initialized = true;
    };
    /**
     * Triggers async fetch data request and result is given back using dataProvider.dataChanges
     *
     */
    /**
     * Triggers async fetch data request and result is given back using dataProvider.dataChanges
     *
     * @param {?=} withParams
     * @return {?}
     */
    DT2DataSource.prototype.fetch = /**
     * Triggers async fetch data request and result is given back using dataProvider.dataChanges
     *
     * @param {?=} withParams
     * @return {?}
     */
    function (withParams) {
        var _this = this;
        var /** @type {?} */ params = null;
        if (isPresent(withParams)) {
            params = new Map().set('offset', withParams.offset)
                .set('limit', withParams.limit)
                .set('orderby', withParams.sortKey)
                .set('selector', withParams.sortOrder);
        }
        this.dataProvider.fetch(params).subscribe(function (result) {
            if (withParams.offset > 0) {
                var /** @type {?} */ incrData = __spread(_this.dataProvider.dataChanges.getValue(), result);
                _this.dataProvider.dataChanges.next(incrData);
            }
            else {
                _this.dataProvider.dataChanges.next(result);
            }
        });
    };
    /**
     * Component uses this method to open up continuous stream to listen for any changes which
     * need to be reflected on the UI.
     *
     * Dont forget to unsubscribe when component is destroyed.
     */
    /**
     * Component uses this method to open up continuous stream to listen for any changes which
     * need to be reflected on the UI.
     *
     * Dont forget to unsubscribe when component is destroyed.
     * @template T
     * @return {?}
     */
    DT2DataSource.prototype.open = /**
     * Component uses this method to open up continuous stream to listen for any changes which
     * need to be reflected on the UI.
     *
     * Dont forget to unsubscribe when component is destroyed.
     * @template T
     * @return {?}
     */
    function () {
        return this.dataProvider.dataChanges.asObservable();
    };
    /**
     * @return {?}
     */
    DT2DataSource.prototype.close = /**
     * @return {?}
     */
    function () {
        this.dataProvider = null;
        this.dataFinder = null;
    };
    /**
     * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
     * dataProvider.dataChanges that are new data. If not enabled we have default implementation
     * which works with local array
     *
     */
    /**
     * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
     * dataProvider.dataChanges that are new data. If not enabled we have default implementation
     * which works with local array
     *
     * @param {?} object
     * @return {?}
     */
    DT2DataSource.prototype.insert = /**
     * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
     * dataProvider.dataChanges that are new data. If not enabled we have default implementation
     * which works with local array
     *
     * @param {?} object
     * @return {?}
     */
    function (object) {
        if (this.dataProvider.canCRUD()) {
            this.dataProvider.insert(object);
        }
        else {
            var /** @type {?} */ copy = this.dataProvider.data().slice();
            copy.push(object);
            this.dataProvider.dataChanges.next(copy);
        }
    };
    /**
     * Please see {@link insert} method
     *
     */
    /**
     * Please see {\@link insert} method
     *
     * @param {?} object
     * @return {?}
     */
    DT2DataSource.prototype.remove = /**
     * Please see {\@link insert} method
     *
     * @param {?} object
     * @return {?}
     */
    function (object) {
        if (this.dataProvider.canCRUD()) {
            this.dataProvider.remove(object);
        }
        else {
            var /** @type {?} */ copy = this.dataProvider.data().slice();
            var /** @type {?} */ afterDelete = copy.filter(function (elem) { return !equals(elem, object); });
            this.dataProvider.dataChanges.next(afterDelete);
        }
    };
    /**
     *
     * Provides access to DataFinder which can accept either plain string or Map.
     *
     * To be able to provide correct input we need to ask DataFinder if it supports FullText like
     * type query or Predicate. In case of Predicate we build the Map with different key/value
     * pairs
     *
     *
     */
    /**
     *
     * Provides access to DataFinder which can accept either plain string or Map.
     *
     * To be able to provide correct input we need to ask DataFinder if it supports FullText like
     * type query or Predicate. In case of Predicate we build the Map with different key/value
     * pairs
     *
     *
     * @param {?=} pattern
     * @return {?}
     */
    DT2DataSource.prototype.find = /**
     *
     * Provides access to DataFinder which can accept either plain string or Map.
     *
     * To be able to provide correct input we need to ask DataFinder if it supports FullText like
     * type query or Predicate. In case of Predicate we build the Map with different key/value
     * pairs
     *
     *
     * @param {?=} pattern
     * @return {?}
     */
    function (pattern) {
        var _this = this;
        if (isBlank(pattern) || pattern.length === 0) {
            // if we received empty string return orginal list
            this.fetch(this.state);
            return;
        }
        var /** @type {?} */ searchParam = pattern;
        if (this.dataFinder.accepts(this.dataProvider, QueryType.Predicate)) {
            searchParam = new Map().set('query', pattern).set('limit', DT2DataSource.MaxLimit);
            if (isPresent(this.state.sortKey)) {
                searchParam.set('orderby', this.state.sortKey);
            }
            if (isPresent(this.state.sortKey)) {
                searchParam.set('selector', this.state.sortOrder);
            }
        }
        else {
            assert(isString(pattern), 'Cannot pass non-string value to FullText Finder');
        }
        this.dataFinder.match(searchParam).subscribe(function (result) {
            _this.dataProvider.dataChanges.next(result);
        });
    };
    /**
     *
     * Data source delegates the responsibility to the given data provider which needs to implement
     * specific sorting mechanism
     *
     * Todo: Extend to sort by multiple columns
     *
     */
    /**
     *
     * Data source delegates the responsibility to the given data provider which needs to implement
     * specific sorting mechanism
     *
     * Todo: Extend to sort by multiple columns
     *
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    DT2DataSource.prototype.sort = /**
     *
     * Data source delegates the responsibility to the given data provider which needs to implement
     * specific sorting mechanism
     *
     * Todo: Extend to sort by multiple columns
     *
     * @param {?} key
     * @param {?} sortOrder
     * @return {?}
     */
    function (key, sortOrder) {
        if (isBlank(this.dataProvider.data()) || this.dataProvider.data().length === 0) {
            return;
        }
        this.state.sortKey = key;
        this.state.sortOrder = sortOrder;
        this.fetch(this.state);
    };
    /**
     *
     * Persist db state
     *
     */
    /**
     *
     * Persist db state
     *
     * @param {?} offset
     * @param {?} sortField
     * @param {?} sOrder
     * @return {?}
     */
    DT2DataSource.prototype.updateState = /**
     *
     * Persist db state
     *
     * @param {?} offset
     * @param {?} sortField
     * @param {?} sOrder
     * @return {?}
     */
    function (offset, sortField, sOrder) {
        this.state.offset = offset;
        this.state.sortKey = sortField;
        this.state.sortOrder = sOrder;
    };
    /**
     *
     * reshuffles current array based on new row D&D result.
     *
     * Since there is a difference if we move item from bottom or from the top and then accordingly
     * highlighting a space between rows. We need to reflect this in here as well.
     *
     * UseCase 1:
     *
     * 1. You can grab item with index 0 and move it down so that you can see a dropping line
     * between row with index 2 - 3
     *
     * 2. In this case splice() starts from position 2 and insert all elements after 2
     *      splice(start: number, deleteCount: number, ...items: T[]): T[];
     *
     * 3. no need to update newPos
     *
     * UseCase 2:
     *
     * 1. You can grab item with index 0 and move all the way down of the DT and now move the
     * row toward TOP and space between rows with index 2 - 3 is highlighted again.
     *
     * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
     * it seems the same but its highlighted row #3 with line at the TOP.
     *
     * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
     * where where the line between rows is created.
     *
     *
     * We don't need any complicated calculation trying to find out if we are on one half of the row
     * or second half and based on this try to apply certain style. This would not give so much
     * space if we want drop row into the row. And the calculation with coordinates woudl be too
     * complicated.
     *
     * We simply remember the direction we are moving and based on this we apply style to
     * to create a line at the TOP if we are going upwards or bottom otherwise.
     *
     *
     */
    /**
     *
     * reshuffles current array based on new row D&D result.
     *
     * Since there is a difference if we move item from bottom or from the top and then accordingly
     * highlighting a space between rows. We need to reflect this in here as well.
     *
     * UseCase 1:
     *
     * 1. You can grab item with index 0 and move it down so that you can see a dropping line
     * between row with index 2 - 3
     *
     * 2. In this case splice() starts from position 2 and insert all elements after 2
     *      splice(start: number, deleteCount: number, ...items: T[]): T[];
     *
     * 3. no need to update newPos
     *
     * UseCase 2:
     *
     * 1. You can grab item with index 0 and move all the way down of the DT and now move the
     * row toward TOP and space between rows with index 2 - 3 is highlighted again.
     *
     * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
     * it seems the same but its highlighted row #3 with line at the TOP.
     *
     * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
     * where where the line between rows is created.
     *
     *
     * We don't need any complicated calculation trying to find out if we are on one half of the row
     * or second half and based on this try to apply certain style. This would not give so much
     * space if we want drop row into the row. And the calculation with coordinates woudl be too
     * complicated.
     *
     * We simply remember the direction we are moving and based on this we apply style to
     * to create a line at the TOP if we are going upwards or bottom otherwise.
     *
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    DT2DataSource.prototype.reorderRows = /**
     *
     * reshuffles current array based on new row D&D result.
     *
     * Since there is a difference if we move item from bottom or from the top and then accordingly
     * highlighting a space between rows. We need to reflect this in here as well.
     *
     * UseCase 1:
     *
     * 1. You can grab item with index 0 and move it down so that you can see a dropping line
     * between row with index 2 - 3
     *
     * 2. In this case splice() starts from position 2 and insert all elements after 2
     *      splice(start: number, deleteCount: number, ...items: T[]): T[];
     *
     * 3. no need to update newPos
     *
     * UseCase 2:
     *
     * 1. You can grab item with index 0 and move all the way down of the DT and now move the
     * row toward TOP and space between rows with index 2 - 3 is highlighted again.
     *
     * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
     * it seems the same but its highlighted row #3 with line at the TOP.
     *
     * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
     * where where the line between rows is created.
     *
     *
     * We don't need any complicated calculation trying to find out if we are on one half of the row
     * or second half and based on this try to apply certain style. This would not give so much
     * space if we want drop row into the row. And the calculation with coordinates woudl be too
     * complicated.
     *
     * We simply remember the direction we are moving and based on this we apply style to
     * to create a line at the TOP if we are going upwards or bottom otherwise.
     *
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    function (origPos, newPos, dropPos) {
        var /** @type {?} */ array = this.dataProvider.data().slice();
        // take something from top and drag&drop under
        if (newPos > origPos && dropPos === DropPosition.Before && newPos < array.length) {
            newPos -= 1;
            // take something from bottom and drag&drop above
        }
        else if (newPos < origPos && dropPos === DropPosition.After && newPos >= 0) {
            newPos += 1;
        }
        array.splice.apply(array, __spread([newPos, 0], array.splice(origPos, 1)[0]));
        this.dataProvider.dataChanges.next(array);
    };
    DT2DataSource.MaxLimit = 100;
    return DT2DataSource;
}(DataSource));
/**
 * Keeps current datatable state the state which drivers the way while fetching the data as well
 * encapsulate set of properties that needs to be persistet in order to recover a state after e.g.
 * browser refresh
 *
 *
 * todo: Create methods to convert this state from and to JSON for easier serialization
 */
var Datatable2State = /** @class */ (function () {
    function Datatable2State() {
        /**
         * Properties for paging and fetching
         */
        this.offset = 0;
        this.limit = 0;
        /**
         * Identifies default value that is used to render N number of rows in non-fullscreen
         * mode
         *
         */
        this.displayLimit = 0;
        /**
         * Sorting order of the sort field. DataTable support sorting for multiple column but we
         * dont persist it now. Maybe in the future
         */
        this.sortOrder = Datatable2State.Ascending;
        /**
         * If we are using global filter for current datatable then save it here
         */
        this.currentSearchQuery = '';
        this.outlineState = new Map();
        this.detailRowExpandState = new Map();
    }
    /**
     * @param {?=} offset
     * @param {?=} limit
     * @param {?=} displayLimit
     * @param {?=} sortField
     * @param {?=} sOrder
     * @param {?=} searchQuery
     * @param {?=} filter
     * @param {?=} outlineState
     * @param {?=} detailRowState
     * @return {?}
     */
    Datatable2State.create = /**
     * @param {?=} offset
     * @param {?=} limit
     * @param {?=} displayLimit
     * @param {?=} sortField
     * @param {?=} sOrder
     * @param {?=} searchQuery
     * @param {?=} filter
     * @param {?=} outlineState
     * @param {?=} detailRowState
     * @return {?}
     */
    function (offset, limit, displayLimit, sortField, sOrder, searchQuery, filter, outlineState, detailRowState) {
        if (offset === void 0) { offset = 0; }
        if (limit === void 0) { limit = 15; }
        if (displayLimit === void 0) { displayLimit = 5; }
        if (sortField === void 0) { sortField = ''; }
        if (sOrder === void 0) { sOrder = 0; }
        if (outlineState === void 0) { outlineState = new Map(); }
        if (detailRowState === void 0) { detailRowState = new Map(); }
        var /** @type {?} */ s = new Datatable2State();
        s.offset = offset;
        s.limit = limit;
        s.displayLimit = displayLimit;
        s.sortKey = sortField;
        s.sortOrder = sOrder;
        s.currentSearchQuery = searchQuery;
        s.currentFilter = filter;
        s.outlineState = outlineState;
        s.detailRowExpandState = detailRowState;
        return s;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    Datatable2State.fromJSON = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var /** @type {?} */ state$$1 = JSON.parse(data);
        var /** @type {?} */ ds = new Datatable2State();
        ds.offset = state$$1.offset;
        ds.limit = state$$1.limit;
        ds.displayLimit = state$$1.displayLimit;
        ds.sortKey = state$$1.sortKey;
        ds.sortOrder = state$$1.sortOrder;
        ds.currentSearchQuery = state$$1.currentSearchQuery;
        ds.outlineState = MapWrapper.createFromAnyMap(state$$1.outlineState);
        ds.detailRowExpandState = MapWrapper.createFromAnyMap(state$$1.detailRowExpandState);
        return ds;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    Datatable2State.toJSON = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var /** @type {?} */ toConvert = {
            offset: data.offset,
            limit: data.limit,
            displayLimit: data.displayLimit,
            sortKey: data.sortKey,
            sortOrder: data.sortOrder,
            currentSearchQuery: data.currentSearchQuery,
            outlineState: MapWrapper.toAnyMap(data.outlineState),
            detailRowExpandState: MapWrapper.toAnyMap(data.detailRowExpandState)
        };
        return JSON.stringify(toConvert);
    };
    Datatable2State.Ascending = 1;
    Datatable2State.Descending = -1;
    return Datatable2State;
}());
/**
 * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
 * simple we have a map holding item reference as a key and boolean value indicating if the
 * detail row is visible
 *
 * Todo: move this out to DS
 */
var  /**
 * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
 * simple we have a map holding item reference as a key and boolean value indicating if the
 * detail row is visible
 *
 * Todo: move this out to DS
 */
DetailRowExpansionState = /** @class */ (function () {
    function DetailRowExpansionState(dt) {
        this.dt = dt;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    DetailRowExpansionState.prototype.itemToKey = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return isEntity(item) ? (/** @type {?} */ (item)).identity() : item;
    };
    Object.defineProperty(DetailRowExpansionState.prototype, "detailExpansionEnabled", {
        get: /**
         * @return {?}
         */
        function () {
            return isPresent(this.expansionStates);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.expansionStates = new Map();
            }
            else {
                this.expansionStates = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} item
     * @return {?}
     */
    DetailRowExpansionState.prototype.toggle = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ key = this.itemToKey(item);
        if (!this.isExpanded(item)) {
            this.expansionStates.set(key, true);
        }
        else {
            this.expansionStates.delete(key);
        }
        this.dt.dataSource.state.detailRowExpandState = this.expansionStates;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    DetailRowExpansionState.prototype.isExpanded = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ key = this.itemToKey(item);
        // handle special case where we collapse parent of parent while detail row is expanded
        if (this.dt.isOutline() && !this.dt.outlineState.isExpanded(key)) {
            this.expansionStates.delete(key);
            return false;
        }
        var /** @type {?} */ isOutlineExpanded = this.dt.isOutline() ? this.dt.outlineState.isExpanded(key) : true;
        return isPresent(key) && this.expansionStates.has(key);
    };
    return DetailRowExpansionState;
}());
/**
 * @param {?} init
 * @return {?}
 */
function isDTInitParams(init) {
    return isPresent(init.obj) || isPresent(init.queryType) || isPresent(init.entity);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Column implementation for the Multiselection where we show checkbox control
 *
 *
 */
var DTMultiSelectColumnComponent = /** @class */ (function (_super) {
    __extends(DTMultiSelectColumnComponent, _super);
    function DTMultiSelectColumnComponent(env, domHandler) {
        var _this = _super.call(this, env, domHandler) || this;
        _this.env = env;
        _this.domHandler = domHandler;
        // default width of the selection control
        // default width of the selection control
        _this.width = '45px';
        return _this;
    }
    DTMultiSelectColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-multi-select-column',
                    template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n\n        <ng-template [ngIf]=\"dt.showSelectAll\">\n            <aw-checkbox [type]=\"'action'\" (action)=\"dt.toggleAllColumns($event)\"\n                         [value]=\"dt.isToggleAllColumnSelected()\"\n                         [disabled]=\"dt.isToggleAllColumnDisabled()\">\n            </aw-checkbox>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!dt.showSelectAll\">&nbsp;\n        </ng-template>\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-checkbox [type]=\"'action'\" [value]=\"dt.isRowSelected(data)\" >\n        </aw-checkbox>\n\n    </td>\n</ng-template>\n",
                    styles: [""],
                    encapsulation: ViewEncapsulation.None,
                    providers: [DomHandler]
                },] },
    ];
    /** @nocollapse */
    DTMultiSelectColumnComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: DomHandler }
    ]; };
    return DTMultiSelectColumnComponent;
}(DTColumn2Component));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Column implementation for the SingleSelect where we show checkbox control
 *
 *
 */
var DTSingleSelectColumnComponent = /** @class */ (function (_super) {
    __extends(DTSingleSelectColumnComponent, _super);
    function DTSingleSelectColumnComponent(env, domHandler) {
        var _this = _super.call(this, env, domHandler) || this;
        _this.env = env;
        _this.domHandler = domHandler;
        // default width of the selection control
        // default width of the selection control
        _this.width = '45px';
        return _this;
    }
    DTSingleSelectColumnComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-single-select-column',
                    template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n        &nbsp;\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-radiobutton [name]=\"'DTRadio'\" [value]=\"data\" [(ngModel)]=\"dt.dataSource.state.selection\">\n        </aw-radiobutton>\n    </td>\n</ng-template>\n",
                    styles: [""],
                    encapsulation: ViewEncapsulation.None,
                    providers: [DomHandler]
                },] },
    ];
    /** @nocollapse */
    DTSingleSelectColumnComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: DomHandler }
    ]; };
    return DTSingleSelectColumnComponent;
}(DTColumn2Component));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * DT component that implements the data grid that shows tabular data. Even the basic
 * structure is based on PrimeNG datatable its completely refactored into smaller pieces that
 * allows more extensibility and trying to stay as close as possible to existing AWL implementation
 *
 * There are 3 main pieces:
 *
 *  Table Wrapper - focuses on the outer structure. Container with basic datable layout plus
 *  contains any additional panels that datatable needs such as our new concept how editing will
 *  work - sliding panel from the bottom
 *
 *  Datatable Column - Instead of rendering everything inside DT I split the part that renders
 *  column into separate component. This way component column has its own renderer template which
 *  can render both header and data cells.
 *  Later on DTColumn is then extended to support other additional column types
 *  SingleSelectionColumn, MultiSelectionColumn, both responsible for rendering selection controls.
 *
 * To support pivotal layout this can be extended for other additional columns that implements their
 * own rendering templates
 *
 * Datatable - The main component that is only focus on header and body rendering and basaed on the
 * column type it will render the correct template
 * column type it will render the correct template
 *
 *
 *
 *
 *
 */
var Datatable2Component = /** @class */ (function (_super) {
    __extends(Datatable2Component, _super);
    /**
     *
     * In case of outline table we are inject OutlineState which is provided in the DT component
     * definition. This is used by nested outlineFor component it set itself as reference and
     * initialize the state so it can be used later on inside OutlineControl
     *
     *
     * Each Datatable is pre-defaulted with its own version of DataSource so all the observers
     * inside are unique for this component
     *
     */
    function Datatable2Component(env, el, _defaultDS, changeDetector, factoryResolver, outlineState, zone, injector) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.el = el;
        _this._defaultDS = _defaultDS;
        _this.changeDetector = changeDetector;
        _this.factoryResolver = factoryResolver;
        _this.outlineState = outlineState;
        _this.zone = zone;
        _this.injector = injector;
        /**
         *  Hides or shows table heading where we have filters and tools menus
         */
        _this.showTableHeader = true;
        /**
         * See AWDataTable
         *
         */
        _this.pivotalLayout = false;
        /**
         * See AWDataTable
         */
        _this.initialSortOrder = 'descending';
        /**
         * When DT is loaded in the page and we are not in the full screen (full page mode), this
         * is hte number of lines that DT will show
         *
         * todo: come up with better name
         */
        _this.displayRowSize = 10;
        /**
         * Used for paging on lazy loading using infinite scroller to set initial fetch limit size
         *
         * todo: come up with better name !!!
         *
         */
        _this.pageSize = 15;
        /**
         * Default message when there are no data .
         *
         * todo: Use i18n value and create resource file
         */
        _this.emptyMessage = 'No records found';
        /**
         *
         * See AWDataTable
         *
         */
        _this.selectionMode = 'none';
        /**
         *
         * Can provide custom icon. These icons are not animated divs, we used css
         * transformation to rotate them.
         *
         */
        _this.loadingIcon = 'icon-synchronize';
        /**
         * Additional indent can be added when rendering detail row
         */
        _this.indentDetailRow = false;
        /**
         * See AWDataTable
         *
         */
        _this.indentationPerLevel = 25;
        /**
         *
         *  SubHeader is used to show summary columns, which in our UX is shown at the top just under
         *  the regular table header
         *
         */
        _this.showSubHeader = false;
        /**
         * See OutlineFor - only used in the tree mode
         */
        _this.expandAll = false;
        /**
         * See AWDataTable
         */
        _this.pushRootSectionOnNewLine = true;
        /**
         * Render or hide expansion control for row detail columns. Expansion control makes sense for
         * simple table, when using this inside outline (tree table), its driven by outline control
         */
        _this.showRowDetailExpansionControl = true;
        /**
         * See AWDataTable
         *
         */
        _this.showSelectionColumn = true;
        /**
         * See AWDataTable
         *
         */
        _this.showSelectAll = true;
        /**
         * Show or hide global search term input field in the header
         */
        _this.showGlobalSearch = true;
        /**
         * Enables or disables row reordering
         *
         */
        _this.dndRowEnabled = false;
        /**
         *
         * Fires event that sorting is enabled for column and we trigger sorting
         *
         */
        _this.onSort = new EventEmitter();
        /**
         * Based on selection mode it triggers even
         *
         */
        _this.onRowClick = new EventEmitter();
        /**
         *
         * When multi or single selection mode is enabled it will trigger event when checkbox or
         * radio buttons is selected
         *
         * todo: implement SingleSelectionDTColumn, MultiSelectionDTColumn with their renderers
         */
        _this.onRowSelectionChange = new EventEmitter();
        /**
         * When cell body selection changes we fire event
         *
         */
        _this.onCellChange = new EventEmitter();
        /**
         * When cell header selection changes we fire event
         *
         */
        _this.onHeaderSelection = new EventEmitter();
        /**
         *
         * Triggers when items in the list are updated
         *
         */
        _this.valueChange = new EventEmitter();
        _this.classList = 'w-datatable ';
        /**
         *  Indicates that columns were initialed Also used when we hide and show column to trigger
         *  change.
         *
         */
        _this.columnsChanged = false;
        /**
         * See AWDataTable
         */
        _this.numberOfColsBeforeData = 0;
        /**
         * See AWDataTable
         */
        _this.startOfFirstDataColumn = 0;
        _this.dataSource = _this._defaultDS;
        return _this;
    }
    /**
     * @return {?}
     */
    Datatable2Component.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        if (isPresent(this.list) && isPresent(this.destinationClass)) {
            throw new Error('You cannot use both bindings [list] and [destinationClass]!');
        }
        this.detailRowExpansionState = new DetailRowExpansionState(this);
        // init default columns
        this.rowDetailExpandColumn = this.factoryResolver
            .resolveComponentFactory(DTDetailRowExpanderComponent).create(this.injector).instance;
        this.multiSelectColumn = this.factoryResolver
            .resolveComponentFactory(DTMultiSelectColumnComponent).create(this.injector).instance;
        this.singleSelectColumn = this.factoryResolver
            .resolveComponentFactory(DTSingleSelectColumnComponent).create(this.injector).instance;
        /**
                 * If the data are not deferred and we get list directly then it creates DS. If
                 * ngOnChanges is called first we properly init DS and clean this.list
                 *
                 */
        if (isPresent(this.destinationClass) || isPresent(this.list)) {
            this.initDatasource();
        }
        else if (this.dataSource.initialized) {
            this.initDatasource(false);
        }
        // since we work with references let's pass created map inside our state
        this.outlineState.expansionStates = this.state.outlineState;
    };
    /**
     * When data arrives later maybe due to REST API latency, initialize DS only when we have a
     * data, otherwise if data changed thru the bindings just trigger dataChange event
     *
     */
    /**
     * When data arrives later maybe due to REST API latency, initialize DS only when we have a
     * data, otherwise if data changed thru the bindings just trigger dataChange event
     *
     * @param {?} changes
     * @return {?}
     */
    Datatable2Component.prototype.ngOnChanges = /**
     * When data arrives later maybe due to REST API latency, initialize DS only when we have a
     * data, otherwise if data changed thru the bindings just trigger dataChange event
     *
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (changes['list'] && isPresent(changes['list'].currentValue)
            && !this.dataSource.initialized) {
            this.initDatasource();
        }
        else if (this.dataSource.initialized) {
            this.dataSource.dataProvider.dataChanges.next(this.list);
        }
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // make sure we init a state when detail column is present
        // todo: move this initialization to datasource
        this.detailRowExpansionState.detailExpansionEnabled = isPresent(this.rowDetailColumn);
        this.initColumns();
        this.columnsSubscription = this.colsQuery.changes.subscribe(function (_) {
            _this.initColumns();
            _this.changeDetector.markForCheck();
        });
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // assign it programatically as we want to have a context for the filter
        if (isPresent(this.rowDetailColumn) && isPresent(this.outlineState.outlineFor)) {
            this.outlineState.outlineFor.filterOut = this.skipOutlineItem.bind(this);
        }
        if (isPresent(this.outlineState.outlineFor)) ;
        this.initialized = true;
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        if (this.columnsChanged && this.el.nativeElement.offsetParent) {
            this.columnsChanged = false;
        }
        if (this.hasFrozenColumns()) {
            this.frozenColumns.forEach(function (col, index) {
                return col.postInitialize(index);
            });
        }
        else {
            this.columns.forEach(function (col, index) {
                return col.postInitialize(index);
            });
        }
    };
    /**
     * Key entry method that initialized our columns. Later on when we will support selection and
     * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
     * components and add them to the list so they can be rendered.
     *
     * so the idea here is:
     *
     * When DT component initialize and we are in editing mode and we support Single/Multi selection
     * we will use ComponentFactoryResolver to create component and add it as first item to the list
     * and then it will be rendered just like anythign else.
     *
     */
    /**
     * Key entry method that initialized our columns. Later on when we will support selection and
     * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
     * components and add them to the list so they can be rendered.
     *
     * so the idea here is:
     *
     * When DT component initialize and we are in editing mode and we support Single/Multi selection
     * we will use ComponentFactoryResolver to create component and add it as first item to the list
     * and then it will be rendered just like anythign else.
     *
     * @return {?}
     */
    Datatable2Component.prototype.initColumns = /**
     * Key entry method that initialized our columns. Later on when we will support selection and
     * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
     * components and add them to the list so they can be rendered.
     *
     * so the idea here is:
     *
     * When DT component initialize and we are in editing mode and we support Single/Multi selection
     * we will use ComponentFactoryResolver to create component and add it as first item to the list
     * and then it will be rendered just like anythign else.
     *
     * @return {?}
     */
    function () {
        var _this = this;
        this.columns = [];
        this.frozenColumns = [];
        if (this.detailRowExpansionState.detailExpansionEnabled) {
            this.initDetailColumnExpansion();
        }
        if (this.hasLeadingSelectColumn() && this.selectionMode === 'multi') {
            this.columns.push(this.multiSelectColumn);
        }
        else if (this.hasLeadingSelectColumn() && this.selectionMode === 'single') {
            this.columns.push(this.singleSelectColumn);
        }
        /**
                 * Add expansion column when detail row is enabled
                 */
        if (this.detailRowExpansionState.detailExpansionEnabled && !this.isOutline()) {
            this.columns.push(this.rowDetailExpandColumn);
        }
        this.colsQuery
            .filter(function (col1) { return !col1.frozen; })
            .forEach(function (col) {
            col.initialize(_this);
            _this.columns.push(col);
        });
        this.initFrozenColumns();
        this.initColumnInfo();
        this.columnsChanged = true;
    };
    /**
     * Makes sure that we also include programmatic column if present. Move them to the correct
     * array
     *
     * @return {?}
     */
    Datatable2Component.prototype.initFrozenColumns = /**
     * Makes sure that we also include programmatic column if present. Move them to the correct
     * array
     *
     * @return {?}
     */
    function () {
        var _this = this;
        this.colsQuery
            .filter(function (col1) { return col1.frozen; })
            .forEach(function (col) {
            col.initialize(_this);
            _this.frozenColumns.push(col);
        });
        if (this.frozenColumns.length > 0) {
            // find last index of column that is internal / programmatic
            var /** @type {?} */ lastInx = this.columns.slice()
                .reverse()
                .findIndex(function (col) { return _this.isInternalColumn(col); });
            if (lastInx !== -1) {
                var /** @type {?} */ idx = this.columns.length - 1 - lastInx;
                var /** @type {?} */ internalCols = this.columns.splice(0, idx + 1);
                this.frozenColumns = __spread(internalCols, this.frozenColumns);
            }
            var /** @type {?} */ hasValidCols = this.columns
                .findIndex(function (col) { return isBlank(col.width); }) === -1;
            assert(hasValidCols || isPresent(this.scrollWidth), 'When using [frozen] binding you need specify [width] for each ' +
                'column or [scrollWidth] on datatable!');
            assert(isBlank(this.rowDetailColumn), 'You cannot combine aw-dt-detail-column with frozen columns!');
        }
    };
    /**
     * Check if current column is programmatically created
     *
     */
    /**
     * Check if current column is programmatically created
     *
     * @param {?} col
     * @return {?}
     */
    Datatable2Component.prototype.isInternalColumn = /**
     * Check if current column is programmatically created
     *
     * @param {?} col
     * @return {?}
     */
    function (col) {
        return col instanceof DTSingleSelectColumnComponent ||
            col instanceof DTMultiSelectColumnComponent ||
            col instanceof DTDetailRowExpanderComponent;
    };
    /**
     * Create new Datasource based on passed values. It tries to initialize DS for first time
     * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
     * can be triggered also from ngOnChanges.
     *
     */
    /**
     * Create new Datasource based on passed values. It tries to initialize DS for first time
     * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
     * can be triggered also from ngOnChanges.
     *
     * @param {?=} initialize
     * @return {?}
     */
    Datatable2Component.prototype.initDatasource = /**
     * Create new Datasource based on passed values. It tries to initialize DS for first time
     * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
     * can be triggered also from ngOnChanges.
     *
     * @param {?=} initialize
     * @return {?}
     */
    function (initialize) {
        var _this = this;
        if (initialize === void 0) { initialize = true; }
        if (isBlank(this.state)) {
            this.state = Datatable2State.create(0, this.pageSize, this.displayRowSize, this.initialSortKey, this.sortOrderingForString(this.initialSortOrder));
        }
        else {
            this.state.limit = this.state.displayLimit = this.displayRowSize;
            if (isPresent(this.initialSortKey)) {
                this.state.sortKey = this.initialSortKey;
                this.state.sortOrder = this.sortOrderingForString(this.initialSortOrder);
            }
        }
        if (initialize) {
            this.dataSource.init({
                obj: isPresent(this.destinationClass) ? this.destinationClass : this.list,
                queryType: QueryType.FullText,
                state: this.state,
                multiselect: false
            });
        }
        this.dataSource.fetch(this.state);
        // reset list to make sure it comes from DataProvider, we use list  to initialize
        this.list = null;
        // This is the ENTRY point for the DATA CHANGES. All addition, edits, deletion ends up
        // here. We dont work directly with LIST. Any change is reactive and here is listener
        this.dataSource.open().subscribe(function (data) {
            _this.updateList(data);
        });
    };
    /**
     * When detailRow column is present we initialize a state holding information which item is
     * expanded.
     *
     * todo: This is temporary here and once we suport lazy loading move this to datasource.
     *
     * For example for outline tree table we need to connect a state from outline with a state in
     * here as we are using outline control to expand and collapse items
     */
    /**
     * When detailRow column is present we initialize a state holding information which item is
     * expanded.
     *
     * todo: This is temporary here and once we suport lazy loading move this to datasource.
     *
     * For example for outline tree table we need to connect a state from outline with a state in
     * here as we are using outline control to expand and collapse items
     * @return {?}
     */
    Datatable2Component.prototype.initDetailColumnExpansion = /**
     * When detailRow column is present we initialize a state holding information which item is
     * expanded.
     *
     * todo: This is temporary here and once we suport lazy loading move this to datasource.
     *
     * For example for outline tree table we need to connect a state from outline with a state in
     * here as we are using outline control to expand and collapse items
     * @return {?}
     */
    function () {
        this.detailRowExpansionState.detailExpansionEnabled = isPresent(this.rowDetailColumn) &&
            BooleanWrapper.isTrue(this.showRowDetailExpansionControl);
    };
    /**
     * This method is executed after we initialize all the columns in order to calculate correct
     * numbers used for indentation while rendering selection columns as well as detail row columns.
     *
     * Here we need to be aware how many columns to span
     *
     */
    /**
     * This method is executed after we initialize all the columns in order to calculate correct
     * numbers used for indentation while rendering selection columns as well as detail row columns.
     *
     * Here we need to be aware how many columns to span
     *
     * @return {?}
     */
    Datatable2Component.prototype.initColumnInfo = /**
     * This method is executed after we initialize all the columns in order to calculate correct
     * numbers used for indentation while rendering selection columns as well as detail row columns.
     *
     * Here we need to be aware how many columns to span
     *
     * @return {?}
     */
    function () {
        var _this = this;
        this.numberOfColsBeforeData = 0;
        this.columns.forEach(function (col) {
            if (!col.isValueColumn()) {
                _this.numberOfColsBeforeData++;
            }
        });
        if (this.indentDetailRow) {
            this.numberOfColsBeforeData++;
        }
        this.startOfFirstDataColumn = this.columns.length - this.numberOfColsBeforeData;
    };
    Object.defineProperty(Datatable2Component.prototype, "state", {
        /**
         * Pushes a state out to application. Can be use as two way bindings
         *
         * [(state)]=dtState(s)
         *
         */
        get: /**
         * Pushes a state out to application. Can be use as two way bindings
         *
         * [(state)]=dtState(s)
         *
         * @return {?}
         */
        function () {
            return this.dataSource.state;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.dataSource.state = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.onCellSelectionChange = /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    function (cell, column, item) {
        if (this.selectionMode !== 'cell') {
            return;
        }
        var /** @type {?} */ lookupKey = {
            col: column.key || column.label,
            item: item
        };
        if (isPresent(this.state.selection) && this.state.selection.length > 0) {
            var /** @type {?} */ foundIndex_1 = ListWrapper.findIndexComplex(this.state.selection, lookupKey);
            var /** @type {?} */ isSelected = foundIndex_1 !== -1;
            if (isSelected) {
                this.state.selection = this.state.selection
                    .filter(function (val, index) { return index !== foundIndex_1; });
            }
            else {
                this.state.selection = __spread(this.state.selection, [lookupKey]);
            }
        }
        else {
            this.state.selection = [lookupKey];
        }
        this.onCellChange.emit(this.state.selection);
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @return {?}
     */
    Datatable2Component.prototype.onHeaderSelectionChange = /**
     * See AWDataTable
     *
     * @param {?} cell
     * @param {?} column
     * @return {?}
     */
    function (cell, column) {
        if (isPresent(this.state.headerSelection)) {
            if (this.isHeaderSelected(column)) {
                this.state.headerSelection = null;
            }
            else {
                this.state.headerSelection = column;
            }
        }
        else {
            this.state.headerSelection = column;
        }
        this.onHeaderSelection.emit(this.state.headerSelection);
    };
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.onHandleRowClicked = /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    function (event, item) {
        // special alt key modifier. When used with rows it indicates there is a D&D enabled
        if (event.altKey) {
            return;
        }
        if (this.selectionMode === 'multi') {
            this.onRowToggle(event, item);
        }
        else if (this.selectionMode === 'single') {
            this.onRowSelect(event, item);
        }
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.onRowToggle = /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    function (event, item) {
        var /** @type {?} */ rowSelected = true;
        if (isPresent(this.state.selection) && this.state.selection.length > 0) {
            var /** @type {?} */ foundIndex_2 = ListWrapper.findIndexComplex(this.state.selection, item);
            var /** @type {?} */ isSelected = foundIndex_2 !== -1;
            if (isSelected) {
                this.state.selection = this.state.selection
                    .filter(function (val, index) { return index !== foundIndex_2; });
                rowSelected = false;
            }
            else {
                this.state.selection = __spread(this.state.selection, [item]);
            }
            // for the outline go up and down the sync with treeitems
            if (this.isOutline()) {
                this.onHandleOutlineRowToggleToChildren(item, isSelected);
                this.oHandleOutlineRowToggleToParent(item, isSelected);
            }
        }
        else {
            this.state.selection = [item];
            if (this.isOutline()) {
                this.onHandleOutlineRowToggleToChildren(item, false);
                this.oHandleOutlineRowToggleToParent(item, false);
            }
        }
        this.onRowSelectionChange.emit({
            isSelected: rowSelected,
            item: this.state.selection
        });
        event.stopPropagation();
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.onRowSelect = /**
     * See AWDataTable
     *
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    function (event, item) {
        this.state.selection = item;
        event.stopPropagation();
        this.onRowSelectionChange.emit(item);
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    Datatable2Component.prototype.onHandleOutlineRowToggleToChildren = /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    function (currentItem, isSelected) {
        var /** @type {?} */ childrenForNode = this.children.apply(this.context, [currentItem]) || [];
        if (childrenForNode.length > 0) {
            // If is selected currently then toggle to other state
            if (!isSelected) {
                // when checking all from root, deselect children and add all
                this.onHandleOutlineRowToggleToChildren(currentItem, true);
                this.state.selection = __spread(this.state.selection, childrenForNode);
            }
            else {
                var _loop_1 = function (child) {
                    var /** @type {?} */ foundIndex = ListWrapper.findIndexComplex(this_1.state.selection, child);
                    this_1.state.selection = this_1.state.selection
                        .filter(function (val, index) { return index !== foundIndex; });
                };
                var this_1 = this;
                try {
                    // remove each child
                    for (var childrenForNode_1 = __values(childrenForNode), childrenForNode_1_1 = childrenForNode_1.next(); !childrenForNode_1_1.done; childrenForNode_1_1 = childrenForNode_1.next()) {
                        var child = childrenForNode_1_1.value;
                        _loop_1(child);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (childrenForNode_1_1 && !childrenForNode_1_1.done && (_a = childrenForNode_1.return)) _a.call(childrenForNode_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            try {
                // apply the same for children of children
                for (var childrenForNode_2 = __values(childrenForNode), childrenForNode_2_1 = childrenForNode_2.next(); !childrenForNode_2_1.done; childrenForNode_2_1 = childrenForNode_2.next()) {
                    var child = childrenForNode_2_1.value;
                    this.onHandleOutlineRowToggleToChildren(child, isSelected);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (childrenForNode_2_1 && !childrenForNode_2_1.done && (_b = childrenForNode_2.return)) _b.call(childrenForNode_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        var e_1, _a, e_2, _b;
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    Datatable2Component.prototype.oHandleOutlineRowToggleToParent = /**
     * See AWDataTable
     *
     * @param {?} currentItem
     * @param {?} isSelected
     * @return {?}
     */
    function (currentItem, isSelected) {
        var /** @type {?} */ parent = currentItem.$$parentItem;
        if (isPresent(parent)) {
            var /** @type {?} */ childrenForNode = this.children.apply(this.context, [parent]) || [];
            var /** @type {?} */ allSelected = true;
            try {
                for (var childrenForNode_3 = __values(childrenForNode), childrenForNode_3_1 = childrenForNode_3.next(); !childrenForNode_3_1.done; childrenForNode_3_1 = childrenForNode_3.next()) {
                    var child = childrenForNode_3_1.value;
                    allSelected = ListWrapper.findIndexComplex(this.state.selection, child) !== -1
                        && allSelected;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (childrenForNode_3_1 && !childrenForNode_3_1.done && (_a = childrenForNode_3.return)) _a.call(childrenForNode_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            if (!isSelected) {
                if (allSelected) {
                    this.state.selection.push(parent);
                }
            }
            else {
                if (!allSelected) {
                    var /** @type {?} */ parentIndex_1 = ListWrapper.findIndexComplex(this.state.selection, parent);
                    this.state.selection = this.state.selection
                        .filter(function (val, index) { return index !== parentIndex_1; });
                }
            }
            this.oHandleOutlineRowToggleToParent(currentItem.$$parentItem, isSelected);
        }
        var e_3, _a;
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    Datatable2Component.prototype.onDnDRowDrop = /**
     * See AWDataTable
     *
     * @param {?} origPos
     * @param {?} newPos
     * @param {?} dropPos
     * @return {?}
     */
    function (origPos, newPos, dropPos) {
        if (isPresent(this.dataSource)) {
            console.log('Dropping row #: ', origPos + ' ' + dropPos + ' row #: ' + newPos);
            this.dataSource.reorderRows(origPos, newPos, dropPos);
        }
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    Datatable2Component.prototype.onOutlineExpandChange = /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ item = event.item;
        // We dont really need to store a state form outline locally as we are using the same object
        // reference
        // this.state.outlineState = this.outlineState.expansionStates;
        if (this.canUseForDetailRow(item)) {
            this.detailRowExpansionState.toggle(item);
        }
    };
    /**
     * See AWDataTable
     *
     *
     */
    /**
     * See AWDataTable
     *
     *
     * @return {?}
     */
    Datatable2Component.prototype.sortSingle = /**
     * See AWDataTable
     *
     *
     * @return {?}
     */
    function () {
        if (isPresent(this.list) && isPresent(this.sortColumn)) {
            assert(isPresent(this.sortColumn.key), 'Invalid column to sort');
            this.dataSource.sort(this.sortColumn.key, this.sortColumn.sortOrder);
            this.onSort.emit({
                field: this.sortColumn.key,
                order: this.sortColumn.sortOrder
            });
        }
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @return {?}
     */
    Datatable2Component.prototype.handleDataChange = /**
     * See AWDataTable
     *
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.state.sortKey || this.sortColumn) {
            if (!this.sortColumn && this.columns) {
                this.sortColumn = this.columns.find(function (col) { return col.key === _this.state.sortKey; });
            }
        }
        this.updateDataToRender();
        this.valueChange.emit(this.list);
    };
    /**
     * @param {?=} datasource
     * @return {?}
     */
    Datatable2Component.prototype.updateDataToRender = /**
     * @param {?=} datasource
     * @return {?}
     */
    function (datasource) {
        this.dataToRender = datasource || this.list;
        // this.changeDetector.markForCheck();
        this.changeDetector.detectChanges();
    };
    /**
     * Updates current immutable list and trigger change detection. Need to wrap it with
     * setTimeout as the change can easily come after view checked and this would result some errors
     *
     * @param {?} newList
     * @return {?}
     */
    Datatable2Component.prototype.updateList = /**
     * Updates current immutable list and trigger change detection. Need to wrap it with
     * setTimeout as the change can easily come after view checked and this would result some errors
     *
     * @param {?} newList
     * @return {?}
     */
    function (newList) {
        var _this = this;
        setTimeout(function () {
            _this.list = newList;
            _this.handleDataChange();
        });
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.reset = /**
     * @return {?}
     */
    function () {
        this.sortColumn = null;
        this.updateDataToRender();
    };
    /**
     * See AWDataTable
     */
    /**
     * See AWDataTable
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.isHeaderSelected = /**
     * See AWDataTable
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isBlank(this.state.headerSelection)) {
            return false;
        }
        var /** @type {?} */ colMatched = item.key || item.label;
        var /** @type {?} */ currentCol = this.state.headerSelection.key || this.state.headerSelection.label;
        return colMatched === currentCol;
    };
    /**
     *
     * See AWDataTable
     *
     */
    /**
     *
     * See AWDataTable
     *
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.isBodyCellSelected = /**
     *
     * See AWDataTable
     *
     * @param {?} column
     * @param {?} item
     * @return {?}
     */
    function (column, item) {
        var /** @type {?} */ lookupKey = {
            col: column.key || column.label,
            item: item
        };
        return isPresent(this.state.selection) &&
            ListWrapper.findIndexComplex(this.state.selection, lookupKey) !== -1;
    };
    /**
     *  See AWDataTable
     *
     */
    /**
     *  See AWDataTable
     *
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.isRowSelected = /**
     *  See AWDataTable
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.hasLeadingSelectColumn() && isPresent(this.state.selection)) {
            if (this.selectionMode === 'multi') {
                return ListWrapper.findIndexComplex(this.state.selection, item) !== -1;
            }
            else if (this.selectionMode === 'single') {
                return equals(this.state.selection, item);
            }
        }
        return false;
    };
    /**
     *
     * Do we have data to render Used inside template to tell if we should use the NoData template
     *
     */
    /**
     *
     * Do we have data to render Used inside template to tell if we should use the NoData template
     *
     * @return {?}
     */
    Datatable2Component.prototype.isEmpty = /**
     *
     * Do we have data to render Used inside template to tell if we should use the NoData template
     *
     * @return {?}
     */
    function () {
        return isBlank(this.dataToRender) || (this.dataToRender.length === 0);
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.hasFrozenColumns = /**
     * @return {?}
     */
    function () {
        return isPresent(this.frozenColumns) && this.frozenColumns.length > 0;
    };
    /**
     * See AWDataTable
     */
    /**
     * See AWDataTable
     * @return {?}
     */
    Datatable2Component.prototype.hasInvisibleSelectionColumn = /**
     * See AWDataTable
     * @return {?}
     */
    function () {
        return this.hasLeadingSelectColumn() && !this.showSelectionColumn;
    };
    /**
     *
     * See AWDataTable
     *
     */
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    Datatable2Component.prototype.hasLeadingSelectColumn = /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    function () {
        return this.selectionMode !== 'none' && this.selectionMode !== 'cell';
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.visibleColumns = /**
     * @return {?}
     */
    function () {
        return this.columns ? this.columns.filter(function (c) { return c.isVisible; }) : [];
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} direction
     * @return {?}
     */
    Datatable2Component.prototype.sortOrderingForString = /**
     * See AWDataTable
     *
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        if (isBlank(direction) || direction === 'ascending') {
            return 1;
        }
        if (isBlank(direction) || direction === 'descending') {
            return -1;
        }
        // todo: log bad key
        return 1;
    };
    /**
     * @param {?} direction
     * @return {?}
     */
    Datatable2Component.prototype.sortOrderingForNumber = /**
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        if (isBlank(direction) || direction === 1) {
            return 'ascending';
        }
        if (isBlank(direction) || direction === -1) {
            return 'descending';
        }
        // todo: log bad key
        return 'ascending';
    };
    /**
     * See AWDataTable
     *
     */
    /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    Datatable2Component.prototype.toggleAllColumns = /**
     * See AWDataTable
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ currentItems = this.dataToRender || [];
        var /** @type {?} */ selectedObject = this.state.selection || [];
        if (selectedObject.length >= currentItems.length) {
            this.state.selection = [];
        }
        else {
            this.state.selection = [];
            this.state.selection = __spread(currentItems);
        }
    };
    /**
     *
     * See AWDataTable
     *
     */
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    Datatable2Component.prototype.isToggleAllColumnSelected = /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ currentItems = this.dataToRender || [];
        var /** @type {?} */ selectedObject = this.state.selection || [];
        return currentItems.length > 0 && selectedObject.length >= currentItems.length;
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.isToggleAllColumnDisabled = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ currentItems = this.dataToRender || [];
        return currentItems.length === 0;
    };
    /**
     *
     * Used by template to decide if we need to render DetailRow template. We need to have
     * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
     * check if the item that is about to be rendered is eligible for detail row
     *
     */
    /**
     *
     * Used by template to decide if we need to render DetailRow template. We need to have
     * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
     * check if the item that is about to be rendered is eligible for detail row
     *
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.showDetailColumn = /**
     *
     * Used by template to decide if we need to render DetailRow template. We need to have
     * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
     * check if the item that is about to be rendered is eligible for detail row
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.canUseForDetailRow(item) && this.detailRowExpansionState.isExpanded(item)) {
            return true;
        }
        return false;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.canUseForDetailRow = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return isPresent(this.rowDetailColumn) &&
            (/** @type {?} */ (this.rowDetailColumn)).showDetailRow(item);
    };
    /**
     *
     * See AWDataTable
     *
     */
    /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    Datatable2Component.prototype.isOutline = /**
     *
     * See AWDataTable
     *
     * @return {?}
     */
    function () {
        return isPresent(this.children);
    };
    /**
     *
     * When dealing with detail column (detail row) and outline all together we need have a
     * mechanism to tell to the outline "don't render the next level of items" and use detail row.
     * So certain item type needs to be skipped.
     *
     * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
     * if we should skip next level.
     *
     */
    /**
     *
     * When dealing with detail column (detail row) and outline all together we need have a
     * mechanism to tell to the outline "don't render the next level of items" and use detail row.
     * So certain item type needs to be skipped.
     *
     * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
     * if we should skip next level.
     *
     * @param {?} item
     * @return {?}
     */
    Datatable2Component.prototype.skipOutlineItem = /**
     *
     * When dealing with detail column (detail row) and outline all together we need have a
     * mechanism to tell to the outline "don't render the next level of items" and use detail row.
     * So certain item type needs to be skipped.
     *
     * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
     * if we should skip next level.
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.canUseForDetailRow(item);
    };
    /**
     *
     * See AWDaTable
     *
     */
    /**
     *
     * See AWDaTable
     *
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    Datatable2Component.prototype.getValue = /**
     *
     * See AWDaTable
     *
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    function (data, field) {
        return FieldPath.getFieldValue(data, field);
    };
    /**
     * @return {?}
     */
    Datatable2Component.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        if (this.columnsSubscription) {
            this.columnsSubscription.unsubscribe();
        }
    };
    Datatable2Component.decorators = [
        { type: Component, args: [{
                    selector: 'aw-datatable2',
                    template: "<!--\n    This template focus only on header and body rendering.\n\n    This datatable also supports frozen column and for this rendering it is pretty much transparent\n    as it received sets of column that it needs to render from the TableWrapper.\n\n    TableWrapper in case of frozen columns calls #headerRows and #bodyRows templates twice to\n    render to separate tables where one has frozen columns and another one has the rest and its\n    scrollable\n-->\n\n<aw-dt-wrapper #dtWrapper>\n    <ng-template #headingArea>\n        <ng-content select=\"aw-dt-header2\"></ng-content>\n    </ng-template>\n\n    <ng-template #headerRows let-colsToRender let-frozenView=\"frozenColumns\">\n        <ng-container\n            *ngTemplateOutlet=\"header; context:{$implicit: colsToRender, frozen:frozenView }\">\n        </ng-container>\n    </ng-template>\n\n    <ng-template #bodyRows let-colsToRender>\n        <ng-template [ngIf]=\"isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyOutline; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n        <ng-template [ngIf]=\"!isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyPlain; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n    </ng-template>\n</aw-dt-wrapper>\n\n\n<!--\n    Each rendering column has its own renderTemplate which define how things should be render.\n    Based on different column types this code should be transparent as we dont care on this\n    level what kind of column we are rendering.\n\n    Later on when we will support single/multi selection, this will be just another column extending\n    DTColumn and providing its own template\n\n    We pass into this template if we are rendering header, subHeader, or data\n-->\n<ng-template #header let-colsToRender let-frozen=\"frozen\">\n    <tr>\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\"\n                     let-columnIndex=\"index\">\n\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:false,\n                columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n\n    <tr *ngIf=\"showSubHeader\">\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:true}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n<ng-template #bodyPlain let-colsToRender>\n\n    <tbody [ngClass]=\"{'dt-content dt-data-cells ': true, 'dt-is-hoverable-row': rowHover}\">\n\n    <ng-template ngFor let-rowData [ngForOf]=\"dataToRender\" let-even=\"even\" let-odd=\"odd\"\n                 let-rowIndex=\"index\" [ngForTrackBy]=\"rowTrackBy\">\n\n        <ng-container *ngTemplateOutlet=\"rowTemplate; context:{$implicit: rowData, even:even,\n                                          odd:odd, rowIndex:rowIndex, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n\n<ng-template #bodyOutline let-colsToRender>\n    <tbody #outlineFor awOutlineFor [list]=\"dataToRender\"\n           [context]=\"context\"\n           [indentationPerLevel]=\"indentationPerLevel\"\n           [pushRootSectionOnNewLine]=\"pushRootSectionOnNewLine\"\n           [children]=\"children\" [expandAll]=\"expandAll\"\n           [state]=\"outlineState\"\n           [ngClass]=\"{'dt-content dt-data-cells ': true,\n                           'dt-is-hoverable-row': rowHover}\"\n           (onExpandChange)=\"onOutlineExpandChange($event)\">\n\n    <ng-template #outline let-rowData let-nestingLevel=\"nestingLevel\" let-rowIndex=\"rowIndex\">\n        <ng-container *ngTemplateOutlet=\"rowTemplate;\n                                context:{$implicit: rowData, nestingLevel:nestingLevel, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n<!--\n    Default template that is display when there are no data\n-->\n<ng-template #noData>\n    <tr *ngIf=\"isEmpty()\" class=\" dt-emptymessage-row\"\n        [style.visibility]=\"loading ? 'hidden' : 'visible'\">\n\n        <td [attr.colspan]=\"visibleColumns().length\" class=\"dt-emptymessage\">\n            <span *ngIf=\"!emptyMessageTemplate\">{{emptyMessage}}</span>\n            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n<!--\n    Template that renders actual row. Renders both header and body column. Each rendered\n    column has its own template called rendererTemplate that has all things that needs to be\n    rendered and we just tell the template if we are rendering header, subheader or body\n-->\n<ng-template #rowTemplate let-rowData let-even=\"event\" let-odd=\"odd\" let-rowIndex=\"rowIndex\"\n             let-nestingLevel=\"nestingLevel\" let-colsToRender=\"colsToRender\">\n\n\n    <tr #rowElement dtDraggableRow [dndRowIndex]=\"rowIndex\"\n        class=\"dt-body-row\"\n        (click)=\"onHandleRowClicked($event, rowData)\"\n        [attr.nestingLevel]=\"nestingLevel\"\n        [ngClass]=\"{'dt-even-row': even, 'dt-odd-row': odd,\n            'dt-row-selected': isRowSelected(rowData),\n            'dt-row-draggable': dndRowEnabled,\n            'dt-root-section': nestingLevel === 0 }\">\n\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-colIndex=\"index\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:rowIndex,\n                    nestingLevel:nestingLevel}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n",
                    styles: [".w-datatable{position:relative;display:block;box-sizing:border-box}.w-datatable table{border-collapse:collapse;width:100%;table-layout:fixed}.w-datatable tbody,.w-datatable td,.w-datatable th{outline:0}.dt-cell-def,.dt-cell-def-selectable{border:1px solid transparent;padding:17px 16px;box-sizing:border-box}.dt-cell-def-selectable{cursor:pointer;width:100%;height:100%}th .dt-cell-def-selectable{border-width:4px 1px 1px;padding:14px 16px 17px}td .dt-cell-def-selectable{border-width:0 1px 0 5px;padding:17px 16px 17px 13px}.dt-data-cells tr.dt-is-highlight,.dt-data-cells tr.dt-is-hover{border-color:inherit;font-weight:inherit;cursor:pointer}.w-datatable-rtl{direction:rtl}.w-datatable-rtl.w-datatable-rtl.w-datatable thead th{text-align:right}.dt-root-section .dt-cell-def,.dt-root-section .dt-cell-def-selectable{background-color:#f3f6f8;padding:10px 16px;border-bottom-color:transparent;border-right-color:transparent}.dt-plain-layout .dt-is-active,.dt-plain-layout .dt-is-default,.dt-plain-layout .dt-is-highlight,.dt-plain-layout .dt-is-hover,.dt-plain-layout .dt-is-hoverable-row{border-right-color:transparent}.dt-is-active,.dt-is-default,.dt-is-highlight,.dt-is-hover,.dt-is-hoverable-row{border:1px solid #d7d7d7;background-color:#fff;color:#363636}.dt-row-selected td{background-color:rgba(238,255,238,.71)}.dt-is-active{border-color:#065d9c;color:#199de0}.dt-is-highlight{background-color:rgba(65,117,5,.18)}.dt-is-hidden{display:none}.dt-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none}.dt-u-sortable{cursor:pointer}"],
                    providers: [
                        ObjectUtils,
                        OutlineState,
                        { provide: DATA_SOURCE, useClass: DT2DataSource, deps: [DataProviders, DataFinders] },
                    ],
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    Datatable2Component.ctorParameters = function () { return [
        { type: Environment },
        { type: ElementRef },
        { type: DT2DataSource, decorators: [{ type: Inject, args: [DATA_SOURCE,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: OutlineState },
        { type: NgZone },
        { type: Injector }
    ]; };
    Datatable2Component.propDecorators = {
        list: [{ type: Input }],
        destinationClass: [{ type: Input }],
        tableStyleClass: [{ type: Input }],
        bodyClassFn: [{ type: Input }],
        isRowSelectable: [{ type: Input }],
        showTableHeader: [{ type: Input }],
        pivotalLayout: [{ type: Input }],
        context: [{ type: Input }],
        initialSortOrder: [{ type: Input }],
        initialSortKey: [{ type: Input }],
        displayRowSize: [{ type: Input }],
        pageSize: [{ type: Input }],
        dataSource: [{ type: Input }],
        emptyMessage: [{ type: Input }],
        rowTrackBy: [{ type: Input }],
        rowHover: [{ type: Input }],
        loading: [{ type: Input }],
        selectionMode: [{ type: Input }],
        loadingIcon: [{ type: Input }],
        indentDetailRow: [{ type: Input }],
        indentationPerLevel: [{ type: Input }],
        showSubHeader: [{ type: Input }],
        children: [{ type: Input }],
        showExpansionControl: [{ type: Input }],
        expandAll: [{ type: Input }],
        pushRootSectionOnNewLine: [{ type: Input }],
        showRowDetailExpansionControl: [{ type: Input }],
        showSelectionColumn: [{ type: Input }],
        showSelectAll: [{ type: Input }],
        showGlobalSearch: [{ type: Input }],
        scrollWidth: [{ type: Input }],
        dndRowEnabled: [{ type: Input }],
        onSort: [{ type: Output }],
        onRowClick: [{ type: Output }],
        onRowSelectionChange: [{ type: Output }],
        onCellChange: [{ type: Output }],
        onHeaderSelection: [{ type: Output }],
        header: [{ type: ContentChild, args: [DTHeaderComponent2,] }],
        emptyMessageTemplate: [{ type: ContentChild, args: ['noDataTempl',] }],
        headerTemplate: [{ type: ContentChild, args: ['dtHeader',] }],
        subHeaderTemplate: [{ type: ContentChild, args: ['dtSubHeader',] }],
        bodyTemplate: [{ type: ContentChild, args: ['dtBody',] }],
        headerFilterTemplate: [{ type: ContentChild, args: ['headerFilter',] }],
        colsQuery: [{ type: ContentChildren, args: [DTColumn2Component,] }],
        rowDetailColumn: [{ type: ContentChild, args: [DTDetailRowComponent,] }],
        valueChange: [{ type: Output }],
        classList: [{ type: HostBinding, args: ['class',] }],
        state: [{ type: Input }]
    };
    return Datatable2Component;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Please see datatable for more detail description. But the main goal of this wrapper to remove
 * all the common surrounding parts around the datatable and make sure DT can focus only actual
 * header and body structure
 *
 * It is expected that wrapper also provides some code for the sliding up panel containing
 * buttons and other actions that will be used during editing
 *
 *
 * Todo: Extract the expand logic out into some directive or component or just a class
 *
 */
var DTWrapper = /** @class */ (function (_super) {
    __extends(DTWrapper, _super);
    function DTWrapper(env, render, thisElement, domUtils, platformId, dt) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.render = render;
        _this.thisElement = thisElement;
        _this.domUtils = domUtils;
        _this.platformId = platformId;
        _this.dt = dt;
        /**
         * Color that is used by full screen div overlay to create expanding effect which needs to have
         * little tent;
         *
         */
        _this.expandColorFrom = '#f3f3f3';
        /**
         * Color that is used to set after we are in the full screen so our overlay div hide everything
         * on the page
         *
         */
        _this.expandColorTo = '#FFFFFF';
        /**
         * In order to debounce the typing we need to use subject
         *
         */
        _this.searchTerms = new Subject();
        /**
         *  Specifies if we are in viewing/editing mode that can browse whole dataset lazily
         *
         */
        _this.isFullScreenMode = false;
        /**
         * Tells if we can support full screen mode - only available for the browser
         *
         */
        _this.supportFullScreen = true;
        return _this;
    }
    /**
     * @return {?}
     */
    DTWrapper.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.querySubscription = this.searchTerms.pipe(
        // wait 300ms after each keystroke before considering the term
        debounceTime(300), 
        // ignore new term if same as previous term
        distinctUntilChanged(), switchMap(function (term) { return of(term); })).subscribe(function (term) {
            if (term) {
                _this.dt.dataSource.find(term);
            }
        });
        this.loadingSub = this.dt.valueChange
            .subscribe(function (data) { return _this.loadingFinished(); });
    };
    /**
     * Iterates over all columns marked as frozen and retrieve a width so we can update
     * parent div
     *
     */
    /**
     * Iterates over all columns marked as frozen and retrieve a width so we can update
     * parent div
     *
     * @return {?}
     */
    DTWrapper.prototype.calculateFrozenWidth = /**
     * Iterates over all columns marked as frozen and retrieve a width so we can update
     * parent div
     *
     * @return {?}
     */
    function () {
        if (!this.dt.hasFrozenColumns()) {
            return null;
        }
        var /** @type {?} */ fWidth = 0;
        this.dt.frozenColumns.forEach(function (col) {
            if (col.maxWidthPx > 0) {
                fWidth += col.widestCell;
            }
            else {
                fWidth += parseInt(col.width);
            }
        });
        return fWidth;
    };
    /**
     * When having two separate tables we need to make sure that rows of the tables are aligned.
     *
     * Therefore this method takes first column from each table read the height of the rows and set
     * the max height to both rows.
     *
     *
     */
    /**
     * When having two separate tables we need to make sure that rows of the tables are aligned.
     *
     * Therefore this method takes first column from each table read the height of the rows and set
     * the max height to both rows.
     *
     *
     * @param {?} frozenView
     * @param {?} unFrozenView
     * @return {?}
     */
    DTWrapper.prototype.alignTablesHeights = /**
     * When having two separate tables we need to make sure that rows of the tables are aligned.
     *
     * Therefore this method takes first column from each table read the height of the rows and set
     * the max height to both rows.
     *
     *
     * @param {?} frozenView
     * @param {?} unFrozenView
     * @return {?}
     */
    function (frozenView, unFrozenView) {
        assert(isPresent(frozenView) && isPresent(frozenView), 'Cant align table views as one of the view is undefined');
        var /** @type {?} */ frozenRows = frozenView.querySelectorAll('table tr');
        var /** @type {?} */ unFrozenRows = unFrozenView.querySelectorAll('table tr');
        assert(frozenRows.length === unFrozenRows.length, 'Frozen Column: Two tables does not much!');
        Array.from(frozenRows).forEach(function (frozen, index) {
            var /** @type {?} */ h = Math.max(frozen.offsetHeight, unFrozenRows[index].offsetHeight);
            frozen.style.height = h + 'px';
            unFrozenRows[index].style.height = h + 'px';
        });
    };
    /**
     * @return {?}
     */
    DTWrapper.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.initFullScreen();
    };
    /**
     * @return {?}
     */
    DTWrapper.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        if (this.dt.hasFrozenColumns()) {
            var /** @type {?} */ frozenView = this.thisElement.nativeElement.querySelector('.dt-body-frozen');
            var /** @type {?} */ unFrozenView = this.thisElement.nativeElement.querySelector('.dt-body-unfrozen');
            var /** @type {?} */ frozenWidth = this.calculateFrozenWidth();
            frozenView.style.width = frozenWidth + 'px';
            if (isPresent(unFrozenView)) {
                // include border and create indent effect by having 1px white space
                unFrozenView.style.left = (frozenWidth + 2) + 'px';
                unFrozenView.style.width = unFrozenView.parentElement.offsetWidth
                    - frozenView.offsetWidth + 'px';
                this.alignTablesHeights(frozenView, unFrozenView);
            }
        }
    };
    /**
     * @return {?}
     */
    DTWrapper.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        if (isPresent(this.querySubscription)) {
            this.querySubscription.unsubscribe();
        }
        if (isPresent(this.loadingSub)) {
            this.loadingSub.unsubscribe();
        }
    };
    /**
     * FULL SCREEN MODE methods
     */
    /**
     *
     * When fullscreen functionality is enabled this method switches between norml and full screen
     * mode
     *
     */
    /**
     *
     * When fullscreen functionality is enabled this method switches between norml and full screen
     * mode
     *
     * @param {?} event
     * @return {?}
     */
    DTWrapper.prototype.toggleFullScreen = /**
     *
     * When fullscreen functionality is enabled this method switches between norml and full screen
     * mode
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isFullScreenMode) {
            this.closeFullScreen(event);
        }
        else {
            this.openFullScreen(event);
        }
    };
    /**
     * To push this component to full screen mode or maybe full page mode we need run following:
     *
     *  - Execute expand transformation, where we have additional overlay div that we slowly expand
     *  and this creates impression the DT is expanding
     *
     *  - apply full-screen class on top host element  - in this case its DataTable to switch
     *  to absolute positioning
     *
     *  - make sure we are scrolled all the way up
     *
     *  - hide all the elements on the page so their dimension don't interfere with this table.
     *
     *
     */
    /**
     * To push this component to full screen mode or maybe full page mode we need run following:
     *
     *  - Execute expand transformation, where we have additional overlay div that we slowly expand
     *  and this creates impression the DT is expanding
     *
     *  - apply full-screen class on top host element  - in this case its DataTable to switch
     *  to absolute positioning
     *
     *  - make sure we are scrolled all the way up
     *
     *  - hide all the elements on the page so their dimension don't interfere with this table.
     *
     *
     * @param {?} event
     * @return {?}
     */
    DTWrapper.prototype.openFullScreen = /**
     * To push this component to full screen mode or maybe full page mode we need run following:
     *
     *  - Execute expand transformation, where we have additional overlay div that we slowly expand
     *  and this creates impression the DT is expanding
     *
     *  - apply full-screen class on top host element  - in this case its DataTable to switch
     *  to absolute positioning
     *
     *  - make sure we are scrolled all the way up
     *
     *  - hide all the elements on the page so their dimension don't interfere with this table.
     *
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.isFullScreenMode = true;
        this.runExpandEffect();
        this.originalScrollPosition = window.pageYOffset;
        window.scroll(0, 0);
        this.toggleFullScreenOnDT(true);
        // mark my element in the path that needs to stay
        var /** @type {?} */ parentNode = this.thisElement.nativeElement.parentNode;
        while (isPresent(parentNode) && parentNode.tagName !== 'BODY') {
            parentNode.classList.add('u-full-screen-element');
            parentNode = parentNode.parentNode;
        }
        this.hideNonFullScreenElement(document.body);
        this.dt.state.limit = Math.round(this.calculateLimit());
        this.dt.dataSource.fetch(this.dt.state);
        // once loaded set back correct page size we use when loading data
        this.dt.state.limit = this.dt.pageSize;
    };
    /**
     *
     * The same like above method (openFullScreen) but in reverse order.
     *
     */
    /**
     *
     * The same like above method (openFullScreen) but in reverse order.
     *
     * @param {?} event
     * @return {?}
     */
    DTWrapper.prototype.closeFullScreen = /**
     *
     * The same like above method (openFullScreen) but in reverse order.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.isFullScreenMode = false;
        this.showNonFullScreenElement();
        this.runCollapseEffect();
        this.toggleFullScreenOnDT(false);
        this.dt.dataSource.state.limit = this.dt.dataSource.state.displayLimit;
        this.dt.dataSource.state.offset = 0;
        this.dt.dataSource.fetch(this.dt.dataSource.state);
        setTimeout(function () {
            window.scroll(0, _this.originalScrollPosition);
        }, 300);
    };
    /**
     * Creates animation effect to make it feel like the element (in this case DT) is expanding
     * from the middle to the full page mode.
     *
     * We take the dimension of the table then it is scaled slowly to the full page
     * @return {?}
     */
    DTWrapper.prototype.runExpandEffect = /**
     * Creates animation effect to make it feel like the element (in this case DT) is expanding
     * from the middle to the full page mode.
     *
     * We take the dimension of the table then it is scaled slowly to the full page
     * @return {?}
     */
    function () {
        var _this = this;
        this.dtBoundingClientRect = this.thisElement.nativeElement.getBoundingClientRect();
        this.updateElement();
        this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorFrom;
        this.dtFullScreenOverlay.nativeElement.style.opacity = 1;
        this.applyTransformation(true);
        setTimeout(function () {
            _this.dtFullScreenOverlay.nativeElement.style.backgroundColor = _this.expandColorTo;
        }, 300);
    };
    /**
     * Applies the transformation and scale the helper div (overlay) down to make it look like
     * it collapses
     * @return {?}
     */
    DTWrapper.prototype.runCollapseEffect = /**
     * Applies the transformation and scale the helper div (overlay) down to make it look like
     * it collapses
     * @return {?}
     */
    function () {
        var _this = this;
        this.updateElement();
        this.applyTransformation(false);
        setTimeout(function () {
            _this.updateElement();
            _this.dtFullScreenOverlay.nativeElement.style.opacity = 0;
        }, 200);
        setTimeout(function () {
            _this.updateElement(_this.dtBoundingClientRect.left, _this.dtBoundingClientRect.top, 0, 0);
        }, 400);
    };
    /**
     * DFS  - to go thru all the element under BODY and remove them from the page.
     *
     * @param {?} parentElement
     * @return {?}
     */
    DTWrapper.prototype.hideNonFullScreenElement = /**
     * DFS  - to go thru all the element under BODY and remove them from the page.
     *
     * @param {?} parentElement
     * @return {?}
     */
    function (parentElement) {
        if (this.thisElement.nativeElement.parentNode === parentElement) {
            return;
        }
        for (var /** @type {?} */ i = 0; i < parentElement.children.length; i++) {
            var /** @type {?} */ element = parentElement.children[i];
            if (this.needTraverseDown(element)) {
                this.hideNonFullScreenElement(element);
            }
            else if (!element.classList.contains('dt-full-screen')) {
                element.classList.add('u-fs-element-out');
            }
        }
    };
    /**
     * Put all the element that were previously removed by hideNonFullScreenElement() back
     * @return {?}
     */
    DTWrapper.prototype.showNonFullScreenElement = /**
     * Put all the element that were previously removed by hideNonFullScreenElement() back
     * @return {?}
     */
    function () {
        Array.from(document.querySelectorAll('.u-fs-element-out'))
            .forEach(function (elem) { return elem.classList.remove('u-fs-element-out'); });
    };
    /**
     * \@Internal
     *
     * @param {?} element
     * @return {?}
     */
    DTWrapper.prototype.needTraverseDown = /**
     * \@Internal
     *
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return isPresent(element) && element.tagName !== 'SCRIPT' &&
            element.classList.contains('u-full-screen-element') &&
            !element.classList.contains('dt-full-screen');
    };
    /**
     * When we enter full screen /page mode when need to calculate how many rows to load initially
     *
     * @return {?}
     */
    DTWrapper.prototype.calculateLimit = /**
     * When we enter full screen /page mode when need to calculate how many rows to load initially
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ browserH = this.domUtils.browserDimentions().height;
        var /** @type {?} */ rowH = this.dt.el.nativeElement.querySelector('tbody tr:first-child').offsetHeight;
        return (isPresent(rowH) && rowH > 0) ? (browserH / rowH) + 20 : 50;
    };
    /**
     * \@Internal
     *
     * @param {?=} l
     * @param {?=} t
     * @param {?=} w
     * @param {?=} h
     * @return {?}
     */
    DTWrapper.prototype.updateElement = /**
     * \@Internal
     *
     * @param {?=} l
     * @param {?=} t
     * @param {?=} w
     * @param {?=} h
     * @return {?}
     */
    function (l, t, w, h) {
        if (l === void 0) { l = this.dtBoundingClientRect.left; }
        if (t === void 0) { t = this.dtBoundingClientRect.top; }
        if (w === void 0) { w = this.dtBoundingClientRect.width; }
        if (h === void 0) { h = this.dtBoundingClientRect.height; }
        this.dtFullScreenOverlay.nativeElement.style.left = l + 'px';
        this.dtFullScreenOverlay.nativeElement.style.top = t + 'px';
        this.dtFullScreenOverlay.nativeElement.style.width = w + 'px';
        this.dtFullScreenOverlay.nativeElement.style.height = h + 'px';
    };
    /**
     * \@Internal
     *
     * @param {?} expand
     * @return {?}
     */
    DTWrapper.prototype.applyTransformation = /**
     * \@Internal
     *
     * @param {?} expand
     * @return {?}
     */
    function (expand) {
        var /** @type {?} */ x, /** @type {?} */ y, /** @type {?} */ tx, /** @type {?} */ ty;
        if (expand) {
            x = window.innerWidth / this.dtBoundingClientRect.width;
            y = window.innerHeight / this.dtBoundingClientRect.height;
            tx = (window.innerWidth / 2 - this.dtBoundingClientRect.width / 2
                - this.dtBoundingClientRect.left) / x;
            ty = (window.innerHeight / 2 - this.dtBoundingClientRect.height / 2
                - this.dtBoundingClientRect.top) / y;
        }
        else {
            x = 1;
            y = 1;
            tx = this.dtBoundingClientRect.left;
            ty = this.dtBoundingClientRect.top;
        }
        this.dtFullScreenOverlay.nativeElement.style.transform =
            'scaleX(' + x + ') scaleY(' + y + ') translate3d(' + (tx) + 'px, ' + (ty) + 'px, 0px)';
    };
    /**
     * @return {?}
     */
    DTWrapper.prototype.initFullScreen = /**
     * @return {?}
     */
    function () {
        if (!isPlatformBrowser(this.platformId)) {
            this.supportFullScreen = false;
            return;
        }
        this.render.appendChild(document.body, this.dtFullScreenOverlay.nativeElement);
    };
    /**
     * Applies set of set of css properties to make the DT main component on the page expand to
     * full page mode and back
     *
     * We want to make it with little delay to let other animation finish
     */
    /**
     * Applies set of set of css properties to make the DT main component on the page expand to
     * full page mode and back
     *
     * We want to make it with little delay to let other animation finish
     * @param {?} fullScreen
     * @return {?}
     */
    DTWrapper.prototype.toggleFullScreenOnDT = /**
     * Applies set of set of css properties to make the DT main component on the page expand to
     * full page mode and back
     *
     * We want to make it with little delay to let other animation finish
     * @param {?} fullScreen
     * @return {?}
     */
    function (fullScreen) {
        var _this = this;
        this.dt.el.nativeElement.style.opacity = 0;
        setTimeout(function () {
            if (fullScreen) {
                _this.dt.classList += 'dt-full-screen';
                _this.dt.el.nativeElement.style.opacity = 1;
            }
            else {
                _this.dt.classList = _this.dt.classList.replace('dt-full-screen', '');
                _this.dt.el.nativeElement.style.opacity = 1;
            }
        }, 200);
    };
    /**
     * INFINITE SCROLLING METHODS
     */
    /**
     * Listen for infinite scroll event and request new data from data source
     *
     */
    /**
     * Listen for infinite scroll event and request new data from data source
     *
     * @param {?} event
     * @return {?}
     */
    DTWrapper.prototype.onLazyLoad = /**
     * Listen for infinite scroll event and request new data from data source
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.isLoad) {
            this.dt.state.offset = event.offset;
            this.dt.dataSource.fetch(this.dt.state);
        }
        else {
            var /** @type {?} */ dataProvider = this.dt.dataSource.dataProvider;
            var /** @type {?} */ data = dataProvider.dataChanges.getValue();
            dataProvider.dataChanges.next(data.slice(0, event.offset));
        }
    };
    /**
     * When loading is finished mark loading icon is done so we can hide it. I am using little
     * delay to make the animation visible
     * @return {?}
     */
    DTWrapper.prototype.loadingFinished = /**
     * When loading is finished mark loading icon is done so we can hide it. I am using little
     * delay to make the animation visible
     * @return {?}
     */
    function () {
        var _this = this;
        if (isPresent(this.infiniteScroll)) {
            setTimeout(function () { return _this.infiniteScroll.complete(); }, 200);
        }
    };
    DTWrapper.decorators = [
        { type: Component, args: [{
                    selector: 'aw-dt-wrapper',
                    template: "<div [ngClass]=\"dt.styleClass\" [class.dt-full-screen-mode]=\"isFullScreenMode\"\n     [style.width]=\"dt.width\"\n>\n    <div class=\"dt-loading-overlay\" *ngIf=\"dt.loading\"></div>\n    <div class=\"dt-loading-content\" *ngIf=\"dt.loading\">\n        <i [class]=\"'sap-icon u-dt-spin-icon ' + dt.loadingIcon\"></i>\n    </div>\n\n    <div class=\"dt-header\" *ngIf=\"dt.showTableHeader\">\n        <ng-template *ngIf=\"dt.header; then appDefinedHeader else defaultHeader\"></ng-template>\n    </div>\n\n    <!-- DT BODY with table headers and values -->\n    <div class=\"dt-body-wrapper-view\">\n        <ng-template\n            *ngIf=\"dt.hasFrozenColumns(); then dtBodyWithFrozenColumns else dtBodyNoFrozenColumns\">\n        </ng-template>\n    </div>\n\n    <!--<div class=\"dt-footer\" *ngIf=\"footer\">-->\n    <!--&lt;!&ndash; footerArea&ndash;&gt;-->\n    <!--<ng-content select=\"aw-dt-footer\"></ng-content>-->\n    <!--</div>-->\n</div>\n\n<!-- todo: dont activate this if we reached the end of list - -->\n<aw-infinite-scroll #infiniteScroll *ngIf=\"isFullScreenMode\"\n                    [distance]=\"'10%'\"\n                    [fetchSize]=\"dt.state.limit\"\n                    (onLoad)=\"onLazyLoad($event)\">\n</aw-infinite-scroll>\n\n\n<ng-template #appDefinedHeader>\n    <ng-container *ngTemplateOutlet=\"heading;\"></ng-container>\n</ng-template>\n\n<ng-template #defaultHeader>\n    <div class=\"dt-global-filter\">\n        <span class=\"sap-icon icon-filter\"></span>\n    </div>\n\n    <div class=\"dt-global-actions\">\n        <div class=\"dt-action-combo\">\n            <span *ngIf=\"supportFullScreen\" class=\"sap-icon icon-resize\"\n                  (click)=\"toggleFullScreen($event)\"></span>\n\n            <aw-input-field *ngIf=\"dt.showGlobalSearch\" styleClass=\"dt-table-search\"\n                            [(ngModel)]=\"dt.state.currentSearchQuery\"\n                            placeHolder=\"search\"\n                            icon=\"icon-search\"\n                            (ngModelChange)=\"searchTerms.next($event)\">\n            </aw-input-field>\n            <span class=\"ariba-icon icon-more\"></span>\n        </div>\n    </div>\n</ng-template>\n\n\n<ng-template #dtBodyNoFrozenColumns>\n    <!--\n        For non-frozen case we also need to set TRUE as the view is actually frozen and does not\n        scroll.\n        We use this frozenColumns flag inside DT to properly set column index on the header level\n        columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))\n\n        therefore we need to set true even in this case to return real columnIndex since we dont\n        have the second table.\n    -->\n    <ng-container *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: true }\">\n    </ng-container>\n</ng-template>\n\n<ng-template #dtBodyWithFrozenColumns>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.frozenColumns, frozenColumns: true }\">\n    </ng-container>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: false }\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #dtBody let-columns let-frozenColumns=\"frozenColumns\">\n\n    <div #dtContainer class=\"dt-body-wrapper\"\n         [style.width.px]=\"this.calculateFrozenWidth()\"\n         [class.dt-body-unfrozen]=\"dt.hasFrozenColumns() && !frozenColumns\"\n         [class.dt-body-frozen]=\"dt.hasFrozenColumns() && frozenColumns\"\n    >\n\n        <table [ngClass]=\"dt.tableStyleClass\"\n               [style.width]=\"frozenColumns ? null : dt.scrollWidth\"\n               [class.dt-pivot-layout]=\"dt.pivotalLayout\"\n               [class.dt-plain-layout]=\"!dt.pivotalLayout && !dt.isOutline()\">\n\n            <!-- Render TH header rows-->\n            <thead class=\"dt-thead\">\n                <ng-container *ngTemplateOutlet=\"headerRows; context:{$implicit: columns,frozenColumns:frozenColumns }\">\n                </ng-container>\n            </thead>\n\n            <!--\n                Render data rows. For data rows we need to keep tbody tag inside DT table\n                due to Outline\n             -->\n            <ng-container *ngTemplateOutlet=\"bodyRows; context:{$implicit: columns,  frozenColumns:frozenColumns }\">\n            </ng-container>\n        </table>\n    </div>\n</ng-template>\n\n\n<div #dtFullScreenOverlay class=\"dt-full-screen-overlay u-full-screen-element\"></div>\n",
                    styles: [".dt-footer,.dt-header{text-align:center;padding:.5em .75em;box-sizing:border-box}.dt-footer{border-top:0}.dt-thead tr{border-width:0}.dt-body-wrapper-view{position:relative}.dt-body-wrapper{overflow:hidden;border:1px solid #d7d7d7}.dt-body-wrapper.dt-body-unfrozen{border-left-color:transparent;position:absolute;top:0;overflow-x:auto}.dt-loading-overlay{position:absolute;background-color:#9b9b9b;width:100%;height:100%;opacity:.1;z-index:1}.dt-loading-content{position:absolute;left:50%;top:25%;z-index:2}.dt-header{width:100%;display:flex;flex-flow:row nowrap;justify-content:space-between;color:#363636;border-bottom:1px solid #f1f1f1;margin-bottom:30px}.dt-header .dt-global-filter{flex:0 0;align-items:flex-start;font-size:18px}.dt-header .dt-global-actions{flex:0 0;align-items:flex-end}.dt-header .dt-action-combo{display:flex;flex-flow:row nowrap;color:#7d7d7d}.dt-header .dt-action-combo .ariba-icon,.dt-header .dt-action-combo .sap-icon{margin-left:15px;font-size:20px;align-self:center;cursor:pointer}.dt-header .dt-action-combo .dt-table-search{border-top-color:transparent;border-left-color:transparent;border-right-color:transparent}.dt-header .dt-action-combo .icon-resize{color:#4a4a4a;font-size:16px;line-height:18px;margin-right:15px}.u-dt-spin-icon{display:inline-block;-webkit-animation:2s linear infinite doSpin;animation:2s linear infinite doSpin}@-webkit-keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dt-full-screen-overlay{position:fixed;z-index:100;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transition:all .4s ease-in-out}.dt-full-screen{width:98vw;z-index:120;position:absolute;top:15px;pointer-events:all;transition:opacity .5s ease-in-out}.u-fs-element-out{display:none}"],
                    encapsulation: ViewEncapsulation.None
                },] },
    ];
    /** @nocollapse */
    DTWrapper.ctorParameters = function () { return [
        { type: Environment },
        { type: Renderer2 },
        { type: ElementRef },
        { type: DomUtilsService },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: Datatable2Component, decorators: [{ type: Inject, args: [forwardRef(function () { return Datatable2Component; }),] }] }
    ]; };
    DTWrapper.propDecorators = {
        expandColorFrom: [{ type: Input }],
        expandColorTo: [{ type: Input }],
        heading: [{ type: ContentChild, args: ['headingArea',] }],
        headerRows: [{ type: ContentChild, args: ['headerRows',] }],
        bodyRows: [{ type: ContentChild, args: ['bodyRows',] }],
        footer: [{ type: ContentChild, args: ['footerArea',] }],
        dtFullScreenOverlay: [{ type: ViewChild, args: ['dtFullScreenOverlay',] }],
        infiniteScroll: [{ type: ViewChild, args: ['infiniteScroll',] }]
    };
    return DTWrapper;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * This directive is responsible for checking and setting the widest content width onto
 * Column component as the widestCell property.
 *
 *
 *
 *
 */
var SetCellMaxWidthDirective = /** @class */ (function () {
    function SetCellMaxWidthDirective(element, render, td) {
        this.element = element;
        this.render = render;
        this.td = td;
    }
    /**
     * @return {?}
     */
    SetCellMaxWidthDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    SetCellMaxWidthDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (isPresent(this.maxWidth) && this.maxWidth > 0) {
            var /** @type {?} */ inlineData = this.element.nativeElement.querySelector('.dt-col-cell-data');
            if (isPresent(inlineData)) {
                inlineData.style.whiteSpace = 'nowrap';
                inlineData.style.display = 'inline-block';
                var /** @type {?} */ cellWidth = inlineData.offsetWidth; // td
                inlineData.style.whiteSpace = 'normal';
                inlineData.style.display = 'inline';
                if (!this.isInThresHold(cellWidth)) {
                    return;
                }
                cellWidth += this.tdPadding();
                if (cellWidth > this.td.widthPx) {
                    if (cellWidth < this.maxWidth) {
                        this.td.widestCell = cellWidth > this.td.widestCell ? cellWidth :
                            this.td.widestCell;
                    }
                    else if (cellWidth >= this.maxWidth) {
                        this.td.widestCell = this.maxWidth > this.td.widestCell ? this.maxWidth :
                            this.td.widestCell;
                    }
                }
            }
        }
    };
    /**
     *
     * Is the new width the same as the one already set on the column? If yes then probably
     * new content does not differ that much. We still keep certain threshold as the new content
     * width might differ 1 or 2 pixes depending how set the css.
     *
     * To make sure we resize column only if necessary because it could be original size
     * is 400px but the new one is 401px since somewhere add some extra border we have this
     * safe threshold
     *
     */
    /**
     *
     * Is the new width the same as the one already set on the column? If yes then probably
     * new content does not differ that much. We still keep certain threshold as the new content
     * width might differ 1 or 2 pixes depending how set the css.
     *
     * To make sure we resize column only if necessary because it could be original size
     * is 400px but the new one is 401px since somewhere add some extra border we have this
     * safe threshold
     *
     * @param {?} newWidth
     * @return {?}
     */
    SetCellMaxWidthDirective.prototype.isInThresHold = /**
     *
     * Is the new width the same as the one already set on the column? If yes then probably
     * new content does not differ that much. We still keep certain threshold as the new content
     * width might differ 1 or 2 pixes depending how set the css.
     *
     * To make sure we resize column only if necessary because it could be original size
     * is 400px but the new one is 401px since somewhere add some extra border we have this
     * safe threshold
     *
     * @param {?} newWidth
     * @return {?}
     */
    function (newWidth) {
        if (this.td.widestCell > 0) {
            return Math.abs(this.td.widestCell - newWidth) > 3 && newWidth > this.td.widestCell;
        }
        return true;
    };
    /**
     * @return {?}
     */
    SetCellMaxWidthDirective.prototype.tdPadding = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ computedStyle = getComputedStyle(this.element.nativeElement);
        var /** @type {?} */ cell = parseInt(computedStyle.paddingLeft) || 0;
        cell += parseInt(computedStyle.paddingRight) || 0;
        cell += parseInt(computedStyle.borderRightWidth) || 0;
        cell += parseInt(computedStyle.borderLeftWidth) || 0;
        // plus give it some little space around the text so it nots px to px inner width of the td
        // cuz it could wrap
        cell += 5;
        return cell;
    };
    SetCellMaxWidthDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[maxWidth]'
                },] },
    ];
    /** @nocollapse */
    SetCellMaxWidthDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: DTColumn2Component }
    ]; };
    SetCellMaxWidthDirective.propDecorators = {
        maxWidth: [{ type: Input }]
    };
    return SetCellMaxWidthDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Directive used inside DT in order to support table rows re-ordering. This manages all the
 * D&D necessary logic for this functionality.
 *
 * [dtDraggableRow] is used inside the `rowTemplate` like this:
 *
 *
 * ```html
 *
 * <ng-template #rowTemplate let-rowData let-even='event" let-odd="odd" let-rowIndex="rowIndex"
 *              let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">
 *
 *     <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
 *          class="dt-body-row"
 *
 *
 *
 * ```
 *
 * which enabled or disables based on the used DT binding [dndRowEnabled]. By default its disabled.
 *
 *
 *
 */
var DTDraggableRowDirective = /** @class */ (function () {
    function DTDraggableRowDirective(element, dt, domUtils, ngZone) {
        this.element = element;
        this.dt = dt;
        this.domUtils = domUtils;
        this.ngZone = ngZone;
        /**
         *
         * Tells the directive if we enable middle row zone to create an effect that we are dropping
         * into the row. Used for outline DT mainly.
         *
         */
        this.dropIntoEnabled = false;
        /**
         * Current TR index number
         *
         */
        this.dndRowIndex = 0;
        /**
         * Holds information about our dragging direction UP and DOWN in order to assign correct style
         * that highlights the row at the top or bottom
         *
         */
        this.dragDir = DragDirection.None;
        /**
         * Indicates that we dragged our row and stopped in the middle of the other row
         *
         */
        this.inMiddle = false;
        /**
         *
         * Current drag Y coordinates which is used together with the dragDir when assinging dragging
         * direction.
         *
         */
        this.dragY = 0;
    }
    /**
     * @return {?}
     */
    DTDraggableRowDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.dt.dndRowEnabled) {
            this.setupEventListeners();
        }
    };
    /**
     * @return {?}
     */
    DTDraggableRowDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.dt.dndRowEnabled) {
            this.releaseEventListeners();
        }
    };
    /**
     * Setups listeners and returns handle to them so we can later on unsubscribe.
     * @return {?}
     */
    DTDraggableRowDirective.prototype.setupEventListeners = /**
     * Setups listeners and returns handle to them so we can later on unsubscribe.
     * @return {?}
     */
    function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            _this.eventHandlers = {};
            _this.eventHandlers['mousedown'] = _this.onMouseDownEvent.bind(_this);
            _this.element.nativeElement.addEventListener('mousedown', _this.eventHandlers['mousedown']);
            _this.eventHandlers['dragstart'] = _this.onDragStartEvent.bind(_this);
            _this.element.nativeElement.addEventListener('dragstart', _this.eventHandlers['dragstart']);
            _this.eventHandlers['dragover'] = _this.onDragOverEvent.bind(_this);
            _this.element.nativeElement.addEventListener('dragover', _this.eventHandlers['dragover']);
            _this.eventHandlers['dragleave'] = _this.onDragLeaveEvent.bind(_this);
            _this.element.nativeElement.addEventListener('dragleave', _this.eventHandlers['dragleave']);
            _this.eventHandlers['drop'] = _this.onDropEvent.bind(_this);
            _this.element.nativeElement.addEventListener('drop', _this.eventHandlers['drop']);
            _this.eventHandlers['dragend'] = _this.onDragEndEvent.bind(_this);
            _this.element.nativeElement.addEventListener('dragend', _this.eventHandlers['dragend']);
        });
    };
    /**
     * Removes all the created listeners inside destroy() callback
     * @return {?}
     */
    DTDraggableRowDirective.prototype.releaseEventListeners = /**
     * Removes all the created listeners inside destroy() callback
     * @return {?}
     */
    function () {
        var _this = this;
        DragEvents.forEach(function (name) {
            document.removeEventListener('name', _this.eventHandlers[name]);
        });
    };
    /**
     *
     * This is first event where we:
     *
     *  - Mark element draggable to enable D&D
     *  - Set click position relative to the middle of the current row
     *      This is mainly needed when we are trying to calculate something for
     *      dropInto row (outline)
     *
     * event.target usually contains reference to TD element
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.onMouseDownEvent = /**
     *
     * This is first event where we:
     *
     *  - Mark element draggable to enable D&D
     *  - Set click position relative to the middle of the current row
     *      This is mainly needed when we are trying to calculate something for
     *      dropInto row (outline)
     *
     * event.target usually contains reference to TD element
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.altKey && this.domUtils.hasParent(event.target, '.dt-row-draggable')) {
            this.element.nativeElement.draggable = true;
            var /** @type {?} */ elToBeDragged = this.domUtils.elementDimensions(event.target);
            this.dt.env.setValue('ddClickDeviance', (elToBeDragged.height / 2) - event.offsetY);
        }
        else {
            this.element.nativeElement.draggable = false;
        }
    };
    /**
     * This is second triggered event when the actual dragging starts. Here we need to disable
     * dragged row and save information that are common to a table.
     *
     * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
     * if we would go without it then D&D framework would create a copy of row in disabled state.
     * Now we grab a row with active state and after a 200ms delay we disable the original row.
     *
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.onDragStartEvent = /**
     * This is second triggered event when the actual dragging starts. Here we need to disable
     * dragged row and save information that are common to a table.
     *
     * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
     * if we would go without it then D&D framework would create a copy of row in disabled state.
     * Now we grab a row with active state and after a 200ms delay we disable the original row.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        setTimeout(function () {
            if (isPresent(event.target.classList)) {
                event.target.classList.add('dt-row-dragging');
            }
        }, 200);
        this.dt.env.setValue('isDragging', true);
        this.dt.env.setValue('dndId', this.dndRowIndex);
        event.dataTransfer.setData('text', this.dndRowIndex);
    };
    /**
     *
     * This events happens anytime as we drag over rows. This event triggered after certain
     * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
     *
     * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
     * show a user where we are.
     *
     * Once we know the direction and the drop target is valid we mark the row with correct class
     * that does the trick
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.onDragOverEvent = /**
     *
     * This events happens anytime as we drag over rows. This event triggered after certain
     * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
     *
     * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
     * show a user where we are.
     *
     * Once we know the direction and the drop target is valid we mark the row with correct class
     * that does the trick
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.dataTransfer.dropEffect = 'move';
        if (this.dragY < event.pageY) {
            this.dragDir = DragDirection.Down;
        }
        else if (this.dragY > event.pageY) {
            this.dragDir = DragDirection.Up;
        }
        // dont set again unless its different
        if (this.dragY !== event.pageY) {
            this.dragY = event.pageY;
        }
        if (this.isValidDropTarget(event)) {
            // todo test this preventDefault() so it does not create some sideeffect
            event.preventDefault();
            this.markRowWithClass(event, this.domUtils.closest(event.target, 'tr'));
        }
    };
    /**
     * This is finishing event just before D&D is done. It takes current information and
     * broadcast them to the DT so DT can do necessary row reordering
     *
     *
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.onDropEvent = /**
     * This is finishing event just before D&D is done. It takes current information and
     * broadcast them to the DT so DT can do necessary row reordering
     *
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.clearClasses(event.target.parentElement);
        // event.preventDefault();
        var /** @type {?} */ origIndx = this.dt.env.getValue('dndId');
        var /** @type {?} */ dropPos = this.inMiddle ? DropPosition.Into : (this.dragDir === DragDirection.Up ? DropPosition.Before : DropPosition.After);
        this.dt.onDnDRowDrop(origIndx, this.dndRowIndex, dropPos);
        this.inMiddle = false;
        this.dragY = 0;
    };
    /**
     * Every time we drag over the element we apply some classes to the it. this method does the
     * opposite which is to remove everything so we are ready for the next row
     *
     *
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.onDragLeaveEvent = /**
     * Every time we drag over the element we apply some classes to the it. this method does the
     * opposite which is to remove everything so we are ready for the next row
     *
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ tr = this.domUtils.closest(event.target, 'tr');
        this.clearClasses(tr);
        this.dt.env.deleteValue('dndOnHoldIndex');
    };
    /**
     *
     * This is last event within D&D flow. Mainly used to clean up all the resource that has not
     * been clean up already inside onDropEvent.
     *
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.onDragEndEvent = /**
     *
     * This is last event within D&D flow. Mainly used to clean up all the resource that has not
     * been clean up already inside onDropEvent.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (isPresent(event.target.classList)) {
            event.target.classList.remove('dt-row-dragging');
        }
        this.clearClasses(event.target);
        this.element.nativeElement.draggable = false;
        this.dt.env.deleteValue('isDragging');
        this.dt.env.deleteValue('dndId');
        this.dt.env.deleteValue('ddClickDeviance');
    };
    /**
     * Assign CSS classes to the row to create an highlighting effect to capture current position
     * for the user.
     *
     * Based on the Drag direction we either apply
     * css class that creates a line on top or bottom.  Only for the dropInto functionality we
     * need to calculate some more to identify if we are really in the middle of the row.
     *
     * DropInto:
     * ---------
     *
     * Initially we captured a position (in mousedown) the distance to the middle of the row and
     * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
     * perfect.
     *
     * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
     *      Read center of current row
     *
     * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
     *      Read mouse coordinates relative to current row/td and add to it our deviation.
     *
     *
     * @param {?} event
     * @param {?} activeRow
     * @return {?}
     */
    DTDraggableRowDirective.prototype.markRowWithClass = /**
     * Assign CSS classes to the row to create an highlighting effect to capture current position
     * for the user.
     *
     * Based on the Drag direction we either apply
     * css class that creates a line on top or bottom.  Only for the dropInto functionality we
     * need to calculate some more to identify if we are really in the middle of the row.
     *
     * DropInto:
     * ---------
     *
     * Initially we captured a position (in mousedown) the distance to the middle of the row and
     * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
     * perfect.
     *
     * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
     *      Read center of current row
     *
     * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
     *      Read mouse coordinates relative to current row/td and add to it our deviation.
     *
     *
     * @param {?} event
     * @param {?} activeRow
     * @return {?}
     */
    function (event, activeRow) {
        this.clearClasses(activeRow);
        // Check if drag item is in the middle of other row
        var /** @type {?} */ currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
        var /** @type {?} */ draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
        if (this.dropIntoEnabled) {
            this.inMiddle = Math.abs(currentTrCenter - draggedTrCenter) < 2;
        }
        if (this.inMiddle) {
            activeRow.classList.add(DragDirection.Middle);
        }
        else {
            activeRow.classList.add(this.dragDir);
        }
    };
    /**
     *
     * Drop target must be only another TR and it cannot be the element itself the one we are
     * dragging and it does not make sense to allow to drop to the same position we started from
     *
     * @param {?} event
     * @return {?}
     */
    DTDraggableRowDirective.prototype.isValidDropTarget = /**
     *
     * Drop target must be only another TR and it cannot be the element itself the one we are
     * dragging and it does not make sense to allow to drop to the same position we started from
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ origInx = this.dt.env.getValue('dndId');
        var /** @type {?} */ siblingRow = this.dndRowIndex - origInx;
        return event.target.parentElement.tagName === 'TR' && this.dndRowIndex !== origInx &&
            !(siblingRow === 1 && this.dragDir === DragDirection.Up) &&
            !(siblingRow === -1 && this.dragDir === DragDirection.Down);
    };
    /**
     *  private
     *
     * @param {?} tr
     * @return {?}
     */
    DTDraggableRowDirective.prototype.clearClasses = /**
     *  private
     *
     * @param {?} tr
     * @return {?}
     */
    function (tr) {
        tr.classList.remove('dt-drag-row-top');
        tr.classList.remove('dt-drag-row-bottom');
        tr.classList.remove('dt-drag-row-both');
    };
    /**
     *  private
     *
     * @return {?}
     */
    DTDraggableRowDirective.prototype.dragDirToString = /**
     *  private
     *
     * @return {?}
     */
    function () {
        switch (this.dragDir) {
            case DragDirection.Up:
                return 'Up';
            case DragDirection.Down:
                return 'Down';
            default:
                return 'Not Sure';
        }
    };
    DTDraggableRowDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[dtDraggableRow]'
                },] },
    ];
    /** @nocollapse */
    DTDraggableRowDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Datatable2Component, decorators: [{ type: Inject, args: [forwardRef(function () { return Datatable2Component; }),] }] },
        { type: DomUtilsService },
        { type: NgZone }
    ]; };
    DTDraggableRowDirective.propDecorators = {
        dropIntoEnabled: [{ type: Input }],
        dndRowIndex: [{ type: Input }]
    };
    return DTDraggableRowDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWDatatable2Module = /** @class */ (function () {
    function AWDatatable2Module() {
    }
    AWDatatable2Module.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        Datatable2Component,
                        DTWrapper,
                        DTColumn2Component,
                        DTHeaderComponent2,
                        DTDetailRowComponent,
                        DTDetailRowExpanderComponent,
                        DTMultiSelectColumnComponent,
                        DTSingleSelectColumnComponent,
                        SetCellMaxWidthDirective,
                        DTDraggableRowDirective
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        AWCoreComponentModule,
                        AWCheckBoxModule,
                        AWOutlineForModule,
                        AWRadioButtonModule,
                        AWInputFieldModule
                    ],
                    entryComponents: [
                        DTDetailRowExpanderComponent,
                        DTMultiSelectColumnComponent,
                        DTSingleSelectColumnComponent
                    ],
                    exports: [
                        Datatable2Component,
                        DTColumn2Component,
                        AWOutlineForModule,
                        DTHeaderComponent2,
                        DTDetailRowComponent
                    ],
                    providers: []
                },] },
    ];
    return AWDatatable2Module;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An confirmation header area.
 *
 * See {\@link ConfirmationComponent} for more explanation.
 */
var ConfirmationHeaderComponent = /** @class */ (function () {
    function ConfirmationHeaderComponent() {
    }
    ConfirmationHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-confirmation-header',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    return ConfirmationHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An confirmation header area.
 *
 * See {\@link ConfirmationComponent} for more explanation.
 */
var ConfirmationFooterComponent = /** @class */ (function () {
    function ConfirmationFooterComponent() {
    }
    ConfirmationFooterComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-confirmation-footer',
                    template: '<ng-content></ng-content>'
                },] },
    ];
    return ConfirmationFooterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Confirmation Component is a specific version of the dialog where it supports confirm and cancel
 * functionality. It behaves like a dialog, is modal, and not closable by default.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<ConfirmationComponent>), service.close()
 *
 * Usage:
 *    1.  Using ModalService directly to display a modal popup. This usage is a quick way to show
 *        a confirmation to the user.
 *
 *          this.modalService.open<ConfirmationComponent>(ConfirmationComponent, {
 *                        title: 'Confirmation',
 *                        body: ` Are you sure ? `,
 *                        width: 300,
 *                        onConfirm: () => {
 *                              this.confirmAction();
 *                        },
 *                        onCancel: () => {
 *                              this.cancelAction();
 *                        }
 *           });
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                              <aw-confirmation [title]="'Confirmation'"
 *                                      [(visible)]="display"
 *                                     (onConfirm)="confirmAction()"
 *                                    (onCancel)="cancelAction()">
 *                                       <i class="sap-icon icon-alert"></i>
 *                                       Are you sure you want to delete your hard drive?
 *                            </aw-confirmation>
 *
 *                                   <aw-button [size]="'small'" (click)="open()">
 *                                       Open Confirmation
 *                                   </aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     display: boolean = false;
 *
 *                     confirmAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *
 *                     open() {
 *                        this.display = true;
 *                     }
 *
 *                     confirmAction()  {
 *                        this.confirmAction = "confirmed";
 *                      }
 *
 *                      close() {
 *                         this.display = false;
 *                      }
 *
 *                      cancelAction() {
 *                          this.confirmAction = "canceled";
 *                      }
 *
 *       }
 *
 *
 */
var ConfirmationComponent = /** @class */ (function (_super) {
    __extends(ConfirmationComponent, _super);
    function ConfirmationComponent(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * support two way data binding on visible property.
         */
        _this.visibleChange = new EventEmitter();
        /**
         * Whether there's an x at the top right that makes the dialog closable.
         */
        _this.closable = false;
        /**
         * Event fired when dialog is closed.
         */
        _this.onClose = new EventEmitter();
        /**
         * Event fired when the dialog is opened.
         */
        _this.onOpen = new EventEmitter();
        /**
         * Fired when user clicked on confirm button.
         */
        _this.onConfirm = new EventEmitter();
        /**
         * Fired when user clicked on cancel button.
         */
        _this.onCancel = new EventEmitter();
        _this.width = 400;
        _this.height = 'auto';
        // Todo: internationalize.
        // Todo: internationalize.
        _this.confirmActionLabel = 'Confirm';
        _this.cancelActionLabel = 'Cancel';
        return _this;
    }
    /**
     * open confirmation.
     */
    /**
     * open confirmation.
     * @return {?}
     */
    ConfirmationComponent.prototype.open = /**
     * open confirmation.
     * @return {?}
     */
    function () {
        this.visible = true;
        this.onOpen.emit();
        this.visibleChange.emit(true);
    };
    /**
     * close confirmation.
     */
    /**
     * close confirmation.
     * @return {?}
     */
    ConfirmationComponent.prototype.close = /**
     * close confirmation.
     * @return {?}
     */
    function () {
        this.visible = false;
        this.onClose.emit();
        // Important to make sure change is set on parent binding.
        // Otherwise, the variable and dialog open/close state can be out
        // of sync and we wouldn't trigger change detection.
        this.visibleChange.emit(false);
    };
    /**
     * Does the confirmation have header content?
     */
    /**
     * Does the confirmation have header content?
     * @return {?}
     */
    ConfirmationComponent.prototype.hasHeader = /**
     * Does the confirmation have header content?
     * @return {?}
     */
    function () {
        return isPresent(this.header);
    };
    /**
     * Does the confirmation have footer content?
     */
    /**
     * Does the confirmation have footer content?
     * @return {?}
     */
    ConfirmationComponent.prototype.hasFooter = /**
     * Does the confirmation have footer content?
     * @return {?}
     */
    function () {
        return isPresent(this.footer);
    };
    /**
     * Confirm action.
     */
    /**
     * Confirm action.
     * @return {?}
     */
    ConfirmationComponent.prototype.confirm = /**
     * Confirm action.
     * @return {?}
     */
    function () {
        this.close();
        this.onConfirm.emit();
    };
    /**
     * Cancel action.
     */
    /**
     * Cancel action.
     * @return {?}
     */
    ConfirmationComponent.prototype.cancel = /**
     * Cancel action.
     * @return {?}
     */
    function () {
        this.close();
        this.onCancel.emit();
    };
    ConfirmationComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-confirmation',
                    template: "<aw-dialog [title]=\"title\" [(visible)]=\"visible\"\n           [modal]=\"true\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n           [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onOpen)=\"open()\" (onClose)=\"close()\">\n\n    <aw-dialog-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-confirmation-header\"></ng-content>\n    </aw-dialog-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n\n    <aw-dialog-footer *ngIf=\"hasFooter(); else defaultFooter\">\n        <ng-content select=\"aw-confirmation-footer\"></ng-content>\n    </aw-dialog-footer>\n\n    <ng-template #defaultFooter>\n        <aw-dialog-footer>\n            <aw-button name=\"confirm\" [style]=\"'primary'\" (action)=\"confirm()\">\n                {{confirmActionLabel}}\n            </aw-button>\n\n            <aw-button name=\"cancel\" [style]=\"'secondary'\" (action)=\"cancel()\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n        </aw-dialog-footer>\n    </ng-template>\n\n</aw-dialog>\n",
                    styles: [".confirmation-footer-separator{border-top:1px solid #d7d7d7;height:14px}"]
                },] },
    ];
    /** @nocollapse */
    ConfirmationComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    ConfirmationComponent.propDecorators = {
        title: [{ type: Input }],
        body: [{ type: Input }],
        confirmActionLabel: [{ type: Input }],
        cancelActionLabel: [{ type: Input }],
        visibleChange: [{ type: Output }],
        closable: [{ type: Input }],
        appendTo: [{ type: Input }],
        onClose: [{ type: Output }],
        onOpen: [{ type: Output }],
        onConfirm: [{ type: Output }],
        onCancel: [{ type: Output }],
        header: [{ type: ContentChild, args: [ConfirmationHeaderComponent,] }],
        footer: [{ type: ContentChild, args: [ConfirmationFooterComponent,] }]
    };
    return ConfirmationComponent;
}(ModalContainer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWConfirmationModule = /** @class */ (function () {
    function AWConfirmationModule() {
    }
    AWConfirmationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ConfirmationComponent,
                        ConfirmationHeaderComponent,
                        ConfirmationFooterComponent
                    ],
                    imports: [
                        CommonModule,
                        AWCoreComponentModule,
                        AWDialogModule,
                        AWButtonModule
                    ],
                    entryComponents: [
                        ModalComponent,
                        ConfirmationComponent,
                        ConfirmationHeaderComponent,
                        ConfirmationFooterComponent
                    ],
                    exports: [
                        ConfirmationComponent,
                        ConfirmationHeaderComponent,
                        ConfirmationFooterComponent
                    ],
                    providers: []
                },] },
    ];
    return AWConfirmationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * Container panel providing scrolling functionality for its children. You can configure this
 * container to let it to scroll its content either horizontally, vertically or let the content
 * wrap.
 *
 *
 * Usage is pretty simple:
 *
 *  ### Example using horizontal scroll (default behavior):
 *
 *  ```
 *            <aw-scrollable>
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *
 *  ```
 *
 *  ### Example using vertical scroll:
 *
 *  ```
 *            <aw-scrollable [direction]="'vertical'" [height]="'40vh'">
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *
 * ```
 *
 *  ### Example scrolling is disabled and content wraps and centers:
 *
 *  ```
 *            <aw-scrollable [direction]="'none'" [alignment]="'center'">
 *                  <w-demo-card> Card 1</w-demo-card>
 *                  <w-demo-card> Card 2</w-demo-card>
 *                  <w-demo-card> Card 3</w-demo-card>
 *                  <w-demo-card> Card 4</w-demo-card>
 *                  <w-demo-card> Card 5</w-demo-card>
 *                  <w-demo-card> Card 6</w-demo-card>
 *                  <w-demo-card> Card 7</w-demo-card>
 *                  <w-demo-card> Card 8</w-demo-card>
 *                  <w-demo-card> Card 9</w-demo-card>
 *              </aw-scrollable>
 *  ```
 *
 * ### Height property:
 *
 * When using "horizontal scrolling" it set "flexbox-direction" to "row" where height
 * is set automatically based on its content. The height should be always 100% when using
 * this in parent container.
 *
 * If "vertical scrolling" is used you need to make sure that:
 *   - your parent container sets the boundaries with correctly set width and height
 *   otherwise it will use 100% of the viewport
 *   - if used as standalone you need to limit the height otherwise it will expand to 100% of
 *   the document
 *
 *
 *
 *
 */
var ScrollableContainerComponent = /** @class */ (function (_super) {
    __extends(ScrollableContainerComponent, _super);
    function ScrollableContainerComponent(env, elementRef) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        _this.elementRef = elementRef;
        /**
         * Defines scrolling direction of the container meaning tells which overflow axies will be
         * disabled or enabled.
         *
         * Default value is "horizontal": Here we lock overflow-y and overflow-x set to auto.
         *
         * When scrolling direction is "vertical" please make sure you maintain correct height and
         * width.
         *
         */
        _this.direction = 'horizontal';
        /**
         * Defines how flexbox container items should be aligned. Default behavior is LEFT
         *
         */
        _this.alignment = 'left';
        _this.height = '100%';
        _this.width = '100%';
        return _this;
    }
    /**
     * @return {?}
     */
    ScrollableContainerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initDefault();
    };
    /**
     * Make sure we re-initialize default when Input Bindings changes
     *
     */
    /**
     * Make sure we re-initialize default when Input Bindings changes
     *
     * @param {?} changes
     * @return {?}
     */
    ScrollableContainerComponent.prototype.ngOnChanges = /**
     * Make sure we re-initialize default when Input Bindings changes
     *
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.initDefault();
    };
    /**
     * Initialize default values and Calculates layout and alignment class. The reason for using
     * these utility classes is that we can change the behavior anytime as compared to using
     * directly [style.xxx] bindings.
     *
     * ### Direction flow class:
     *  - u-scrollable-f<direction>
     *
     * ### Alignment class:
     *  - u-scrollable-a<alignment>
     *
     * @return {?}
     */
    ScrollableContainerComponent.prototype.initDefault = /**
     * Initialize default values and Calculates layout and alignment class. The reason for using
     * these utility classes is that we can change the behavior anytime as compared to using
     * directly [style.xxx] bindings.
     *
     * ### Direction flow class:
     *  - u-scrollable-f<direction>
     *
     * ### Alignment class:
     *  - u-scrollable-a<alignment>
     *
     * @return {?}
     */
    function () {
        this.layoutClass = 'u-scrollable-fh';
        if (this.direction === 'vertical') {
            this.layoutClass = 'u-scrollable-fv';
        }
        if (this.direction === 'vertical-row') {
            this.layoutClass = 'u-scrollable-fv-row';
        }
        else if (this.direction === 'both') {
            this.layoutClass = 'u-scrollable-fb';
        }
        else if (this.direction === 'none') {
            this.layoutClass = 'u-scrollable-fn';
        }
        this.layoutClass += ' u-scrollable-a' + this.alignment.substring(0, 1);
        if (isPresent(this.styleClass)) {
            this.layoutClass += " " + this.styleClass;
        }
        // make sure we default width and height to some value in case somebody passes null
        if (isBlank(this.width)) {
            this.width = '100%';
        }
        if (isBlank(this.height)) {
            this.height = '100%';
        }
    };
    /**
     * Tells if the horizontal scrollbar is visible
     *
     */
    /**
     * Tells if the horizontal scrollbar is visible
     *
     * @return {?}
     */
    ScrollableContainerComponent.prototype.hasHorizontalScroll = /**
     * Tells if the horizontal scrollbar is visible
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
        return scrollContainer.scrollWidth > scrollContainer.clientWidth;
    };
    /**
     * Tells if the vertical scrollbar is visible
     *
     */
    /**
     * Tells if the vertical scrollbar is visible
     *
     * @return {?}
     */
    ScrollableContainerComponent.prototype.hasVerticalScroll = /**
     * Tells if the vertical scrollbar is visible
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
        return scrollContainer.scrollHeight > scrollContainer.clientHeight;
    };
    ScrollableContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-scrollable',
                    template: "<div class=\"w-scrollable\" [ngClass]=\"layoutClass\" [style.width]=\"width\"\n     [style.height]=\"height\">\n    <ng-content></ng-content>\n</div>\n",
                    styles: [".w-scrollable{display:flex;display:-webkit-flex;backface-visibility:hidden;-webkit-backface-visibility:hidden;will-change:overflow}.w-scrollable /deep/>*{flex:0 0 auto;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;margin:10px}.u-scrollable-fh{flex-flow:row nowrap;overflow-x:auto;overflow-y:hidden}.u-scrollable-fv{flex-flow:column nowrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fb{flex-flow:row nowrap;overflow-x:auto;overflow-y:auto}.u-scrollable-fv-row{flex-flow:row wrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fn{flex-flow:row wrap}.u-scrollable-al{justify-content:flex-start;-webkit-justify-content:flex-start}.u-scrollable-ar{justify-content:flex-end;-webkit-justify-content:flex-end}.u-scrollable-ac{justify-content:center;-webkit-justify-content:center}.u-scrollable-aj,.u-scrollable-aj-around{justify-content:space-between;-webkit-justify-content:space-between}"]
                },] },
    ];
    /** @nocollapse */
    ScrollableContainerComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: ElementRef }
    ]; };
    ScrollableContainerComponent.propDecorators = {
        direction: [{ type: Input }],
        alignment: [{ type: Input }]
    };
    return ScrollableContainerComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWScrollableContainerModule = /** @class */ (function () {
    function AWScrollableContainerModule() {
    }
    AWScrollableContainerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ScrollableContainerComponent
                    ],
                    imports: [
                        CommonModule
                    ],
                    entryComponents: [
                        ScrollableContainerComponent
                    ],
                    exports: [
                        ScrollableContainerComponent
                    ],
                    providers: []
                },] },
    ];
    return AWScrollableContainerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ LB_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return ListComponent; }),
    multi: true
};
/**
 *
 * The List component represent a structure which contains a list of selectable items. Items
 * selection can be configured in single-selection, multi-selection or multi-selection with visible
 * checkboxes mode.
 * In addition it can display data inside 3 zones LEFT, MIDDLE and RIGHT in order to provide
 * easy way for application developer to layout its own custom content or even change out of box
 * behavior.
 *
 *
 *  ### Examples
 *
 *  1. Render simple single selection list
 *
 *  ```html
 *
 *      <aw-list [list]="list"></aw-list>
 *
 *  ```
 *  2. Render list - multi selection with custom RIGHT content to show a CheckMark when item
 *  is selected
 *
 *  ```html
 *
 *   <aw-list #awlist [list]="list"
 *                       height="150px"
 *                       width="250px"
 *                       [selectionMode]="'multi'">
 *
 *                  <ng-template #right let-item>
 *
 *                      <span class="sap-icon"
 *                            [ngClass]="{'icon-accept': awlist.pListBox.isSelected(item),
 *                            '': !awlist.pListBox.isSelected(item)}">
 *
 *                      </span>
 *                  </ng-template>
 *   </aw-list>
 *
 *  ```
 *
 * 3. Render list - multi selection with visible checkboxes and custom MIDDLE content to change
 *  the way item name is rendered
 *
 *
 *
 *  ```html
 *
 *   <aw-list [list]="list" height="180px"
 *                       width="200px"
 *                       [selection]="selection"
 *                       [selectionMode]="'multiWithCheckbox'">
 *
 *                  <ng-template #middle let-item>
 *                      XX-{{item.value}}
 *                  </ng-template>
 *    </aw-list>
 *
 *  ```
 *
 *
 *
 */
var ListComponent = /** @class */ (function (_super) {
    __extends(ListComponent, _super);
    function ListComponent(env, parentContainer) {
        var _this = _super.call(this, env, parentContainer) || this;
        _this.env = env;
        _this.parentContainer = parentContainer;
        /**
         * Component recognizes 3 modes: single, multi, multi with visible checkboxes
         */
        _this.selectionMode = 'single';
        /**
         * Don't render Listbox border. Used for embedding this inside other components
         *
         */
        _this.borderless = false;
        /**
         * Triggered when we double click on the list Item
         *
         */
        _this.action = new EventEmitter();
        /**
         * Event fired when user select a item
         *
         */
        _this.onSelection = new EventEmitter();
        _this.listStyle = {};
        _this.isMultiple = false;
        _this.showCheckbox = false;
        return _this;
    }
    /**
     * @return {?}
     */
    ListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this.isMultiple = this.selectionMode === 'multi' ||
            this.selectionMode === 'multiWithCheckbox';
        this.showCheckbox = this.selectionMode === 'multiWithCheckbox';
        // cannot have both either we use field to get display value or valueTransformer
        if (isPresent(this.field) && isPresent(this.valueTransformer)) {
            throw new Error('You can have either [field] or [valueTransformer].');
        }
        if (isPresent(this.list)) {
            this.initList();
        }
        else {
            throw new Error('Missing [list] binding.');
        }
        // Also add overflowY to make sure it can scroll and does not expand based on its content
        if (isPresent(this.height)) {
            this.listStyle['height'] = this.height;
            this.listStyle['overflow-y'] = 'auto';
        }
        if (isPresent(this.width)) {
            this.listStyle['width'] = this.width;
        }
        if (this.borderless) {
            this.listStyle['border-color'] = 'transparent';
        }
        if (this.isStandalone) {
            _super.prototype.registerFormControl.call(this, this.selection);
            if (isBlank(this.selection)) {
                this.selection = this.formControl.value;
            }
        }
    };
    /**
     *
     * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
     * checkbox as well as item text.
     *
     *
     */
    /**
     *
     * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
     * checkbox as well as item text.
     *
     *
     * @param {?} event
     * @param {?} item
     * @param {?} checkbox
     * @return {?}
     */
    ListComponent.prototype.itemClicked = /**
     *
     * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
     * checkbox as well as item text.
     *
     *
     * @param {?} event
     * @param {?} item
     * @param {?} checkbox
     * @return {?}
     */
    function (event, item, checkbox) {
        if (isPresent(checkbox)) {
            this.pListBox.onCheckboxClick(event, item);
        }
        else if (isPresent(this.pListBox)) {
            this.pListBox.onOptionClick(event, item);
            event.stopPropagation();
            event.preventDefault();
        }
    };
    /**
     * Internal
     *
     */
    /**
     * Internal
     *
     * @return {?}
     */
    ListComponent.prototype.hasRightTempl = /**
     * Internal
     *
     * @return {?}
     */
    function () {
        return isPresent(this.rZoneTempl);
    };
    /**
     * @return {?}
     */
    ListComponent.prototype.hasLeftTempl = /**
     * @return {?}
     */
    function () {
        return isPresent(this.lZoneTempl);
    };
    /**
     * @return {?}
     */
    ListComponent.prototype.hasMiddleTempl = /**
     * @return {?}
     */
    function () {
        return isPresent(this.mZoneTempl);
    };
    /**
     *
     * Triggered by p-listbox component when item is selected. When state is managed internally
     * we also update FormControl model.
     *
     */
    /**
     *
     * Triggered by p-listbox component when item is selected. When state is managed internally
     * we also update FormControl model.
     *
     * @param {?} event
     * @return {?}
     */
    ListComponent.prototype.onItemSelected = /**
     *
     * Triggered by p-listbox component when item is selected. When state is managed internally
     * we also update FormControl model.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (isBlank(event.value)) {
            return;
        }
        this.onSelection.emit(event.value);
        if (this.isStandalone) {
            this.formControl.setValue(event.value, { emitEvent: true });
        }
        this.onModelChanged(event.value);
    };
    /**
     * Internal. Please see ControlValueAccessor
     *
     */
    /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    ListComponent.prototype.writeValue = /**
     * Internal. Please see ControlValueAccessor
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!equals(value, this.selection)) {
            this.selection = value;
            if (this.isStandalone) {
                this.formControl.setValue(value);
            }
        }
    };
    /**
     * Translates external form of the list into PrimeNG expected format where it uses
     * SelectionItem interface
     * @return {?}
     */
    ListComponent.prototype.initList = /**
     * Translates external form of the list into PrimeNG expected format where it uses
     * SelectionItem interface
     * @return {?}
     */
    function () {
        var _this = this;
        if (isPresent(this.list)) {
            this.internalList = this.list.map(function (item) {
                return { label: _this.displayValue(item), value: item };
            });
        }
    };
    /**
     *  Generates label value for the list box.
     *
     * @param {?} item
     * @return {?}
     */
    ListComponent.prototype.displayValue = /**
     *  Generates label value for the list box.
     *
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (isBlank(item)) {
            return '';
        }
        var /** @type {?} */ val = item.toString();
        if (isPresent(this.field)) {
            val = item[this.field];
        }
        else if (isPresent(this.valueTransformer)) {
            val = this.valueTransformer(item);
        }
        return val;
    };
    ListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-list',
                    template: "<p-listbox #listbox [options]=\"internalList\" [multiple]=\"isMultiple\" [checkbox]=\"showCheckbox\"\n           [(ngModel)]=\"selection\" [disabled]=\"disabled\" [style]=\"listStyle\" [showToggleAll]=\"false\"\n           (onChange)=\"onItemSelected($event)\" (onDblClick)=\"action.emit($event.value)\"\n           [styleClass]=\"styleClass\">\n\n\n    <ng-template let-item pTemplate=\"item\">\n        <div class=\"w-li-wrapper\">\n            <div class=\"w-li-left\">\n                <ng-template *ngIf=\"hasLeftTempl(); else defaultLeft\"\n                             [ngTemplateOutlet]=\"lZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n\n                <ng-template #defaultLeft>\n                    <aw-checkbox #check *ngIf=\"isMultiple && showCheckbox\"\n                                 [isStandalone]=\"false\"\n                                 [value]=\"listbox.isSelected(item)\"\n                                 type=\"action\"\n                                 (action)=\"itemClicked($event, item, check)\">\n                    </aw-checkbox>\n                </ng-template>\n            </div>\n\n            <div class=\"w-li-middle\" (click)=\"itemClicked($event, item, null)\">\n\n                <ng-template *ngIf=\"hasMiddleTempl(); else defaultMiddle\"\n                             [ngTemplateOutlet]=\"mZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n                <ng-template #defaultMiddle>\n                    {{item.label}}\n                </ng-template>\n\n            </div>\n\n            <div class=\"w-li-right\" *ngIf=\"hasRightTempl()\">\n                <ng-template [ngTemplateOutlet]=\"rZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\">\n                </ng-template>\n\n            </div>\n        </div>\n    </ng-template>\n</p-listbox>\n",
                    styles: ["::ng-deep .ui-listbox-item>.ui-chkbox{display:none}::ng-deep .ui-listbox-item .ui-chkbox{margin-right:1em}.w-li-wrapper{display:flex;align-items:flex-start}.w-li-wrapper .w-li-left,.w-li-wrapper .w-li-right{flex:0 1 auto}.w-li-wrapper .w-li-middle{flex:1 1 auto}"],
                    providers: [
                        LB_CONTROL_VALUE_ACCESSOR,
                        { provide: BaseFormComponent, useExisting: forwardRef(function () { return ListComponent; }) }
                    ]
                },] },
    ];
    /** @nocollapse */
    ListComponent.ctorParameters = function () { return [
        { type: Environment },
        { type: BaseFormComponent, decorators: [{ type: SkipSelf }, { type: Optional }, { type: Inject, args: [forwardRef(function () { return BaseFormComponent; }),] }] }
    ]; };
    ListComponent.propDecorators = {
        list: [{ type: Input }],
        selection: [{ type: Input }],
        selectionMode: [{ type: Input }],
        valueTransformer: [{ type: Input }],
        field: [{ type: Input }],
        borderless: [{ type: Input }],
        action: [{ type: Output }],
        onSelection: [{ type: Output }],
        pListBox: [{ type: ViewChild, args: ['listbox',] }],
        lZoneTempl: [{ type: ContentChild, args: ['left',] }],
        mZoneTempl: [{ type: ContentChild, args: ['middle',] }],
        rZoneTempl: [{ type: ContentChild, args: ['right',] }]
    };
    return ListComponent;
}(BaseFormComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWListModule = /** @class */ (function () {
    function AWListModule() {
    }
    AWListModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ListComponent
                    ],
                    imports: [
                        CommonModule,
                        ReactiveFormsModule,
                        FormsModule,
                        ListboxModule,
                        AWCheckBoxModule
                    ],
                    entryComponents: [
                        ListComponent
                    ],
                    exports: [
                        ListComponent,
                        ReactiveFormsModule,
                        FormsModule
                    ],
                    providers: []
                },] },
    ];
    return AWListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Overlay Component is a simple version of the dialog where there's only content.
 * Overlay will appear at the position where the action performed trigger an overlay.
 *
 * There are three types of popup.
 *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
 *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
 *   3.  a overlay, which is a very basic popup with what you put inside.
 *       It doesn't have header and footer.
 *
 * There are two ways to use any popup component.
 *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
 *   2.  or the ModalService  service.open(<OverlayComponent>), service.close()
 *
 * Usage:
 *    1.  Using ModalService directly to display a modal popup. The usage is a little tricky
 *        because angular currently doesn't support dynamic content projection.
 *
 *          let overlay = this.modalService.open<OverlayComponent>(OverlayComponent, {});
 *
 *            // Add content. There's not support for dynamic content projection yet.
 *            // So have add content directly.
 *            // This is probably not the best way.
 *          overlay.instance.overlay.el.nativeElement.querySelector(".ui-overlaypanel-content")
 *               .innerHTML = `<img style='width:300px;' src="sales.png" alt="Sales Chart" />`;
 *
 *          // delay the opening after ng lifecycle has been initialized.
 *          setTimeout(() => { overlay.instance.open(event); }, 1);
 *
 *
 *   2.   Use the component inside your template.
 *
 * \@Component({
 *                selector: 'aw-page' ,
 *                           template: `
 *                                <aw-overlay #overlay (onOpen)="overlayAction='open'"
 *                                                     (onClose)="overlayAction='close'">
 *                                      <img src="sales.png" alt="Chart"/>
 *                                </aw-overlay>
 *
 *                                <aw-button [size]="'small'" (click)="overlay.open($event)">
 *                                    Open Overlay
 *                                </aw-button>
 *                  `
 *         export class MyPageComponent implements OnInit {
 *
 *                     overlayAction: string;
 *
 *                     constructor(private modalService: ModalService) {
 *                          super();
 *                       }
 *                     ngOnInit() { }
 *       }
 *
 *
 */
var OverlayComponent = /** @class */ (function (_super) {
    __extends(OverlayComponent, _super);
    function OverlayComponent(env) {
        var _this = _super.call(this, env) || this;
        _this.env = env;
        /**
         * Enables hide overlay when outside is clicked.
         */
        _this.dismissable = true;
        /**
         * displays the close icon 'x' at top of right corner.
         */
        _this.showCloseIcon = false;
        /**
         * Event fired when overlay is closed.
         */
        _this.onClose = new EventEmitter();
        /**
         * Event fired when the overlay is opened.
         */
        _this.onOpen = new EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    OverlayComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * Open Overlay
     * @param event
     */
    /**
     * Open Overlay
     * @param {?} event
     * @return {?}
     */
    OverlayComponent.prototype.open = /**
     * Open Overlay
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.overlay.show(event);
        this.onOpened(null);
    };
    /**
     * Close Overlay
     */
    /**
     * Close Overlay
     * @return {?}
     */
    OverlayComponent.prototype.close = /**
     * Close Overlay
     * @return {?}
     */
    function () {
        this.overlay.hide();
    };
    /**
     * toggle open and close.
     * @param event
     */
    /**
     * toggle open and close.
     * @param {?} event
     * @return {?}
     */
    OverlayComponent.prototype.toggle = /**
     * toggle open and close.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.overlay.toggle(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OverlayComponent.prototype.onOpened = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onOpen.emit(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OverlayComponent.prototype.onClosed = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onClose.emit(event);
    };
    OverlayComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-overlay',
                    template: "<p-overlayPanel [dismissable]=\"dismissable\" [showCloseIcon]=\"showCloseIcon\"\n                [styleClass]=\"styleClass\" [appendTo]=\"appendTo\"\n                (onAfterHide)=\"onClosed($event)\">\n    <ng-content></ng-content>\n</p-overlayPanel>\n",
                    styles: ["::ng-deep .ui-overlaypanel{border:1px solid #d7d7d7;box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .ui-overlaypanel-content{padding:2em 3.4em .6em 1.43em}::ng-deep .ui-overlaypanel-close{border-radius:0;top:.5em;right:.5em}::ng-deep .ui-overlaypanel-close.ui-state-default{border:none}"]
                },] },
    ];
    /** @nocollapse */
    OverlayComponent.ctorParameters = function () { return [
        { type: Environment }
    ]; };
    OverlayComponent.propDecorators = {
        dismissable: [{ type: Input }],
        showCloseIcon: [{ type: Input }],
        appendTo: [{ type: Input }],
        onClose: [{ type: Output }],
        onOpen: [{ type: Output }],
        overlay: [{ type: ViewChild, args: [OverlayPanel,] }]
    };
    return OverlayComponent;
}(ModalContainer));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var HCCardPosition = {
    top: 0,
    bottom: 1,
    none: 2,
};
HCCardPosition[HCCardPosition.top] = "top";
HCCardPosition[HCCardPosition.bottom] = "bottom";
HCCardPosition[HCCardPosition.none] = "none";
/** @enum {number} */
var HCCardAlignment = {
    left: 0,
    paddedLeft: 1,
    right: 2,
    paddedRight: 3,
    default: 4,
};
HCCardAlignment[HCCardAlignment.left] = "left";
HCCardAlignment[HCCardAlignment.paddedLeft] = "paddedLeft";
HCCardAlignment[HCCardAlignment.right] = "right";
HCCardAlignment[HCCardAlignment.paddedRight] = "paddedRight";
HCCardAlignment[HCCardAlignment.default] = "default";
/**
 * Maps position to styles that are applied to the Card container. This is just to make it easier
 * as we are working with enumerations and have already enum type.
 *
 * u-hc-arrow-b: Arrow will appear at the bottom
 * u-hc-arrow-t: Arrow will appear at the top
 *
 * u-hc-shadow-t: Border shadow will appear at the top
 * u-hc-shadow-b: Border shadow will appear at the bottom
 */
var /** @type {?} */ PositionToStyle = {
    top: ' w-hc-panel-arrow u-hc-arrow-b u-hc-shadow-t',
    bottom: ' w-hc-panel-arrow u-hc-arrow-t u-hc-shadow-b',
    none: ''
};
/**
 *
 * Maps aligned Card container to custom styles in order to apply correct arrow
 *
 * -ll: Stands for Large Left (large: there is plenty of space around )
 * -lr: Stands for Large right
 * -sl: Stands for Small left (Small and resized screen where we try to fit card container
 * somewhere in between)
 * -sr: Stands for Large right
 *
 */
var /** @type {?} */ AlignmentToStyle = {
    left: ' u-hc-arrow-ll',
    right: ' u-hc-arrow-lr',
    paddedLeft: ' u-hc-arrow-sl',
    paddedRight: ' u-hc-arrow-sr',
    default: ' u-hc-arrow-ll',
};
/**
 * The HoverCard components adds hover behavior to text, the specified content is loaded
 * on the left or right side of the element.
 *
 * Todo: extends so we can wrap any element and any element can be triggering this. Not only
 * linkTitle
 *
 *
 * ### Example:
 *
 * ```
 *
 *   <aw-hover-card [linkTitle]="'Frank kolar'">
 *       <h3>My Card Title</h3>
 *       <div>
 *
 *           This is my contents
 *
 *       </div>
 *
 *
 *    </aw-hover-card>
 * ```
 *
 * By default there is [forceClose]=true which forces the user to use X close icon
 *
 *
 *
 */
var HoverCardComponent = /** @class */ (function (_super) {
    __extends(HoverCardComponent, _super);
    function HoverCardComponent(elem, env, cd) {
        var _this = _super.call(this, env) || this;
        _this.elem = elem;
        _this.env = env;
        _this.cd = cd;
        /**
         * Should we keep the hover card open and force user to manually close
         *
         */
        _this.forceClose = true;
        /**
         *
         * This current workaround until we find better solution. PrimeNG overlays operates within
         * its relative element so if the overlay is wrapped inside some other relative container
         * the overlay content is croped by its parent and content is not visible.
         *
         * They have [appendTo] binding which we need to use for this purpose
         *
         */
        _this.appendContentToBody = true;
        /**
         *
         * Internal style class to use to apply additional styles when it needs to show a Arrow on the
         * card
         *
         */
        _this.arrowClass = '';
        _this.opening = false;
        _this.currrentPosition = HCCardPosition.none;
        return _this;
    }
    /**
     * @return {?}
     */
    HoverCardComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        assert(isPresent(this.linkTitle), 'You must provide [linkTitle] binding !');
        // make sure there is open HC when we start new component
        this.env.deleteValue('hc-open');
        if (!this.appendContentToBody) {
            this.appendTo = null;
        }
    };
    /**
     * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
     * during this phase.
     *
     * So now its broken down into two parts:
     *   - Apply class styles
     *   - Position it.
     */
    /**
     * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
     * during this phase.
     *
     * So now its broken down into two parts:
     *   - Apply class styles
     *   - Position it.
     * @return {?}
     */
    HoverCardComponent.prototype.ngAfterViewChecked = /**
     * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
     * during this phase.
     *
     * So now its broken down into two parts:
     *   - Apply class styles
     *   - Position it.
     * @return {?}
     */
    function () {
        if (this.opening) {
            var /** @type {?} */ container = this.awOverlay.overlay.container;
            var /** @type {?} */ cntRect = container.getBoundingClientRect();
            if (this.currrentPosition !== HCCardPosition.none) {
                this.adjustCard(container, cntRect, this.awOverlay.overlay);
            }
            else {
                this.arrowClass = '';
            }
            this.opening = false;
        }
    };
    /**
     * Init elements BoundingClientRect that we use for calculation
     *
     */
    /**
     * Init elements BoundingClientRect that we use for calculation
     *
     * @return {?}
     */
    HoverCardComponent.prototype.initElements = /**
     * Init elements BoundingClientRect that we use for calculation
     *
     * @return {?}
     */
    function () {
        var /** @type {?} */ titleElem = this.elem.nativeElement.querySelector('.w-hc-title');
        var /** @type {?} */ triggerElem = this.elem.nativeElement.querySelector('.sap-icon');
        this.titleAreaRect = titleElem.getBoundingClientRect();
        this.trigRect = triggerElem.getBoundingClientRect();
        this.trigIconMiddle = this.trigRect.width / 2;
    };
    /**
     *
     * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
     * only one Card is opened at the time it uses Environment to save extra information for it
     *
     *
     */
    /**
     *
     * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
     * only one Card is opened at the time it uses Environment to save extra information for it
     *
     *
     * @param {?} event
     * @return {?}
     */
    HoverCardComponent.prototype.openCard = /**
     *
     * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
     * only one Card is opened at the time it uses Environment to save extra information for it
     *
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (isPresent(this.awOverlay) && !this.env.hasValue('hc-open')) {
            this.awOverlay.open(event);
            this.env.setValue('hc-open', true);
        }
    };
    /**
     *
     * Fired at the end of the opening cycle when all is initialized and the card is about to
     * fade in.
     *
     * This method first simulates displaying card by setting display:block and
     * domHandler.absolutePosition so we can read dimensions and then later on position the card
     * accordingly.
     *
     */
    /**
     *
     * Fired at the end of the opening cycle when all is initialized and the card is about to
     * fade in.
     *
     * This method first simulates displaying card by setting display:block and
     * domHandler.absolutePosition so we can read dimensions and then later on position the card
     * accordingly.
     *
     * @param {?} event
     * @return {?}
     */
    HoverCardComponent.prototype.cardOpened = /**
     *
     * Fired at the end of the opening cycle when all is initialized and the card is about to
     * fade in.
     *
     * This method first simulates displaying card by setting display:block and
     * domHandler.absolutePosition so we can read dimensions and then later on position the card
     * accordingly.
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ container = this.awOverlay.overlay.container;
        var /** @type {?} */ target = this.awOverlay.overlay.target;
        this.openForAdjustments(container);
        // pre-run positioning so we can calculate new coordinates
        this.awOverlay.overlay.domHandler.absolutePosition(container, target);
        var /** @type {?} */ cntRect = container.getBoundingClientRect();
        this.currrentPosition = this.positionForCard(container, cntRect);
        this.applyStyleClass(container, cntRect, this.awOverlay.overlay);
        this.closeForAdjustments(container);
        this.opening = true;
    };
    /**
     *
     * When card is closed we need to release it and delete all the references from Environment
     *
     *
     */
    /**
     *
     * When card is closed we need to release it and delete all the references from Environment
     *
     *
     * @param {?} event
     * @return {?}
     */
    HoverCardComponent.prototype.cardClosed = /**
     *
     * When card is closed we need to release it and delete all the references from Environment
     *
     *
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.env.deleteValue('hc-open');
    };
    /**
     *
     * Applies style.TOP and style.LEFT to the container in order to reposition it and add
     * extra arrow.
     *
     * First based on the initial position we apply style.TOP and depending if its on the
     * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
     *
     * Then for positioning horizontally we use two types.
     *  - When there is allot of space the arrow is 25% from the edge
     *
     *    -----^------------   or       -----------^----
     *
     *
     *  - When there is less or none space we have only 10% far away form the edge
     *
     *    --^------------   or       -----------^--
     *
     *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
     *  either to the left or right.
     *
     */
    /**
     *
     * Applies style.TOP and style.LEFT to the container in order to reposition it and add
     * extra arrow.
     *
     * First based on the initial position we apply style.TOP and depending if its on the
     * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
     *
     * Then for positioning horizontally we use two types.
     *  - When there is allot of space the arrow is 25% from the edge
     *
     *    -----^------------   or       -----------^----
     *
     *
     *  - When there is less or none space we have only 10% far away form the edge
     *
     *    --^------------   or       -----------^--
     *
     *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
     *  either to the left or right.
     *
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    HoverCardComponent.prototype.adjustCard = /**
     *
     * Applies style.TOP and style.LEFT to the container in order to reposition it and add
     * extra arrow.
     *
     * First based on the initial position we apply style.TOP and depending if its on the
     * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
     *
     * Then for positioning horizontally we use two types.
     *  - When there is allot of space the arrow is 25% from the edge
     *
     *    -----^------------   or       -----------^----
     *
     *
     *  - When there is less or none space we have only 10% far away form the edge
     *
     *    --^------------   or       -----------^--
     *
     *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
     *  either to the left or right.
     *
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    function (container, containerRect, modalContainer) {
        var /** @type {?} */ diff = (this.currrentPosition === HCCardPosition.bottom) ? 1 : -1;
        var /** @type {?} */ scrollTop = modalContainer.domHandler.getWindowScrollTop();
        var /** @type {?} */ posWithScroll = containerRect.top + scrollTop;
        container.style.top = (posWithScroll + (HoverCardComponent.ArrowPad * diff)) + 'px';
        var /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
        container.style.left = this.calcLeftForAlignment(containerRect, alignment) + 'px';
    };
    /**
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    HoverCardComponent.prototype.applyStyleClass = /**
     * @param {?} container
     * @param {?} containerRect
     * @param {?} modalContainer
     * @return {?}
     */
    function (container, containerRect, modalContainer) {
        if (this.currrentPosition !== HCCardPosition.none) {
            var /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
            this.arrowClass = (/** @type {?} */ (PositionToStyle))[(/** @type {?} */ (HCCardPosition))[this.currrentPosition]];
            this.arrowClass += (/** @type {?} */ (AlignmentToStyle))[(/** @type {?} */ (HCCardAlignment))[alignment]];
        }
        else {
            this.arrowClass = '';
        }
    };
    /**
     *
     * Detects if the card is going to be shown on the top of the Link label or under. Or if
     * its covering it.
     *
     */
    /**
     *
     * Detects if the card is going to be shown on the top of the Link label or under. Or if
     * its covering it.
     *
     * @param {?} container
     * @param {?} boundingRect
     * @return {?}
     */
    HoverCardComponent.prototype.positionForCard = /**
     *
     * Detects if the card is going to be shown on the top of the Link label or under. Or if
     * its covering it.
     *
     * @param {?} container
     * @param {?} boundingRect
     * @return {?}
     */
    function (container, boundingRect) {
        // secure this in case of IE returning undefined
        var /** @type {?} */ borderWidth = getComputedStyle(container).borderWidth;
        var /** @type {?} */ cntWidth = parseFloat(borderWidth || '0');
        var /** @type {?} */ pos = HCCardPosition.none;
        if (this.trigRect.bottom < boundingRect.top) {
            pos = HCCardPosition.bottom;
        }
        else if (this.trigRect.top > (boundingRect.bottom - cntWidth)) {
            pos = HCCardPosition.top;
        }
        return pos;
    };
    /**
     *
     * Detect horizontal alignment.
     *
     * @param {?} boundingRect
     * @param {?} modalContainer
     * @return {?}
     */
    HoverCardComponent.prototype.alignmentForCard = /**
     *
     * Detect horizontal alignment.
     *
     * @param {?} boundingRect
     * @param {?} modalContainer
     * @return {?}
     */
    function (boundingRect, modalContainer) {
        var /** @type {?} */ alignment = HCCardAlignment.left;
        var /** @type {?} */ viewPort = modalContainer.domHandler.getViewport();
        if (this.trigRect.left.toFixed(0) === boundingRect.left.toFixed(0) &&
            boundingRect.left > HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.left;
        }
        else if (boundingRect.left < HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.paddedLeft;
        }
        else if ((viewPort.width - boundingRect.right) < HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.paddedRight;
        }
        else if (this.trigRect.right.toFixed(0) === boundingRect.right.toFixed(0) ||
            (viewPort.width - boundingRect.right) > HoverCardComponent.SpacingLimit) {
            alignment = HCCardAlignment.right;
        }
        else {
            alignment = HCCardAlignment.default;
        }
        return alignment;
    };
    /**
     *
     * Turn on temporary display to BLOCK so we can read dimensions
     *
     */
    /**
     *
     * Turn on temporary display to BLOCK so we can read dimensions
     *
     * @param {?} container
     * @return {?}
     */
    HoverCardComponent.prototype.openForAdjustments = /**
     *
     * Turn on temporary display to BLOCK so we can read dimensions
     *
     * @param {?} container
     * @return {?}
     */
    function (container) {
        container.style.visibility = 'hidden';
        container.style.display = 'block';
        this.initElements();
    };
    /**
     *
     * Turn off display back NONE
     *
     */
    /**
     *
     * Turn off display back NONE
     *
     * @param {?} container
     * @return {?}
     */
    HoverCardComponent.prototype.closeForAdjustments = /**
     *
     * Turn off display back NONE
     *
     * @param {?} container
     * @return {?}
     */
    function (container) {
        container.style.visibility = 'visible';
        // container.style.display = 'none';
    };
    /**
     *
     * Calculates positioning for style.LEFT. As already said they are two types of triangles that
     * are applies for these case:
     *
     *
     * a) Large left, Large right
     *
     *  PrimeNG aligns the card with either the right side or left side of the triggering icon
     *
     *
     *  V                                                                V
     *  ......^........................ or  .......................^......
     *
     *
     *
     *
     *  b) Small left , small right
     *
     *  This is for cases where there is not enough space and PrimeNG position the card off to the
     *  triggering icons, so even primeNg does not have space to align it with the V
     *
     *
     *     V                                                      V
     *  ....^........................ or  .......................^....
     *
     *
     * c)Aligned with the edge of browser
     *
     * On the right side this is problem as we cannot calculate full future width of the card.
     * but we applly for this case #b (arrow 10% )
     *
     *
     *
     * @param {?} boundingRect
     * @param {?} alignment
     * @return {?}
     */
    HoverCardComponent.prototype.calcLeftForAlignment = /**
     *
     * Calculates positioning for style.LEFT. As already said they are two types of triangles that
     * are applies for these case:
     *
     *
     * a) Large left, Large right
     *
     *  PrimeNG aligns the card with either the right side or left side of the triggering icon
     *
     *
     *  V                                                                V
     *  ......^........................ or  .......................^......
     *
     *
     *
     *
     *  b) Small left , small right
     *
     *  This is for cases where there is not enough space and PrimeNG position the card off to the
     *  triggering icons, so even primeNg does not have space to align it with the V
     *
     *
     *     V                                                      V
     *  ....^........................ or  .......................^....
     *
     *
     * c)Aligned with the edge of browser
     *
     * On the right side this is problem as we cannot calculate full future width of the card.
     * but we applly for this case #b (arrow 10% )
     *
     *
     *
     * @param {?} boundingRect
     * @param {?} alignment
     * @return {?}
     */
    function (boundingRect, alignment) {
        // width for which we need to shift card. 25% or 10% of the container width
        var /** @type {?} */ wLargeTriangle = boundingRect.width * 0.25;
        var /** @type {?} */ wSmallTriangle = boundingRect.width * 0.10;
        switch (alignment) {
            case HCCardAlignment.right:
                var /** @type {?} */ shiftRight = boundingRect.left + wLargeTriangle;
                var /** @type {?} */ trigRight = this.trigRect.right - this.trigIconMiddle;
                return shiftRight - (boundingRect.right - trigRight);
            case HCCardAlignment.paddedRight:
                var /** @type {?} */ shiftRightS = boundingRect.left + wSmallTriangle;
                var /** @type {?} */ trigRightS = this.trigRect.right - this.trigIconMiddle;
                return shiftRightS - (boundingRect.right - trigRightS);
            case HCCardAlignment.paddedLeft:
                var /** @type {?} */ shiftLeftPad = boundingRect.left - wSmallTriangle;
                return shiftLeftPad + this.trigIconMiddle;
            case HCCardAlignment.left:
            default:
                var /** @type {?} */ shiftLeft = boundingRect.left - wLargeTriangle;
                return shiftLeft + this.trigIconMiddle;
        }
    };
    /**
     * Default padding representing a height of the Arrow for which we need to vertically adjust
     * Card container
     *
     */
    HoverCardComponent.ArrowPad = 10;
    /**
     * Defines safe threshold where there might not be enough space around or Card is aligned with
     * the left or right edge of the viewport for which we need to position the Arrow closer to the
     * side of the card
     *
     */
    HoverCardComponent.SpacingLimit = 50;
    HoverCardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'aw-hover-card',
                    template: "<span class=\"w-hc\">\n    <span class=\"w-hc-title\">\n        <aw-string [value]=\"linkTitle\"></aw-string>\n        <span class=\"sap-icon icon-slim-arrow-down\" (mouseover)=\"openCard($event)\"></span>\n    </span>\n\n    <div class=\"w-hc-body\">\n\n         <aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"\n                     [styleClass]=\"arrowClass\"\n                     [appendTo]=\"appendTo\"\n                     (onOpen)=\"cardOpened($event)\"\n                     (onClose)=\"cardClosed($event)\">\n\n        <!-- this is workaround to create a _ngcontent-INDEX reference so we can\n        refer to this ng-content. Angular does not have any way right now to track this\n        -->\n        <span class=\"u-ngcontent\">\n                <ng-content></ng-content>\n            </span>\n\n    </aw-overlay>\n\n    </div>\n</span>\n\n\n<!--<ng-template #contentToBody>-->\n    <!--<aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"-->\n                <!--[styleClass]=\"arrowClass\"-->\n                <!--[appendTo]=\"appendTo\"-->\n                <!--(onOpen)=\"cardOpened($event)\"-->\n                <!--(onClose)=\"cardClosed($event)\">-->\n\n        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->\n        <!--refer to this ng-content. Angular does not have any way right now to track this-->\n        <!--&ndash;&gt;-->\n        <!--<span class=\"u-ngcontent\">-->\n                <!--<ng-content></ng-content>-->\n            <!--</span>-->\n\n    <!--</aw-overlay>-->\n\n<!--</ng-template>-->\n\n\n<!--<ng-template #contentToOverlay>-->\n\n    <!--<aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"-->\n                <!--[styleClass]=\"arrowClass\"-->\n                <!--(onOpen)=\"cardOpened($event)\"-->\n                <!--(onClose)=\"cardClosed($event)\">-->\n\n        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->\n        <!--refer to this ng-content. Angular does not have any way right now to track this-->\n        <!--&ndash;&gt;-->\n        <!--<span class=\"u-ngcontent\">-->\n                <!--<ng-content></ng-content>-->\n            <!--</span>-->\n\n    <!--</aw-overlay>-->\n<!--</ng-template>-->\n\n\n",
                    styles: [".w-hc-title{padding-right:1.4em;position:relative;white-space:nowrap}.w-hc-title .sap-icon{font-size:1em;color:#00679e;position:absolute;padding-top:.2em;right:0}::ng-deep .w-hc-panel-arrow.u-hc-shadow-b{box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow.u-hc-shadow-t{box-shadow:0 -2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow:after,::ng-deep .w-hc-panel-arrow:before{left:25%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}::ng-deep .w-hc-panel-arrow:after{border-color:rgba(136,183,213,0);border-width:.7em;margin-left:-.7em}::ng-deep .w-hc-panel-arrow:before{border-color:rgba(255,136,56,0);border-width:.8em;margin-left:-.8em}::ng-deep .u-hc-arrow-ll:after,::ng-deep .u-hc-arrow-ll:before{left:25%}::ng-deep .u-hc-arrow-lr:after,::ng-deep .u-hc-arrow-lr:before{left:75%}::ng-deep .u-hc-arrow-sl:after,::ng-deep .u-hc-arrow-sl:before{left:10%}::ng-deep .u-hc-arrow-sr:after,::ng-deep .u-hc-arrow-sr:before{left:90%}::ng-deep .u-hc-arrow-t:after,::ng-deep .u-hc-arrow-t:before{bottom:100%}::ng-deep .u-hc-arrow-t:after{border-bottom-color:#fff}::ng-deep .u-hc-arrow-t:before{border-bottom-color:#d7d7d7}::ng-deep .u-hc-arrow-b:after,::ng-deep .u-hc-arrow-b:before{top:100%}::ng-deep .u-hc-arrow-b:after{border-top-color:#fff}::ng-deep .u-hc-arrow-b:before{border-top-color:#d7d7d7}"]
                },] },
    ];
    /** @nocollapse */
    HoverCardComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Environment },
        { type: ChangeDetectorRef }
    ]; };
    HoverCardComponent.propDecorators = {
        linkTitle: [{ type: Input }],
        forceClose: [{ type: Input }],
        appendContentToBody: [{ type: Input }],
        awOverlay: [{ type: ViewChild, args: ['overlay',] }]
    };
    return HoverCardComponent;
}(BaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Spy lifecycle directive is used for debugging purposes to track lifecycle callback
 *
 * ###Usage
 *
 * ```
 *   <my-directive spyhooks><my-directive>
 *
 * ```
 */
var SpyLifeCycleHooksDirective = /** @class */ (function () {
    function SpyLifeCycleHooksDirective(elementRef) {
        this.elementRef = elementRef;
    }
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.logIt('onInit');
    };
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.logIt('onDestroy');
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.logIt('ngOnChanges = ' + changes);
    };
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        this.logIt('ngDoCheck');
    };
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.logIt('ngAfterContentInit');
    };
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        this.logIt('ngAfterContentChecked');
    };
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.logIt('ngAfterViewInit');
    };
    /**
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ngAfterViewChecked = /**
     * @return {?}
     */
    function () {
        this.logIt('ngAfterViewChecked');
    };
    /**
     * @param {?} msg
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.logIt = /**
     * @param {?} msg
     * @return {?}
     */
    function (msg) {
        var /** @type {?} */ level = 0;
        var /** @type {?} */ me = this.elementRef.nativeElement;
        var /** @type {?} */ tagBody = me;
        while ((tagBody = tagBody.parentNode) != null) {
            level++;
            if (tagBody.tagName === 'APP-ROOT' || level === 6) {
                break;
            }
        }
        var /** @type {?} */ indent = '';
        var /** @type {?} */ indentNumber = level;
        while (level > 0) {
            indent += '\t';
            level--;
        }
        var /** @type {?} */ params = '';
        if (isPresent(me.attributes)) {
            for (var /** @type {?} */ i = 0; i < me.attributes.length; i++) {
                var /** @type {?} */ attr = me.attributes.item(i);
                if (this.ignore(attr.name.toLowerCase())) {
                    continue;
                }
                params += '(' + attr.name + '=' + attr.value + '),  ';
            }
        }
        print(indent + me.tagName + '(' + indentNumber + '): ' + msg + ' => ' + params);
    };
    /**
     * @param {?} name
     * @return {?}
     */
    SpyLifeCycleHooksDirective.prototype.ignore = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return name.indexOf('_ng') > -1 ||
            name.indexOf('ng-') > -1 ||
            name.indexOf('spyhooks') > -1;
    };
    SpyLifeCycleHooksDirective.decorators = [
        { type: Directive, args: [{ selector: '[spyHooks]' },] },
    ];
    /** @nocollapse */
    SpyLifeCycleHooksDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return SpyLifeCycleHooksDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

var components = /*#__PURE__*/Object.freeze({
    AWCoreComponentModule: AWCoreComponentModule,
    ErrorMessagesComponent: ErrorMessagesComponent,
    ModalContainer: ModalContainer,
    ModalService: ModalService,
    ModalComponent: ModalComponent,
    CurrencyFormatPipe: CurrencyFormatPipe,
    BaseComponent: BaseComponent,
    BaseFormComponent: BaseFormComponent,
    WidgetSizeColumns: WidgetSizeColumns,
    DomUtilsService: DomUtilsService,
    EmbeddedItemDirective: EmbeddedItemDirective,
    EmbededItem: EmbededItem,
    ErrorManagerService: ErrorManagerService,
    GenericContainerComponent: GenericContainerComponent,
    IncludeComponentDirective: IncludeComponentDirective,
    ComponentRegistry: ComponentRegistry,
    DataTypeProviderRegistry: DataTypeProviderRegistry,
    DataProviders: DataProviders,
    DataFinders: DataFinders,
    DataFinder: DataFinder,
    FullTextArrayDataFinder: FullTextArrayDataFinder,
    QueryType: QueryType,
    DATA_SOURCE: DATA_SOURCE,
    DataProvider: DataProvider,
    ArrayDataProvider: ArrayDataProvider,
    NgForSetDirective: NgForSetDirective,
    AwNameDirective: AwNameDirective,
    AwNameStore: AwNameStore,
    FormTableComponent: FormTableComponent,
    AWFormTableModule: AWFormTableModule,
    FormRowComponent: FormRowComponent,
    TopZoneComponent: TopZoneComponent,
    LeftZoneComponent: LeftZoneComponent,
    MiddleZoneComponent: MiddleZoneComponent,
    RightZoneComponent: RightZoneComponent,
    BottomZoneComponent: BottomZoneComponent,
    AWInputFieldModule: AWInputFieldModule,
    AWStringFieldModule: AWStringFieldModule,
    AWBasicNavigatorModule: AWBasicNavigatorModule,
    AWButtonModule: AWButtonModule,
    AWCardModule: AWCardModule,
    AWCheckBoxModule: AWCheckBoxModule,
    AWCheckBoxListModule: AWCheckBoxListModule,
    AWHyperlinkModule: AWHyperlinkModule,
    AWChooserModule: AWChooserModule,
    AWDropdownModule: AWDropdownModule,
    AWCurrencyModule: AWCurrencyModule,
    AWDateAndTimeModule: AWDateAndTimeModule,
    AWDialogModule: AWDialogModule,
    AWGenericChooserModule: AWGenericChooserModule,
    AWRadioButtonModule: AWRadioButtonModule,
    AWRadioButtonListModule: AWRadioButtonListModule,
    AWOutlineForModule: AWOutlineForModule,
    AWTextAreaModule: AWTextAreaModule,
    AWPageNotificationModule: AWPageNotificationModule,
    AWPageWrapperModule: AWPageWrapperModule,
    AWRichTextAreaModule: AWRichTextAreaModule,
    AWSectionModule: AWSectionModule,
    AWStepperModule: AWStepperModule,
    AWDatatable2Module: AWDatatable2Module,
    AWConfirmationModule: AWConfirmationModule,
    AWScrollableContainerModule: AWScrollableContainerModule,
    AWListModule: AWListModule,
    BasicNavigatorComponent: BasicNavigatorComponent,
    ButtonComponent: ButtonComponent,
    CheckBoxListComponent: CheckBoxListComponent,
    CHOOSER_CONTROL_VALUE_ACCESSOR: CHOOSER_CONTROL_VALUE_ACCESSOR,
    ChooserComponent: ChooserComponent,
    ChooserState: ChooserState,
    DefaultSelectionState: DefaultSelectionState,
    ChooserSelectionState: ChooserSelectionState,
    ChooserDataSource: ChooserDataSource,
    isDSChooserInitParams: isDSChooserInitParams,
    CURRENCY_CONTROL_VALUE_ACCESSOR: CURRENCY_CONTROL_VALUE_ACCESSOR,
    CurrencyComponent: CurrencyComponent,
    Money: Money,
    DateAndTimeComponent: DateAndTimeComponent,
    DATETIME_CONTROL_VALUE_ACCESSOR: DATETIME_CONTROL_VALUE_ACCESSOR,
    DialogComponent: DialogComponent,
    DialogHeaderComponent: DialogHeaderComponent,
    DialogFooterComponent: DialogFooterComponent,
    ConfirmationComponent: ConfirmationComponent,
    ConfirmationHeaderComponent: ConfirmationHeaderComponent,
    ConfirmationFooterComponent: ConfirmationFooterComponent,
    OverlayComponent: OverlayComponent,
    DD_CONTROL_VALUE_ACCESSOR: DD_CONTROL_VALUE_ACCESSOR,
    DropdownComponent: DropdownComponent,
    GCChooserState: GCChooserState,
    GenericChooserComponent: GenericChooserComponent,
    HyperlinkComponent: HyperlinkComponent,
    INPUT_CONTROL_VALUE_ACCESSOR: INPUT_CONTROL_VALUE_ACCESSOR,
    InputFieldComponent: InputFieldComponent,
    RadioButtonListComponent: RadioButtonListComponent,
    StringComponent: StringComponent,
    TEXTAREA_CONTROL_VALUE_ACCESSOR: TEXTAREA_CONTROL_VALUE_ACCESSOR,
    TextAreaComponent: TextAreaComponent,
    CardComponent: CardComponent,
    CardZoneTitleComponent: CardZoneTitleComponent,
    CardZoneTopComponent: CardZoneTopComponent,
    CardZoneBottomComponent: CardZoneBottomComponent,
    OutlineForComponent: OutlineForComponent,
    OutlineControlComponent: OutlineControlComponent,
    OutlineState: OutlineState,
    PageContentComponent: PageContentComponent,
    PageNotificationComponent: PageNotificationComponent,
    PageNotification: PageNotification,
    PageInitialized: PageInitialized,
    PageDestroyed: PageDestroyed,
    PageWrapper: PageWrapper,
    PageLifeCycleService: PageLifeCycleService,
    ObjectPageWrapperComponent: ObjectPageWrapperComponent,
    PageHeaderComponent: PageHeaderComponent,
    PageMenuItem: PageMenuItem,
    UserNotification: UserNotification,
    PageFooterComponent: PageFooterComponent,
    SidenavComponent: SidenavComponent,
    PageActionsComponent: PageActionsComponent,
    SectionComponent: SectionComponent,
    SubSectionComponent: SubSectionComponent,
    SectionActionsComponent: SectionActionsComponent,
    EditorType: EditorType,
    RichTextAreaComponent: RichTextAreaComponent,
    CheckboxComponent: CheckboxComponent,
    RadioButtonComponent: RadioButtonComponent,
    StepperComponent: StepperComponent,
    StepComponent: StepComponent,
    ScrollableContainerComponent: ScrollableContainerComponent,
    HoverCardComponent: HoverCardComponent,
    ListComponent: ListComponent,
    Datatable2Component: Datatable2Component,
    DTHeaderComponent2: DTHeaderComponent2,
    DTColumn2Component: DTColumn2Component,
    DTDetailRowComponent: DTDetailRowComponent,
    Datatable2State: Datatable2State,
    isDTInitParams: isDTInitParams,
    DT2DataSource: DT2DataSource,
    DetailRowExpansionState: DetailRowExpansionState,
    DTMultiSelectColumnComponent: DTMultiSelectColumnComponent,
    DomHandler: DomHandler,
    TreeDragDropService: TreeDragDropService,
    ConfirmationService: ConfirmationService,
    Header: Header,
    Footer: Footer,
    PrimeTemplate: PrimeTemplate,
    Column: Column,
    Row: Row,
    HeaderColumnGroup: HeaderColumnGroup,
    FooterColumnGroup: FooterColumnGroup,
    SharedModule: SharedModule,
    AccordionTab: AccordionTab,
    Accordion: Accordion,
    AccordionModule: AccordionModule,
    AUTOCOMPLETE_VALUE_ACCESSOR: AUTOCOMPLETE_VALUE_ACCESSOR,
    AutoComplete: AutoComplete,
    AutoCompleteModule: AutoCompleteModule,
    BlockUI: BlockUI,
    BlockUIModule: BlockUIModule,
    Breadcrumb: Breadcrumb,
    BreadcrumbModule: BreadcrumbModule,
    ButtonDirective: ButtonDirective,
    Button: Button,
    ButtonModule: ButtonModule,
    Captcha: Captcha,
    CaptchaModule: CaptchaModule,
    CALENDAR_VALUE_ACCESSOR: CALENDAR_VALUE_ACCESSOR,
    Calendar: Calendar,
    CalendarModule: CalendarModule,
    Card: Card,
    CardModule: CardModule,
    Carousel: Carousel,
    CarouselModule: CarouselModule,
    UIChart: UIChart,
    ChartModule: ChartModule,
    CHECKBOX_VALUE_ACCESSOR: CHECKBOX_VALUE_ACCESSOR,
    Checkbox: Checkbox,
    CheckboxModule: CheckboxModule,
    CHIPS_VALUE_ACCESSOR: CHIPS_VALUE_ACCESSOR,
    Chips: Chips,
    ChipsModule: ChipsModule,
    CodeHighlighter: CodeHighlighter,
    CodeHighlighterModule: CodeHighlighterModule,
    COLORPICKER_VALUE_ACCESSOR: COLORPICKER_VALUE_ACCESSOR,
    ColorPicker: ColorPicker,
    ColorPickerModule: ColorPickerModule,
    ConfirmDialog: ConfirmDialog,
    ConfirmDialogModule: ConfirmDialogModule,
    ContextMenuSub: ContextMenuSub,
    ContextMenu: ContextMenu,
    ContextMenuModule: ContextMenuModule,
    DataGrid: DataGrid,
    DataGridModule: DataGridModule,
    DataList: DataList,
    DataListModule: DataListModule,
    DataScroller: DataScroller,
    DataScrollerModule: DataScrollerModule,
    DTRadioButton: DTRadioButton,
    DTCheckbox: DTCheckbox,
    ColumnHeaders: ColumnHeaders,
    ColumnFooters: ColumnFooters,
    TableBody: TableBody,
    ScrollableView: ScrollableView,
    DataTable: DataTable,
    DataTableModule: DataTableModule,
    DeferredLoader: DeferredLoader,
    DeferModule: DeferModule,
    Dialog: Dialog,
    DialogModule: DialogModule,
    Draggable: Draggable,
    Droppable: Droppable,
    DragDropModule: DragDropModule,
    DROPDOWN_VALUE_ACCESSOR: DROPDOWN_VALUE_ACCESSOR,
    Dropdown: Dropdown,
    DropdownModule: DropdownModule,
    EDITOR_VALUE_ACCESSOR: EDITOR_VALUE_ACCESSOR,
    Editor: Editor,
    EditorModule: EditorModule,
    Fieldset: Fieldset,
    FieldsetModule: FieldsetModule,
    FileUpload: FileUpload,
    FileUploadModule: FileUploadModule,
    Galleria: Galleria,
    GalleriaModule: GalleriaModule,
    GMap: GMap,
    GMapModule: GMapModule,
    Growl: Growl,
    GrowlModule: GrowlModule,
    InplaceDisplay: InplaceDisplay,
    InplaceContent: InplaceContent,
    Inplace: Inplace,
    InplaceModule: InplaceModule,
    INPUTMASK_VALUE_ACCESSOR: INPUTMASK_VALUE_ACCESSOR,
    InputMask: InputMask,
    InputMaskModule: InputMaskModule,
    INPUTSWITCH_VALUE_ACCESSOR: INPUTSWITCH_VALUE_ACCESSOR,
    InputSwitch: InputSwitch,
    InputSwitchModule: InputSwitchModule,
    InputText: InputText,
    InputTextModule: InputTextModule$1,
    InputTextarea: InputTextarea,
    InputTextareaModule: InputTextareaModule,
    KEYFILTER_VALIDATOR: KEYFILTER_VALIDATOR,
    KeyFilter: KeyFilter,
    KeyFilterModule: KeyFilterModule,
    Lightbox: Lightbox,
    LightboxModule: LightboxModule,
    LISTBOX_VALUE_ACCESSOR: LISTBOX_VALUE_ACCESSOR,
    Listbox: Listbox,
    ListboxModule: ListboxModule,
    MegaMenu: MegaMenu,
    MegaMenuModule: MegaMenuModule,
    MenuItemContent: MenuItemContent,
    Menu: Menu,
    MenuModule: MenuModule,
    MenubarSub: MenubarSub,
    Menubar: Menubar,
    MenubarModule: MenubarModule,
    Messages: Messages,
    MessagesModule: MessagesModule,
    UIMessage: UIMessage,
    MessageModule: MessageModule,
    MULTISELECT_VALUE_ACCESSOR: MULTISELECT_VALUE_ACCESSOR,
    MultiSelect: MultiSelect,
    MultiSelectModule: MultiSelectModule,
    OrderList: OrderList,
    OrderListModule: OrderListModule,
    OrganizationChartNode: OrganizationChartNode,
    OrganizationChart: OrganizationChart,
    OrganizationChartModule: OrganizationChartModule,
    OverlayPanel: OverlayPanel,
    OverlayPanelModule: OverlayPanelModule,
    Paginator: Paginator,
    PaginatorModule: PaginatorModule,
    Panel: Panel,
    PanelModule: PanelModule,
    BasePanelMenuItem: BasePanelMenuItem,
    PanelMenuSub: PanelMenuSub,
    PanelMenu: PanelMenu,
    PanelMenuModule: PanelMenuModule,
    Password: Password,
    PasswordModule: PasswordModule,
    PickList: PickList,
    PickListModule: PickListModule,
    ProgressBar: ProgressBar,
    ProgressBarModule: ProgressBarModule,
    ProgressSpinner: ProgressSpinner,
    ProgressSpinnerModule: ProgressSpinnerModule,
    RADIO_VALUE_ACCESSOR: RADIO_VALUE_ACCESSOR,
    RadioButton: RadioButton,
    RadioButtonModule: RadioButtonModule,
    RATING_VALUE_ACCESSOR: RATING_VALUE_ACCESSOR,
    Rating: Rating,
    RatingModule: RatingModule,
    Schedule: Schedule,
    ScheduleModule: ScheduleModule,
    ScrollPanel: ScrollPanel,
    ScrollPanelModule: ScrollPanelModule,
    SELECTBUTTON_VALUE_ACCESSOR: SELECTBUTTON_VALUE_ACCESSOR,
    SelectButton: SelectButton,
    SelectButtonModule: SelectButtonModule,
    SlideMenuSub: SlideMenuSub,
    SlideMenu: SlideMenu,
    SlideMenuModule: SlideMenuModule,
    SLIDER_VALUE_ACCESSOR: SLIDER_VALUE_ACCESSOR,
    Slider: Slider,
    SliderModule: SliderModule,
    Sidebar: Sidebar,
    SidebarModule: SidebarModule,
    SPINNER_VALUE_ACCESSOR: SPINNER_VALUE_ACCESSOR,
    Spinner: Spinner,
    SpinnerModule: SpinnerModule,
    SplitButton: SplitButton,
    SplitButtonModule: SplitButtonModule,
    Steps: Steps,
    StepsModule: StepsModule,
    TabViewNav: TabViewNav,
    TabPanel: TabPanel,
    TabView: TabView,
    TabViewModule: TabViewModule,
    TabMenu: TabMenu,
    TabMenuModule: TabMenuModule,
    Terminal: Terminal,
    TerminalModule: TerminalModule,
    TieredMenuSub: TieredMenuSub,
    TieredMenu: TieredMenu,
    TieredMenuModule: TieredMenuModule,
    TOGGLEBUTTON_VALUE_ACCESSOR: TOGGLEBUTTON_VALUE_ACCESSOR,
    ToggleButton: ToggleButton,
    ToggleButtonModule: ToggleButtonModule,
    Toolbar: Toolbar,
    ToolbarModule: ToolbarModule,
    Tooltip: Tooltip,
    TooltipModule: TooltipModule,
    UITreeNode: UITreeNode,
    Tree: Tree,
    TreeModule: TreeModule,
    TreeTableService: TreeTableService,
    TreeTable: TreeTable,
    TTBody: TTBody,
    TTScrollableView: TTScrollableView,
    TTSortableColumn: TTSortableColumn,
    TTSortIcon: TTSortIcon,
    TTResizableColumn: TTResizableColumn,
    TTReorderableColumn: TTReorderableColumn,
    TTSelectableRow: TTSelectableRow,
    TTSelectableRowDblClick: TTSelectableRowDblClick,
    TTContextMenuRow: TTContextMenuRow,
    TTCheckbox: TTCheckbox,
    TTHeaderCheckbox: TTHeaderCheckbox,
    TTEditableColumn: TTEditableColumn,
    TreeTableCellEditor: TreeTableCellEditor,
    TreeTableToggler: TreeTableToggler,
    TreeTableModule: TreeTableModule,
    TRISTATECHECKBOX_VALUE_ACCESSOR: TRISTATECHECKBOX_VALUE_ACCESSOR,
    TriStateCheckbox: TriStateCheckbox,
    TriStateCheckboxModule: TriStateCheckboxModule
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWOverlayModule = /** @class */ (function () {
    function AWOverlayModule() {
    }
    AWOverlayModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        OverlayComponent
                    ],
                    imports: [
                        CommonModule,
                        AWCoreComponentModule,
                        OverlayPanelModule
                    ],
                    entryComponents: [
                        OverlayComponent
                    ],
                    exports: [
                        OverlayComponent,
                        AWCoreComponentModule
                    ],
                    providers: []
                },] },
    ];
    return AWOverlayModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AWHoverCardModule = /** @class */ (function () {
    function AWHoverCardModule() {
    }
    AWHoverCardModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        HoverCardComponent
                    ],
                    imports: [
                        CommonModule,
                        AWOverlayModule,
                        AWStringFieldModule
                    ],
                    entryComponents: [
                        HoverCardComponent
                    ],
                    exports: [
                        HoverCardComponent
                    ],
                    providers: []
                },] },
    ];
    return AWHoverCardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Component module is core module for the common layouts and widgets libraries.
 *
 * todo: There are some things that I still need to resolve - please see and notices \@Duplicates
 * jsdoc I want to keep this there to remind me that I need to refactor this as of now there are
 * not much option with angular.
 *
 */
var AribaComponentsModule = /** @class */ (function () {
    function AribaComponentsModule() {
    }
    /**
     * @return {?}
     */
    AribaComponentsModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AribaComponentsModule,
            providers: [
                ModalService,
                ComponentRegistry,
                ErrorManagerService,
                DomUtilsService,
                DataTypeProviderRegistry,
                DataProviders,
                DataFinders,
                AwNameStore,
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerComponents,
                    deps: [ComponentRegistry],
                    multi: true,
                }
            ]
        };
    };
    AribaComponentsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        AribaCoreModule,
                        CommonModule,
                        FormsModule,
                        ReactiveFormsModule,
                        AWCoreComponentModule,
                        AWBasicNavigatorModule,
                        AWCardModule,
                        AWCheckBoxListModule,
                        AWCheckBoxModule,
                        AWChooserModule,
                        AWConfirmationModule,
                        AWCurrencyModule,
                        AWDateAndTimeModule,
                        AWDialogModule,
                        AWDropdownModule,
                        AWGenericChooserModule,
                        AWHyperlinkModule,
                        AWInputFieldModule,
                        AWOutlineForModule,
                        AWOverlayModule,
                        AWPageNotificationModule,
                        AWPageWrapperModule,
                        AWRadioButtonModule,
                        AWRadioButtonListModule,
                        AWRichTextAreaModule,
                        AWScrollableContainerModule,
                        AWSectionModule,
                        AWStepperModule,
                        AWStringFieldModule,
                        AWTextAreaModule,
                        AWFormTableModule,
                        AWButtonModule,
                        AWHoverCardModule,
                        AWListModule,
                        AWDatatable2Module,
                        PanelModule,
                        ButtonModule,
                        ToolbarModule,
                        InputTextModule$1,
                        InputTextareaModule,
                        AutoCompleteModule,
                        DropdownModule,
                        CalendarModule,
                        CheckboxModule,
                        RadioButtonModule,
                        SharedModule,
                        DialogModule,
                        MenuModule,
                        TabMenuModule,
                        AccordionModule,
                        EditorModule,
                        DataTableModule,
                        PaginatorModule,
                        OverlayPanelModule
                    ],
                    declarations: [
                        SpyLifeCycleHooksDirective,
                    ],
                    bootstrap: [],
                    entryComponents: [
                        Checkbox,
                        Dialog
                    ],
                    exports: [
                        ReactiveFormsModule,
                        FormsModule,
                        SpyLifeCycleHooksDirective,
                        AWCoreComponentModule,
                        AWBasicNavigatorModule,
                        AWCardModule,
                        AWCheckBoxListModule,
                        AWCheckBoxModule,
                        AWChooserModule,
                        AWConfirmationModule,
                        AWCurrencyModule,
                        AWDateAndTimeModule,
                        AWDialogModule,
                        AWDropdownModule,
                        AWGenericChooserModule,
                        AWHyperlinkModule,
                        AWInputFieldModule,
                        AWOutlineForModule,
                        AWOverlayModule,
                        AWPageNotificationModule,
                        AWPageWrapperModule,
                        AWRadioButtonModule,
                        AWRadioButtonListModule,
                        AWRichTextAreaModule,
                        AWScrollableContainerModule,
                        AWSectionModule,
                        AWStepperModule,
                        AWStringFieldModule,
                        AWTextAreaModule,
                        AWFormTableModule,
                        EmbeddedItemDirective,
                        AWButtonModule,
                        AWHoverCardModule,
                        AWListModule,
                        AWDatatable2Module,
                        SharedModule,
                        PanelModule,
                        ButtonModule,
                        ToolbarModule,
                        InputTextModule$1,
                        InputTextareaModule,
                        AutoCompleteModule,
                        DropdownModule,
                        CalendarModule,
                        CheckboxModule,
                        RadioButtonModule,
                        DialogModule,
                        MenuModule,
                        TabMenuModule,
                        EditorModule,
                        DataTableModule,
                        PaginatorModule,
                        OverlayPanelModule
                    ]
                },] },
    ];
    return AribaComponentsModule;
}());
/**
 * @param {?} compRegistry
 * @return {?}
 */
function registerComponents(compRegistry) {
    return compRegistry.initialize.bind(compRegistry, components);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 *
 * This module is used mainly for tests as importing a module with all the components and you
 * use only 1 or two has a big impact on the performance execution. e.g. from executing couple
 * tests under 1 sec can go up to 10sec if you import all the things that you are not using.
 *
 * I havent noticed anything similar in application its only jasmine/karma that needs to init
 * components for every test.
 *
 */
var AribaComponentsTestProviderModule = /** @class */ (function () {
    function AribaComponentsTestProviderModule() {
    }
    /**
     * @return {?}
     */
    AribaComponentsTestProviderModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AribaComponentsTestProviderModule,
            providers: [
                ModalService,
                ComponentRegistry,
                ErrorManagerService,
                DomUtilsService,
                DataTypeProviderRegistry,
                DataProviders,
                DataFinders,
                AwNameStore,
                {
                    provide: APP_INITIALIZER,
                    useFactory: registerComponents$1,
                    deps: [ComponentRegistry],
                    multi: true,
                }
            ]
        };
    };
    AribaComponentsTestProviderModule.decorators = [
        { type: NgModule, args: [{
                    imports: []
                },] },
    ];
    return AribaComponentsTestProviderModule;
}());
/**
 * @param {?} compRegistry
 * @return {?}
 */
function registerComponents$1(compRegistry) {
    return compRegistry.initialize.bind(compRegistry, components);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { ErrorMessagesComponent, ModalContainer, ModalService, ModalComponent, CurrencyFormatPipe, BaseComponent, WidgetSizeColumns, DomUtilsService, EmbeddedItemDirective, EmbededItem, ErrorManagerService, GenericContainerComponent, IncludeComponentDirective, ComponentRegistry, AWCoreComponentModule, BaseFormComponent, DataTypeProviderRegistry, DataProvider, DataProviders, DataFinders, DataFinder, QueryType, FullTextArrayDataFinder, DATA_SOURCE, ArrayDataProvider, NgForSetDirective, AwNameDirective, AwNameStore, FormTableComponent, FormRowComponent, TopZoneComponent, LeftZoneComponent, MiddleZoneComponent, RightZoneComponent, BottomZoneComponent, AWFormTableModule, BasicNavigatorComponent, ButtonComponent, CheckBoxListComponent, CHOOSER_CONTROL_VALUE_ACCESSOR, ChooserComponent, ChooserState, DefaultSelectionState, ChooserSelectionState, CURRENCY_CONTROL_VALUE_ACCESSOR, CurrencyComponent, Money, DateAndTimeComponent, DATETIME_CONTROL_VALUE_ACCESSOR, DialogComponent, DialogHeaderComponent, DialogFooterComponent, ConfirmationComponent, ConfirmationHeaderComponent, ConfirmationFooterComponent, OverlayComponent, DropdownComponent, GCChooserState, GenericChooserComponent, HyperlinkComponent, INPUT_CONTROL_VALUE_ACCESSOR, InputFieldComponent, RadioButtonListComponent, StringComponent, TEXTAREA_CONTROL_VALUE_ACCESSOR, TextAreaComponent, OutlineForComponent, OutlineControlComponent, PageActionsComponent, PageContentComponent, PageFooterComponent, PageHeaderComponent, PageMenuItem, UserNotification, PageNotificationComponent, PageNotification, PageInitialized, PageDestroyed, PageWrapper, PageLifeCycleService, ObjectPageWrapperComponent, SectionComponent, SubSectionComponent, RichTextAreaComponent, EditorType, CheckboxComponent, RadioButtonComponent, StepperComponent, StepComponent, AWInputFieldModule, AWStringFieldModule, AWBasicNavigatorModule, AWButtonModule, AWHyperlinkModule, AWCardModule, AWCheckBoxModule, AWCheckBoxListModule, AWChooserModule, AWDropdownModule, AWCurrencyModule, AWDateAndTimeModule, AWDialogModule, AWGenericChooserModule, AWRadioButtonModule, AWRadioButtonListModule, AWTextAreaModule, AWPageNotificationModule, AWPageWrapperModule, AWRichTextAreaModule, AWSectionModule, AWStepperModule, ScrollableContainerComponent, AWScrollableContainerModule, AWConfirmationModule, ChooserDataSource, isDSChooserInitParams, HoverCardComponent, ListComponent, AWListModule, CardComponent, OutlineState, Datatable2Component, DTColumn2Component, DTHeaderComponent2, DTDetailRowComponent, DetailRowExpansionState, Datatable2State, isDTInitParams, DT2DataSource, DTMultiSelectColumnComponent, AWDatatable2Module, AribaComponentsModule, AribaComponentsTestProviderModule, SpyLifeCycleHooksDirective, registerComponents as ɵq, registerComponents$1 as ɵr, DataSource as ɵa, InfiniteScrollComponent as ɵs, CardZoneTitleComponent as ɵi, CardZoneBottomComponent as ɵh, CardZoneTopComponent as ɵg, AWCardModule as ɵb, CB_LIST_CONTROL_VALUE_ACCESSOR as ɵd, CB_CONTROL_VALUE_ACCESSOR as ɵn, DTDetailRowExpanderComponent as ɵv, DTSingleSelectColumnComponent as ɵw, SetCellMaxWidthDirective as ɵx, DTDraggableRowDirective as ɵy, DTWrapper as ɵu, DD_CONTROL_VALUE_ACCESSOR as ɵe, AWHoverCardModule as ɵba, LB_CONTROL_VALUE_ACCESSOR as ɵp, InitNestingDirective as ɵj, AWOutlineForModule as ɵc, AWOverlayModule as ɵz, SidenavComponent as ɵk, RB_LIST_CONTROL_VALUE_ACCESSOR as ɵf, RAB_CONTROL_VALUE_ACCESSOR as ɵo, EDITOR_CONTROL_VALUE_ACCESSOR as ɵm, SectionActionsComponent as ɵl };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJpYmF1aS1jb21wb25lbnRzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZW1iZWRkZWQtaXRlbS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2dlbmVyaWMtY29udGFpbmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Jhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvb24tbmdmb3Itc2V0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RvbS11dGlscy5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvaW5maXRlLXNjcm9sbC9pbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9jb3JlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9hcnJheS1kYXRhLXByb3ZpZGVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycy50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RhdGEvZGF0YS1maW5kZXJzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9sYXlvdXRzL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9idXR0b24vYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLXRpdGxlL2NhcmQtdGl0bGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9oeXBlcmxpbmsvaHlwZXJsaW5rLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRlLWFuZC10aW1lLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWZvb3Rlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtc3RhdGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3RleHQtYXJlYS90ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1ldmVudHMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1saWZlY3ljbGUuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIvb2JqZWN0LXBhZ2Utd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1hY3Rpb25zL3BhZ2UtYWN0aW9ucy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1jb250ZW50L3BhZ2UtY29udGVudC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zdGVwcGVyL3N0ZXBwZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwL3N0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3NlY3Rpb24vc2VjdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9hdy1kYXRhdGFibGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RpcmVjdGl2ZXMvZHQtY2VsbC1kaXJlY3RpdmVzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9saXN0L2xpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3NweS1saWZlY3ljbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvYXJpYmEuY29tcG9uZW50Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9hcmliYS5jb21wb25lbnQucHJvdmlkZXIubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBXaGVuIHdlIGhhdmUgYSBjdXN0b20gY29tcG9uZW50IGxpa2UgZHJvcGRvd24sIHJhZGlvYnV0dG9ubGlzdCBhbmRcbiAqIG1hbnkgbW9yZSB3ZSB3YW50IHRvIHByb3ZpZGUgYSBjdXN0b20gY29udGVudCB0byBpdCBsaWtlIHNvOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICpcbiAqIGBgYFxuICogV2hvIGVsc2Ugd291bGQga25vdyBob3cgdG8gcmVuZGVyIGxpc3Qgb2Ygb2JqZWN0cy4uXG4gKlxuICogQnV0IGl0cyBub3QgcG9zc2libGUgaW4gY3VycmVudCBmb3JtLiBpZiBJIGRvIG5vdCBwcm92aWRlIEFuZ3VsYXIgc29tZSBhcyB0aGV5IGNhbGwgaXQgdGhpc1xuICogc3ludGFjdGljIHN1Z2FyICosXG4gKlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biAqbXlTdWdlckRpcmVjdGl2ZT0uLi4uLj5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICogYGBgXG4gKlxuICpcbiAqIHRoZW4gYW5ndWxhciB3aWxsIG5vdCBrbm93ICBpbnNpZGUgaXMgYSB0ZW1wbGF0ZSBhbmQgSSB3b250IGJlIGFibGUgdG8gZ2V0IGhvbGQgb2YgVGVtcGxhdGVSZWZcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50XG4gKlxuICogU28gdGhlIG9ubHkgd2F5IEkgZm91bmQgKGV4cGVjdGluZyBJIGRvIG5vdCB3YW50IHRvIGNoYW5nZSBhbnl0aGluZyBpbiB0ZXJtcyBvZiBiaW5kaW5ncyBhbmQgdGhlXG4gKiBzaWduYXR1cmUgSSB1c2UgaXQuIEkgaGF2ZSB0byB1c2UgaXQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtPiB7e2l0ZW0udXNlck5hbWV9fTwvbmctdGVtcGxhdGU+XG4gKlxuICogICA8YXctZHJvcGRvd25cbiAqXG4gKiBgYGBcbiAqXG4gKiAgVGhpcyB3YXkgaXQgY291bGQgd29yay4gU2luY2UgSSBhbSBpbnNpZGUgbmdGb3IgSSB3YW50IHRvIHJlbmRlciB0aGUgaXRlbSBpbnRvIHRoZSBjb3JyZWN0XG4gKiB2aWV3Q29udGFpbmVyIG9mIG5nRm9yJ3MgY3VycmVudCBpdGVtLlxuICpcbiAqICBUaGlzIHdheSBJIGNhbiBhbHNvIGV4cG9zZSBpdGVtIG91dHNpZGUgdXNpbmcgQW5ndWxhcidzIHNwZWNpYWwgbG9jYWwgdmFyaWFibGUgY2FsbGVkOlxuICogJGltcGxpY2l0LlxuICpcbiAqIFRoaXMgZ2V0cyBldmVuIG1vcmUgY29tcGxleCBpZiB3ZSB0cnkgdG8gcGFzcyB0aGlzIHRlbXBsYXRlIDIgbGV2ZWxzIGRvd24sIGxpa2UgaW4gY2FzZSBvZlxuICogUmFkaW9CdXR0b25MaXN0LiBCdXQgbGF0ZXIgb24gSSBtaWdodCB3YW50IHRvIHJlZmFjdG9yIHRoaXMgaW50byBjdXN0b20gTkcgRk9SXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbmdUZW1wbGF0ZU91dGxldCAod2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tlbWJlZGRlZEl0ZW1dJ30pXG5leHBvcnQgY2xhc3MgRW1iZWRkZWRJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzXG57XG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgd2Ugd2FudCB0byByZW5kZXIgTi1UaW1lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1iZWRkZWRJdGVtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFZhbHVlID0gaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbXBsaWNpdFZhbHVlOiBhbnk7XG4gICAgcHJpdmF0ZSBfdmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fdmlld1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXIuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZW1iZWRkZWRJdGVtKSkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgRW1iZWRlZEl0ZW0odGhpcy5faW1wbGljaXRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5lbWJlZGRlZEl0ZW0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgQW5ndWxhcidzIEVtYmVkZGVkVmlld1JlZi5jb250ZXh0KClcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBFbWJlZGVkSXRlbVxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ6IGFueSlcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCBpcyB1c2VkIGJ5IGluY2x1ZGUtY29tcG9uZW50LmRpcmVjdGl2ZSB0byBkeW5hbWljYWxseSBjcmVhdGUgYW5cbiAqIEhUTUxFbGVtZW50IGFuZCB1c2UgdGhpcyBlbGVtZW50IHRvIHdyYXAgYSBjaGlsZCBjb21wb25lbnQuIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvXG4gKiBtb2RpZnkgYSBjaGlsZCBieSB3cmFwcGluZyBpdCB3aXRoIGEgYm9yZGVyLCBhIGJhY2tncm91bmQsIG9yIGJvbGQgaXRzIHRleHQuXG4gKlxuICogVGhlIHdyYXBwZXIgZWxlbWVudCBpcyBkeW5hbWljYWxseSBjcmVhdGVkLiBJdCdzIGVsZW1lbnQgaXMgc3BlY2lmaWVkIGJ5IHRoZSB0YWdOYW1lIHByb3BlcnR5IGluXG4gKiB0aGUgYmluZGluZ3MgQElucHV0LlxuICpcbiAqICAjIyMgRXhhbXBsZS4gIERpcmVjdGx5IGluIGh0bWxcbiAqXG4gKiAgIGFwcC5odG1sXG4gKiAgICAgIDxhdy1nZW5lcmljLWNvbnRhaW5lciB0YWdOYW1lPVwidGFnTmFtZVwiIGJpbmRpbmdzPVwiYmluZGluZ3NcIj5cbiAqICAgICAgICAgIDxteS1jb21wb25lbnQgLi5iaW5kaW5ncy4uPjwvbXktY29tcG9uZW50PlxuICogICAgICA8L2F3LWdlbmVyaWMtY29udGFpbmVyPlxuICpcbiAqICAgYXBwLmNvbXBvbmVudC50c1xuICpcbiAqICAgICAgIHRhZ05hbWUgPSAoYkJvbGQpID8gJ2gxJyA6ICdzcGFuJztcbiAqICAgICAgIGJpbmRpbmdzID0geyAgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnIH1cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZ2VuZXJpYy1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgc3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrXG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRhZ05hbWUgaWYgbm9uZSBpcyBzcGVjaWZpZWQgaW5zaWRlIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IERlZmF1bHRUYWdOYW1lID0gJ2Rpdic7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kaW5ncyB0byBiZSBhZGRlZCBhcyBhdHRyaWJ1dGVzIHRvIHRoZSB0YWdOYW1lIGVsZW1lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gYmUgY3JlYXRlZCB0aGF0IHdyYXBzIGl0J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhZ05hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByb290IGVsZW1lbnQuIFBvaW50cyB0byA8YXctZ2VuZXJpYy1jb250YWluZXI+XG4gICAgICovXG4gICAgcHJpdmF0ZSBuYXRpdmVFbGVtZW50OiBOb2RlO1xuXG4gICAgcHJpdmF0ZSBjaGlsZEVsZW1lbnQ6IE5vZGU7XG5cblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHJlbmRlcmVyIC0gUmVuZGVyZXIgaXMgdXNlZCB0byBjcmVhdGUgJ3RhZ05hbWUnIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiwgdmVyaWZ5IHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGlucHV0LCB0aGlzIGNvbXBvbmVudCB3b3VsZG4ndCBrbm93IHdoYXQgdG8gZG8gYW5kIHRocm93IGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5iaW5kaW5ncykgJiYgaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbmVyaWNDb250YWluZXJDb21wb25lbnQgaW5wdXQgYmluZGluZ3Mgb3IgdGFnTmFtZSAnICtcbiAgICAgICAgICAgICAgICAnaGF2ZSBub3QgYmVlbiBzZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdGFnTmFtZSBpcyBibGFuaywgdGhlIGdldCBpdCBmcm9tIGJpbmRpbmdzLlxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ05hbWUgPSB0aGlzLmJpbmRpbmdzLmdldCgndGFnTmFtZScpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9IEdlbmVyaWNDb250YWluZXJDb21wb25lbnQuRGVmYXVsdFRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGZpcnN0IGFkZGVkXG4gICAgICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY2hpbGRFbGVtZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5jaGlsZEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblxuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBjb250ZW50IGhhcyBiZWVuIGluaXRpYWxpemVkLiBDcmVhdGUgdGhlIHRhZ05hbWUgZWxlbWVudC4gQXBwbHkgYWxsIHRoZSBiaW5kaW5ncyBvbiB0b1xuICAgICAqIHRoZSBlbGVtZW50IGFzIGF0dHJpYnV0ZS4gRmluYWxseSwgbW92ZSB0aGUgY2hpbGQgZWxlbWVudCwgPG5nLWNvbnRlbnQ+LCB0byBpbnNpZGUgdGhlXG4gICAgICogd3JhcHBlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb1JlbmRlcigpXG4gICAge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmF0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5uYXRpdmVFbGVtZW50LCBlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBiaW5kaW5ncyBhbmQgYWRkIHRoZW0gdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUodGhpcy5iaW5kaW5ncykuZm9yRWFjaCgodiwgaykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgaywgdik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoaXMgZGl2RWxlbWVudC5cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgIH1cblxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RG9DaGVjaywgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBcHBDb25maWcsIEVudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqICBCYXNlIGNvbXBvbmVudCBzaGFyZXMgY29tbW9uIGZ1bmN0aW9uYWxpdHkgYW1vbmcgYWxsIHRoZSBjb21wb25lbnRzIChsYXlvdXRzLCB3aWRnZXRzKS5cbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2ssIE9uRGVzdHJveVxue1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBkaXNhYmxlZCBmbGFnIHRvIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogV2VhdGhlciB0aGlzIGNvbXBvbmVudCBpcyB2aXNpYmxlXG4gICAgICogRGVmYXVsdCBpcyBmYWxzZTtcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGwgIHRoZSBjb21wb25lbnQgaWYgd2UgYXJlIGluIGVkaXRpbmcgbW9kZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFibGU/OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IGNvbXBvbmVudCBoYXZlIG9wdGlvbiB0byBzZXQgYSBjdXN0b20gd2l0aFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB3aWR0aDogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlcnkgY29tcG9uZW50IGhhdmUgb3B0aW9uIHRvIHNldCBhIGN1c3RvbSB3aXRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoZWlnaHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIG9wdGlvbmFsIGNzcyBjbGFzcyB3aGljaCBjYW4gYmUgdXRpbGl6ZWQgYnkgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdHlsZUNsYXNzOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHBhZGRpbmcgZnJvbSB0aGUgY29tcG9uZW50LiBVc3VhbGx5IHVzZWQgd2hlbiB3ZSBhcmUgbmVzdGluZyBvdGhlciBjb21wb25lbnQgd2l0aFxuICAgICAqIGl0cyBvd24gZ3JpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9taXRQYWRkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBleHRlbnNpb24gc3VwcG9ydCByZWdpc3RlciBoZXJlIGFueSBkeW5hbWljIGZpZWxkIHRoYXQgZG9lcyBub3QgZXhpc3Rpbmcgb24gdGhlXG4gICAgICogY2xhc3MvY29tcG9uZW50XG4gICAgICovXG4gICAgZXh0QmluZGluZ3M6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFByZWZpeCBmb3IgdGhlIGNvcnJlY3QgYXNzZXQgcGF0aFxuICAgICAqL1xuICAgIGFzc2V0Rm9sZGVyOiBzdHJpbmcgPSAnYXNzZXRzJztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY/OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHRoaXMuZXh0QmluZGluZ3MgPSBuZXcgTWFwPHN0cmluZywgYW55PigpO1xuICAgICAgICB0aGlzLm9taXRQYWRkaW5nID0gZmFsc2U7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmFzc2V0Rm9sZGVyID0gdGhpcy5lbnYuZ2V0VmFsdWUoQXBwQ29uZmlnLkFzc2V0Rm9sZGVyKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudCwgbm9vcCwgdXVpZH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge2ZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBQaXBlVHJhbnNmb3JtLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIHgtc21hbGwgPSA+IDEyJSAgPSA+IGNvbC0xXG4gKiBzbWFsbCA9ID4gYFxuICogbWVkaXVtID0gPiA1MCUgICA9ID4gY29sLTZcbiAqIGxhcmdlID0gPiA3NSUgICAgPSA+IGNvbC05XG4gKiBsYXJnZSA9ID4gMTAwJSAgID0gPiBjb2wtMTJcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIFdpZGdldFNpemUgPSAneC1zbWFsbCcgfCAnc21hbGwnIHwgJ21lZGl1bScgfCAnbGFyZ2UnIHwgJ3gtbGFyZ2UnO1xuXG5leHBvcnQgZW51bSBXaWRnZXRTaXplQ29sdW1uc1xue1xuICAgIHhzbWFsbCA9IDEsXG4gICAgc21hbGwgPSAzLFxuICAgIG1lZGl1bSA9IDYsXG4gICAgbGFyZ2UgPSA5LFxuICAgIHhsYXJnZSA9IDEyXG59XG5cblxuLyoqXG4gKiAgQmFzZUZvcm1Db21wb25uZXQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGZvciBhZGQgc3BlY2lmaWMgZm9ybSBiZWhhdmlvclxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VGb3JtQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG57XG4gICAgLypcbiAgICAgKiAgU3VwcG9ydGVkIGxheW91dCBjb25zdGFudHMuIEl0IGlzIGV4cGVjdGVkIHRoZXJlIHdpbGwgYmUgbW9yZSBvcHRpb25zIGFzIHdlIGN1cnJlbnRseVxuICAgICAqICBzdXBwb3J0IG9ubHkgdGhlc2UgdHdvIHRoZXJlIHdpbGwgYmUgb3RoZXIgdmFyaWF0aW9ucyBvZiBpdC4gZS5nLiBmb3Igc3RhY2tlZCBpdCB3aWxsIG5vdFxuICAgICAqICBiZSAxIGNvbHVtbnMgbGlrZSBpdCBpcyBub3cgYnV0IG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZWFkb25seSBMYXlvdXRTdGFja2VkID0gJ3N0YWNrZWQnO1xuICAgIHN0YXRpYyByZWFkb25seSBMYXlvdXRJbmxpbmUgPSAnaW5saW5lJztcblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IG5hbWUgYXR0cmlidXRlLiBDYW4gYmUgdXNlZCB0byBsb29rdXAgY29tcG9uZW50IGluIGZvcm0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBuYW1lOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCBJZC4gQ2FuIGJlIHVzZWQgdG8gbG9va3VwIGNvbXBvbmVudCBpbiBmb3JtLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyBjdXJyZW50IGVsZW1lbnQgdmlzaWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIHBhc3MgaW4gZm9ybUdyb3VwIHdoaWNoIHdpbGwgYmUgdXNlZCB3aXRoIGluIHRoZSBmb3JtXG4gICAgICpcbiAgICAgKiBASW5wdXQoKSAtIHNlZSBnZXR0ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIF9mb3JtR3JvdXA6IEZvcm1Hcm91cDtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyByZXF1aXJlZCBmbGV4IGFyb3VuZCB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqICBhIHRleHQgZGlzcGxheWVkIHdoZW4gdmFsdWUgaXMgZW1wdHkgb3IgTlVMTFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGxhY2VIb2xkZXI6IFN0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZnkgaWYgdGhpcyBjb250cm9sIGlzIHVzZWQgZGlyZWN0bHkgb3IgaWYgaXRzIHBhcnQgb2Ygc29tZSBvdGhlciBjb250cm9sXG4gICAgICogZS5nLiBHZW5lcmljQ2hvb3NlciBhbmQgbWFuYWdlZCBieSB0aGlzIGNvbnRyb2wuXG4gICAgICogTWVhbmluZyBTdGF0ZSBpcyBtYW5hbmdlZCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzU3RhbmRhbG9uZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm0gQ29udHJvbCBmb3IgdGhlIGNvbXBvbmVudC4gSXRzIGVpdGhlciBpbmhlcml0ZWQgc2luY2UgaXQgd2FzIHByZWNyZWF0ZWQgaW4gcGFyZW50XG4gICAgICogY29tcG9uZW50IG9yIGl0cyBjcmVhdGVkIGJhc2VkIG9uIHBhc3NlZCAnbmFtZScgYW5kIHJlZ2lzdGVyZWQgd2l0aCB0aGUgJ2Zvcm1Hcm91cCdcbiAgICAgKlxuICAgICAqIFdoZW4gIGluaXRpYWxpemUgRm9ybUNvbnRyb2wgd2UgZG8gc2V0VmFsdWUgd2l0aCBvbmx5U2VsZjp0cnVlIGZsYWcgYW5kIHdlIGRvIG5vdCBlbWl0IGFueVxuICAgICAqIGV2ZW50IG91dHNpZGVcbiAgICAgKlxuICAgICAqL1xuICAgIGZvcm1Db250cm9sOiBGb3JtQ29udHJvbDtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHRoYXQgY2FuIGJlIGFzc2lnbiB0byB0aGUgY29tcG9uZW50IGluIG9yZGVyIHRvIGZvcm1hdCBpdHMgaW5wdXRcbiAgICAgKi9cbiAgICBmb3JtYXR0ZXI6IFBpcGVUcmFuc2Zvcm07XG5cblxuICAgIHByb3RlY3RlZCBvbk1vZGVsQ2hhbmdlZDogKF86IGFueSkgPT4gdm9pZCA9IG5vb3A7XG4gICAgcHJvdGVjdGVkIG9uTW9kZWxUb3VjaGVkOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcblxuXG4gICAgLyoqXG4gICAgICogU29tZSBvZiB0aGUgQmFzZUZvcm1Db21wb25lbnQgY2FuIHdyYXAgb3RoZXIgY29tcG9uZW50IGFuZCBpbiB0aGVzZSBjYXNlcyB3ZSB3YW50IHRvXG4gICAgICogaW5oZXJpdCBzb21lIG9mIHRoZSBiZWhhdmlvciBmcm9tIHBhcmVudFxuICAgICAqXG4gICAgICogQEluamVjdChFbnZpcm9ubWVudCkgcHVibGljIGVudjogRW52aXJvbm1lbnQgOiBpcyB0ZW0gYSB3b3JrYXJvdW5kIGFzIHdpdGhvdXQgaW5qZWN0XG4gICAgICogb24gdGhpcyBzcGVjaWZpYyBjb21wb25lbnQgaXQgY29tcGxhaW5zIHRoYXQgRW52aXJvbm1lbnQgaXMgdW5yZXNvbHZlZCBzeW1ib2xcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yIChASW5qZWN0KEVudmlyb25tZW50KSBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUdyb3VwID0gdGhpcy5wYXJlbnRDb250YWluZXIuZm9ybUdyb3VwO1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jaGVja0luaXRGb3JtKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgdGhhdCB3ZSBoYXZlIGF2YWlsYWJsZSBmb3JtR3JvdXAgYW5kIE5hbWUgYW5kIElEXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY2hlY2tJbml0Rm9ybSAoKVxuICAgIHtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmVudi5jdXJyZW50Rm9ybSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVG9kbzogUmlnaHQgbm93IEkganVzdCBuZWVkIHRvIGluaXRpYWxpemUgbmFtZSAsIGJ1dCBpZGVhbGx5IGl0IG5lZWRzIHRvIGJlIGdlbmVyYXRlZFxuICAgICAgICAgKiBudW1iZXIgYmFzZWRvbiBzb21lIHNlbWFudGljcyBhcHAucGFnZS5jb21wb25lbnQgaWYgdGhlcmUgYXJlIG1vcmUgY29tcG9uZW50IG9uIHRoZSBwYWdlXG4gICAgICAgICAqIHRoZW4gYXBwLnBhZ2UuY29tcG9uZW50TnVtYmVyLiBTaW1wbGUgc29sdXRpb24gaXMgdG8gaXMgdG8gZ2V0IEVsZW1lbnRyZWYgYW5kIHF1ZXJ5IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdXVpZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB1dWlkKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3RlY3RlZCBkb1JlZ2lzdGVyIChuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBGb3JtQ29udHJvbFxuICAgIHtcblxuICAgICAgICBsZXQgZkNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtR3JvdXAucmVnaXN0ZXJDb250cm9sKG5hbWUsIG5ldyBGb3JtQ29udHJvbCh2YWx1ZSkpO1xuICAgICAgICAgICAgZkNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW25hbWVdO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICBsZXQgdXBkYXRlZFZhbHVlOiBhbnkgPSBpc1ByZXNlbnQoZkNvbnRyb2wudmFsdWUpID8gZkNvbnRyb2wudmFsdWUgOiB2YWx1ZTtcbiAgICAgICAgICAgIGZDb250cm9sLnBhdGNoVmFsdWUodXBkYXRlZFZhbHVlLCB7b25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZkNvbnRyb2w7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGFyZSBkZWFsaW5nIHdpdGggRm9ybXMgdGhpcyBpcyBhIGhlbHBlciBtZXRob2QgdG8gcmVnaXN0ZXIgY29udHJvbFxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgZGVmYXVsdCB2YWx1ZSB0byBiZSBwcmUtc2V0XG4gICAgICovXG4gICAgcmVnaXN0ZXJGb3JtQ29udHJvbCAodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSB0aGlzLmRvUmVnaXN0ZXIodGhpcy5uYW1lLCB2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBASW5wdXQoKSBnZXQgZm9ybUdyb3VwICgpOiBGb3JtR3JvdXBcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5fZm9ybUdyb3VwKSA/IHRoaXMuX2Zvcm1Hcm91cCA6IHRoaXMuZW52LmN1cnJlbnRGb3JtO1xuICAgIH1cblxuICAgIHNldCBmb3JtR3JvdXAgKHZhbHVlOiBGb3JtR3JvdXApXG4gICAge1xuICAgICAgICB0aGlzLl9mb3JtR3JvdXAgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgd2UgY2FuIHBhc3MgZmllbGQgdHlwZSBhcyBhIGJpbmRpbmcgdG8gdGhlIGNvbXBvbmVudHMuIGUuZy4gSW5wdXRGaWVsZCBuZWVkXG4gICAgICogc3VjaCB0eXBlIHRvIGNvcnJlY3RseSByZW5kZXIgaW5wdXQgdHlwZT10ZXh0LCBudW1iZXJcbiAgICAgKlxuICAgICAqIHRvZG86IGlzIHRoaXMgbmVlZGVkPyBjYW4gd2UgbWF5YmUgcGFzcyB0aGlzIHRvIHRoZSBmb3JtUm93P1xuICAgICAqL1xuICAgIGNhblNldFR5cGUgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIHdyaXRlVmFsdWUgKHZhbHVlOiBhbnkpXG4gICAge1xuXG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZSAoZm46IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZCAoZm46IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbFRvdWNoZWQgPSBmbjtcbiAgICB9XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RG9tU2FuaXRpemVyfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSBjb21wb25lbnQgcmVuZGVyaW5nIHZhbHVlcyBpbiB0aGUgcmVhZCBvbmx5IG1vZGUuIEp1c3QgbmVlZGVkIHNvbWUgY29tcG9uZW50IHVzZWRcbiAqIHRvIHJlbmRlciBTdHJpbmdzIGluIHJlYWQgb25seSBtb2RlXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICpcbiAqIFVzaW5nIGl0IGluc2lkZSBmb3JtIGNvbnRhaW5lciBhbG9uZyB3aXRoIGxhYmVsXG4gKlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgIHNlbGVjdG9yOiAndXNlckluZm8nICxcbiAqICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgW2VkaXRhYmxlXT1cImZhbHNlXCIgPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbmFtZV09XCJmaWVsZE5hbWVcIiAgW2xhYmVsXT1cImxhYmVsXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiA+PC9hdy1zdHJpbmc+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgICB9KVxuICogICAgICAgICAgZXhwb3J0IGNsYXNzIFVzZXJQcm9maWxlQ29tcG9uZW50XG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgdGV4dCc7XG4gKiAgICAgICAgICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICAgICAgICAgICAgICBmaWVsZE5hbWU6IHN0cmluZyA9ICdmaXJzdE5hbWUnO1xuICogICAgICAgICAgICAgIGxhYmVsOiBzdHJpbmcgPSAnTXkgTmFtZSc7XG4gKiAgICAgICAgICAgICAgcmVxdWlyZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICAgICAgICAgIGVkaXRpbmc6IGJvb2xlYW4gPSB0cnVlO1xuICogICAgICAgICAgICAgIGxhYmVsc09uVG9wOiBib29sZWFuID0gZmFsc2U7XG4gKlxuICogICAgICAgICAgfVxuICpcbiAqICBgYGBcbiAqXG4gKiBZb3UgY2FuIGFsc28gcGFzcyBodG1sIHRhZ3MuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN0cmluZycsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gY2xhc3M9XCJ3LXN0cmluZy1maWVsZFwiIFtpbm5lckhUTUxdPVwidmFsdWVcIj48L3NwYW4+XG4gICAgYCxcbiAgICBzdHlsZXM6IFtgLnctc3RyaW5nLWZpZWxke2Rpc3BsYXk6aW5saW5lLWJsb2NrfWBdXG59KVxuZXhwb3J0IGNsYXNzIFN0cmluZ0NvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogIFZhbHVlIHRvIGJlIGludGVycG9sYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdmFsdWU6IHN0cmluZyA9ICcnO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBzYW5pdGl6ZXI6IERvbVNhbml0aXplcixcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgfVxuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdEh0bWwodGhpcy5fdmFsdWUpO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1N0cmluZ01hcH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBBIGNsYXNzIGhvbGRpbmcgYSByZWZlcmVuY2VzIHRvIGNvbXBvbmVudHMuIFRoZSBtZXRob2RzIGFyZSBzZWxmLWV4cGxhbmF0b3J5LlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbXBvbmVudFJlZ2lzdHJ5XG57XG4gICAgcHJpdmF0ZSBfbmFtZVRvVHlwZTogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgaW5pdGlhbGl6ZShyZWZlcmVuY2VzOiBhbnkpOiBQcm9taXNlPGFueT5cbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJUeXBlcyhyZWZlcmVuY2VzKTtcbiAgICAgICAgbGV0IHByb21pc2U6IFByb21pc2U8YW55PiA9IG5ldyBQcm9taXNlKChyZXNvbHZlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcblxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJUeXBlKG5hbWU6IHN0cmluZywgdHlwZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLm5hbWVUb1R5cGUuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lVG9UeXBlLnNldChuYW1lLCB0eXBlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcmVnaXN0ZXJUeXBlcyhyZWZlcmVuY2VzOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIWlzU3RyaW5nTWFwKHJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3Qua2V5cyhyZWZlcmVuY2VzKS5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJUeXBlKG5hbWUsIHJlZmVyZW5jZXNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIGdldCBuYW1lVG9UeXBlKCk6IE1hcDxzdHJpbmcsIGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lVG9UeXBlO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBpc0JsYW5rLCBpc1ByZXNlbnQsIE1hcFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTdHJpbmdDb21wb25lbnR9IGZyb20gJy4uL3dpZGdldHMvc3RyaW5nL3N0cmluZy5jb21wb25lbnQnO1xuaW1wb3J0IHtDb21wb25lbnRSZWZlcmVuY2V9IGZyb20gJy4vY29tcG9uZW50LXJlZmVyZW5jZSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcblxuLyoqXG4gKiB0aGlzIGlzIHNwZWNpZmljIGltcG9ydCB0byB3ZSBjYW4gdXNlIGNvbXBvbmVudHMgYXMgY29tcG9uZW50c1t0eXBlbmFtZV0gYW5kICBnZXQgYmFjayBhXG4gKiB0eXBlLlxuICogSSBjb3VsZCBub3QgZmluZCBhbnkgYmV0dGVyIGR5bmFtaWMgd2F5IHVwIHRvIG5vd1xuICovXG4vKipcbiAqICBgSW5jbHVkZUNvbXBvbmVudGAgZGlyZWN0aXZlIGR5bmFtaWNhbGx5IGluc3RhbnRpYXRlIGFuZCBpbnNlcnQgYSBjb21wb25lbnRzIGludG8gdGhlIHNjcmVlblxuICogYmFzZWQgb24gdGhlIG5hbWUuIEl0IGNhbiBhY2NlcHRzIGJpbmRpbmdzIGFzIHdlbGwgd2hpY2ggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kIGFuZCBhcHBsaWVkXG4gKiB0byB0aGUgY29tcG9uZW50XG4gKlxuICogICMjIyB1c2FnZTpcbiAqXG4gKiAgSW5zdGVhZCBvZiBpbnNlcnRpbmcgY29tcG9uZW50IGluIHRoZSB3YXk6XG4gKlxuICogIGBgYFxuICogICAgPHRleHRmaWVsZCB2YWx1ZT1cInNvbWUgdmFsdWVcIj5cbiAqXG4gKiAgYGBgXG4gKlxuICogIHlvdSBjYW4gZG8gc28gZHluYW1pY2FsbHkgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1pbmNsdWRlLWNvbXBvbmVudCAnVGV4dGZpZWxkQ29tcG9uZW50JyBbYmluZGluZ3NdPWJpbmRpbmdzID48L2F3LWluY2x1ZGUtY29tcG9uZW50PlxuICogYGBgXG4gKlxuICogVGhpcyBpcyB0aGUgbWFpbiBidWlsZGluZyBibG9jayB0byBkeW5hbWljYWxseSBnZW5lcmF0ZWQgVUkuXG4gKlxuICpcbiAqIFRvZG86IEN1cnJlbnRseSB0aGUgd2F5IEFuZ3VsYXIgQVBJIHdvcmsgYW5kIHdlIHVzZSBpdCB0byBjcmVhdGUgcHJvZ3JhbWF0aWNhbGx5IGNvbXBvbmVudHNcbiAqIGlzIHRvbyBjb21wbGV4dCB3ZSBuZWVkIHRvIGNyZWF0ZSBldmVyeXRoaW5nIDMgZGlmZmVyZW50IGNhbGxzIHRvIHBsYWNlIGEgY29tcG9uZW50IHRvIHRoZVxuICogY29udGFpbmVyLiBXaGF0IEkgd2FudCBpcyBpcyB0byBjcmVhdGUgc29tZSBraW5kIG9mIHJlcHJlc2VudGF0aW9uIG9mIENvbnRhaW5lckVsZW1lbnQgYW5kIHRoaXNcbiAqIGNhbiBiZSBhbHNvIHBhcmVudCBmb3Igb3VyIEJhc2VDb21wb25lbnQgd2l0aCBtZXRob2QgYWRkIGFuZCByZW1vdmUgY29udGVudC4gVGhlbiB3ZSBjb3VsZCBoYXZlXG4gKiBzb21lIEFXQ29udGVudC5cbiAqXG4gKiBlLmcuOiB0byByZXBsYWNlIGFwcGx5Q29udGVudEVsZW1lbnRJZkFueSB3aGVyZSB3ZSBoYXZlIHNldmVyYWwgY2FsbHMgdG8gY3JlYXRlIGFuZCBhZGRcbiAqIGNvbXBvbmVudCB0byB0aGUgdmlldy5cbiAqXG4gKiBgYGB0c1xuICogIGxldCBjb250YWluZXJFbGVtZW50ID0gQVdDb25jcmV0ZVRlbXBsYXRlKHZpZXdDb250YWluZXIsIGZhY3RvcnlSZXNvbHZlcilcbiAqICBjb250YWluZXJFbGVtZW50LmFkZCgnQ2xjayBNZScpXG4gKiBgYGBcbiAqXG4gKiBUbyBhc3NlbWJsZSBkaWZmZXJlbnQgY29tcG9uZW50cyB0b2dldGhlciAtIG5vdCBvbmx5IGFkZGluZyBzdHJpbmcgY29udGVudFxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRlbnQgPSBuZXcgQVdDb250ZW50KEJ1dHRvbkNvbXBvbmVudCwgYmluZGluZ3NNYXApXG4gKiAgY29udGVudC5hZGQoJ0NsaWNrIE1lJyk7XG4gKiAgY29udGFpbmVyRWxlbWVudC5hZGQoY29udGVudClcbiAqXG4gKiBgYGBcbiAqXG4gKiBhZGQgbW9yZSBjb21wb25lbnQgaGllcmFyY2h5OlxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRlbnQgPSBuZXcgQVdDb250ZW50KEhvdmVyQ2FyZENvbXBvbm5ldHMsIGJpbmRpbmdzTWFwKVxuICogIGNvbnRlbnQuYWRkKGNyZWF0ZUxheW91dCgpO1xuICogIGNvbnRhaW5lckVsZW1lbnQuYWRkKGNvbnRlbnQpXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2F3LWluY2x1ZGUtY29tcG9uZW50J1xufSlcbmV4cG9ydCBjbGFzcyBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95LCBPbkluaXQsIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdDb250ZW50ID0gJ25nY29udGVudCc7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5nQ29udGVudEVsZW1lbnQgPSAnbmdjb250ZW50RWxlbWVudCc7XG5cbiAgICAvKipcbiAgICAgKiBGdWxsIGNvbXBvbmVudCBuYW1lIGUuZy46IERyb3Bkb3duQ29tcG9uZW50IHdoaWNoIGlzIGdvaW5nIHRvIGJlIGluc2VydGVkLiBXZSBuZWVkIHRvIHRha2VcbiAgICAgKiB0aGlzIG5hbWUgYW5kIHRyYW5zbGF0ZSBpdCBpbnRvIGFjdHVhbCBUWVBFLiBJbiBvcmRlciB0byBkbyB0aGlzIHdlIHVzZSBhIHRyaWNrIHdoZXJlIHdlXG4gICAgICogYWNjZXNzIGFuIElNUE9SVEVEIGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4uL2NvbXBvbmVudHMnO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlbiB5b3UgY2FuIHJldHJpZXZlIGEgdHlwZSBieSBqdXN0IGNvbXBvbmVudHNbPFN0cmluZyBMaXRlcmFsID5dID0+IENvbXBvbmVudCBUWVBFXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByb3RlY3RlZCBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBiaW5kaW5ncyB3aGljaCB3aWxsIGJlIHBhc3NlZCBpbnRvIHRoZSBjb21wb25lbnQgd2hlbiBpbnN0YW50aWF0ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByb3RlY3RlZCBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY3JlYXRlZCBjb21wb25lbnQgcmVmZXJlbmNlIHVzaW5nIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlci4gV2UgdXNlIHRoaXMgdG8gYWNjZXNzXG4gICAgICogdGhlIGFjdHVhbCBjb21wb25lbnQgaW5zdGFuY2UgYW5kIEVsZW1lbnQgUmVmZXJlbmNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGN1cnJlbnRDb21wb25lbnQ6IENvbXBvbmVudFJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogSSB1c2UgdGhpcyBmbGFnIHRvIGlkZW50aWZ5IHRoYXQgY29tcG9uZW50IGlzIHJlbmRlcmluZyBmb3IgZmlyc3QgdGltZSBvciBpdHMgdXBkYXRlZCBkdXJpbmdcbiAgICAgKiBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE5vdCBzdXJlIGlmIHdlIG5lZWQgdGhpcywgYnV0IHdhbnQgdG8ga2VlcCBpdCBoZXJlIG9yIG1heWJlIG1vdmUgaXQgdG8gc29tZSBzZXJ2aWNlIHNvIHdlXG4gICAgICogY2FuIGNhY2hlIGNyZWF0ZWQgY29tcG9uZW50cyBhbmQgbWF5YmUgcmV1c2UgdGhlbS5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjb21wb25lbnRSZWZlcmVuY2VzOiBNYXA8c3RyaW5nLCBDb21wb25lbnRSZWZlcmVuY2U+ID1cbiAgICAgICAgbmV3IE1hcDxzdHJpbmcsIENvbXBvbmVudFJlZmVyZW5jZT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogTmVlZCB0byBjYWNoZSB0aGUgcmVzb2x2ZWQgY29tcG9uZW50IHJlZmVyZW5jZSBzbyB3ZSBkb250IGNhbGwgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogZXZlcnl0aGluZyB3ZSB3YW50IHRvIHJlZnJlc2ggYSBzY3JlZW5cbiAgICAgKi9cbiAgICByZXNvbHZlZENvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmZXJlbmNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgICAgICAgICAgcHVibGljIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBwdWJsaWMgY29tcFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSlcbiAgICB7XG5cbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcblxuICAgICAgICB0aGlzLmluaXRSZW5kZXJJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgLy8gdG9kbzogY2hlY2sgaWYgdGhpcyB0aGUgcmlnaHQgbGlmZWN5Y2xlIGNhbGxiYWNrLCB0aGlzIGlzIGNhbGxlZCBvbmx5IG9uY2UgYW5kIHlvdSB3YW50XG4gICAgICAgIC8vIHRvIHByb2JhYmx5IGxpc3RlbiBmb3IgY2hhbmdlcywgYW5kIGNoYW5nZSBkZWN0aW9uIGRlY2lkZSB0aGVyZSBpcyBzb21lIGNoYW5nZSBhbmQgd2VcbiAgICAgICAgLy8gbmVlZCB0byByZS1kcmF3IHRoZSB2aWV3XG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB0aGlzLmRvUmVuZGVyQ29tcG9uZW50KCk7XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWyduYW1lJ10pICYmXG4gICAgICAgICAgICAoY2hhbmdlc1snbmFtZSddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1snbmFtZSddLnByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuZG9SZW5kZXJDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgYW5kIHJlcG9zaXRpb24gRE9NIGVsZW1lbnQgYm90aCBmb3Igd3JhcHBlciBhbmRcbiAgICAgICAgLy8gY29udGVudFxuICAgICAgICB0aGlzLmNyZWF0ZVdyYXBwZXJFbGVtZW50SWZBbnkoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250ZW50RWxlbWVudElmQW55KCk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgY2FzZSB3aGVyZSB3ZSBuZWVkIHRvIHJlc29sdmUgYWRkaXRpb25hbCBjb21wb25lbnQgYW5kIHdyYXAgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqIEp1c3QgbGlrZSByZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKSB0aGlzIG1ldGhvZCBuZWVkcyB0byBiZSBleGVjdXRlZCBhZnRlciBhbGxcbiAgICAgKiBpcyBjcmVhdGVkIGFuZCBpbml0aWFsaXplZCAoaW5zaWRlIHRoZSBuZ0FmdGVyVmlld0luaXQoKSApXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlV3JhcHBlckVsZW1lbnRJZkFueSgpOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYSBjb21wb25lbnQgaW50byBhY3R1YWwgVmlldyBDb250YWluZXIuIFRoZSBwcm9jZXNzIGdvZXMgYXMgdGhpcy5cbiAgICAgKiAgMS4gV2UgcmV0cmlldmUgY29tcG9uZW50IFR5cGUgYmFzZWQgb24gdGhlIGNvbXBvbmVudCBuYW1lLCB3aGljaCBjcmVhdGVzIGNvbXBvbmVudFJlZlxuICAgICAqICAyLiBQbGFjZSB0aGUgY29tcG9uZW50IG9udG8gdGhlIHNjcmVlblxuICAgICAqICAzLiBSZWFkIGNvbXBvbmVudCBtZXRhZGF0YSwgbWFpbmx5IElOUFVUcyBhbmQgYXBwbHkgYmluZGluZ3MgZm9yIGVhY2ggb2YgdGhlbVxuICAgICAqICA0LiBNYW51YWxseSBzcGluIGNoYW5nZSBkZXRlY3Rpb24gdG8gdXBkYXRlIHRoZSBzY3JlZW4uIE1haW5seSBmb3IgY2FzZSB3aGVyZSBJIG5lZWQgdG9cbiAgICAgKiByZWRyYXcgYSBzY3JlZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZG9SZW5kZXJDb21wb25lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wbGFjZVRoZUNvbXBvbmVudCgpO1xuICAgICAgICAvLyB0aGlzLmN1cnJlbnRDb21wb25lbnQuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0YWNoKCk7XG5cbiAgICAgICAgdGhpcy5hcHBseUJpbmRpbmdzKHRoaXMuY29tcG9uZW50UmVmZXJlbmNlKCksIHRoaXMuY3VycmVudENvbXBvbmVudCwgdGhpcy5iaW5kaW5ncyk7XG4gICAgICAgIC8vIHRoaXMuY3VycmVudENvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICAgICAgLy8gU3RpbGwgbm90IHN1cmUgYWJvdXQgdGhpcyB3aGF0IGFsbCBJIHNob3VsZCByZWxlYXNlIGhlcmUuXG4gICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudC5vbkRlc3Ryb3koKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcy5iaW5kaW5ncy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdGhpcy5iaW5kaW5ncyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZXMuY2xlYXIoKTtcbiAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUGxhY2UgYWN0dWFsIGNvbXBvbmVudCBvbnRvIHRoZSBzY3JlZW4gdXNpbmcgVmlld0NvbnRhaW5lclJlZlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBsYWNlVGhlQ29tcG9uZW50KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCByZWZlcmVuY2UgPSB0aGlzLmNvbXBvbmVudFJlZmVyZW5jZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KHJlZmVyZW5jZS5yZXNvbHZlZENvbXBGYWN0b3J5KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW5zZXJ0aW5nIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGhhdmUgYSBjb250ZW50IGxpa2UgZS5nLiBoeXBlcmxpbmsgb3IgYnV0dG9uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgIDxidXR0b24+IE1ZIE5HIENPTlRFTlQgPC9idXR0b24+XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgdGhpcyBtZXRob2QgYXBwbGllcyBhbmQgaW5zZXJ0IGEgY2hpbGQgY29udGVudCBpbnRvIHRoZSBtYWluIGNvbXBvbmVudC4gVGhpcyBtZXRob2QgaW5zZXJ0XG4gICAgICogYSBzaW1wbGUgc3RyaW5nLiBXZSBhcmUgbm90IHdyYXBwaW5nIGV4aXN0aW5nIGNvbXBvbmVudCB3aXRoIGFub3RoZXIgY29tcG9uZW50IGhlcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIG5lZWQgdG8gcnVuIGRldGVjdCBjaGFuZ2VzID8gZGVmYXVsdCBpcyBmYWxzZVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVDb250ZW50RWxlbWVudElmQW55KCk6IGJvb2xlYW5cbiAgICB7XG5cbiAgICAgICAgbGV0IGRldGVjdENoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IG5nQ29udGVudCA9IHRoaXMubmdDb250ZW50KCk7XG4gICAgICAgIGxldCBuZ0NvbnRlbnRFbGVtZW50ID0gdGhpcy5uZ0NvbnRlbnRFbGVtZW50KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQobmdDb250ZW50KSkge1xuICAgICAgICAgICAgbGV0IGF3Q29udGVudENvbXBvbmVudCA9IHRoaXMuZmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFN0cmluZ0NvbXBvbmVudCk7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50ID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChhd0NvbnRlbnRDb21wb25lbnQsIDApO1xuXG4gICAgICAgICAgICAoPFN0cmluZ0NvbXBvbmVudD5jb21wb25lbnQuaW5zdGFuY2UpLnZhbHVlID0gbmdDb250ZW50O1xuICAgICAgICAgICAgbGV0IGF3Q29udGVudENvbnRhaW5lciA9IHRoaXMuY3VycmVudENvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBhd0NvbnRlbnRDb250YWluZXIuYXBwZW5kQ2hpbGQoY29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICBkZXRlY3RDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQobmdDb250ZW50RWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb250ZW50IEVsZW1lbnQ6ICcsIG5nQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRldGVjdENoYW5nZXM7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHJpZXZlIGEgTkcgQ29udGVudCBmcm9tIGJpbmRpbmcgbGlzdCBhbmQgcmVtb3ZlIGl0IHNvIGl0IGl0cyBub3QgcHJlcGFnYXRlZCBkb3duIHdoZW5cbiAgICAgKiBhcHBseWluZyBvdGhlciBiaW5kaW5ncy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBuZ0NvbnRlbnQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgY29udGVudDogYW55O1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbnRlbnQgPSB0aGlzLmJpbmRpbmdzLmdldChJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgbmdDb250ZW50RWxlbWVudCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBjb250ZW50OiBhbnk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29udGVudCA9IHRoaXMuYmluZGluZ3MuZ2V0KEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50RWxlbWVudCkpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzLmRlbGV0ZShJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLk5nQ29udGVudEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gY29udmVydCBhIGNvbXBvbmVudCBuYW1lIHRvIGFjdHVhbCBhIHR5cGUgYW5kIHRoZW4gdXNlIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlclxuICAgICAqIHRvIGluc3RhbnRpYXRlIGEgYSBjb21wb25lbnQgYW5kIHNhdmUgaXRzIGluZm9ybWF0aW9uIGludG8gb3VyIGNvbXBvbmVudCByZWZlcmVuY2VzLiBUaGVcbiAgICAgKiByZWFzb24gd2h5IHdlIGhhdmUgdGhpcyBjb21wb25lbnQgcmVmZXJlbmNlIGlzIHdlIG5lZWQgdG8gc3RvcmUgQW5ndWxhcidzIGNvbXBvbmVudCBtZXRhZGF0YVxuICAgICAqIHNvIHdlIGNhbiBpdGVyYXRlIHRocnUgYWxsIHRoZSBpbnB1dHMgYW5kIGJpbmQgdGhlbSB0byB0aGUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIHJldHVybnMge0NvbXBvbmVudFJlZmVyZW5jZX0gYSByZWZlcmVuY2UgcmVwcmVzZW50aW5nIGEgY29tcG9lbnQgY3VycmVudGx5IGJlaW5nIHJlbmRlcmVkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZmVyZW5jZSgpOiBDb21wb25lbnRSZWZlcmVuY2VcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJyVHlwZSA9IHRoaXMucmVzb2x2ZUNvbXBvbmVudFR5cGUoKTtcbiAgICAgICAgbGV0IGNvbXBvbmVudEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55PiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY3VyclR5cGUpO1xuXG4gICAgICAgIGxldCBjb21wb25lbnRNZXRhOiBDb21wb25lbnQgPSB0aGlzLnJlc29sdmVEaXJlY3RpdmUoY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgIGxldCBjb21wUmVmZXJlbmNlOiBDb21wb25lbnRSZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY29tcG9uZW50TWV0YSxcbiAgICAgICAgICAgIHJlc29sdmVkQ29tcEZhY3Rvcnk6IGNvbXBvbmVudEZhY3RvcnksXG4gICAgICAgICAgICBjb21wb25lbnRUeXBlOiBjdXJyVHlwZSxcbiAgICAgICAgICAgIGNvbXBvbmVudE5hbWU6IHRoaXMubmFtZVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzb2x2ZWRDb21wb25lbnRSZWYgPSBjb21wUmVmZXJlbmNlO1xuICAgICAgICByZXR1cm4gY29tcFJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyB0aHJ1IENvbXBvbmVudE1ldGFkYXRhIEBJbnB1dHMoKSBhbmQgY2hlY2sgaWYgd2UgaGF2ZSBhdmFpbGFibGUgYmluZGluZyBpbnNpZGUgdGhlXG4gICAgICogJ3RoaXMuYmluZGluZ3MnXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFwcGx5QmluZGluZ3MoY1JlZjogQ29tcG9uZW50UmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3M6IE1hcDxzdHJpbmcsIGFueT4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgaW5wdXRzOiBzdHJpbmdbXSA9IGNSZWYubWV0YWRhdGEuaW5wdXRzO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGlucHV0cykgfHwgaW5wdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNob3VsZCB3ZSBkbyBhbnkgdHlwZSBjb252ZXJzaW9uP1xuICAgICAgICBNYXBXcmFwcGVyLml0ZXJhYmxlKGJpbmRpbmdzKS5mb3JFYWNoKCh2LCBrKSA9PlxuICAgICAgICB7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY29tcG9uZW50Lmluc3RhbmNlW2tdKSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pbnN0YW5jZVtrXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBjb21wb25lbnQgVHlwZSBiYXNlZCBvbiB0aGUgc3RyaW5nIGxpdGVyYWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGNvbXBvbmVudCB0eXBlIHVzZWQgYnkgYENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcmBcbiAgICAgKlxuICAgICAqIHRvZG86IHJlbmFtZSB0aGUgbWV0aG9kIHNvIGl0cyBjbGVhciB0aGF0IGl0IHJldHVybnMgY29tcG9uZW50IHR5cGUgYmFzZWQgb24gc3RyaW5nLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZXNvbHZlQ29tcG9uZW50VHlwZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIGxldCBjb21wb25lbnRUeXBlID0gdGhpcy5jb21wUmVnaXN0cnkubmFtZVRvVHlwZS5nZXQodGhpcy5uYW1lKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhjb21wb25lbnRUeXBlKSkge1xuICAgICAgICAgICAgYXNzZXJ0KGZhbHNlLCB0aGlzLm5hbWUgKyAnIGNvbXBvbmVudCBkb2VzIG5vdCBleGlzdHMuIENyZWF0ZSBEdW1teSBDb21wb25lbnQgaW5zdGVhZCcgK1xuICAgICAgICAgICAgICAgICcgb2YgdGhyb3dpbmcgdGhpcyBlcnJvcicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRUeXBlO1xuICAgIH1cblxuXG4gICAgcHJvdGVjdGVkIHJlc29sdmVEaXJlY3RpdmUoY29tcEZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8YW55Pik6IENvbXBvbmVudFxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBNZXRhOiBDb21wb25lbnQgPSB7XG4gICAgICAgICAgICBpbnB1dHM6IFtdLFxuICAgICAgICAgICAgb3V0cHV0czogW11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBGYWN0b3J5LmlucHV0cykgJiYgY29tcEZhY3RvcnkuaW5wdXRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29tcEZhY3RvcnkuaW5wdXRzLmZvckVhY2goKGlucHV0OiB7cHJvcE5hbWU6IHN0cmluZywgdGVtcGxhdGVOYW1lOiBzdHJpbmd9KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbXBNZXRhLmlucHV0cy5wdXNoKGlucHV0LnByb3BOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjb21wRmFjdG9yeS5vdXRwdXRzKSAmJiBjb21wRmFjdG9yeS5vdXRwdXRzLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgY29tcEZhY3Rvcnkub3V0cHV0cy5mb3JFYWNoKChvdXRwdXQ6IHtwcm9wTmFtZTogc3RyaW5nLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZ30pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcE1ldGEub3V0cHV0cy5wdXNoKG91dHB1dC5wcm9wTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcE1ldGE7XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VycmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmlld0NvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmN1cnJlbnRDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N0cmluZ1dyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIEVycm9yIE1hbmFnZXIgaXMgYSBzZXJ2aWNlIHVzZWQgYnkgRm9ybXMgY29tcG9uZW50cyB0byBtYXAgZXJyb3IgY29kZXMgaW50byBtZWFuaW5nZnVsIG1lc3NhZ2VzLlxuICogQ3VycmVudGx5IGl0IGRvZXMgbm90IGhhdmUgbXVjaCBidXQgb25jZSB3ZSBwbHVnIGluIGxvY2FsaXphdGlvbiBpdCB3aWxsIG1ha2UgbW9yZSBzZW5zZVxuICpcbiAqXG4gKiB0b2RvOiBPbmNlIG5nLXRyYW5zbGF0ZSBpcyBpbXBsZW1lbnRlZCByZXBsYWNlIHRoaXMgd2l0aCBuZy10cmFuc2xhdGUgZnVuY3Rpb25hbGl0eSBzbyB3ZSBjYW5cbiAqIGV4dGVybmFsaXplIHRoZXNlIG1lc3NhZ2VzIGludG8gbG9jYWxlIGZpbGVzLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEVycm9yTWFuYWdlclNlcnZpY2VcbntcbiAgICBtZXNzYWdlczoge1trZXk6IHN0cmluZ106IGFueX07XG5cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLm1lc3NhZ2VzID0ge1xuICAgICAgICAgICAgJ3JlcXVpcmVkJzogJ1JlcXVpcmVkIGZpZWxkJyxcbiAgICAgICAgICAgICdtaW5sZW5ndGgnOiAnRmllbGQgZG9lcyBub3QgbWVldCBtaW5pbXVtIGxlbmd0aCcsXG4gICAgICAgICAgICAnbWF4bGVuZ3RoJzogJ0ZpZWxkIGRvZXMgbm90IG1lZXQgbWF4aW11bSBsZW5ndGgnLFxuICAgICAgICAgICAgJ2N1c3RvbU1zZyc6ICclcycsXG4gICAgICAgICAgICAnbWV0YXZhbGlkJzogJyVzJ1xuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgZXJyb3JNZXNzYWdlKHZhbGlkYXRvck5hbWU6IHN0cmluZywgdmFsaWRhdG9yVmFsdWU/OiBhbnkpXG4gICAge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXNbdmFsaWRhdG9yTmFtZV07XG4gICAgICAgIGlmIChTdHJpbmdXcmFwcGVyLmNvbnRhaW5zKG1lc3NhZ2UsICclcycpKSB7XG4gICAgICAgICAgICAvLyB0b2RvOiB1c2UgbmctdHJhbnNsYXRlIHdpdGggcHJvcGVyIG1lc3NhZ2UgZm9ybWF0dGluZ1xuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nV3JhcHBlci5yZXBsYWNlKG1lc3NhZ2UsICclcycsIHZhbGlkYXRvclZhbHVlLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2x9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RXJyb3JNYW5hZ2VyU2VydmljZX0gZnJvbSAnLi4vLi4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuXG4vKipcbiAqIEVycm9yTWVzc2FnZXNDb21wb25lbnQgaXMgdXNlZCBieSBmb3JtJ3MgY29tcG9uZW50IGxpa2UgRm9ybVJvdyB0byBwcmludCBpdHMgdmFsaWRhdGlvbiBlcnJvcnMuXG4gKiBJdHMgIGJhc2VkIG9uIE1vZGVsRHJpdmVuIChSZWFjdGl2ZSBmb3JtcykgYW5kIGl0IHJlYWRzIGVycm9ycyBmcm9tIEZvcm1Db250cm9sXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYS1lcnJvci1tZXNzYWdlcycsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgICAgICAgICAgICAgIDxzbWFsbCAqbmdJZj1cImhhc01lc3NhZ2UoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInVpLWctMTIgdWktbWVzc2FnZSB1aS1tZXNzYWdlcy1lcnJvciB1aS1jb3JuZXItYWxsXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBlcnJvck1zZyB9fVxuICAgICAgICAgICAgICAgICAgICA8L3NtYWxsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgICBzdHlsZXM6IFtgYF1cbn0pXG5leHBvcnQgY2xhc3MgRXJyb3JNZXNzYWdlc0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBmb3JtIEZvcm1Db250cm9sbCB0byBjaGVjayBmb3IgRXJyb3JzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250cm9sOiBGb3JtQ29udHJvbDtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlcnJNYW5hZ2VyOiBFcnJvck1hbmFnZXJTZXJ2aWNlKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgfVxuXG5cbiAgICBoYXNNZXNzYWdlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBtc2cgPSB0aGlzLmVycm9yTXNnO1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KG1zZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYSBtZXNzYWdlcyBpZiBhbnkgcmVnaXN0ZXJlZCBieSBhZGRlZCB2YWxpZGF0b3JzXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgZXJyb3JNc2coKTogc3RyaW5nXG4gICAge1xuICAgICAgICBmb3IgKGxldCBwcm9wZXJ0eU5hbWUgaW4gdGhpcy5jb250cm9sLmVycm9ycykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbC5lcnJvcnMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSAmJiB0aGlzLmNvbnRyb2wudG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVyck1hbmFnZXIuZXJyb3JNZXNzYWdlKHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250cm9sLmVycm9yc1twcm9wZXJ0eU5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2hvdyBlcnJvcnM/IFdlIGN1cnJlbnRseSBzaG93cyBlcnJvcnMgaWYgdGhlIGNvbnRyb2wgaXMgbm90IHZhbGlkLCBpdCB3YXMgdG91Y2hlZCBieSB1c2VyLlxuICAgICAqIE1vc3Qgb2YgdGhlIHR5cGUgb24gYmx1ciBldmVudCAgYW5kIGF0IGxhc3QgaXRzIG5vdCBwcmlzdGluZSBhbnltb3JlIChpdHMgZGlydHkpXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93RXJyb3JzKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb250cm9sLnZhbGlkICYmICF0aGlzLmNvbnRyb2wucHJpc3RpbmUgJiYgdGhpcy5jb250cm9sLnRvdWNoZWQ7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50RmFjdG9yeSxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIEluamVjdGFibGUsXG4gICAgVHlwZSxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIE1vZGFsIHNlcnZpY2UgaXMgdXNlZCB0byB0byBjcmVhdGUgbW9kYWwgZGlhbG9ncy4gSXQgY3JlYXRlcyBtb2RhbCBkaWFsb2dzIGR5bmFtaWNhbGx5LlxuICogVGhlIHNlcnZpY2UgYWxzbyBrZWVwcyB0cmFjayBvZiB0aGUgY3JlYXRlZCBtb2RhbCBkaWFsb2cgYW5kIGNhbiBjbG9zZSBpdCBieSBjYWxsaW5nIHRoZVxuICogc2VydmljZSdzIGNsb3NlKClcbiAqXG4gKiBNb2RhbCBzZXJ2aWNlIHJlcXVpcmVzIGEgVmlld0NvbnRhaW5lciB0byBpbnNlcnQgbmV3bHkgY3JlYXRlZCBtb2RhbHMuIFRoaXMgaXMgdGFrZW4gY2FyZVxuICogYnkgdGhlIE1vZGFsQ29tcG9uZW50LlxuICpcbiAqIFVzYWdlOlxuICogICAgIEFkZCAgIDxhdy1tb2RhbD48L2F3LW1vZGFsPiAgaW50byB5b3VyIGFwcGxpY2F0aW9uIG1haW4gaHRtbC4gSXQgbmVlZHMgdG8gYmUgb24gZXZlcnlcbiAqICAgICBwYWdlIHdoZXJlIGEgbW9kYWwgZGlhbG9nIHdpbGwgYXBwZWFyLlxuICpcbiAqICAgIDEuICBQb3B1cCBhIGRpYWxvZyB3aXRob3V0IGNyZWF0aW5nIHlvdXIgb3duIGNvbXBvbmVudC5cbiAqICAgICAgICBVc2UgdGhlIGV4aXN0aW5nIERpYWxvZ0NvbXBvbmVudCBpbiB3aWRnZXRzLlxuICpcbiAqICAgICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48RGlhbG9nQ29tcG9uZW50PihEaWFsb2dDb21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdNeSBQb3B1cCBUaXRsZScsXG4gKiAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICdNeSBQb3B1cCBCb2R5J1xuICogICAgICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgQ3JlYXRpbmcgeW91ciBvd24gRGlhbG9nIENvbXBvbmVudCB0byBwb3B1cC5cbiAqXG4gKiAgICAgICAgIGxldCBjb21wb25lbnRSZWYgPSB0aGlzLm1vZGFsU2VydmljZS5vcGVuPE15RGlhbG9nQ29tcG9uZW50PihNeURpYWxvZ0NvbXBvbmVudCxcbiAqIHtpbnB1dHN9KTtcbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctbXlkaWFsb2cnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nIChvbkNsb3NlKT1cImNsb3NlUG9wdXAoKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICN0aXRsZVRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+PGkgY2xhc3M9XCJmYSBmYS1lbnZpcmFcIiA+PC9pPlRoaXMgaXMgbXlcbiAqICAgICBUaXRsZSA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNib2R5VGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj48aSBjbGFzcz1cImZhIGZhLWVudmlyYVwiID48L2k+VGhpcyBpcyBteVxuICogICAgIEJvZHkgPC9zcGFuPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGlhbG9nPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICB9KVxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlEaWFsb2dDb21wb25lbnQgZXh0ZW5kcyBEaWFsb2dDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICogICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgIG5nT25Jbml0KCkgeyB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjbG9zZVBvcHVwKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2UuY2xvc2UoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgfVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTW9kYWxTZXJ2aWNlXG57XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIHN0YXRpYyBsaXN0IG9mIG91dHB1dCBwYXJhbWV0ZXIgZnJvbSBEaWFsb2csIENvbmZpcm1hdGlvbiBjb21wb25lbnRzXG4gICAgICogdGhhdCBuZWVkcyB0byBiZSBoYW5kbGVkLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgT1VUUFVUX1BBUkFNRVRFUlM6IHN0cmluZ1tdID0gWydvbkNsb3NlJywgJ29uQ29uZmlybScsICdvbkNhbmNlbCddO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb250YWluZXIgZm9yIHRoZSBuZXdseSBjcmVhdGVkIG1vZGFsLiBUaGlzIGlzIHBhc3NlZCBpbiB0aHJvdWdoIHRoZVxuICAgICAqIHJlZ2lzdGVyVmlld0NvbnRhaW5lclJlZigpLlxuICAgICAqL1xuICAgIHByaXZhdGUgdmNSZWY6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgICAvKipcbiAgICAgKiBTdG9yaW5nIHRoZSBjcmVhdGVkIG1vZGFsIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5zdGFuY2U6IGFueTtcblxuICAgIC8qKlxuICAgICAqIERJIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciB0byBiZSB1c2VkIHRvIGNyZWF0ZSBtb2RhbCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2ZyXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcilcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIFBsYWNlSG9sZGVyIGZvciBtb2RhbCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2Y1JlZlxuICAgICAqL1xuICAgIHJlZ2lzdGVyVmlld0NvbnRhaW5lclJlZih2Y1JlZjogVmlld0NvbnRhaW5lclJlZik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMudmNSZWYgPSB2Y1JlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgbW9kYWwgZGlhbG9nIGJ5IGR5bmFtaWNhbGx5IGNyZWF0aW5nIHRoZSBjb21wb25lbnQgYW5kIGFkZGluZyBpdCB0byB2Y1JlZi5cbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW48VD4oY29tcG9uZW50OiBUeXBlPFQ+LCBwYXJhbWV0ZXJzPzogYW55KTogQ29tcG9uZW50UmVmPFQ+XG4gICAge1xuICAgICAgICBjb25zdCBjZjogQ29tcG9uZW50RmFjdG9yeTxUPiA9IHRoaXMuY2ZyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KGNvbXBvbmVudCk7XG4gICAgICAgIGxldCBjb21wb25lbnRSZWY6IENvbXBvbmVudFJlZjxUPiA9IHRoaXMudmNSZWYuY3JlYXRlQ29tcG9uZW50KGNmKTtcblxuICAgICAgICAvLyBBdXRvIHNldCB2aXNpYmxpdHkgdG8gdHJ1ZS4gU28gdGhhdCB0aGUgRGlhbG9nIHdpbGwgZGlzcGxheVxuICAgICAgICBwYXJhbWV0ZXJzID0gKHBhcmFtZXRlcnMpID8gcGFyYW1ldGVycyA6IHt9O1xuICAgICAgICBwYXJhbWV0ZXJzWyd2aXNpYmxlJ10gPSB0cnVlO1xuXG4gICAgICAgIC8vIEhhbmRsZSBvdXRwdXQgcGFyYW1ldGVycy5cbiAgICAgICAgTW9kYWxTZXJ2aWNlLk9VVFBVVF9QQVJBTUVURVJTLmZvckVhY2goKHBhcmFtKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyc1twYXJhbV0pIHtcbiAgICAgICAgICAgICAgICAoPGFueT5jb21wb25lbnRSZWYuaW5zdGFuY2UpW3BhcmFtXS5zdWJzY3JpYmUocGFyYW1ldGVyc1twYXJhbV0pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbWV0ZXJzW3BhcmFtXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihjb21wb25lbnRSZWYuaW5zdGFuY2UsIHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIC8vIGhhZCB0byBjYXN0IGl0IGluIG9yZGVyIHRvIGF2b2lkIGFueSBpbmRleCBFcnJvclxuICAgICAgICAvLyBBdHRhY2ggYSBkZXN0cm95IG1ldGhvZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBjb21wb25lbnQuXG4gICAgICAgICg8YW55PmNvbXBvbmVudFJlZi5pbnN0YW5jZSlbJ2Rlc3Ryb3knXSA9ICgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNhdmUgdGhlIGluc3RhbmNlLCBzbyBpdCBjYW4gYmUgZGVzdHJveWVkIGxhdGVyLlxuICAgICAgICB0aGlzLmluc3RhbmNlID0gY29tcG9uZW50UmVmO1xuXG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGluZyBjbG9zZSgpIHdpbGwgcmVtb3ZlIHRoZSBtb2RhbCBmcm9tIHZpZXcuXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBPbkluaXQsIFZpZXdDaGlsZCwgVmlld0NvbnRhaW5lclJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge01vZGFsU2VydmljZX0gZnJvbSAnLi4vbW9kYWwuc2VydmljZSc7XG5cblxuLyoqXG4gKiBQbGFjZSBob2xkZXIgZm9yIGFsbCBtb2RhbCBkaWFsb2dzLiBUaGlzIGNvbXBvbmVudCB3b3JrcyB3aXRoIHRoZSBtb2RhbFNlcnZpY2UgYnkgcHJvdmlkaW5nXG4gKiBhIHBsYWNlIGhvbGRlciBmb3IgaXQgdG8gaW5qZWN0IERpYWxvZyBjb21wb25lbnQgaW50by5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1tb2RhbCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICNtb2RhbD48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYGBdXG59KVxuZXhwb3J0IGNsYXNzIE1vZGFsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICBAVmlld0NoaWxkKCdtb2RhbCcsIHtyZWFkOiBWaWV3Q29udGFpbmVyUmVmfSlcbiAgICB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSlcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2UucmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKHRoaXMudmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q3VycmVuY3lQaXBlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQaXBlLCBQaXBlVHJhbnNmb3JtfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGN1cnJlbmN5IGZvcm1hdHRlciB3aWxsIGlnbm9yZSBudWxsIGFuZCBlbXB0eSBzdHJpbmcgZm9yIHZhbHVlLlxuICogSXNzdWUgOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy84Njk0ICBESSBmYWlscyB3aGVuIGV4dGVuZHMgb3RoZXIgY2xhc3Nlc1xuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ2N1cnJlbmN5Rm9ybWF0JyxcbiAgICBwdXJlOiBmYWxzZVxufSlcbmV4cG9ydCBjbGFzcyBDdXJyZW5jeUZvcm1hdFBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtXG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGN1cnJlbmN5UGlwZTogQ3VycmVuY3lQaXBlKVxuICAgIHtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgLi4uYXJnczogYW55W10pOiBhbnlcbiAgICB7XG5cbiAgICAgICAgLy8gRGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgbGV0IGN1cnJlbmN5Q29kZSA9ICdVU0QnLCBzeW1ib2xEaXNwbGF5ID0gdHJ1ZSwgZGlnaXRzID0gJzEuMC0yJztcblxuICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyZ3MgJiYgYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY29kZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoY29kZSAmJiBjb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW5jeUNvZGUgPSBjb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVuY3lQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgY3VycmVuY3lDb2RlLCBzeW1ib2xEaXNwbGF5LCBkaWdpdHMpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSB1dGlsaXR5IGRpcmVjdGl2ZSB0aGF0IGlzIHVzZWQgYnkgTkcgRm9yIGN5Y2xlIGluIHNpdHVhdGlvbiB3aGVyZSB3ZSBuZWVkIHRvIGNhbGwgYVxuICogb3IgZXhlY3V0ZSBzb21lIGxvZ2ljIGFmdGVyIGVhY2ggaXRlcmF0aW9uXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW25nRm9yU2V0XSdcbn0pXG5leHBvcnQgY2xhc3MgTmdGb3JTZXREaXJlY3RpdmVcbntcblxuICAgIEBPdXRwdXQoKVxuICAgIG9uSXRlbTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5vbkl0ZW0uZW1pdCgnLS0nKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNpbXBsZSBjb252ZW5pZW50IHNlcnZpY2UgdG8gd29yayB3aXRoIHRoZSBkb20uIEFsbCB0aGUgZnV0dXJlIGxvZ2ljIHJlbGF0ZWQgdG8gRE9NIG1hbmlwdWxhdGlvblxuICogb3IgdHJhdmVyc2FsIHNob3VsZCBiZSBwdXQgaW50byB0aGlzIHNlcnZpY2VcbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEb21VdGlsc1NlcnZpY2VcbntcblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdvZXMgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIGJvZHkgYW5kIGNoZWNrcyBpZiB0aGVyZSBpcyBhIGVsZW1lbnQgaWRlbnRpZmllZCBieSBhICdzZWxlY3RvcidcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1BhcmVudCAobmF0aXZlRWxlbWVudDogYW55LCBzZWxlY3Rvcjogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNsb3Nlc3QobmF0aXZlRWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBUcmF2ZWxzIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBCT0RZIGFuZCByZXRyaWV2ZSBlbGVtZW50IGlkZW50aWZpZWQgYnkgJ3NlbGVjdG9yJyBvciBOVUxMIGlmXG4gICAgICogbm90IGZvdW5kXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZXN0IChuYXRpdmVFbGVtZW50OiBhbnksIHNlbGVjdG9yOiBzdHJpbmcpOiBhbnlcbiAgICB7XG4gICAgICAgIGxldCBmaXJzdENoYXIgPSBzZWxlY3Rvci5jaGFyQXQoMCk7XG5cbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSBuYXRpdmVFbGVtZW50O1xuXG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudCgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZSkpKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnLicgJiYgcGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoc2VsZWN0b3Iuc3Vic3RyKDEpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmlyc3RDaGFyID09PSAnIycgJiYgcGFyZW50Tm9kZS5pZCA9PT0gc2VsZWN0b3Iuc3Vic3RyKDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHNlbGVjdG9yIGlzIGEgdGFnXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBwYXJlbnROb2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUubm9kZVR5cGUgPT09IDEgJiYgcGFyZW50Tm9kZS50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGFuZ3VsYXIgY29tcG9uZW50IGlzIHJlbmRlcmVkIGFsb25nIHdpdGggTkdDb250ZW50IGl0IGhhcyBpdHMgb3duIF9uZ0NvbnRlbnRfSU5ERVhcbiAgICAgKiB3aGljaCBhbHdheXMgY29ycmVzcG9uZHMgd2l0aCBfbmdob3N0X0lOREVYLCB0aGlzIHdvcmtzIGZpbmUgaWYgd2UgaGF2ZSBhY3R1YWwgY29tcG9uZW50XG4gICAgICogdGhhdCBpcyBhbHJlYWR5IHJlbmRlcmVkLiBJZiB3ZSBhcmUgY3JlYXRpbmcgY29tcG9uZW50IHByb2dyYW1hdGljYWxseSB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICAgKiBpZGVudGlmeSB3aGVyZSB0aGUgYWN0dWFsIG5nLWNvbnRlbnQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBlLmcuIENvbnNpZGVyIGZvbGxvd2luZyBleGFtcGxlOlxuICAgICAqXG4gICAgICpcbiAgICAgKiBCdXR0b24gQ29tcG9uZW50IFRlbXBsYXRlOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogIDxzcGFuIGNsYXNzPW15YnV0dG9uVGl0bGU+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pjwvc3Bhbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZW4geW91IHVzZSBidXR0b24gY29tcG9uZW50IGFzIDxhdy1idXR0b24+Q2xpY2tNZTwvYXctYnV0dG9uPiAgdGhlbiBpdHMgcmVuZGVyZWQgYXNcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIDxhdy1idXR0b24gX25naG9zdF8xMjM+XG4gICAgICogIDxzcGFuIF9uZ2NvbnRlbnRfMTIzIGNsYXNzPW15YnV0dG9uVGl0bGU+Q2xpY2tNZTwvc3Bhbj5cbiAgICAgKiA8L2F3LWJ1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJ1dCB3aXRoIHByb2dyYW1tYXRpYyBBUEkgeW91IGluc3RhbnRpYXRlIEJ1dHRvbiBhbmQgc2luY2UgaXQgY3JlYXRlZCB3aXRob3V0IGEgQ29udGVudCBpdFxuICAgICAqIGxvb2tzIGxpa2UgdGhpcztcbiAgICAgKlxuICAgICAqICBgYGBcbiAgICAgKiA8YXctYnV0dG9uIF9uZ2hvc3RfMTIzPlxuICAgICAqICA8c3BhbiBjbGFzcz1teWJ1dHRvblRpdGxlPjwvc3Bhbj5cbiAgICAgKiA8L2F3LWJ1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFdoZXJlIGRvIHlvdSBwbGFjZSB5b3UgY2hpbGQgKGNvbnRlbnQgY29tcG9uZW50KT8gVGhlcmVmb3JlIHV0aWxpdHkgY3NzIGNsYXNzIHdhcyBjcmVhdGVkXG4gICAgICogdG8gd3JhcCA8bmctY29udGVudD4gdG8gZ2V0IGFyb3VuZCB0aGlzIGxpbWl0YXRpb24uXG4gICAgICpcbiAgICAgKiAgYGBgXG4gICAgICogICA8c3BhbiBjbGFzcz1cInUtbmdjb250ZW50XCI+XG4gICAgICogICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICogICA8L3NwYW4+XG4gICAgICogIGBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydEludG9QYXJlbnROZ0NvbnRlbnQgKHBhcmVudE5hdGl2ZUVsOiBhbnksIGNoaWxkTmF0aXZlRWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gaW5zZXJ0IGl0IGFzIGNoaWxkIHRvIHBhcmVudE5hdGl2ZUVsXG4gICAgICAgIGxldCBuZ0NvbnRlbnRQYXJlbnQgPSBwYXJlbnROYXRpdmVFbDtcblxuICAgICAgICBsZXQgZm91bmROZ0NvbnRlbnQgPSBwYXJlbnROYXRpdmVFbC5xdWVyeVNlbGVjdG9yKCcudS1uZ2NvbnRlbnQnKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChmb3VuZE5nQ29udGVudCkpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGNvdmVyIGEgY2FzZSB3aGVyZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBuZ2NvbnRlbnRzXG4gICAgICAgICAgICBuZ0NvbnRlbnRQYXJlbnQgPSBmb3VuZE5nQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICBuZ0NvbnRlbnRQYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGROYXRpdmVFbCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgYnJvd3NlciB3aW5kb3cgd2lkdGggYW5kIGhlaWdodFxuICAgICAqXG4gICAgICovXG4gICAgYnJvd3NlckRpbWVudGlvbnMgKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiAod2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoXG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRXaWR0aCksXG4gICAgICAgICAgICBoZWlnaHQ6ICh3aW5kb3cuaW5uZXJIZWlnaHQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICAgICAgICAgICAgIHx8IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZXMgZWxlbWVtZW50cyBkaW1lbnNpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBlbGVtZW50RGltZW5zaW9ucyAoZWxlbWVudDogYW55KTogYW55XG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDAsIHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9O1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogVW5kZXIgQG9yaWdpbmFsLWxpY2Vuc2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAxNS1wcmVzZW50IERyaWZ0eSBDby5cbiAqIGh0dHA6Ly9kcmlmdHkuY29tL1xuICpcbiAqICBNSVQgTGljZW5zZVxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICogYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbiAqIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICogcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG4gKiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAqIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqXG4gKlxuICogQ3JlZGl0IHRvIGRyaWZ0eSBmb3IgdGhpcyBleGNlbGxlbnQgY29tcG9uZW50LiBXZSBoYXZlIGEgc3Ryb25nIG5lZWRzIGZvciBnb29kIGluZmluaXRlXG4gKiBzY3JvbGxpbmcgY29tcG9uZW50IHNvIHRoaXMgaXMgZGVyaXZlZCB3b3JrIGJhc2VkIG9uIHRoaXMgZHJpZnR5IGNvbXBvbmVudCBhcyB3ZSBjYW4gbm90IHJlYWxseVxuICogYnJpbmcgaW4gd2hvbGUgZnJhbWV3b3JrIGFuZCB0aGVpciBjb21wb25lbnQvQVBJLiBJdCB3b3VsZCBiZSB0b28gaGVhdnlcbiAqXG4gKiBDb21wb25lbnQgaXMgdXBkYXRlZCB3aXRoIG5hdGl2ZSBET00gQVBJLiBwbHVzIHNpbXBsaWZpZWQgYnkgcmVtb3ZpbmcgdGhpbmdzXG4gKiB0aGF0IGFyZSBub3QgbmVjZXNzYXJ5IGZvciBvdXIgdXNlY2FzZS4gVXBkYXRlZCBkaXJlY3RpdmUgcHJlZml4IHRvIG1hdGNoIG91ciBndWlkZWxpbmVzXG4gKlxuICpcbiAqXG4gKi9cblxuXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSwgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuXG4vKipcbiAqIFRoZSBJbmZpbml0ZSBTY3JvbGwgYWxsb3dzIHlvdSB0byBwZXJmb3JtIGFuIGFjdGlvbiB3aGVuIHRoZSB1c2VyXG4gKiBzY3JvbGxzIGEgc3BlY2lmaWVkIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbSBvciB0b3Agb2YgdGhlIHBhZ2UuXG4gKlxuICogVGhlIGV4cHJlc3Npb24gYXNzaWduZWQgdG8gdGhlIGBpbmZpbml0ZWAgZXZlbnQgaXMgY2FsbGVkIHdoZW5cbiAqIHRoZSB1c2VyIHNjcm9sbHMgdG8gdGhlIHNwZWNpZmllZCBkaXN0YW5jZS4gV2hlbiB0aGlzIGV4cHJlc3Npb25cbiAqIGhhcyBmaW5pc2hlZCBpdHMgdGFza3MsIGl0IHNob3VsZCBjYWxsIHRoZSBgY29tcGxldGUoKWAgbWV0aG9kXG4gKiBvbiB0aGUgaW5maW5pdGUgc2Nyb2xsIGluc3RhbmNlLlxuICpcbiAqICMjIFVzYWdlXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8ZGl2ICAqbmdGb3I9XCJsZXQgaXRlbSBvZiBpdGVtc1wiPnt7aXRlbX19IDwvZGl2PlxuICogICA8YXctaW5maW5pdGUtc2Nyb2xsIChvbkxvYWQpPVwiZG9JbmZpbml0ZSgkZXZlbnQpXCI+XG4gKiAgPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFlvdSBjYW4gYWxzbyBzZXQgYSB0aHJlc2hvbGQgdG8gY2hhbmdlIHRoZSBkaXN0YW5jZSB3aGVuIHRoZSBsYXp5IGxvYWQga2lja3NcbiAqIGluLlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxkaXYgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX0gPC9kaXY+XG4gKiAgIDxhdy1pbmZpbml0ZS1zY3JvbGwgKG9uTG9hZCk9XCJkb0luZmluaXRlKCRldmVudClcIiAgW2Rpc3RhbmNlXT1cIicxNSUnXCI+XG4gKiAgPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG4gKlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5maW5pdGUtc2Nyb2xsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LWluZmluaXRlLWxvYWRlci1wYW5lbFwiICpuZ0lmPVwiaXNMb2FkaW5nKClcIj5cbiAgICA8c3BhbiBjbGFzcz1cInNhcC1pY29uIGljb24tc3luY2hyb25pemUgdS1zcGluLWljb25cIj48L3NwYW4+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWluZmluaXRlLWxvYWRlci1wYW5lbHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7YmFja2dyb3VuZC1jb2xvcjojZmZmO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMHB4O3otaW5kZXg6MzAwO2JvdHRvbToxMDBweH0udy1pbmZpbml0ZS1sb2FkZXItcGFuZWwgc3Bhbntjb2xvcjojNGE0YTRhO2ZvbnQtc2l6ZToyZW19YF0sXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0XG57XG4gICAgX2xhc3RDaGVjazogbnVtYmVyID0gMDtcbiAgICBfbGFzdFNjcm9sbFRvcDogbnVtYmVyID0gMDtcbiAgICBfc2NMc246IGFueTtcbiAgICBfdGhyOiBzdHJpbmcgPSAnMTAlJztcbiAgICBfdGhyUHg6IG51bWJlciA9IDA7XG4gICAgX3RoclBjOiBudW1iZXIgPSAwLjEwO1xuICAgIF9pbml0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBfY29udGVudDogYW55O1xuICAgIF9kb2NCb2R5OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0ZTogc3RyaW5nID0gU1RBVEVfRU5BQkxFRDtcblxuICAgIC8qKlxuICAgICAqIEBpbnB1dCB7c3RyaW5nfSBUaGUgdGhyZXNob2xkIGRpc3RhbmNlIGZyb20gdGhlIGJvdHRvbVxuICAgICAqIG9mIHRoZSBjb250ZW50IHRvIGNhbGwgdGhlIGBvbkxvYWRgIG91dHB1dCBldmVudCB3aGVuIHNjcm9sbGVkLlxuICAgICAqIFRoZSB0aHJlc2hvbGQgdmFsdWUgY2FuIGJlIGVpdGhlciBhIHBlcmNlbnQsIG9yXG4gICAgICogaW4gcGl4ZWxzLiBGb3IgZXhhbXBsZSwgdXNlIHRoZSB2YWx1ZSBvZiBgMTAlYCBmb3IgdGhlIGBpbmZpbml0ZWBcbiAgICAgKiBvdXRwdXQgZXZlbnQgdG8gZ2V0IGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhhcyBzY3JvbGxlZCAxMCVcbiAgICAgKiBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuIFVzZSB0aGUgdmFsdWUgYDEwMHB4YCB3aGVuIHRoZVxuICAgICAqIHNjcm9sbCBpcyB3aXRoaW4gMTAwIHBpeGVscyBmcm9tIHRoZSBib3R0b20gb2YgdGhlIHBhZ2UuXG4gICAgICogRGVmYXVsdCBpcyBgMTUlYC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXN0YW5jZSAoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGhyO1xuICAgIH1cblxuICAgIHNldCBkaXN0YW5jZSAodmFsOiBzdHJpbmcpXG4gICAge1xuICAgICAgICB0aGlzLl90aHIgPSB2YWw7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZignJScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX3RoclB4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX3RoclBjID0gKHBhcnNlRmxvYXQodmFsKSAvIDEwMCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3RoclB4ID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgICAgICAgICAgdGhpcy5fdGhyUGMgPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGlucHV0IHtib29sZWFufSBJZiB0cnVlLCBXaGV0aGVyIG9yIG5vdCB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGVuYWJsZWQgKHNob3VsZEVuYWJsZTogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIHRoaXMuZW5hYmxlKHNob3VsZEVuYWJsZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBAb3V0cHV0IHtldmVudH0gRW1pdHRlZCB3aGVuIHRoZSBzY3JvbGwgcmVhY2hlc1xuICAgICAqIHRoZSB0aHJlc2hvbGQgZGlzdGFuY2UuIEZyb20gd2l0aGluIHlvdXIgaW5maW5pdGUgaGFuZGxlcixcbiAgICAgKiB5b3UgbXVzdCBjYWxsIHRoZSBpbmZpbml0ZSBzY3JvbGwncyBgY29tcGxldGUoKWAgbWV0aG9kIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uTG9hZDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgQFZpZXdDaGlsZCgnbG9hZGluUGFuZWwnKVxuICAgIGxvYWRQYW5lbDogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBMYXp5IGxvYWQgY3VycmVudCBudW1iZXJzLiB0ZWxsIHRoZSBhcHAgc3RhcnRpbmcgcG9pbnQgYW5kIHdoYXQgaXMgdGhlIHNpemUgb2YgbG9hZGVkXG4gICAgICogbGlzdFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmZXRjaFNpemU6IG51bWJlciA9IDA7XG5cbiAgICBsb2FkT2Zmc2V0OiBudW1iZXIgPSAwO1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBfcmVuZGVyOiBSZW5kZXJlcjIsIHByaXZhdGUgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIF9jZDogQ2hhbmdlRGV0ZWN0b3JSZWYpXG4gICAge1xuXG5cbiAgICB9XG5cblxuICAgIG5nT25Jbml0ICgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9yZW5kZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ2hhcy1pbmZpbml0ZS1zY3JvbGwnKTtcblxuICAgIH1cblxuICAgIF9vblNjcm9sbCAoZXY6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFURV9MT0FESU5HIHx8IHRoaXMuc3RhdGUgPT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtdXN0IHRocm90dGxlIHRoZSBjbGFzcyBieSAxMDBtc1xuICAgICAgICBpZiAodGhpcy5fbGFzdENoZWNrICsgMTAwID4gZXYudGltZVN0YW1wKSB7XG4gICAgICAgICAgICAvLyBubyBuZWVkIHRvIGNoZWNrIGxlc3MgdGhhbiBldmVyeSBYWG1zXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0Q2hlY2sgPSBldi50aW1lU3RhbXA7XG4gICAgICAgIGxldCBzY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcCgpO1xuXG4gICAgICAgIGxldCB3aW5IZWlnaHQgPSB0aGlzLmRvbVV0aWxzLmJyb3dzZXJEaW1lbnRpb25zKCkuaGVpZ2h0O1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1heCh0aGlzLl9kb2NCb2R5LnNjcm9sbEhlaWdodCwgdGhpcy5fZG9jQm9keS5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICB3aW5IZWlnaHQsIHRoaXMuX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0LCB0aGlzLl9jb250ZW50Lm9mZnNldEhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFoZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGhlaWdodCBvZiB0aGlzIGVsZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyUGMgPyAoaGVpZ2h0ICogdGhpcy5fdGhyUGMpIDogdGhpcy5fdGhyUHg7XG4gICAgICAgIGxldCBkaXN0YW5jZUZyb21JbmZpbml0ZSA9IHRoaXMuX2NvbnRlbnQuc2Nyb2xsSGVpZ2h0IC0gd2luSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gdGhyZXNob2xkO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdEb2N1bWVudCBoZWlnaHQgKCcgKyBoZWlnaHQgKyAnKSAsIERpc3RhbmNlIGZyb20gYm90dG9tICdcbiAgICAgICAgLy8gKyBkaXN0YW5jZUZyb21JbmZpbml0ZSArICcsICA9PiB0aHJlc2hvbGQgPSAnICtcbiAgICAgICAgLy8gICAgIHRoaXMuZGlzdGFuY2UgKyAnICgnICsgdGhyZXNob2xkICsgJyknKTtcblxuICAgICAgICBpZiAoZGlzdGFuY2VGcm9tSW5maW5pdGUgPCAwICYmIHRoaXMuX2xhc3RTY3JvbGxUb3AgPCBzY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZU9uTGF6eUxvYWQoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RTY3JvbGxUb3AgPiBzY3JvbGxUb3AgJiYgc2Nyb2xsVG9wIDwgd2luSGVpZ2h0XG4gICAgICAgICAgICAmJiB0aGlzLmxvYWRPZmZzZXQgIT09IHRoaXMuZmV0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVPbkxhenlVbkxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0U2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9kbzogcmVmYWN0b3IgdG8gb25lIG1ldGhvZFxuICAgICAqL1xuICAgIHByaXZhdGUgZmlyZU9uTGF6eUxvYWQgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9MT0FESU5HICYmIHRoaXMuc3RhdGUgIT09IFNUQVRFX0RJU0FCTEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX0xPQURJTkc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBsaW1pdDogdGhpcy5mZXRjaFNpemUsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5sb2FkT2Zmc2V0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb24gdGhlIG5leHQgcmVjb3JkXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkT2Zmc2V0ICs9IHRoaXMuZmV0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgZmlyZU9uTGF6eVVuTG9hZCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX0xPQURJTkcgJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfTE9BRElORztcblxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG9uIHRoZSBuZXh0IHJlY29yZFxuICAgICAgICAgICAgICAgIHRoaXMubG9hZE9mZnNldCA9IHRoaXMuZmV0Y2hTaXplO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbkxvYWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGlzTG9hZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmZldGNoU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxvYWRPZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIHNjcm9sbFRvcCAoKTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gKHdpbmRvdy5wYWdlWU9mZnNldCB8fCB0aGlzLl9jb250ZW50LnNjcm9sbFRvcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgY29tcGxldGUoKWAgd2l0aGluIHRoZSBgaW5maW5pdGVgIG91dHB1dCBldmVudCBoYW5kbGVyIHdoZW5cbiAgICAgKiB5b3VyIGFzeW5jIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLiBGb3IgZXhhbXBsZSwgdGhlIGBsb2FkaW5nYFxuICAgICAqIHN0YXRlIGlzIHdoaWxlIHRoZSBhcHAgaXMgcGVyZm9ybWluZyBhbiBhc3luY2hyb25vdXMgb3BlcmF0aW9uLFxuICAgICAqIHN1Y2ggYXMgcmVjZWl2aW5nIG1vcmUgZGF0YSBmcm9tIGFuIEFKQVggcmVxdWVzdCB0byBhZGQgbW9yZSBpdGVtc1xuICAgICAqIHRvIGEgZGF0YSBsaXN0LiBPbmNlIHRoZSBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkIGFuZCBVSSB1cGRhdGVkLCB5b3VcbiAgICAgKiB0aGVuIGNhbGwgdGhpcyBtZXRob2QgdG8gc2lnbmlmeSB0aGF0IHRoZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjaGFuZ2UgdGhlIGluZmluaXRlIHNjcm9sbCdzIHN0YXRlIGZyb20gYGxvYWRpbmdgXG4gICAgICogdG8gYGVuYWJsZWRgLlxuICAgICAqL1xuICAgIGNvbXBsZXRlICgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfTE9BRElORykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRU5BQkxFRDtcblxuICAgICAgICAgICAgLy8gbmVlZCB0byB0cmlnZ2VyIGV4dHJhIGRldGVjdCBjaGFuZ2VzIHRvIHJlcmVuZGVyIGxvYWRpbmcgaWNvblxuICAgICAgICAgICAgdGhpcy5fY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgZW5hYmxlKGZhbHNlKWAgdG8gZGlzYWJsZSB0aGUgaW5maW5pdGUgc2Nyb2xsIGZyb20gYWN0aXZlbHlcbiAgICAgKiB0cnlpbmcgdG8gcmVjZWl2ZSBuZXcgZGF0YSB3aGlsZSBzY3JvbGxpbmcuIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bFxuICAgICAqIHdoZW4gaXQgaXMga25vd24gdGhhdCB0aGVyZSBpcyBubyBtb3JlIGRhdGEgdGhhdCBjYW4gYmUgYWRkZWQsIGFuZFxuICAgICAqIHRoZSBpbmZpbml0ZSBzY3JvbGwgaXMgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICAgKiBAcGFyYW0gc2hvdWxkRW5hYmxlICBJZiB0aGUgaW5maW5pdGUgc2Nyb2xsIHNob3VsZCBiZVxuICAgICAqIGVuYWJsZWQgb3Igbm90LiBTZXR0aW5nIHRvIGBmYWxzZWAgd2lsbCByZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqIGFuZCBoaWRlIHRoZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIGVuYWJsZSAoc2hvdWxkRW5hYmxlOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IChzaG91bGRFbmFibGUgPyBTVEFURV9FTkFCTEVEIDogU1RBVEVfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoc2hvdWxkRW5hYmxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIG5hdGl2ZSB3aW5kb3dzIHNjcm9sbCBldmVudFxuICAgICAqL1xuICAgIF9zZXRMaXN0ZW5lcnMgKHNob3VsZExpc3RlbjogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0KSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTGlzdGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9zY0xzbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjTHNuID0gdGhpcy5fb25TY3JvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY0xzbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuX3NjTHNuKSkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5fc2NMc24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY0xzbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBpc0xvYWRpbmcgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBTVEFURV9MT0FESU5HO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5faW5pdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RvY0JvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyh0aGlzLnN0YXRlICE9PSBTVEFURV9ESVNBQkxFRCk7XG5cbiAgICAgICAgaWYgKHRoaXMubG9hZE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5maXJlT25MYXp5TG9hZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIG5nT25EZXN0cm95ICgpXG4gICAge1xuICAgICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoZmFsc2UpO1xuICAgIH1cblxufVxuXG5cbmNvbnN0IFNUQVRFX0VOQUJMRUQgPSAnZW5hYmxlZCc7XG5jb25zdCBTVEFURV9ESVNBQkxFRCA9ICdkaXNhYmxlZCc7XG5jb25zdCBTVEFURV9MT0FESU5HID0gJ2xvYWRpbmcnO1xuIiwiaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF3TmFtZVN0b3JlIHtcblxuICAgIHByaXZhdGUgc3RvcmU6IE1hcDxzdHJpbmcsIGFueT47XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICBhZGQobmFtZTogc3RyaW5nLCBlbDogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbGxpZGVzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgaXMgbm90IHVuaXF1ZSEnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5zZXQobmFtZSwgZWwpO1xuICAgIH1cblxuICAgIHJlbW92ZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmUuZGVsZXRlKG5hbWUpO1xuICAgIH1cblxuICAgIGNvbGxpZGVzKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5oYXMobmFtZSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3RvcmUuY2xlYXIoKTtcbiAgICB9XG5cbn1cbiIsImltcG9ydCB7XG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIE9uRGVzdHJveVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgQXBwQ29uZmlnXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5pbXBvcnQge1xuICAgIEF3TmFtZVN0b3JlXG59IGZyb20gJy4vYXctbmFtZS5zdG9yZSc7XG5cbi8qKlxuICogVGhlICdhd05hbWUnIGRpcmVjdGl2ZSBhdHRhY2hlcyBhIGlkZW50aWZpZXIgdG8gZGVjb3JhdGVkIGVsZW1lbnQgdG8gYWlkIHNlbGVjdG9ycyBmb3IgdGVzdGluZ1xuICogcHVycG9zZXMuIFRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgdHJpZXMgdG8gZ2VuZXJhdGUgYSB1bmlxdWUgaWRlbnRpZmllciBiYXNlZCBvbiBjb250ZXh0dWFsIGRhdGFcbiAqIGFuZCBpbmhlcmFudCBpbW11dGFibGUgZWxlbWVudCBhdHRyaWJ1dGVzLlxuICpcbiAqICoqR2VuZXJhdGluZyB0aGUgQmFzZSBOYW1lKipcbiAqXG4gKiBUaGUgJ2F3TmFtZScgZGlyZWN0aXZlIGdlbmVyYXRlcyBhIGJhc2UgbmFtZSBmcm9tIGVsZW1lbnQgdGFnIG5hbWUgYW5kIGF0dHJpYnV0ZXMgd2hpY2ggYXJlXG4gKiBzdGF0aWMgYnkgbmF0dXJlLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGF3TmFtZT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGF3bmFtZT1cImJ1dHRvbl9vcmRlclwiPlxuICpcbiAqIElmIHRoZSBlbGVtZW50IGhhcyBhbiAnaWQnLCB0aGF0IHZhbHVlIHRha2VzIHByZWNlZGVudCBhbmQgaXMgdXNlZCBpbnN0ZWFkIG9mIGEgZ2VuZXJhdGVkXG4gKiBuYW1lLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGlkPVwibXlPcmRlckJ1dHRvblwiIGF3TmFtZT5cbiAqXG4gKiAgICAgUmVzdWx0OlxuICogICAgICAgICA8YnV0dG9uIG5hbWU9XCJvcmRlclwiIGlkPVwibXlPcmRlckJ1dHRvblwiIGF3bmFtZT1cImJ1dHRvbl9teU9yZGVyQnV0dG9uXCI+XG4gKlxuICpcbiAqICoqUmVwZWF0ZWQgRWxlbWVudHMgYW5kIHRoZSAnZXh0JyBQYXJhbWV0ZXIqKlxuICpcbiAqIFRoZXJlIGFyZSBtYW55IGNhc2VzIHdoZXJlIGVsZW1lbnRzIGFyZSBnZW5lcmF0ZWQgZHluYW1pY2FsbHkgaW4gdGhlIGNvZGUgYXMgbGlzdHMgb3IgdGFibGVzLlxuICogSW4gc3VjaCBjYXNlcywgaXQgbWF5IG5vdCBiZSBlYXN5IHRvIGRpc3Rpbmd1aXNoIGluZGl2aWR1YWwgZWxlbWVudHMgYnkgc3RhbmRhcmQgSFRNTFxuICogYXR0cmlidXRlcywgc28gdGhlICdhd05hbWUnIGRpcmVjdGl2ZSBhbGxvd3MgY3VzdG9tIGV4dGVudGlvbnMgdG8gdGhlIGJhc2UgbmFtZSB0byBiZSBwcm92aWRlZFxuICogdXNpbmcgdGhlICdleHQnIGF0dHJpYnV0ZS5cbiAqXG4gKiAgICBFeGFtcGxlOlxuICogICAgICAgIGZydWl0cyA9IFsnYXBwbGUnLCAnYmFuYW5hJywgJ29yYW5nZSddO1xuICpcbiAqICAgICAgICA8dWw+XG4gKiAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgZnJ1aXQgb2YgZnJ1aXRzXCIgYXdOYW1lIGV4dD1cInt7ZnJ1aXR9fVwiPnt7ZnJ1aXR9fTwvbGk+XG4gKiAgICAgICAgPC91bD5cbiAqXG4gKiAgIFJlc3VsdDpcbiAqICAgICAgIDx1bD5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfYXBwbGVcIj5hcHBsZTwvbGk+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX2JhbmFuYVwiPmJhbmFuYTwvbGk+XG4gKiAgICAgICAgICAgPGxpIGF3bmFtZT1cImxpX29yYW5lXCI+b3JhbmdlPC9saT5cbiAqICAgICAgIDwvdWw+XG4gKlxuICogKipBZGRpbmcgQ29udGV4dCBUaHJvdWdoIEFuY2VzdG9yIEluc3BlY3Rpb24qKlxuICpcbiAqIEluIG9yZGVyIHRvIHByb3ZpZGUgY29udGV4dCB0byB0aGUgZWxlbWVudCBuYW1pbmcsIHRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgbG9vcHMgdGhyb3VnaCB0aGVcbiAqIHBhcmVudCBhbmNlc3RyeSBhbmQgc2VhcmNoZXMgZm9yIGFueSB1bmlxdWUgZWxlbWVudCAnaWQnIHRvIHByZXBlbmQgdG8gdGhlIGJhc2UgbmFtZS5cbiAqXG4gKiAgICAgRXhhbXBsZTpcbiAqICAgICAgICAgPGZvcm0gaWQ9XCJhcHBsaWNhbnRcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICA8L2Zvcm0+XG4gKiAgICAgICAgIDxmb3JtIGlkPVwic3BvdXNlXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgPC9mb3JtPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxmb3JtIGlkPVwiYXBwbGljYW50XCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd25hbWU9XCJhcHBsaWNhbnRfaW5wdXRfZmlyc3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3bmFtZT1cImFwcGxpY2FudF9pbnB1dF9sYXN0TmFtZVwiPlxuICogICAgICAgICA8L2Zvcm0+XG4gKiAgICAgICAgIDxmb3JtIGlkPVwic3BvdXNlXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJmaXJzdE5hbWVcIiBhd25hbWU9XCJzcG91c2VfaW5wdXRfZmlyc3ROYW1lXCI+XG4gKiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJsYXN0TmFtZVwiIGF3bmFtZT1cInNwb3VzZV9pbnB1dF9sYXN0bmFtZVwiPlxuICogICAgICAgICA8L2Zvcm0+XG4gKlxuICogKipVbmlxdWVuZXNzIENoZWNrKipcbiAqXG4gKiAnYXdOYW1lJyBrZWVwcyB0cmFjayBvZiB0aGUgbmFtZXMgaXQgY3JlYXRlcyBieSBhZGRpbmcgdGhlbSB0byBhIG1hcCBzdG9yZS4gV2hlbmV2ZXIgaXRcbiAqIGNyZWF0ZXMgYSBuZXcgbmFtZSBkdXJpbmcgdGhlIGBuZ09uSW5pdGAgcGhhc2UgaXQgY2hlY2tzIGl0IGFnYWluc3QgdGhlIGV4aXN0aW5nIG1hcCxcbiAqIGFuZCB3aWxsIHRocm93IGFuIGVycm9yIGlmIGl0IGVuY291bnRlcnMgYSBkdXBsaWNhdGUuIE1vcmVvdmVyIGR1cmluZyB0aGUgZWxlbWVudCBkZXN0cnVjdGlvblxuICogcGhhc2UsIGBuZ09uRGVzdHJveWAsICdhd05hbWUnIHJlbW92ZXMgdGhlIGdlbmVyYXRlZCBuYW1lIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqXG4gKiAqKkluIFByb2R1Y3Rpb24qKlxuICpcbiAqIFVzaW5nICdhd05hbWUnIGFkZHMgYSBzbWFsbCBiaXQgb2YgcmVuZGVyaW5nIG92ZXJoZWFkIGZvciBlYWNoIGVsZW1lbnQgaXQgaXMgdXNlZCBvbi4gSW5cbiAqIGEgcHJvZHVjdGlvbiBlbnZpcm9ubWVudCwgJ2F3TmFtZScgc2VydmVzIG5vIGZ1bmN0aW9uYWxpdHkgdG8gdGhlIGVuZCB1c2VyLCBidXQgbWF5IGhhdmVcbiAqIGEgcGVyZm9ybWFuY2UgaW1wYWN0IG9uIHRoZSBhcHBsaWNhdGlvbi4gQXMgc3VjaCwgJ2F3TmFtZScgdGFrZXMgaW50byBhY2NvdW50IHRoZVxuICogYEFwcENvbmZpZ2Agc2V0dGluZ3MgYW5kIGRpc2FibGVzIG5hbWUgZ2VuZXJhdGlvbiB3aGVuIGBBcHBDb25maWcuaXNQcm9kdWN0aW9uTW9kZSgpYFxuICogaXMgYHRydWVgLlxuICpcbiAqIEluIHlvdXIgYXBwbGljYXRpb24sIHlvdSBjYW4gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgYnkgc2V0dGluZyBgZGV2bW9kZS5lbmFibGVkYCB0b1xuICogYGZhbHNlYCB3aGVuIGNvbmZpZ3VyaW5nIGBBcmliYUNvcmVNb2R1bGVgOlxuICpcbiAqICAgICBBcmliYUNvcmVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgICAgICAgICdkZXZtb2RlLmVuYWJsZWQnOiBmYWxzZVxuICogICAgIH0pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1thd05hbWVdJyxcbn0pXG5leHBvcnQgY2xhc3MgQXdOYW1lRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgZXh0OiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIG5hbWU6IHN0cmluZztcblxuICAgIHByaXZhdGUgc2VwYXJhdG9yOiBzdHJpbmcgPSAnXyc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbDogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBzdG9yZTogQXdOYW1lU3RvcmUsXG4gICAgICAgIHByaXZhdGUgY29uZmlnOiBBcHBDb25maWdcbiAgICApIHt9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5pc1Byb2R1Y3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY3JlYXRlTmFtZSh0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudFRvU3RvcmUodGhpcy5uYW1lLCB0aGlzLmVsKTtcbiAgICAgICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2F3bmFtZScsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5yZW1vdmUodGhpcy5uYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgZWxlbWVudCBuYW1lL2lkIGFuZCByZWZlcmVuY2UgdG8gbWFwIHN0b3JlLiBJZiBuYW1lL2lkIGFscmVhZHlcbiAgICAgKiBleGlzdHMgaW4gc3RvcmUgdGhlbiBpdCB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGRFbGVtZW50VG9TdG9yZShuYW1lOiBzdHJpbmcsIGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuYWRkKG5hbWUsIGVsZW0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUubWVzc2FnZSArIGAuIFwiJHtuYW1lfVwiIGlzIGFscmVhZHkgaW4gdXNlLmAsIGVsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBuYW1lL2lkIGZvciBlbGVtZW50LlxuICAgICAqXG4gICAgICogcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqIEByZXR1cm4gU3RyaW5nIE5hbWUvSURcbiAgICAgKi9cbiAgICBjcmVhdGVOYW1lKGVsZW06IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICBjb25zdCB0YWdOYW1lID0gdGhpcy5nZXRUYWdOYW1lKGVsZW0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgYXJyYXkgb2Ygc3RyaW5nIHBhcnRzXG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICAgICAgLy8gRmluZCBhbmNlc3RvciB0YWcgaWQsIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBjb25zdCBwYXJlbnRJRCA9IHRoaXMuZ2V0QW5jZXN0b3JJZChlbGVtKTtcbiAgICAgICAgaWYgKHBhcmVudElEKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHBhcmVudElEKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRoZSB0YWcgdHlwZVxuICAgICAgICBpZiAodGFnTmFtZSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSB0aGlzLmdldFBhcmVudE5hbWUoZWxlbSk7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFyZW50TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgdGFnbmFtZVxuICAgICAgICBwYXJ0cy5wdXNoKHRhZ05hbWUpO1xuXG4gICAgICAgIC8vIENob29zZSBpZCBwcm9wZXJ0eSBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5pZCkge1xuICAgICAgICAgICAgcGFydHMucHVzaChlbGVtLm5hdGl2ZUVsZW1lbnQuaWQpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBidWlsZCBleHRlbnNpb24gZnJvbSB0YWcgcHJvcGVydGllc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGEgbmFtZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmIChlbGVtLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCduYW1lJykpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGVsZW0ubmF0aXZlRWxlbWVudC5uYW1lKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHZhbHVlIGF0dHJpYnV0ZSBpZiAnb3B0aW9uJyB0YWdcbiAgICAgICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLm5hdGl2ZUVsZW1lbnQuaGFzQXR0cmlidXRlKCd2YWx1ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zcGFjZXNUb1VuZGVyc2NvcmUoZWxlbS5uYXRpdmVFbGVtZW50LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjdXN0b20gZXh0ZW5zaW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAodGhpcy5leHQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5zcGFjZXNUb1VuZGVyc2NvcmUodGhpcy5leHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKHRoaXMuc2VwYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGFnIG5hbWUgZnJvbSBlbGVtZW50IHJlZmVyZW5jZS5cbiAgICAgKiBAcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWUoZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gZWxlbS5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmF2ZXJzZSBlbGVtZW50IGFuY2VzdHJ5IGFuZCByZXR1cm4gZmlyc3QgaWQgYXR0cmlidXRlXG4gICAgICogZW5jb3VudGVyZWQuXG4gICAgICogQHBhcmFtIGVsZW0gUmVmZXJlbmNlIHRvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRBbmNlc3RvcklkKGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGVsZW0ubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICBsZXQgaWQgPSAnJztcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhaWQpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IHBhcmVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgbmFtZSBhdHRyaWJ1dGUgZnJvbSBwYXJlbnQgaWYgbmFtZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgICAqIEBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0UGFyZW50TmFtZShlbGVtOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW0ubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICByZXR1cm4gKHBhcmVudC5uYW1lICYmICFwYXJlbnQuaWQpID8gcGFyZW50Lm5hbWUgOiBudWxsO1xuICAgIH1cblxuICAgIHNwYWNlc1RvVW5kZXJzY29yZShzdHI6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccysvZywgJ18nKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RW1iZWRkZWRJdGVtRGlyZWN0aXZlfSBmcm9tICcuL2VtYmVkZGVkLWl0ZW0nO1xuaW1wb3J0IHtHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50fSBmcm9tICcuL2dlbmVyaWMtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0luY2x1ZGVDb21wb25lbnREaXJlY3RpdmV9IGZyb20gJy4vaW5jbHVkZS1jb21wb25lbnQuZGlyZWN0aXZlJztcbmltcG9ydCB7RXJyb3JNZXNzYWdlc0NvbXBvbmVudH0gZnJvbSAnLi9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQnO1xuaW1wb3J0IHtNb2RhbENvbXBvbmVudH0gZnJvbSAnLi9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudCc7XG5pbXBvcnQge0N1cnJlbmN5Rm9ybWF0UGlwZX0gZnJvbSAnLi9waXBlcy9jdXJyZW5jeS1mb3JtYXQucGlwZSc7XG5pbXBvcnQge05nRm9yU2V0RGlyZWN0aXZlfSBmcm9tICcuL29uLW5nZm9yLXNldC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbENvbXBvbmVudH0gZnJvbSAnLi9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7QXdOYW1lRGlyZWN0aXZlfSBmcm9tICcuL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEVtYmVkZGVkSXRlbURpcmVjdGl2ZSxcbiAgICAgICAgSW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZSxcbiAgICAgICAgR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgRXJyb3JNZXNzYWdlc0NvbXBvbmVudCxcbiAgICAgICAgTW9kYWxDb21wb25lbnQsXG4gICAgICAgIEN1cnJlbmN5Rm9ybWF0UGlwZSxcbiAgICAgICAgTmdGb3JTZXREaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsQ29tcG9uZW50LFxuICAgICAgICBBd05hbWVEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgTW9kYWxDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLFxuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBFcnJvck1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ3VycmVuY3lGb3JtYXRQaXBlLFxuICAgICAgICBOZ0ZvclNldERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxDb21wb25lbnQsXG4gICAgICAgIEF3TmFtZURpcmVjdGl2ZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0Vudmlyb25tZW50LCBub29wfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFBhcmVudCBjbGFzcyBmb3IgYWxsIG1vZGFsIGRpYWxvZ3MuIFByb3ZpZGVzIGRlZmF1bHRzIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBtb2RhbHMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNb2RhbENvbnRhaW5lciBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGRlc3Ryb3k6ICgpID0+IHZvaWQgPSBub29wO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGNsb3NlcyB0aGUgZGlhbG9nIGJ5IGNhbGxpbmcgZGVzdHJveSBvbiB0aGUgY29tcG9uZW50IHJlZmVyZW5jZS5cbiAgICAgKiBNZXRob2QgaW5oZXJpdGVkIGJ5IGFsbCBpdHMgY2hpbGRyZW4uXG4gICAgICovXG4gICAgY2xvc2VNb2RhbCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZSwgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgaXNTdHJpbmdNYXAsIGlzVHlwZSwgb2JqZWN0VG9OYW1lfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeSBhZ2dyZWdhdGVzIGRpZmZlcmVudCBEYXRhUHJvdmlkZXJzIHBlciB0eXBlLlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5XG57XG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGNsYXNzIG5hbWUgdG8gRGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RyeUJ5UHJvdmlkZXI6IE1hcDxzdHJpbmcsIERhdGFQcm92aWRlcjxhbnk+PjtcblxuXG4gICAgLyoqXG4gICAgICogTWFwcyBhIGNsYXNzIE5hbWUgIHRvIGFjdHVhbCB0eXBlXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RyeU5hbWVUb0NsYXNzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG5cbiAgICBjb25zdHJ1Y3RvciAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIgPSBuZXcgTWFwPHN0cmluZywgRGF0YVByb3ZpZGVyPGFueT4+KCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlOYW1lVG9DbGFzcyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIGV2ZXJ5IHNpbmdsZSByZWdpc3RlcmVkIERhdGFQcm92aWRlciBpbXBsZW1lbnRhdGlvbiB3ZSBhbHNvIG5lZWQgc3RvcmUgaXRzIHByb3RvdHlwZVxuICAgICAqIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gc3VwcG9ydCBzb21lIGtpbmQgb2YgaW5oZXJpdGFuY2UuIFlvdSBjYW4gcmVnaXN0ZXIgYSBwcm92aWRlciBmb3JcbiAgICAgKiBhIHBhcmVudCBjbGFzcyBpZiBuZWVkZWRcbiAgICAgKlxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJvdmlkZXI8VD4gKHRhcmdldDogYW55LCBwcm92aWRlcjogRGF0YVByb3ZpZGVyPFQ+KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGFyZ2V0KSB8fCAoIWlzU3RyaW5nTWFwKHRhcmdldCkgJiYgIWlzVHlwZSh0YXJnZXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcgQ2Fubm90IHJlZ2lzdGVyIG5vbi1vYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBuYW1lID0gaXNUeXBlKHRhcmdldCkgPyB0YXJnZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yLm5hbWUgOiB0YXJnZXQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIuc2V0KG5hbWUsIHByb3ZpZGVyKTtcblxuICAgICAgICBsZXQgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRhcmdldCk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlOYW1lVG9DbGFzcy5zZXQobmFtZSwgcHJvdG90eXBlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlYXJjaCBmb3IgYmVzdCBtYXRjaGluZyBwcm92aWRlci4gSWYgbm90IGZvdW5kIHRoZW4gdXNlIG9iamVjdCBwcm90b3R5cGUgdG8gZ2V0IGhvbGQgb2YgaXRzXG4gICAgICogcGFyZW50IGFuZCBzZWUgaWYgdGhlcmUgaXMgYSBwcm92aWRlciByZWdpc3RlcmVkIG9uIHRoaXMgbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIGJlc3RNYXRjaEZvckNsYXNzPFQ+IChjbGFzc05hbWU6IHN0cmluZyk6IERhdGFQcm92aWRlcjxUPlxuICAgIHtcbiAgICAgICAgbGV0IHJlZ2lzdGVyZWRDbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGxldCBjbGFzc1Byb3RvID0gdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLmdldChjbGFzc05hbWUpO1xuXG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQocmVnaXN0ZXJlZENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBwcm92aWRlcjogRGF0YVByb3ZpZGVyPFQ+ID0gdGhpcy5yZWdpc3RyeUJ5UHJvdmlkZXIuZ2V0KHJlZ2lzdGVyZWRDbGFzc05hbWUpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnR5cGUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHbyB1cCB0byBwYXJlbnRcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoY2xhc3NQcm90bykpIHtcbiAgICAgICAgICAgICAgICBjbGFzc1Byb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNsYXNzUHJvdG8pO1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnROYW1lID0gb2JqZWN0VG9OYW1lKGNsYXNzUHJvdG8pO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWRDbGFzc05hbWUgPVxuICAgICAgICAgICAgICAgICAgICAoaXNQcmVzZW50KHBhcmVudE5hbWUpICYmIHBhcmVudE5hbWUgIT09IHJlZ2lzdGVyZWRDbGFzc05hbWUpID8gcGFyZW50TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBzYW1lIGFzIGJlc3RNYXRjaEZvckNsYXNzKCkgd2l0aCB0aGUgZGlmZmVyZW5jZSB0byBwYXNzIGEgdHlwZS4gSWYgeW91IHdhbnQgdG9cbiAgICAgKiBzdXBwb3J0IG9iamVjdCBpbmhlcml0YW5jZSB5b3UgbmVlZCB0aGlzLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBiZXN0TWF0Y2hGb3JUeXBlPFQ+ICh0eXBlOiBUeXBlPFQ+KTogRGF0YVByb3ZpZGVyPFQ+XG4gICAge1xuICAgICAgICBsZXQgbmFtZTogc3RyaW5nID0gb2JqZWN0VG9OYW1lKHR5cGUpO1xuXG4gICAgICAgIHRoaXMucmVnaXN0cnlOYW1lVG9DbGFzcy5zZXQobmFtZSwgdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJlc3RNYXRjaEZvckNsYXNzPFQ+KG5hbWUpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFByb3ZpZGVyIGlzIGEgZGF0YSBkcml2ZXIgdGhhdCBjYW4gYWNjZXNzIGRhdGEgYW5kIHJldHJpZXZlIHRoZW0uIEl0IGtub3dzIGhvdyB0byBnZXQgMVxuICogb3IgbW9yZSByZWNvcmRzLCBtYXliZSBkbyBwYWdpbmcgYW5kIHNvbWUgb3RoZXIgdGhpbmdzLlxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFQcm92aWRlcjxUPlxue1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VycmVudCB0eXBlIGZvciB0aGlzIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIHR5cGU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCB0aGUgbGlzdGVuZXJzIGluIGNhc2Ugb2YgZGF0YSBhcmUgYXZhaWxhYmxlIG9yIGlmIHRoZXkgY2hhbmdlZCBkdWUgdG8gc29tZSB1c2VyXG4gICAgICogaW50ZXJhY3Rpb24gIChzZWFyY2gsIGFkZGluZyBvciByZW1vdmluZykuXG4gICAgICpcbiAgICAgKi9cbiAgICBkYXRhQ2hhbmdlczogQmVoYXZpb3JTdWJqZWN0PFRbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRbXT4oW10pO1xuXG4gICAgLyoqXG4gICAgICogIFJldHVybiBzaXplIG9mIHRoZSBzb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIGV4cGVjdGVkQ291bnQgKHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZvciB1c2UgY2FzZXMgd2hlcmUgd2UgbmVlZCB0byByZXRyaWV2ZSBkYXRhIGJhc2VkIG9uIHNvbWUgY3JpdGVyaWEgZS5nLlxuICAgICAqXG4gICAgICogIC0gbWF4IG51bWJlciBvZiByZWNvcmRzXG4gICAgICogIC0gc3VwcG9ydCBwYWdpbmcgd2l0aCBvZmZzZXQgYW5kIGxpbWl0XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBieSBmZXRjaFxuICAgICAqL1xuICAgIGFic3RyYWN0IGRhdGFGb3JQYXJhbXMgKHBhcmFtczogTWFwPHN0cmluZywgYW55Pik6IEFycmF5PFQ+O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZldGNoZXMgZGF0YSBmcm9tIHVuZGVybHlpbmcgZGF0YVByb3ZpZGVyLlxuICAgICAqXG4gICAgICogUmVwbGFjZW1lbnQgZm9yIGRhdGFmb3JQYXJhbXNcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGZldGNoIChwYXJhbXM6IE1hcDxzdHJpbmcsIGFueT4pOiBPYnNlcnZhYmxlPFRbXT47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgbm9uLWFzeW5jIGN1cnJlbnQgc3RhdGUgb2YgZGF0YVxuICAgICAqL1xuICAgIGRhdGEgKCk6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhpcyBEYXRhUHJvdmlkZXIgc3VwcG9ydHMgSU5TRVJULCBSRU1PVkVcbiAgICAgKlxuICAgICAqL1xuICAgIGNhbkNSVUQgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoaXMgRGF0YVByb3ZpZGVyIHN1cHBvcnRzIHF1ZXJ5IGNhcGFiaWxpdHlcbiAgICAgKlxuICAgICAqL1xuICAgIGNhblF1ZXJ5ICgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHN1cHBvcnQgaW5zZXJ0aW9uLiBBZnRlciByZWNvcmQgaXMgaW5zZXJ0ZWQgZW1pdCBldmVudCBmb3IgZGF0YUNoYW5nZXMgdG9cbiAgICAgKiBpbmZvcm0gYWxsIHN1YnNjcmliZXJzXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnNlcnQgKG9iajogYW55KTogdm9pZFxuICAgIHtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byBzdXBwb3J0IHJlY29yZCByZW1vdmFsLiBBZnRlciByZWNvcmQgaXMgcmVtb3ZlZCBlbWl0IGV2ZW50IGZvciBkYXRhQ2hhbmdlcyB0b1xuICAgICAqIGluZm9ybSBhbGwgc3Vic2NyaWJlcnMuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmUgKG9iajogYW55KTogdm9pZFxuICAgIHtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCB0byBwcm92aWRlIGFjY2VzcyB0byBsb3cgbGV2ZWwgc2VhcmNnIEFQSS5cbiAgICAgKlxuICAgICAqL1xuICAgIHF1ZXJ5IChwYXJhbXM6IE1hcDxzdHJpbmcsIHN0cmluZz4pOiB2b2lkXG4gICAge1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4vZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0ZpZWxkUGF0aCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7b2YgYXMgb2JzZXJ2YWJsZU9mLCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcblxuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIEFycmF5cy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5RGF0YVByb3ZpZGVyPFQ+IGV4dGVuZHMgRGF0YVByb3ZpZGVyPFQ+XG57XG5cbiAgICBjb25zdHJ1Y3RvciAocHJvdGVjdGVkICB2YWx1ZXM6IEFycmF5PFQ+KVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlID0gQXJyYXk7XG5cbiAgICAgICAgdGhpcy5kYXRhQ2hhbmdlcy5uZXh0KHRoaXMudmFsdWVzKTtcbiAgICB9XG5cbiAgICBleHBlY3RlZENvdW50IChwYXJhbXM/OiBNYXA8c3RyaW5nLCBhbnk+KTogbnVtYmVyXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGRhdGFGb3JQYXJhbXMgKHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBBcnJheTxUPlxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsocGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gdGhpcy52YWx1ZXM7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChwYXJhbXMpICYmIHBhcmFtcy5oYXMoJ29mZnNldCcpICYmIHBhcmFtcy5oYXMoJ2xpbWl0JykpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBwYXJhbXMuZ2V0KCdvZmZzZXQnKTtcbiAgICAgICAgICAgIGxldCBsaW1pdCA9IHBhcmFtcy5nZXQoJ2xpbWl0Jyk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IChvZmZzZXQgKyBsaW1pdCkpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGxpbWl0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEuc2xpY2Uob2Zmc2V0LCBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyYW1zLmhhcygnb3JkZXJieScpICYmIHBhcmFtcy5oYXMoJ3NlbGVjdG9yJykpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydChkYXRhLCBwYXJhbXMuZ2V0KCdvcmRlcmJ5JyksIHBhcmFtcy5nZXQoJ3NlbGVjdG9yJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuXG4gICAgZmV0Y2ggKHBhcmFtczogTWFwPHN0cmluZywgYW55Pik6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmRhdGFGb3JQYXJhbXMocGFyYW1zKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciBzb3J0aW5nIGN1cnJlbnQgZGF0YXNldCBieSBvbmUgY29sdW1uIC8ga2V5XG4gICAgICpcbiAgICAgKiBmb3Igc29ydE9yZGVyaW5nIHBsZWFzZSBzZWUgRGF0YXRhYmxlIGFuZCBpdHMgc29ydE9yZGVyaW5nRm9yTnVtYmVyKClcbiAgICAgKlxuICAgICAqICAgICAgMSAgPSBhc2NlbmRpbmdcbiAgICAgKiAgICAgIC0xID0gZGVzY2VuZGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgc29ydCAoYXJyYXlUb1NvcnQ6IGFueVtdLCBrZXk6IHN0cmluZywgc29ydE9yZGVyOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBhcnJheVRvU29ydC5zb3J0KChkYXRhMTogYW55LCBkYXRhMjogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgdmFsdWUxID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YTEsIGtleSk7XG4gICAgICAgICAgICBsZXQgdmFsdWUyID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YTIsIGtleSk7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHZhbHVlMSA9PSBudWxsICYmIHZhbHVlMiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gLTE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlMSAhPSBudWxsICYmIHZhbHVlMiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUxID09IG51bGwgJiYgdmFsdWUyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUxID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlMS5sb2NhbGVDb21wYXJlKHZhbHVlMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICh2YWx1ZTEgPCB2YWx1ZTIpID8gLTEgOiAodmFsdWUxID4gdmFsdWUyKSA/IDEgOiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKHNvcnRPcmRlciAqIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyLCBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc0FycmF5LCBpc1N0cmluZ30gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FycmF5RGF0YVByb3ZpZGVyfSBmcm9tICcuL2FycmF5LWRhdGEtcHJvdmlkZXInO1xuXG5cbi8qKlxuICogUHJvdmlkZXMgdG9wIGxldmVsIGFjY2Vzc29yIGNsYXNzIGluIG9yZGVyIHRvIG1ha2Uge0BsaW5rIERhdGFQcm92aWRlcn0gcmV0cmlldmFsIHByb2Nlc3MgZWFzaWVyLlxuICogVXNpbmcge0BsaW5rIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gd2UgZWl0aGVyIHJldHJpZXZlIHJlZ2lzdGVyZWQgaW5zdGFuY2Ugb2YgY29uY3JldGVcbiAqIHByb3ZpZGVyIG9yIGluc3RhbnRpYXRlIG91ciBpbXBsaWNpdCBwcm92aWRlciBmb3IgbmF0aXZlIHR5cGVzIHN1Y2ggYXMgQXJyYXkuXG4gKlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFQcm92aWRlcnNcbntcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZWdpc3RyeTogRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5KVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYmVzdCBtYXRjaGluZyAgRGF0YVByb3ZpZGVyIG9yIGNyZWF0ZSBuZXcgb25lIGluIGNhc2Ugb2YgQXJyYXlcbiAgICAgKiBNb3JlIHJvb20gdG8gcmVnaXN0ZXIgYW5kIGluc3RhbnRpYXRlIHNvbWUgb3RoZXIgaW1wbGljaXQgUHJvdmlkZXJzXG4gICAgICovXG4gICAgZmluZCh0YXJnZXQ6IGFueSk6IERhdGFQcm92aWRlcjxhbnk+XG4gICAge1xuICAgICAgICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5RGF0YVByb3ZpZGVyKHRhcmdldCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNTdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuYmVzdE1hdGNoRm9yQ2xhc3ModGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5LmJlc3RNYXRjaEZvclR5cGUodGFyZ2V0KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgcHJvdmlkZXIgd2l0aGluIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeVxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXI8VD4odGFyZ2V0OiBhbnksIHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5LnJlZ2lzdGVyUHJvdmlkZXIodGFyZ2V0LCBwcm92aWRlcik7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7SW5qZWN0YWJsZSwgVHlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIGFzc2VydCxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNCbGFuayxcbiAgICBpc0Z1bmN0aW9uLFxuICAgIGlzSnNPYmplY3QsXG4gICAgaXNQcmVzZW50LFxuICAgIGlzU3RyaW5nLFxuICAgIHVuaW1wbGVtZW50ZWRcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge29mIGFzIG9ic2VydmFibGVPZiwgT2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0FycmF5RGF0YVByb3ZpZGVyfSBmcm9tICcuL2FycmF5LWRhdGEtcHJvdmlkZXInO1xuXG5cbi8qKlxuICpcbiAqIFByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgZGlmZmVyZW50IGRhdGEgRmluZGVycyB1c2VkIG1vc3RseSBieSBEYXRhU291cmNlcy4gQWxsIEZpbmRlcnMgYXJlXG4gKiByZWdpc3RlcmVkIGJ5IHRoaXMgY2xhc3MgYXMgd2UgZG9uJ3QgaGF2ZSBhbnkgbmVlZHMgcmlnaHQgbm93IHRvIGV4cG9zZSB0aGlzIHRvIGRldmVsb3Blci5cbiAqXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhRmluZGVycyB7XG5cbiAgICBwcml2YXRlIGZpbmRlcnNCeVR5cGU6IE1hcDxEYXRhRmluZGVyLCBUeXBlPERhdGFGaW5kZXI+PiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluaXRGaW5kZXJzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgRGF0YUZpbmRlciBiYXNlZCBvbiB0aGUgb2JqZWN0IHR5cGUgYW5kIHF1ZXJ5VHlwZS5cbiAgICAgKi9cbiAgICBmaW5kKGZvclByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogRGF0YUZpbmRlciB7XG5cbiAgICAgICAgbGV0IGZpbmRlck1hdGNoOiBUeXBlPERhdGFGaW5kZXI+O1xuICAgICAgICB0aGlzLmZpbmRlcnNCeVR5cGUuZm9yRWFjaCgodjogVHlwZTxEYXRhRmluZGVyPiwgazogRGF0YUZpbmRlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGsuYWNjZXB0cyhmb3JQcm92aWRlciwgZm9yVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBmaW5kZXJNYXRjaCA9IHY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoZmluZGVyTWF0Y2gpKSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IG5ldyBmaW5kZXJNYXRjaCgpO1xuICAgICAgICAgICAgY29weS5mb3JEYXRhKGZvclByb3ZpZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBjb3B5O1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0RmluZGVycygpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcHJvdG90eXBlIGZvciBlYWNoXG4gICAgICAgIHRoaXMuZmluZGVyc0J5VHlwZS5zZXQobmV3IEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKCksIEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyKTtcblxuICAgIH1cbn1cblxuLyoqXG4gKiBXZSBoYXZlIGRpZmZlcmVudCBvcHRpb25zIGhvdyB0byBxdWVyeSBkYXRhLiBGdWxsVGV4dCB1c2VzIGEgc3RyaW5nIHdoZXJlIHByZWRpY2F0ZSBpc1xuICogdXNpbmcga2V5OnZhbHVlIHBhaXIgdG8gYnVpbHQgYSBxdWVyeVxuICovXG5leHBvcnQgZW51bSBRdWVyeVR5cGUge1xuICAgIEZ1bGxUZXh0LFxuICAgIFByZWRpY2F0ZSxcbiAgICBGdWxsVGV4dEFuZFByZWRpY2F0ZVxufVxuXG5cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBtYXRjaGluZyBjYXBhYmlsaXR5IGZvciBnaXZlbiBEYXRhUHJvdmlkZXIuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhRmluZGVyIHtcblxuXG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gZmluZCBjb25jcmV0ZSBEYXRhRmluZGVyIHdlIG5lZWQgdG8ga25vdyB0aGUgdGFyZ2V0IHR5cGUgYW5kIHRoZSBxdWVyeSB0eXBlXG4gICAgICpcbiAgICAgKi9cbiAgICBhY2NlcHRzKGZvckRhdGE6IERhdGFQcm92aWRlcjxhbnk+LCBmb3JUeXBlOiBRdWVyeVR5cGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0cyBhIERhdGFQcm92aWRlciBmb3IgRGF0YUZpbmRlclxuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgZm9yRGF0YShwcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT4pOiBEYXRhRmluZGVyO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBMb29rdXAga2V5IHRvIGFwcGx5IHdoZW4gcnVubmluZyBtYXRjaC4gSWRlYWxseSB5b3VyIERTIHNob3VsZCBiZSBhYmxlIHRvIHNldCBsb29rdXBLZXlcbiAgICAgKiBlaXRoZXIgZ2xvYmFsbHkgZm9yIGdpdmVuIGRhdGFQcm92aWRlciBvciBsb2NhbGx5IGV2ZXJ5IHRpbWUgeW91IHJ1biBzZWFyY2guIFRoaXMgaXMgaW5cbiAgICAgKiBjYXNlIHlvdSBoYXZlIG1hbnkgY2hvb3NlcnMgZm9yIHRoZSBzYW1lIHR5cGUgYW5kIHlvdSB3YW50IHRoZW0gdG8gaGF2ZSBkaWZmZXJlbnQgbG9va3VwXG4gICAgICoga2V5LlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IHNldCBsb29rdXBLZXkoa2V5OiBzdHJpbmcpO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE1hdGNoaW5nIG1ldGhvZHMgd2hpY2ggYXJlIGVpdGhlciBhc3luYyBvciBzeW5jXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBpbnN0YW50TWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBUW107XG5cbiAgICBhYnN0cmFjdCBpbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihzZWxlY3Rpb25zOiBhbnlbXSwgcXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBUW107XG5cblxuICAgIG1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyID0gLTEpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuICAgIG1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uczogYW55W10sIHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTaW1wbGUgRnVsbFRleHQgaW1wbGVtZW50YXRpb24gYmFzZWQgb24gaW5maXggc3RyaW5nIG1hdGNoaW5nIHdoaWNoIHdvcmtzIG9uIHRvcCBvZlxuICogQXJyYXlEYXRhUHJvdmlkZXIuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIEZ1bGxUZXh0QXJyYXlEYXRhRmluZGVyIGV4dGVuZHMgRGF0YUZpbmRlciB7XG4gICAgLyoqXG4gICAgICogIElmIGxpc3QgdmFsdWUgaXMgb2JqZWN0IHNldCBrZXlQYXRoIHRvIGdldCB0aGUgb2JqZWN0IHZhbHVlXG4gICAgICovXG4gICAgX2tleVBhdGg6IEZpZWxkUGF0aDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgRGF0YVByb3ZpZGVyIHVzZWQgdG8gYWNjZXNzIGRhdGFcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3Byb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcblxuXG4gICAgYWNjZXB0cyhmb3JEYXRhOiBEYXRhUHJvdmlkZXI8YW55PiwgZm9yVHlwZTogUXVlcnlUeXBlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmb3JEYXRhIGluc3RhbmNlb2YgQXJyYXlEYXRhUHJvdmlkZXIgJiYgZm9yVHlwZSA9PT0gUXVlcnlUeXBlLkZ1bGxUZXh0O1xuICAgIH1cblxuICAgIGZvckRhdGEocHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+KTogRnVsbFRleHRBcnJheURhdGFGaW5kZXIge1xuICAgICAgICB0aGlzLl9wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXQgbG9va3VwS2V5KGtleTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2tleVBhdGggPSBpc1ByZXNlbnQoa2V5KSA/IG5ldyBGaWVsZFBhdGgoa2V5KSA6IG51bGw7XG4gICAgfVxuXG4gICAgaW5zdGFudE1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogVFtdIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLl9wcm92aWRlciksICdNaXNzaW5nIERhdGFQcm92aWRlcicpO1xuXG4gICAgICAgIGxldCBsaXN0ID0gdGhpcy5fcHJvdmlkZXIuZGF0YUZvclBhcmFtcyhuZXcgTWFwKCkuc2V0KCdsaW1pdCcsIG1heCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihsaXN0LCBxdWVyeSwgbWF4KTtcbiAgICB9XG5cbiAgICBpbnN0YW50TWF0Y2hXaXRoU2VsZWN0aW9uczxUPihzZWxlY3Rpb25zOiBhbnlbXSwgcXVlcnk6IHN0cmluZywgbWF4OiBudW1iZXIpOiBBcnJheTxUPiB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5fcHJvdmlkZXIpLCAnTWlzc2luZyBEYXRhUHJvdmlkZXInKTtcblxuICAgICAgICBpZiAoaXNCbGFuayhxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb25zO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgICAgIGxldCB0b0xvd2VyUGF0dGVybiA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlbGVjdGlvbnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5tYXRjaGVzKGl0ZW0sIHRvTG93ZXJQYXR0ZXJuKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID49IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdhcm5pbmc6IElmIHlvdSBkb250IHN1cHBseSBzZWFyY2ggS2V5IGFuZCB5b3Ugd2FudCBmdWxsdGV4dCBzZWFyY2ggYW5kIHlvdSB1c2UgdGhpc1xuICAgICAqIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYmUgYXdhcmUgdGhhdCBpdCBjYW4gIHBlcmZvcm0gcG9vcmx5IGFzIGl0IGlzIG5haXZlIGltcGxlbWVudGFpb25cbiAgICAgKiB0aGF0IGRvZXMgbm90IGRvIGRlZXAgY29tcGFyZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG1hdGNoZXM8VD4oaXRlbTogYW55LCBwYXR0ZXJuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IHZhbCA9IChpc1ByZXNlbnQodGhpcy5fa2V5UGF0aCkpID8gdGhpcy5fa2V5UGF0aC5nZXRGaWVsZFZhbHVlKGl0ZW0pIDogaXRlbTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsKSkge1xuICAgICAgICAgICAgdmFsID0gdmFsLmNhbGwoaXRlbSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNKc09iamVjdChpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGl0ZW0pLmZpbHRlcigoa2V5OiBzdHJpbmcpID0+XG4gICAgICAgICAgICAgICAgaXNQcmVzZW50KGl0ZW1ba2V5XSkgJiYgaXNTdHJpbmcoaXRlbVtrZXldKSAmJiBpdGVtW2tleV1cbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgLmxlbmd0aCA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCbGFuayhwYXR0ZXJuKSB8fFxuICAgICAgICAgICAgICAgIGlzUHJlc2VudCh2YWwpICYmIHZhbC50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihwYXR0ZXJuKSA+IC0xO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBtYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlT2YodGhpcy5pbnN0YW50TWF0Y2gocXVlcnksIG1heCkpO1xuICAgIH1cblxuICAgIG1hdGNoV2l0aFNlbGVjdGlvbnM8VD4oc2VsZWN0aW9uczogYW55W10sIHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zKHNlbGVjdGlvbnMsIHF1ZXJ5LCBtYXgpKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVyc30gZnJvbSAnLi9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHt1bmltcGxlbWVudGVkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5cblxuZXhwb3J0IGNvbnN0IERBVEFfU09VUkNFID0gbmV3IEluamVjdGlvblRva2VuPERhdGFTb3VyY2U+KCdEQVRBX1NPVVJDRScpO1xuXG4vKipcbiAqIERhdGFTb3VyY2UgZGVzY3JpYmVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgZm9yIGhhbmRsaW5nIHN0cmVhbSBvZiBkYXRhIHNwZWNpZmljIHRvIGNvbXBvbmVudFxuICpcbiAqIEl0IGlzIGV4cGVjdGVkIHRoYXQgRGF0YVNvdXJjZSB3aWxsIGJlIGRlZmluZWQgYXMgY29tcG9uZW50IHByb3ZpZGVyIHVzaW5nXG4gKlxuICogQENvbXBvbmVudHMgKHtcbiAqICAgICAgLi4uXG4gKiAgICAgIHByb3ZpZGVyczpbXG4gKlxuICogICAgICAgICAgcHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZVBsYWluQXJyYXlFeGFtcGxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXVxuICogICAgICBdXG4gKlxuICogfSlcbiAqXG4gKlxuICogc28gYWxsIHRoZSBkZXBlbmRlbmNpZXMgKERhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzKSBhcmUgcHJvcGVybHkgaW5qZWN0ZWQuXG4gKlxuICogRGF0YVByb3ZpZGVyIHVzZXMgb3BlbigpIG1ldGhvZCB0byBicm9hZGNhc3QgY2hhbmdlcyB0byBhbGwgdGhlIHN1YnNjcmliZXJzIGluIHJlYWN0aXZlIHdheS5cbiAqIE9yIHlvdSBjYW4gdXNlIGluc3RhbnQoKSBtZXRob2QgdG8gcmV0cmlldmUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIERhdGFTb3VyY2UgKHN5bmMpXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVNvdXJjZVxue1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhMZW5ndGggPSAxMDtcbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4UmVjZW50U2VsZWN0ZWQgPSA1O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFYWNoIERhdGFTb3VyY2UgaGF2ZSBpbmplY3RlZCBEYXRhUHJvdmlkZXJzIGFuZCBEYXRhRmluZGVycyB0byByZXRyaWV2ZSBjb25jcmV0ZVxuICAgICAqIGltcGxlbWVudGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGF0YVByb3ZpZGVycz86IERhdGFQcm92aWRlcnMsIHByb3RlY3RlZCBmaW5kZXJzPzogRGF0YUZpbmRlcnMpXG4gICAge1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRvIGluaXRpYWxpemUgZGF0YSBzb3VyY2UgYW5kIHBhc3Mgc29tZSBhZGRpdGlvbmFsIHZhbHVlc1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIERhdGFQcm92aWRlcnMgd29ya3Mgd2l0aCBzdHJlYW0gb2YgZGF0YSBhbmQgdGhpcyBvcGVucyB1cCB0aGUgY2hhbm5lbCBpbiBvcmRlciB0b1xuICAgICAqIGxpc3RlbiBhbmQgcmVhY3QgZm9yIGFueSBjaGFuZ2VzIHRoYXQgY291bGQgaGFwcGVuIGluc2lkZSBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBvcGVuPFQ+KCk6IE9ic2VydmFibGU8VFtdPjtcblxuXG4gICAgLyoqXG4gICAgICogUmVsZWFzZSBzdWJzY3JpcHRpb24gdG8gRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgYWJzdHJhY3QgY2xvc2UoKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGRhdGEgaW5zdGFudGx5IGZyb20gdGhlIGludGVybmFsIHN0YXRlIG9mIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIGluc3RhbnQ8VD4oKTogVFtdXG4gICAge1xuXG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEU0luaXRQYXJhbXNcbntcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHZhbHVlcyBvciB0aGUgb2JqZWN0IHR5cGUgbmFtZSB3ZSB3YW50IHRvIHJlbmRlclxuICAgICAqL1xuICAgIG9iaj86IGFueTtcblxuICAgIC8qKlxuICAgICAqIFdoaWNoIGZpbmQgd2Ugd2FudCB0byBsb2FkIEZ1bGxUZXh0IG9yIFByZWRpY2F0ZVxuICAgICAqL1xuICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHNwZWNpZnkgbG9va3VwIEtleSB0byBuYXJyb3cgZG93biB0aGUgc2VhcmNoIHRvIHNwZWNpZmljIGZpZWxkLiBJZiBsb29rdXAga2V5IGlzXG4gICAgICogbnVsbCwgaXRlbXMgYXJlIGFzc3VtZWQgdG8gYmUgc3RyaW5nc1xuICAgICAqL1xuICAgIGxvb2t1cEtleT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSBDaG9vc2VyIGlzIHNpbmdsZSBvciBtdWx0aSBzZWxlY3RcbiAgICAgKi9cbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbiB0byBwYXNzIGN1c3RvbSBEYXRhUHJvdmlkZXIgaW5zdGVhZCBsZXR0aW5nIERhdGFQcm92aWRlcnMgdG8gZmluZCBtYXRjaFxuICAgICAqL1xuICAgIGRhdGFQcm92aWRlcj86IERhdGFQcm92aWRlcjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIERhdGFGaW5kZXIgaW5zdGVhZCBsZXR0aW5nIERhdGFGaW5kZXJzIHRvIGZpbmQgbWF0Y2hcbiAgICAgKi9cbiAgICBkYXRhRmluZGVyPzogRGF0YUZpbmRlcjtcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEhvc3RCaW5kaW5nfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBXZSBhcmUgdXNpbmcgdGhlc2UgY29tcG9uZW50cyBhcyBhIGJldHRlciB3YXkgc2VsZWN0b3JzLlxuICpcbiAqL1xuXG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10b3AnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgVG9wWm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQgJztcbn1cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWxlZnQnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgTGVmdFpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcbn1cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW1pZGRsZScsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBNaWRkbGVab25lQ29tcG9uZW50XG57XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJ3VpLWctMTIgdWktbWQtNiB1aS1sZy00IHVpLWctbm9wYWQnO1xufVxuXG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yaWdodCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBSaWdodFpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcblxufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctYm90dG9tJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIEJvdHRvbVpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1nLW5vcGFkJztcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEhvc3RCaW5kaW5nLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtBc3luY1ZhbGlkYXRvckZuLCBWYWxpZGF0b3JGbiwgVmFsaWRhdG9yc30gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlciwgU3RyaW5nV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Zvcm1UYWJsZUNvbXBvbmVudH0gZnJvbSAnLi4vZm9ybS10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudCwgV2lkZ2V0U2l6ZUNvbHVtbnN9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVXNlZCBieSBGb3JtVGFibGUgdG8gbGF5b3V0IGZpZWxkcyBpbnRvIFJvd3MuIEVhY2ggRm9ybVRhYmxlIHJvdyBpcyByZWFzb25hYmxlIGZvciBub3Qgb25seSB0b1xuICogaW5jbHVkZSBhY3R1YWwgY29tcG9uZW50IHN1Y2ggaXMgRHJvcERvd24gb3IgSW5wdXRGaWVsZCBidXQgbWFpbmx5IHByb3ZpZGVzIGEgZW5vdWdoIGNvbnRleHQgZm9yXG4gKiB0aGUgY29tcG9uZW50IHRvIHNwZWNpZnkgdGhlIHNpemUsIGhvdyBpdCBzaG91bGQgbGF5b3V0LCB3aGV0aGVyIHdlIG5lZWQgdG8gc2hvdyByZXF1aXJlZCBmbGFnLFxuICogdG8gc2hvdy9oaWRlIGxhYmVscyBpbiBjYXNlIGlmIHdlIGhhdmUgbm8gbGFiZWwgbGF5b3V0IGFuZCBtdWNoIG1vcmUuXG4gKlxuICogRm9ybVJvdyBjb21wb25lbnQgYWxzbyByZWdpc3RlcnMgYW5ndWxhciB2YWxpZGF0b3IgZm9yIHRoZSBjdXJyZW50IHJvdy9maWVsZC4gQXMgYWxyZWFkeVxuICogbWVudGlvbmVkIFdlIHRyZWF0IG91ciB3aWRnZXRzIHdpdGggbWluaW1hbCByZXNwb25zaWJpbGl0eSBhcyBwb3NzaWJsZSB0byBwcmVzZW50IGFuZCByZXRyaXZlXG4gKiBpbmZvcm1hdGlvbiB0by9mcm9tIHVzZXIgYW5kIGxldCBzb21lYm9keSBlbHNlIHRvIGZpZ3VyZSBvdXQgd2hlcmUgaXQgYXBwZWFyIGFuZCBob3cuXG4gKlxuICogdG9kbzogTW92ZSB1bmRlciBGb3JtVGFibGVcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1mb3JtLXJvdycsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiIWhpZGRlblwiXG4gICAgIGNsYXNzPVwidy1mb3JtLXJvdyB1aS1nXCJcbiAgICAgW2NsYXNzLmhpZ2hsaWdodC1yb3ddPVwiaGlnaGxpZ2h0Um93XCJcbiAgICAgW2NsYXNzLnJlcXVpcmVkXT1cInJlcXVpcmVkXCJcbiAgICAgW2NsYXNzLmxhYmVsLW9uLXRvcF09XCJsYWJlbHNPblRvcFwiXG4gICAgIFtjbGFzcy5sYWJlbC1vbi1zaWRlXT1cIiFsYWJlbHNPblRvcFwiXG4gICAgIFtjbGFzcy5oYXMtZGFuZ2VyXT1cIiFmb3JtQ29udHJvbC52YWxpZCAmJiAhZm9ybUNvbnRyb2wucHJpc3RpbmUgXCJcbiAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRyb2wtbGFiZWwgdWktZy0xMiB1aS1nLW5vcGFkXCJcbiAgICAgICAgICpuZ0lmPVwiIW5vTGFiZWxMYXlvdXRcIlxuICAgICAgICAgW2NsYXNzLnVpLW1kLTNdPVwiIWxhYmVsc09uVG9wXCI+XG4gICAgICAgIDxsYWJlbCBbY2xhc3Muc3Itb25seV09XCJub0xhYmVsTGF5b3V0XCI+e3tsYWJlbH19PC9sYWJlbD5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLXZhbHVlIHVpLWctbm9wYWRcIiBbbmdDbGFzc109XCJzaXplXCJcbiAgICAgICAgIFtjbGFzcy5yZWFkLW9ubHldPVwiIWVkaXRhYmxlXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPGEtZXJyb3ItbWVzc2FnZXMgW2NvbnRyb2xdPVwiZm9ybUNvbnRyb2xcIj48L2EtZXJyb3ItbWVzc2FnZXM+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5yZXF1aXJlZCBsYWJlbDphZnRlcntjb250ZW50OlwiKlwiO2NvbG9yOnJlZH0vZGVlcC8gLmhpZ2hsaWdodC1yb3d7YmFja2dyb3VuZC1jb2xvcjojZjdmOGZhfS53LWZvcm0tcm93LmhpZ2hsaWdodC1yb3d7YmFja2dyb3VuZC1jb2xvcjojZjdmOGZhfS53LWZvcm0tcm93LmxhYmVsLW9uLXRvcHtwYWRkaW5nLWJvdHRvbToxM3B4fS53LWZvcm0tcm93LmxhYmVsLW9uLXRvcCAuY29udHJvbC1sYWJlbCwudy1mb3JtLXJvdy5sYWJlbC1vbi10b3AgLmNvbnRyb2wtdmFsdWV7cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowfS53LWZvcm0tcm93LmxhYmVsLW9uLXRvcCAuY29udHJvbC1sYWJlbHtwYWRkaW5nLWJvdHRvbToxMnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwsLnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC12YWx1ZXtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjB9LnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC1sYWJlbCA6Om5nLWRlZXAgLnctc3RyaW5nLWZpZWxkLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgOjpuZy1kZWVwIC53LXN0cmluZy1maWVsZHtsaW5lLWhlaWdodDozNnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwgOjpuZy1kZWVwIC5zYXAtaWNvbiwudy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLXZhbHVlIDo6bmctZGVlcCAuc2FwLWljb257bGluZS1oZWlnaHQ6MjZweH0udy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLWxhYmVsIGxhYmVsLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgbGFiZWx7bGluZS1oZWlnaHQ6MzZweH0udy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLWxhYmVsIC5mYSwudy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLXZhbHVlIC5mYXtsaW5lLWhlaWdodDoxOHB4fS5jb250cm9sLWxhYmVse2NvbG9yOiM2MzYzNjN9LnUtdmFsaWRhdGlvbi1lcnJvcntib3JkZXItY29sb3I6cmVkfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRm9ybVJvd0NvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBsYWJlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub0xhYmVsTGF5b3V0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHJvdyB3aXRoIGhpZ2hsaWdodGVkIGJhY2tncm91bmRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlnaGxpZ2h0Um93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBGaWVsZCBsYWJlbCB0aGF0IHNob3VsZCBhcHBlYXIgYWJvdmUgb3IgbmV4dCB0byB0aGUgY29udHJvbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiAgRm9yIGlucHV0cyB0eXBlIGZpZWxkcyBwcm92aWRlcyBkZWZhdWx0IGFuZ3VsYXIgdmFsaWRhdG9ycywgbWF4aW1hbCBsZW5ndGggb2YgdGhlIGZpZWxkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtYXhMZW5ndGg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciB2YWxpZGF0b3JzLCBtaW5pbWFsIGxlbmd0aCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbkxlbmd0aDogbnVtYmVyO1xuXG5cbiAgICAvKipcbiAgICAgKiAgRm9yIGlucHV0cyB0eXBlIGZpZWxkcyBwcm92aWRlcyBkZWZhdWx0IGFuZ3VsYXIgZm9ybWF0dGVycy4gSG93IHRoZSBpbnB1dCBmaWVsZHMgc2hvdWxkIGJlXG4gICAgICogZm9ybWF0dGVkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tIGFzeW5jIHZhbGlkYXRvcnMgd2hpY2ggd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgQ29udHJvbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VzdG9tQXN5bmNWYWxpZGF0b3JzOiBBc3luY1ZhbGlkYXRvckZuW107XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1c3RvbSAgdmFsaWRhdG9ycyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBDb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21WYWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBpcyB0aGUgY3VycmVudCBzaXplIG9mIHRoZSBmaWVsZC4gQ3VycmVudCB3ZSBzdXBwb3J0IDQgZGlmZmVyZW50IHNpemVzOiB4LXNtYWxsLCBzbWFsbCxcbiAgICAgKiBtZWRpdW0sIGxhcmdlLCB4LWxhcmdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2l6ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGb3Igc2luZ2xlIGNvbHVtbiBsYXlvdXQgd2l0aG91dCB6b25lcyB3ZSBuZWVkIHRvIGFwcGx5IGdyaWQgZGlyZWN0bHkgdG8gdGhlIEZvcm1Sb3cgdGFnXG4gICAgICogc28gd2UgZG9uJ3QgbmVlZCB0byBpbnRyb2R1Y2UgZXh0cmEgZGl2IGxldmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAnJztcblxuXG4gICAgcHJpdmF0ZSBfbGFiZWxzT25Ub3A6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAvLyBFdmVudCB0aGlzIGNyZWF0ZXMgQ0kgZGVwZW5kcy4gTmVlZCB0byBoYXZlIGEgcmVmZXJlbmNlIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIC8vIEkgbmVlZCB0byByZWZhY3RvciBtb3JlIHBhcmVudCB0byBub3QgdXNlIHRoaXMgY2hpbGQgYW5kIHJlZmFjdG9yIGxheW91dGluZ1xuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtVGFibGVDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEZvcm1UYWJsZUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICAgICAgdGhpcy5fc2l6ZSA9ICd1aS1nLTEyIHVpLW1kLScgKyBXaWRnZXRTaXplQ29sdW1ucy5tZWRpdW07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSaWdodCBub3cgd2UganVzdCBpbml0aWFsaXplIHRoaXMgb25jZSBhbmQgdXNlIHRoZSB2YWx1ZXMgd2UgZG8gbm90IGV4cGVjdCBub3cgdG8gcmVhY3QgdG9cbiAgICAgKiBjaGFuZ2VzXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wobnVsbCk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlclZhbGlkYXRvcnMoKTtcblxuICAgICAgICB0aGlzLm9taXRQYWRkaW5nID0gdGhpcy5wYXJlbnRDb250YWluZXIub21pdFBhZGRpbmc7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ICs9IGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikgPyAnIHVpLWctMTIgJyA6ICcnO1xuICAgICAgICB0aGlzLmNsYXNzTGlzdCA9IHRoaXMuaGlnaGxpZ2h0Um93ID8gdGhpcy5jbGFzc0xpc3QgKyAnIGhpZ2hsaWdodC1yb3cgJyA6IHRoaXMuY2xhc3NMaXN0O1xuXG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5vbWl0UGFkZGluZyA/IHRoaXMuY2xhc3NMaXN0ICsgJyB1aS1nLW5vcGFkICcgOiB0aGlzLmNsYXNzTGlzdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEp1c3QgYSBzaXplIGdldHRlclxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IHNpemUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEEgc2l6ZSBzZXR0ZXIgd2UgdHJhbnNsYXRlIGN1c3RvbSBzaXplcyBpbnRvIGFjdHVhbCBib290c3RyYXAgZ3JpZCBzeXN0ZW0uIFdlIHVzZSBtZWRpdW1cbiAgICAgKiByaWdodCBub3cuIGJ1dCB3ZSBzaG91bGQgZXh0ZW5kIHRoaXMgZm9yIG90aGVyIHNjcmVlbiBzaXplc1xuICAgICAqXG4gICAgICogIHRvZG86IHByb3ZpZGUgbWFwcGluZyBhbmQgYWRkIG90aGVyIGdyaWQgY2xhc3NlcyBmb3Igb3RoZXIgc2l6ZXMgeHMsIHNtLCBsZywgeGxcbiAgICAgKlxuICAgICAqICBBbHNvIGNoZWNrIGlmIHRoaXMgaXMgZHluYW1pYyBzaXplIHRoYXQgc2hvdWxkIHZhcnkgYmFzZWQgb24gdGhlIGhvdyBtYW55IG51bWJlciBvZiBjb2x1bW5zXG4gICAgICogd2UgaGF2ZS4gZS5nLiBEYXRlIHdpZGdldHMgaXMgYnkgZGVmYXVsdCBzbWFsbCwgYnV0IGluIDIsIDMgY29sdW1ucyBsYXlvdXQgdGhpcyBzbWFsbCBpcyB0b29cbiAgICAgKiBzbWFsbC5cbiAgICAgKi9cblxuXG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzaXplKHZhbHVlOiBzdHJpbmcpIHtcblxuICAgICAgICBsZXQgaXNEeW5WYWwgPSBmYWxzZTtcblxuICAgICAgICBpZiAoU3RyaW5nV3JhcHBlci5zdGFydHNXaWR0aCh2YWx1ZSwgJ2QtJykpIHtcbiAgICAgICAgICAgIGlzRHluVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyKDIsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IHRoaXMuZHluU2l6ZSh2YWx1ZSwgaXNEeW5WYWwpO1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9ICd1aS1nLTEyIHVpLW1kLScgKyBkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSAmJiB0aGlzLmVkaXRhYmxlICE9PSB0aGlzLnBhcmVudENvbnRhaW5lci5lZGl0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0YWJsZSA9IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHVzaCBvdXQgb2YgYm94IGFuZ3VsYXIgdmFsaWRhdG9yIGFzIHdlbGwgYXMgY3VzdG9tIG9uZSB0byBjdXJyZW50IEZvcm1Db250cm9sXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWdpc3RlclZhbGlkYXRvcnMoKSB7XG4gICAgICAgIGxldCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdID0gW107XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1heExlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLm1heExlbmd0aCh0aGlzLm1heExlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1pbkxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLm1pbkxlbmd0aCh0aGlzLm1pbkxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJlcXVpcmVkKSAmJiB0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3JzLnB1c2goVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnBhdHRlcm4odGhpcy5wYXR0ZXJuKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmN1c3RvbVZhbGlkYXRvcnMpKSB7XG4gICAgICAgICAgICBMaXN0V3JhcHBlci5hZGRBbGwodmFsaWRhdG9ycywgdGhpcy5jdXN0b21WYWxpZGF0b3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWxpZGF0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWxpZGF0b3JzKFZhbGlkYXRvcnMuY29tcG9zZSh2YWxpZGF0b3JzKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzKSAmJiB0aGlzLmN1c3RvbUFzeW5jVmFsaWRhdG9ycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpICYmIHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKFxuICAgICAgICAgICAgICAgIFZhbGlkYXRvcnMuY29tcG9zZUFzeW5jKHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRG8gd2UgaGF2ZSBsYWJlbHMgb24gVE9QLCB0cnkgdG8gcmVhZCB0aGlzIGZyb20gUGFyZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgbGFiZWxzT25Ub3AoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX2xhYmVsc09uVG9wKSAmJiBpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDxGb3JtVGFibGVDb21wb25lbnQ+dGhpcy5wYXJlbnRDb250YWluZXIpLmlzTGFiZWxzT25Ub3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbiByZWZhY3RvciBhbGwgaW50byAxIGxpbmUgYnV0IGl0cyBoYXJkIHRvIGRlYnVnIHNvIHRoaXMgaXMganVzdCBmb3IgcmVhZFxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkeW5TaXplKHZhbHVlOiBzdHJpbmcsIGlzRHluVmFsdWU6IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgICAgICBsZXQgbm9ybWFsaXplU2l6ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnLScsICcnKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSAmJlxuICAgICAgICAgICAgKDxGb3JtVGFibGVDb21wb25lbnQ+dGhpcy5wYXJlbnRDb250YWluZXIpLmhhc1R3b0NvbHVtbiAmJiBpc0R5blZhbHVlKSB7XG5cbiAgICAgICAgICAgIGxldCBlbnVtVmFsdWVzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKFdpZGdldFNpemVDb2x1bW5zKTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZVNpemUgPSBlbnVtVmFsdWVzW2VudW1WYWx1ZXMuaW5kZXhPZihub3JtYWxpemVTaXplKSArIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoPGFueT5XaWRnZXRTaXplQ29sdW1ucylbbm9ybWFsaXplU2l6ZV07XG5cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNpbXBsZUNoYW5nZXNcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBCb3R0b21ab25lQ29tcG9uZW50LFxuICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgIFRvcFpvbmVDb21wb25lbnRcbn0gZnJvbSAnLi4vZml2ZS16b25lLWxheW91dC5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogRm9ybVRhYmxlIGlzIGEgc3BlY2lmaWMgbGF5b3V0IGNvbXBvbmVudCBmb3IgcmVuZGVyaW5nIExhYmVscyBhbmQgaXRzIGNvbnRyb2xzIGluIHR3byBjb2x1bW5zXG4gKiBhbmQgNSBkaWZmZXJlbnQgem9uZXMuXG4gKlxuICogV2Ugc3VwcG9ydCBMRUZULCBNSURETEUsIFJJR0hULCBUT1AsIEJPVFRPTSB6b25lIHdoZXJlIHdlIGNhbiBwbGFjZSBvdXIgY29tcG9uZW50IG9yIHdpZGdldHMuXG4gKiBUaGlzXG4gKiBjb21wb25lbnQgaXMgdXNlZCBhcyBwcmltYXJ5IGxheW91dCB0byB3cmFwIGFsbCB0aGUgY29tbW9uIHVzZSBjYXNlcy4gRS5nLiBXaGVuIHdlIGxheSBvdXRcbiAqIGZpZWxkcyBpbiB0aGUgZm9ybSBJIGRvIG5vdCB3YW50IGNvbnRyb2xzIHRvIGJlIGF3YXJlIG9mIGVycm9yIHZhbGlkYXRpb24sIHNpemUsIGxhYmVscywgYW5kXG4gKiBzb21lIG90aGVyIHRoaW5ncy4gQ29udHJvbCBzdWNoIElOUFVUIGlzIGp1c3QgcmVzcG9uc2libGUgZm9yIHJldHJpZXZlIHVzZXIgdmFsdWUgYnV0IG5vdCBob3cgaXRcbiAqIGFwcGVhciBvbiB0aGUgcGFnZS5cbiAqXG4gKiBUaGlzIHdheSB3ZSBjYW4gYmUgZmxleGlibGUgaG93IHdlIHRyZWF0IHdpZGdldHMgZm9yIGRpZmZlcmVudCBraW5kcyBvZiBzaXR1YXRpb24gZGVwZW5kaW5nXG4gKiB3aGVyZSB0aGV5IGFwcGVhclxuXG4gKiBGb3JtVGFibGUganVzdCBsaWtlIHRoZSByZXN0IG9mIHRoZSBjb21wb25lbnRzIGFyZSB1c2luZyBNb2RlbCBkcml2ZW4gYXBwcm9hY2ggaG93IHRvIHdvcmsgd2l0aFxuICogZGF0YSwgbWVhbiB3ZSBhcmUgdXNpbmcgRm9ybUdyb3VwLCBGb3JtQ29udHJvbCBldGMuIEZvcm1Hcm91cCBjYW4gYmUgcGFzc2VkIGludG8gdGhlIEZvcm1UYWJsZSxcbiAqIG90aGVyd2lzZSBpdHMgYXV0b21hdGljYWxseSBjcmVhdGVkIHdoZW4gdGhlIEZvcm1UYWJsZSBpcyBpbnN0YW50aWF0ZWQuXG4gKlxuICogRm9ybUdyb3VwIGlzIHNhdmVkIGluc29kZSBFbnZpcm9ubWVudCB3aGVyZSB3ZSBhcmUgdXNpbmcgdGhpcyB0byBwYXNzIHRoaXMgYXJvdW5kIHRoZSBwYWdlcyBhbmRcbiAqIGNvbXBvbmVudHMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBTaW1wbGUgTGF5b3V0IGZpZWxkcyBhbmQgaXRzIGNvbnRyb2xcbiAqXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYFxuICogIFx0XHRcdDxhdy1mb3JtLXRhYmxlIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgKG9uU3VibWl0KT0+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIiduYW1lJ1wiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogIFx0XHRcdFx0XHQ8YXctaW5wdXQtZmllbGQgW3R5cGVdPVwiJ3N0cmluZydcIj48L2F3LWlucHV0LWZpZWxkPlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidQcmVmZXJyZWQgQ29sb3JzJ1wiIFtuYW1lXT1cIidteUNvbG9ycydcIj5cbiAqICBcdFx0XHRcdFx0PGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgW2xheW91dF09XCInaW5saW5lJ1wiXG4gKiAgXHRcdFx0XHRcdCAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGljaygkZXZlbnQpXCI+XG4gKiAgXHRcdFx0XHRcdDwvYXctY2hlY2tib3gtbGlzdD5cbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidHZW5kZXInXCIgW25hbWVdPVwiJ2dlbmRlcidcIj5cbiAqXG4gKiAgXHRcdFx0XHRcdDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiVmFsdWVzXCIgW3NlbGVjdGlvbl09XCJyYlNlbGVjdGlvblwiPlxuICpcbiAqICBcdFx0XHRcdFx0PC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICpcbiAqICBcdFx0XHRcdDwvYXctZm9ybS1yb3c+XG4gKiAgXHRcdFx0XHQ8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidNeSBiaXJ0aGRhdGUnXCIgW25hbWVdPVwiJ2JpcnRoRGF0ZSdcIiBbc2l6ZV09XCInc21hbGwnXCI+XG4gKlxuICogIFx0XHRcdFx0XHQ8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgW3Nob3dUaW1lXT1cInNob3dUaW1lXCI+XG4gKiAgXHRcdFx0XHRcdDwvYXctZGF0ZS10aW1lPlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHQ8L2F3LWZvcm0tdGFibGU+XG4gKiAgICBgXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgU2hvd1VzZXJJbmZvQ29tcG9uZW50XG4gKiAge1xuICogICAgICAgY2hlY2tCb3hMaXN0VmFsdWVzOiBzdHJpbmdbXSA9IFsnYmx1ZScgLCAncmVkJyAsICd5ZWxsb3cnICwgJ29yYW5nZScgLCAnd2hpdGUnICwgJ3NpbHZlcidcbiAqICAgICAsICdibGFjaycgLCAnR3JlZW4nXG4gKiAgICAgLCAnR3JheScgLCAnTmF2eScgLFxuICogICAgICAgICAgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqICAgICAgc2VsZWN0ZWRWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKiAgICAgIHJiVmFsdWVzOiBzdHJpbmdbXSA9IFsnbWFsZScgLCAnZmVtYWxlJyAsICdvdGhlciddO1xuICogICAgICByYlNlbGVjdGlvbjogc3RyaW5nID0gJ21hbGUnO1xuICogICAgICBlZGl0YWJsZTogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgIHNob3dUaW1lOiBib29sZWFuID0gdHJ1ZTtcbiAqXG4gKiAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgb25DQkNsaWNrIChldmVudCk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIG9uU3VibWl0IChtb2RlbDogYW55KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG1vZGVsKVxuICpcbiAqICAgICAgICAgLy8gd2lsbCBwcmludCB7IG5hbWU6bnVsbCwgbXlDb2xvcnM6WydibHVlJyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ10sIGdlbmRlcjpcbiAqICAgICBtYWxlfVxuICogICAgICB9XG4gKlxuICogIH1cbiAqXG4gKiAgYGBgXG4gKlxuICogIE9yIHlvdSBjYW4gdXNlIHpvbmUgdG8gbGF5b3V0IHRoZXNlIGZpZWxkcyBpbnRvIHR3byBjb2x1bW5zOlxuICpcbiAqICBDdXJyZW50IHpvbmVzIGFyZSBpbXBsZW1lbnQgd2l0aCA8bmctY29udGVudCBTRUxFQ1Q+IHdoaWNoIGlzIGp1c3QgYSBzZWxlY3RvciB0byBzZWFyY2hlcyBmb3JcbiAqICAgICBzcGVjaWZpYyBwYXR0ZXJuLiBJbiBvdXIgY2FzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGV4dHJhIHdyYXBwZXIgY3VzdG9tIGNvbXBvbmVudCB1c2Ugc2ltcGxlXG4gKiAgICAgQ1NTIGNsYXNzXG4gKlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgI21ldGFGb3JtVGFibGUgW2VkaXRhYmxlXT1cImVkaXRpbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFt1c2VGaXZlWm9uZV09XCJpc0ZpdmVab25lTGF5b3V0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25TdWJtaXQpPVwib25TYXZlQWN0aW9uKCRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICA8YXctbGVmdCAgKm5nSWY9XCJjYW5TaG93Wm9uZSgnekxlZnQnKVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInbmFtZSdcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1pbnB1dC1maWVsZCBbdHlwZV09XCInc3RyaW5nJ1wiPjwvYXctaW5wdXQtZmllbGQ+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidQcmVmZXJyZWQgQ29sb3JzJ1wiIFtuYW1lXT1cIidteUNvbG9ycydcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1jaGVja2JveC1saXN0IFtsaXN0XT1cImNoZWNrQm94TGlzdFZhbHVlc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25zXT1cInNlbGVjdGVkVmFsdWVzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xheW91dF09XCInaW5saW5lJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvbkNCQ2xpY2soJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgPC9hdy1sZWZ0PlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICA8YXctcmlnaHQgICpuZ0lmPVwiY2FuU2hvd1pvbmUoJ3pSaWdodCcpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0dlbmRlcidcIiBbbmFtZV09XCInZ2VuZGVyJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiVmFsdWVzXCIgW3NlbGVjdGlvbl09XCJyYlNlbGVjdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ015IGJpcnRoZGF0ZSdcIiBbbmFtZV09XCInYmlydGhEYXRlJ1wiXG4gKiAgICAgW3NpemVdPVwiJ3NtYWxsJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRhdGUtdGltZSBbdmFsdWVdPVwiZGF0ZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gKiAgICAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRhdGUtdGltZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgIDwvPGF3LXJpZ2h0PlxuICogICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogIGBgYFxuICpcbiAqICB0b2RvOiByZW1vdmUgbXkgY3NzIHNlbGVjdG9ycyBmb3Igem9uZXMgYW5kIHJlcGxhY2UgaXQgd2l0aCByZWFsIGNvbXBvbmVudCBldmVuIGp1c3QgYSB0YWdcbiAqICB0b2RvOiB3b3VsZCB3b3JrIGZpbGVcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZm9ybS10YWJsZScsXG4gICAgdGVtcGxhdGU6IGA8Zm9ybSBjbGFzcz1cInctZm9ybS10YWJsZSB1aS1nIHVpLWZsdWlkXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIlxuICAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiXG4gICAgICAobmdTdWJtaXQpPVwib25TdWJtaXRGb3JtKGZvcm1Hcm91cC52YWx1ZSlcIiBub3ZhbGlkYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG48L2Zvcm0+XG5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLWNvbnRhaW5lcj5mb3Jte21hcmdpbi10b3A6MWVtfS53LWZvcm0tdGFibGUgYnV0dG9ue2Zsb2F0OnJpZ2h0fWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1UYWJsZUNvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtVGFibGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHRoZSBmb3JtIGxheW91dCB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbGFiZWxzIHN0YWNrZWQgIG9yIHNpZGUgYnkgc2lkZSBuZXh0IHRvXG4gICAgICogdGhlIGNvbnRyb2xcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxzT25Ub3A/OiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgdGhpcyBhIDQgem9uZSBsYXlvdXRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlRml2ZVpvbmU/OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGb3IgY2VydGFpbiB1c2VjYXNlIHdlIGRvbnQgd2FudCB0byBzZXQgYXV0b21hdGljYWxseSB0aGlzIHRvIGFsbCBjaGlsZHJlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdGFiaWxpdHlDaGVjazogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiAgVHJpZ2dlcnMgd2hlbiB0aGUgPGZvcm0+IGlzIHN1Ym1pdHRlZC4gb25TdWJtaXQgd2UgZW1pdCB0aGUgd2hvbGUgZm9ybUNvbnRyb2xsZXIgb2JqZWN0c1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblN1Ym1pdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgcmVwcmVzZW50IGluZGl2aWR1YWwgem9uZXMgYW5kIHdlIHVzZSB0aGVtIHRvIGFkanVzdCBvdXIgY29sdW1uIGdyaWRcbiAgICAgKiBsYXlvdXRcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKExlZnRab25lQ29tcG9uZW50KSBsZWZ0Wm9uZTogTGVmdFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKE1pZGRsZVpvbmVDb21wb25lbnQpIG1pZGRsZVpvbmU6IE1pZGRsZVpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKFJpZ2h0Wm9uZUNvbXBvbmVudCkgcmlnaHRab25lOiBSaWdodFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKFRvcFpvbmVDb21wb25lbnQpIHRvcFpvbmU6IFRvcFpvbmVDb21wb25lbnQ7XG5cbiAgICBAQ29udGVudENoaWxkKEJvdHRvbVpvbmVDb21wb25lbnQpIGJvdHRvbVpvbmU6IEJvdHRvbVpvbmVDb21wb25lbnQ7XG5cblxuICAgIEBDb250ZW50Q2hpbGRyZW4oQmFzZUZvcm1Db21wb25lbnQsIHtkZXNjZW5kYW50czogdHJ1ZX0pXG4gICAgZm9ybUZpZWxkczogUXVlcnlMaXN0PEJhc2VGb3JtQ29tcG9uZW50PjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSwge2Rlc2NlbmRhbnRzOiB0cnVlfSlcbiAgICByb3dzOiBRdWVyeUxpc3Q8Rm9ybVJvd0NvbXBvbmVudD47XG5cblxuICAgIC8qKlxuICAgICAqIENhY2hlIGNhbGN1bGF0ZWQgcHJvcGVydGllcyB3aGVuIGluaXQgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc09uZUNvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhhc1R3b0NvbHVtbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGhhc1RocmVlQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBudWxsKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ2VkaXRhYmxlJ10pICYmXG4gICAgICAgICAgICBjaGFuZ2VzWydlZGl0YWJsZSddLnByZXZpb3VzVmFsdWUgIT09IGNoYW5nZXNbJ2VkaXRhYmxlJ10uY3VycmVudFZhbHVlKSB7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRm9ybUZpZWxkcygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBvblN1Ym1pdEZvcm0oZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMub25TdWJtaXQuZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcmUgbGFiZWxzIG9uIHRvcFxuICAgICAqXG4gICAgICovXG4gICAgaXNMYWJlbHNPblRvcCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNPblRvcDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSBjaGlsZCBjb21wb25lbnQgdG8gaW5oZXJpdCBlZGl0YWJpbGl0eVxuICAgICAqXG4gICAgICovXG4gICAgaXNGb3JtRWRpdGFibGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGU7XG4gICAgfVxuXG5cbiAgICBhcHBseUNvbHVtbnMoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnVzZUZpdmVab25lICYmIHRoaXMuaGFzQW55Wm9uZXMoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdab25lcyBkZXRlY3RlZCBpbiB0aGUgRm9ybVRhYmxlIGJ1dCB1c2VGaXZlWm9uZSBvcHRpb24gaXMgZmFsc2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaGFzT25lQ29sdW1uID0gIWlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiYgIWlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpO1xuICAgICAgICB0aGlzLmhhc1R3b0NvbHVtbiA9IGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSAmJiBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmXG4gICAgICAgICAgICAhaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSk7XG5cbiAgICAgICAgdGhpcy5oYXNUaHJlZUNvbHVtbiA9IGlzUHJlc2VudCh0aGlzLmxlZnRab25lKSAmJiBpc1ByZXNlbnQodGhpcy5yaWdodFpvbmUpICYmXG4gICAgICAgICAgICBpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKTtcblxuICAgICAgICBpZiAodGhpcy5oYXNUd29Db2x1bW4gJiYgIXRoaXMuaXNUd29ab25lUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTYnO1xuICAgICAgICAgICAgdGhpcy5yaWdodFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy02JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc1RocmVlQ29sdW1uICYmICF0aGlzLmlzVGhyZWVab25lUmVhZHkoKSkge1xuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTQnO1xuICAgICAgICAgICAgdGhpcy5yaWdodFpvbmUuY2xhc3NMaXN0ICs9ICcgdWktbWQtNiB1aS1sZy00JztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBoYXNBbnlab25lcygpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgfHwgaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSlcbiAgICAgICAgICAgIHx8IGlzUHJlc2VudCh0aGlzLnRvcFpvbmUpIHx8IGlzUHJlc2VudCh0aGlzLmJvdHRvbVpvbmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gY2hlY2sgaWYgd2UgYWxyZWFkeSBpbml0aWFsaXplZCB0aGUgY2xhc3NMaXN0LlxuICAgICAqIHRoZVxuICAgICAqXG4gICAgICogVE9ETzogUHJvYmFibHkgc3RyaW5nIGFycmF5IHdvdWxkIGJlIGVhc2llclxuICAgICAqL1xuICAgIGlzVHdvWm9uZVJlYWR5KCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy02JykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy02JykgPiAwO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBhbHJlYWR5IGluaXRpYWxpemVkIHRoZSBjbGFzc0xpc3QuXG4gICAgICogdGhlXG4gICAgICpcbiAgICAgKiBUT0RPOiBQcm9iYWJseSBzdHJpbmcgYXJyYXkgd291bGQgYmUgZWFzaWVyXG4gICAgICovXG4gICAgaXNUaHJlZVpvbmVSZWFkeSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNCcpID4gMCAmJlxuICAgICAgICAgICAgdGhpcy5sZWZ0Wm9uZS5jbGFzc0xpc3QuaW5kZXhPZigndWktbGctNCcpID4gMDtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gcHJvYmxlbSBzaW5jZSBBbmd1bGFyIDQuMiwgbmdBZnRlckNvbnRlbnRJbml0XG4gICAgICAgIC8vIHdpdGhvdXQgdGhpcyBJIGdldCBlcnJvciB0aGF0IHZhbHVlIHdhcyBjaGFuZ2VkIGFmdGVyIHZpZXcgd2FzIGNoZWNrZWRcbiAgICAgICAgLy8gdG9kbzogcmVmYWN0b3IgIC0gbWFpbmx5IG91ciB6b25lcyBsZWZ0LCByaWdodCBtaWRkbGVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5Q29sdW1ucygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtRmllbGRzKCk7XG4gICAgICAgICAgICB0aGlzLmFkanVzdExheW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdXBkYXRlRm9ybUZpZWxkcygpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJpbGl0eUNoZWNrICYmIGlzUHJlc2VudCh0aGlzLmZvcm1GaWVsZHMpICYmIHRoaXMuZm9ybUZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1GaWVsZHMuZm9yRWFjaCgoaXRlbTogQmFzZUZvcm1Db21wb25lbnQpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaXRlbS5lZGl0YWJsZSA9IHRoaXMuZWRpdGFibGU7XG4gICAgICAgICAgICAgICAgLy8gaXRlbS5mb3JtR3JvdXAgPSB0aGlzLmZvcm1Hcm91cDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiBpZiB3ZSBhcmUgMiBvciAzIG9yIDEgY29sdW1uIGxheW91dCB3ZSBuZWVkIHRvIGFkanVzdCB3aWRnZXRzIHdpZHRoIHdpdGhpbiB0aGVcbiAgICAgKiBmb3JtIHJvdy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFkanVzdExheW91dCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucm93cykgJiYgdGhpcy5yb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1RocmVlQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dzLmZvckVhY2goKGl0ZW06IEZvcm1Sb3dDb21wb25lbnQpID0+IGl0ZW0uc2l6ZSA9ICdsYXJnZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1UYWJsZUNvbXBvbmVudH0gZnJvbSAnLi9mb3JtLXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4vZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgQm90dG9tWm9uZUNvbXBvbmVudCxcbiAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICBUb3Bab25lQ29tcG9uZW50XG59IGZyb20gJy4uL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRm9ybVRhYmxlQ29tcG9uZW50LFxuICAgICAgICBGb3JtUm93Q29tcG9uZW50LFxuICAgICAgICBUb3Bab25lQ29tcG9uZW50LFxuICAgICAgICBMZWZ0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgICAgICBNaWRkbGVab25lQ29tcG9uZW50LFxuICAgICAgICBCb3R0b21ab25lQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Zvcm1UYWJsZU1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2ltcGxlQ2hhbmdlcyxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNQcmVzZW50LCBWYWx1ZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGVjaW1hbFBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cblxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZXByZXNlbnQgYSBJbnB1dCBmaWVsZCBhbmQgaXQgY2FuICBhY2NlcHQgZGlmZmVyZW50IHR5cGVzIG9mIHZhbHVlcyBzdWNoIGFzXG4gKiB0ZXh0LCBudW1iZXIuXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICd3cmFwcGVyLWNvbXAnICxcbiAqICAgICAgdGVtcGxhdGU6ICc8YXctaW5wdXQtZmllbGQgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiBbdHlwZV09XCJpbnB1dFR5cGVcIj48L2F3LWlucHV0LWZpZWxkPidcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBUZXN0SW5wdXRDb21wb25lbnRcbiAqICB7XG4gKiAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHRleHQnO1xuICpcbiAqICAgICAgLy8gYnkgZGVmYXVsdCBpbnB1dCB0eXBlIGlzIHRleHQsIHlvdSBjYW4gcGFzcyBzdHJpbmcsIFN0cmluZywgb3IgdGV4dFxuICogICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogIH1cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIHdoZXIgaW5wdXQgZmllbGQgaXMgaW5pdGlhbGl6ZWQgd2l0aCBuZ01vZGVsXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1pbnB1dC1maWVsZCBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFsobmdNb2RlbCldPVwiaW5wdXRUeXBlXCI+PC9hdy1pbnB1dC1maWVsZD4nXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgVGVzdElucHV0Q29tcG9uZW50XG4gKiAge1xuICogICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSB0ZXh0JztcbiAqXG4gKiAgICAgIC8vIGJ5IGRlZmF1bHQgaW5wdXQgdHlwZSBpcyB0ZXh0LCB5b3UgY2FuIHBhc3Mgc3RyaW5nLCBTdHJpbmcsIG9yIHRleHRcbiAqICAgICAgaW5wdXRUeXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcbiAqICB9XG4gKlxuICogYGBgXG4gKlxuICogIE5vdGU6IGlmIHlvdSBhcmUgdXNpbmcgdGhpcyBvdXRzaWRlIG9mIEZvcm1UYWJsZSBwbGVhc2UgcHJvdmlkZSB5b3VyIG93biBGb3JtR3JvdXBcbiAqXG4gKi9cblxuXG5cbmV4cG9ydCBjb25zdCBJTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSW5wdXRGaWVsZENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1pbnB1dC1maWVsZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiZWRpdGFibGVcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiIGNsYXNzPVwidy1pbnB1dC13cmFwcGVyXCI+XG5cbiAgICA8aW5wdXQgcElucHV0VGV4dFxuXG4gICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgIFthdHRyLnR5cGVdPVwidHlwZVwiXG4gICAgICAgICAgIGNsYXNzPVwidy1pbnB1dC1maWVsZFwiXG4gICAgICAgICAgIFtuZ0NsYXNzXT1cInN0eWxlQ2xhc3NcIlxuICAgICAgICAgICBbY2xhc3MuaGFzLWljb25dPVwiaWNvblwiXG4gICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3twbGFjZUhvbGRlcn19XCJcbiAgICAgICAgICAgW2NsYXNzLnUtdmFsaWRhdGlvbi1lcnJvcl09XCIhKGZvcm1Db250cm9sLnZhbGlkIHx8IChmb3JtQ29udHJvbC5wcmlzdGluZSkpXCJcbiAgICAgICAgICAgZm9ybUNvbnRyb2xOYW1lPVwie3tuYW1lfX1cIlxuICAgICAgICAgICBbdmFsdWVdPVwiZGlzcGxheVZhbHVlXCI+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaWNvblwiIGNsYXNzPVwic2FwLWljb25cIiBbbmdDbGFzc109XCJpY29uXCI+PC9zcGFuPlxuPC9kaXY+XG5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cImRpc3BsYXlWYWx1ZVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWlucHV0LXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmV9LnctaW5wdXQtZmllbGR+c3Bhbnt0b3A6MTNweDtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxNXB4fWBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIElOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG5cbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dEZpZWxkQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIElucHV0RmllbGRDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgdmFsdWUgdXNlZCB0byBzYXZlIGFuZCByZWFkICB3aGVuIHJlbmRlcmluZyBhbmQgdXBkYXRpbmcgYSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHVzZWQgdG8gZm9ybWF0IHRoZSBudW1iZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwcmVjaXNpb246IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEJpZ0RlY2ltYWwgb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHZhbHVlIGFuZCBsb2NhbGUuXG4gICAgICogSWYgdGhpcyBvYmplY3QgaXMgc2V0LCB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIHRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaWdEZWNpbWFsOiBCaWdEZWNpbWFsO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZSBjdXN0b20gaWNvbiB0aGF0IGlzIHBsYWNlZCBpbnRvIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgKlxuICAgICAqIFRvZG86IGFkZCBleHRyYSBiaW5kaW5nIHRoYXQgd2lsbCBhbGxvdyBkZXZlbG9wZXIgdG8gdGVsbCBwb3NpdGlvbiwgbGVmdCByaWdodFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaWNvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSW5wdXQgZmllbGQgdHlwZS4gQ3VycmVudGx5IHdlIHN1cHBvcnQgZWl0aGVyIE51bWJlciBvciB0ZXh0XG4gICAgICovXG4gICAgcHJpdmF0ZSBfdHlwZTogc3RyaW5nID0gJ3N0cmluZyc7XG5cblxuICAgIC8qKlxuICAgICAqIEp1c3QgdG8gY2xlYW4gdXAgc3Vic2NyaWJlciB3aGVuIGNvbXBvbmVudCBpcyBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIHZjaFN1YnNjcmliZXI6IFN1YnNjcmlwdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWNpbWFsIHBpcGUgaXMgdXNlZCB0byBmb3JtYXQgb3VyIG51bWJlciBvYmplY3QuXG4gICAgICovXG4gICAgZGVjaW1hbFBpcGU6IERlY2ltYWxQaXBlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBkZWNpbWFsIHZhbHVlLiBVc2VzIGFuZ3VsYXIgZGVjaW1hbFBpcGUgdG8gZm9ybWF0IGJhc2VkIG9uIGxvY2FsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9kaXNwbGF5VmFsdWU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZGVjaW1hbFBpcGUgPSBuZXcgRGVjaW1hbFBpcGUoZW52LmxvY2FsZSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5iaWdEZWNpbWFsKTtcblxuICAgICAgICB0aGlzLnZjaFN1YnNjcmliZXIgPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodmFsID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmFsdWUgPSB2YWwpO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogZ2VuZXJhdGVkIHNldHRlciB0byBjaGVjayBmb3IgdmFsdWUgYW5kIG5vcm1hbGl6aW5nIGludG8gZXhwZWN0ZWQgZWl0aGVyIG51bWJlciBvciB0ZXh0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCB0eXBlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdzdHJpbmcnIHx8IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICd0ZXh0JztcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fdHlwZSA9ICdudW1iZXInO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG5cbiAgICBnZXQgZGlzcGxheVZhbHVlKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmJpZ0RlY2ltYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0TnVtYmVyKHRoaXMuYmlnRGVjaW1hbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5VmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5VmFsdWU7XG4gICAgfVxuXG4gICAgY2FuU2V0VHlwZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLmJpZ0RlY2ltYWwgJiYgIWVxdWFscyh2YWx1ZSwgdGhpcy5iaWdEZWNpbWFsKSkge1xuICAgICAgICAgICAgdGhpcy5iaWdEZWNpbWFsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuYmlnRGVjaW1hbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlLCB7b25seVNlbGY6IHRydWV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdCB0aGUgbnVtYmVyIG9iamVjdCBhY2NvcmRpbmcgdG8gaXRzIHByZWNpc2lvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIGZvcm1hdE51bWJlcih2YWx1ZTogYW55KSB7XG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IHByZWNpc2lvbiBpcyAyLiBGb3IgZXhhbXBsZSwgMTAuMjMuXG4gICAgICAgIGxldCBkaWdpdHMgPSAnMS4wLTInO1xuXG4gICAgICAgIC8vIElmIHByZWNpc2lvbiBpcyBwcmVzZW50LCB1c2UgaXQgZm9yIGZvcm1hdCB0aGUgYmlnRGVjaW1hbCB2YWx1ZSBmb3IgZGlzcGxheS5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnByZWNpc2lvbikgJiZcbiAgICAgICAgICAgIHRoaXMuX3R5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkaWdpdHMgPSAnMS4wLScgKyB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY2ltYWxQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgZGlnaXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnZjaFN1YnNjcmliZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnZjaFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBCaWdEZWNpbWFsIG9iamVjdCBpcyByZXByZXNlbnRlZCBhcyBhIHZhbHVlLCBsb2NhbGUsIGFuZCBjdXJyZW5jeUNvZGVcbiAqL1xuZXhwb3J0IGNsYXNzIEJpZ0RlY2ltYWwgaW1wbGVtZW50cyBWYWx1ZSB7XG4gICAgdW5pcXVlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyID0gMCxcbiAgICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcgPSAnZW5fVVMnKSB7XG4gICAgfVxuXG5cbiAgICBnZXRUeXBlcygpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIsXG4gICAgICAgICAgICBsb2NhbGU6IFN0cmluZ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ0JpZ0RlY2ltYWwnO1xuICAgIH1cblxuICAgICRwcm90bygpOiBCaWdEZWNpbWFsIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKDEsICdlbl9VUycpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmFtb3VudCArICcsIGxvY2FsZTogJyArIHRoaXMubG9jYWxlO1xuICAgIH1cblxuXG4gICAgY2xvbmUoZGF0YTogeyBhbW91bnQ/OiBudW1iZXIsIGxvY2FsZT86IHN0cmluZyB9ID0ge30pOiBCaWdEZWNpbWFsIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdEZWNpbWFsKFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuYW1vdW50KSA/IGRhdGEuYW1vdW50IDogdGhpcy5hbW91bnQsXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5sb2NhbGUpID8gZGF0YS5sb2NhbGUgOiB0aGlzLmxvY2FsZSk7XG4gICAgfVxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7U3RyaW5nQ29tcG9uZW50fSBmcm9tICcuL3N0cmluZy5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTdHJpbmdDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTdHJpbmdGaWVsZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0lucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL2lucHV0dGV4dC9pbnB1dHRleHQnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0lucHV0RmllbGRDb21wb25lbnR9IGZyb20gJy4uL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSW5wdXRGaWVsZENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBJbnB1dEZpZWxkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIElucHV0RmllbGRDb21wb25lbnQsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSW5wdXRGaWVsZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBUZW1wbGF0ZVJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtBcHBDb25maWcsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICpcbiAqIGJhc2ljIG5hdmlnYXRpb24gYmFyIHByb3ZpZGUgYSBtYWluIGFjdGlvbiBidXR0b25zIGZvciBpdHMgY29udGVudCAocGFnZSBsZXZlbCBidXR0b25zKS5cbiAqIFRoaXMgaXMgbm90IHRoZSBUb3AgbGV2ZWwgYXBwbGljYXRpb24gbmF2aWdhdGlvbi4gVGhpcyBjb21wb25lbnQgcHJvdmlkZXMgYnkgZGVmYXVsdCBhY3Rpb24gT0ssXG4gKiBDQU5DRUwgYW5kIHlvdSBhcmUgZnJlZSB0byBtb2RpZnkgaG93IHRoZSBPSyBvciBDQU5DRUwgd2lsbCBiZSBjYWxsIGFzIHdlbGwgYXMgc3Vic2NyaWJlIHRvIHRoZVxuICogZXZlbnQuIE9yIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBidXR0b25zIHRlbXBsYXRlIHdoaWNoIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoaXMgZGVmYXVsdFxuICogb25lLlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSAxOlxuICpcbiAqIEluIG9yZGVyIHRvIHVzZSBuYXZpZ2F0aW9uIGJhciBpbiBpdHMgYmFzaWMgdXNhZ2UgeW91IGNhbiBkbyBmb2xsb3dpbmc6XG4gKiB0aGlzIHdpbGwgcmVuZGVyIGJ1dHRvbnMgb24gdGhlIHRvcCBhcyB3ZWxsIGFzIG9uIHRoZSBib3R0b20gYXJvdW5kIHRoZSBjb250ZW50LlxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgICAgPGF3LWJhc2ljLW5hdmlnYXRvciBbYnJhbmRJbWddPVwiJ2ltZy9hcmliYWxvZ29iYWwucG5nJ1wiPlxuICpcbiAqICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICogICAgICAgICAgICAgICAgPGZvcm0+XG4gKiAgICAgICAgICAgICAgICAgICAgVXNlciBuYW1lOiA8aW5wdXQgdHlwZT10ZXh0IHZhbHVlPVwicGV0ZXIucGFuXCI+XG4gKiAgICAgICAgICAgICAgICA8Lzxmb3JtPj5cbiAqICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvYXctYmFzaWMtbmF2aWdhdG9yPlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiAgaWYgeW91IGRvIG5vdCB3YW50IGJ1dHRvbiBvbiB0aGUgdG9wIG9yIGJvdHRvbSB5b3UgY2FuIHNheSB0aGkgdXNpbmcgYmluZGluZyBzaG93VG9wIG9yXG4gKiBzaG93Qm90dG9tLlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZSAyOlxuICogIEluIHRoaXMgZXhhbXBsZSB3ZSBhcmUgcHJvdmlkaW5nIGN1c3RvbSBidXR0b25zIGFzIHdlbGwgYXMgYnJhbmsgc2VjdGlvblxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqXG4gKiAgICAgIDxhdy1iYXNpYy1uYXZpZ2F0b3IgW2JyYW5kSW1nXT1cIidpbWcvYXJpYmFsb2dvYmFsLnBuZydcIj5cbiAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNidXR0b25zPlxuICogICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXYgZmxvYXQtbWQtcmlnaHQgY29sbGFwc2UgbmF2YmFyLXRvZ2dsZWFibGUteHNcIj5cbiAqICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3M9XCJuYXYtaXRlbSBcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gKiAoY2xpY2spPVwib25TYXZlQWN0aW9uKCRldmVtdClcIj5DYW5jZWw8L2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIGFjdGl2ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCIgdHlwZT1cImJ1dHRvblwiXG4gKiAoY2xpY2spPVwib25DYW5jZWxBY3Rpb24oJGV2ZW50KVwiPiBTYXZlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gKiAgICAgICAgICAgICAgICA8L3VsPlxuICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNicmFuZD5cbiAqICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYnJhbmQtdGl0bGVcIj5BcmliYTwvc3Bhbj5cbiAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gKiAgICAgICAgICAgICAgICA8Zm9ybT5cbiAqICAgICAgICAgICAgICAgICAgICBVc2VyIG5hbWU6IDxpbnB1dCB0eXBlPXRleHQgdmFsdWU9XCJwZXRlci5wYW5cIj5cbiAqICAgICAgICAgICAgICAgIDwvPGZvcm0+PlxuICogICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9hdy1iYXNpYy1uYXZpZ2F0b3I+XG4gKlxuICpcbiAqIGBgYFxuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWJhc2ljLW5hdmlnYXRvcicsXG4gICAgdGVtcGxhdGU6IGA8cC10b29sYmFyICpuZ0lmPVwic2hvd1RvcFwiIFtjbGFzc109XCIndy1iYXNpYy1uYXZpZ2F0b3InXCI+XG4gICAgPGRpdiBjbGFzcz1cInVpLXRvb2xiYXItZ3JvdXAtbGVmdFwiPlxuXG4gICAgICAgIDxhIGNsYXNzPVwibmF2LWJyYW5kXCIgaHJlZj1cIiNcIiAqbmdJZj1cInNob3dCcmFuZFwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNCcmFuZFRlbXBsYXRlKClcIj5cbiAgICAgICAgICAgICAgICA8aW1nIHNyYz1cInt7YXNzZXRGb2xkZXJ9fS97e2JyYW5kSW1nfX1cIiBoZWlnaHQ9XCIzMFwiIGFsdD1cIlwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibmF2LWJyYW5kLXRpdGxlXCI+QXJpYmE8L3NwYW4+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJicmFuZFRlbXBsYXRlXCIgW2l0ZW1dPVwiY29udGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCcmFuZFRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2E+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1aS10b29sYmFyLWdyb3VwLXJpZ2h0XCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzQnV0dG9uVGVtcGxhdGUoKVwiPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uICpuZ0lmPVwic2hvd0NhbmNlbEJ1dHRvblwiIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiXG4gICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DYW5jZWxBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAge3tjYW5jZWxBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuICAgICAgICAgICAgPGF3LWJ1dHRvbiAoYWN0aW9uKT1cIm9uT0tBY3Rpb24uZW1pdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAge3tva0FjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiYnV0dG9uc1RlbXBsYXRlXCIgW2l0ZW1dPVwiY29udGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0J1dHRvblRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuXG48L3AtdG9vbGJhcj5cblxuPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG48cC10b29sYmFyICpuZ0lmPVwic2hvd0JvdHRvbVwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLXRvb2xiYXItZ3JvdXAtcmlnaHRcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNCdXR0b25UZW1wbGF0ZSgpXCI+XG5cbiAgICAgICAgICAgIDxhdy1idXR0b24gKm5nSWY9XCJzaG93Q2FuY2VsQnV0dG9uXCIgW3N0eWxlXT1cIidzZWNvbmRhcnknXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNhbmNlbEFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICB7e2NhbmNlbEFjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uIChhY3Rpb24pPVwib25PS0FjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICB7e29rQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cImJ1dHRvbnNUZW1wbGF0ZVwiIFtpdGVtXT1cImNvbnRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCdXR0b25UZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuPC9wLXRvb2xiYXI+XG5cblxuXG5gLFxuICAgIHN0eWxlczogW2BhLm5hdi1icmFuZHt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bGluZS1oZWlnaHQ6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZTtjb2xvcjojMmQzNTNjfWEubmF2LWJyYW5kOmZvY3VzLGEubmF2LWJyYW5kOmhvdmVye3RleHQtZGVjb3JhdGlvbjpub25lfWEubmF2LWJyYW5kIHNwYW57dmVydGljYWwtYWxpZ246bWlkZGxlfS5uYXYtYnJhbmQgaW1ne2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtwYWRkaW5nOjNweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBCYXNpY05hdmlnYXRvckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgdG9wXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1RvcDogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJ1dHRvbnMgd2lsbCBiZSByZW5kZXJlZCBvbiB0aGUgYm90dG9tXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JvdHRvbTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBicmFuZCBzZWN0aW9uIHRoYXQgaXMgb24gdGhlIGxlZnQgc2lkZSBhbmQgb25seSBpbiB0aGUgdG9wIGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIFRSVUVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0JyYW5kOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFJlbGF0aXZlIHBhdGggdG8gYSBpbWFnZS4gSW1hZ2VzIGFyZSBzYXZlZCBpbnNpZGUgYXNzZXRzIGZvbGRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYnJhbmRJbWc6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIE9LIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2tBY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gQ2FuY2VsIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2FuY2VsQWN0aW9uTGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBpcyBhbiBvYmplY3Qgd2hpY2ggaXMgcmVuZGVyZWQgaW5zaWRlIG5hdi1iYXIgY29udGVudC4gU29tZXRpbWVzIHRoZXJlIGFyZSBzaXR1YXRpb25cbiAgICAgKiB0aGF0IHlvdSB3YW50IHRvIHJlbmRlciBzb21lIGluZm9ybWF0aW9uIGZyb20gdGhlIG9iamVjdCBpbnNpZGUgbmF2aWdhdGlvbiBiYXIuIFNvIHlvdSBhcmVcbiAgICAgKiBmcmVlIHRvIHBhc3MgYSBjb250ZXh0IG9iamVjdCBhbmQgdGhlbiBhY2Nlc3MgaXQgaW5zaWRlIHlvdXIgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqIGBgYEhUTUxcbiAgICAgKiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjYnJhbmQgbGV0LWl0ZW0+XG4gICAgICogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJicmFuZC10aXRsZVwiPnt7aXRlbS5maXJzdE5hbWV9fTwvc3Bhbj5cbiAgICAgKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBzaG93Q2FuY2VsQnV0dG9uOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBFdmVudEVtaXR0ZXIgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiB5b3UgY2xpY2sgb24gZGVmYXVsdCBPSyBBY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT0tBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV2ZW50RW1pdHRlciB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjbGljayBvbiBkZWZhdWx0IENBTkNFTCBBY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2FuY2VsQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgYnV0dG9ucyB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdidXR0b25zJylcbiAgICBidXR0b25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBRdWVyaWVzIGEgYnJhbmQgdGVtcGxhdGUgaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYnJhbmQnKVxuICAgIGJyYW5kVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuXG4gICAgY29uc3RydWN0b3IoZW52OiBFbnZpcm9ubWVudCwgYXBwQ29uZmlnOiBBcHBDb25maWcpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIHRvZG86IGxvYWQgdGhpcyBmcm9tIHJlc291cmNlIGZpbGUgdXNpbmcgbmdUcmFuc2xhdGUgc2VydmljZVxuICAgICAgICB0aGlzLm9rQWN0aW9uTGFiZWwgPSAnT0snO1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbkxhYmVsID0gJ0NhbmNlbCc7XG4gICAgICAgIHRoaXMuYnJhbmRJbWcgPSAnaW1hZ2VzL2FyaWJhbG9nb2JhbC5wbmcnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2hvd0NhbmNlbEJ1dHRvbikpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0NhbmNlbEJ1dHRvbiA9IHRoaXMuZWRpdGFibGUgfHwgKHRoaXMub25DYW5jZWxBY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICAgICAmJiB0aGlzLm9uT0tBY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGJ1dHRvbnNUZW1wbGF0ZSBpcyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0J1dHRvblRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5idXR0b25zVGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYnJhbmRUZW1wbGF0ZSBpcyBhdmFpbGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0JyYW5kVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJyYW5kVGVtcGxhdGUpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEJ1dHRvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuIEJ1dHRvbiBjYW4gYmUgcmVuZGVyZWQgZWl0aGVyIGFzXG4gKiBhIGJ1dHRvbiBvciBhcyBhIGxpbmsuIEl0IGNvdWxkIGJlIHN0YW5kYWxvbmUgb3IgYmUgcGFydCBvZiBhIGZvcm0uXG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICA8YXctZm9ybS10YWJsZSA+XG4gKiAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIidBbW91bnQnXCIgW25hbWVdPVwiJ2Ftb3VudCdcIiBbc2l6ZV09XCInc21hbGwnXCI+XG4gKlxuICogICAgICAgICAgIDxhdy1idXR0b24gW3R5cGVdPVwiJ3N1Ym1pdCdcIiBbbmFtZV09XCInYnV0dG9uJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwib25DbGlja2VkKCRldmVudClcIiBbdmFsdWVdPVwiY29tbWFuZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZV09XCInd2FybmluZydcIiA+QnV0dG9uPC9hdy1idXR0b24+XG4gKiAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICA8L2F3LWZvcm0tdGFibGU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGNvbW1hbmQ6Ym9vbGVhbjtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgICBvbkNsaWNrZWQodmFsdWU6c3RyaW5nKSB7XG4gKiAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gKiAgICAgICAgICAgICAgLy8gc3VibWl0IGZvcm0uXG4gKiAgICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPGJ1dHRvblxuICAgIHBCdXR0b25cbiAgICBbYXR0ci50eXBlXT1cInR5cGVcIlxuICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgW25nQ2xhc3NdPVwiYnV0dG9uQ2xhc3NcIlxuICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgW2F0dHIudmFsdWVdPVwidmFsdWVcIlxuICAgIChjbGljayk9XCJjbGlja2VkKCRldmVudClcIj5cblxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvYnV0dG9uPlxuYCxcbiAgICBzdHlsZXM6IFtgLnVpLWJ1dHRvbi1saW5re2NvbG9yOiMzMzdhYjc7Zm9udC13ZWlnaHQ6NDAwO2JvcmRlci1yYWRpdXM6MDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS51aS1idXR0b24tbGluaywudWktYnV0dG9uLWxpbmsuYWN0aXZlLC51aS1idXR0b24tbGluazphY3RpdmUsLnVpLWJ1dHRvbi1saW5rOmZvY3VzLC51aS1idXR0b24tbGluazpob3ZlciwudWktYnV0dG9uLWxpbmtbZGlzYWJsZWRde2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudH0udWktYnV0dG9uLWxpbms6Zm9jdXMsLnVpLWJ1dHRvbi1saW5rOmhvdmVye2NvbG9yOiMzMzdhYjc7LXdlYmtpdC10ZXh0LWRlY29yYXRpb246IzMzN2FiNzt0ZXh0LWRlY29yYXRpb246IzMzN2FiNztiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS51aS1idXR0b24tbGlua1tkaXNhYmxlZF06Zm9jdXMsLnVpLWJ1dHRvbi1saW5rW2Rpc2FibGVkXTpob3Zlcntjb2xvcjojMjM5OWU1O3RleHQtZGVjb3JhdGlvbjpub25lfS51aS1idXR0b257bWFyZ2luLXJpZ2h0OjVweH0uYnRuLW1pZHtoZWlnaHQ6MzZweDtwYWRkaW5nOjVweCAxMHB4fS5idG4tbGd7aGVpZ2h0OjQycHg7Zm9udC1zaXplOjE2cHg7cGFkZGluZzo1cHggMTJweH0uYnRuLXNte2hlaWdodDozMHB4O2ZvbnQtc2l6ZToxMnB4O3BhZGRpbmc6NXB4IDEwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXRcbntcblxuICAgIC8qKlxuICAgICAqIEJ1dHRvbiB0eXBlcyAgWyBidXR0b24gfCBzdWJtaXQgfCByZXNldCBdXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZyA9ICdidXR0b24nO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBmb3IgdGhpcyBidXR0b24uIENhbiBiZSB1c2VkIHRvIGxvb2t1cCBjb21wb25lbnQgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5hbWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc3R5bGluZyBmb3IgdGhpcyBidXR0b24uIFNlZSBCdXR0b25TdHlsZSBmb3IgYWxsIHN1cHBvcnRlZCBzdHlsZXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdHlsZTogQnV0dG9uU3R5bGUgPSAncHJpbWFyeSc7XG5cblxuICAgIC8qKlxuICAgICAqIHNpemluZyBmb3IgdGhpcyBidXR0b24uIFtsYXJnZSwgbm9ybWFsLCBzbWFsbF0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaXplOiBCdXR0b25TaXplID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZ5IHRoZSB0YXJnZXQgb2YgdGhlIGJ1dHRvbi4gW19ibGFuayB8IF9zZWxmIHwgX3BhcmVudCB8IF90b3AgfCBmcmFtZW5hbWUgXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFyZ2V0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSB0byBiZSBzZW5kIHRvIHNlcnZlciB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBQcmltZU5nIGJ1dHRvbiBzaW1wbHkgZG9lcyBub3Qgc3VwcG9ydCBjb250ZW50IHNvIHdlIG5lZWQgdG8gZ2V0IGFyb3VuZCBpdFxuICAgICAqL1xuICAgIGxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBDU1MgY2xhc3MgdGhhdCBzdHlsZXMgdGhpcyBidXR0b24gYmFzZWQgb24gaW5wdXQgJ3N0eWxlJyBhbmQgJ3NpemUnXG4gICAgICovXG4gICAgYnV0dG9uQ2xhc3M6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBidXR0b24gY2xhc3MgaXMgc2Vjb25kYXJ5LlxuICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJ3VpLWJ1dHRvbi1zZWNvbmRhcnknO1xuXG4gICAgICAgIC8vIERlZmF1bHQgZGlzYWJsZWRcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIC8vIEhvdyB0byBzdHlsZSB0aGlzIGJ1dHRvbi5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0eWxlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3R5bGUgPT09ICdwcmltYXJ5Jykge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgLnVpLWJ1dHRvbiBhbmQgLnVpLWJ1dHRvbi1wcmltYXJ5IGdldCB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgICAgICAgICAvLyAudWktYnV0dG9uLXByaW1hcnkgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYnV0dG9uIHN0eWxlIGNhbiBiZSBvdmVycmlkZGVuXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBpbmNsdWRlZCBpbnNpZGUgb3RoZXIgd2lkZ2V0cy4gU28gc3BlY2lmeSBwcmltYXJ5XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICd1aS1idXR0b24tcHJpbWFyeSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAndWktYnV0dG9uLScgKyB0aGlzLnN0eWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBidXR0b24gY2xhc3MgYmFzZWQgb24gaW5wdXQgc2l6ZS5cbiAgICAgICAgaWYgKHRoaXMuc2l6ZSkge1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xhcmdlJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgKz0gJyBidG4tbGcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub3JtYWwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyArPSAnIGJ0bi1taWQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzICs9ICcgYnRuLXNtJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgbGl0dGxlIGhhY2t5IGhhY2tpdHkgaGFjayBhcyBjdXJyZW50bHkgcHJpbWVuZyBidXR0b24gZGlyZWN0aXZlIGRvZXMgbm90IHdvcmsgd2l0aFxuICAgICAqIG5nY29udGVudCBwcm9qZWN0aW9uIGJ1dCBpdCBoYXMgYSBsYWJlbCBiaW5kaW5ncywgd2hpY2ggaXMgbm90IHRoZSB3YXkgZGV2ZWxvcGVycyB3b3JrIHdpdGhcbiAgICAgKiBidXR0b24uIHlvdSB3YW50IHRvXG4gICAgICpcbiAgICAgKiA8YnV0dG9uPiBNWSBDT05URU5UPC9idXR0b24gaW5zdGVhZCBvZiA8YnV0dG9uIGxhYmVsPSdNeUNvbnRlbnQnPjwvYnV0dG9uPlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAVG9kbzogQ2hhbmdlIHRoaXMgdW50aWwgdGhlIHRpbWUga2VlcCBhIHRlc3QgdGhhdCBjaGVjayB0aGF0IHRoZXkgYXJlIHN0aWxsIHVzaW5nIHVpLWJ1dHRvblxuICAgICAqICAgICB0aGF0IHdlIGFyZSBleHBlY3RpbmcgYW5kIHJlcGxhY2luZ1xuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgIGxldCBidXR0b25UaXRsZSA9IGJ1dHRvbi5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIGJ1dHRvbi5jaGlsZHJlblswXS50ZXh0Q29udGVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnRleHRDb250ZW50LnRyaW0oKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCd1aS1idXR0b24nLCAnJykucmVwbGFjZSgndWktYnRuJywgJycpO1xuXG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgndWktYnV0dG9uLXRleHQtZW1wdHknKTtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGJ1dHRvblRpdGxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBBY3Rpb24gY2xpY2tlZC4gQ2FsbCBwYXJlbnQgYWN0aW9uLlxuICAgICAqL1xuICAgIGNsaWNrZWQoJGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KGlzQmxhbmsodGhpcy52YWx1ZSkgPyAkZXZlbnQgOiB0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBTdXBwb3J0ZWQgQnV0dG9uIFN0eWxlXG4gKi9cbmV4cG9ydCB0eXBlIEJ1dHRvblN0eWxlID0gJ2luZm8nIHwgJ3ByaW1hcnknIHwgJ3NlY29uZGFyeScgfCAnd2FybmluZycgfCAnc3VjY2VzcycgfCAnZGFuZ2VyJyB8XG4gICAgJ2xpbmsnO1xuXG4vKipcbiAqIFN1cHBvcnRlZCBCdXR0b24gU2l6ZVxuICovXG5leHBvcnQgdHlwZSBCdXR0b25TaXplID0gJ2xhcmdlJyB8ICdub3JtYWwnIHwgJ3NtYWxsJztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QnV0dG9uQ29tcG9uZW50fSBmcm9tICcuL2J1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtCdXR0b25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEJ1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0J1dHRvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QmFzaWNOYXZpZ2F0b3JDb21wb25lbnR9IGZyb20gJy4vYmFzaWMtbmF2aWdhdG9yLmNvbXBvbmVudCc7XG5pbXBvcnQge1Rvb2xiYXJNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG5cbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQmFzaWNOYXZpZ2F0b3JDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdCYXNpY05hdmlnYXRvck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBEaXJlY3RpdmUsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgYXctY2FyZC10b3BgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC16dG9wJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFpvbmVUb3BDb21wb25lbnRcbntcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBhdy1jYXJkLWJvdHRvbWAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXpib3R0b20nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxue1xufVxuXG4vKipcbiAqXG4gKiBDYXJkIGNvbXBvbmVudCBpcyBhIGNvbnRhaW5lciByZW5kZXJpbmcgaXRzIGNvbnRlbnQgaW5zaWRlIDMgZGlmZmVyZW50IHpvbmVzLlxuICpcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgVElUTEUgICAgICAgICAgICAgICAgICAgICAgIHwgQUNUSU9OIHxcbiAqICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgVE9QICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgQk9UVE9NICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKlxuICogIFRoZXJlIGFyZSAzIHpvbmVzICArIDEgcGxhY2Vob2xkZXIgZm9yIHRoZSBhY3Rpb25JY29uXG4gKlxuICogIENhcmRzIGNhbiBiZSBzZWxlY3RhYmxlIHdoaWNoIG1lYW5zIHdoZW4geW91IGNsaWNrIG9uIGl0IHRoZXJlIHdpbGwgYmUgcmVuZGVyZWQgYSBib3JkZXIgd2l0aFxuICogIGEgY2hlY2sgbWFyayBpbnNpZGUgQWN0aW9uIHpvbmUgKHRoaXMgaXMgZGVmYXVsdCBiZWhhdmlvcikuXG4gKiAgWW91IGNhbiB1c2UgW3NlbGVjdGFibGVdIGJpbmRpbmcgdG8gZGlzYWJsZSB0aGlzLCBpbiBzdWNoIGNhc2UgY2FyZCB3aWxsIGhhdmUganVzdCBhIGJvcmRlclxuICogIHdpdGhvdXQgYW55IGNoZWNrIG1hcmsuXG4gKlxuICogIENhcmRzIGNhbiBhbHNvIGNvbnRhaW4gY3VzdG9tIEFjdGlvbiB3aGljaCBpcyByZW5kZXJlZCBpbnNpZGUgQUNUSU9OIHpvbmUgYW5kIG9uIHRoZVxuICogIGFwcGxpY2F0aW9uIGxldmVsIHlvdSBjYW4gbGlzdGVuIGZvciAoY2xpY2spIGV2ZW50cyBhcyB3ZWxsIGFzIHlvdSBjYW4gcHJvdmlkZSB5b3VyIG93biBhY3Rpb25cbiAqICBpY29uXG4gKlxuICogIEJlc2lkZXMgQUNUSU9OLCBUSVRMRSwgVE9QIGFuZCBCT1RUT00gY29udGVudCB6b25lcyBjYXJkcyBzdXBwb3J0IGhvdmVyIG92ZXJsYXkgZWZmZWN0IGFuZFxuICogIHdoZW4gaXRzIGFjdGl2YXRlZCB0aGVyZSBpcyBhIG92ZXJsYXkgZGlzcGxheWVkIG9uIHRvcCBvZiB0aGUgY2FyZCB3aXRoIEljb24gaW4gdGhlIG1pZGRsZS5cbiAqICBQbGVhc2Ugbm90ZSB3aGVuIFtoYXNIb3Zlcl0gaXMgVFJVRSBhbGwgdGhlIGFjdGlvbnMgYW5kIHNlbGVjdGFiaWxpdHkgYXJlIGRpc2FibGVkIGFzIHRoZXJlIGlzXG4gKiAgb25seSBvbmUgYWN0aW9uIHdoaWNoIGNsaWNrIG9uIHRoZSBob3ZlciBvdmVybGF5LlxuICpcbiAqXG4gKiAjIyNleGFtcGxlIDE6XG4gKiAgQmFzaWMgaG92ZXIgY2FyZCB3aGljaCBieSBkZWZhdWx0IHN1cHBvcnQgc2VsZWN0YWJsZSBtb2RlXG4gKlxuICogYGBgXG4gKiAgICAgICAgICA8YXctY2FyZCAjY2FyZDEgW2hhc0FjdGlvbl09XCJmYWxzZVwiIFt3aWR0aF09XCInMjAycHgnXCIgW2hlaWdodF09XCInMTU0cHgnXCI+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10b3A+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllck5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEhhaWdodCBQdW1wc1xuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTG9jYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFBhbG8gQWx0bywgQ0EsIFVTQVxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdG9wPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC1ib3R0b20gY2xhc3M9XCJ3LWNhcmQtemJvdHRvbVwiPlxuICogICAgICAgICAgICAgICAgICAgICBzb21lIHRleHQgYWJvdXQgdGhlIHN1cHBsaWVyIGFuZCBoaXMgcGFyZW50czxici8+XG4gKiAgICAgICAgICAgICAgICAgICAgIGFuZCBzb21lIGNvbnRhY3RzXG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLWJvdHRvbT5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKlxuICogICMjI2V4YW1wbGUgMjpcbiAqICAgSG92ZXIgY2FyZCB3aXRoIGN1c3RvbSBhY3Rpb24uIHdoZW4gdW5zZWxlY3RlZCBhY3Rpb24gd2lsbCBhcHBlYXIgYW5kIHVzZXIgY2FuIGNsaWNrIG9uIGl0LlxuICpcbiAqIGBgYFxuICogICAgICAgICAgPGF3LWNhcmQgI2NhcmQxIFtzZWxlY3RhYmxlXT1cInRydWVcIiBbYWN0aW9uSWNvbl09XCInaWNvbi1xdWVzdGlvbi1tYXJrJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgIChvbkFjdGlvbik9XCJvbkFjdGlvbigzLCAkZXZlbnQpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFByZWZlcnJlZFxuICogICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC10b3A+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdXBwbGllck5hbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIEhhaWdodCBQdW1wc1xuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTG9jYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgIFBhbG8gQWx0bywgQ0EsIFVTQVxuICogICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdG9wPlxuICpcbiAqICAgICAgICAgICAgICAgICA8YXctY2FyZC1ib3R0b20gY2xhc3M9XCJ3LWNhcmQtemJvdHRvbVwiPlxuICogICAgICAgICAgICAgICAgICAgICBzb21lIHRleHQgYWJvdXQgdGhlIHN1cHBsaWVyIGFuZCBoaXMgcGFyZW50czxici8+XG4gKiAgICAgICAgICAgICAgICAgICAgIGFuZCBzb21lIGNvbnRhY3RzXG4gKiAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLWJvdHRvbT5cbiAqXG4gKiAgICAgICAgICAgICA8L2F3LWNhcmQ+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2FyZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidy1jYXJkXCIgW3N0eWxlLndpZHRoXT1cIndpZHRoXCIgW3N0eWxlLmhlaWdodF09XCJoZWlnaHRcIlxuICAgICBbY2xhc3MudS1pcy1ob3Zlcl09XCJoYXNIb3ZlclwiXG4gICAgIChtb3VzZWVudGVyKT1cIm9uSG92ZXIodHJ1ZSlcIlxuICAgICAobW91c2VsZWF2ZSk9XCJvbkhvdmVyKGZhbHNlKVwiXG4gICAgIFtjbGFzcy51LWNhcmQtc2VsZWN0ZWRdPVwic2VsZWN0ZWRcIlxuICAgICBbY2xhc3MudS1jYXJkLXVuc2VsZWN0ZWRdPVwiIXNlbGVjdGVkXCJcbiAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiXG4+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY2FyZC1ib2R5IHVpLWdcIiAgKm5nSWY9XCIhc2hvd0JvZHlUZW1wbGF0ZSgpXCI+XG4gICAgICAgIDwhLS0gSG92ZXIgZWxlbWVudCB0aGF0IGlzIHRyaWdnZXJlZCBieSBtb3VzZWVudGVyLCBtb3VzZWxlYXZlIGV2ZW50cy0tPlxuICAgICAgICA8ZGl2ICNob3ZlckRpdiAqbmdJZj1cImhhc0hvdmVyXCIgY2xhc3M9XCJ1LWNhcmQtaG92ZXJcIiAoY2xpY2spPVwib25Ib3ZlckFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgIDxzcGFuIFtzdHlsZS53aWR0aF09XCInMTAwJSdcIiBjbGFzcz1cInNhcC1pY29uXCIgW25nQ2xhc3NdPVwiaG92ZXJJY29uXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPCEtLSBIRUFERVIgSEFWSU5HIFRJVExFIEFORCBJQ09OUy9BQ1RJT05TLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLWctbm9wYWQgdy1jYXJkLWhlYWRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInctY2FyZC16dGl0bGUgdWktZy1ub3BhZFwiIChjbGljayk9XCJ0b2dnbGVTZWxlY3QoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieyd1aS1nLTknOiBoYXNBY3Rpb24gfHwgc2VsZWN0YWJsZSwgJ3VpLWctMTEnOiAhaGFzQWN0aW9uICYmICFzZWxlY3RhYmxlfVwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWNhcmQtdGl0bGVcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhhc0FjdGlvbiB8fCBzZWxlY3RhYmxlXCIgY2xhc3M9XCJ3LWNhcmQtemFjdGlvbiB1aS1nLW5vcGFkIHVpLWctM1wiPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJzZWxlY3RlZCAmJiBzZWxlY3RhYmxlXCIgY2xhc3M9XCJzYXAtaWNvbiBzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLWFjdGlvbi1iZ109XCJzZWxlY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVNlbGVjdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJzZWxlY3RlZEljb25cIj48L3NwYW4+XG5cblxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzQWN0aW9uICYmICghc2VsZWN0ZWQgfHwgIXNlbGVjdGFibGUpIFwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzYXAtaWNvbiBhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwib25BY3Rpb25DbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJhY3Rpb25JY29uXCJcbiAgICAgICAgICAgICAgICA+PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwhLS1UT1AgQ0FSRCBTRUNUSU9OLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3LWNhcmQtenRvcCB1aS1nLW5vcGFkIHVpLWctMTIgXCJcbiAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlU2VsZWN0KCRldmVudClcIlxuICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtcG9pbnRlcl09XCJzZWxlY3RhYmxlXCI+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jYXJkLXRvcFwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZCB3LWNhcmQtbGluZS1kaXZpZGVyICBcIiAqbmdJZj1cInNob3dCb3R0b21TZWN0aW9uKClcIj48L2Rpdj5cbiAgICAgICAgPCEtLUJPVFRPTSBDQVJEIFNFQ1RJT04tLT5cbiAgICAgICAgPGRpdiAqbmdJZj1cInNob3dCb3R0b21TZWN0aW9uKClcIiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZCB3LWNhcmQtemJvdHRvbVwiXG4gICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1wb2ludGVyXT1cInNlbGVjdGFibGVcIlxuICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVTZWxlY3QoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY2FyZC1ib3R0b21cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiAqbmdJZj1cInNob3dCb2R5VGVtcGxhdGUoKVwiIGNsYXNzPVwidy1jYXJkLXVzZXItY250XCIgPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVRlbXBsYXRlXCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWNhcmR7Ym9yZGVyOjJweCBzb2xpZCAjMDA3NmNiO2Rpc3BsYXk6aW5saW5lLWJsb2NrO292ZXJmbG93OmhpZGRlbjtjb2xvcjojNjM2MzYzO2JveC1zaXppbmc6Ym9yZGVyLWJveH0udy1jYXJkLWhlYWRlcntwb3NpdGlvbjpyZWxhdGl2ZTtoZWlnaHQ6MzBweDtwYWRkaW5nLWxlZnQ6MWVtfS53LWNhcmQtenRpdGxle2hlaWdodDoxMDAlO3BhZGRpbmctdG9wOjNweH0udy1jYXJkLXp0aXRsZSA6Om5nLWRlZXAgLnctY2FyZC10aXRsZXtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleH0udy1jYXJkLXp0aXRsZSA6Om5nLWRlZXAgLnctY2FyZC10aXRsZT4qe2ZsZXg6MCAxfS53LWNhcmQtemFjdGlvbntoZWlnaHQ6MTAwJTtkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOnJpZ2h0fS53LWNhcmQtemFjdGlvbiAuc2FwLWljb257d2lkdGg6MjlweDtoZWlnaHQ6MjlweDt0ZXh0LWFsaWduOmNlbnRlcjtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6MS41ZW07bGluZS1oZWlnaHQ6MS40ZW19LnctY2FyZC16YWN0aW9uIC5zYXAtaWNvbi5zZWxlY3Rpb257Y29sb3I6I2ZmZn0udy1jYXJkLXphY3Rpb24gLnNhcC1pY29uLmFjdGlvbntjb2xvcjojOTY5Njk2fS53LWNhcmQtemJvdHRvbSwudy1jYXJkLXp0b3B7cGFkZGluZzoxZW19LnctY2FyZC1saW5lLWRpdmlkZXJ7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q2ZDZkNjttYXJnaW46MCAxNHB4fS53LWNhcmQtdXNlci1jbnR7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOiNlZWV9LnUtY2FyZC1ob3Zlcntwb3NpdGlvbjphYnNvbHV0ZTtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlO29wYWNpdHk6MDt0cmFuc2l0aW9uOi41cyBlYXNlO2JhY2tncm91bmQtY29sb3I6IzAwNzZjYjt6LWluZGV4OjEwMH0udS1jYXJkLWhvdmVyIC5zYXAtaWNvbnt0ZXh0LWFsaWduOmNlbnRlcjtkaXNwbGF5OmlubGluZS1ibG9jaztmb250LXNpemU6NGVtO2NvbG9yOiNmZmY7cG9zaXRpb246cmVsYXRpdmU7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS51LWNhcmQtYWN0aW9uLWJne2JhY2tncm91bmQ6IzAwNzZjYn0udS1pcy1ob3Zlcntwb3NpdGlvbjpyZWxhdGl2ZX0udS1jYXJkLXNlbGVjdGVke2JvcmRlci1jb2xvcjojMDA3NmNifS51LWNhcmQtdW5zZWxlY3RlZHtib3JkZXItY29sb3I6I2Q3ZDdkN30udS1jYXJkLWhvdmVyLC51LWNhcmQtcG9pbnRlcntjdXJzb3I6cG9pbnRlcn1gXVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIHNob3VsZCBleHBsaWNpdGx5IGhpZGUgdGhlIGFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoYXNBY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgc2VsZWN0YWJsZSBtb2RlIHN1cHBvcnRlZD8gU2F5aW5nIFllcywgY2FyZCB3aWxsIGhhdmUgYnkgZGVmYXVsdCBjaGVjay1tYXJrIGluIHRoZVxuICAgICAqIEFDVElPTiB6b25lIHdoZW4gc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb24gdG8gcGFzcyBjdXN0b20gXCJDYXJkIFNlbGVjdGVkXCIgSWNvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RlZEljb246IHN0cmluZyA9ICdpY29uLWFjY2VwdCc7XG5cbiAgICAvKipcbiAgICAgKiBUaGVyZSBpcyBubyBkZWZhdWx0IHZhbHVlIGZvciBhY3Rpb24gaWNvbiwgd2hlbiBhcHBsaWNhdGlvbiB3YW50IHRvIGFkZCBhY3Rpb24gdG8gdGhlIGNhcmRcbiAgICAgKiBpdCBtdXN0IGFsc28gcHJvdmlkZSBhIGljb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWN0aW9uSWNvbjogc3RyaW5nO1xuXG4gICAgLypcbiAgICAgKiBFbmFibGUgYW5kIGRpc2FibGVzIGhvdmVyIGVmZmVjdCBvbiB0b3Agb2YgdGhlIGNhcmRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhhc0hvdmVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlZmF1bHQgaWNvbiBuYW1lIGZvciB0aGUgaG92ZXIgb3ZlcmxheS4gVGhpcyBpY29ucyBzaG93cyB1cCBpbiB0aGUgbWlkZGxlIG92ZXIgdGhlIGNhcmRcbiAgICAgKiB2ZXJ0aWNhbGx5IGFuZCBob3Jpem9udGFsbHkgY2VudGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaG92ZXJJY29uOiBzdHJpbmcgPSAnaWNvbi1hZGQnO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU2VsZWN0aW9uIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGVkOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2FyZCBpcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gYWN0aW9uIGljb24gaXMgY2xpY2tlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBob3ZlciBvdmVybGF5LlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Ib3ZlckFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcXVlcnkgaXMgdXNlZCB0byBzYXZlIHRoZSBjb250ZW50IHJlZmVyZW5jZSB0byBib3R0b20gc2VjdGlvbiBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENhcmRab25lQm90dG9tQ29tcG9uZW50KVxuICAgIGJvdHRvbTogQ2FyZFpvbmVCb3R0b21Db21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGN1c3RvbSB0ZW1wbGF0ZSBmb3IgdGhlIGJvZHkgd2hpY2ggaXMgdW5kZXIgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGNvbnRyb2wuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICBAVmlld0NoaWxkKCdob3ZlckRpdicpXG4gICAgaG92ZXJEaXY6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBVc3VhbGx5IHdoZW4gdGVtcGxhdGUgaXMgcHJvdmlkZWQgd2Ugd2FudCB0byB1c2UgaXQgYW5kIHJlcGxhY2UgaW50ZXJuYWwgb25lIGJ1dCBpbiB0aGlzXG4gICAgICogY2FzZSBpdCB3aWxsIGJlIGFsd2F5cyBjb25kaXRpb25hbCBhbmQgYXBwbGljYXRpb24gZGV2ZWxvcGVyIGNhbiBzd2l0Y2ggYmV0d2VlbiBkZWZhdWx0XG4gICAgICogdGVtcGxhdGUgd2l0aCB6b25lcyBhbmQgY3VzdG9tIG9uZSBwcm92aWRlZCBieSBkZXZlbG9wZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICB1c2VCb2R5VGVtcGxhdGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIC8vIHNldHMgZGVmYXVsdCB2YWx1ZVxuICAgICAgICB0aGlzLndpZHRoID0gJzIwMnB4JztcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnMTU0cHgnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gSWYgYXBwbGljYXRpb24gd2FudHMgdG8gdXNlIGFjdGlvbiBpdCBtdXN0IHByb3ZpZGUgYWN0aW9uSWNvblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmFjdGlvbkljb24pICYmIHRoaXMuaGFzQWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHByb3ZpZGUgYWN0aW9uIGljb24nKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHVibGljIHNob3dCb3R0b21TZWN0aW9uKClcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ib3R0b20pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogZmlyZXMgc2VsZWN0IGFuZCB1bnNlbGVjdCBldmVudC5cbiAgICAgKi9cbiAgICB0b2dnbGVTZWxlY3QoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSAhdGhpcy5zZWxlY3RlZDtcbiAgICAgICAgICAgIHRoaXMub25TZWxlY3QuZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT25seSBmaXJlZCB3aGVuIGFjdGlvbiBpcyByZW5kZXJlZCBhbmQgdXNlciBjbGlja3Mgb24gY3VzdG9tIGFjdGlvbkljb25cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQWN0aW9uQ2xpY2soZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmhhc0FjdGlvbiAmJiAoIXRoaXMuc2VsZWN0ZWQgfHwgIXRoaXMuc2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMub25BY3Rpb24uZW1pdCh0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCAgd2hlbiBob3ZlciBlZmZlY3QgaXMgb24gKyB1c2VyIGNsaWNrIG9uIHRoZSBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhvdmVyKGlzRW50ZXI6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaG92ZXJEaXYpKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyRGl2Lm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IGlzRW50ZXIgPyAwLjUgOiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHRvIGRlY2lkZSBpZiB3ZSBzaG91bGQgcmVuZGVyIGltcGxpY2l0IGNhcmQgdGVtcGxhdGUgd2l0aCBvdXIgem9uZXMgb3JcbiAgICAgKiB1c2VyIHByb3ZpZGVkIHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93Qm9keVRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ib2R5VGVtcGxhdGUpICAmJiB0aGlzLnVzZUJvZHlUZW1wbGF0ZTtcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIE1hcHMgb3VyIGludGVybmFsIGFsaWdubWVudCB2YWx1ZSB0byByZWFsIGNzcyB2YWx1ZXNcbiAqXG4gKi9cbmNvbnN0IFZBbGlnbk1hcCA9IHtcbiAgICAndG9wLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1jZW50ZXInOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1yaWdodCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAnY2VudGVyLWxlZnQnOiAnY2VudGVyJyxcbiAgICAnY2VudGVyLWNlbnRlcic6ICdjZW50ZXInLFxuICAgICdjZW50ZXItcmlnaHQnOiAnY2VudGVyJyxcbiAgICAnYm90dG9tLWxlZnQnOiAnZmxleC1lbmQnLFxuICAgICdib3R0b20tY2VudGVyJzogJ2ZsZXgtZW5kJyxcbiAgICAnYm90dG9tLXJpZ2h0JzogJ2ZsZXgtZW5kJ1xufTtcblxuXG5jb25zdCBIQWxpZ25NYXAgPSB7XG4gICAgJ3RvcC1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICd0b3AtY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ3RvcC1yaWdodCc6ICdmbGV4LWVuZCcsXG4gICAgJ2NlbnRlci1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdjZW50ZXItY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2NlbnRlci1yaWdodCc6ICdmbGV4LWVuZCcsXG4gICAgJ2JvdHRvbS1sZWZ0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdib3R0b20tY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2JvdHRvbS1yaWdodCc6ICdmbGV4LWVuZCdcbn07XG5cblxuLyoqXG4gKiBUaXRsZSB6b25lIHByb3ZpZGVzIGEgY29udGVudCBwbGFjZWhvbGRlciBmb3IgdGhlIFRpdGxlIEFyZWEuIFRoaXMgem9uZSBpcyBhZGRpbmcgYWJpbGl0eVxuICogdG8gYWxpZ24gaXRzIGNvbnRlbnQgaW50byA5IGRpZmZlcmVudCBwb3NpdGlvbi5cbiAqXG4gKiBZb3UgY2FuIHVzZSB0aGlzIFRpdGxlIHpvbmUgd2l0aGluIDxhdy1jYXJkPiBhczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICA8YXctY2FyZCAgW3dpZHRoXT1cIicyMDJweCdcIiBbaGVpZ2h0XT1cIicxNTRweCdcIiBbaGFzSG92ZXJdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGFibGVdPVwiZmFsc2VcIiBbaGFzQWN0aW9uXT1cImZhbHNlXCJcbiAqICAgICAgICAgICAgICAgICAgKG9uSG92ZXJBY3Rpb24pPVwib25BY3Rpb24oNywgJGV2ZW50KVwiID5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRpdGxlIFthbGlnbl09XCInYm90dG9tLWxlZnQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImEtc3VwcGxpZXItdGFnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgIDwvYXctY2FyZC10aXRsZT5cbiAqXG4gKiAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqIERlZmF1bHQgYWxpZ25tZW50IGlzIHRvcC1sZWZ0XG4gKlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYGF3LWNhcmQtdGl0bGVgLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3ctY2FyZC10aXRsZSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhcmRab25lVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBwcm9wZXJ0eSB3aGljaCBpcyB1c2VkIHRvIGFwcGx5IGZsZXggcHJvcGVydGllcyBmb3IgYWxpZ25pbmcgY29udGVudCB2ZXJ0aWNhbGx5XG4gICAgICogYXMgd2VsbCBhcyBob3Jpem9udGFsbHlcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxpZ246IENhcmRUaXRsZUFsaWdubWVudCA9ICd0b3AtbGVmdCc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWxlbTogRWxlbWVudFJlZilcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQuc3R5bGUuYWxpZ25JdGVtcyA9IFZBbGlnbk1hcFt0aGlzLmFsaWduXTtcbiAgICAgICAgdGhpcy5lbGVtLm5hdGl2ZUVsZW1lbnQuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBIQWxpZ25NYXBbdGhpcy5hbGlnbl07XG4gICAgfVxufVxuXG5cbi8qKlxuICogTWFrZSBzdXJlIHdlIGRvbnQgYWNjZXB0IGFueSB1bnN1cHBvcnRlZCB2YWx1ZXMuIFRoZXNlIHZhbHVlcyBtYXBzIHRvIHRoZSBIQWxpZ25NYXAgYW5kXG4gKiBWQWxpZ25NYXAgaW4gb3JkZXIgdG8gZ2V0IHJlYWwgY3NzIHZhbHVlIGZvciB0aGUgZmxleCBhbGlnbm1lbnRcbiAqL1xuZXhwb3J0IHR5cGUgQ2FyZFRpdGxlQWxpZ25tZW50ID0gJ3RvcC1sZWZ0JyB8ICd0b3AtY2VudGVyJyB8ICd0b3AtcmlnaHQnIHwgJ2NlbnRlci1sZWZ0JyB8XG4gICAgJ2NlbnRlci1jZW50ZXInICB8ICdjZW50ZXItcmlnaHQnIHwgJ2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tY2VudGVyJyB8ICdib3R0b20tcmlnaHQnO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtDYXJkQ29tcG9uZW50LCBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudCwgQ2FyZFpvbmVUb3BDb21wb25lbnR9IGZyb20gJy4vY2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHtDYXJkWm9uZVRpdGxlQ29tcG9uZW50fSBmcm9tICcuL2NhcmQtdGl0bGUvY2FyZC10aXRsZS5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDYXJkQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRpdGxlQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZVRvcENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVCb3R0b21Db21wb25lbnRcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENhcmRDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVGl0bGVDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVG9wQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NhcmRNb2R1bGVcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQm9vbGVhbiwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiAgQ2hlY2tib3hUeXBlIGRlc2NyaWJlcyB3aGF0IHR5cGUgb2YgY2hlY2tib3ggaXMgdGhpczpcbiAqXG4gKiAtIEZvcm0gdHlwZTogdGhhdCBpcyB3cml0aW5nIGFuZCByZWFkaW5nIGEgdmFsdWUgZnJvbS90byBtb2RlbCBib3RoIHVzaW5nIEZvcm1Hcm91cCBhcyB3ZWxsXG4gKiAgICAgICAgICAgICAgYXMgbmdNb2RlbFxuICogLSBBY3Rpb24gdHlwZTogIG9ubHkgZmlyZXMgYWN0aW9uIGFuZCBkb2VzIG5vdCB3cml0ZSB2YWx1ZSB0byBtb2RlbC5cbiAqXG4gKlxuICovXG5leHBvcnQgdHlwZSBDaGVja2JveFR5cGUgPSAnZm9ybScgfCAnYWN0aW9uJztcblxuLyoqXG4gKlxuICogSW1wbGVtZW50cyBzdGFuZGFyZCBIVE1MIGNoZWNrYm94IG9uIHRvcCBvZiBQcmltZU5HLiBUaGVyZSBhcmUgMiB0eXBlcyBvZlxuICoge0BsaW5rIENoZWNrYm94Q29tcG9uZW50fTogZm9ybSBhbmQgYWN0aW9uIGNoZWNrYm94IGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAqXG4gKlxuICogVXNhZ2U6IEJhc2ljIGV4YW1wbGUgaGF2aW5nIHJlZCBjaGVja2JveCBjaGVja2VkXG4gKlxuICogYGBgSFRNTFxuICogICAgICAgIDxhdy1jaGVja2JveCBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgICA8L2F3LWNoZWNrYm94PlxuICogICAgICAgIDxhdy1jaGVja2JveCBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgPC9hdy1jaGVja2JveD5cbiAqXG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICpcbiAqXG4gKiAgIGNsYXNzIENCQmFzaWNXaXRoTmdNb2RlbENvbXBvbmVudFxuICogICB7XG4gKlxuICogICAgICAgbW9kZWw6IHN0cmluZ1tdID0gWydyZWQnXTtcbiAqXG4gKiAgICAgICBjb25zdHJ1Y3RvcigpXG4gKiAgICAgICB7XG4gKiAgICAgICB9XG4gKiAgIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcyBwbGVhc2Ugc2VlIGEgcGxheWdyb3VuZCBvciB1bml0IHRlc3QuXG4gKlxuICovXG5leHBvcnQgY29uc3QgQ0JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNoZWNrYm94JyxcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwidy1jaGVja2JveFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlICYmIGlzRm9ybVR5cGUoKVwiPlxuICAgICAgICA8cC1jaGVja2JveCBbbmFtZV09XCJuYW1lXCIgW3ZhbHVlXT1cInZhbHVlXCIgW2xhYmVsXT1cImxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgIFtiaW5hcnldPVwiaXNCaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LXZhbGlkYXRpb24tZXJyb3JdPVwiIShmb3JtQ29udHJvbC52YWxpZCB8fCAoZm9ybUNvbnRyb2wucHJpc3RpbmUpKVwiXG4gICAgICAgID5cbiAgICAgICAgPC9wLWNoZWNrYm94PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNGb3JtVHlwZSgpXCI+XG4gICAgICAgIDxwLWNoZWNrYm94IFtiaW5hcnldPVwiaXNCaW5hcnlcIlxuICAgICAgICAgICAgICAgICAgICBbbGFiZWxdPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgPC9wLWNoZWNrYm94PlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvc3Bhbj5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudWktY2hrYm94IC51aS1jaGtib3gtYm94e3dpZHRoOjIycHg7aGVpZ2h0OjIycHh9L2RlZXAvIC51aS1jaGtib3ggLnBpe2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojMTk5ZGUwO2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjA3ZW07bGluZS1oZWlnaHQ6MS40MmVtfS9kZWVwLyAudWktY2hrYm94IC5waS5waS1jaGVjazpiZWZvcmV7Y29udGVudDonXFxcXGUwNWInfWBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNoZWNrYm94XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogVHlwZSBvZiBjaGVja2JveC4gRm9ybSBiYXNlZCB1cGRhdGVzIG1vZGVsIGFuZCBBY3Rpb24gYmFzZWQgb25seSBmaXJlcyBjbGljayBldmVudHNcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogQ2hlY2tib3hUeXBlID0gJ2Zvcm0nO1xuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIGEgY2hlY2tib3hcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgY2xpY2sgZXZlbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogUHJpbWVORyBoYXMgdGhpcyB0eXBlIGNhbGxlZCBiaW5hcnkgd2hpY2ggd29ya3Mgb25seSB3aXRoIEJvb2xlYW4gbWVhbmluZyBpdCBkb2VzIG5vdCBhZGQgb3JcbiAgICAgKiByZW1vdmUgdmFsdWVzLlxuICAgICAqXG4gICAgICogSW4gb3VyIGNhc2UgQ2hlY2t0eXBlID0gQWN0aW9uIGlzIGFsd2F5cyBiaW5hcnkgb3Igd2hlbiB0aGlzLnZhbHVlIGlzIGJvb2xlYW5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzQmluYXJ5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbCBmb3IgY2hlY2tib3hcbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0aGlzLmFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCA/ICdhY3Rpb24nIDogdGhpcy50eXBlO1xuXG4gICAgICAgIGlmICh0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgY29udHJvbCBmcm9tIHBhcmVudFxuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB2YWx1ZSBpcyBib29sZWFuIHdlIGFyZSBkZWFsaW5nIHdpdGggUHJpbWVOZyBCaW5hcnkgY2hlY2tib3hcbiAgICAgICAgLy8gd2hpY2ggb25seSBzZXRzIFRSVUUvRkFMU0UgYW5kIGRvZXMgbm90IGFkZCBvciByZW1vdmUgdmFsdWVzXG4gICAgICAgIHRoaXMuaXNCaW5hcnkgPSBpc0Jvb2xlYW4odGhpcy52YWx1ZSk7XG5cbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ3ZhbHVlJ10pICYmXG4gICAgICAgICAgICAoY2hhbmdlc1sndmFsdWUnXS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXNbJ3ZhbHVlJ10ucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSBjaGFuZ2VzWyd2YWx1ZSddLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuXG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBDaGVja2JveCBpcyBjbGlja2VkIGFuZCBpdCBlaXRoZXIgZmlyZSBhY3Rpb24gb3IgdXBkYXRlcyB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGb3JtVHlwZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGwgaWYgd2UgYXJlIHVzaW5nIEZvcm0gQ2hlY2tib3guIFRoaXMgaXMgdXNlZCByZW1vdmUgc29tZSBvZiB0aGUgYmluZGluZ3MgdGhhdCBhcmUgbm90XG4gICAgICogYXBwbGljYWJsZSBmb3IgY2VydGFpbiB0eXBlLlxuICAgICAqXG4gICAgICovXG4gICAgaXNGb3JtVHlwZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnZm9ybSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbCAmJiB0aGlzLmlzRm9ybVR5cGUoKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q2hlY2tib3hDb21wb25lbnR9IGZyb20gJy4vY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7Q2hlY2tib3hNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2hlY2tib3hDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGVcbiAgICBdLFxuXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENoZWNrYm94Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NoZWNrQm94TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqICBDaGVja2JveCBsaXN0IGlzIGEgd3JhcHBlciBjbGFzcyBhcm91bmQgJ0NoZWNrYm94JyBjb21wb25lbnQgdG8gc2ltcGx5IGFzc2VtYmx5IG9mIG11bHRpIGNob2ljZVxuICogY29tcG9uZW50XG4gKlxuICogSW4gQWRkaXRpb24gaXQgYWRkcyBhYmlsaXR5IHRvIHdvcmsgd2l0aCBjb21wbGV4IG9iamVjdC4gUHJpbWVORyBjaGVja2JveGVzIHdvcmsgb25seSB3aXRoXG4gKiBwcmltaXRpdmUgdmFsdWVzLlxuICpcbiAqIEBzZWUge0BsaW5rIGNoZWNrLWJveC9jaGVjay1ib3guY29tcG9uZW50LnRzfVxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqXG4gKiAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgIHNlbGVjdG9yOiAnc2hvd0NoZWNrQm94TGlzdCcgLFxuICogICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICA8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJjaGVja0JveExpc3RWYWx1ZXNcIiBbc2VsZWN0aW9uc109XCJzZWxlY3RlZFZhbHVlc1wiXG4gKlxuICogICAgICAgICAgICBbbmFtZV09XCInbXlDb2xvcnMnXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiAob25TZWxlY3Rpb24pPVwib25DQkNsaWNrXCI+XG4gKiAgICAgICAgICAgPC9hdy1jaGVja2JveC1saXN0PlxuICogICAgICAgYFxuICpcbiAqICAgICAgIH0pXG4gKiAgICAgICAgY2xhc3MgTXlTaG93Q0xDb21wb25lbnRcbiAqICAgICAgICB7XG4gKiAgICAgICAgICAgIGNoZWNrQm94TGlzdFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ3JlZCcgLCAneWVsbG93JyAsICdvcmFuZ2UnICwgJ3doaXRlJyAsXG4gKiAgICAgJ3NpbHZlcicgLCAnYmxhY2snICxcbiAqICAgICAgICAgICAgJ0dyZWVuJyAsICdHcmF5JyAsICdOYXZ5JyAsICdPbGl2ZScgLCAnQXF1YScgLCAnUHVycGxlJ107XG4gKlxuICogICAgICAgICAgICBzZWxlY3RlZFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqXG4gKlxuICogICAgICAgICAgICBmb3JtR3JvdXA6IEZvcm1Hcm91cCA9IG5ldyBGb3JtR3JvdXAoe30pO1xuICpcbiAqXG4gKiAgICAgICAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdvbkNCQ2xpY2sgPSAnICsgZXZlbnQpO1xuICogICAgICAgICAgICB9XG4gKlxuICogICAgICAgIH1cbiAqKlxuICovXG5cblxuXG5cbmV4cG9ydCBjb25zdCBDQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja0JveExpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hlY2tib3gtbGlzdCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGxpc3Q7IGxldCBpID0gaW5kZXhcIiBjbGFzcz1cInVpLWdcIj5cblxuICAgIDwhLS0gaW4gdGhlIGZ1dHVyZSB3ZSBzaG91bGQgYmUgYWJsZSB0byB0byBzdXBwb3J0IGlubGluZSBhbmQgc3RhY2stLT5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMlwiPlxuICAgICAgICA8YXctY2hlY2tib3ggWyhuZ01vZGVsKV09XCJtb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImlcIlxuICAgICAgICAgICAgICAgICAgICAgW2xhYmVsXT1cImxhYmVsVmFsdWUoaXRlbSlcIj5cblxuICAgICAgICA8L2F3LWNoZWNrYm94PlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0JfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrQm94TGlzdENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja0JveExpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIHZhbHVlcyB1c2VkIHRvIHJlbmRlciBjaGVja2JveGVzLiBFdmVuIHdlIGhhdmUgaGVyZSB0eXBlIGFzIEFOWSB3ZSBpbnRlcm5hbGx5XG4gICAgICogc3VwcG9ydCBvbmx5IHN0cmluZyBhdCB0aGUgbW9tZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogIFNlbGVjdGlvbnMgYXJlIGRlZmF1bHQgQ0hFQ0tFRCB2YWx1ZXMgcGFzc2VkLiBlLmcuIFdoZW4gcmVuZGVyaW5nIGZpZWxkIGZhdm9yaXRlIGNvbG9yczpcbiAgICAgKiBibHVlLCByZWQsIHllbGxvdyB5b3Ugd2lsbCBwYXNzIGluIGhlcmUgYmx1ZSwgcmVkLCB0aGVuIGNoZWNrYm94ZXMgd2l0aCB2YWx1ZSBibHVlLCByZWQgd2lsXG4gICAgICogYmUgcmVuZGVyZWQgYXMgY2hlY2sgYW5kIHllbGxvdyB1bmNoZWNrZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbnM6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogRmlyZXMgZXZlbnQgd2hlbiBjaGVja2JveCBpcyBzZWxlY3RlZC9jbGlja2VkLiBFbWl0cyBjdXJyZW50IGNsaWNrZWQgY2hlY2tib3hlZC4gbm90IHRoZVxuICAgICAqIGFjdHVhbGwgaW50ZXJuYWwgbW9kZWwgdmFsdWUgaW4gdGhpcyBjYXNlIGFycmF5IG9mIGNob2ljZXNcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogc3BlY2lhbCBleHByZXNzaW9uIHRvIGZvcm1hdCBsYWJlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxGb3JtYXR0ZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsXG4gICAgICovXG4gICAgbW9kZWw6IGFueSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb25zKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb25zKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuc2VsZWN0aW9ucyk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5zZWxlY3Rpb25zKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQgdXBkYXRlZE1vZGVsOiBhbnlbXSA9IFtdO1xuXG4gICAgICAgIHRoaXMubW9kZWwuZm9yRWFjaCgoaW5kZXg6IG51bWJlcikgPT4gdXBkYXRlZE1vZGVsLnB1c2godGhpcy5saXN0W2luZGV4XSkpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIGlzIGV4dHJhY3RlZCBpbnRvIHRoaXMgbWV0aG9kIHNvIGluIHRoZSBmdXR1cmUgd2UgY2FuIHBsYXkgbW9yZSBob3cgd2Ugd2FudCB0byBkaXNwbGF5XG4gICAgICogdGhlIHZhbHVlLiBTaW5jZSBJIHdhbnQgdG8gc3VwcG9ydCBmb3JtYXR0ZXJzIGZvciBlYWNoIGNvbXBvbmVudHMgd2UgbWlnaHQgaGF2ZSBhIGNoYW5jZSB0b1xuICAgICAqIGRlY2lkZSBob3cgbGFiZWwgd2lsbCBsb29rIGxpa2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBsYWJlbFZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxhYmVsRm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3JtYXR0ZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgdmVyc2lvbiBvZiBjaGVja2JveGVzIHdlIHN0aWxsIGV4cGVjdCBvbmx5IHByaW1pdGl2ZSB0eXBlcy4gS2VlcCB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBpbiBleHRyYSBtZXRob2Qgc28gd2UgY2FuIHdvcmsgd2l0aCBpdCBldmVuIG5vdyB3ZSBqdXN0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrXG4gICAgICovXG4gICAgdmFsdWUoaXRlbTogYW55KTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxlZ2F0ZSBldmVudCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50IGFuZCBjb252ZXJ0IGluZGV4ZWQgbW9kZWwgdG8gb3JpZ2luYWwgb2JqZWN0c1xuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueVtdID0gW107XG5cbiAgICAgICAgdGhpcy5tb2RlbC5mb3JFYWNoKChpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB1cGRhdGVkTW9kZWwucHVzaCh0aGlzLmxpc3RbaW5kZXhdKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBtaWdodCBiZSBkZWFsaW5nIHdpdGggY29tcGxleCBvYmplY3Qgc3RvcmUgb25seSBJTkRFWGVzIG51bWJlciBpbiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbChzb3VyY2VMaXN0OiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHNvdXJjZUxpc3QuZm9yRWFjaCgoaXRlbTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmxpc3QuZmluZEluZGV4KChlbGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyhpdGVtLCBlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5wdXNoKGluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1vZGVsKSAmJiBpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgbmV3TW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWwobmV3TW9kZWwpO1xuXG4gICAgICAgICAgICAvLyB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaGVja0JveExpc3RDb21wb25lbnR9IGZyb20gJy4uL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENoZWNrQm94TGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlXG4gICAgXSxcblxuXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDaGVja0JveExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaGVja0JveExpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIEh5cGVybGluayBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuIEh5cGVybGluayBzdXBwb3J0cyBhbGwgb2YgdGhlXG4gKiBuYXRpdmUgbGluayBmdW5jdGlvbmFsaXR5LiBJbiBhZGRpdGlvbiwgaXQgc3VwcG9ydHMgbmF2aWdhdGlvbiB0byBjb21wb25lbnRzIHRocm91Z2ggdGhlIGFjdGlvblxuICogYmluZGluZy5cbiAqXG4gKlxuICogZm9yIG1vcmUgaW5mbyBwbGVhc2Ugc2VlIGNsYXNzIERvYyBvZiB0aGU6XG4gKiAgQHNlZSB7QGxpbmsgYnV0dG9uL2J1dHRvbi5jb21wb25lbnQudHN9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgICAgIDxhdy1oeXBlcmxpbmsgIFt0eXBlXT1cIid0ZXh0L2h0bWwnXCIgW25hbWVdPVwiJ2xpbmsnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNsaWNrZWQoJGV2ZW50KVwiIFt2YWx1ZV09XCJjdXN0b21lcklkXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3NpemVdPVwiJ2xhcmdlJ1wiID5teSBsaW5rPC9hdy1oeXBlcmxpbms+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGNvbW1hbmQ6Ym9vbGVhbjtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgICAgICBvbkNsaWNrZWQoY3VzdG9tZXJJZDpzdHJpbmcpIHtcbiAqICAgICAgICAgICBpZiAoY3VzdG9tZXJJZCkge1xuICogICAgICAgICAgICAgIC8vIGRpc3BsYXkgY3VzdG9tZXIgZGV0YWlscyBjb21wb25lbnQuXG4gKiAgICAgICAgICAgfVxuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1oeXBlcmxpbmsnLFxuICAgIHRlbXBsYXRlOiBgPGEgW2F0dHIudHlwZV09XCJ0eXBlXCJcbiAgIFthdHRyLmhyZWZdPVwiaHJlZlwiXG4gICBbYXR0ci5yZWxdPVwicmVsXCJcbiAgIFthdHRyLnRhcmdldF09XCJ0YXJnZXRcIlxuICAgW25nQ2xhc3NdPVwibGlua0NsYXNzXCJcbiAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAoY2xpY2spPVwiY2xpY2tlZCgkZXZlbnQpXCI+XG5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2E+XG5gLFxuICAgIHN0eWxlczogW2AubGlua3tjb2xvcjojMDI3NWQ4O2N1cnNvcjpwb2ludGVyfS5saW5rLmxpbmstYmh7Y29sb3I6IzAyNzVkOH0ubGluay5saW5rLWJoOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7Y3Vyc29yOnBvaW50ZXJ9Lmxpbmstc217Zm9udC1zaXplOi44NzVlbX0ubGluay1taWR7Zm9udC1zaXplOjFlbX0ubGluay1sZ3tmb250LXNpemU6MS4yNWVtfS5saW5rLmRpc2FibGVke3BvaW50ZXItZXZlbnRzOm5vbmU7Y3Vyc29yOmRlZmF1bHQ7Y29sb3I6I2RkZH1gXVxufSlcbmV4cG9ydCBjbGFzcyBIeXBlcmxpbmtDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiAgICBTcGVjaWZpZXMgdGhlIG1lZGlhIHR5cGUgb2YgdGhlIGxpbmtlZCBkb2N1bWVudC4gTWltZSB0eXBlXG4gICAgICogICAgZXg6IFt0ZXh0L2h0bWwgfCB0ZXh0L2NzdiB8IGltYWdlL3BuZyB8IGF1ZGlvLzNncHAgfCAuLi4uXVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogdXJsIGZvciB0aGlzIGh5cGVybGluay4gQ2FuIGJlIHVzZWQgdG8gbmF2aWdhdGUgdG8gYSBjb21wb25lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBocmVmOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiByZWwgZm9yIHRoaXMgaHlwZXJsaW5rLiBTcGVjaWZ5IHRoZSByZWxhdGlvbnNoaXAgb2YgdGhlIGN1cnJlbnQgZG9jdW1lbnQgYW5kIGxpbmtlZCBkb2N1bWVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHNpemluZyBmb3IgdGhpcyBsaW5rLiBbbGFyZ2UsIG5vcm1hbCwgc21hbGxdLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2l6ZTogTGlua1NpemUgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHRhcmdldCBvZiB0aGUgaHlwZXJsaW5rLiBbX2JsYW5rIHwgX3NlbGYgfCBfcGFyZW50IHwgX3RvcCB8IGZyYW1lbmFtZSBdXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0YXJnZXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIGJlIHNlbmQgdG8gc2VydmVyIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBDU1MgY2xhc3MgdGhhdCBzdHlsZXMgdGhpcyBoeXBlcmxpbmsgYmFzZWQgb24gaW5wdXQgJ3NpemUnXG4gICAgICovXG4gICAgbGlua0NsYXNzOiBzdHJpbmcgPSAnbGluayc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIC8vIERldGVybWluZSB0aGUgbGluayBjbGFzcyBiYXNlZCBvbiBpbnB1dCBzaXplLlxuICAgICAgICBpZiAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xhcmdlJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1sZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstbWlkJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc21hbGwnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLXNtJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBJIGhhdmUgYW4gYWN0aW9uIHRhZywgYW5kIG5vIGhyZWYuIFdlIGFkZCBkZWZhdWx0IHN0eWxpbmcgYW5kIGJlaGF2aW9yLlxuICAgICAgICBpZiAodGhpcy5hY3Rpb24ub2JzZXJ2ZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1iaCc7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBBY3Rpb24gY2xpY2tlZC4gQ2FsbCBwYXJlbnQgYWN0aW9uLlxuICAgICAqL1xuICAgIGNsaWNrZWQoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoe1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFN1cHBvcnRlZCBMaW5rIFNpemVcbiAqL1xuZXhwb3J0IHR5cGUgTGlua1NpemUgPSAnbGFyZ2UnIHwgJ25vcm1hbCcgfCAnc21hbGwnO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIeXBlcmxpbmtDb21wb25lbnR9IGZyb20gJy4vaHlwZXJsaW5rLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSHlwZXJsaW5rQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEh5cGVybGlua0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBIeXBlcmxpbmtDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdIeXBlcmxpbmtNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7dW5pbXBsZW1lbnRlZH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBTZWxlY3Rpb24gU3RhdGUgZm9yIHRoZSBjaG9vc2VyIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gY29tdW5pY2F0ZSB3aXRoIHRoZSBwYXJlbnQgb2JqZWN0IHVzaW5nIGFcbiAqIGNob29zZXIuIElmIEkgd291bGQgaGF2ZSB0byBtYW5hZ2Ugb25seSBzaW5nbGUgdmFsdWVzIHdpdGggbm8gYWRkaW9uYWwgbWV0aG9kcyBpIHdvdWxkIHVzZXJcbiAqIGVtaXR0ZXJzIHRvIGRvIHRoZSBqb2IsIGJ1dCBpbiB0aGlzIGNhc2Ugd2UgbmVlZCB0aGlzIGludGVyZmFjZSAoYWJzdHJhY3QgY2xhc3MpIGJldHdlZW4gYVxuICogY2hvb3NlciBhbmQgYWN0dWFsIG9iamVjdC5cbiAqXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG57XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXQgc2VsZWN0aW9uIHN0YXRlIGlzIHVzdWFsbHkgdHJpZ2dlcmVkIGJ5IHNlbGVjdGluZyBhbmQgdW5zZWxlY3RpbmcgYSBpdGVtIChpbiBjYXNlIG9mXG4gICAgICogbXVsdGlzZWxlY3QpIGFuZCBpdCBzaG91bGQgdXBkYXRlIGl0cyBsaXN0IG9mIG9iamVjdHMgd2l0aCBlaXRoZXIgc2V0dGluZ3MvYWRkaW5nIGl0ZW0gb3JcbiAgICAgKiByZW1vdmluZyBpdC5cbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIC4gTnVsbCBpZiBsYXN0IGFjdGlvbiB3YXMgYSBkZXNlbGVjdGlvbi4gVXN1YWxseSB1c2VkIGJ5IENob29zZXJcbiAgICAgKiBvciBDaG9vc2VyU3RhdGUgdG8gZ2V0IGN1dXJlbnQgdmFsdWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbW9zdCByZWNlbnQgc2VsZWN0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgaXRlbSBzZWxlY3Rpb24gaXRlbXMgaXMgaW4gdGhlIHNlbGVjdGVkT2JqZWN0c1xuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoc2VsZWN0aW9uOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDaG9vc2VyU2VsZWN0aW9uU3RhdGV9IGZyb20gJy4vY2hvb3Nlci1zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IHtEYXRhU291cmNlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuXG4vKipcbiAqIENob29zZXJTdGF0ZSBtYW5hZ2VzIGNvbXBsZXRlIGxpZmVjeWNsZSBmb3IgdGhlIENob29zZXIgQ29tcG9uZW50LiBJdCBrZWVwcyB0cmFjayBvZiBjdXJyZW50XG4gKiBzZWxlY3Rpb24gYXMgd2VsbCBhcyBpdCBjYW4gYnJvYWRjYXN0IGFueSB1cGRhdGVzLlxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDaG9vc2VyU3RhdGVcbntcblxuICAgIC8qKlxuICAgICAqICBDYWxsYmFjayB0byB0aGUgcGFyZW50IG9iamVjdCB0byBzdG9yZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNlbGVjdGlvblN0YXRlOiBDaG9vc2VyU2VsZWN0aW9uU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiB0b2RvOiBXZSBkbyBub3QgbmVlZGVkIHRoaXMgISFcbiAgICAgKi9cbiAgICBjdXJyZW50SXRlbTogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGluZyBwYXR0ZXJuLiBVc2VyIGxhdGVzdCBpbnB1dCB0byB0aGUgY2hvb3NlciBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIHBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogTGFzdCBzdWNjZXNzZnVsbCBwYXR0ZXJuIHRoYXQgcmV0cmlldmVkIHNvbWUgZGF0YVxuICAgICAqL1xuICAgIGxhc3RGdWxsTWF0Y2hQYXR0ZXJuOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgbWF0Y2hlZCBpdGVtcyB1c2luZyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbiAgICAgKi9cbiAgICBtYXRjaGVzOiBBcnJheTxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG11bHRpc2VsZWN0IGNob29zZXJcbiAgICAgKi9cbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBjYW4gc2V0IGxvb2t1cCBrZXkgdG8gbmFycm93IHRoZSBzZWFyY2guIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggb2JqZWN0XG4gICAgICogeW91IHNob3VsZCBzZXQgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGxvb2t1cEtleTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBwcmV2aW91cyBkaXNwbGF5IHZhbHVlIGlzIHNldCB3aGVuIHRoZSBkaXNwbGF5IHZhbHVlIGlzIHJlbmRlcmVkIG9uIHRoZSBjaG9vc2VyLiB3ZSBjYWNoZVxuICAgICAqIHRoZSBVSSB2YWx1ZSB0byBjb21wYXJlIHdpdGggdGhlIGluYm91bmQgdmFsdWUgbGF0ZXIgaW5zdGVhZCBvZiB0aGUgdmFsdWUgZnJvbSB1bmRlcmx5aW5nXG4gICAgICogb2JqZWN0IGJlY2F1c2UgYnVzaW5lc3MgbG9naWMgbGV2ZWwgY29kZSBjb3VsZCBoYXZlIGNoYW5nZWQgdGhlIHVuZGVybHlpbmcgb2JqZWN0J3MgdmFsdWVcbiAgICAgKlxuICAgICAqIHRvZG86IGRvIEkgc3RpbGwgbmVlZCB0aGlzP1xuICAgICAqL1xuICAgIHByZXZEaXNwbGF5VmFsdWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZXJlIGFyZSBhbnkgdmFsaWRhdGlvbiBsaWtlIGVudGVyZWQgdmFsdWUgZG9lcyBub3QgbXVjaCB3aXRoIHRoZSBzb3VyY2UgbGlzdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW52YWxpZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBpbmRpY2F0ZXMgdGhhdCB3ZSBzdGFydGVkIHRvIHNvbWUgZWRpdGluZyBlLmcuIHN0YXJ0aW5nIHRvIHR5cGUgaW4gc29tZXRoaW5nIGludG8gdGhlXG4gICAgICogZmlsdGVyLCBvciByZW1vdmluZyBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICovXG4gICAgYWRkTW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICByZWNlbnRTZWxlY3RlZERpc3BsYXllZDogbnVtYmVyID0gMDtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGlzIG9wdGlvbiBpcyBhY3RpdmUgd2UgZG8gbm90IHNob3cgYWxsIHNlbGVjdGVkIGl0ZW1zLCBidXQgbWF4IG51bWJlciB0aGF0IGlzXG4gICAgICogZGVmaW5lZC4gVXNlciBpcyBhYmxlIHRvIHRvZ2dsZSB0byBleHBhbmQgdGhlIHZpZXcgdG8gc2VlIGFsbCBzZWxlY3Rpb25zIGFuZCBoaWRlIHRoZW0gYXNcbiAgICAgKiB3ZWxsXG4gICAgICovXG4gICAgc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IoY2hvb3NlclNlbGVjdGlvblN0YXRlPzogQ2hvb3NlclNlbGVjdGlvblN0YXRlLCBpc011bHRpOiBib29sZWFuID0gdHJ1ZSlcbiAgICB7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZSA9IGNob29zZXJTZWxlY3Rpb25TdGF0ZTtcbiAgICAgICAgdGhpcy5tdWx0aXNlbGVjdCA9IGlzTXVsdGk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb25TdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGUgPSBuZXcgRGVmYXVsdFNlbGVjdGlvblN0YXRlKHRoaXMubXVsdGlzZWxlY3QpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEl0IHdpbGwgc2VsZWN0IGFuZCBwZXJzaXN0IGFuIGl0ZW0gdXNpbmcgQ2hvb3NlclNlbGVjdGlvblN0YXRlIHByb3ZpZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgdXBkYXRlZFNlbGVjdGVkT2JqZWN0cyhpdGVtOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhpdGVtKSkge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMuY3VycmVudEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3QgPSB0aGlzLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3RzID0gdGhpcy5zZWxlY3RlZE9iamVjdHMoKTtcblxuXG4gICAgICAgICAgICBpZiAodGhpcy5hZGRNb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc2VsZWN0ZWRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGVkT2JqZWN0LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKGl0ZW0sICFMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgoc2VsZWN0ZWRPYmplY3RzLCBpdGVtKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoc2VsZWN0ZWRPYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0ZWRPYmplY3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB1c2VyIHNlbGVjdGlvbiBpcyBsYXJnZSB3ZSB1c2UgdGhpcyBtZXRob2QgdG8gY2hlY2sgaWYgd2UgbmVlZCB0byBzaG93IGFsbCBzZWxlY3RlZFxuICAgICAqIGl0ZW1zIG9yIG9ubHkgTWF4UmVjZW50U2VsZWN0ZWRcbiAgICAgKi9cbiAgICB0b2dnbGVBbGxTZWxlY3RlZCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkID0gIXRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQ7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlbmRlcnMgdXNlcidzIHNlbGVjdGlvbiB1bmRlciB0aGUgaW5wdXQgZmllbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCByZWNlbnRTZWxlY3RlZE9iamVjdHMoKTogQXJyYXkgPGFueT5cbiAgICB7XG5cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgcmVjZW50U2VsZWN0ZWRPYmplY3RzOiBhbnlbXSA9IFtdO1xuICAgICAgICB0aGlzLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkID0gMDtcbiAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0cyA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgICAgIGxldCBzaXplID0gc2VsZWN0ZWRPYmplY3RzLmxlbmd0aDtcbiAgICAgICAgbGV0IG1heENvdW50ID0gRGF0YVNvdXJjZS5NYXhSZWNlbnRTZWxlY3RlZDtcbiAgICAgICAgaWYgKHNpemUgPiBEYXRhU291cmNlLk1heFJlY2VudFNlbGVjdGVkICYmICF0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBtYXhDb3VudCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICBtYXhDb3VudCA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gc2l6ZSAtIDE7IGkgPj0gMCAmJiAodGhpcy5yZWNlbnRTZWxlY3RlZERpc3BsYXllZCA8IG1heENvdW50KTsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gc2VsZWN0ZWRPYmplY3RzW2ldO1xuICAgICAgICAgICAgcmVjZW50U2VsZWN0ZWRPYmplY3RzLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWNlbnRTZWxlY3RlZE9iamVjdHM7XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25TdGF0ZS5zZWxlY3RlZE9iamVjdCgpO1xuICAgIH1cblxuXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblN0YXRlLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoc2VsZWN0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhdGUuc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uLCBzZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIER1bW15IGltcGxlbWVudGF0aW9uIENob29zZXJTZWxlY3Rpb25TdGF0ZVxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFNlbGVjdGlvblN0YXRlIGV4dGVuZHMgQ2hvb3NlclNlbGVjdGlvblN0YXRlXG57XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRPYmplY3Q6IGFueTtcbiAgICBwcml2YXRlIF9zZWxlY3RlZE9iamVjdHM6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtdWx0aVNlbGVjdDogYm9vbGVhbilcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE9iamVjdCA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0ICYmICFMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgodGhpcy5zZWxlY3RlZE9iamVjdHMoKSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRPYmplY3RzKCkucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KHRoaXMuc2VsZWN0ZWRPYmplY3RzKCksIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZE9iamVjdDtcbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fc2VsZWN0ZWRPYmplY3RzKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRPYmplY3RzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkT2JqZWN0cztcbiAgICB9XG5cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVNvdXJjZSwgRFNJbml0UGFyYW1zfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBEYXRhRmluZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7Q2hvb3NlclN0YXRlfSBmcm9tICcuL2Nob29zZXItc3RhdGUnO1xuaW1wb3J0IHthc3NlcnQsIGlzQXJyYXksIGlzQmxhbmssIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIENvbmNyZXRlIERhdGFTb3VyY2UgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBDaG9vc2VyIGNvbXBvbmVudC4gVGhlcmUgYXJlIHR3byB3YXlzIGhvdyB0byB1c2UgaXQ6XG4gKlxuICogMSkgWW91IGNhbiB1c2UgZGVmYXVsdCBEYXRhU291cmNlIGluamVjdGVkIGluc2lkZSBjb21wb25lbnQgY29uc3RydWN0b3IgYW5kIGp1c3QgY2FsbFxuICogaW5pdGlhbGl6ZSB0byBjb25maWd1cmUgaXQgd2l0aCBjb3JyZWN0IERhdGFQcm92aWRlciBhbmQgRGF0YUZpbmRlcjpcbiAqXG4gKlxuICogYGBgXG4gKiAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAqICAgICAgICAgICAgICAgb2JqOiB0aGlzLmxpc3QsXG4gKiAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICogICAgICAgICAgICAgICBzdGF0ZTogbnVsbCxcbiAqICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAqICAgICAgICAgICB9KTtcbiAqXG4gKiBgYGBcbiAqXG4gKiBhbmQgdGhlbiB5b3UgY2FuIHVzZSBpdCB0byBzaW1wbHkgcmV0cmlldmUgZGF0YSBvciBydW4gcXVlcmllcy5cbiAqXG4gKiAyKSBZb3Ugd2lsbCBpbnN0YW50aWF0ZSB5b3VyIG93biBEYXRhU291cmNlIGFuZCBwYXNzIGl0IGludG8gdGhlIGNvbXBvbmVudCB1c2luZyBbZGF0YVNvdXJjZV1cbiAqIGJpbmRpbmdcbiAqXG4gKiBgYGBcbiAqXG4gKiAgIHRoaXMuZHMgPSBuZXcgQ2hvb3NlckRhdGFTb3VyY2UodGhpcy5kYXRhLCB0aGlzLmZpbmRlcnMpO1xuICogICB0aGlzLmRzLmluaXQoe1xuICogICAgICAgICAgICAgICBvYmo6IHRoaXMubGlzdCxcbiAqICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gKiAgICAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICogICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICogICAgICAgICAgIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBDaG9vc2VyRGF0YVNvdXJjZSBleHRlbmRzIERhdGFTb3VyY2VcbntcblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIGRhdGFQcm92aWRlcnMgYW5kIGZpbmRlcnNcbiAgICAgKi9cbiAgICBwcml2YXRlIGRhdGFQcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT47XG4gICAgcHJpdmF0ZSBkYXRhRmluZGVyOiBEYXRhRmluZGVyO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIG9iamVjdCB0byBrZWVwIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBjaG9vc2VyXG4gICAgICovXG4gICAgc3RhdGU6IENob29zZXJTdGF0ZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGFQcm92aWRlcnM6IERhdGFQcm92aWRlcnMsIHB1YmxpYyBmaW5kZXJzOiBEYXRhRmluZGVycylcbiAgICB7XG4gICAgICAgIHN1cGVyKGRhdGFQcm92aWRlcnMsIGZpbmRlcnMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVG8gaW5pdGlhbGl6ZSB0aGlzIERhdGFTb3VyY2Ugd2l0aCBjdXJyZW50IERhdGFGaW5kZXIgYW5kIFByb3ZpZGVyIGFzIHdlbGwgYXMgc3RhdGUgd2UgdXNlXG4gICAgICogYW4gaW50ZXJmYWNlIERTQ2hvb3NlckluaXRQYXJhbXMgdG8gaGF2ZSBhbGwgaW5pdCB2YWx1ZXMgdHlwZWQgY2hlY2tlZFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoYXJncykgfHwgYXJncy5sZW5ndGggIT09IDEgJiYgIWlzRFNDaG9vc2VySW5pdFBhcmFtcyhhcmdzWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBpbml0aWFsaXplIERTIHdpdGggKERTQ2hvb3NlckluaXRQYXJhbXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXQ6IERTQ2hvb3NlckluaXRQYXJhbXMgPSBhcmdzWzBdO1xuXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YVByb3ZpZGVyKSA/IGluaXQuZGF0YVByb3ZpZGVyXG4gICAgICAgICAgICA6IHRoaXMuZGF0YVByb3ZpZGVycy5maW5kKGluaXQub2JqKTtcblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhRmluZGVyKSA/IGluaXQuZGF0YUZpbmRlclxuICAgICAgICAgICAgOiB0aGlzLmZpbmRlcnMuZmluZCh0aGlzLmRhdGFQcm92aWRlciwgaW5pdC5xdWVyeVR5cGUpO1xuXG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kYXRhUHJvdmlkZXIpICYmIGlzUHJlc2VudCh0aGlzLmRhdGFGaW5kZXIpLFxuICAgICAgICAgICAgJ0RhdGFTb3VyY2UgaW5jb3JyZWN0bHkgaW5pdGlhbGl6ZWQuIChEYXRhUHJvdmlkZXIsIERhdGFGaW5kZXIpIG1pc3NpbmcuICcpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoaW5pdC5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpbml0LnN0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBDaG9vc2VyU3RhdGUobnVsbCwgaW5pdC5tdWx0aXNlbGVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gaW5pdC5sb29rdXBLZXk7XG4gICAgICAgIHRoaXMuc3RhdGUubG9va3VwS2V5ID0gaW5pdC5sb29rdXBLZXk7XG4gICAgfVxuXG5cbiAgICBmaW5kKHBhdHRlcm46IHN0cmluZywgbWF4OiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLnN0YXRlLmxhc3RGdWxsTWF0Y2hQYXR0ZXJuID0gcGF0dGVybjtcblxuICAgICAgICBpZiAocGF0dGVybi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0dGVybiA9PT0gJyonKSB7IC8vIHF1ZXJ5IGV2ZXJ5dGhpbmdcbiAgICAgICAgICAgIHBhdHRlcm4gPSAnJztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRhdGFGaW5kZXIgaGFzIGV4cGVjdGVkIGxvb2t1cCBrZXlcbiAgICAgICAgbGV0IG9yaWdLZXkgPSB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5O1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gdGhpcy5zdGF0ZS5sb29rdXBLZXk7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5mb3JEYXRhKHRoaXMuZGF0YVByb3ZpZGVyKS5tYXRjaDxhbnk+KHBhdHRlcm4sIG1heClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlc3VsdDogYW55W10pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tYXRjaGVzID0gcmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKClbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KHRoaXMuc3RhdGUubWF0Y2hlcywgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gb3JpZ0tleTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBtdWx0aXNlbGVjdCB0aGlzIG1ldGhvZCBjaGVja3MgaWYgd2UgbmVlZCB0byBzaG93IFNIT1cgTU9SRSBsYWJlbCB1bmRlciB0aGUgc2VsZWN0ZWRcbiAgICAgKiBpdGVtcy4gV2UgZG8gbm90IHdhbnQgc2hvdyBlLmcuIDUwIHNlbGVjdGlvbiB1bmRlciB0aGUgY2hvb3NlciB0aGF0IHdvdWxkIHRha2UgdXAgd2hvbGVcbiAgICAgKiBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgc2hvd01vcmVTZWxlY3RlZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKS5sZW5ndGggPj0gRGF0YVNvdXJjZS5NYXhSZWNlbnRTZWxlY3RlZDtcbiAgICB9XG5cbiAgICBvcGVuPFQ+KCk6IE9ic2VydmFibGU8VFtdPlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaW5zdGFudDxUPigpOiBUW11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgbGV0IGl0ZW1zOiBhbnlbXSA9IHZhbHVlO1xuICAgICAgICAgICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4gdGhpcy5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUudXBkYXRlZFNlbGVjdGVkT2JqZWN0cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5hZGRNb2RlID0gZmFsc2U7XG5cbiAgICB9XG5cblxuICAgIGdldCBsb29rdXBLZXkoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleTtcbiAgICB9XG59XG5cbi8qIGlzIFwiaW5pdFwiIHR5cGUgb2YgRFNDaG9vc2VySW5pdFBhcmFtcyBpbnRlcmZhY2UgPyAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRFNDaG9vc2VySW5pdFBhcmFtcyhpbml0OiBEU0Nob29zZXJJbml0UGFyYW1zKTogaW5pdCBpcyBEU0Nob29zZXJJbml0UGFyYW1zXG57XG4gICAgcmV0dXJuIGlzUHJlc2VudChpbml0Lm9iaikgfHwgaXNQcmVzZW50KGluaXQucXVlcnlUeXBlKTtcbn1cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEU0Nob29zZXJJbml0UGFyYW1zIGV4dGVuZHMgRFNJbml0UGFyYW1zXG57XG4gICAgLyoqXG4gICAgICogQ2hvb3NlciBzdGF0ZSBrZWVwaW5nIGluZm9ybWF0aW9uIHdoYXQgaXMgY3VycmVudGx5IHNlbGVjdGVkICwgcmVzdWx0IG9mIHRoZSBsYXN0IG1hdGNoXG4gICAgICovXG4gICAgc3RhdGU/OiBDaG9vc2VyU3RhdGU7XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0F1dG9Db21wbGV0ZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0RBVEFfU09VUkNFfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtDaG9vc2VyRGF0YVNvdXJjZX0gZnJvbSAnLi9jaG9vc2VyLWRhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0Nob29zZXJTdGF0ZSwgRGVmYXVsdFNlbGVjdGlvblN0YXRlfSBmcm9tICcuL2Nob29zZXItc3RhdGUnO1xuXG5cbi8qKlxuICogVHlwZWFoZWFkIGNob29zZXIgdGhhdCBzdXBwb3J0cyBib3RoIHNpbmdsZSBhbmQgbXVsdGktc2VsZWN0LiBOb3QgbGlrZSBEcm9wZG93biwgdGhpcyBjaG9vc2VyXG4gKiByZXF1aXJlcyBsaXR0bGUgYml0IGRpZmZlcmVudCBzZXR1cC4gSXQgcmVxdWlyZXMgYXQgbWluaW11bSBASW5wdXQgZGF0YVNvdXJjZSBvclxuICogZGVzdGluYXRpb25DbGFzc1xuICpcbiAqXG4gKiBCeSBkZWZhdWx0IGNob29zZXIgaXMgbXVsdGktc2VsZWN0LiBJZiB5b3Ugd2FudCBzaW5nbGUgc2VsZWN0IHRoZW4geW91IG11c3QgcHJvdmlkZSBtdWx0aS1zZWxlY3RcbiAqIHdpdGggQElucHV0LlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogSW4gc2ltcGxlIHNjZW5hcmlvIHlvdSBjYW4gdXNlIENob29zZXIgbGlrZSBzbzpcbiAqXG4gKlxuICogYGBgXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnY2hvb3Nlci1hcHAnICxcbiAqICAgICAgdGVtcGxhdGU6IGA8YXctY2hvb3NlciAgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiBuYW1lPVwiY29sb3JcIidcbiAqICAgICAgICAgICAgICAgICAgICAgIFtkYXRhU291cmNlXT1cImRzXCI+PC9hdy1jaG9vc2VyPmBcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBNeUNob29zZXJBcHBcbiAqICB7XG4gKlxuICogICAgICBkczogQ2hvb3NlckRhdGFTb3VyY2U7XG4gKlxuICogICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0YTogRGF0YVByb3ZpZGVycywgcHJpdmF0ZSBmaW5kZXJzOiBEYXRhRmluZGVycyl7XG4gKiAgICAgICAgICB0aGlzLmRzID0gbmV3IENob29zZXJEYXRhU291cmNlKHRoaXMuZGF0YSwgdGhpcy5maW5kZXJzKTtcbiAqXG4gKiAgICAgICB0aGlzLmRzLmluaXQoe1xuICogICAgICAgICAgIG9iajogWydibHVlJywgJ3JlZCcsICd5ZWxsb3cnXSwgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsIHN0YXRlOiBudWxsLFxuICogICAgICAgICAgICBtdWx0aXNlbGVjdDogdHJ1ZVxuICogICAgICAgfSk7XG4gKlxuICogICAgIH1cbiAqICB9XG4gKlxuICogYGBgYFxuICogIEFib3ZlIGV4YW1wbGUgd2lsbCB1c2UgcHJvdmlkZWQgZGF0YVNvdXJjZSBhbmQgcmVuZGVyIG11bHRpLXNlbGVjdCBjaG9vc2VyLiBXaXRoIGRlZmF1bHRcbiAqICBpbXBsZW1lbnRhdGlvbiAgc2VsZWN0ZWQgdmFsdWVzIHdpbGwgYXBwZWFyIGFzIGEgdGFncyB1bmRlciB0aGUgaW5wdXQgYm94XG4gKlxuICpcbiAqXG4gKiAqICMjIyBFeGFtcGxlXG4gKlxuICogIEluIHRoaXMgZXhhbXBsZSB3ZSBwcm92aWRlIGN1c3RvbSB0ZW1wbGF0ZSB0byBjaGFuZ2UgdGhlIHdheSBob3cgY2hvb3NlcidzIE1lbnVJdGVtIGFyZVxuICogICAgIHJlbmRlcmVkIGFzIHdlbGwgYXMgdGVtcGxhdGUgZm9yIHRoZSBzZWxlY3Rpb24gaXRlbSBsb29rcyBsaWtlXG4gKlxuICogYGBgXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnY2hvb3Nlci1hcHAnICxcbiAqICAgICAgdGVtcGxhdGU6IGA8YXctY2hvb3NlciAgbmFtZT1cImNvbW1vZGl0eVwiJyBbZGF0YVNvdXJjZV09XCJkc1wiPlxuICpcbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjbWVudUl0ZW0gbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICBcdDxzcGFuPlxuICogICAgICAgICAgICAgXHRcdDxpIGNsYXNzPVwiZmEgZmEtZW52aXJhIFwiID48L2k+XG4gKiAgICAgICAgICAgICBcdFx0e3tpdGVtfX1cbiAqICAgICAgICAgICAgIFx0PC9zcGFuPlxuICpcbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlICNzZWxlY3Rpb25JdGVtIGxldC1pdGVtPlxuICogICAgICAgICAgICAgXHQ8c3BhbiBjbGFzcz1cInRhZyB0YWctY2lyY2xlXCI+XG4gKiAgICAgICAgICAgICBcdFx0aXRlbToge3tpdGVtIH19XG4gKiAgICAgICAgICAgICBcdFx0PGkgY2xhc3M9XCJmYSBmYS1jbG9zZVwiIChjbGljayk9XCJjaG9vc2VyLnJlbW92ZVZhbHVlKGl0ZW0pXCI+PC9pPlxuICogICAgICAgICAgICAgXHQ8L3NwYW4+XG4gKlxuICpcbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgIDwvYXctY2hvb3Nlcj5cbiAqICAgICAgYFxuICogICAgICBzdHlsZTogW2BcbiAqICAgICAgICAgICAgICAudGFnLWNpcmNsZSB7XG4gKiAgICAgICAgICAgICAgXHRib3JkZXItcmFkaXVzOiA2cmVtO1xuICogICAgICAgICAgICAgIFx0aGVpZ2h0OiA3cmVtO1xuICogICAgICAgICAgICAgIFx0Y29sb3I6ICNlOGVlZjE7XG4gKiAgICAgICAgICAgICAgXHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDUzLCA1NiwgNTgsIDAuNjcpO1xuICogICAgICAgICAgICAgIFx0bGluZS1oZWlnaHQ6IDZyZW07XG4gKiAgICAgICAgICAgICAgfVxuICogICAgICBgXVxuICogIH0pXG4gKlxuICogYGBgYFxuICpcbiAqICBJbiBhYm92ZSBleGFtcGxlIHdlIGNoYW5nZSBob3cgdGhlIGNob29zZXIncyBtZW51IGl0ZW0gbG9vayBsaWtlIGFzIHdlbGwgYXMgd2UgZGVmaW5lIGN1c3RvbVxuICogICAgIHRlbXBsYXRlIGZvciBzZWxlY3Rpb24gaXRlbSB0byB0dXJuIGFsbCBzZWxlY3Rpb24gdG8gY2lyY2xlcyB3aXRoIHRleHQgaW4gdGhlIG1pZGRsZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5leHBvcnQgY29uc3QgQ0hPT1NFUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hvb3NlckNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jaG9vc2VyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LWNob29zZXIgXCI+XG5cbiAgICA8cC1hdXRvQ29tcGxldGUgI2F1dG9Db21wcGxldGUgWyhuZ01vZGVsKV09XCJpbnRlcm5hbENob29zZXJNb2RlbFwiXG4gICAgICAgICAgICAgICAgICAgIFtzdWdnZXN0aW9uc109XCJkYXRhU291cmNlLnN0YXRlLm1hdGNoZXNcIlxuICAgICAgICAgICAgICAgICAgICBbbXVsdGlwbGVdPVwiZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgIFtkcm9wZG93bl09XCIhZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdFwiXG4gICAgICAgICAgICAgICAgICAgIFttaW5MZW5ndGhdPVwibWluTGVuRm9yU2VhcmNoXCJcbiAgICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCJcbiAgICAgICAgICAgICAgICAgICAgW2RlbGF5XT1cImRlbGF5XCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uRHJvcGRvd25DbGljayk9XCJvbkRyb3Bkb3duQ2xpY2soJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChjb21wbGV0ZU1ldGhvZCk9XCJtYXRjaCgkZXZlbnQucXVlcnkpXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0KT1cInNlbGVjdEl0ZW0oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIChvblVuc2VsZWN0KT1cInJlbW92ZVZhbHVlKCRldmVudClcIj5cblxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBsZXQtaW50ZXJuYWxDaG9vc2VyTW9kZWwgcFRlbXBsYXRlPVwiaXRlbVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNNZW51VGVtcGxhdGUoKVwiPlxuICAgICAgICAgICAgICAgIHt7IGRpc3BsYXlJdGVtKGludGVybmFsQ2hvb3Nlck1vZGVsKSB9fVxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cIm1lbnVUZW1wbGF0ZVwiIFtpdGVtXT1cImludGVybmFsQ2hvb3Nlck1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc01lbnVUZW1wbGF0ZSgpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3AtYXV0b0NvbXBsZXRlPlxuXG4gICAgPCEtLVxuICAgICAgICBXcmFwIHdob2xlIHNlbGVjdGlvbiB3aXRoIG9uZSBleHRyYSBlbGVtZW50IHNvIHdlIGNhbiBtb3ZlIGl0IGFyb3VuZFxuXG4gICAgICAgICBzZWU6IHNlbGVjdGlvbkFwcGVuZFRvXG4gICAgLS0+XG4gICAgPHNwYW4gI3NlbGVjdGlvblZpZXc+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3LWNob29zZXItc2VsZWN0aW9uc1wiXG4gICAgICAgICAgICAgKm5nSWY9XCJtdWx0aXNlbGVjdCAmJiBkYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkT2JqZWN0cy5sZW5ndGggPiAwXCI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNTZWxlY3Rpb25UZW1wbGF0ZSgpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gbm8gc2VsZWN0aW9uIHRlbXBsYXRlIHJlbmRlciBpdCBhcyBpdCBpcyBmcm9tIENPUkUtLT5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXIgdWktd2lkZ2V0IHVpLXN0YXRlLWRlZmF1bHQgXCJcbiAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7J3VpLXN0YXRlLWRpc2FibGVkJzpkaXNhYmxlZCwndWktc3RhdGUtZm9jdXMnOmF1dG9Db21wbGV0ZUNvbXBvbmVudC5mb2N1c31cIj5cblxuICAgICAgICAgICAgICAgIDxsaSAjdG9rZW4gKm5nRm9yPVwibGV0IGl0ZW0gb2YgZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZE9iamVjdHNcIlxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS10b2tlbiB1aS1zdGF0ZS1oaWdobGlnaHQgdWktY29ybmVyLWFsbFwiIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgICAgIChrZXl1cC5kZWxldGUpPVwicmVtb3ZlVmFsdWUoaXRlbSlcIlxuICAgICAgICAgICAgICAgICAgICAoa2V5dXAuYmFja3NwYWNlKT1cInJlbW92ZVZhbHVlKGl0ZW0pXCI+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJ1aS1hdXRvY29tcGxldGUtdG9rZW4taWNvbiBzYXAtaWNvbiBpY29uLWRlY2xpbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwicmVtb3ZlVmFsdWUoaXRlbSlcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidWktYXV0b2NvbXBsZXRlLXRva2VuLWxhYmVsXCI+e3sgZGlzcGxheUl0ZW0oaXRlbSkgfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwhLS1ZZXMgdGhlcmUgaXMgc2VsZWN0aW9uIHRlbXBsYXRlIGxldCdzIGl0ZXJhdGUgYW5kIHB1c2ggZWFjaCBpdGVtIHRvIGJlIHJlbmRlcmVkLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBbbmdGb3JPZl09XCJkYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkT2JqZWN0c1wiIGxldC1pdGVtPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwic2VsZWN0aW9uVGVtcGxhdGVcIiBbaXRlbV09XCJpdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc1NlbGVjdGlvblRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJkYXRhU291cmNlLnNob3dNb3JlU2VsZWN0ZWQoKVwiPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJtb3JlLXNlbGVjdGVkXCI+XG5cdFx0XHRcdDxhdy1oeXBlcmxpbmsgW3NpemVdPVwiJ3NtYWxsJ1wiIChhY3Rpb24pPVwiZGF0YVNvdXJjZS5zdGF0ZS50b2dnbGVBbGxTZWxlY3RlZCgpXCI+XG5cdFx0XHRcdFx0e3ttb3JlU2VsZWN0U3RyaW5nKCl9fVxuXHRcdFx0XHQ8L2F3LWh5cGVybGluaz5cblx0XHRcdDwvc3Bhbj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgICA8L3NwYW4+XG5cblxuPC9kaXY+XG5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudWktZmx1aWQgLnVpLWF1dG9jb21wbGV0ZS51aS1hdXRvY29tcGxldGUtZGQgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dCwvZGVlcC8gLnVpLWZsdWlkIC51aS1hdXRvY29tcGxldGUudWktYXV0b2NvbXBsZXRlLWRkIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVye3dpZHRoOjEwMCV9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZXtsaW5lLWhlaWdodDpub3JtYWx9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dHt3aWR0aDoxMDAlfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd24udWktYnV0dG9ue3JpZ2h0OjA7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyOjA7d2lkdGg6MzBweDtiYWNrZ3JvdW5kOjAgMH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3duLnVpLWJ1dHRvbiAucGl7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2NvbG9yOiM3Njc2NzY7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuNGVtO21hcmdpbi1sZWZ0Oi0uODVlbX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3duLnVpLWJ1dHRvbiAucGktY2FyZXQtZG93bjpiZWZvcmV7Y29udGVudDonXFxcXGUxZWYnfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd24udWktYnV0dG9uIGlucHV0e3BhZGRpbmctcmlnaHQ6MzBweH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2Vue3BhZGRpbmc6MDttYXJnaW46MDt2ZXJ0aWNhbC1hbGlnbjpiYXNlbGluZTt3aWR0aDppbmhlcml0fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4gLmZhe2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojNzY3Njc2O2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjJlbX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuIC5mYS1zZWFyY2g6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMDBkJ30vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuIGlucHV0e3dpZHRoOmluaGVyaXQ7cGFkZGluZy1yaWdodDoyNXB4fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4gc3Bhbntwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDo1cHg7dG9wOjA7cGFkZGluZy10b3A6LjZlbX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWRyb3Bkb3due2hlaWdodDozNnB4fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtcGFuZWwgLnVpLWF1dG9jb21wbGV0ZS1saXN0LWl0ZW17cGFkZGluZzouNjVlbSAyZW0gLjY1ZW0gLjY0ZW07bWFyZ2luOjB9L2RlZXAvIGJvZHkgLnVpLWF1dG9jb21wbGV0ZS51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXJ7cGFkZGluZzouNGVtIC41ZW0gLjRlbSAxZW19LnctY2hvb3Nlci1zZWxlY3Rpb25ze21hcmdpbi10b3A6MnB4fS53LWNob29zZXItc2VsZWN0aW9ucyB1bHttYXJnaW46MDtwYWRkaW5nOjB9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVye2JvcmRlcjowfS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciAudWktYXV0b2NvbXBsZXRlLXRva2Vue2ZvbnQtc2l6ZTouODVlbTtsZXR0ZXItc3BhY2luZzouMXB4O2ZvbnQtd2VpZ2h0OjQwMDtwYWRkaW5nOjA7YmFja2dyb3VuZDojZTBmMmZmO21hcmdpbi1yaWdodDo1cHg7bWFyZ2luLWJvdHRvbTo1cHh9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIC51aS1hdXRvY29tcGxldGUtdG9rZW4tbGFiZWx7cGFkZGluZzo0cHggMjFweCA0cHggNXB4fS53LWNob29zZXItc2VsZWN0aW9ucyAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciAudWktYXV0b2NvbXBsZXRlLXRva2VuLWljb257Zm9udC1zaXplOi43OGVtO3BhZGRpbmctcmlnaHQ6LjI4ZW19LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIC5zYXAtaWNvbntsaW5lLWhlaWdodDppbmhlcml0fS53LWNob29zZXItc2VsZWN0aW9ucyAubW9yZS1zZWxlY3RlZHtkaXNwbGF5OmlubGluZS1ibG9ja31gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0hPT1NFUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENob29zZXJDb21wb25lbnQpfSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogQ2hvb3NlckRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119XG4gICAgXVxuXG5cbn0pXG5leHBvcnQgY2xhc3MgQ2hvb3NlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0IHtcblxuICAgIC8qKlxuICAgICAqIE1heCBudW1iZXIgb2YgaXRlbXMgcmV0dXJuIGF0IHNpbmdsZSBNYXRjaCBzbyB3ZSBkbyBub3QgcmV0dXJuIDEwMDAgaXRlbXMgYXQgc2luZ2xlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heExlbmd0aDogbnVtYmVyID0gMTA7XG5cblxuICAgIC8qKlxuICAgICAqIE1heCBudW1iZXIgb2YgaXRlbXMgcmV0dXJuIGF0IHNpbmdsZSBNYXRjaCBzbyB3ZSBkbyBub3QgcmV0dXJuIDEwMDAgaXRlbXMgYXQgc2luZ2xlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbkxlbkZvclNlYXJjaDogbnVtYmVyID0gMTtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHVzZWQgdG8gZm9ybWF0IGVhY2ggc2VsZWN0aW9uIGFuZCBzZWxlY3RlZCBvYmplY3QgZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlVHJhbnNmb3JtZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGlzIG11bHRpc2VsZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG11bHRpc2VsZWN0OiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCBDaG9vc2VyRGF0YVNvdXJjZSB3aWxsIGJlIGNyZWF0ZWQgYnV0IHRoZXJlIGlzIGEgb3B0aW9uIHRvIHNldFxuICAgICAqIGN1c3RvbSBvbmUgb24gYXBwbGljYXRpb24gbGV2ZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRhdGFTb3VyY2U6IENob29zZXJEYXRhU291cmNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIHdhbnQgdG8gY2hhbmdlIHRoZSBwbGFjZSB3aGVyZSBzZWxlY3Rpb24gaXMgcmVuZGVyZWQgdXNlIHRoaXMgYXBwZW5kVG8gcHJvcGVydHlcbiAgICAgKiBhbmQgaXQgd2lsbCB1c2UgRE9NIG9wZXJhdGlvbiBhcHBlbmRDaGlsZCgpIHRvIG1vdmUgc2VsZWN0aW9uVmlldyB1bmRlciBkaWZmZXJlbnQgcGFyZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25BcHBlbmRUbzogRWxlbWVudFJlZjtcblxuXG4gICAgQElucHV0KClcbiAgICBkZWxheTogbnVtYmVyID0gMzAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgdHlwZSB0byByZW5kZXIuIERhdGEgd2lsbCBiZSByZWFkIGZyb20gdGhlIHJlZ2lzdGVyZWQgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgZmllbGQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIG1vZGVsIHRvIGxpc3RlbiBmb3IgSW5wdXQgdmFsdWUgY2hhbmdlc1xuICAgICAqL1xuICAgIGludGVybmFsQ2hvb3Nlck1vZGVsOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIEVtYmVkZGVkIHRlbXBsYXRlIGRlZmluZWQgYnkgdXNlci4gSWYgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFueSB0ZW1wbGF0ZSB0aGVuIHdoZW4gcmVuZGVyaW5nXG4gICAgICogYW4gaXRlbSB3ZSBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBwcmltaXRpdmUgdHlwZXMgYW5kIGNhbGwgb24gZWFjaCBpdGVtIHRvU3RyaW5nKCksIGlmXG4gICAgICogd2UgYXJlIGRlYWxpbmcgd2l0aCBvYmplY3QsIHRoZW4gd2UgZXhwZWN0IHVzZXIgdG8gcHJvdmlkZSBhIHRlbXBsYXRlIGFuZCB0ZWxsIHRoZSBjaG9vc2VyXG4gICAgICogaG93IGl0ZW1zIHNob3VsZHMgYmUgaGFuZGxlZCBvciBhdCBsZWFzdCB2YWx1ZVRyYW5zZm9ybWVyIHNvIHdlIGtub3cgaG93IHRvIGNvbnZlcnQgdGhpc1xuICAgICAqIHZhbHVlLlxuICAgICAqXG4gICAgICogRWFjaCBvYmplY3QgY2FuIHByb3ZpZGUgaXRzIG93biB0b1N0cmluZyBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ21lbnVJdGVtJylcbiAgICBtZW51VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBDb250ZW50Q2hpbGQoJ3NlbGVjdGlvbkl0ZW0nKVxuICAgIHNlbGVjdGlvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZCgnYXV0b0NvbXBwbGV0ZScpXG4gICAgYXV0b0NvbXBsZXRlQ29tcG9uZW50OiBBdXRvQ29tcGxldGU7XG5cbiAgICBAVmlld0NoaWxkKCdzZWxlY3Rpb25WaWV3JylcbiAgICBzZWxlY3Rpb25WaWV3RWxlbTogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgc2VsZWN0aW9uIGlzID4gbWF4IHNlbGVjdGlvbiwgdGhlbiBzaG93IGhpZGUgbGluay5cbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVMaW5rOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHJpdmF0ZSBlbGVtZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHJpdmF0ZSBfZGVmYXVsdERTOiBDaG9vc2VyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnBsYWNlSG9sZGVyKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5wbGFjZUhvbGRlciA9IGkxOG4uaW5zdGFudCgnV2lkZ2V0cy5jaG9vc2VyLnBsYWNlSG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnBsYWNlSG9sZGVyID0gJ1NlYXJjaCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcy5oaWRlTGluayA9IGkxOG4uaW5zdGFudCgnV2lkZ2V0cy5jaG9vc2VyLmhpZGVTZWxlY3Rpb24nKTtcbiAgICAgICAgdGhpcy5oaWRlTGluayA9ICdIaWRlJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRhdGFTb3VyY2UpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuX2RlZmF1bHREUztcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbCkgJiYgaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UudXBkYXRlVmFsdWUodGhpcy5mb3JtQ29udHJvbC52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRJbnRlcm5hbE1vZGVsKCk7XG5cblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIFNlYXJjaCBpY29uIGluIGNhc2Ugb2YgbXVsdGlzZWxlY3QuXG4gICAgICogdG9kbzogT25jZSBQcmltZU5HIHdpbGwgcHJvdmlkZSBhIHRlbXBsYXRlIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IgcmVtb3ZlIGl0XG4gICAgICpcbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoSW5wdXQgPSB0aGlzLmVsZW1lbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICAnLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbicpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoc2VhcmNoSW5wdXQpKSB7XG4gICAgICAgICAgICBsZXQgaWNvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBpY29uRWxlbWVudC5jbGFzc05hbWUgPSAnc2VhcmNoLWljb24tcmlnaHQgZmEgZmEtZncgZmEtc2VhcmNoJztcbiAgICAgICAgICAgIHNlYXJjaElucHV0LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25BcHBlbmRUbykgJiYgaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uVmlld0VsZW0pKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50RWxlbSA9IHRoaXMuc2VsZWN0aW9uQXBwZW5kVG8gaW5zdGFuY2VvZiBFbGVtZW50UmVmID9cbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLnNlbGVjdGlvbkFwcGVuZFRvO1xuXG4gICAgICAgICAgICBwYXJlbnRFbGVtLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0aW9uVmlld0VsZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIGNoYW5nZSBjdXJyZW50IGJlaGF2aW9yIHNpbmNlIHdlIHdhbnQgdG8gc2hvdyBzZWxlY3Rpb24gdW5kZXIgdGhlIGNob29zZXIuIEtcbiAgICAgKlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b2tlbnMgPSB0aGlzLmVsZW1lbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICAnLnVpLWF1dG9jb21wbGV0ZSAudWktYXV0b2NvbXBsZXRlLXRva2VuJyk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodG9rZW5zKSAmJiB0b2tlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9rZW5zLmZvckVhY2goKGl0ZW06IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0ucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiB2YWx1ZSBpcyBlbnRlcmVkIGludG8gc2VhcmNoIGJveCwgd2UgYXNrIG91ciBEYXRhU291cmNlIHRvIG1hdGNoIHRoaXMgcGF0dGVyblxuICAgICAqIGFnYWluc3QgZGF0YSByZXBvc2l0b3J5LiBJdCB3aWxsIHJldHJpZXZlIGFsbCBwb3NzaWJsZSBtYXRjaGVzIGxpbWl0ZWQgYnkgTWF4TGVuIGFuZCB0aGlzXG4gICAgICogaXMgYWdhaW4gZmlsdGVyZWQgc28gaXQgZG9lcyBub3QgaW5jbHVkZSBhbHJlYWR5IHNlbGVjdGVkIGl0ZW1zLlxuICAgICAqXG4gICAgICogIHRoZSBtYXRjaGVkIHJlc3VsdGVkIGlzIHNhdmVkIGluIHRoZTogdGhpcy5kYXRhU291cmNlLnN0YXRlLm1hdGNoZXNcbiAgICAgKi9cbiAgICBtYXRjaChwYXR0ZXJuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbGV0IG1heExlbiA9IHRoaXMubWF4TGVuZ3RoID8gdGhpcy5tYXhMZW5ndGggOiBDaG9vc2VyRGF0YVNvdXJjZS5NYXhMZW5ndGg7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5maW5kKHBhdHRlcm4sIG1heExlbik7XG5cblxuICAgICAgICAvLyBmaXg6IGZvciB0ZXN0czogSW4gdmVyc2lvbiA0IHdlIG5lZWQgdG8gZXhwbGljaXRseSBmb2N1cyBpbnB1dCBvdGhlcndpc2UgYXV0b2NvbXBsZXRlXG4gICAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBhbnkgcG9wdXAgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMuZW52LmluVGVzdCAmJiBpc1ByZXNlbnQodGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudC5mb2N1c0lucHV0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW52b2tlZCBieSBEcm9wZG93biBidXR0b24gaW4gY2FzZSBvZiBzaW5nbGUgc2VsZWN0IGFuZCBoZXJlIHdlIHdhbnQgdG8gaW52b2tlIG1hdGNoXG4gICAgICogdG8gcmV0cmlldmUgYWxsIHN1Z2dlc3Rpb25zIHdpdGhvdXQgYW55IGZpbHRlclxuICAgICAqXG4gICAgICovXG4gICAgb25Ecm9wZG93bkNsaWNrKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tYXRjaCgnKicpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF0Y2goJyonKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENob29zZXIgc3RhdGUgaXMgdXBkYXRlZCAgd2l0aCB1c2VyIHNlbGVjdGlvbi4gUGxlYXNlIHNlZSB3cml0ZVZhbHVlLiBXaGVuIGRvIG5vdCBuZWVkXG4gICAgICogY2FsbCBhbnl0aGluZyBhZGRpdGlvbmFsIGFzIGludGVybmFsQ2hvb3Nlck1vZGVsIGFuZCB0aGlzLmNob29zZXJTdGF0ZS5zZWxlY3RlZE9iamVjdHMoKVxuICAgICAqIHNoYXJlcyB0aGUgc2FtZSByZWZlcmVuY2VzIHNvIGl0cyBpbXBvcnRhbnQgdGhhdCB3ZSBmaXJzdCBzYXZlIHJlZmVyZW5jZSB0b1xuICAgICAqIHRoaXMuY2hvb3NlclN0YXRlLnNlbGVjdGVkT2JqZWN0cygpIGFuZCB0aGVuIGJhY2sgdG8gaW50ZXJuYWxDaG9vc2VyTW9kZWxcbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdEl0ZW0oaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoe29ubHlTZWxmOiB0cnVlfSk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQuaW5wdXRFTC5uYXRpdmVFbGVtZW50LnZhbHVlID1cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlJdGVtKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVuc2VsZWN0IGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZVZhbHVlKGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW0pO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCk7XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuXG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50LmZvY3VzSW5wdXQoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDb252ZXJ0IGEgb2JqZWN0IGlmIGFueSBpbnRvIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgKlxuICAgICAqIHRvZG86IGltcGxlbWVudCBiZXR0ZXIgd2F5IGhvdyB0byB3b3JrIHdpdGggb2JqZWN0c1xuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheUl0ZW0oaXRlbTogYW55KSB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuY3VycmVudEl0ZW0gPSBpdGVtO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52YWx1ZVRyYW5zZm9ybWVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVUcmFuc2Zvcm1lcihpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UubG9va3VwS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW1bdGhpcy5kYXRhU291cmNlLmxvb2t1cEtleV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBsYWJlbCB0aGF0IGlzIHNob3duIHVuZGVyIHRoZSBzZWxlY3RlZCBpdGVtIHdoZW4gdXNlciBzZWxlY3Rpb24gaXMgPlxuICAgICAqIE1heFJlY2VudFNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBtb3JlU2VsZWN0U3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIGxldCBtb3JlU2VsZWN0ZWQgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoIC1cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5yZWNlbnRTZWxlY3RlZERpc3BsYXllZDtcbiAgICAgICAgaWYgKG1vcmVTZWxlY3RlZCA8IDIgJiYgIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zaG93QWxsUmVjZW50bHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZUxpbms7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vcmVTZWxlY3RlZH0gbW9yZSBzZWxlY3RlZC4uLmA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIG9mIG11bHRpc2VsZWN0ID0gZmFsc2UgY2hlY2sgaWYgd2Ugd2FudCB0byBzaG93IGEgc2VsZWN0ZWQgdmFsdWUgaW5zaWRlIHRoZSBpbnB1dFxuICAgICAqIGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBzaW5nbGVWYWx1ZVNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlLnN0YXRlLmN1cnJlbnRJdGVtKVxuICAgICAgICAgICAgJiYgIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlO1xuICAgIH1cblxuICAgIGhhc01lbnVUZW1wbGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1lbnVUZW1wbGF0ZSk7XG4gICAgfVxuXG5cbiAgICBoYXNTZWxlY3Rpb25UZW1wbGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvblRlbXBsYXRlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICogQXMgd2UgYXJlIHVzaW5nIERhdGFTb3VyY2UgaW50ZXJuYWxseSBmb3IgWyhuZ01vZGVsKV0gY2FzZSB3ZSBuZWVkIHRvIGRlZmZlciBEYXRhU291cmNlXG4gICAgICogaW5pdGlhbGl6YXRpb24gb25jZSB3ZSBoYXZlIGEgdmFsdWUgYW5kIHdlIG9ubHkgYWNjZXB0IFtdXG4gICAgICpcbiAgICAgKlxuICAgICAqID8gU2hvdWxkIHdlIGRvIHNvbWUgZGVlcGVyIGNvbXBhcmlzaW9uP1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAoaXNCbGFuayh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kYXRhU291cmNlKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxTdGF0ZTogRGVmYXVsdFNlbGVjdGlvblN0YXRlID0gbmV3IERlZmF1bHRTZWxlY3Rpb25TdGF0ZSh0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgICAgIGxldCBjaFN0YXRlOiBDaG9vc2VyU3RhdGUgPSBuZXcgQ2hvb3NlclN0YXRlKHNlbFN0YXRlLCB0aGlzLm11bHRpc2VsZWN0KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoY2hTdGF0ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS51cGRhdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRJbnRlcm5hbE1vZGVsKCk7XG4gICAgfVxuXG4gICAgaW5pdERhdGFzb3VyY2UoY2hvb3NlclN0YXRlPzogQ2hvb3NlclN0YXRlKTogdm9pZCB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSxcbiAgICAgICAgICAgICdZb3UgbmVlZCB0byBwcm92aWRlIGRlc3RpbmF0aW9uQ2xhc3Mgb3IgY3VzdG9tIERhdGFTb3VyY2UnKTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICBvYmo6IHRoaXMuZGVzdGluYXRpb25DbGFzcyxcbiAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICAgICAgICAgICAgbG9va3VwS2V5OiB0aGlzLmZpZWxkLFxuICAgICAgICAgICAgc3RhdGU6IGNob29zZXJTdGF0ZSxcbiAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSBuZ09uSW5pdCBhbmQgV3JpdGUgdmFsdWUgdG8gcmVhZCBzdGF0ZSBmcm9tIENob29zZXJTdGF0ZSBhbmQgc2V0IGl0IHRvIGludGVybmFsXG4gICAgICogbmdNb2RlbCBwcm9wZXJ0eVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0SW50ZXJuYWxNb2RlbCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwgPSB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZm9ybUNvbnRyb2wpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaG9vc2VyQ29tcG9uZW50fSBmcm9tICcuL2Nob29zZXIuY29tcG9uZW50JztcbmltcG9ydCB7QXV0b0NvbXBsZXRlTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi4vaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBBV0h5cGVybGlua01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG5cbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2hvb3Nlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtTZWxlY3RJdGVtfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuXG4vKipcbiAqIEEgcG9wdXAgbGlrZSBjb21wb25lbnQgcmVuZGVyaW5nIGxpc3Qgb2YgdmFsdWVzIGFzLiBCYXNlZCBvbiBQcmltZU5HIGNvbXBvbmVudCBhbmQgb25lIG9mIHRoZVxuICogbWFpbiByZWFzb24gd2h5IHdlIG5lZWQgdG8gd3JhcCB0aGlzIGlzIHRvIGV4dGVuZCBpdHMgY2FwYWJpbGl0aWVzIHRvIGFjY2VwdCBhbG1vc3QgYW55XG4gKiBkYXRhIHR5cGUgd2l0aG91dCB1c2luZyBQcmltZW5zJ3Mgc3BlY2lmaWMgU2VsZWN0SXRlbSB0eXBlLlxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3Nob3dEcm9wRG93bicgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1kcm9wZG93biBbbGlzdF09XCJ0ZXN0SXRlbVNtYWxsXCJcbiAqICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPjwvYXctZHJvcGRvd24+J1xuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIE15RHJvcENvbXBvbmVudFxuICogIHtcbiAqICAgICAgdGVzdEl0ZW1TbWFsbDogc3RyaW5nW10gPSBbJ3ZpZXcnICwgJ2VkaXQnXTtcbiAqXG4gKiAgICAgIC8vIHdoZW4geW91IHN3aXRjaCBsaXN0IGJpbmRpbmcgdG8gcmVmZXJ0IHRvIGxhcmdlIGl0ZW0gZmlpbHRlciBhdXRvbWF0aWNhbGx5IGlzIHNob3duIGFuZFxuICogICAgIG1heCAxMCBpdGVtcyBhcmVcbiAqICAgICAgLy8gdmlzaWJsZVxuICogICAgICB0ZXN0SXRlbUxhcmdlOiBzdHJpbmdbXSA9IFsndmlldycgLCAnZWRpdCcgLCAnZnJhbmsnICwgJ2tvbGFyJyAsICdUaGUgU3VuJyAsICdEb2cnICxcbiAqICAgICAnQ29tcHV0ZXInICwgJ0EgRGVzaycgLFxuICogICAgICAnTXkgQ2FyJyAsICdQZW5jaWwnICwgJ1RoaXMgUGFnZScgLCAnWWVzdGVyZGF5JyAsICdNb25kYXknICwgJ1R1ZXNkYXknICwgJ0JNVyBSMTIwMCBHUycgLFxuICogICAgICdDemVjaCBSZXB1YmxpYycgLFxuICogICAgICAnTGFzdCBJdGVtJ107XG4gKlxuICpcbiAqICAgICAgaXRlbVNlbGVjdGVkOiBzdHJpbmcgPSAndmlldyc7XG4gKiAgICAgIGl0ZW1TZWxlY3RlZExnOiBzdHJpbmcgPSAnTW9uZGF5JztcbiAqXG4gKiAgICAgIG5vc2VsU3RyaW5nOiBzdHJpbmcgPSAnKG5vIHNlbGVjdGlvbiknO1xuICpcbiAqXG4gKiAgICAgIG9uU2VsZWN0aW9uIChldmVudCk6IHZvaWRcbiAqICAgICAge1xuICogICAgICAgICAgdGhpcy5pdGVtU2VsZWN0ZWQgPSBldmVudDtcbiAqXG4gKiAgICAgIH1cbiAqICB9XG4gKlxuICogIGBgYFxuICpcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBERF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRHJvcGRvd25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHJvcGRvd24nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctZHJvcGRvd25cIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzU3RhbmRhbG9uZVwiPlxuICAgICAgICA8cC1kcm9wZG93biBbb3B0aW9uc109XCJpbnRlcm5hbExpc3RcIlxuICAgICAgICAgICAgICAgICAgICBbZm9ybUNvbnRyb2xOYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwibm9TZWxlY3Rpb25TdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICBbYXV0b1dpZHRoXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgW2ZpbHRlcl09XCJzaG93RmlsdGVyKClcIlxuICAgICAgICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25JdGVtU2VsZWN0aW9uKCRldmVudClcIj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtIHBUZW1wbGF0ZT1cIml0ZW1cIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0VtYmVkZGVkVGVtcGxhdGUoKSAmJiBpdGVtRXhpc3QoaXRlbSlcIj5cbiAgICAgICAgICAgICAgICAgICAge3tpdGVtLmxhYmVsIH19XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cIml0ZW1UZW1wbGF0ZVwiIFtpdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0VtYmVkZGVkVGVtcGxhdGUoKSAmJiBpdGVtRXhpc3QoaXRlbSlcIj5cblxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG5cbiAgICAgICAgPC9wLWRyb3Bkb3duPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L2Rpdj5cblxuXG48IS0tIG5vIGZvcm1Db250cm9sIE5hbWUgaGVyZS4gbmdNb2RlbCBjYW5ub3QgaGF2ZSBmb3JtR3JvdXAgYXJvdW5kIC0tPlxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc1N0YW5kYWxvbmVcIj5cbiAgICA8ZGl2IGNsYXNzPVwidy1kcm9wZG93blwiPlxuICAgICAgICA8cC1kcm9wZG93biBbb3B0aW9uc109XCJpbnRlcm5hbExpc3RcIlxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJub1NlbGVjdGlvblN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvV2lkdGhdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cInNob3dGaWx0ZXIoKVwiXG4gICAgICAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkl0ZW1TZWxlY3Rpb24oJGV2ZW50KVwiPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbGV0LWl0ZW0gcFRlbXBsYXRlPVwiaXRlbVwiPlxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNFbWJlZGRlZFRlbXBsYXRlKCkgJiYgaXRlbUV4aXN0KGl0ZW0pXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7aXRlbS5sYWJlbCB9fVxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiaXRlbVRlbXBsYXRlXCIgW2l0ZW1dPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzRW1iZWRkZWRUZW1wbGF0ZSgpICYmIGl0ZW1FeGlzdChpdGVtKVwiPlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L3AtZHJvcGRvd24+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24taXRlbXMtd3JhcHBlcnttYXgtaGVpZ2h0Om5vbmUhaW1wb3J0YW50fS9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWl0ZW17cGFkZGluZzouNjVlbSAyZW0gLjY1ZW0gLjY0ZW07bWFyZ2luOjB9L2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24tZmlsdGVyLWNvbnRhaW5lcnt3aWR0aDoxMDAlfS9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWZpbHRlci1jb250YWluZXIgLmZhe3RvcDoxLjJlbX0vZGVlcC8gLnVpLWRyb3Bkb3duLXBhbmVsIC51aS1kcm9wZG93bi1saXN0e3BhZGRpbmc6MWVtIDB9L2RlZXAvIC53LWRyb3Bkb3duOm5vdCgubmctZGlydHkpIGxhYmVse2NvbG9yOiM5Njk2OTZ9L2RlZXAvIC53LWRyb3Bkb3duIC51aS1kcm9wZG93bi10cmlnZ2VyLnVpLWNvcm5lci1yaWdodHtib3JkZXItbGVmdDpub25lO2NvbG9yOiM5Njk2OTZ9L2RlZXAvIC53LWRyb3Bkb3duIC51aS1kcm9wZG93bi10cmlnZ2VyIC5waXtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Y29sb3I6Izc2NzY3NjtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS40ZW07bWFyZ2luLWxlZnQ6LS44NWVtfS9kZWVwLyAudy1kcm9wZG93biAudWktZHJvcGRvd24tdHJpZ2dlciAucGktY2FyZXQtZG93bjpiZWZvcmV7Y29udGVudDonXFxcXGUxZWYnfS9kZWVwLyAudy1kcm9wZG93biAudWktZHJvcGRvd24tbGFiZWx7cGFkZGluZy1yaWdodDoyLjRlbX1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgRERfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEcm9wZG93bkNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIHN0YXRpYyByZWFkb25seSBNYXhOdW1TaG93biA9IDEwO1xuXG4gICAgLyoqXG4gICAgICogT3JkZXJlZCBsaXN0IG9mIGl0ZW1zIHJlbmRlcmVkIGFzIGEgcG9wdXAgbWVudVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBJdGVtcyB3aGljaCB3YXMgc2VsZWN0ZWQgYXMgYSBkZWZhdWx0IHZhbHVlIG9yIGJ5IHVzZWQgaW4gdGhlIHBvcHVwIG1lbnUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb246IGFueTtcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyByZW5kZXJlZCBhcyBmaXJzdCB2YWx1ZSBpbiB0aGUgcG9wdXAgd2hpY2ggbGV0IHRoZSB1c2VyIHRvIG1ha2UgJ25vIHNlbGVjdGlvbicgZnJvbVxuICAgICAqIGF2YWlsYWJsZSBsaXN0IG9mIHZhbHVlcy4gV2hlbiB0aGlzIG9wdGlvbiBpcyBhY3RpdmUgYW5kIHVzZSBtYWtlIHRoaXMgc2VsZWN0aW9uIHdlIHNhdmUgYVxuICAgICAqIE5VTEwgdmFsdWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vU2VsZWN0aW9uU3RyaW5nOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGludGVybmFsIGxpc3QgdGhhdCBoaWRlcyBQcmltZU5HIHNwZWNpZmljcyB3aGVyZSB3ZSBuZWVkIHRvIGRlYWwgd2l0aCBzcGVjaWFsXG4gICAgICogdHlwZTogU2VsZWN0SXRlbS4gT3VyIGV4cGVjdGF0aW9uIGlzIHRoYXQgeW91IG5lZWQgdG8gYmUgYWJsZSB0byBwYXNzIHJlZ3VsYXIgc3RyaW5nIHZhbHVlc1xuICAgICAqIG9yIGZ1bGwgb2JqZWN0IGFuZCBub3QgdHJ5aW5nIHRvIHdyYXAgaXQgaW50byBleHRyYSBsYXllci5cbiAgICAgKlxuICAgICAqL1xuICAgIGludGVybmFsTGlzdDogU2VsZWN0SXRlbVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBFbWJlZGRlZCB0ZW1wbGF0ZSBkZWZpbmVkIGJ5IHVzZXIuIElmIHVzZXIgZG9lcyBub3QgcHJvdmlkZSBhbnkgdGVtcGxhdGUgYW5kIHdoaWxlIHJlbmRlcmluZ1xuICAgICAqIGl0ZW0gd2UgYXNzdW1lIHdlIGFyZSBkZWFsaW5nIHdpdGggcHJpbWl0aXZlIHR5cGVzIGFuZCBjYWxsIG9uIGVhY2ggaXRlbSB0b1N0cmluZygpLCBpZiB3ZVxuICAgICAqIGFyZSBkZWFsaW5nIHdpdGggb2JqZWN0LCB0aGVuIHdlIGV4cGVjdCB1c2VyIHRvIHByb3ZpZGUgYSB0ZW1wbGF0ZSBhbmQgdGVsbCB0aGUgZHJvcGRvd24gb2ZcbiAgICAgKiBlYWNoIGl0ZW0gc2hvdWxkIGJlIGhhbmRsZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2l0ZW1UZW1wbGF0ZScpXG4gICAgaXRlbVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtb2RlbCB1c2VkIGZvciBlbWJlZGRlZCB2ZXJzaW9uLlxuICAgICAqL1xuICAgIG1vZGVsOiBTZWxlY3RJdGVtO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZG86IFB1dCBiYWNrIHRoZSBzY3JvbGxpbmcgb3B0aW9uIG9uY2Ugd2UgZGVjaWRlIHNvLiBDdXJyZW50bHkgdGhlIHJlcXVpcmVtZW50cyBhcmVcbiAgICAgKiBzaG93IG9ubHkgMTAgaXRlbXMgbWF4LCBubyBzY3JvbGxpbmcuIEZ1bmN0aW9uYWxpdHkgY29tbWVudGVkIG91dCBjYW4gc2hvdyBzY3JvbGxiYXIgd2l0aFxuICAgICAqIHNlYXJjaCBmaWx0ZXIuXG4gICAgICovXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIGEgdmFsdWUgdG8gUHJpbWVOZyBGb3JtYXQsIHdlIGFyZSBub3QgcmVhbGx5IGJlIHVzaW5nIGEgbGFiZWwgZmllbGQgb25seSBhXG4gICAgICAgIC8vIHZhbHVlLlxuICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IFtdO1xuICAgICAgICAvLyBpZiAoaXNQcmVzZW50KHRoaXMubm9TZWxlY3Rpb25TdHJpbmcpKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmludGVybmFsTGlzdC5wdXNoKHtcbiAgICAgICAgLy8gICAgICAgICBsYWJlbDogdGhpcy5ub1NlbGVjdGlvblN0cmluZyxcbiAgICAgICAgLy8gICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMubm9TZWxlY3Rpb25TdHJpbmc7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgdGhpcy5saXN0Lmxlbmd0aCA+PSBEcm9wZG93bkNvbXBvbmVudC5NYXhOdW1TaG93bikge1xuXG4gICAgICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IHRoaXMubGlzdC5zbGljZSgwLCBEcm9wZG93bkNvbXBvbmVudC5NYXhOdW1TaG93bikubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogaXRlbS50b1N0cmluZygpLCB2YWx1ZTogaXRlbX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3Quc2xpY2UoMCkubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogaXRlbS50b1N0cmluZygpLCB2YWx1ZTogaXRlbX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgaGFzRW1iZWRkZWRUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuaXRlbVRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBwcmV2ZW50IEVtcHR5IGl0ZW0gdG8gYmUgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqIHRvZG86IFJlcG9ydCB0aGlzIG9uIFByaW1lTmdcbiAgICAgKlxuICAgICAqL1xuICAgIGl0ZW1FeGlzdChpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGl0ZW0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkcm9wZG93biBsaXN0IGlzIG1vcmUgdGhlbiBkZWZpbmVkIGNvbnN0YW50IE1heE51bVNob3duICgxMCkgYXV0b21hdGljYWxseSBzaG93IGZpbHRlclxuICAgICAqIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgc2hvd0ZpbHRlcigpXG4gICAge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHJldHVybiBpc1ByZXNlbnQodGhpcy5saXN0KSAmJiB0aGlzLmxpc3QubGVuZ3RoID4gRHJvcGRvd25Db21wb25lbnQuTWF4TnVtU2hvd247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVcGRhdGVzIGludGVybmFsIG1vZGVscyBvZiBjdXJyZW50IHNlbGVjdGlvbnMgYW5kIHRyaWdnZXJzIG9uU2VsZWN0aW9uIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBvbkl0ZW1TZWxlY3Rpb24odmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWUudmFsdWU7XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh2YWx1ZS52YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoe29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHZhbHVlLnZhbHVlKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5SXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KGl0ZW0pID8gaXRlbS5sYWJlbCA6ICdObyBTZWxlY3Rpb24nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIWVxdWFscyh2YWx1ZSwgdGhpcy5zZWxlY3Rpb24pKSB7XG5cbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Ryb3Bkb3duQ29tcG9uZW50fSBmcm9tICcuL2Ryb3Bkb3duLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Ryb3Bkb3duTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERyb3Bkb3duQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBEcm9wZG93bkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEcm9wZG93bkNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEcm9wZG93bk1vZHVsZVxue1xufVxuXG5cbiIsImltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzQmxhbmssIGlzUHJlc2VudCwgVmFsdWV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cbi8qKlxuICogTGlnaHR3ZWlnaHQgYW5kIGNvbmZpZ3VyYWJsZSBDdXJyZW5jeSBjb21wb25lbnQgYmFzZWQgb24gdGhlIG5nIGJvb3RzdHJhcCBkaXJlY3RpdmUuIFRoaXNcbiAqIGNvbXBvbmVudCBjb21iaW5lcyBhbiBpbnB1dCBhbmQgY3VycmVuY3kgY29kZSBkcm9wZG93bi5cbiAqXG4gKlxuICogZm9yIG1vcmUgaW5mbyBwbGVhc2Ugc2VlIGNsYXNzIERvYyBvZiB0aGU6XG4gKiAgQHNlZSB7QGxpbmsgY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzfVxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnYW1vdW50JyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgPGF3LWN1cnJlbmN5IFttb25leV09XCJwcmljZVwiIFtjdXJyZW5jaWVzXT1cImN1cnJlbmNpZXNcIiBbbmFtZV09XCInY3VycmVuY3knXCI+XG4gKiAgICAgIDwvYXctY3VycmVuY3k+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGFtb3VudDogbnVtYmVyID0gMTAwMDtcbiAqICAgICAgICBjdXJyZW5jaWVzOiBzdHJpbmdbXSA9IFsnVVNEJywgJ0NOWScsICdBVUQnLCAnRVVSJywgJ0dCUCddO1xuICogICAgICAgIGN1cnJlbmN5Q29kZTogc3RyaW5nID0gdGhpcy5jdXJyZW5jaWVzWzBdO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cblxuZXhwb3J0IGNvbnN0IENVUlJFTkNZX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDdXJyZW5jeUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jdXJyZW5jeScsXG4gICAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGVcIj5cbiAgICA8ZGl2IGNsYXNzPVwidy1jdXJyZW5jeS1maWVsZCB1aS1mbHVpZFwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nIFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctOCB1aS1nLW5vcGFkIFwiPlxuICAgICAgICAgICAgICAgIDxpbnB1dCAjY3VycmVuY3lJbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICBwSW5wdXRUZXh0XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJ3LXRleHQtZmllbGQgY3VycmVuY3ktZm9ybWF0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwiZGlzcGxheVZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGZvY3VzKT1cIm9uRm9jdXMoY3VycmVuY3lJbnB1dClcIlxuICAgICAgICAgICAgICAgICAgICAgICAoYmx1cik9XCJvbkJsdXIoY3VycmVuY3lJbnB1dClcIlxuICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctNCB1aS1nLW5vcGFkIHctY2MtZmllbGRcIj5cbiAgICAgICAgICAgICAgICA8YXctZHJvcGRvd24gKm5nSWY9XCIhcmVhZG9ubHlDdXJyZW5jeUNvZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCIgW2xpc3RdPVwiY3VycmVuY2llc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25dPVwibW9uZXkuY3VycmVuY3lcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuXG4gICAgICAgICAgICAgICAgPC9hdy1kcm9wZG93bj5cbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwicmVhZG9ubHlDdXJyZW5jeUNvZGVcIiBjbGFzcz1cInctY2MtcmVhZG9ubHktZmllbGRcIj57e21vbmV5LmN1cnJlbmN5fX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gY3VycmVuY3k6J1VTRCc6dHJ1ZSAtLT5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgdmFsdWU9XCJ7e2Rpc3BsYXlWYWx1ZX19IHt7IGdldE1vbmV5Q3VycmVuY3koKSB9fVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWN1cnJlbmN5LWZpZWxkIFtyZWFkb25seV0sLnctY3VycmVuY3ktdHlwZS1maWVsZCBbcmVhZG9ubHlde2JhY2tncm91bmQtY29sb3I6I2ZmZn0udy1jdXJyZW5jeS1maWVsZCBpbnB1dCwudy1jdXJyZW5jeS10eXBlLWZpZWxkIGlucHV0e21pbi13aWR0aDo4MHB4fS53LWN1cnJlbmN5LWZpZWxkIGkuZmEsLnctY3VycmVuY3ktdHlwZS1maWVsZCBpLmZhe2N1cnNvcjpwb2ludGVyfS53LWN1cnJlbmN5LWZpZWxke21hcmdpbi10b3A6MH0udy1jdXJyZW5jeS1maWVsZCAvZGVlcC8gLnVpLWRyb3Bkb3due21pbi13aWR0aDo4MHB4fS53LWNjLWZpZWxke2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9LnctY2MtcmVhZG9ubHktZmllbGR7cGFkZGluZy1sZWZ0OjVweDtjb2xvcjojOTY5Njk2fS5uby1ndXR0ZXI+W2NsYXNzKj11aS1nLV17cGFkZGluZy1yaWdodDowO3BhZGRpbmctbGVmdDowfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDVVJSRU5DWV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEN1cnJlbmN5Q29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgQ3VycmVuY3lDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIE1vbmV5IG9iamVjdCB0aGF0IGVuY2Fwc3VsYXRlcyB2YWx1ZSwgbG9jYWxlLCBjdXJyZW5jeSBjb2RlLlxuICAgICAqIElmIHRoaXMgb2JqZWN0IGlzIHNldCwgdmFsdWVzIHdpbGwgYmUgdGFrZW4gZnJvbSB0aGlzIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbW9uZXk6IE1vbmV5O1xuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSB1c2VyIHRvIGNoYW5nZSBNb25leSdzIGN1cnJlbmN5IGNvZGUgYW5kIHN0aWxsXG4gICAgICogYWxsb3cgdXNlciB0byBlZGl0IE1vbmV5J3MgYW1vdW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVhZG9ubHlDdXJyZW5jeUNvZGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW5jeSB0aGF0J3Mgc2VsZWN0ZWQgZm9yIHRoaXMgY3VycmVuY3kgZmllbGQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW5jeVNlbGVjdGlvbjogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIHVzZWQgdG8gZm9ybWF0IHRoZSBtb25leSBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByZWNpc2lvbjogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjdXJyZW5jaWVzIHRoYXQgdGhpcyBjdXJyZW5jeSB3aWRnZXQgc3VwcG9ydC4gVGhlIGZvcm1hdCBmb3IgZWFjaCBlbnRyeSBzaG91bGQgYmVcbiAgICAgKiBbY3VycmVuY3ktY29kZSAtIGRlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIF9jdXJyZW5jaWVzOiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvcm1hdHRlZCBjdXJyZW5jeSB2YWx1ZS4gVXNlcyBhbmd1bGFyIGN1cnJlbmN5UGlwZSB0byBmb3JtYXQgYmFzZWQgb24gY291bnRyeSBjb2RlLlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbmN5IHBpcGUgaXMgdXNlZCB0byBmb3JtYXQgb3VyIG1vbmV5IG9iamVjdC5cbiAgICAgKi9cbiAgICBjdXJyZW5jeVBpcGU6IEN1cnJlbmN5UGlwZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIGN1cnJlbmNpZXMuXG4gICAgICAgIHRoaXMuaW5pdEN1cnJlbmNpZXMoKTtcblxuICAgICAgICB0aGlzLmN1cnJlbmN5UGlwZSA9IG5ldyBDdXJyZW5jeVBpcGUoZW52LmxvY2FsZSk7XG5cbiAgICAgICAgZW52Lm9uTG9jYWxlQ2hhbmdlLnN1YnNjcmliZSgobG9jYWxlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lQaXBlID0gbmV3IEN1cnJlbmN5UGlwZShsb2NhbGUpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbmV5LmFtb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLm1vbmV5KTtcblxuICAgICAgICB0aGlzLmluaXRDdXJyZW5jaWVzKCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jdXJyZW5jeVNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSB0aGlzLl9jdXJyZW5jaWVzWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVhZHkgdGhlIG1vbmV5IGZpZWxkIGlmIGl0IGV4aXN0cy4gYW5kIG92ZXJyaWRlIHRoZSBleGlzdGluZyB2YWx1ZXMuXG4gICAgICAgIGlmICh0aGlzLm1vbmV5KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gdGhpcy5tb25leS5jdXJyZW5jeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9uZXkgPSBuZXcgTW9uZXkobnVsbCwgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBpbml0Q3VycmVuY2llcygpXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbmNpZXMgfHwgdGhpcy5fY3VycmVuY2llcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbmNpZXMgPSBbJ1VTRCcsICdDTlknLCAnQVVEJywgJ0VVUicsICdHQlAnXTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheSB0aGUgcmVhbCB2YWx1ZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBpbiB0aGUgY3VycmVuY3kgd2lkZ2V0LiBUaGVuIGhlIGNhbiBtb2RpZnkgdGhlXG4gICAgICogdmFsdWUgd2l0aG91dCBzZWVpbmcgdGhlIGZvcm1hdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZWxcbiAgICAgKi9cbiAgICBvbkZvY3VzKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkpICYmIGlzUHJlc2VudCh0aGlzLm1vbmV5LmFtb3VudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5tb25leS5hbW91bnQudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXkgdGhlIGZvcm1hdHRlZCBjdXJyZW5jeSB2YWx1ZSB3aGVuIHRoZSB1c2VyIG5hdmlnYXRlcyBhd2F5LlxuICAgICAqIEBwYXJhbSBlbFxuICAgICAqL1xuICAgIG9uQmx1cihlbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5tb25leSA9IHRoaXMubW9uZXkuY2xvbmUoe2Ftb3VudDogTnVtYmVyKGVsLnZhbHVlKX0pO1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb25leSk7XG4gICAgfVxuXG4gICAgb25TZWxlY3Rpb24oY3VycmVuY3k6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSBjdXJyZW5jeTtcbiAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLmZvcm1hdEN1cnJlbmN5KHRoaXMubW9uZXkuYW1vdW50KTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gd2lsbCBjaGVjayB0byBzZWUgaWYgY3VycmVuY3kgaXMgYSB2YWxpZCBudW1iZXIgYmVmb3JlIGZvcm1hdHRpbmcuXG4gICAgICogQHBhcmFtIHZhbFxuICAgICAqL1xuICAgIHByaXZhdGUgZm9ybWF0Q3VycmVuY3kodmFsOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmICghdmFsIHx8IHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOYU4odmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2RlID0gJ1VTRCc7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbmN5U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb2RlID0gdGhpcy5jdXJyZW5jeVNlbGVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9uZXkgPSB0aGlzLm1vbmV5LmNsb25lKHtjdXJyZW5jeTogdGhpcy5jdXJyZW5jeVNlbGVjdGlvbn0pO1xuXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSBwcmVjaXNpb24gaXMgMi4gRm9yIGV4YW1wbGUsIDEwLjIzIFVTRC5cbiAgICAgICAgbGV0IGRpZ2l0cyA9ICcxLjAtMic7XG4gICAgICAgIC8vIElmIHByZWNpc2lvbiBpcyBwcmVzZW50LCB1c2UgaXQgZm9yIGZvcm1hdCB0aGUgbW9uZXkgdmFsdWUgZm9yIGRpc3BsYXkuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wcmVjaXNpb24pKSB7XG4gICAgICAgICAgICBkaWdpdHMgPSAnMS4wLScgKyB0aGlzLnByZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVBpcGUudHJhbnNmb3JtKHZhbCwgY29kZSwgJ3N5bWJvbCcsIGRpZ2l0cyk7XG4gICAgfVxuXG4gICAgZ2V0TW9uZXlDdXJyZW5jeSgpOiBzdHJpbmcge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGlzcGxheVZhbHVlKSAmJiB0aGlzLmRpc3BsYXlWYWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVNlbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgY3VycmVuY2llcygpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbmNpZXM7XG4gICAgfVxuXG4gICAgc2V0IGN1cnJlbmNpZXModmFsdWU6IGFueVtdKVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbmNpZXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoKHZhbHVlIGluc3RhbmNlb2YgTW9uZXkpICYmICFlcXVhbHModmFsdWUsIHRoaXMubW9uZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1vbmV5ID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9uZXkuY3VycmVuY3kpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IHRoaXMubW9uZXkuY3VycmVuY3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vbmV5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBNb25leSBvYmplY3QgaXMgcmVwcmVzZW50ZWQgYXMgYSB2YWx1ZSwgbG9jYWxlLCBhbmQgY3VycmVuY3lDb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBNb25leSBpbXBsZW1lbnRzIFZhbHVlXG57XG4gICAgdW5pcXVlTmFtZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IGFtb3VudDogbnVtYmVyID0gMCwgcHVibGljIHJlYWRvbmx5IGN1cnJlbmN5OiBzdHJpbmcgPSAnVVNEJyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbG9jYWxlOiBzdHJpbmcgPSAnZW5fVVMnKVxuICAgIHtcbiAgICB9XG5cblxuICAgIGdldFR5cGVzKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFtb3VudDogTnVtYmVyLFxuICAgICAgICAgICAgY3VycmVuY3k6IFN0cmluZyxcbiAgICAgICAgICAgIGxvY2FsZTogU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3NOYW1lKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuICdNb25leSc7XG4gICAgfVxuXG4gICAgJHByb3RvKCk6IE1vbmV5XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IE1vbmV5KDEsICcyMycsICczMycpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50ICsgJywgbG9jYWxlOiAnICsgdGhpcy5sb2NhbGUgKyAnLCBjb2RlOiAgJyArIHRoaXMuY3VycmVuY3k7XG4gICAgfVxuXG5cbiAgICBjbG9uZShkYXRhOiB7IGFtb3VudD86IG51bWJlciwgY3VycmVuY3k/OiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyB9ID0ge30pOiBNb25leVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNb25leShcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmFtb3VudCkgPyBkYXRhLmFtb3VudCA6IHRoaXMuYW1vdW50LFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuY3VycmVuY3kpID8gZGF0YS5jdXJyZW5jeSA6IHRoaXMuY3VycmVuY3ksXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5sb2NhbGUpID8gZGF0YS5sb2NhbGUgOiB0aGlzLmxvY2FsZVxuICAgICAgICApO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlLCBDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Ryb3Bkb3duTW9kdWxlLCBJbnB1dFRleHRNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0N1cnJlbmN5Q29tcG9uZW50fSBmcm9tICcuL2N1cnJlbmN5LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ3VycmVuY3lDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtDdXJyZW5jeVBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ3VycmVuY3lNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc0RhdGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBMaWdodHdlaWdodCBhbmQgY29uZmlndXJhYmxlIERhdGUgYW5kIFRpbWUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBwcmltZW5nLiBUaGlzXG4gKiBjb21wb25lbnQgY29tYmluZXMgYm90aCBkYXRlIHBpY2tlciBhcyB3ZWxsIGFzIHRpbWUgcGlja2VyXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXlUaW1lcicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIiAgW25hbWVdPVwiJ2R1ZURhdGUnXCI+XG4gKiAgICA8L2F3LWRhdGUtdGltZT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15VGltbWVyQ29tcG9uZXRcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gKlxuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEZ1bGxZZWFyKDIwMTYgLCAxMCAsIDMpO1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0SG91cnMoMTAgLCAxMCAsIDEwKTtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICogQnkgZGVmYXVsdCB5b3Ugd2lsbCBzZWUgZGF0ZSBmaWVsZCBhbmQgdGltZSBmaWVsZCBpcyBoaWRkZW4gdG8gc2hvdyBib3RoIHlvdSBqdXN0IGRvIGZvbGxvd2luZzpcbiAqXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteVRpbWVyJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgIDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCIgIFtuYW1lXT1cIidiYmRkJ1wiPlxuICogICAgPC9hdy1kYXRlLXRpbWU+XG4gKlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVRpbW1lckNvbXBvbmV0XG4gKiAgICB7XG4gKiAgICAgICAgZGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG4gKiAgICAgICAgc2hvd1RpbWUgPSB0cnVlO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgdGhpcy5kYXRlLnNldEZ1bGxZZWFyKDIwMTYgLCAxMCAsIDMpO1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0SG91cnMoMTAgLCAxMCAsIDEwKTtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKi9cblxuXG5leHBvcnQgY29uc3QgREFURVRJTUVfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVBbmRUaW1lQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kYXRlLXRpbWUnLFxuICAgIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidy1kYXRldGltZSBcIiBbY2xhc3MuaGFzLXRpbWVdPVwic2hvd1RpbWVcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiPlxuXG4gICAgICAgIDxwLWNhbGVuZGFyIGZvcm1Db250cm9sTmFtZT1cInt7bmFtZX19XCJcbiAgICAgICAgICAgICAgICAgICAgW2RlZmF1bHREYXRlXT1cImRlZmF1bHREYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dJY29uXT1cInNob3dJY29uXCJcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdD1cInt7c2hvd1RpbWUgPyBmb3JtYXROYW1lV2l0aFRpbWUgOiBmb3JtYXRQYXR0ZXJufX1cIlxuICAgICAgICAgICAgICAgICAgICBbeWVhck5hdmlnYXRvcl09XCJzaG93TmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFttb250aE5hdmlnYXRvcl09XCJzaG93TmF2aWdhdGlvblwiXG4gICAgICAgICAgICAgICAgICAgIFt5ZWFyUmFuZ2VdPVwieWVhclJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e3Nob3dUaW1lID8gZm9ybWF0TmFtZVdpdGhUaW1lLnRvVXBwZXJDYXNlKCkgOiBmb3JtYXRQYXR0ZXJuLnRvVXBwZXJDYXNlKCl9fVwiXG4gICAgICAgICAgICAgICAgICAgIChvblNlbGVjdCk9XCJvbkRhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIFt0aW1lT25seV09XCIhc2hvd0RhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbcmVhZG9ubHlJbnB1dF09XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2xvY2FsZV09XCJpMThuXCI+XG4gICAgICAgIDwvcC1jYWxlbmRhcj5cblxuICAgICAgICA8cC1jYWxlbmRhciAqbmdJZj1cInNob3dUaW1lXCJcbiAgICAgICAgICAgICAgICAgICAgaWNvbj1cImljb24taGlzdG9yeVwiXG4gICAgICAgICAgICAgICAgICAgIGZvcm1Db250cm9sTmFtZT1cInt7bmFtZX19XCJcbiAgICAgICAgICAgICAgICAgICAgW2hvdXJGb3JtYXRdPVwiaG91ckZvcm1hdFwiXG4gICAgICAgICAgICAgICAgICAgIFtkZWZhdWx0RGF0ZV09XCJkZWZhdWx0RGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzaG93SWNvbl09XCJzaG93SWNvblwiXG4gICAgICAgICAgICAgICAgICAgIFt0aW1lT25seV09XCJzaG93VGltZVwiXG4gICAgICAgICAgICAgICAgICAgIFtzaG93VGltZV09XCJzaG93VGltZVwiXG4gICAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJ0aW1lUGxhY2VIb2xkZXJcIlxuICAgICAgICAgICAgICAgICAgICAob25TZWxlY3QpPVwib25EYXRlQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICBbbG9jYWxlXT1cImkxOG5cIj5cbiAgICAgICAgPC9wLWNhbGVuZGFyPlxuXG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyB2YWx1ZT1cInt7dmFsdWUgfCBkYXRlOiBmb3JtYXRQYXR0ZXJuTkd9fVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC9kZWVwLyAudy1kYXRldGltZSAudWktY2FsZW5kYXIgYnV0dG9ue2JvcmRlcjowO3dpZHRoOjB9L2RlZXAvIC53LWRhdGV0aW1lIC51aS1jYWxlbmRhci51aS1jYWxlbmRhci13LWJ0biAudWktaW5wdXR0ZXh0e3dpZHRoOjEwMCV9L2RlZXAvIC51aS1jYWxlbmRhciAudWktY2FsZW5kYXItYnV0dG9uIC51aS1idXR0b24taWNvbi1sZWZ0e2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojMTk5ZGUwO2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjRlbX0vZGVlcC8gLnVpLWNhbGVuZGFyIC51aS1jYWxlbmRhci1idXR0b24gLnVpLWJ1dHRvbi1pY29uLWxlZnQucGktY2FsZW5kYXI6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMGUwJ30vZGVlcC8gLnVpLWNhbGVuZGFyIC51aS1jYWxlbmRhci1idXR0b24gLnVpLWJ1dHRvbi1pY29uLWxlZnQuaWNvbi1oaXN0b3J5OmJlZm9yZXtjb250ZW50OidcXFxcZTAyZCd9L2RlZXAvIC51aS1kYXRlcGlja2Vye3dpZHRoOjI0LjI4ZW07bGluZS1oZWlnaHQ6MjVweDtwYWRkaW5nOjA7Ym9yZGVyLWNvbG9yOiM5Nzk3OTc7Ym94LXNoYWRvdzpub25lfS9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1oZWFkZXJ7cGFkZGluZzouOTJlbSAwO2ZvbnQtd2VpZ2h0OjQwMDtjb2xvcjojMDAwO2ZvbnQtc2l6ZToxZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLW5leHQsL2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLXByZXZ7dG9wOjFlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItcHJldntsZWZ0Oi4yZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLW5leHR7cmlnaHQ6LjJlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGFibGV7Zm9udC1zaXplOjFlbTttYXJnaW46MCAwIDEuNWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0aHtmb250LXdlaWdodDo0MDA7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjO2NvbG9yOiMzNjM2MzY7cGFkZGluZzouNzg2ZW0gMS4wN2VtfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0ZHtwYWRkaW5nOi4xZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIHRkIGF7dGV4dC1hbGlnbjpjZW50ZXI7d2lkdGg6Mi43ZW07aGVpZ2h0OjIuN2VtO2xpbmUtaGVpZ2h0OjIuN2VtO3BhZGRpbmc6MDtib3JkZXItcmFkaXVzOjUwJX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGQgYS51aS1zdGF0ZS1kZWZhdWx0e2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudH0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGQgYS51aS1zdGF0ZS1hY3RpdmV7YmFja2dyb3VuZC1jb2xvcjojMTk5ZGUwO2NvbG9yOiNmZmZ9L2RlZXAvIC51aS1kYXRlcGlja2VyIC5waXtmb250LXNpemU6MWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciAucGkucGktY2hldnJvbi1sZWZ0OmJlZm9yZXtjb250ZW50OidcXFxcZTFlZSd9L2RlZXAvIC51aS1kYXRlcGlja2VyIC5waS5waS1jaGV2cm9uLXJpZ2h0OmJlZm9yZXtjb250ZW50OidcXFxcZTFlZCd9L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLWNhbGVuZGFyIHRkOm5vdCgudWktc3RhdGUtZGlzYWJsZWQpIGE6aG92ZXJ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50O2JhY2tncm91bmQtY29sb3I6cmdiYSgyNSwxNTcsMjI0LC43KTtvcGFjaXR5Oi43NTtjb2xvcjojMzYzNjM2fS9kZWVwLyAudWktZGF0ZXBpY2tlci10aW1lb25seXt3aWR0aDoxMDAlfS9kZWVwLyAudWktdGltZXBpY2tlcntmb250LXNpemU6MS4xNGVtO2NvbG9yOiM3Njc2NzY7Zm9udC13ZWlnaHQ6NDAwfS9kZWVwLyAudWktdGltZXBpY2tlciAucGl7Zm9udC1zaXplOjFlbX0vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnBpLnBpLWNoZXZyb24tdXA6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWYwJ30vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnBpLnBpLWNoZXZyb24tZG93bjpiZWZvcmV7Y29udGVudDonXFxcXGUxZWYnfS9kZWVwLyAudWktdGltZXBpY2tlcj5kaXZ7bWFyZ2luLWxlZnQ6MH0vZGVlcC8gLnVpLXRpbWVwaWNrZXIgLnVpLXNlcGFyYXRvcnt3aWR0aDouMWVtO21pbi13aWR0aDouMWVtfS9kZWVwLyAudWktdGltZXBpY2tlciAudWktc2VwYXJhdG9yIC5waXtmb250LXNpemU6MH0vZGVlcC8gLnVpLWRhdGVwaWNrZXItdHJpZ2dlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS9kZWVwLyAudWktZGF0ZXBpY2tlci10cmlnZ2VyLnVpLWJ1dHRvbjplbmFibGVkOmhvdmVyLC9kZWVwLyAudWktZGF0ZXBpY2tlci10cmlnZ2VyLnVpLWJ1dHRvbjpmb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS9kZWVwLyAuaGFzLXRpbWV7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDpub3dyYXB9L2RlZXAvIC5oYXMtdGltZSBwLWNhbGVuZGFyOmZpcnN0LWNoaWxke3dpZHRoOjU1JTttYXJnaW4tcmlnaHQ6MTRweH0vZGVlcC8gLmhhcy10aW1lIHAtY2FsZW5kYXI6bGFzdC1jaGlsZHt3aWR0aDo0NSV9L2RlZXAvIC5oYXMtdGltZSBwLWNhbGVuZGFyOmxhc3QtY2hpbGQgLnVpLWRhdGVwaWNrZXJ7cGFkZGluZzowfS9kZWVwLyAuaGFzLXRpbWUgLnVpLWJ1dHRvbi1pY29uLWxlZnR7bGluZS1oZWlnaHQ6MThweH1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgREFURVRJTUVfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEYXRlQW5kVGltZUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIERhdGVBbmRUaW1lQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuXG4gICAgc3RhdGljIHJlYWRvbmx5IE5nVGltZTEyOiBzdHJpbmcgPSAnaGg6bW0gYSc7XG4gICAgc3RhdGljIHJlYWRvbmx5IE5nVGltZTI0OiBzdHJpbmcgPSAnSEgubW0gYSc7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUgdXNlZCB0byBzZXQgdGhlIGRhdGUgYW5kIHRpbWUgcGlja2VyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogRGF0ZTtcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgZGF0ZSBmb3JtYXQgcGF0dGVybiB1c2VkIGlmIG5vbmUgaXMgcGFzc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdFBhdHRlcm46IHN0cmluZyA9ICdtbS9kZC95eSc7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgd29ya2Fyb3VuZCBhcyBmb3JtYXR0ZXJzIGluIHRoZSBwcmltZU5HIGFuZCBhbmd1bGFyIGFyZSBkaWZmZXJlbnQgc28gdW50aWwgaXRzXG4gICAgICogZml4ZWQgd2UgbmVlZCB0byBrZWVwIHRoaXMgZXh0cmEgcGF0dGVybi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvcm1hdFBhdHRlcm5ORzogc3RyaW5nID0gJ01NL2RkL3l5JztcblxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgYW5kIGhpZGVzIG5hdmlnYXRpb24gYmFyIHdpdGggeWVhciBhbmQgbW9udGhzIHNlbGVjdGlvbnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dOYXZpZ2F0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFllYXIgcmFuZ2UgZGlzcGxheWVkIGZvciB0aGUgZHJvcCBkb3duLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgeWVhclJhbmdlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhbmQgaGlkZXMgbmF2aWdhdGlvbiBiYXIgd2l0aCB5ZWFyIGFuZCBtb250aHMgc2VsZWN0aW9uc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0ljb246IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IHRpbWVwaWNrZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dUaW1lOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBEYXRlUGlja2VyLiBFdmVuIHdlIGNhbiBoaWRlIGl0LiBpdCBzaG91bGQgYmUgZm9yIG1vc3Qgb2YgdGhlIGNhc2UgYWx3YXlzXG4gICAgICogdHJ1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0RhdGU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHRoZSBkYXRlIHBpY2tlciB3aGF0IGZvcm1hdCBpdCBzaG91bGQgdXNlIHdoZW4gcHJlc2VudGluZyB0aW1lLiBXaGVuIGhvdXJGb3JtYXQgaXMgMTIsXG4gICAgICogaXQgc2hvd3MgdGhlIEFNLCBQTVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBob3VyRm9ybWF0OiBzdHJpbmcgPSAnMjQnO1xuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgZXZlbnQgd2hlbiBzcGVjaWZpYyBkYXRlIGlzIGNsaWNrZWQgaW5zaWRlIERhdGVQaWNrZXJcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGRhdGUgdG8gaGlnaGxpZ2h0IG9uIGZpcnN0IG9wZW5pbmcgaWYgdGhlIGZpZWxkIGlzIGJsYW5rLlxuICAgICAqXG4gICAgICovXG4gICAgZGVmYXVsdERhdGU6IERhdGUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBEYXRldGltZSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGUgRGF0ZUFuZFRpbWUgZm9ybWF0TmFtZSBpcyBub3QgcHJvcGFnYXRlZFxuICAgICAqIHRvIERhdGUgZmllbGQuXG4gICAgICovXG4gICAgZm9ybWF0TmFtZVdpdGhUaW1lOiBzdHJpbmc7XG5cblxuICAgIGkxOG46IGFueTtcbiAgICB0aW1lUGxhY2VIb2xkZXI6IHN0cmluZyA9ICdoaDpzcyc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudCkge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHRvIGRhdGVUaW1lIHBhdHRlcm4gd2hpY2ggaXMgZGVmaW5lZCBpbiByZXNvdXJjZSBmaWxlc1xuICAgICAgICBpZiAodGhpcy5ob3VyRm9ybWF0ICE9PSAnMTInICYmIHRoaXMuaG91ckZvcm1hdCAhPT0gJzI0Jykge1xuICAgICAgICAgICAgdGhpcy5ob3VyRm9ybWF0ID0gJzI0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZVBsYWNlSG9sZGVyID0gKHRoaXMuaG91ckZvcm1hdCA9PT0gJzEyJykgP1xuICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSgodmFsOiBEYXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5pbml0VHJhbnNsYXRpb25zKCk7XG5cbiAgICAgICAgdGhpcy5lbnYub25Mb2NhbGVDaGFuZ2Uuc3Vic2NyaWJlKChsb2NhbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0VHJhbnNsYXRpb25zKCk7XG5cbiAgICAgICAgfSk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE5lZWQgdG8gcmVmYWN0b3IgdGhpcyBhcyB0aGlzIHJlYWxseSBnZXQgY29tcGxpY2F0ZWQgdHJ5aW5nIHRvIGNvdmVyIHVzZWNhc2Ugd2l0aCB0aW1lXG4gICAgICogYW5kIGRhdGUgYW5kIGV2ZXJ5IGZvcm1hdCB3ZSBoYXZlLiBXZSBzaG91bGQgcHJvYmFibHkgaGF2ZSBzZXBhcmF0ZSBwYXR0ZXJucyBmb3JcbiAgICAgKiBkYXRlcyBvbmx5IGFuZCBkYXRlICsgdGltZVxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdFRyYW5zbGF0aW9ucygpIHtcblxuICAgICAgICB0aGlzLmZvcm1hdE5hbWVXaXRoVGltZSA9IHRoaXMuZm9ybWF0UGF0dGVybjtcbiAgICAgICAgaWYgKCF0aGlzLnNob3dEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFBhdHRlcm5ORyA9IHRoaXMuZm9ybWF0UGF0dGVybiArPSAodGhpcy5ob3VyRm9ybWF0ID09PSAnMTInKSA/XG4gICAgICAgICAgICAgICAgYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTEyfWAgOiBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMjR9YDtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvd1RpbWUpIHtcbiAgICAgICAgICAgIGxldCB0aW1lU3RhcnRzID0gdGhpcy5mb3JtYXRQYXR0ZXJuLmluZGV4T2YoJ2gnKTtcbiAgICAgICAgICAgIGlmICh0aW1lU3RhcnRzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0TmFtZVdpdGhUaW1lID0gdGhpcy5mb3JtYXRQYXR0ZXJuLnN1YnN0cmluZygwLCB0aW1lU3RhcnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGF0dGVybk5HICs9ICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicpID9cbiAgICAgICAgICAgICAgICBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMTJ9YCA6IGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUyNH1gO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLmkxOG4gPSB7XG4gICAgICAgICAgICBmaXJzdERheU9mV2VlazogMCxcbiAgICAgICAgICAgIGRheU5hbWVzOiBbJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JyxcbiAgICAgICAgICAgICAgICAnU2F0dXJkYXknXSxcbiAgICAgICAgICAgIGRheU5hbWVzU2hvcnQ6IFsnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0J10sXG4gICAgICAgICAgICBkYXlOYW1lc01pbjogWydTJywgJ00nLCAnVCcsICdXJywgJ1QnLCAnRicsICdTJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLFxuICAgICAgICAgICAgICAgICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddLFxuICAgICAgICAgICAgbW9udGhOYW1lc1Nob3J0OiBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsXG4gICAgICAgICAgICAgICAgJ05vdicsICdEZWMnXVxuICAgICAgICB9O1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIGRhdGVzIGNoYW5nZXMuIEhlcmUgd2UgdXBkYXRlICB0aGlzLnZhbHVlIC0gPiBkYXRlIGFuZCBhbHNvIHVwZGF0ZSB2YWx1ZSBpbnNpZGVcbiAgICAgKiBmb3JtQ29udHJvbGxlclxuICAgICAqXG4gICAgICovXG4gICAgb25EYXRlQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkIHtcblxuICAgICAgICBpZiAoaXNCbGFuayhldmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRocm93IHNvbWUgZXJyb3IgP1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlzRGF0ZShldmVudCkgPyBldmVudCA6IG5ldyBEYXRlKGV2ZW50KTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMudmFsdWUsIHtvbmx5U2VsZjogZmFsc2UsIGVtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG4iLCJpbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDYWxlbmRhck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RGF0ZUFuZFRpbWVDb21wb25lbnR9IGZyb20gJy4vZGF0ZS1hbmQtdGltZS5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERhdGVBbmRUaW1lQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0RhdGVBbmRUaW1lTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGlhbG9nIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGlhbG9nQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2ctaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERpYWxvZ0hlYWRlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBkaWFsb2cgaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBEaWFsb2dDb21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRpYWxvZy1mb290ZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7RGlhbG9nSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWFsb2cgQ29tcG9uZW50IHRoYXQgcHJvdmlkZXMgdGhlIGxvb2sgYW5kIGZlZWwgZm9yIGEgbW9kYWwgZGlhbG9nLiBUaGlzIGNvbXBvbmVudCBoYXMgdGhyZWVcbiAqIHNlY3Rpb25zOiBoZWFkZXIsIGJvZHksIGFuZCBmb290ZXIuIEl0IGNhbiBiZSB1c2VkIGJ5IGl0c2VsZiBvciBleHRlbmRlZC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgdHlwZXMgb2YgcG9wdXAuXG4gKiAgIDEuICBhIHJlZ3VsYXIgZGlhbG9nIGJveCB0aGF0IGhhcyBoZWFkZXIsIGJvZHkgYW5kIGZvb3Rlci4gSXQncyB0aGUgbW9zdCBjdXN0b21pemFibGUuXG4gKiAgIDIuICBhIGNvbmZpcm1hdGlvbiBib3ggaXMgc2ltaWxhciB0byBhIGRpYWxvZyBib3ggYnV0IGhhcyBhY2NlcHQgYW5kIHJlamVjdCBhY3Rpb24gYnV0dG9ucy5cbiAqICAgMy4gIGEgb3ZlcmxheSwgd2hpY2ggaXMgYSB2ZXJ5IGJhc2ljIHBvcHVwIHdpdGggd2hhdCB5b3UgcHV0IGluc2lkZS5cbiAqICAgICAgIEl0IGRvZXNuJ3QgaGF2ZSBoZWFkZXIgYW5kIGZvb3Rlci5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIGFueSBwb3B1cCBjb21wb25lbnQuXG4gKiAgIDEuICBFaXRoZXIgZGlyZWN0bHkgYnkgdXNpbmcgY29tcG9uZW50LCBhdy1kaWFsb2csIGF3LWNvbmZpcm1hdGlvbiBvciBhdy1vdmVybGF5XG4gKiAgIDIuICBvciB0aGUgTW9kYWxTZXJ2aWNlICBzZXJ2aWNlLm9wZW4oPERpYWxvZ0NvbXBvbmVudD4pLCBzZXJ2aWNlLmNsb3NlKClcbiAqXG4gKiBVc2FnZTpcbiAqICAgIDEuICBVc2luZyBEaWFsb2cgZGlyZWN0bHkgdG8gZGlzcGxheSBhIG1vZGFsIHBvcHVwLiBUaGlzIHVzYWdlIGlzIGEgcXVpY2sgd2F5IHRvIHNob3cgYVxuICogbWVzc2FnZSB0byB0aGUgdXNlci5cbiAqXG4gKiAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5vcGVuPERpYWxvZ0NvbXBvbmVudD4oIERpYWxvZ0NvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ015IFBvcHVwIFRpdGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgYm9keTogJ015IFBvcHVwIEJvZHknXG4gKiAgICAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBVc2UgdGhlIGNvbXBvbmVudCBpbnNpZGUgeW91ciB0ZW1wbGF0ZS5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nIFsodmlzaWJsZSldPVwiZGlzcGxheVwiIFttb2RhbF09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbk9wZW4pPVwib3BlbkFjdGlvbigpXCIgKG9uQ2xvc2UpPVwiY2xvc2VBY3Rpb24oKVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZy1oZWFkZXI+RGlhbG9nIEhlYWRlcjwvYXctZGlhbG9nLWhlYWRlcj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaWFsb2cgQm9keTogQ3JlYXRpbmcgYSBkaWFsb2cgdXNpbmcgdGhlIGRpYWxvZyBjb21wb25lbnRcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2ctZm9vdGVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIFtzdHlsZV09XCIncHJpbWFyeSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNsb3NlKClcIj5PSzwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGlhbG9nPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiAoY2xpY2spPVwib3BlbigpXCI+T3BlbiBEaWFsb2c8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpYWxvZ0FjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gdHJ1ZTtcbiAqICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3BlbkFjdGlvbigpICB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlhbG9nQWN0aW9uID0gXCJvcGVuXCI7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kaWFsb2cnLFxuICAgIHRlbXBsYXRlOiBgPHAtZGlhbG9nIFtoZWFkZXJdPVwidGl0bGVcIiBbKHZpc2libGUpXT1cInZpc2libGVcIlxuICAgICAgICAgIFttb2RhbF09XCJtb2RhbFwiIFtjbG9zYWJsZV09XCJjbG9zYWJsZVwiIFt3aWR0aF09XCJ3aWR0aFwiIFtoZWlnaHRdPVwiaGVpZ2h0XCJcbiAgICAgICAgICBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW2FwcGVuZFRvXT1cImFwcGVuZFRvXCIgKG9uU2hvdyk9XCJvcGVuKClcIiAob25IaWRlKT1cImNsb3NlKClcIj5cblxuICAgIDxwLWhlYWRlciAqbmdJZj1cImhhc0hlYWRlcigpXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWRpYWxvZy1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9wLWhlYWRlcj5cblxuICAgIHt7Ym9keX19XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG4gICAgPHAtZm9vdGVyICpuZ0lmPVwiaGFzRm9vdGVyKClcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImRpYWxvZy1mb290ZXItc2VwYXJhdG9yXCI+PC9kaXY+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWRpYWxvZy1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9wLWZvb3Rlcj5cbjwvcC1kaWFsb2c+XG5gLFxuICAgIHN0eWxlczogW2A6Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLXRpdGxlYmFye2JhY2tncm91bmQtY29sb3I6I2YyZjJmMjtwYWRkaW5nOjE1cHggMjBweH06Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLXRpdGxlYmFyIC51aS1kaWFsb2ctdGl0bGViYXItaWNvbjpob3Zlcntib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9OjpuZy1kZWVwIC51aS13aWRnZXQtaGVhZGVye2ZvbnQtd2VpZ2h0OjQwMDtmb250LXNpemU6MTZweH06Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktZGlhbG9nLWNvbnRlbnR7cGFkZGluZzoxNXB4IDIwcHg7bGluZS1oZWlnaHQ6MS4zZW19OjpuZy1kZWVwIC51aS1kaWFsb2cgLnVpLXdpZGdldC1jb250ZW50e2JvcmRlcjpub25lfTo6bmctZGVlcCAudWktZGlhbG9nLnVpLXdpZGdldC1jb250ZW50e2JvcmRlcjpub25lO2JveC1zaGFkb3c6MCAycHggMTBweCAwIHJnYmEoMCwwLDAsLjMpfTo6bmctZGVlcCAudWktZGlhbG9nIC5kaWFsb2ctZm9vdGVyLXNlcGFyYXRvcntib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3O2hlaWdodDoxNHB4fTo6bmctZGVlcCAudWktZGlhbG9nIC51aS1kaWFsb2ctZm9vdGVye3BhZGRpbmc6MCAyMHB4IDE1cHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nQ29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXJcbntcbiAgICAvKipcbiAgICAgKiBUaXRsZSBmb3IgdGhlIERpYWxvZy4gIGlmIHRpdGxlIGFuZCAnVGl0bGVUZW1wbGF0ZScgYXJlIGJvdGggc2V0LCB0aXRsZVRlbXBsYXRlIHRha2VzXG4gICAgICogcHJlY2VkZW5jZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5IHNlY3Rpb24gZm9yIERpYWxvZy4gQ2FsbGVyIHNob3VsZCB1c2UgZWl0aGVyIHRoZSBib2R5IHN0cmluZywgb3IgY29udGVudCBwcm9qZWN0aW9uXG4gICAgICogdG8gYWRkIHZhbHVlcyB0byB0aGUgZGlhbG9nLiBJZiBib3RoIGFyZSB1c2VkLCB0aGV5IHdpbGwgYm90aCBzaG93IHVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIHN1cHBvcnQgdHdvIHdheSBkYXRhIGJpbmRpbmcgb24gdmlzaWJsZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIHdoZXRoZXIgdGhpcyBkaWFsb2cgYmxvY2tzIHRoZSByZXN0IG9mIHRoZSBwYWdlIG9yIG5vdCB3aGVuIGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1vZGFsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlcmUncyBhbiB4IGF0IHRoZSB0b3AgcmlnaHQgdGhhdCBtYWtlcyB0aGUgZGlhbG9nIGNsb3NhYmxlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2xvc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaWFsb2cuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGRpYWxvZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgY29tcG9uZW50LiBVc3VhbGx5IGNvbnRhaW5zIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERpYWxvZ0hlYWRlckNvbXBvbmVudCkgaGVhZGVyOiBEaWFsb2dIZWFkZXJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgZm9vdGVyLiBVc3VhbGx5IGNvbnRhaW5zIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERpYWxvZ0Zvb3RlckNvbXBvbmVudCkgZm9vdGVyOiBEaWFsb2dGb290ZXJDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gMzAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoaXMgZGlhbG9nLlxuICAgICAqL1xuICAgIG9wZW4oKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgpO1xuXG4gICAgICAgIC8vIHZpc2libGUgaXMgYSAyLXdheSBiaW5kaW5nIHZhcmlhYmxlLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSB0aGUgZGlhbG9nXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG5cbiAgICAgICAgLy8gSW1wb3J0YW50IHRvIG1ha2Ugc3VyZSBjaGFuZ2UgaXMgc2V0IG9uIHBhcmVudCBiaW5kaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YXJpYWJsZSBhbmQgZGlhbG9nIG9wZW4vY2xvc2Ugc3RhdGUgY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBzeW5jIGFuZCB3ZSB3b3VsZG4ndCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoaXMgZGlhbG9nIGhhdmUgaGVhZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzSGVhZGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5oZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBkaWFsb2cgaGF2ZSBmb290ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNGb290ZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmZvb3Rlcik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtEaWFsb2dDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0hlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RpYWxvZ0Zvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2ctZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0Zvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdEaWFsb2dNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIFNraXBTZWxmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIEVudmlyb25tZW50LFxuICAgIGVxdWFscyxcbiAgICBGaWVsZFBhdGgsXG4gICAgaXNBcnJheSxcbiAgICBpc0JsYW5rLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNQcmVzZW50LFxuICAgIExpc3RXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDaG9vc2VyU2VsZWN0aW9uU3RhdGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1zZWxlY3Rpb24tc3RhdGUnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci1zdGF0ZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtDaG9vc2VyRGF0YVNvdXJjZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLWRhdGEtc291cmNlJztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuXG5cbi8qKlxuICogQ29udmVuaWVudCB3cmFwcGVyIGNsYXNzIGFyb3VuZCBjb250cm9scyBzdWNoIGFzIHJhZGlvYnV0dG9ucywgZHJvcGRvd24sIGNoZWNrYm94ZXMsXG4gKiBDaG9vc2VyLiBUaGUgdHlwZSBvZiB0aGUgY2hvb3NlciBtYXkgYmUgZGV0ZXJtaW5lZCBkeW5hbWljYWxseSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluXG4gKiB0aGUgZGF0YSBzb3VyY2UgbGlzdCwgb3IgY2FuIGJlIHNwZWNpZmllZCBleHBsaWNpdGx5IHZpYSB0aGUgXCJ0eXBlXCIgYmluZGluZy5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1nZW5lcmljLWNob29zZXInLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwidHlwZVwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ0NoZWNrYm94J1wiPlxuICAgICAgICA8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJsaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbnNdPVwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtsYWJlbEZvcm1hdHRlcl09XCJkaXNwbGF5VmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPlxuICAgICAgICA8L2F3LWNoZWNrYm94LWxpc3Q+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ1JhZGlvJ1wiPlxuICAgICAgICA8YXctcmFkaW9idXR0b24tbGlzdCBbbGlzdF09XCJsaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsRm9ybWF0dGVyXT1cImRpc3BsYXlWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICAgIDwvYXctcmFkaW9idXR0b24tbGlzdD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ0Ryb3Bkb3duJ1wiPlxuICAgICAgICA8YXctZHJvcGRvd24gW2xpc3RdPVwibGlzdFwiXG4gICAgICAgICAgICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICBbbm9TZWxlY3Rpb25TdHJpbmddPVwibm9TZWxlY3Rpb25TdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uU2VsZWN0aW9uKCRldmVudClcIj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjaXRlbVRlbXBsYXRlIGxldC1pdGVtPlxuXG4gICAgICAgICAgICAgICAgPCEtLSB0b2RvOiBhbGxvdyB0byBwYXNzIGEgUElQRSB0byBkbyBzb21lIGFkZGl0aW9uYWwgZm9ybWF0dGluZyAtLT5cbiAgICAgICAgICAgICAgICB7eyBkaXNwbGF5VmFsdWUoaXRlbS52YWx1ZSkgfX1cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvYXctZHJvcGRvd24+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ0Nob29zZXInXCI+XG4gICAgICAgIDxhdy1jaG9vc2VyICNjaG9vc2VyXG4gICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW211bHRpc2VsZWN0XT1cIm11bHRpc2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgW2RhdGFTb3VyY2VdPVwiZGF0YVNvdXJjZVwiXG4gICAgICAgICAgICAgICAgICAgIFt2YWx1ZVRyYW5zZm9ybWVyXT1cImRpc3BsYXlWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuXG4gICAgICAgIDwvYXctY2hvb3Nlcj5cblxuICAgIDwvbmctdGVtcGxhdGU+XG5cbjwvbmctY29udGFpbmVyPlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gR2VuZXJpY0Nob29zZXJDb21wb25lbnQpfSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogQ2hvb3NlckRhdGFTb3VyY2UsIGRlcHM6IFtEYXRhUHJvdmlkZXJzLCBEYXRhRmluZGVyc119XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIE9yZGVyZWQgbGlzdCBvZiBpdGVtcyBhc3NpZ25hYmxlIHRvIHRoZSBrZXkgb2YgdGhlIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb2JqZWN0IHRoaXMgY29udHJvbCBpcyBiZWluZyBhc3NpZ25lZCB0by5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdDogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IGZpZWxkIHBhdGggdGhpcyBjb250cm9sIGlzIGJlaW5nIGFzc2lnbmVkIHRvLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAga2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENhbiBiZSB1c2VkIGluIHBsYWNlIG9mIExJU1QgYmluZGluZyB0byByZXRyaWV2ZSBhIGxpc3QgYmFzZWQgb24gdGhlIENob2ljZVNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiByZXRyaWV2aW5nIGNob2ljZVNvdXJjZSBieSBkZXN0aW5hdGlvbiBjbGFzcyBhbmQgdGhpcyBhcmUgZXh0cmEgcGFyYW1zIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBuYXJyb3cgdGhlIG1hdGNoaW5nIG9yIHRvIHBhc3MgcGFyYW1ldGVycyBpbnRvIENob2ljZVNvdXJjZSBwcm92aWRlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hvaWNlUHJvdmlkZXJQYXJhbXM6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIC8qKlxuICAgICAqICBJcyB0aGlzIGEgTGlzdCBwcm9wZXJ0eSwgb3IgYSB0by1vbmUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtdWx0aXNlbGVjdDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogIFRoZSBzdHlsZSBvZiBjaG9vc2VyIHRvIHVzZSAoUmFkaW8sIENoZWNrYm94LCBEcm9wZG93biwgQ2hvb3NlcilcbiAgICAgKiAgRGVmYXVsdHMgYmFzZWQgb24gY2FyZGluYWxpdHkgb2YgdGhlIGxpc3QgYW5kIHdoZXRoZXIgaXQncyBtdWx0aVNlbGVjdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHR5cGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgY3VzdG9tIGtleS4gaW4gb3JkZXIgdG8gbWFrZSB0aGlzIHdvcmsgd2UgbmVlZCB0byBpbnRyb2R1Y2UgY3VzdG9tIDx0ZW1wbGF0ZXM+IGZvclxuICAgICAqIGFsbCB0aGlzIGNob29zZXIgdHlwZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlLZXk6IHN0cmluZztcblxuICAgIC8vIC8qKlxuICAgIC8vICAqICBTaG91bGQgd2UgYXR0ZW1wdCBhIG1hdGNoIGFzIHRoZXkgdHlwZSAoYWdhaW5zdCB0aGUgZnVsbCBsaXN0KVxuICAgIC8vICAqL1xuICAgIC8vIEBJbnB1dCgpXG4gICAgLy8gYWxsb3dGdWxsTWF0Y2hPbklucHV0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlbmRlcmVkIGFzIGZpcnN0IHZhbHVlIGluIHRoZSBkcm9wZG93biB3aGljaCBsZXQgdGhlIHVzZXIgdG8gbWFrZSAnbm8gc2VsZWN0aW9uJ1xuICAgICAqIGZyb20gYXZhaWxhYmxlIGxpc3Qgb2YgdmFsdWVzLiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSBhbmQgdXNlIG1ha2UgdGhpcyBzZWxlY3Rpb24gd2VcbiAgICAgKiBzYXZlIGEgTlVMTCB2YWx1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9TZWxlY3Rpb25TdHJpbmc6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogR2VuZXJpYyBDaG9vc2VyIHdvcmtzIGRpcmVjdGx5IHdpdGggb2JqZWN0IGFuZCBpdHMgcmVmZXJlbmNlcyBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhpc1xuICAgICAqIGtleXBhdGggdG8gYmUgYWJsZSB0byBzZXQvZ2V0IHZhbHVlIGZyb20gdGFyZ2V0IG9yIHBhcmVudCBvYmplY3RcbiAgICAgKi9cbiAgICBrZXlQYXRoOiBGaWVsZFBhdGg7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHB1YmxpYyBkYXRhU291cmNlOiBDaG9vc2VyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm9iamVjdCkpIHtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0ID0gKDxhbnk+dGhpcy5fdmlld0NvbnRhaW5lci5pbmplY3Rvcikudmlldy5jb250ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5UGF0aCA9IG5ldyBGaWVsZFBhdGgodGhpcy5rZXkpO1xuICAgICAgICBsZXQgZGVmYXVsdERhdGFQcm92aWRlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICBkZWZhdWx0RGF0YVByb3ZpZGVyID0gdGhpcy5kYXRhU291cmNlLmRhdGFQcm92aWRlcnMuZmluZCh0aGlzLmxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVmYXVsdERhdGFQcm92aWRlciA9IHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXJzLmZpbmQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwcm9qZWN0ZWRTaXplID0gZGVmYXVsdERhdGFQcm92aWRlci5leHBlY3RlZENvdW50KHRoaXMuY2hvaWNlUHJvdmlkZXJQYXJhbXMpO1xuICAgICAgICB0aGlzLmluaXRUeXBlKHByb2plY3RlZFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdDaG9vc2VyJykge1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICAgICAgZGF0YVByb3ZpZGVyOiBkZWZhdWx0RGF0YVByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHF1ZXJ5VHlwZTogUXVlcnlUeXBlLkZ1bGxUZXh0LFxuICAgICAgICAgICAgICAgIGxvb2t1cEtleTogdGhpcy5kaXNwbGF5S2V5LFxuICAgICAgICAgICAgICAgIHN0YXRlOiBuZXcgQ2hvb3NlclN0YXRlKG5ldyBHQ0Nob29zZXJTdGF0ZSh0aGlzKSwgdGhpcy5tdWx0aXNlbGVjdCksXG4gICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBkbyB3ZSBuZWVkIHRvIHJlYWQgdGhpcyB2YWx1ZSBpbiBhc3luYz9cbiAgICAgICAgICAgIHRoaXMubGlzdCA9IGRlZmF1bHREYXRhUHJvdmlkZXIuZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWlyZWQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMubm9TZWxlY3Rpb25TdHJpbmcgPSB0aGlzLmkxOG4uaW5zdGFudCgnV2lkZ2V0cy5nY2hvb3Nlci5ub1NlbFN0cmluZycpO1xuICAgICAgICAgICAgdGhpcy5ub1NlbGVjdGlvblN0cmluZyA9ICdTZWxlY3QgYSBJdGVtJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBASW5wdXQgdHlwZSBpcyBub3QgcGFzc2VkIHdlIHRyeSB0byBndWVzcyBhbmQgc2VsZWN0IHRoZSBiZXN0IHR5cGUgZm9yIGN1cnJlbnQgZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0VHlwZShwcm9qZWN0ZWRTaXplOiBudW1iZXIpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IChwcm9qZWN0ZWRTaXplIDw9IDAgfHwgcHJvamVjdGVkU2l6ZSA+IDgpID8gJ0Nob29zZXInIDogJ0NoZWNrYm94JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gKHByb2plY3RlZFNpemUgPD0gMCB8fCBwcm9qZWN0ZWRTaXplID4gMjApID8gJ0Nob29zZXInXG4gICAgICAgICAgICAgICAgICAgIDogKHByb2plY3RlZFNpemUgPCA2KSA/ICdSYWRpbycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ0Ryb3Bkb3duJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSBjZXJ0YWluIHByb3BlcnRpZXMgd2hpY2ggYXJlIHJlcXVpcmVkIGJ5IHRoaXMgY29tcG9uZW50LiBBcyBhbHJlYWR5IG1lbnRpb25lZFxuICAgICAqIGFib3ZlIEdlbmVyaWNDaG9vc2VyIHdvcmtzIHdpdGggcmVmZXJlbmNlcyBhbmQgdGhlZm9yZSB0d28ga2V5IHByb3BlcnRpZXMgYXJlIG9iamVjdCBhbmQga2V5XG4gICAgICogc28gd2UgY2FuIGFjY2VzcyBhbiBvYmplY3RcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVJlcXVpcmVkKClcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMub2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGEgb2JqZWN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmtleSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBhIGtleSBiaW5kaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5saXN0KSAmJiBpc0JsYW5rKHRoaXMuZGVzdGluYXRpb25DbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgY29udGludWUgd2l0aG91dCBoYXZpbmcgZWl0aGVyIGxpc3Qgb2YgdmFsdWVzIG9yIGRlc3RpbmF0aW9uQ2xhc3MnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlKSAmJlxuICAgICAgICAgICAgKHRoaXMudHlwZSAhPT0gJ1JhZGlvJyAmJiB0aGlzLnR5cGUgIT09ICdDaGVja2JveCcgJiYgdGhpcy50eXBlICE9PSAnRHJvcGRvd24nICYmXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlICE9PSAnQ2hvb3NlcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGluc3RhbnRpYXRlIEdlbmVyaWNDaG9vc2VyICAtIGludmFsaWQgdHlwZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kaXNwbGF5S2V5KSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5S2V5ID0gJ3RvU3RyaW5nJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB3aGVuIGRpc3BsYXlpbmcgdmFsdWUgYm90aCBmcm9tIHByaW1pdGl2ZSB0eXBlIGFzIHdlbGwgY29tcGxleCBvYmplY3QuIElmIHlvdSB3YW50IHRvXG4gICAgICogY29udHJvbCBob3cgaXRlbSBpcyBkaXNwbGF5ZWQgeW91IGNhbiBwcm92aWRlIGRpc3BsYXkga2V5LCB3aGljaCBpcyBjYW4gYmUgYSAgbWV0aG9kIG9yXG4gICAgICogcHJvcGVydHkgb2YgdGhlIG9iamVjdCB5b3UgYXJlIGRpc3BsYXlpbmcuXG4gICAgICpcbiAgICAgKiBUb2RvOiB0aGluayBhYm91dCBmb3JtYXR0ZXJzIGFzIHdlbGxcbiAgICAgKlxuICAgICAqL1xuICAgIGRpc3BsYXlWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGlzcGxheUtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoaXRlbSwgdGhpcy5kaXNwbGF5S2V5KTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWVsZFZhbHVlLmNhbGwoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgUmV0cmlldmUgYSBjdXJyZW50IHZhbHVlIGZyb20gdGhlIHBhcmVudC90YXJnZXQgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uKCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5UGF0aC5nZXRGaWVsZFZhbHVlKHRoaXMub2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgc2V0IHZhbHVlIGJhY2sgdG8gdGhlIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgc2V0IHNlbGVjdGlvbih2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5rZXlQYXRoLnNldEZpZWxkVmFsdWUodGhpcy5vYmplY3QsIHZhbHVlKTtcbiAgICB9XG5cblxuICAgIG9uU2VsZWN0aW9uKHZhbHVlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KCk7XG5cbiAgICB9XG59XG5cbi8qKlxuICogR2VuZXJpY0Nob29zZXIgaW1wbGVtZW50YXRpb24gb2YgdGhlIENob29zZXJTZWxlY3Rpb25TdGF0ZSB3aGljaCBpcyB1c2VkIHdoZW4gVHlwZSA9IENob29zZXIuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgR0NDaG9vc2VyU3RhdGUgZXh0ZW5kcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZ0Nob29zZXI6IEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IHRoaXMuaXNTZWxlY3RlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gaW1wbGVtZW50IHNtYXJ0ZXIgYW5kIG1vcmUgZ2VuZXJpYyB3YXkgaG93IHdlIHVzZSBpdCBpbiBqYXZhXG4gICAgICAgICAgICAvLyBSZWxhdGlvbnNoaXBGaWVsZC5hZGRUbyhfb2JqZWN0LCBfa2V5UGF0aCwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgbGV0IG11bHRpUmVsOiBBcnJheTxhbnk+ID0gdGhpcy5nQ2hvb3Nlci5rZXlQYXRoLmdldEZpZWxkVmFsdWUodGhpcy5nQ2hvb3Nlci5vYmplY3QpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsobXVsdGlSZWwpKSB7XG4gICAgICAgICAgICAgICAgbXVsdGlSZWwgPSBbXTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQobXVsdGlSZWwpICYmICFpc0FycmF5KG11bHRpUmVsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSSBjYW4gbm90IHN0b3JlIG11bHRpc2VsZWN0IHZhbHVlIGludG8gbm9uLWFycmF5IG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVJlbC5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb24gPSBtdWx0aVJlbDtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBMaXN0V3JhcHBlci5yZW1vdmVJZkV4aXN0KG11bHRpUmVsLCBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3QoKTogYW55XG4gICAge1xuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgbGV0IG9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICAgICAgcmV0dXJuIChpc0JsYW5rKG9iamVjdHMpIHx8IExpc3RXcmFwcGVyLmlzRW1wdHkob2JqZWN0cykpID8gbnVsbCA6IExpc3RXcmFwcGVyLmxhc3QoXG4gICAgICAgICAgICAgICAgb2JqZWN0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICBsZXQgc2VsZWN0aW9uID0gdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0ICYmIGlzQmxhbmsoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0ICYmIGlzQXJyYXkoc2VsZWN0aW9uKSkgPyBzZWxlY3Rpb24gOiBbc2VsZWN0aW9uXTtcbiAgICB9XG5cbiAgICBpc1NlbGVjdGVkKHNlbGVjdGlvbjogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5jb250YWluc0NvbXBsZXgodGhpcy5zZWxlY3RlZE9iamVjdHMoKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VyVmFsdWUgPSB0aGlzLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgICAgIHJldHVybiBlcXVhbHMoY3VyVmFsdWUsIHNlbGVjdGlvbik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBmb3IgUmFkaW9CdXR0b24gY29tcG9uZW50IHByb3ZpZGluZyBjb252ZW5pZW50IHdheSB0byB0byByZW5kZXIgUmFkaW9CdXR0b24gR3JvdXBzXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICpcbiAqIGBgYFxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnZ2VuZGVyLXNlbGVjdG9yJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cInJiTGlzdFZhbHVlc1wiIFtsYXlvdXRdPVwibGF5b3V0XCJcbiAqICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGVkVmFsdWVcIiBbbmFtZV09XCInbmFtZSdcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICogICAgICBgXG4gKiAgICAgIH0pXG4gKiAgICAgIGV4cG9ydCBjbGFzcyBHZW5kZXJTZWxlY3RvckNvbXBvbmVudFxuICogICAgICB7XG4gKiAgICAgICAgICByYkxpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydtYWxlJyAsICdmZW1hbGUnICwgJ290aGVyJ107XG4gKiAgICAgICAgICBzZWxlY3RlZFZhbHVlOiBzdHJpbmcgPSAnb3RoZXInO1xuICogICAgICAgICAgbGF5b3V0OiBzdHJpbmcgPSAnc3RhY2tlZCc7XG4gKlxuICpcbiAqICAgICAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgICAgIG9uQ0JDbGljayAoZXZlbnQpOiB2b2lkXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgICAgICB9XG4gKlxuICogICAgICB9XG4gKlxuICogYGBgXG4gKi9cblxuXG5leHBvcnQgY29uc3QgUkJfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJhZGlvYnV0dG9uLWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBsaXN0OyAgbGV0IGkgPSBpbmRleFwiIGNsYXNzPVwidWktZ1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLWctMTJcIj5cbiAgICAgICAgPGF3LXJhZGlvYnV0dG9uXG4gICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJpXCJcbiAgICAgICAgICAgIFtsYWJlbF09XCJsYWJlbFZhbHVlKGl0ZW0pXCI+XG4gICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIExJc3Qgb2YgdmFsdWVzIHVzZWQgdG8gcmVuZGVyIHRoZSByYWRpbyBidXR0b24gZ3JvdXBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIHdoaWNoIHJhZGlvIGJ1dHRvbnMgaXMgc2VsZWN0ZWQgd2hlbiByZW5kZXJlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIHNwZWNpYWwgZXhwcmVzc2lvbiB0byBmb3JtYXQgbGFiZWxcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsRm9ybWF0dGVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVzIGFuIGV2ZW50IHdoZW4gcmFkaW8gYnV0dG9uIGlzIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgbW9kZWwgdG8gbGlzdGVuIGZvciByYWRpbyB2YWx1ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgaXMgZXh0cmFjdGVkIGludG8gYSBtZXRob2Qgc28gaW4gdGhlIGZ1dHVyZSB3ZSBjYW4gcGxheSBob3cgd2Ugd2FudCB0byBkaXNwbGF5IHRoZVxuICAgICAqIHZhbHVlLiBTaW5jZSBJIHdhbnQgdG8gc3VwcG9ydCBmb3JtYXR0ZXJzIGZvciBlYWNoIGNvbXBvbmVudHMgd2UgbWlnaHQgaGF2ZSBhIGNoYW5jZSB0b1xuICAgICAqIGRlY2lkZSBob3cgdGhlIGxhYmVsIHdpbGwgbG9vayBsaWtlLlxuICAgICAqXG4gICAgICovXG4gICAgbGFiZWxWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sYWJlbEZvcm1hdHRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm9ybWF0dGVyKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbiB0aGlzIHZlcnNpb24gb2YgY2hlY2tib3hlcyB3ZSBzdGlsbCBleHBlY3Qgb25seSBwcmltaXRpdmUgdHlwZXMuIEtlZXAgdGhpcyBmdW5jdGlvbmFsaXR5XG4gICAgICogaW4gZXh0cmEgbWV0aG9kIHNvIHdlIGNhbiB3b3JrIHdpdGggaXQgZXZlbiBub3cgd2UganVzdCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgYmFja1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICB2YWx1ZShpdGVtOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPbiBOR01vZGVsIGNoYW5nZSByZXRyaWV2ZSBhY3R1YWwgcmVjb3JkIGJhc2VkIG9uIHRoZSBJTkRFWCBhbmQgcHJvcGFnYXRlIGl0IHRvIGJvdGhcbiAgICAgKiBuZ01vZGVsIGFzIHdlbGwgYXMgRm9ybUdyb3VwLlxuICAgICAqXG4gICAgICovXG4gICAgb25DaGFuZ2UoZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueSA9IHRoaXMubGlzdFt0aGlzLm1vZGVsXTtcblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBjb21wbGV4IG9iamVjdCBzdG9yZSBvbmx5IElOREVYIG51bWJlciBpbiB0aGUgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVNb2RlbChzb3VjZUl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubGlzdC5maW5kSW5kZXgoKGVsZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIHNvdWNlSXRlbSA9PT0gZWxlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubW9kZWwgPSBpbmRleCA9PT0gLTEgPyAwIDogaW5kZXg7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueSA9IHRoaXMubGlzdFt0aGlzLm1vZGVsXTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh1cGRhdGVkTW9kZWwsIHtcbiAgICAgICAgICAgIGVtaXRFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGVtaXRWaWV3VG9Nb2RlbENoYW5nZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgbGV0IG5ld01vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKG5ld01vZGVsKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIEltcGxlbWVudHMgc3RhbmRhcmQgSFRNTCByYWRpbyBidXR0b24gb24gdG9wIG9mIFByaW1lTkcgd2l0aCBhcmliYSBzdHlsaW5nXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiAxLiBCYXNpYyB1c2FnZSB1c2luZyBuZ01vZGVsIHByZS1zZWxlY3RlZCBmaXJzdCByYWRpb1xuICpcbiAqICBgYGB0c1xuICpcbiAqICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICBzZWxlY3RvcjogJ2RlbW8tY29tcCcsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICogICAgICAgICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInY29sb3InXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKiAgICAgIGBcbiAqICAgICAgfSkqXG4gKiAgICAgIGNsYXNzIEJhc2ljV2l0aE5nTW9kZWxDb21wb25lbnRcbiAqICAgICAge1xuICogICAgICAgICAgbW9kZWw6IHN0cmluZ1tdID0gWydyZWQnXTtcbiAqXG4gKiAgICAgICAgICBjb25zdHJ1Y3RvcigpXG4gKiAgICAgICAgICB7XG4gKiAgICAgICAgICB9XG4gKiAgICAgIH1cbiAqXG4gKiAgYGBgXG4gKlxuICpcbiAqIDIuIEJhc2ljIHVzYWdlIHdpdGggZm9ybUdyb3VwXG4gKlxuICpcbiAqIGBgYHRzXG4gKiAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICBzZWxlY3RvcjogJ2RlbW8tY29tcCcsXG4gKiAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgIDxkaXYgW2Zvcm1Hcm91cF09XCJlbnYuY3VycmVudEZvcm1cIj5cbiAqICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcjInXCIgW3ZhbHVlXT1cIidyZWQnXCIgW2xhYmVsXT1cIidSZWQnXCJcbiAqICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIj5cbiAqICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcjInXCIgW3ZhbHVlXT1cIidibHVlJ1wiIFtsYWJlbF09XCInQmx1ZSdcIlxuICogICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICpcbiAqICAgICAgIDwvZGl2PlxuICogICAgICAgYFxuICogICAgICAgfSlcbiAqICAgICAgIGNsYXNzIEJhc2ljV2l0aEZvcm1Hcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdFxuICogICAgICAge1xuICogICAgICAgICAgIG1vZGVsOiBzdHJpbmcgPSAnYmx1ZSc7XG4gKlxuICogICAgICAgICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgIG5nT25Jbml0KCk6IHZvaWRcbiAqICAgICAgICAgICB7XG4gKiAgICAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKiAgICAgICAgICAgICAgIHRoaXMuZW52LmN1cnJlbnRGb3JtLnJlZ2lzdGVyQ29udHJvbCgnY29sb3IyJywgbmV3IEZvcm1Db250cm9sKHRoaXMubW9kZWwpKTtcbiAqICAgICAgICAgICB9XG4gKlxuICpcbiAqICAgICAgICAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgdGhpcy5tb2RlbFNldCA9IGV2ZW50O1xuICogICAgICAgICAgIH1cbiAqXG4gKiAgICAgICB9XG4gKiAgYGBgYFxuICpcbiAqXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IFJBQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmFkaW9idXR0b24nLFxuICAgIHRlbXBsYXRlOiBgPHNwYW4gY2xhc3M9XCJ3LXJhZGlvYnV0dG9uXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGUgXCI+XG4gICAgICAgIDxwLXJhZGlvQnV0dG9uIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxdPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwib25Nb2RlbENoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnUtdmFsaWRhdGlvbi1lcnJvcl09XCIhKGZvcm1Db250cm9sLnZhbGlkIHx8IChmb3JtQ29udHJvbC5wcmlzdGluZSkpXCI+XG4gICAgICAgIDwvcC1yYWRpb0J1dHRvbj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9zcGFuPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC53LXJhZGlvYnV0dG9uIC51aS1yYWRpb2J1dHRvbi1ib3h7d2lkdGg6MjNweDtoZWlnaHQ6MjNweDtsaW5lLWhlaWdodDoyM3B4fS9kZWVwLyAudy1yYWRpb2J1dHRvbiAudWktcmFkaW9idXR0b24taWNvbntmb250LXNpemU6MS41ZW07bGluZS1oZWlnaHQ6MWVtfWBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJBQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhpcyByYWRpb1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgYSByYWRpb1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBjbGljayBldmVudCB3aXRoIGN1cnJyZW50IHNlbGVjdGVkIHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsIHRvIGNvbXVuaWNhdGUgd2l0aCBwcmltZU5nIFJhZGlvXG4gICAgICovXG4gICAgbW9kZWw6IGFueTtcblxuXG4gICAgY29uc3RydWN0b3IgKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0ICgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdGhpcy5mb3JtQ29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiByYWRpbyBpcyBjbGlja2VkLiBOb3QgdXNpbmcgUHJpbWVORyBjbGljayBldmVudCBhcyBpdCBpcyBmaXJlZCBiZWZvcmVcbiAgICAgKiB0aGUgbW9kZWwgaXMgY2hhbmdlZC4gVGhlcmVmb3JlIG5lZWQgdG8gbGlzdGVuIG9uIChuZ01vZGVsQ2hhbmdlKVxuICAgICAqXG4gICAgICovXG4gICAgb25Nb2RlbENoYW5nZSAobmV3VmFsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMubW9kZWwpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5tb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLm1vZGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSAodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5tb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7UmFkaW9CdXR0b25Db21wb25lbnR9IGZyb20gJy4vcmFkaW8tYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQge1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmFkaW9CdXR0b25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1JhZGlvQnV0dG9uTGlzdENvbXBvbmVudH0gZnJvbSAnLi9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25MaXN0Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7R2VuZXJpY0Nob29zZXJDb21wb25lbnR9IGZyb20gJy4vZ2VuZXJpYy1jaG9vc2VyLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hMaXN0TW9kdWxlfSBmcm9tICcuLi9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0Nob29zZXJNb2R1bGV9IGZyb20gJy4uL2Nob29zZXIvY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi4vZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBHZW5lcmljQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgR2VuZXJpY0Nob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0dlbmVyaWNDaG9vc2VyTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtFbnRpdHksIGlzQmxhbmssIGlzRW50aXR5LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPdXRsaW5lRm9yQ29tcG9uZW50fSBmcm9tICcuL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5cbi8qKlxuICogT3V0bGluZVN0YXRlIGlzIHRoZSBrZXkgZ2x1aW5nIHBhcnQgZm9yIHRoZSBPdXRsaW5lRm9yIGFuZCBPdXRsaW5lQ29udHJvbGxlciBjb21wb25lbnRzLiBJdFxuICogaG9sZHMgYWxsIGltcG9ydGFudCBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgb3V0bGluZSB0cmVlIGFuZCBtYW5hZ2VzIGV4cGFuc2lvbiBzdGF0ZXMgaW4gZm9ybVxuICogb2Ygc28gY2FsbGVkIGV4cGFuc2lvblBhdGggYW5kIGV4cGFuc2lvblN0YXRlc1xuICpcbiAqIFdlIG5lZWQgdG8gaGF2ZSBhIHdheSBob3cgdG8gd29yayB3aXRoIGdlbmVyaWMgZGF0YSBzdHJ1Y3R1cmUgaW4gb3JkZXIgbm90IHRvIGhvbGQgVUkgc3BlY2lmaWNcbiAqIGluZm9ybWF0aW9uIG9uIHRoZSBkb21haW4gb2JqZWN0IG1vZGVsIGp1c3QgbGlrZSB3ZSBoYWQgaXQgYmVmb3JlLCB3aGVyZSB3ZSBoYWQgYW4gaW50ZXJmYWNlXG4gKiBjYWxsZWQgT3V0bGluZU5vZGUsIHdpdGggZmllbGRzIChleHBhbmRlZCwgc2VsZWN0ZWQsIGV0Yy4uIClcbiAqXG4gKlxuICogYGV4cGFuc2lvblBhdGhgOiBIb2xkcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgYW5kIGV4cGFuZGVkIG5vZGVzLiBUaGlzIGlzIGZpbGxlZCBieVxuICogT3V0bGluZUNvbnRyb2xsZXIuXG4gKlxuICpcbiAqIElmIHdlIGFyZSBkZWFsaW5nIHdpdGggRW50aXR5IG9yIGFueXRoaW5nIHRoYXQgaGFzIGlkZW50aXR5IHRoZW4gd2UgaGF2ZSBlYXNpZXIgc2l0dWF0aW9uIGFzIHdlXG4gKiBjYW4gYXNrIGZvciBJRCBhbmQgaXQgaXMgbW9yZSBlZmZpY2llbnQgZm9yIHNlcmlhbGl6YXRpb25cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE91dGxpbmVTdGF0ZVxue1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBhbmQgZXhwYW5kZWQgbm9kZXNcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgX2V4cGFuc2lvblBhdGg6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBgYWxsb3dTZWxlY3Rpb25gIGlzIGVuYWJsZWQgb24gT3V0bGluZUNvbnRyb2wgaXQgc2F2ZWQgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0gdG8gYmVcbiAgICAgKiBhYmxlIGxhdGVyIG9uIGFwcGx5IHNvbWUgc3R5bGluZyBhbmQgYnJvYWRjYXN0IHRoaXMgc2VsZWN0aW9uIG91dHNpZGUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBzZWxlY3RlZEl0ZW06IGFueTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWFwcyBvYmplY3QgcmVmZXJlbmNlIHRvIGJvb2xlYW4gdmFsdWVzLCB3aGVyZSBUUlVFIG1lYW5zIEVYUEFOREVELCBGQUxTRSBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGV4cGFuc2lvblN0YXRlczogTWFwPGFueSwgYm9vbGVhbj47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBvdXRsaW5lIGlzIHJlbmRlcmVkIGZvciBmaXJzdCB0aW1lIG9yIHJlLXJlbmRlcmVkIGFuZCB3ZSBzZXQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlXG4gICAgICogZXhwYW5zaW9uU3RhdGVzLiBUaGlzIHdheSB3ZSBjYW4gcHJldHR5IGVhc2lseSBleGVjdXRlIENvbGxhcHNlQWxsLCBFeHBhbmRBbGxcbiAgICAgKlxuICAgICAqL1xuICAgIGdsb2JhbFN0YXRlOiBib29sZWFuID0gZmFsc2U7IC8vIGNvbGxhcHNlZFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBIb2xkcyBjdXJyZW50IGxldmVsIGR1cmluZyB0cmVlIG5vZGUgcmVuZGVyaW5nIHNvIHdlIGNhbiBhcHBseSBjb3JyZWN0IGluZGVudGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50TGV2ZWw6IG51bWJlciA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBkdXJpbmcgYSB0b2dnbGUgYWN0aW9uIHRvIHJlY29yZCBjdXJyZW50IHNlbGVjdGlvbiBwYXRoLlxuICAgICAqXG4gICAgICovXG4gICAgY3VycmVudFBhdGg6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWxseSBzaGFyZWQgcHJvcGVydHlcbiAgICAgKi9cbiAgICBvdXRsaW5lRm9yOiBPdXRsaW5lRm9yQ29tcG9uZW50O1xuXG5cbiAgICBjb25zdHJ1Y3RvciAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBjb2xsYXBzZUFsbCBhbmQgZXhwYW5kQWxsIHdlIGFyZSB1c2luZyBzaW1wbGUgbWVjaGFuaXNtIHdoZXJlIHdlIGNsZWFuIHVwIGFsbFxuICAgICAqIHNlbGVjdGlvbiBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBleHBhbmQgc3RhdGUsIHRoaXMgd2hleSBpc0V4cGFuZCBtZXRob2QgcmV0dXJucyB0aGUgc2FtZVxuICAgICAqIHN0YXRlIGZvciBhbGwgaXRlbXNcbiAgICAgKi9cbiAgICBjb2xsYXBzZUFsbCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGV4cGFuZEFsbCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxTdGF0ZSA9IHRydWU7XG4gICAgfVxuXG5cbiAgICBnZXQgZXhwYW5zaW9uUGF0aCAoKTogYW55W11cbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX2V4cGFuc2lvblBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvblBhdGg7XG4gICAgfVxuXG5cbiAgICBzZXQgZXhwYW5zaW9uUGF0aCAodmFsdWU6IGFueVtdKVxuICAgIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uUGF0aCA9IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuX2V4cGFuc2lvblBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uUGF0aC5mb3JFYWNoKChpdGVtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUoaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uIChjdXJyZW50UGF0aDogYW55W10sIGNoaWRyZW4/OiBhbnlbXSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoY3VycmVudFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgbGV0IGl0ZW1DaGlsZHJlbiA9IGNoaWRyZW4gfHwgW107XG4gICAgICAgIGxldCBuZXdTdGF0ZSA9ICF0aGlzLmlzRXhwYW5kZWQoaXRlbSk7XG4gICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUoaXRlbSwgbmV3U3RhdGUpO1xuXG4gICAgICAgIGlmICghbmV3U3RhdGUpIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUxhc3QoY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgaXRlbUNoaWxkcmVuLmZvckVhY2goKGNoaWxkOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShjaGlsZCwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEV4cGFuc2lvblBhdGgoY3VycmVudFBhdGgpO1xuICAgIH1cblxuICAgIHNldEV4cGFuc2lvblN0YXRlIChpdGVtOiBhbnksIGlzRXhwYW5kZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgIGlmIChpc0V4cGFuZGVkID09PSB0aGlzLmdsb2JhbFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLnNldChrZXksIChpc0V4cGFuZGVkKSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBpbXByb3ZlIHN0YXRlIHBlcnNpc3RpbmcgbGV0cyBjaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIE9iamVjdCB0aGF0IGhhcyBJZGVudGl0eVxuICAgICAqIHNvIHdlIGNhbiBleHRyYWN0IGFuIElEIG90aGVyd2lzZSB1c2Ugb2JqZWN0IHRvIGNvbXBhcmUgYnkgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXRlbVRvS2V5IChpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBpc0VudGl0eShpdGVtKSA/ICg8RW50aXR5Pml0ZW0pLmlkZW50aXR5KCkgOiBpdGVtO1xuICAgIH1cblxuXG4gICAgc2V0RXhwYW5zaW9uUGF0aCAoaXRlbTogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblBhdGggPSBpdGVtO1xuXG4gICAgICAgIGl0ZW0uZm9yRWFjaCgobm9kZTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKG5vZGUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpc0V4cGFuZGVkIChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgIGlmICghdGhpcy5leHBhbnNpb25TdGF0ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbFN0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuc2lvblN0YXRlcy5nZXQoa2V5KTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthbmltYXRlLCBBbmltYXRpb25CdWlsZGVyLCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXJ9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi9vdXRsaW5lLXN0YXRlJztcblxuXG4vKipcbiAqXG4gKiBPdXRsaW5lRm9yQ29tcG9uZW50IGlzIGxpa2UgbmdGb3IsIGJ1dCBmb3IgaGllcmFyY2hpY2FsIChvdXRsaW5lL3RyZWUpIHN0cnVjdHVyZXMgLS0gaS5lLiBpblxuICogdGhvc2UgY2FzZXMgd2hlcmUgYW4gaXRlbSBtYXkgaGF2ZSBjaGlsZHJlbi5cbiAqXG4gKlxuICogSXQgdXNlcyBvdXRsaW5lIGA8YXctb3V0bGluZS1jb250cm9sPmAgdG8gcHJvdmlkZSBleHBhbmRpbmcgZnVuY3Rpb25hbGl0eSwgaW5kZW50YXRpb25cbiAqIGFuZCBvdGhlciB0aGluZ3MuXG4gKlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGhhcyBtaW5pbWFsIHN0eWxpbmcgdG8gbWFrZSBzdXJlIGl0IGNhbiBiZSBjaGFuZ2VkIGVhc2lseS5cbiAqXG4gKiAjIyMgRXhhbXBsZSByZW5kZXJpbmcgdHJlZSBzZWN0aW9uLCB3aGVyZSBiYXNlZCBvbiB0aGUgdHlwZSB3ZSBmb3JtYXQgdGhlIG91dCBwbHVzXG4gKiBmb3IgdGhlIG1haW4gcm9vdCBzZWN0aW9uIHdlIGFsd2F5cyByZW5kZXIgbGl0dGxlIHBvcHVwIG1lbnUuXG4gKlxuICogYGBgXG4gKlxuICogICA8YXctb3V0bGluZS1mb3IgW2xpc3RdPVwibGlzdFwiIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiPlxuICpcbiAqICAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqXG4gKiAgICAgICAgICAgPGRpdiBjbGFzcz1cIm15LXNlY3Rpb25cIj5cbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm91dGxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxhdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdTd2l0Y2hdPVwiaXRlbS50eXBlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdTd2l0Y2hDYXNlXT1cIid0ZXh0J1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImFzLXBhcmFncmFmXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3tpdGVtPy5jb250ZW50fX1cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBuZ1N3aXRjaERlZmF1bHQ+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDwvYXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqXG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJmaWx0ZXJzXCIgKm5nSWY9XCJpdGVtLnR5cGUgPT09ICdzZWN0aW9uJ1wiID5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICA8YXctaG92ZXItY2FyZCBbbGlua1RpdGxlXT1cIidGaWx0ZXIgSXRlbXMnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPGF3LWxpc3QgW2xpc3RdPVwiZmlsdGVySXRlbXNcIiBbYm9yZGVybGVzc109XCJ0cnVlXCI+PC9hdy1saXN0PlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1ob3Zlci1jYXJkPlxuICpcbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgPC9uZy10ZW1wbGF0ZT5gXG4gKiAgIDwvYXctb3V0bGluZS1mb3I+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFdlIGNhbiB1c2UgaXQgYWxzbyBpbiBlbWJlZGRlZCBtb2RlIHdoZXJlIHdlIHVzZSB0aGUgYGF3T3V0bGluZUZvcmAgZGlyZWN0aXZlXG4gKlxuICogIyMgRXhhbXBsZVxuICpcbiAqXG4gKiBgYGBgXG4gKiAgPHRhYmxlICBjbGFzcz1cInRyZWUtdGFibGVcIiA+XG4gKiAgICAgIDx0aGVhZD5cbiAqICAgICAgICAgIDx0cj5cbiAqICAgICAgICAgICAgICA8dGg+TmFtZTwvdGg+XG4gKiAgICAgICAgICAgICAgPHRoPlR5cGU8L3RoPlxuICogICAgICAgICAgPC90cj5cbiAqICAgICAgPC90aGVhZD5cbiAqICAgICAgPHRib2R5ICNvb28yIGF3T3V0bGluZUZvciBbbGlzdF09XCJsaXN0XCJcbiAqICAgICAgICAgICAgIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiXG4gKiAgICAgICAgICAgICBjbGFzcz1cIm91dGxpbmUtdGFibGVcIlxuICogICAgICA+XG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUgI291dGxpbmUgbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9XCJpdGVtLW5hbWUgb3V0bGluZS1hbmltYXRpb25cIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+PC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gKiAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIml0ZW0tdHlwZSBvdXRsaW5lLWFuaW1hdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgPGRpdj57e2l0ZW0udHlwZX19PC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gKiAgICAgICAgICAgICAgPC90cj5cbiAqICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgIDwvdGJvZHk+XG4gKiAgPC90YWJsZT5cbiAqXG4gKiBgYGBcbiAqXG4gKiBJIHdhcyB0aGlua2luZyBtYXliZSBmb3IgZmlyc3QgdGltZSB3ZSBkb24ndCBuZWVkIHRoZSBzYW1lIGFuaW1hdGlvbiBsaWtlIGV4cGFuZGluZyBhbmRcbiAqIGNvbGxhcHNpbmcuIE1heWJlIHdlIG5lZWQgZmFkZS1pbi4gSW4gc3VjaCBjYXNlIEkgd291bGQgcHJvYmFibHkgYXBwbHkgQHNlY3Rpb24gYW5pbSBvbmx5XG4gKiBvbiBpdGVtcyB3aGVyZSBsZXZlbCA+IDAgKGluIHRoZSB0ZW1wbGF0ZSBJIGtlZXAgbGV2ZWxzKSBhbmQgaWYgbGV2ZWwgPT0gMCB0aGVuIEkgd291bGRcbiAqIGV4ZWN1dGUgdGhlIHNhbWUgcmVuZGVyaW5nIGp1c3Qgd2l0aG91dCBbQHNlY3Rpb25dXG4gKlxuICpcbiAqIFRvZG86IFRoaW5rIGFib3V0IGhvdyB0byBkbyBhbmltYXRpb24gZm9yIHRoZSB0YWJsZSBjYXNlLiBNdXN0IGFsc28gd3JpdGUgdW5pdGVzdCAtIGR1ZSB0b1xuICogQXJpYmFMaXZlIGFnZ3Jlc3NpdmUgc2NoZWR1bGUgd2UgYXJlIHNraXBwaW5nIHRoZW0gZm9yIG5vd1xuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1vdXRsaW5lLWZvciwgW2F3T3V0bGluZUZvcl0nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFN0YXJ0cyB3aXRoIHRoZSBsaXN0LCB3aGVyZSBuZXN0aW5nTGV2ZWwgaXMgLTEuXG4gICAgY2FsbCB0ZW1wbGF0ZSBvdXRsaW5lSXRlbXMgdG8gaXRlcmF0ZSBhbmQgcmVuZGVyIGVhY2ggaXRlbVxuLS0+XG48bmctY29udGFpbmVyIFtuZ0lmXT1cImxpc3RcIiAqbmdUZW1wbGF0ZU91dGxldD1cIm91dGxpbmVJdGVtcztcbiAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGxpc3QsIG5lc3RpbmdMZXZlbDogMCwgcGFyZW50SXRlbTogbnVsbCwgZXhwYW5kZWQ6IHRydWV9XCI+XG48L25nLWNvbnRhaW5lcj5cblxuPCEtLVxuICAgIE1haW4gRW50cnkgcG9pbnQgZm9yIHRoZSByZWN1cnNpb24uIHRoaXMgaXMgY2FsbGVkIGJ5IHRoZSBibG9jayBhYm92ZSBhcyB3ZWxsIGFzIGJ5dCB0aGUgaW5uZXJcbiAgICBwaWVjZSB0aGF0IGNhbGxzIHRoaXMgdGVtcGxhdGUgcmVjdXJzaXZlbHkgYWdhaW4gd2hlbiBhbiBpdGVtIGhhcyBjaGlsZHJlblxuLS0+XG48bmctdGVtcGxhdGUgI291dGxpbmVJdGVtcyBsZXQtY2hpbGRyZW4gbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiXG4gICAgICAgICAgICAgbGV0LXBhcmVudD1cInBhcmVudEl0ZW1cIiBsZXQtZXhwYW5kZWQ9XCJleHBhbmRlZFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1pdGVtIFtuZ0Zvck9mXT1cImNoaWxkcmVuXCIgIGxldC1yb3dJbmRleD1cImluZGV4XCI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm91dGxpbmVJdGVtO1xuICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogaXRlbSwgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsIHBhcmVudEl0ZW06IHBhcmVudCxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBleHBhbmRlZCwgcm93SW5kZXg6cm93SW5kZXh9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDwhLS1cblxuICAgICAgICAgICAgUmVjdXJzaW9uIHBpZWNlOlxuXG4gICAgICAgICAgICBGb3Igbm9uIGVtYmVkZGVkIGNhc2Ugd2hlbiBldmVuIGlmIGl0cyBub3QgZXhwYW5kZWQgd2UgbmVlZCB0byBpdGVyYXRlIGNoaWxkcmVuXG4gICAgICAgICAgICBhcyB3ZSB3YW50IHRvIGFwcGx5IGFuaW1hdGlvbiB0aGF0IHNob3VsZCBnbyB3aXRoIG5nSWYgd2hpY2ggaW5zaWRlIHRoZSBvdXRpbmVJdGVtXG4gICAgICAgICAgICB0ZW1wbGF0ZVxuXG4gICAgICAgICAgICBEb250IHJlY3Vyc2UvIHJlbmRlciBpdGVtcyB0aGF0IGFyZSBub3QgdmlzaWJsZS5cbiAgICAgICAgLS0+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImhhc0NoaWxkcmVuKGl0ZW0pICYmIChpc0V4cGFuZGVkKGl0ZW0sIG5lc3RpbmdMZXZlbCkgfHwgIWVtYmVkZGVkKSAmJiBpc1Zpc2libGUoaXRlbSlcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJvdXRsaW5lSXRlbXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnsgJGltcGxpY2l0OiBjaGlsZHJlbkZvckl0ZW0oaXRlbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsKzEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkOiBpc0V4cGFuZGVkKGl0ZW0sIG5lc3RpbmdMZXZlbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEl0ZW06aXRlbSB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48IS0tXG4gICAgUmVuZGVycyBhY3R1YWwgb3V0bGluZSBub2RlIGFuZCBhcHBsaWVzIGFuaW1hdGlvbiB3aGlsZSBleHBhbmRpbmcgYW5kIGNvbGxhcHNpbmdcblxuICAgIFtAc2VjdGlvbl09XCJleHBhbmRlZCB8fCBpc0V4cGFuZGVkKGl0ZW0pID8gJ3Zpc2libGUnIDogJ2hpZGRlbidcIlxuLS0+XG48bmctdGVtcGxhdGUgI291dGxpbmVJdGVtIGxldC1pdGVtIGxldC1uZXN0aW5nTGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIiBsZXQtcGFyZW50PVwicGFyZW50SXRlbVwiXG4gICAgICAgICAgICAgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIlxuICAgICAgICAgICAgIGxldC1leHBhbmRlZD1cImV4cGFuZGVkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidy1vdXRsaW5lLWl0ZW1cIlxuICAgICAgICAgKm5nSWY9XCIhZW1iZWRkZWQgJiYgZXhwYW5kZWRcIlxuICAgICAgICAgW3N0eWxlLnBhZGRpbmctbGVmdC5weF09XCJpbmRlbnRhdGlvbihuZXN0aW5nTGV2ZWwpXCJcbiAgICAgICAgIGluaXROZXN0aW5nIFtzZXRMZXZlbF09XCJuZXN0aW5nTGV2ZWxcIiBbc2V0UGFyZW50SXRlbV09XCJwYXJlbnRcIlxuICAgICAgICAgW3NldEN1cnJyZW50SXRlbV09XCJpdGVtXCJcbiAgICAgICAgIFtAc2VjdGlvbl1cbiAgICAgICAgIChAc2VjdGlvbi5kb25lKT1cIm9uQW5pbWF0aW9uRG9uZSgkZXZlbnQpXCI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRyb2xUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGl0ZW0sIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsLCByb3dJbmRleDpyb3dJbmRleCB9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLVxuICAgICAgICBXaGVuIG91dGxpbmUgY29udHJvbCBpcyB1c2VkIGFzIGVtYmVkZGVkIG1lYW5pbmcgaXRzIGluc2lkZSBlLi5nIGRhdGF0YWJsZSB3ZVxuICAgICAgICBjYW5ub3QgaGF2ZSBhbnkgdGFncyBhcm91bmQgaXQuXG5cbiAgICAgICAgVG9kbzogUmVmYWN0b3IgdGhpcyBpbiB0aGUgd2F5IHNvIHdlIGNhbiBkbyBhbmltYXRpb24gd2hlbiB0YWJsZSBsaW5lcyBhcmVcbiAgICAgICAgZXhwYW5kZWQuIFNpbmNlIGl0cyBlbWJlZGRlZCB3ZSBjYW4gbm90IGhhdmUgYW55IHdyYXBwaW5nIGVsZW1lbnQgYXJvdW5kLCB0aGUgdGVtcGxhdGVcbiAgICAgICAgaXMgZnVsbHkgcmVzcG9uc2libGVcbiAgICAtLT5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZW1iZWRkZWQgJiYgZXhwYW5kZWRcIlxuICAgICAgICAgICAgICAgICBpbml0TmVzdGluZyBbc2V0TGV2ZWxdPVwibmVzdGluZ0xldmVsXCIgW3NldFBhcmVudEl0ZW1dPVwicGFyZW50XCJcbiAgICAgICAgICAgICAgICAgW3NldEN1cnJyZW50SXRlbV09XCJpdGVtXCJcbiAgICA+XG4gICAgICAgIDxuZy1jb250YWluZXIgI3JlbmRlcmVkSXRlbSAqbmdUZW1wbGF0ZU91dGxldD1cImNvbnRyb2xUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGl0ZW0sIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsLCByb3dJbmRleDpyb3dJbmRleCAgfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYC5pcy1vdXRsaW5lLWFuaW1hdGlvbj5kaXYsOjpuZy1kZWVwIC53LW91dGxpbmUtaXRlbXtvdmVyZmxvdzpoaWRkZW59YF0sXG5cbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ3NlY3Rpb24nLCBbXG4gICAgICAgICAgICBzdGF0ZSgnKicsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnKicsXG4gICAgICAgICAgICAgICAgJ29wYWNpdHknOiAnMSdcblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgc3RhdGUoJ3ZvaWQnLCBzdHlsZSh7XG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcwJyxcbiAgICAgICAgICAgICAgICAnb3BhY2l0eSc6ICcwJyxcbiAgICAgICAgICAgICAgICAnb3ZlcmZsb3cteSc6ICdoaWRkZW4nXG5cbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIGFuaW1hdGUoJzIwMG1zIGVhc2Utb3V0JykpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbigndm9pZCA9PiAqJywgYW5pbWF0ZSgnMjAwbXMgZWFzZS1pbicpKVxuICAgICAgICBdKSxcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE91dGxpbmVGb3JDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGl0ZW1zIHRoYXQgbmVlZHMgdG8gYmUgcmVuZGVyZWQuIEl0IGRvZXMgbm90IGhhdmUgdG8gaW4gaGllcmFyY2hpY2FsIG9yZGVyIG9yIHdlXG4gICAgICogbGVhdmUgaXQgdXAgdG8gdGhlIGFwcGxpY2F0aW9uIHRvIGRlY2lkZSBhYm91dCB0aGUgc3RydWN0dXJlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdD86IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyB0aGUgY29tcG9uZW50IG5vdCB0byByZW5kZXIgZXhwYW5zaW9uIGNvbnRyb2wsIGluIHN1Y2ggY2FzZSB3ZSBleHBhbmRBbGwgYXMgYVxuICAgICAqIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0V4cGFuc2lvbkNvbnRyb2w6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIG1ldGhvZCBwcm92aWRlZCBieSBhcHBsaWNhdGlvbiB0byByZXRyaWV2ZSBsaXN0IG9mIGNoaWxkcmVuIGZvciBjdXJyZW50IGl0ZW0uIElmXG4gICAgICogY2hpbGRyZW4gaXMgdW5kZWZpbmVkIHRoZW4sIGRlZmF1bHQgJ2NoaWxkcmVuJyBmaWVsZCBpcyB1c2VkIDxjdXJyZW50SXRlbT4uY2hpbGRyZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNoaWxkcmVuOiAodmFsdWU6IGFueSkgPT4gYW55W107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE9wdGlvbiB0byBjb25kaXRpb25hbGx5IHJlbmRlciBvbmx5IGl0ZW1zIHRoYXQgYXJlIHNhdGlzZnlpbmcgZmlsdGVyIGNvbmRpdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmaWx0ZXJPdXQ6ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBPcGVucyBhbGwgdHJlZSBub2Rlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQWxsOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqICBNYW5hZ2VzIHRoZSBzdGF0ZSBmb3IgdGhlIE91dGxpbmUgY29tcG9uZW50LiBMYXRlciBvbiB3ZSBjYW4gcHJvdmlkZSBlYXNpZXIgd2UgaG93IHRvXG4gICAgICogIGluaXRpYWxpemUgYW5kIHNldCBzZWxlY3Rpb25QYXRocyBhbmQgc2VsZWN0aW9uU3RhdGVzIGZyb20gdGhlIGFwcGxpY2F0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0YXRlOiBPdXRsaW5lU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldCBpbmRlbnRhdGlvbiBzaXplIHRvIGJlIHVzZWQgZm9yIGVhY2ggbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyID0gMjU7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2UgdGVtcGxhdGUgaXMgb3V0c2lkZSBvZiB0aGUgb3V0bGluZUZvclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXh0ZXJuYWxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGN1cnJlbnQgb2JqZWN0IHVzaW5nIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250ZXh0OiBhbnk7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgcHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgd2hlbiBpbiBzZWxlY3Rpb24gbW9kZSB0byBwdXNoIGN1cnJlbnQgc2VsZWN0ZWQgSXRlbSB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uSXRlbVNlbGVjdGVkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGV2ZW50IGlzIHRyaWdnZXJlZCBieSBPdXRsaW5lQ29udHJvbCB3aGVuIG5vZGUgaXMgZXhwYW5kZWQgb3IgY29sbGFwc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkV4cGFuZENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBBIHRlbXBsYXRlIHRvIHVzZSBvbiBhcHBsaWNhdGlvbiBsZXZlbCB0byByZW5kZXIgaW5kaXZpZHVhbCBpdGVtc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ291dGxpbmUnKVxuICAgIGNvbnRyb2xUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgQFZpZXdDaGlsZCgncmVuZGVyZWRJdGVtJylcbiAgICBvdXRsaW5lSXRlbTogRWxlbWVudFJlZjtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxzXG4gICAgICpcbiAgICAgKiBjdXJyZW50SXRlbSBhbmQgcGFyZW50SXRlbSBhcmUgdXNlZCB0byBjYXB0dXJlIGN1cnJlbnQgcHJvY2Vzc2VkIGl0ZW0gb2YgbmdGb3IuIFRoaXMgaXNcbiAgICAgKiBzZXQgYnkgZGlyZWN0aXZlIGBJbml0TmVzdGluZ0RpcmVjdGl2ZWBcbiAgICAgKlxuICAgICAqIGFuaW1hdGlvbkluUHJvZ3Jlc3M6IHVzZWQgYnkgYW5pbWF0aW9uIGVuZ2luZSB0byBtYWtlIHN1cmUgd2UgZG9udCBkbyBhbnkgYWN0aW9ucyB3aGlsZVxuICAgICAqIGFuaW1hdGlvbiBpcyBpbiB0aGUgcHJvZ3Jlc3NcbiAgICAgKlxuICAgICAqIGVtYmVkZGVkOiBJbmRpY2F0ZXMgdGhhdCB3ZSBhcmUgdXNpbmcgZGlyZWN0aXZlIHNvIGl0IHdpbGwgbm90IGhhdmUgZGVmYXVsdCBjb21wb25lbnRcbiAgICAgKiB3cmFwcGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50SXRlbTogYW55O1xuICAgIHBhcmVudEl0ZW06IGFueTtcbiAgICBhbmltYXRpb25JblByb2dyZXNzOiBib29sZWFuO1xuICAgIGVtYmVkZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBGbGFnIHRoYXQgdGVsbHMgdXMgdGhhdCBjb21wb25lbnQgaXMgZnVsbHkgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIHZpZXdJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgYnVpbGRlcjogQW5pbWF0aW9uQnVpbGRlcixcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIG5nT25Jbml0ICgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IE91dGxpbmVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUub3V0bGluZUZvcikpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUub3V0bGluZUZvciA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5leHBhbmRBbGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd0V4cGFuc2lvbkNvbnRyb2wgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhdGUuZ2xvYmFsU3RhdGUgPSB0aGlzLmV4cGFuZEFsbDtcblxuICAgICAgICAvLyBpbiBjYXNlIHdlIHdhbnQgdG8gcmVuZGVyIGNvbnRlbnQgb2YgdHJlZSBvdXRzaWRlIG9mIG91dGxpbmVGb3JcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmV4dGVybmFsVGVtcGxhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xUZW1wbGF0ZSA9IHRoaXMuZXh0ZXJuYWxUZW1wbGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1iZWRkZWQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2F3b3V0bGluZWZvcicpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAvLyB3aGVuIHJvb3Qgc2VjdGlvbiBuZWVkcyB0byBiZSBvbiBuZXcgbGluZSwgdGhlbiBhdXRvbWF0aWNhbGx5IGV4cGFuZCBzZWNvbmQgbGV2ZWxcbiAgICAgICAgLy8gaWYgKHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmxpc3QuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgbGV0IGN1cnJlbnRJdGVtID0gTGlzdFdyYXBwZXIubGFzdCh0aGlzLnN0YXRlLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLnN0YXRlLnRvZ2dsZUV4cGFuc2lvbihpdGVtKTtcbiAgICAgICAgLy8gICAgIH0pXG4gICAgICAgIC8vIH1cbiAgICB9XG5cblxuICAgIG5nRG9DaGVjayAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0ZW1wbGF0ZSBhbmQgT3V0bGluZUNvbnRyb2wgdG8gaWRlbnRpZnkgd2hpY2ggaXRlbSBpcyBleHBhbmRlZCBhbmQgY29sbGFwc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0V4cGFuZGVkIChpdGVtOiBhbnksIGN1cnJlbnRMZXZlbDogbnVtYmVyID0gLTEpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGN1cnJlbnRMZXZlbCA9PT0gMCAmJiB0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSlcbiAgICAgICAgICAgID8gdHJ1ZSA6IHRoaXMuc3RhdGUuaXNFeHBhbmRlZChpdGVtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNpbmNlIHdlIGhhdmUgY3VycmVudGx5IHR3byB3YXlzIGhvdyB0byBwYXNzIGNoaWxkcmVuIGl0ZW1zIHdlIG5lZWQgaGF2ZSB0aGlzIG1ldGhvZCB0b1xuICAgICAqIHVuaWZ5IHRoZSB3YXkgaG93IHdlIGFjY2VzcyBpdC4gSWYgd2UgcGFzcyBgY2hpbGRyZW5gIGJpbmRpbmcgd2UgdXNlIHRoaXMgaW5zdGVhZCwgb3RoZXJ3aXNlXG4gICAgICogd2UgZXhwZWN0IGN1cnJlbnQgb2JqZWN0IHRvIGhhdmUgYGNoaWxkcmVuYCBmaWVsZFxuICAgICAqXG4gICAgICovXG4gICAgY2hpbGRyZW5Gb3JJdGVtIChpdGVtOiBhbnkpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQ2hpbGRyZW4oaXRlbSkgPyB0aGlzLmRvR2V0Q2hpbGRyZW4oaXRlbSkgOiBbXTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgdGhlIGN1cnJlbnQgaXRlbSBoYXMgYSBjaGlsZHJlbiBhbmQgbmVlZHMgdG8gYmUgcmVuZGVyZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0NoaWxkcmVuIChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNoaWxkcmVuKSAmJiBpc0JsYW5rKGl0ZW0uY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsICdNaXNzaW5nIFtjaGlsZHJlbl0gbWV0aG9kIGJpbmRpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmRvR2V0Q2hpbGRyZW4oaXRlbSkubGVuZ3RoID4gMDtcblxuICAgIH1cblxuICAgIGRvR2V0Q2hpbGRyZW4gKGl0ZW06IGFueSk6IGFueVtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtpdGVtXSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgVXNlcyB0aGUgYE91dGxpbmVTdGF0ZWAgdG8gdG9nZ2xlIHN0YXRlIG9mIGN1cnJlbnQgc2VsZWN0aW9uUGF0aC4gVGhlIGBzZWxlY3Rpb25QYXRoYCBpc1xuICAgICAqICBwdXQgdG9nZXRoZXIgaW5zaWRlIGBPdXRsaW5lQ29udHJvbGAgd2hlcmUgd2UgaXRlcmF0ZSBhbGwgdGhlIHdheSB0byB0aGUgcm9vdCBhbmQgYWRkXG4gICAgICogIGVhY2ggaXRlbSB0byB0aGUgYGN1cnJlbnRQYXRoYCBhcnJheS4gVGhpcyB3YXkgd2UgY29sbGVjdCBsaXN0IG9mIGl0ZW0gcmVwcmVzZW50aW5nIGN1cnJlbnRcbiAgICAgKiAgY3VycmVudCBleHBhbnNpb25QYXRoLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb24gKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8vIGJhY2t1cCBwcm9jZWR1cmUgaW4gY2FzZSBvbkFuaW1hdGlvbkRvbmUgZmFpbHNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25JblByb2dyZXNzKSB7IC8vIGNoYW5nZSBvbmx5IGlmIGl0cyBmYWlsc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGN1cnJlbnRJdGVtID0gTGlzdFdyYXBwZXIubGFzdCh0aGlzLnN0YXRlLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS50b2dnbGVFeHBhbnNpb24odGhpcy5zdGF0ZS5jdXJyZW50UGF0aCwgdGhpcy5jaGlsZHJlbkZvckl0ZW0oY3VycmVudEl0ZW0pKTtcblxuICAgICAgICBpZiAodGhpcy5lbWJlZGRlZCkge1xuICAgICAgICAgICAgLy8gdGhpcy5hbmltYXRlRW1iZWRkZWRJdGVtKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFuZ3VsYXIgYW5pbS4gY2FsbGJhY2sgdGhhdCBzZXRzIGJhY2sgdGhlIGZsYWcgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHRyaWdnZXIgYW5pbWF0aW9uc1xuICAgICAqIHdoZW4gb25lIGlzIGluIHByb2dyZXNzLlxuICAgICAqXG4gICAgICovXG4gICAgb25BbmltYXRpb25Eb25lIChldmVudDogRXZlbnQpXG4gICAge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVkIGluZGVudGF0aW9uIHVzZWQgdG8gc2hpZnQgdGhlIG5lc3RlZCBzZWN0aW9uIHRvIHRoZSByaWdodCBvciBsYXRlciBvbiB0byB0aGVcbiAgICAgKiBsZWZ0IHdoZW4gUlRMIGlzIHN1cHBvcnRlZFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpbmRlbnRhdGlvbiAoY3VycmVudExldmVsOiBudW1iZXIpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBjdXJyZW50TGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoY3VycmVudExldmVsID09PSAwICYmIHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKVxuICAgICAgICAgICAgPyAwIDogKHRoaXMuaW5kZW50YXRpb25QZXJMZXZlbCAqIGN1cnJlbnRMZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90IGFsbCByb3dzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQsIHRoZXJlIGNhbiBiZSBhIGNhc2Ugd2hlcmUgeW91IGRvbnQgd2FudCB0byByZW5kZXIgaXRlbXNcbiAgICAgKiB1c2luZyBvdXRsaW5lLiBlLmcuIERhdGF0YWJsZSB3aXRoIGRldGFpbCByb3cuXG4gICAgICovXG4gICAgaXNWaXNpYmxlIChpdGVtOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmlsdGVyT3V0KSkge1xuICAgICAgICAgICAgcmV0dXJuICF0aGlzLmZpbHRlck91dChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIFNpbmNlIHdlIGNhbiBub3QgZGlyZWN0bHkgc2V0IGAqbmdUZW1wbGF0ZU91dGxldGAgY29udGV4dCB2YXJpYWJsZXMgdG8gdGhlIHR5cGVzY3JpcHQgY2xhc3Mgd2VcbiAqIHVzZSB0aGlzIGRpcmVjdGl2ZSB0byBkbyB0aGUgSm9iXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpbml0TmVzdGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIEluaXROZXN0aW5nRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICBASW5wdXQoKVxuICAgIHNldExldmVsOiBudW1iZXI7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0Q3VycnJlbnRJdGVtOiBhbnk7XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0UGFyZW50SXRlbTogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBvdXRsaW5lOiBPdXRsaW5lRm9yQ29tcG9uZW50KVxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0ICgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2V0TGV2ZWwpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmUuc3RhdGUuY3VycmVudExldmVsID0gdGhpcy5zZXRMZXZlbDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNldEN1cnJyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5jdXJyZW50SXRlbSA9IHRoaXMuc2V0Q3VycnJlbnRJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNldFBhcmVudEl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmUuY3VycmVudEl0ZW1bJyQkcGFyZW50SXRlbSddID0gdGhpcy5zZXRQYXJlbnRJdGVtO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge091dGxpbmVGb3JDb21wb25lbnR9IGZyb20gJy4uL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZS1zdGF0ZSc7XG5cblxuLyoqXG4gKiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCByZW5kZXJzIHRoZSBpbmRlbnRhdGlvbiwgYXJyb3csIGFuZCB0ZXh0IGZvciBhIG5vZGUgaW4gYW4gb3V0bGluZS5cbiAqIEl0IHNob3VsZCBiZSB1c2VkIGVpdGhlciBpbiB0aGUgYm9keSBvZiBhbiBPdXRsaW5lRm9yIGNvbXBvbmVudCwgb3IgaW5zaWRlIGRhdGF0YWJsZVxuICpcbiAqXG4gKiAjI1VzYWdlIGluc2lkZSBib2R5OlxuICpcbiAqICBIZXJlIHlvdSBjYW4gc2VlIHRoYXQgd2UgbmVlZCB0byB3cmFwIG91dCBjb250ZW50IGluc2lkZSBuZy10ZW1wbGF0ZSB3aGljaCB3aWxsIHB1c2ggdXNcbiAqICBnaXZlIHVzIGN1cnJlbnQgaXRlbSBpdGVtIGFuZCB0aGVuIHdlIGNhbiBwbGFjZSBPdXRsaW5lQ29udHJvbENvbXBvbmVudCB0byBjb250cm9sXG4gKiAgdGhlIHRyZWUuXG4gKlxuICogYGBgXG4gKiAgPGF3LW91dGxpbmUtZm9yMiAjb29vIFtsaXN0XT1cImxpc3RcIiBbaGFzQ2hpbGRyZW5dPVwiaGFzQ2hpbGRyZW5cIj5cbiAqXG4gKiAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJteS1zZWN0aW9uXCI+XG4gKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm91dGxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgPGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgIDwvYXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgIDwvZGl2PipcbiAqICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L25nLXRlbXBsYXRlPlxuICogIDwvYXctb3V0bGluZS1mb3IyPlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBXZSBjYW5cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW91dGxpbmUtY29udHJvbCcsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgQ29udHJvbCBpcyBqdXN0IHRoZSB0d28gZmxleCBib3ggaXRlbXMgZm9yIGRpc3BsYXlpbmcgZXhwYW5kL2NvbGxhcHNlIGljb24gYW5kIGNvbnRlbnRcblxuICAgIFNpbmNlIHdlIGFuaW1hdGUgb25seSBzdGFuZGFsb25lL25vbi1lbWJlZGRlZCBjYXNlIG5vdyB0aGVuIHdlIG5lZWQgdG8gYWxzbyBhbmltYXRlIHRoZSBpY29uXG4gICAgc28gd2UgdXNlIG9ubHkgaWNvbi1zbGltLWFycm93LXJpZ2h0IGFuZCBkbyB0cmFuZm9ybWF0aW9uIG9uIHRvcCBvZiB0aGlzIHRvIG1ha2UgaXQgcm90YXRlLlxuXG4gICAgSWYgZW1iZWRkZWQgY2FzZSB3ZSB1c2UgYm90aCBpY29ucyBpY29uLXNsaW0tYXJyb3ctcmlnaHQgLyBpY29uLXNsaW0tYXJyb3ctZG93blxuLS0+XG48ZGl2IGNsYXNzPVwidy1vdXRsaW5lLWNvbnRyb2xcIlxuICAgICBbbmdDbGFzc109XCJ7J291dGxpbmUtdS11bnNlbGVjdGFibGUtdGV4dCc6IG91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lICYmICFpdGVtLiQkcGFyZW50SXRlbX1cIj5cbiAgICA8ZGl2IGNsYXNzPVwib3V0bGluZS1pY29uIHNhcC1pY29uXCJcbiAgICAgICAgICpuZ0lmPVwiIW91dGxpbmVGb3IucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lIHx8ICFpc1Jvb3RJdGVtXCJcbiAgICAgICAgIChjbGljayk9XCJ0b2dnbGVFeHBhbnNpb24oJGV2ZW50KVwiXG4gICAgICAgICBbc3R5bGUubWFyZ2luLWxlZnQucHhdPVwiaW5kZW50YXRpb25cIlxuICAgICAgICAgW25nQ2xhc3NdPVwiY2FsY3VsYXRlU3R5bGVDbGFzcygpXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiYWxsb3dTZWxlY3Rpb247IHRoZW4gd2l0aFNlbGVjdGlvbiBlbHNlIHdpdGhvdXRTZWxlY3Rpb25cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48IS0tXG4gV2Ugc3VwcG9ydCB0d28gY2FzZSBmb3IgdGhlIGNvbnRlbnRcblxuIFNlbGVjdGlvbjogV2hlbiB5b3UgY2xpY2sgb24gdGhlIGNvbnRlbnQgaXQgd2lsbCBhZGQgZXh0cmEgY2xhc3Mgc28geW91IGNhbiBzdHlsZSBjdXJyZW50bHlcbiBzZWxlY3RlZCBpdGVtIGFzIHdlbGwgYXMgYnJvYWRjYXN0IGV2ZW50IG91dHNpZGUgc28gZGV2ZWxvcGVyIGNhbiBob29rIGluIHNvbWUgY3VzdG9tIGxvZ2ljXG5cbiBJZiB3ZSBkb250IHN1cHBvcnQgc2VsZWN0aW9uOiBUaGVuIGNsaWNraW5nIG9uIHRoZSBjb250ZW50IGlzIGp1c3QgbGlrZSBjbGlja2luZyBvbiBleHBhbmRhYmxlXG4gaWNvbiwgaXQgdG9nZ2xlcyB0aGUgc3RhdGVcbi0tPlxuXG48bmctdGVtcGxhdGUgI3dpdGhTZWxlY3Rpb24+XG4gICAgIDxzcGFuIGNsYXNzPVwib3V0bGluZS1jb250ZW50IG91dGxpbmUtY29udGVudC1zZWxlY3RlZFwiICpuZ0lmPVwiaXNTZWxlY3RlZCgpXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJuZ0NvbnRlbnRcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJvdXRsaW5lLWNvbnRlbnRcIiAqbmdJZj1cIiFpc1NlbGVjdGVkKClcIiAoY2xpY2spPVwic2VsZWN0KClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5nQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cblxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI3dpdGhvdXRTZWxlY3Rpb24+XG4gICAgPHNwYW4gY2xhc3M9XCJvdXRsaW5lLWNvbnRlbnRcIiAoY2xpY2spPVwidG9nZ2xlRXhwYW5zaW9uKCRldmVudClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5nQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNuZ0NvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9uZy10ZW1wbGF0ZT5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnctb3V0bGluZS1jb250cm9se292ZXJmbG93OmhpZGRlbjtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOm5vd3JhcDtjdXJzb3I6cG9pbnRlcn0udy1vdXRsaW5lLWNvbnRyb2wgLm91dGxpbmUtaWNvbntmbGV4OjAgMCAxNXB4O2NvbG9yOiNhYmFiYWI7Zm9udC1zaXplOjE0cHg7Zm9udC13ZWlnaHQ6NzAwO21pbi13aWR0aDoxMXB4O2FsaWduLXNlbGY6Y2VudGVyO3RyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gNTBtcyBlYXNlLWluO3RyYW5zaXRpb246dHJhbnNmb3JtIDUwbXMgZWFzZS1pbjt0cmFuc2l0aW9uOnRyYW5zZm9ybSA1MG1zIGVhc2UtaW4sLXdlYmtpdC10cmFuc2Zvcm0gNTBtcyBlYXNlLWluOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjoyNSUgNjUlO3RyYW5zZm9ybS1vcmlnaW46MjUlIDY1JTstd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2R9Lnctb3V0bGluZS1jb250cm9sIC5vdXRsaW5lLWljb24ub3V0bGluZS1pY29uLWV4cGFuZGVkey13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9Lnctb3V0bGluZS1jb250cm9sIC5vdXRsaW5lLWNvbnRlbnR7ZmxleDoxIDEgYXV0bztmbGV4LXdyYXA6d3JhcDtwYWRkaW5nOjAgNHB4fS53LW91dGxpbmUtY29udHJvbCAub3V0bGluZS1jb250ZW50Lm91dGxpbmUtY29udGVudC1zZWxlY3RlZHtjdXJzb3I6ZGVmYXVsdDtmb250LXdlaWdodDo3MDB9Lm91dGxpbmUtdS11bnNlbGVjdGFibGUtdGV4dHstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1vLXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTtjdXJzb3I6YXV0b31gXSxcbn0pXG5leHBvcnQgY2xhc3MgT3V0bGluZUNvbnRyb2xDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGl0ZW1zIHRoYXQgbmVlZHMgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBJZiBUUlVFIGl0IGNoYW5nZXMgdGhlIGJlaGF2aW9yIG9mIHRoZSBvdXRsaW5lIG5vZGUgdGV4dCB3aGljaCBjbGljayBpcyB0cmlnZ2VyZWRcbiAgICAgKiAgaXQgc2VsZWN0cyB0aGUgaXRlbSBhbmQgYnJvYWRjYXN0IHRoZSBgb25JdGVtU2VsZWN0ZWRgIGV2ZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsbG93U2VsZWN0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRyaWdnZXJzIGFjdGlvbiB3aGVuIG91dGxpbmUgaXRlbSBpcyBleHBhbmRlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgaXRlbSB1c2VkIGZvciB0aGlzIGBPdXRsaW5lQ29udHJvbGBcbiAgICAgKlxuICAgICAqL1xuICAgIGl0ZW06IGFueTtcblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZWQgaW5kZW50YXRpb24gdXNlZCB0byBzaGlmdCB0aGUgbmVzdGVkIHNlY3Rpb24gdG8gdGhlIGxlZnQuIFRoaXMgaXMgdXNlZCBmb3JcbiAgICAgKiBlbWJlZGRlZCBtb2RlIGUuZy4gdHJlZSB0YWJsZSB3aGVyZSB3ZSBjYW5ub3QgaW5kZW50IHBhcmVudFxuICAgICAqL1xuICAgIGluZGVudGF0aW9uOiBudW1iZXI7XG5cblxuICAgIGlzUm9vdEl0ZW06IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yIChwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE91dGxpbmVTdGF0ZSkpXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGUsXG4gICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgcGFyZW50Q29udHJvbDogT3V0bGluZUNvbnRyb2xDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBPdXRsaW5lRm9yQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHVibGljIG91dGxpbmVGb3I6IE91dGxpbmVGb3JDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQgKClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5wcmVwYXJlQ29udHJvbCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXZSBkb250IHNob3cgZXhwYW5zaW9uIGljb25zIHdoZW4gdGhlcmUgbm8gY2hpbGRyZW5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0V4cGFuc2lvbkNvbnRyb2wgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaGFzQ2hpbGRyZW4odGhpcy5pdGVtKSAmJiB0aGlzLm91dGxpbmVGb3Iuc2hvd0V4cGFuc2lvbkNvbnRyb2w7XG4gICAgfVxuXG5cbiAgICBpc1NlbGVjdGVkICgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLnN0YXRlLnNlbGVjdGVkSXRlbSA9PT0gdGhpcy5pdGVtO1xuICAgIH1cblxuICAgIGNhbGN1bGF0ZVN0eWxlQ2xhc3MgKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0V4cGFuc2lvbkNvbnRyb2woKSB8fFxuICAgICAgICAgICAgKHRoaXMub3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgJiYgaXNCbGFuayh0aGlzLml0ZW0uJCRwYXJlbnRJdGVtKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaXNFeHBhbmRlZCh0aGlzLml0ZW0pID8gJ2ljb24tc2xpbS1hcnJvdy1kb3duJ1xuICAgICAgICAgICAgICAgIDogJ2ljb24tc2xpbS1hcnJvdy1yaWdodCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lRm9yLmlzRXhwYW5kZWQodGhpcy5pdGVtKVxuICAgICAgICAgICAgICAgID8gJ2ljb24tc2xpbS1hcnJvdy1yaWdodCBvdXRsaW5lLWljb24tZXhwYW5kZWQnIDogJ2ljb24tc2xpbS1hcnJvdy1yaWdodCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYW5kIGV4cGFuZHMgY3VycmVudCBub2RlXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVFeHBhbnNpb24gKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuY3VycmVudFBhdGggPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRQYXRoID0gdGhpcy5pdGVtO1xuXG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQoY3VycmVudFBhdGgpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuY3VycmVudFBhdGgudW5zaGlmdChjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICBjdXJyZW50UGF0aCA9IGN1cnJlbnRQYXRoLiQkcGFyZW50SXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3V0bGluZUZvci50b2dnbGVFeHBhbnNpb24oKTtcbiAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICBpdGVtOiB0aGlzLml0ZW0sXG4gICAgICAgICAgICBleHBhbmRlZDogdGhpcy5vdXRsaW5lRm9yLnN0YXRlLmlzRXhwYW5kZWQodGhpcy5pdGVtKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGlvbi5lbWl0KHBheWxvYWQpO1xuICAgICAgICB0aGlzLm91dGxpbmVGb3Iub25FeHBhbmRDaGFuZ2UuZW1pdChwYXlsb2FkKTtcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBzZWxlY3QgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5zZWxlY3RlZEl0ZW0gPSB0aGlzLml0ZW07XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5vbkl0ZW1TZWxlY3RlZC5lbWl0KHRoaXMuaXRlbSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmVwYXJlQ29udHJvbCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5vdXRsaW5lRm9yKSAmJiBpc1ByZXNlbnQodGhpcy5vdXRsaW5lU3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVGb3IgPSB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLm91dGxpbmVGb3IpLCAnTWlzc2luZyBvdXRsaW5lRm9yIGNvbXBvbmVudCcpO1xuICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICBsZXQgbGV2ZWwgPSB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuY3VycmVudExldmVsO1xuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgJiYgbGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5pbmRlbnRhdGlvbiA9ICh0aGlzLm91dGxpbmVGb3IuaW5kZW50YXRpb25QZXJMZXZlbCAqIGxldmVsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW0gPSB0aGlzLm91dGxpbmVGb3IuY3VycmVudEl0ZW07XG4gICAgICAgIHRoaXMuaXNSb290SXRlbSA9IGlzQmxhbmsodGhpcy5pdGVtLiQkcGFyZW50SXRlbSk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0luaXROZXN0aW5nRGlyZWN0aXZlLCBPdXRsaW5lRm9yQ29tcG9uZW50fSBmcm9tICcuL291dGxpbmUtZm9yLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge091dGxpbmVDb250cm9sQ29tcG9uZW50fSBmcm9tICcuL291dGxpbmUtY29udHJvbC9vdXRsaW5lLWNvbnRyb2wuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgT3V0bGluZUZvckNvbXBvbmVudCxcbiAgICAgICAgT3V0bGluZUNvbnRyb2xDb21wb25lbnQsXG4gICAgICAgIEluaXROZXN0aW5nRGlyZWN0aXZlXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBPdXRsaW5lRm9yQ29tcG9uZW50LFxuICAgICAgICBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdPdXRsaW5lRm9yTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cblxuLyoqXG4gKiBSZW5kZXJzIGh0bWwgdGV4dCBhcmVhIGNvbXBvbmVudFxuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKlxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnbXlOb3RlJyAsXG4gKiAgICAgICAgICB0ZW1wbGF0ZTogJzxhdy10ZXh0LWFyZWEgW3ZhbHVlXT1cImlucHV0VmFsdWVcIiBbYXV0b1Jlc2l6ZV09XCJhdXRvUmVzaXplXCIgPlxuICogICAgICAgICAgICAgIDwvYXctdGV4dC1hcmVhPidcbiAqICAgICAgfSlcbiAqICAgICAgZXhwb3J0IGNsYXNzIE15Tm90ZUNvbXBvbmVudFxuICogICAgICB7XG4gKiAgICAgICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSByZWFsbHkgbG9uZyB0ZXh0JztcbiAqICAgICAgICAgIGF1dG9SZXNpemU6IGZhbHNlO1xuICogICAgICB9XG4gKlxuICogYGBgXG4gKiAgTm90ZTogaWYgeW91IGFyZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgRm9ybVRhYmxlIHBsZWFzZSBwcm92aWRlIHlvdXIgb3duIEZvcm1Hcm91cFxuICovXG5cbmV4cG9ydCBjb25zdCBURVhUQVJFQV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEFyZWFDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctdGV4dC1hcmVhJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCJlZGl0YWJsZVwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG5cblx0PHRleHRhcmVhXG4gICAgICAgIHBJbnB1dFRleHRhcmVhXG4gICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgIGNsYXNzPVwidy10ZXh0LWFyZWFcIlxuICAgICAgICBbY2xhc3MudS12YWxpZGF0aW9uLWVycm9yXT1cIiEoZm9ybUNvbnRyb2wudmFsaWQgfHwgKGZvcm1Db250cm9sLnByaXN0aW5lKSlcIlxuICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJ7e25hbWV9fVwiXG4gICAgICAgIFtyb3dzXT1cInJvd3NcIlxuICAgICAgICBbY29sc109XCJjb2x1bW5zXCJcbiAgICAgICAgW2F1dG9SZXNpemVdPVwiYXV0b1Jlc2l6ZVwiXG4gICAgICAgIFthdHRyLnBsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCJcblxuICAgID48L3RleHRhcmVhPlxuXG48L2Rpdj5cblxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyBbdmFsdWVdPVwidmFsdWVcIj48L2F3LXN0cmluZz5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2BgXSxcblxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBURVhUQVJFQV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRleHRBcmVhQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFRleHRBcmVhQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgdmFsdWUgdXNlZCB0byBzdG9yZSBhbmQgcmVhZCB1c2VyIGlucHV0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogU3BlZmlmaWVzIHZpc2libGUgbnVtYmVyIG9mIGxpbmVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb3dzOiBudW1iZXIgPSAyO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdmlzaWJsZSB3aWR0aFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29sdW1uczogbnVtYmVyID0gMjA7XG5cblxuICAgIC8qKlxuICAgICAqIHdoZW4gdGhpcyBvcHRpb24gaXMgVFJVRSBhbmQgdXNlciBzdGFydHMgdHlwaW5nIGl0IHdpbGwgbWF4aW1pemUgdGV4dGFyZWEncyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhdXRvUmVzaXplOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC52YWx1ZUNoYW5nZXMucGlwZShcbiAgICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICAgKS5zdWJzY3JpYmUodmFsID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHtvbmx5U2VsZjogdHJ1ZX0pO1xuICAgICAgICB9XG5cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0lucHV0VGV4dGFyZWFNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge1RleHRBcmVhQ29tcG9uZW50fSBmcm9tICcuL3RleHQtYXJlYS5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dGFyZWFNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFRleHRBcmVhQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1RleHRBcmVhTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBUZW1wbGF0ZVJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogUGFnZS1Ob3RpZmljYXRpb24gY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBhIG5vdGlmaWNhdGlvbiBzeXN0ZW0gZm9yIHRoZSB1c2VyIHJlZ2FyZGluZ1xuICogdGhlIGN1cnJlbnQgb2JqZWN0IGhlJ3Mgd29ya2luZyBvbi4gVHlwaWNhbCBub3RpZmljYXRpb24gYXJlOlxuICogICAgICBTdWNjZXNzIC0gc2F2ZWQuXG4gKiAgICAgIFdhcm5pbmcgLSBTb3VyY2luZyByZXF1ZXN0IHJlcXVpcmVzIDMgc3VwcGxpZXJzLlxuICogICAgICBFcnJvciAgIC0gY2Fubm90IGNvbm5lY3QgdG8gc2VydmVyLCBjaGVjayBpbnRlcm5ldCBjb25uZWN0aW9uLlxuICpcbiAqXG4gKlxuICogVXNhZ2UgMTogIEFzIHBhcnQgb2YgcGFnZSB3cmFwcGVyLlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnTXlQYWdlJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgPGF3LW9iamVjdC1wYWdlLXdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cIk15UGFnZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtvYmplY3RUeXBlXT1cIk15VHlwZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtub3RpZmljYXRpb25dPVwicGFnZU5vdGlmaWNhdGlvblwiPlxuICogICAgICAgICAgICAgcGFnZSBjb250ZW50XG4gKiAgICAgICAgICBgXG4gKiAgICAgICA8L2F3LW9iamVjdC1wYWdlci13cmFwcGVyPlxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqXG4gKiAgICAgICAgcGFnZU5vdGlmaWNhdGlvbjogUGFnZU5vdGlmaWNhdGlvbiA9IG5ldyBQYWdlTm90aWZpY2F0aW9uKFwid2FyblwiLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBvbGljeSBXYXJuaW5nXCIsIFwiVGhpcyByZXF1ZXN0IHJlcXVpcmVzIDMgYmlkcy5cIik7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqXG4gKiBVc2FnZSAyOiBkaXJlY3RseSBpbnRvIHRoZSBwYWdlLlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICA8XG4gKiAgICAgIGF3LWhlYWRlcj48L2F3LWhlYWRlcj5cbiAqICAgICAgICBQYWdlIEhlYWRlclxuICpcbiAqICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzTm90aWZpY2F0aW9ucygpXCI+XG4gKiAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1LW5vcGFkZGluZ1wiPlxuICogICAgICAgICAgICA8YXctcGFnZS1ub3RpZmljYXRpb24gW25vdGlmaWNhdGlvbl09XCJub3RpZmljYXRpb25cIj48L2F3LXBhZ2Utbm90aWZpY2F0aW9uPlxuICogICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgICAgIDxhdy1mb290ZXI+PC9hdy1mb290ZXI+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5pbmdcIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2Utbm90aWZpY2F0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLW5vdGlmaWNhdGlvblwiPlxuICAgIDxkaXYgW2NsYXNzXT1cIm5vdGlmaWNhdGlvbkNsYXNzKClcIj5cbiAgICAgICAgPGkgW2NsYXNzXT1cIm5vdGlmaWNhdGlvbkljb24oKVwiPjwvaT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJjb250ZW50XCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIj57e25vdGlmaWNhdGlvbi50aXRsZX19PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRlc2NyaXB0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIm5vdGlmaWNhdGlvbi5oYXNUZW1wbGF0ZSgpOyBlbHNlIGRlc2NyaXB0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm5vdGlmaWNhdGlvbi5jb250ZW50VG1wbFwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2Rlc2NyaXB0aW9uPnt7bm90aWZpY2F0aW9uLmRlc2NyaXB0aW9ufX08L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICA8L3NwYW4+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLW5vdGlmaWNhdGlvbnttYXJnaW46MCAwIDVweH0ubm90aWZpY2F0aW9uLWVycm9yLC5ub3RpZmljYXRpb24taW5mbywubm90aWZpY2F0aW9uLXN1Y2Nlc3MsLm5vdGlmaWNhdGlvbi13YXJuaW5ne3BhZGRpbmc6OXB4IDhweH0ubm90aWZpY2F0aW9uLWVycm9yIGksLm5vdGlmaWNhdGlvbi1pbmZvIGksLm5vdGlmaWNhdGlvbi1zdWNjZXNzIGksLm5vdGlmaWNhdGlvbi13YXJuaW5nIGl7Zm9udC1zaXplOjI0cHg7bWFyZ2luOjEwcHh9Lm5vdGlmaWNhdGlvbi1zdWNjZXNzIGl7Y29sb3I6IzU4Yjk1N30ubm90aWZpY2F0aW9uLWluZm8gaXtjb2xvcjojMTk5ZGUwfS5ub3RpZmljYXRpb24td2FybmluZyBpe2NvbG9yOiNmOTB9Lm5vdGlmaWNhdGlvbi1lcnJvciBpe2NvbG9yOiNjMDB9Lm5vdGlmaWNhdGlvbi1zdWNjZXNze2JhY2tncm91bmQtY29sb3I6I2YxZjlmMTtib3JkZXI6MXB4IHNvbGlkIHJnYmEoODgsMTg1LDg3LC41KX0ubm90aWZpY2F0aW9uLWluZm97YmFja2dyb3VuZC1jb2xvcjojZWRmOGZkO2JvcmRlcjoxcHggc29saWQgcmdiYSgyNSwxNTcsMjI0LC41KX0ubm90aWZpY2F0aW9uLXdhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZmOGRkO2JvcmRlcjoxcHggc29saWQgcmdiYSgyNTUsMTUzLDAsLjUpfS5ub3RpZmljYXRpb24tZXJyb3J7YmFja2dyb3VuZC1jb2xvcjojZmZlYmViO2JvcmRlcjoxcHggc29saWQgcmdiYSgyMDQsMCwwLC41KX0uaWNvbi1lcnJvcjpiZWZvcmV7Y29udGVudDpcIlxcXFxFQTlEXCJ9Lmljb24td2FybmluZzpiZWZvcmV7Y29udGVudDpcIlxcXFxFQTlDXCJ9LmNvbnRlbnR7dmVydGljYWwtYWxpZ246c3VwZXJ9LnRpdGxle2ZvbnQtd2VpZ2h0OjcwMDttYXJnaW4tcmlnaHQ6MTBweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogQW55IGluZm8sIEVycm9yLCBvciBXYXJuIGZvciB0aGlzIHBhZ2UuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIG5vdGlmaWNhdGlvbkNsYXNzKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBub3RpZmljYXRpb24tJHt0aGlzLm5vdGlmaWNhdGlvbi50eXBlfWA7XG4gICAgfVxuXG4gICAgbm90aWZpY2F0aW9uSWNvbigpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgYXJpYmEtaWNvbiBpY29uLSR7dGhpcy5ub3RpZmljYXRpb24udHlwZX1gO1xuICAgIH1cblxufVxuXG4vKipcbiAqIFBhZ2UgTm90aWZpY2F0aW9uIGFyZSBtZXNzYWdlcyBmb3IgdGhpcyBwYWdlIG9ubHkuIEl0IGRpc3BsYXlzIGluIHRoZSBjZW50ZXIgb2YgdGhlIHBhZ2VcbiAqIHJpZ2h0IHVuZGVyIHBhZ2UgdGl0bGUuIFR5cGljYWwgcGFnZSBub3RpZmljYXRpb25zIGFyZSAnc2F2ZSBjb25maXJtYXRpb24nLFxuICogJ2Vycm9yIGR1cmluZyBzdWJtaXQnLCB3YXJuaW5ncyBvZiBmaWVsZCByZXF1aXJlbWVudHMsIGV0Yy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VOb3RpZmljYXRpb25cbntcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdHlwZTogUGFnZU5vdGlmaWNhdGlvblR5cGUsIHB1YmxpYyB0aXRsZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBkZXNjcmlwdGlvbjogc3RyaW5nLCBwdWJsaWMgY29udGVudFRtcGw/OiBUZW1wbGF0ZVJlZjxhbnk+KVxuICAgIHtcbiAgICB9XG5cbiAgICBoYXNUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY29udGVudFRtcGwpO1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSArICcsIHRpdGxlOiAnICsgdGhpcy50aXRsZSArICcsIGRlc2NyaXB0aW9uOiAgJyArIHRoaXMuZGVzY3JpcHRpb247XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlTm90aWZpY2F0aW9uVHlwZSA9ICdzdWNjZXNzJyB8ICdpbmZvJyB8ICd3YXJuaW5nJyB8ICdlcnJvcic7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BhZ2VOb3RpZmljYXRpb25Db21wb25lbnR9IGZyb20gJy4vcGFnZS1ub3RpZmljYXRpb24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbi8qKlxuICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIHBhZ2UgaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gKlxuICovXG5leHBvcnQgY2xhc3MgUGFnZUluaXRpYWxpemVkXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHRpdGxlOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlSW5pdGlhbGl6aWVkKHRpdGxlOiAke3RoaXMudGl0bGV9KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXZlbnQgdHJpZ2dlcmVkIHdoZW4gYSBwYWdlIGhhcyBiZWVuIGRlc3Ryb3llZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlRGVzdHJveWVkXG57XG4gICAgY29uc3RydWN0b3IocHVibGljIHRpdGxlOiBzdHJpbmcpXG4gICAge1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlRGVzdHJveWVkKHRpdGxlOiAke3RoaXMudGl0bGV9KWA7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBQYWdlRXZlbnQgPSBQYWdlSW5pdGlhbGl6ZWQgfCBQYWdlRGVzdHJveWVkO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTdWJqZWN0fSBmcm9tICdyeGpzJztcbmltcG9ydCB7UGFnZURlc3Ryb3llZCwgUGFnZUV2ZW50LCBQYWdlSW5pdGlhbGl6ZWR9IGZyb20gJy4vcGFnZS1ldmVudHMnO1xuXG4vKipcbiAqIFBhZ2UgTGlmZUN5Y2xlIFNlcnZpY2UgbW9uaXRvcnMgYWxsIHBhZ2UgaW5pdGlhbGl6YXRpb24gYW5kIGRlc3RydWN0aW9ucy5cbiAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgc2VydmljZSBpcyB0byBoZWxwIHRoZSBhcHBsaWNhdGlvbiBtb25pdG9yIHBhZ2UgbGlmZWN5Y2xlLCBzdWJzY3JpYmVcbiAqIHRvIGxpZmVjeWNsZSBldmVudHMgYW5kIGV4ZWN1dGUgYWN0aW9ucyBzdWNoIGFzIHVzZXIgYW5hbHl0aWNzLlxuICpcbiAqIFVzYWdlOlxuICpcbiAqICAgIDEuICBJbmplY3QgUGFnZUxpZmVDeWNsZVNlcnZpY2UgaW50byB5b3VyIGNvbnN0cnVjdG9yXG4gKlxuICogICAgY29uc3RydWN0b3IocGFnZUxpZmVjeWNsZTpQYWdlTGlmZUN5Y2xlU2VydmljZSkge1xuICogICAgICAgIHBhZ2VMaWZlY3ljbGUucGFnZUV2ZW50cy5zdWJzY3JpYmUoZXZlbnQ6RXZlbnQgPT4ge1xuICogICAgICAgICAgICBpZihldmVudCBpbnN0YW5jZW9mIFBhZ2VJbml0aWFsaXplZCkge1xuICogICAgICAgICAgICB9XG4gKiAgICAgICAgICAgIC8vIFBhZ2VEZXN0cm95ZWRcbiAqXG4gKiAgICAgICAgfSk7XG4gKiAgICAgfVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUxpZmVDeWNsZVNlcnZpY2VcbntcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgZXZlbnQgcXVldWUgd2hlbiBhbGwgcGFnZSBsaWZlY3ljbGUgZXZlbnRzOiBpbml0LCBkZXN0cm95IGFyZSBlbWl0dGVkLlxuICAgICAqIExpc3RlbmVycyBjYW4gc3Vic2NyaWJlIHRvIHRoZXNlIGV2ZW50cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGFnZUV2ZW50czogU3ViamVjdDxQYWdlRXZlbnQ+ID0gbmV3IFN1YmplY3Q8UGFnZUV2ZW50PigpO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpXG4gICAge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFnZSBpcyBpbml0aWFsaXplZC5cbiAgICAgKiBAcGFyYW0gcGFnZVRpdGxlXG4gICAgICovXG4gICAgcHVibGljIG9uUGFnZUluaXQocGFnZVRpdGxlOiBzdHJpbmcpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBhZ2VFdmVudHMubmV4dChuZXcgUGFnZUluaXRpYWxpemVkKHBhZ2VUaXRsZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgd2hlbiBwYWdlIGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgICAqIEBwYXJhbSB0aXRsZVxuICAgICAqL1xuICAgIHB1YmxpYyBvblBhZ2VEZXN0cm95KHBhZ2VUaXRsZTogc3RyaW5nKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlRXZlbnRzLm5leHQobmV3IFBhZ2VEZXN0cm95ZWQocGFnZVRpdGxlKSk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi4vLi4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgcGFnZSB0eXBlcyBpbiBhbiBhcHBsaWNhdGlvbi5cbiAqL1xuZXhwb3J0IGVudW0gUGFnZVR5cGUge1xuICAgIEluaXQsICAgICAgICAgLy8gSW5pdCBQYWdlIHR5cGVcbiAgICBMb2dpbiwgICAgICAgIC8vIExvZ2luIFBhZ2VcbiAgICBPYmplY3QsICAgICAgIC8vIE9iamVjdCBkZXRhaWwgcGFnZVxuICAgIExpc3QsICAgICAgICAgLy8gTGlzdCBQYWdlXG4gICAgTWFzdGVyRGV0YWlsLCAvLyBNYXN0ZXJEZXRhaWxcbiAgICBEYXNoYm9hcmQsICAgIC8vIERhc2hib2FyZCBwYWdlXG4gICAgTW9kYWwgICAgICAgICAvLyBNb2RhbCBwYWdlLCBpdCBjYW4gYmUgY29uZmlndXJlZCB0byBiZSBhIHBvcHVwLCBvciBzdGFuZGFsb25lIHBhZ2UuXG59XG5cbi8qKiBQbGFjZWhvbGRlciBub3cuIFRoZSBFcnJvciBNYW5hZ2VyIGhhbmRsZXMgYWxsIHRoZSBlcnJvcnMgb24gdGhlIHBhZ2UuXG4gKiAgSXQgaXMgaW5pdGlhbGl6ZWQgZm9yIGV2ZXJ5IHBhZ2UuIFBhZ2UgZXJyb3JzLCB3YXJuaW5nLCBpbmZvIGdvZXMgdGhyb3VnaFxuICogIHRoZSBlcnJvciBNYW5hZ2VyIGFuZCB0aGUgcmVzdWx0IG1lc3NhZ2UgaXMgZGlzcGxheWVkIG9uIHRoZSBwYWdlIG5vdGlmaWNhdGlvbiBhcmVhLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyXG57XG5cbn1cblxuLyoqXG4gKiAgUGFnZSB3cmFwcGVyIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgcGFnZXMuIFRoZSBpZGVhIGlzIHRoYXQgdGhlcmUgYXJlIGRpZmZlcmVudCBwYWdlIHR5cGVzXG4gKiAgaW4gYW4gQXBwbGljYXRpb24uIEEgTGlzdCBQYWdlIHJlbmRlcnMgYSBsaXN0IG9mIG9iamVjdHMsIGV4OiBjdXN0b21lcnMsIHJlcXVlc3RzLCBQTy4gIEFuZFxuICogIGEgb2JqZWN0IHBhZ2Ugd2lsbCByZW5kZXIgb25lIG9iamVjdCBpbiBkZXRhaWwuXG4gKlxuICogIFRoZXkgc2hhcmUgY29tbW9uIGF0dHJpYnV0ZXMgc3VjaCBhcyBwYWdlIHR5cGUgYW5kIHBhZ2UgaWQuXG4gKlxuICogIEFyaWJhIFBhZ2UgaGF2ZSBhIGxpZmUgY3ljbGUuIFdoZW4gcGFnZSBzdGFydHMgdXAsIGl0J3MgaW5pdGlhbGl6ZWQuIEFuZCB3aGVuIHRoZSBwYWdlIGlzXG4gKiAgZGVzdHJveWVkLCBpdCdsbCBiZSBjb21wbGV0ZS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBhZ2VXcmFwcGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqIFdoYXQgdHlwZSBvZiBwYWdlIHRoaXMgaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGFnZVR5cGU6IFBhZ2VUeXBlID0gUGFnZVR5cGUuSW5pdDtcblxuICAgIC8qKlxuICAgICAqIFBhZ2UgSWQuIFVzZWQgd2hlbiBwYWdlcyBhcmUgc3RvcmVkIGluIG1hcC5cbiAgICAgKi9cbiAgICBpZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSGFuZGxpbmcgYWxsIHRoZSBlcnJvciBvbiBhIHBhZ2UuXG4gICAgICovXG4gICAgcHVibGljIGVycm9yTWFuYWdlcjogRXJyb3JNYW5hZ2VyO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdGhhdCB0aGlzIHBhZ2Ugd3JhcHBlciBoYXMgYmVlbiB3cmFwcGVkIGJ5IGFub3RoZXIgcGFnZSB3cmFwcGVyLlxuICAgICAqIEluIHRoaXMgY2FzZSwgd2Ugd291bGRuJ3QgZGlzcGxheSBoZWFkZXIgYW5kIGZvb3RlciBhbmQgb3RoZXIgcGFnZSB3cmFwcGVyIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBhbHJlYWR5SW5QYWdlV3JhcHBlcjogYm9vbGVhbjtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHBhZ2VUeXBlOiBQYWdlVHlwZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYWdlTGlmZWN5Y2xlU2VydmljZTogUGFnZUxpZmVDeWNsZVNlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICB0aGlzLnBhZ2VUeXBlID0gcGFnZVR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxsIHN1YmNsYXNzIG5lZWRzIHRvIGdlbmVyYXRlZCBhIHBhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBJdCBmb2xsb3dzIHRoZSBmb2xsb3dpbmcgcGF0dGVybjpcbiAgICAgKiAgICB0eXBlX3RpdGxlX2lkXG4gICAgICpcbiAgICAgKiAgICBSRlFfU291cmNpbmdSZXF1ZXN0XzEyM1xuICAgICAqL1xuICAgIGFic3RyYWN0IGdlbmVyYXRlUGFnZUlkKCk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdW5pcXVlIElkIGZvciB0aGlzIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0SWQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlkID0gdGhpcy5nZW5lcmF0ZVBhZ2VJZCgpO1xuICAgIH1cblxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtQYWdlTWVudUl0ZW19IGZyb20gJy4uL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqICBUaGlzIGlzIGEgdGVtcG9yYXJ5IGltcGxlbWVudGF0aW9uIGZvciB0aGUgcGFnZSBoZWFkZXIgY29tcG9uZW50LlxuICogIFdoZW4gdGhlIHJlYWwgaW1wbGVtZW50YXRpb24gb2Ygc2lkZSBtZW51IGlzIGRvbmUsIFBhZ2VIZWFkZXJDb21wb25lbnQgd2lsbFxuICogIGJlIHN3YXBlZCB0byB1c2UgaXQuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNpZGVuYXYnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBbbmdDbGFzc109XCJnZXRTaWRlbmF2Q2xhc3MoKVwiPlxuICAgIDxkaXYgY2xhc3M9XCJzaWRlbmF2LWNvbnRlbnRcIj5cbiAgICAgICAgPGEgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIiBbcm91dGVyTGlua109XCJpdGVtLmxpbmtcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2lkZW5hdi1pY29uXCI+PGkgW25nQ2xhc3NdPVwiJ3NhcC1pY29uICcgKyBpdGVtLmljb25cIj48L2k+PC9zcGFuPlxuICAgICAgICAgICAge3tpdGVtLmxhYmVsfX1cbiAgICAgICAgPC9hPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2Auc2lkZW5hdntoZWlnaHQ6MTAwJTt3aWR0aDowO3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MTt0b3A6NTBweDtsZWZ0OjA7YmFja2dyb3VuZC1jb2xvcjojMzYzNjM2O292ZXJmbG93LXg6aGlkZGVuO3BhZGRpbmctdG9wOjIwcHg7dHJhbnNpdGlvbjouNXN9LnNpZGVuYXYtYWN0aXZle3dpZHRoOjI1MHB4fS5zaWRlbmF2IGF7cGFkZGluZzo4cHggOHB4IDhweCAzMnB4O3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQtc2l6ZToxNnB4O2NvbG9yOiNmZmY7ZGlzcGxheTpibG9jazt0cmFuc2l0aW9uOi4zc30uc2lkZW5hdiBhOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uc2lkZW5hdi1pY29ue2ZvbnQtc2l6ZTozMHB4O2NvbG9yOiNjY2M7bWFyZ2luLXJpZ2h0OjEwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgU2lkZW5hdkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIG1lbnUgaXRlbXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGl0ZW1zOiBQYWdlTWVudUl0ZW1bXTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBiYWNrIGxpbmsgdGhhdCBuYXZpZ2F0ZXMgdXNlciB0byB0aGUgcHJldmlvdXMgcGFnZSB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93OiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBnZXRTaWRlbmF2Q2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICAvLyBPbmx5IHNob3cgaWYgSSBoYXZlIGl0ZW1zXG4gICAgICAgIHJldHVybiAodGhpcy5zaG93ICYmIHRoaXMuaXRlbXMpID8gJ3NpZGVuYXYgc2lkZW5hdi1hY3RpdmUnIDogJ3NpZGVuYXYnO1xuICAgIH1cblxuICAgIG9wZW4oKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudCwgUm91dGluZ1NlcnZpY2V9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTaWRlbmF2Q29tcG9uZW50fSBmcm9tICcuLi9zaWRlbmF2L3NpZGVuYXYuY29tcG9uZW50JztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIEhlYWRlciBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IgZm9yIGFuIEFyaWJhIHBhZ2UuXG4gKiBIZWFkZXIgaW5jbHVkZXMgYSBtZW51LCB1c2VyIHByb2ZpbGUsIGFuZCBhbGVydHMuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICA8YXctcGFnZS1oZWFkZXIgW3Nob3dCYWNrQWN0aW9uXT1cInRydWVcIiB1c2VyTmFtZT1cIkNoYWQgTm9sbFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttZW51SXRlbXNdPVwibWVudUl0ZW1zXCIgW25vdGlmaWNhdGlvbnNdPVwidXNlck5vdGlmaWNhdGlvbnNcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWNlbnRlclwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cIm5hdmJhci1icmFuZFwiIHRhYmluZGV4PVwiMFwiIGhyZWY9XCIvXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPVwibmF2YmFyLWxvZ29cIiBzcmM9XCIuL2ltYWdlcy9TQVBfQXJpYmFfREIucG5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9XCJHbyB0byBob21lcGFnZVwiIGRhdGEtcGluLW5vcGluPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAqICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICA8L2F3LXBhZ2UtaGVhZGVyPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKiAgICAgIG1lbnVJdGVtczogUGFnZU1lbnVJdGVtW10gPSBbbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1ob21lJywgJ0hvbWUnLCAnL3BsYXkvJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFnZU1lbnVJdGVtKCdpY29uLWV4cGVuc2UtcmVwb3J0JywgJ1JlcG9ydHMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS9wYWdlaGVhZGVyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFnZU1lbnVJdGVtKCdpY29uLXNhbGVzLW9yZGVyJywgJ1B1cmNoYXNlIE9yZGVyJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS9wYWdlaGVhZGVyJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUGFnZU1lbnVJdGVtKCdpY29uLWFjY291bnQnLCAnQWNjb3VudHMnLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS9wYWdlaGVhZGVyJyldO1xuICpcbiAqICAgICB1c2VyTm90aWZpY2F0aW9uczogVXNlck5vdGlmaWNhdGlvbltdID0gW1xuICogICAgICAgbmV3IFVzZXJOb3RpZmljYXRpb24oJ2ljb24tZXhwZW5zZS1yZXBvcnQnLCAnRXhwZW5zZSByZXBvcnQgRVhQNDUzIGhhcyBiZWVuIGFwcHJvdmVkLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy9wbGF5LycpLFxuICogICAgICAgICBuZXcgVXNlck5vdGlmaWNhdGlvbignaWNvbi1zYWxlcy1vcmRlcicsICdTYWxlcyBPcmRlciBTTzEyMzQgaGFzIGJlZW4gY3JlYXRlZC4nLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS8nKSxcbiAqICAgICAgICAgICBuZXcgVXNlck5vdGlmaWNhdGlvbignaWNvbi1hY2NvdW50JywgJ1N1cHBsaWVyIGFjY291bnQgU0ExMjM0IGhhcyBiZWVuIHVwZGF0ZWQuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS8nKVxuICogICAgICAgIF07XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiBgPG5hdiBjbGFzcz1cIm5hdmJhciBwYWdlLWhlYWRlclwiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidWktZ1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC00IG5hdmJhci1sZWZ0XCI+XG5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNNZW51SXRlbXMoKVwiPlxuICAgICAgICAgICAgPGEgKGNsaWNrKT1cInNob3dIaWRlTWVudSgpXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJzYXAtaWNvbiBpY29uLXBhZ2luZ1wiPjwvaT5cbiAgICAgICAgICAgIDwvYT5cblxuICAgICAgICAgICAgPCEtLSBTaWRlIG1lbnUgLS0+XG4gICAgICAgICAgICA8YXctc2lkZW5hdiAjc2lkZW1lbnUgW2l0ZW1zXT1cIm1lbnVJdGVtc1wiPjwvYXctc2lkZW5hdj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPCEtLSBFbmQgSGFtYnVyZ2VyIG1lbnUuIC0tPlxuXG4gICAgICAgICAgICA8IS0tICBiYWNrIGFjdGlvbiAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYmFjay1hY3Rpb25cIj5cbiAgICAgICAgICAgIDxhIChjbGljayk9XCJiYWNrQWN0aW9uKClcIj5cbiAgICAgICAgICAgICAgICA8aSAqbmdJZj1cInNob3dCYWNrQWN0aW9uXCIgY2xhc3M9XCJzYXAtaWNvbiBpY29uLWFycm93LWxlZnRcIiByb2xlPVwiYnV0dG9uXCI+PC9pPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtNCBuYXZiYXItY2VudGVyXCI+XG5cbiAgICAgICAgICAgIDwhLS0gY2VudHJhbCBzZWN0aW9uLiAgQXBwbGljYXRpb24gY2FuIGFkZCBBcmliYS1sb2dvLCBzZWFyY2ggYm94LCBldGMgLS0+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1oZWFkZXItY2VudGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC00IG5hdmJhci1yaWdodFwiPlxuICAgICAgICA8c3BhbiAqbmdJZj1cInVzZXJOYW1lXCI+XG4gICAgICAgICAgICA8aW1nIGlkPVwidXNlclByb2ZpbGVQaWN0dXJlXCIgY2xhc3M9XCJwcm9maWxlLWxvZ29cIiBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgICAgICAgICBbdGl0bGVdPVwidXNlck5hbWVcIiBzcmM9XCJ7e2Fzc2V0Rm9sZGVyfX0vaW1hZ2VzL2RlZmF1bHRfaW1hZ2Vfc21hbGwucG5nXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInByb2ZpbGUtdXNlclwiIHRpdGxlPVwie3t1c2VyTmFtZX19XCI+e3t1c2VyTmFtZX19PC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIWhpZGVOb3RpZmljYXRpb25cIiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1jb250YWluZXJcIj5cblxuICAgICAgICAgICAgPGkgI25vdGlmaWNhdGlvbkljb24gY2xhc3M9XCJhcmliYS1pY29uIGljb24tbm90aWZpY2F0aW9uXCJcbiAgICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVOb3RpZmljYXRpb25QYW5lbCgpXCI+PC9pPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNOb3RpZmljYXRpb25zKClcIiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1iYWRnZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7bm90aWZpY2F0aW9ucy5sZW5ndGh9fTwvc3Bhbj5cblxuICAgICAgICAgICAgICAgIDwhLS0gT3JpZ2luYWxseSBJIHdhcyB1c2luZyBwLW92ZXJsYXktcGFuZWwsIGhvd2V2ZXIsIGl0IGRvZXNuJ3QgcG9zaXRpb24gY29ycmVjdGx5IHVuZGVyIHRoZSBub3RpZmljYXRpb24gaWNvbi5cbiAgICAgICAgICAgICAgICAgICAgIFRoZSBwb3NpdGlvbmluZyBsb2dpYyBpbiBwcmltZSBuZyBuZWVkcyBzb21lIG1vcmUgaW52ZXN0aWdhdGlvbi4gU28gZm9yIG5vdywgdXNlIGEgZGl2IGluc3RlYWQtLT5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJzaG93Tm90aWZpY2F0aW9uUGFuZWxcIiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1wYW5lbFwiPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvbi1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgIE5vdGlmaWNhdGlvbnNcbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cIm5vdGlmaWNhdGlvbi1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgbm90aSBvZiBub3RpZmljYXRpb25zXCIgY2xhc3M9XCJub3RpZmljYXRpb24taXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgW3JvdXRlckxpbmtdPVwibm90aS5saW5rXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJub3RpZmljYXRpb24taXRlbS1pY29uXCI+PGlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiJ3NhcC1pY29uICcgKyBub3RpLmljb25cIj48L2k+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7bm90aS5sYWJlbH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuXG5cbiAgICA8L2Rpdj5cbjwvbmF2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2UtaGVhZGVyIGl7Zm9udC1zaXplOjMycHh9LnBhZ2UtaGVhZGVyIC5pY29uLXBhZ2luZ3tmb250LXNpemU6MzBweDtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MnB4fS5iYWNrLWFjdGlvbntkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDoxNXB4fS5iYWNrLWFjdGlvbiBpe3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDozcHh9Lm5hdmJhcntiYWNrZ3JvdW5kOiMwMDA7Y29sb3I6I2ZmZn0ubmF2YmFyLWxlZnR7cGFkZGluZy1sZWZ0OjE1cHg7aGVpZ2h0OjUwcHh9Lm5hdmJhci1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXI7aGVpZ2h0OjUwcHh9Lm5hdmJhci1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0O2hlaWdodDo1MHB4fS5wcm9maWxlLWxvZ297d2lkdGg6MzBweDtoZWlnaHQ6MzBweDtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MnB4fS5wcm9maWxlLXVzZXJ7dmVydGljYWwtYWxpZ246c3VwZXI7bWFyZ2luLXJpZ2h0OjMwcHh9Lmljb24tbm90aWZpY2F0aW9uOmJlZm9yZXtjb250ZW50OlwiXFxcXGVBMTRcIn0ubmF2YmFyICNzaWRlYmFyLW1lbnUtaWNvbntwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6LjVlbX0ubm90aWZpY2F0aW9uLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tcmlnaHQ6MjBweDtkaXNwbGF5OmlubGluZS1ibG9ja30ubm90aWZpY2F0aW9uLWJhZGdle2Rpc3BsYXk6aW5saW5lLWJsb2NrO3BhZGRpbmc6MnB4IDVweDtmb250LXNpemU6MTJweDtmb250LXdlaWdodDo3MDA7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNjMDA7Ym9yZGVyLXJhZGl1czoxMHB4O3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MTZweH0ubm90aWZpY2F0aW9uLXBhbmVse3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0Oi0yN3B4O3RvcDo0NXB4O3dpZHRoOjM1MHB4O2NvbG9yOiM3Njc2NzY7Ym94LXNoYWRvdzowIDJweCAxMHB4IDAgcmdiYSgwLDAsMCwuMTMpO2JhY2tncm91bmQtY29sb3I6I2ZmZjtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjphbGwgLjNzIGVhc2UtaW4tb3V0fS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1oZWFkZXJ7YmFja2dyb3VuZC1jb2xvcjojZjNmM2YzO2ZvbnQtc2l6ZToxNnB4O2hlaWdodDo1MHB4O2xpbmUtaGVpZ2h0OjUwcHg7dGV4dC1hbGlnbjpjZW50ZXJ9Lm5vdGlmaWNhdGlvbi1wYW5lbCAubm90aWZpY2F0aW9uLWNvbnRlbnR7cGFkZGluZzowO21hcmdpbjowfS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1pdGVte2hlaWdodDo1MHB4O2JvcmRlci10b3A6MXB4IHNvbGlkICNkN2Q3ZDc7cGFkZGluZzoxNXB4IDEwcHg7d2hpdGUtc3BhY2U6bm93cmFwO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXN9Lm5vdGlmaWNhdGlvbi1wYW5lbCAubm90aWZpY2F0aW9uLWl0ZW0gYXtjb2xvcjojNzY3Njc2O3RleHQtZGVjb3JhdGlvbjpub25lO2xpbmUtaGVpZ2h0OjM1cHh9Lm5vdGlmaWNhdGlvbi1wYW5lbCAubm90aWZpY2F0aW9uLWl0ZW06aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZjdmOGZhfS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1pdGVtLWljb257bWFyZ2luLXJpZ2h0OjE1cHg7Y29sb3I6Izc2NzY3NjtkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tdG9wOjEwcHg7dmVydGljYWwtYWxpZ246bWlkZGxlfWBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIG1lbnUgZW50cmllcy4gVGhlIHBhZ2UgbWVudSBpY29uIHdpbGwgb25seSBkaXNwbGF5IHdoZW4gdGhpcyBsaXN0IGlzIG5vdCBlbXB0eS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1lbnVJdGVtczogUGFnZU1lbnVJdGVtW107XG5cbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIHVzZXIgbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub3RpZmljYXRpb25zOiBVc2VyTm90aWZpY2F0aW9uW107XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgdGhlIHVzZXIgbm90aWZpY2F0aW9uIGljb24gYmUgaGlkZGVuLiBEZWZhdWx0IGl0IHRvIHNob3cgdGhlIGljb24gZXZlblxuICAgICAqIGlmIHRoZXJlJ3Mgbm8gbm90aWZpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZU5vdGlmaWNhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIGJhY2sgbGluayB0aGF0IG5hdmlnYXRlcyB1c2VyIHRvIHRoZSBwcmV2aW91cyBwYWdlIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dCYWNrQWN0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGxvZ2dlZCBpbiB1c2VyIG5hbWUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VyTmFtZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNpZGVtZW51XG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnc2lkZW1lbnUnKVxuICAgIHNpZGVuYXY6IFNpZGVuYXZDb21wb25lbnQ7XG5cbiAgICBzaG93Tm90aWZpY2F0aW9uUGFuZWw6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgcm91dGluZzogUm91dGluZ1NlcnZpY2UpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgYmFja0FjdGlvbigpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnJvdXRpbmcuZ29CYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG8gaSBoYXZlIGFueSBtZW51IGl0ZW1zLlxuICAgICAqXG4gICAgICovXG4gICAgaGFzTWVudUl0ZW1zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAodGhpcy5tZW51SXRlbXMgJiYgdGhpcy5tZW51SXRlbXMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBzaWRlIG5hdmlnYXRpb24gbWVudS5cbiAgICAgKi9cbiAgICBzaG93SGlkZU1lbnUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaWRlbmF2LnRvZ2dsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvIEkgaGF2ZSBhbnkgbm90aWZpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc05vdGlmaWNhdGlvbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm5vdGlmaWNhdGlvbnMpICYmIHRoaXMubm90aWZpY2F0aW9ucy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRvZ2dsaW5nIHdoZWF0aGVyIG5vdGlmaWNhdGlvbiBwYW5lbCBpcyBkaXNwbGF5ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIHRvZ2dsZU5vdGlmaWNhdGlvblBhbmVsKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd05vdGlmaWNhdGlvblBhbmVsID0gIXRoaXMuc2hvd05vdGlmaWNhdGlvblBhbmVsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYWdlTWVudUl0ZW0gcmVwcmVzZW50cyBhbiBpdGVtIGluIHRoZSBwYWdlIG1lbnUgc3RydWN0dXJlLlxuICovXG5leHBvcnQgY2xhc3MgUGFnZU1lbnVJdGVtXG57XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGljb24gICAgLSBJY29uIG9mIHRoaXMgbWVudSBpdGVtLlxuICAgICAqIEBwYXJhbSBsYWJlbCAgIC0gbGFiZWwgb2YgdGhpcyBpdGVtLlxuICAgICAqIEBwYXJhbSBsaW5rICAgIC0gbGluayB0byB0aGUgZGVzdGluYXRpb24gd2hlbiB1c2VyIGNsaWNrcyBvbiBpdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaWNvbjogc3RyaW5nLCBwdWJsaWMgbGFiZWw6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgbGluazogc3RyaW5nKVxuICAgIHtcbiAgICB9XG5cbiAgICB0b1N0cmluZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiBgUGFnZU1lbnVJdGVtOiAobGFiZWwsICR7dGhpcy5sYWJlbH0pYDtcbiAgICB9XG59XG5cbi8qKlxuICogbm90aWZpY2F0aW9uIGZvciB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlci5cbiAqIEV4OiAgUFIyMDQ5IGhhcyBiZWVuIGFwcHJvdmVkLlxuICogICAgICBPcmRlciBQTzUxOCByZWNlaXZlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFVzZXJOb3RpZmljYXRpb25cbntcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpY29uICAgLSBhbGVydCBub3RpZmljYXRpb24gaWNvblxuICAgICAqIEBwYXJhbSBsYWJlbCAgLSBhbGVydCBub3RpZmljYXRpb24gbGFiZWxcbiAgICAgKiBAcGFyYW0gbGluayAgIC0gbGlua1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBpY29uOiBzdHJpbmcsIHB1YmxpYyBsYWJlbDogc3RyaW5nLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBsaW5rOiBzdHJpbmcpXG4gICAge1xuXG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYFBhZ2VVc2VyTm90aWZpY2F0aW9uOiAobGFiZWwsICR7dGhpcy5sYWJlbH0pYDtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7QWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogRm9vdGVyIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvci5cbiAqIFRoaXMgZm9vdGVyIGNvbXBvbmVudCBzZWxmIGNvbnRhaW5lZC5cbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgICAgICA8YXctcGFnZS1mb290ZXI+XG4gKiAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWZvb3Rlci1sb2dvXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cImltYWdlcy9hcmliYV9sb2dvX3doaXRlX2JrZ2QucG5nXCI+XG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1mb290ZXItdXNlci1pbmZvXCI+XG4gKiAgICAgICAgICAgICAgICAgICBDaGFkIE5vbGwgKGNub2xsKSBsYXN0IHZpc2l0IHt7bGFzdF92aXNpdGVkIHwgZGF0ZTonTU0vZGQveXl5eSBoOm1tYScgfX1cbiAgKiAgICAgICAgICAgICAgICAgICB8IEJ1eWVyIE9yZ2FuaXphdGlvblxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwYWdlLWZvb3Rlci1jb3B5cmlnaHRcIiAjY29weXJpZ2h0PlxuICogICAgICAgICAgICAgICAgICAgPHA+w4LCqSAyMDIww6LCgMKTMjAyOCBUaGUgRnV0dXJlLCBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQ8L3A+XG4gKiAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtZm9vdGVyPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VcbiAqICAgIHtcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtZm9vdGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLWZvb3RlclwiPlxuICAgIDxkaXYgY2xhc3M9XCJ1aS1nXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLW1kLThcIj5cblxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2UtZm9vdGVyLWxvZ29cIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1c2VyLWluZm9cIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1mb290ZXItdXNlci1pbmZvXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDx1bCBjbGFzcz1cImZvb3Rlci1saW5rc1wiPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGEgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhX3RvdS5jZm1cIj5UZXJtcyBvZlxuICAgICAgICAgICAgICAgICAgICBVc2U8L2E+PC9saT5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYV9zZWN1cml0eV9wb2xpY3kuY2ZtXCI+U2VjdXJpdHlcbiAgICAgICAgICAgICAgICAgICAgRGlzY2xvc3VyZTwvYT48L2xpPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhX3ByaXZhY3lfc3RhdGVtZW50LmNmbVwiPlByaXZhY3lcbiAgICAgICAgICAgICAgICAgICAgU3RhdGVtZW50PC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIj48YVxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cDovL3d3dy5hcmliYS5jb20vbGVnYWwvYXJpYmEtcHJpdmFjeS1zdGF0ZW1lbnRcIj5Db29raWUgU3RhdGVtZW50PC9hPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIj48YVxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cDovL3d3dy5hcmliYS5jb20vbGVnYWwvYXJpYmEtcHJpdmFjeS1zdGF0ZW1lbnRcIj5QYXJ0aWNpcGFudFxuICAgICAgICAgICAgICAgICAgICBTdGF0ZW1lbnQ8L2E+PC9saT5cbiAgICAgICAgICAgIDwvdWw+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLW1kLTRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1LWJvdHRvbS1hbGlnblwiPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInUtaHJpZ2h0IGNvcHlyaWdodFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLWZvb3Rlci1jb3B5cmlnaHRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPCEtLSBEZWZhdWx0IENvcHlyaWdodCAtLT5cbiAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJzaG93RGVmYXVsdENvcHlyaWdodFwiIGNsYXNzPVwidS1ocmlnaHQgY29weXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgPHA+w4LCqSAxOTk2w6LCgMKTMjAxNyBBcmliYSwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLWZvb3RlcntiYWNrZ3JvdW5kOiNmZmY7cGFkZGluZzoxNXB4IDAgMDtmb250LXNpemU6MTFweDtib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3fS5wYWdlLWZvb3RlciAudXNlci1pbmZve2NvbG9yOiNjY2N9LnBhZ2UtZm9vdGVyIC51aS1ne21hcmdpbjowIGF1dG99LnBhZ2UtZm9vdGVyIC5jb3B5cmlnaHR7Y29sb3I6I2NjY30uZm9vdGVyLWxpbmtze2xpc3Qtc3R5bGU6bm9uZTttYXJnaW46MCAtMTVweDtwYWRkaW5nOjA7Zm9udC1zaXplOjEwcHh9LmZvb3Rlci1saW5rcyBsaXtmbG9hdDpsZWZ0fS5mb290ZXItbGlua3M6YWZ0ZXIsLmZvb3Rlci1saW5rczpiZWZvcmV7Y29udGVudDpcIiBcIjtkaXNwbGF5OnRhYmxlfS5mb290ZXItbGlua3M6YWZ0ZXJ7Y2xlYXI6Ym90aH0uZm9vdGVyLWxpbmtzPmxpLC5mb290ZXItbGlua3M+bGk+YXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrfS5mb290ZXItbGlua3M+bGk+YXtwYWRkaW5nOjEwcHggMTVweDtjb2xvcjojMTk5ZGUwfWBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VGb290ZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogY29weXJpZ2h0IGNvbnRlbnRcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdjb3B5cmlnaHQnKSBjb3B5cmlnaHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIHNob3cgZGVmYXVsdCBjb3B5cmlnaHQuIElmIGNvcHlyaWdodCBpcyBwYXNzZWQgaW4sIHRoZW4gc2hvdyB0aGUgcGFzc2VkIGluIG9uZS5cbiAgICAgKi9cbiAgICBzaG93RGVmYXVsdENvcHlyaWdodDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93RGVmYXVsdENvcHlyaWdodCA9ICFpc1ByZXNlbnQodGhpcy5jb3B5cmlnaHQpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5wdXQsXG4gICAgT25EZXN0cm95LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi4vLi4vLi4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge1BhZ2VUeXBlLCBQYWdlV3JhcHBlcn0gZnJvbSAnLi4vcGFnZS13cmFwcGVyJztcbmltcG9ydCB7UGFnZU5vdGlmaWNhdGlvbn0gZnJvbSAnLi4vLi4vcGFnZS1ub3RpZmljYXRpb24vcGFnZS1ub3RpZmljYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUxpZmVDeWNsZVNlcnZpY2V9IGZyb20gJy4uL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuLi9wYWdlLWZvb3Rlci9wYWdlLWZvb3Rlci5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBPYmplY3QgUGFnZSBXcmFwcGVyIENvbXBvbmVudCByZW5kZXJzIGFueSBvYmplY3QgaW5zdGFuY2UgaW4gZGV0YWlsLiBJdCBoYXMgYSB1bmlmb3JtIGxheW91dCxcbiAqIEhlYWRlciwgUGFnZSB0aXRsZSwgUGFnZSBub3RpZmljYXRpb24sIGFjdGlvbnMsIGNvbnRlbnQsIGFuZCBGb290ZXIuXG4gKlxuICpcbiAqICBVc2FnZTpcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ1JGWFBhZ2UnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8YXctb2JqZWN0LXBhZ2Utd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwicmZ4RW50aXR5LmhlYWRlckluZm8udGl0bGVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbb2JqZWN0VHlwZV09XCJyZnhFbnRpdHkuaGVhZGVySW5mby5ldmVudFR5cGVTdHJpbmdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbbm90aWZpY2F0aW9uXT1cInBhZ2VOb3RpZmljYXRpb25cIj5cbiAqXG4gKlxuICogICAgICAgICAgIDxhdy1wYWdlLWFjdGlvbnM+XG4gKiAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3R5cGVdPVwiJ3N1Ym1pdCdcIiBbbmFtZV09XCInZWRpdCdcIiBbdmFsdWVdPVwiZWRpdFwiIFtzdHlsZV09XCIncHJpbWFyeSdcIj5cbiAqICAgICAgICAgICAgICAgICAgIEVkaXRcbiAqICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICA8YXctYnV0dG9uIFt0eXBlXT1cIididXR0b24nXCIgW25hbWVdPVwiJ2NhbmNlbCdcIiBbdmFsdWVdPVwiY2FuY2VsXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0eWxlXT1cIidzZWNvbmRhcnknXCI+XG4gKiAgICAgICAgICAgICAgICAgIENhbmNlbFxuICogICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtYWN0aW9ucz5cbiAqXG4gKiAgICAgICAgICAgPGF3LXBhZ2UtY29udGVudD5cbiAqICAgICAgICAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiU291cmNpbmcgcmVxdWVzdCBpbmZvXCIgKG9uU3RhdGVDaGFuZ2VkKT1cIm9uU3RhdGVDaGFuZ2UoJGV2ZW50KVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDxtLWNvbnRleHQgW29iamVjdF09XCJyZnhFbnRpdHkuaGVhZGVySW5mb1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtvcGVyYXRpb25dPVwidGhpcy5lZGl0YWJpbGl0eVN0YXRlLmhlYWRlckluZm9PcFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dD1cIkluc3BlY3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aUdyb3VwPVwiSGVhZGVyR2VuZXJhbFwiXG4gKiAgICAgICAgICAgICAgICAgICA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgPG0taW5jbHVkZS1jb21wb25lbnQ+PC9tLWluY2x1ZGUtY29tcG9uZW50PlxuICogICAgICAgICAgICAgICAgICAgPC9tLWNvbnRleHQ+XG4gKlxuICogICAgICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICogICAgICAgICAgIDwvYXctcGFnZS1jb250ZW50PlxuICogICAgICAgPC9hdy1vYmplY3QtcGFnZS13cmFwcGVyPlxuICogICAgYFxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBSRlhQYWdlXG4gKiAgICB7XG4gKiAgICAgICAvLyBUbyBrZWVwIHRyYWNrIHdoYXQgc2VjdGlvbiBpcyBlZGl0YWJsZSBhbmQgd2hpY2ggcmVhZCBvbmx5XG4gKiAgICAgICBlZGl0YWJpbGl0eVN0YXRlOiBFZGl0YWJpbGl0eVN0YXRlO1xuICpcbiAqICAgICAgIC8vIEN1cnJlbnQgUkZYIGV2ZW50XG4gKiAgICAgICByZnhFbnRpdHk6IFJmeEV2ZW50RW50aXR5O1xuICpcbiAqICAgICAgIC8vIE5vdGlmaWNhdGlvbnNcbiAqICAgICAgIG5vdGlmaWNhdGlvbjogUGFnZU5vdGlmaWNhdGlvbiA9IG5ldyBQYWdlTm90aWZpY2F0aW9uKFwid2FyblwiLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBvbGljeSBXYXJuaW5nXCIsIFwiVGhpcyByZXF1ZXN0IHJlcXVpcmVzIDMgYmlkcy5cIik7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb2JqZWN0LXBhZ2Utd3JhcHBlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicGFnZS13cmFwcGVyXCI+XG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoaWRlSGVhZGVyXCI+XG4gICAgICAgIDxhdy1pbmNsdWRlLWNvbXBvbmVudCBbbmFtZV09J2hlYWRlci5uYW1lJz48L2F3LWluY2x1ZGUtY29tcG9uZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwiYXJjLW9iamVjdC1kZXRhaWxcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZ1wiPlxuXG4gICAgICAgICAgICA8IS0tIHBhZ2UgaGVhZGVyIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgcGFnZS10aXRsZVwiPlxuXG4gICAgICAgICAgICAgICAgPCEtLSBwYWdlIHRpdGxlIC0tPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTggdWktbWQtOCBwYWdlLXRpdGxlLXRleHRcIj57e3RpdGxlfX08L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTQgdWktbWQtNCBwYWdlLXN0YXR1c1wiPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm9iamVjdC1zdGF0dXMtbGFiZWxcIj57e29iamVjdFN0YXR1c0xhYmVsfX0gJm5ic3A7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIm9iamVjdC1zdGF0dXNcIj57e29iamVjdFN0YXR1c319PC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gcGFnZSBhY3Rpb25zIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgcGFnZS1hY3Rpb25zXCIgKm5nSWY9XCJoYXNUb3BQYWdlQWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cImFjdGlvbnNUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzVG9wUGFnZUFjdGlvbnNcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gb2JqZWN0IHN0YXRlcyAgZGlzcGxheXMgb25seSBpZiBzdGF0ZSBleGlzdHMuIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgcGFnZS1zdGF0ZVwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTMgcGFnZS1zdGF0ZS1sZWZ0XCIgW2NsYXNzLmNvbnRlbnRdPVwiaGFzT2JqZWN0U3RhdGVzKClcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2Utc3RhdGUtbGVmdFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy02IHBhZ2Utc3RhdGUtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJoYXNPYmplY3RTdGF0ZXMoKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0ZXBwZXIgW3N0ZXBzXT1cIm9iamVjdFN0YXRlc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFN0ZXBdPVwib2JqZWN0U3RhdGVJbmRleFwiPjwvYXctc3RlcHBlcj5cbiAgICAgICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMyBwYWdlLXN0YXRlLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLXN0YXRlLXJpZ2h0XCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cblxuICAgICAgICAgICAgPCEtLSBQYWdlIE5vdGlmaWNhdGlvbiAtLT5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJoYXNOb3RpZmljYXRpb25zKClcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1LW5vcGFkZGluZ1wiPlxuXG4gICAgICAgICAgICAgICAgICAgIDxhdy1wYWdlLW5vdGlmaWNhdGlvbiAqbmdGb3I9XCJsZXQgbm90aWZpY2F0aW9uIG9mIG5vdGlmaWNhdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJub3RpZmljYXRpb25cIj48L2F3LXBhZ2Utbm90aWZpY2F0aW9uPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPCEtLSBhZGRpdGlvbmFsIGNvbnRlbnQgLS0+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1wYWdlLWNvbnRlbnRcIj48L25nLWNvbnRlbnQ+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gcGFnZSBhY3Rpb25zIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2UtYWN0aW9ucy1ib3R0b21cIiAqbmdJZj1cImhhc0JvdHRvbVBhZ2VBY3Rpb25zXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cImFjdGlvbnNUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0JvdHRvbVBhZ2VBY3Rpb25zXCI+PC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInBhZ2UtcHVzaFwiPjwvZGl2PlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGlkZUZvb3RlclwiPlxuICAgIDxhdy1pbmNsdWRlLWNvbXBvbmVudCBbbmFtZV09J2Zvb3Rlci5uYW1lJz48L2F3LWluY2x1ZGUtY29tcG9uZW50PlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLXdyYXBwZXJ7YmFja2dyb3VuZC1jb2xvcjojZjJmMmYyO21pbi1oZWlnaHQ6MTAwJTttYXJnaW4tYm90dG9tOi0xMDBweH0uYXJjLW9iamVjdC1kZXRhaWx7cGFkZGluZzoyMHB4fS5wYWdlLXRpdGxlLXRleHR7Zm9udC1zaXplOjIycHg7Y29sb3I6IzAwMDtwYWRkaW5nOjE0cHggMH0ucGFnZS10aXRsZXtwYWRkaW5nOjVweCAwO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkN2Q3ZDd9LnBhZ2UtYWN0aW9uc3twYWRkaW5nOjE1cHggMCA1cHh9LnBhZ2UtYWN0aW9ucy1ib3R0b217cGFkZGluZzowIDIwcHh9LnBhZ2Utc3RhdGUsLnBhZ2Utc3RhdGUtY2VudGVyLC5wYWdlLXN0YXRlLWxlZnQsLnBhZ2Utc3RhdGUtcmlnaHR7cGFkZGluZzowfS5jb250ZW50OjphZnRlcntjb250ZW50OidcXFxcMDBhMCc7Zm9udC1zaXplOjB9LnBhZ2UtdGl0bGUgL2RlZXAvIC51aS1idXR0b257bWluLXdpZHRoOjEwMHB4fS5wYWdlLXN0YXR1c3t0ZXh0LWFsaWduOnJpZ2h0O3BhZGRpbmc6MThweCAwfS5wYWdlLXN0YXR1cyAub2JqZWN0LXN0YXR1cy1sYWJlbHtjb2xvcjojNzY3Njc2fS5wYWdlLXN0YXR1cyAub2JqZWN0LXN0YXR1c3tmb250LXdlaWdodDo3MDA7Y29sb3I6IzAzODcxOX0ucGFnZS1wdXNoe2hlaWdodDoxMDBweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudCBleHRlbmRzIFBhZ2VXcmFwcGVyIGltcGxlbWVudHMgT25EZXN0cm95XG57XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBwYWdlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCBiZWluZyByZW5kZXJlZCAtIEV2ZW50LCBXb3Jrc3BhY2UsIGNvbnRyYWN0LCBldGMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RUeXBlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBsYWJlbCBmb3IgdGhlIG9iamVjdCBzdGF0dXMuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RTdGF0dXNMYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBvYmplY3QncyBzdGF0dXMuIEZvciBleGFtcGxlLCBkcmFmdCwgcGVuZGluZyBzZWxlY3Rpb24sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RTdGF0dXM6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsLiBTb21lIG9iamVjdCBoYXMgc3RhdGVzLiBGb3IgZXhhbXBsZTogUkZ4T2JqZWN0IGhhcyBSZXNvbHZlLCBSZXZpZXcsIEdldCBRdW90ZS5cbiAgICAgKiBPYmplY3Qgc3RhdGVzIHdpbGwgYXBwZWFyIG9uIHRoZSBwYWdlIHdoZW4gdGhleSBhcmUgcHJlc2VudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG9iamVjdFN0YXRlczogc3RyaW5nW107XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gU3RlcHBlciBpcyB1c2VkIHRoaXMgaWRlbnRpZmllcyBjdXJyZW50IHNldCBzdGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0YXRlOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIEhlYWRlciBpcyBhIGNvbXBvbmVudCB0eXBlIHRvIGJlIHJlbmRlcmVkIGFzIGEgcGFnZSBIZWFkZXIuXG4gICAgICpcbiAgICAgKiBUaGUgJ2RlZmF1bHQnIHZhbHVlIGlzIHRoZSBjb21wb25lbnQvd2lkZ2V0L0hlYWRlckNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGVhZGVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHJ1ZSBpZiBwYWdlIHNob3VsZCBub3QgaW5jbHVkZSBhbnkgaGVhZGVyLiBOZWVkIHRvIHNldCB0byB0cnVlIGV2ZW4gbm8gaGVhZGVyXG4gICAgICogb2JqZWN0IGlzIHBhc3NlZCBpbi4gT3RoZXJ3aXNlLCBhIGRlZmF1bHQgSGVhZGVyIGNvbXBvbmVudCB3aWxsIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZUhlYWRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRm9vdGVyIENvbXBvbmVudCBpcyB0aGUgcGFnZSBmb290ZXIuXG4gICAgICogY2FuIGJlIG92ZXJyaWRlbiBidXQgdGhlIGRlZmF1bHQgdmFsdWUgaXMgY29tcG9lbmVudC93aWRnZXQvRm9vdGVyQ29tcG9uZW50LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9vdGVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdHJ1ZSBpZiBwYWdlIHNob3VsZCBub3QgaW5jbHVkZSBhbnkgZm9vdGVyLiBOZWVkIHRvIHNldCB0byB0cnVlIGV2ZW4gbm8gZm9vdGVyXG4gICAgICogb2JqZWN0IGlzIHBhc3NlZCBpbi4gT3RoZXJ3aXNlLCBhIGRlZmF1bHQgRm9vdGVyIGNvbXBvbmVudCB3aWxsIGJlIGFkZGVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGlkZUZvb3RlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBwYWdlIGFjdGlvbnMgKHBhZ2UgYnV0dG9ucylcbiAgICAgKiAgICd0b3AnIDogICAgcGFnZSBidXR0b25zIGFyZSBwbGFjZWQgYXQgdGhlIHRvcCBvZiB0aGUgcGFnZSwgYmVsb3cgdGhlIHRpdGxlLCB0byB0aGUgcmlnaHQuXG4gICAgICogICAnYm90dG9tJyA6IHBhZ2UgYnV0dG9ucyBhcmUgcGxhY2VkIGF0IHRoZSBib3R0b20gb2YgdGhlIHBhZ2UsIGFib3ZlIHRoZSBmb290ZXIuXG4gICAgICogICAnYm90aCcgICA6IHBhZ2UgYnV0dG9ucyBhcmUgcGxhY2VkIGF0IGJvdGggdG9wIGFuZCBib3R0b20uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhZ2VBY3Rpb25Qb3NpdGlvbjogc3RyaW5nID0gJ3RvcCc7XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZmxhZyBpcyBkcml2ZW4gYnkgcGFnZUFjdGlvblBvc2l0aW9uLiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBpcyB0b3AuXG4gICAgICogVmFsdWUgaXMgdHJ1ZSBmb3IgYm90aCAndG9wJyBhbmQgJ2JvdGgnIG9mIHBhZ2VBY3Rpb25Qb3NpdGlvbi5cbiAgICAgKi9cbiAgICBoYXNUb3BQYWdlQWN0aW9uczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZsYWcgaXMgZHJpdmVuIGJ5IHBhZ2VBY3Rpb24gcG9zaXRpb24uXG4gICAgICogVmFsdWUgaXMgdHJ1ZSBmb3IgYm90aCAnYm90dG9tJyBhbmQgJ2JvdGgnIG9mIHBhZ2VBY3Rpb25Qb3NpdGlvbi5cbiAgICAgKi9cbiAgICBoYXNCb3R0b21QYWdlQWN0aW9uczogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogUXVlcmllcyBhIHAgdGVtcGxhdGUgaWYgYW55XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgncGFnZUFjdGlvbnMnKVxuICAgIGFjdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEFueSBTdWNjZXNzLCBJbmZvLCBFcnJvciwgb3IgV2FybiBmb3IgdGhpcyBwYWdlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm90aWZpY2F0aW9uczogUGFnZU5vdGlmaWNhdGlvbltdO1xuXG5cbiAgICBvYmplY3RTdGF0ZUluZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIGNvbXBvbmVudFJlZ2lzdHJ5OiBDb21wb25lbnRSZWdpc3RyeSwgcGFnZUxpZmVjeWNsZVNlcnZpY2U6IFBhZ2VMaWZlQ3ljbGVTZXJ2aWNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBQYWdlVHlwZS5PYmplY3QsIGNvbXBvbmVudFJlZ2lzdHJ5LCBwYWdlTGlmZWN5Y2xlU2VydmljZSk7XG5cbiAgICAgICAgLy8gU2V0dGluZyBEZWZhdWx0IGhlYWRlciBjb21wb25lbnRcbiAgICAgICAgdGhpcy5oZWFkZXIgPSBQYWdlSGVhZGVyQ29tcG9uZW50O1xuICAgICAgICB0aGlzLmZvb3RlciA9IFBhZ2VGb290ZXJDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB1bmlxdWUgSWQgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgZ2VuZXJhdGVQYWdlSWQoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RUeXBlICsgJ18nICsgdGhpcy50aXRsZSArICh0aGlzLmlkKSA/ICgnXycgKyB0aGlzLmlkKSA6ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgbXkgcGFnZSBoYXZlIHBhZ2Ugbm90aWZpY2F0aW9uP1xuICAgICAqXG4gICAgICovXG4gICAgaGFzTm90aWZpY2F0aW9ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMubm90aWZpY2F0aW9ucyAmJiB0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgaGFzT2JqZWN0U3RhdGVzKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5vYmplY3RTdGF0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgbXkgbG9jYWwgY29tcG9uZW50c1xuICAgICAqL1xuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gTmV3IENvbXBvbmVudCB0eXBlcyB0aGF0IGFyZSB1c2VkIGluIGMtaW5jbHVkZS1jb21wb25lbnRcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyVHlwZSh0aGlzLmhlYWRlci5uYW1lLCB0aGlzLmhlYWRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOZXcgQ29tcG9uZW50IHR5cGVzIHRoYXQgYXJlIHVzZWQgaW4gYy1pbmNsdWRlLWNvbXBvbmVudFxuICAgICAgICBpZiAodGhpcy5mb290ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVnaXN0cnkucmVnaXN0ZXJUeXBlKHRoaXMuZm9vdGVyLm5hbWUsIHRoaXMuZm9vdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBub3RpZnkgc3Vic2NyaWJlcnMgb2YgdGhlIHBhZ2UgbGlmZWN5Y2xlIHNlcnZpY2UgICovXG4gICAgICAgIHRoaXMucGFnZUxpZmVjeWNsZVNlcnZpY2Uub25QYWdlSW5pdCh0aGlzLnRpdGxlKTtcblxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBwYWdlIGFjdGlvbiBwb3NpdGlvbi5cbiAgICAgICAgaWYgKHRoaXMucGFnZUFjdGlvblBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgdGhpcy5oYXNUb3BQYWdlQWN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oYXNCb3R0b21QYWdlQWN0aW9ucyA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBhZ2VBY3Rpb25Qb3NpdGlvbiA9PT0gJ2JvdGgnKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaGFzVG9wUGFnZUFjdGlvbnMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5oYXNCb3R0b21QYWdlQWN0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub2JqZWN0U3RhdGVzKSAmJiB0aGlzLm9iamVjdFN0YXRlcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAmJiBpc1ByZXNlbnQodGhpcy5jdXJyZW50U3RhdGUpKSB7XG5cbiAgICAgICAgICAgIHRoaXMub2JqZWN0U3RhdGVJbmRleCA9IHRoaXMub2JqZWN0U3RhdGVzLmluZGV4T2YodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGFuZ2VzWydjdXJyZW50U3RhdGUnXSkgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2N1cnJlbnRTdGF0ZSddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1snY3VycmVudFN0YXRlJ10ucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgLy8gd2UgZG9udCBuZWVkIHRvIGNoZWNrIGlmIG9iamVjdFN0YXRlcyBleGlzdHNcbiAgICAgICAgICAgIHRoaXMub2JqZWN0U3RhdGVJbmRleCA9IHRoaXMub2JqZWN0U3RhdGVzLmluZGV4T2YodGhpcy5jdXJyZW50U3RhdGUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLnBhZ2VMaWZlY3ljbGVTZXJ2aWNlLm9uUGFnZURlc3Ryb3kodGhpcy50aXRsZSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFnZSBhY3Rpb25zIGlzIGEgd3JhcHBlciBmb3IgYWxsIHBhZ2UgYWN0aW9ucywgYnV0dG9ucywgbGlua3MsIG1lbnVzIHRoYXQgaW50ZXJhY3RzIGl0IHdpdGggdGhlXG4gKiBwYWdlLiBUaGUgd3JhcHBlciB1c2UgdGhlIGFiaWxpdHkgdG8gcG9zaXRpb24gaXQgYXMgbmVlZGVkLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtYWN0aW9ucycsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicGFnZS1hY3Rpb25zXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS1hY3Rpb25ze3RleHQtYWxpZ246cmlnaHQ7cGFkZGluZy10b3A6MDtwYWRkaW5nLXJpZ2h0OjB9YF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUFjdGlvbnNDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFBhZ2UgY29udGVudCBpcyBhIHdyYXBwZXIgZm9yIHBhZ2UgY29udGVudC5cbiAqIEN1cnJlbnRseSwgaXQncyBwcmV0dHkgYmFyZSwgYnV0IGFzIHdlIGFkZCBtb3JlIGludGVyYWN0aW9ucyBvbiB0aGUgcGFnZSwgbGlrZSBhIHNpZGUgYmFyLFxuICogdGhlIHBhZ2UgY29udGVudCBhcmVhIHdpbGwgbGlrZWx5IGdldCBhZmZlY3RlZC5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWNvbnRlbnQnLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgc3R5bGVzOiBbJzpob3N0IHt3aWR0aDogMTAwJTsgcGFkZGluZzogMCAuNWVtO30nXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlQ29udGVudENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cblxuY29uc3QgU1RFUFBFUl9DT01QTEVURURfU1RFUF9DT0xPUiA9ICcjNThiOTU3JztcbmNvbnN0IFNURVBQRVJfQ1VSUkVOVF9TVEVQX0NPTE9SID0gJyMwMDc2Q0InO1xuY29uc3QgU1RFUFBFUl9SRU1BSU5JTkdfU1RFUF9DT0xPUiA9ICcjRDdEN0Q3JztcblxuLyoqXG4gKiBTdGVwcGVyIGNvbXBvbmVudCBkaXNwbGF5cyBhIGxpc3Qgb2Ygc3RlcHMgZm9yIHVzZXIgdG8gZm9sbG93LiBJdCBjYW4gYmUgdXNlZCBhcyBhIGNoZWNrbGlzdFxuICogdG8gaW5kaWNhdGUgY29tcGxldGVkLCBjdXJyZW50IGFuZCByZW1haW5pbmcgaXRlbXMuIEl0IGNvdWxkIGJlIGFsc28gYmUgdXNlZCB0byBpbmRpY2F0ZVxuICogdGhlIHN0YXRlIG9mIGFuIGRvY3VtZW50LCBjcmVhdGVkLCBzdWJtaXR0ZWQsIGFwcHJvdmVkLCBldGMuLi5cbiAqXG4gKlxuICogVXNhZ2U6XG4gKiAgIDEuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuIHByb3ZpZGUgYSBsaXN0IG9mIHN0ZXBzIGFuZCB0aGUgY3VycmVudCBzdGVwLlxuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICA8YXctc3RlcHBlciBbc3RlcHNdPVwic3RlcHNcIiBbY3VycmVudFN0ZXBdPVwiY3VycmVudFN0ZXBcIj48L2F3LXN0ZXBwZXI+XG4gKlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0cmluZ1tdID0gWydNb25pdG9yJywgJ0FkZCBTdXBwbGllcicsICdHZXQgUXVvdGUnXTtcbiAqICAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IG51bWJlciA9IDE7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgIG5nT25Jbml0KCkgeyB9XG4gKiAgICAgICB9XG4gKlxuICogICAyLiAgT3ZlcnJpZGUgdGhlIGRlZmF1bHQgY29sb3JzLlxuICpcbiAqICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdGVwcGVyIFtzdGVwc109XCJzdGVwc1wiIFtzdGVwQ29sb3JDdXJyZW50XT1cIicjZmY5OTAwJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RlcENvbG9yUmVtYWluaW5nXT1cIicjQ0MwMDAwJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RlcENvbG9yQ29tcGxldGVkXT1cIicjOTdhODIyJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY3VycmVudFN0ZXBdPVwiY3VycmVudFN0ZXBcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctc3RlcHBlcj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN0ZXBwZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInN0ZXBwZXItY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cInN0ZXBzXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdGVwLXNwYWNpbmdcIj48L2Rpdj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzOyBsZXQgaT1pbmRleDsgbGV0IGxhc3Q9bGFzdDtcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdGVwXCI+XG4gICAgICAgICAgICAgICAgPGF3LXN0ZXAgW3RpdGxlXT1cInN0ZXBcIiBbY29sb3JdPVwiZ2V0U3RlcENvbG9yKGkpXCI+PC9hdy1zdGVwPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiIWxhc3RcIiBjbGFzcz1cInN0ZXAtY29ubmVjdG9yXCIgW3N0eWxlLndpZHRoXT1cImNvbm5lY3RvcldpZHRoXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbm5lY3RvclwiIFtzdHlsZS5ib3JkZXJCb3R0b21Db2xvcl09XCJnZXRDb25uZWN0b3JDb2xvcihpKVwiPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzdGVwLXNwYWNpbmdcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzdGVwLWxhYmVsc1wiPjwvZGl2PlxuPC9kaXY+XG5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnN0ZXBwZXItY29udGFpbmVye2Rpc3BsYXk6dGFibGU7dGFibGUtbGF5b3V0OmZpeGVkO3dpZHRoOjEwMCV9LnN0ZXBze2Rpc3BsYXk6dGFibGUtcm93fS5zdGVwLXNwYWNpbmd7ZGlzcGxheTp0YWJsZS1jZWxsO3dpZHRoOjEwJX0uc3RlcHtkaXNwbGF5OnRhYmxlLWNlbGw7d2lkdGg6MzJweH0uc3RlcC1jb25uZWN0b3J7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uY29ubmVjdG9ye2hlaWdodDoxcHg7Ym9yZGVyLWJvdHRvbTozcHggc29saWQgIzU4Yjk1N30uc3RlcC1sYWJlbHN7ZGlzcGxheTp0YWJsZS1yb3c7aGVpZ2h0OjUwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgU3RlcHBlckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZFxuICAgICAqIEFycmF5IG9mIHN0ZXBzLiBPcmRlciBvZiB0aGUgc3RlcHMgc2hvdWxkIGJlIGluIGFycmF5IG9yZGVyLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcHM6IHN0cmluZ1tdO1xuXG5cbiAgICAvKipcbiAgICAgKiBzcGVjaWZ5IHRoZSBjb2xvcnMgYXNzb2NpYXRlZCB3aXRoIHN0ZXBzIGFib3ZlLiBUaGUgbnVtYmVyIG9mIGNvbG9yc1xuICAgICAqIGFuZCBudW1iZXIgb2Ygc3RlcHMgbXVzdCBtYXRjaC5cbiAgICAgKiBPcHRpb25hbDosIGlmIGVtcHR5LCBkZWZhdWx0IGNvbG9ycyBvciBjb2xvcnMgZnJvbSBzdGVwQ29sb3IgaW5wdXRzIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbG9yczogc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCB2YXJpYWJsZSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRvIHVzZSB0aGUgY29sb3JzIGFycmF5IG9yIG5vdC5cbiAgICAgKi9cbiAgICBiVXNlQ29sb3JBcnJheTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgSW5wdXQgZm9yIGNhbGxlciB0byBvdmVycmlkZSB0aGUgY29sb3Igb2YgY29tcGxldGVkIHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwQ29sb3JDb21wbGV0ZWQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIGN1cnJlbnQgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBDb2xvckN1cnJlbnQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIHJlbWFpbmluZyBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcENvbG9yUmVtYWluaW5nOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGVwIHRoYXQncyBvbi4gSWYgbm90IHByb3ZpZGVkIGRlZmF1bHQgdG8gdGhlIGZpcnN0IHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50U3RlcDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZWQgdGhlIHdpZHRoIG9mIGNvbm5lY3RvcnMgYmV0d2VlbiBzdGVwcy4gVGhlIGNhbGN1bGF0aW9ucyBpcyBzb1xuICAgICAqIHRoYXQgdGhlIHN0ZXBzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seS5cbiAgICAgKi9cbiAgICBjb25uZWN0b3JXaWR0aDogYW55O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICAvLyBJbml0aWFsIGNvbG9yIGZvciB0aGUgZGlmZmVyZW50IHN0YWdlcyBvZiBzdGVwcy5cbiAgICAgICAgdGhpcy5zdGVwQ29sb3JDb21wbGV0ZWQgPSBTVEVQUEVSX0NPTVBMRVRFRF9TVEVQX0NPTE9SO1xuICAgICAgICB0aGlzLnN0ZXBDb2xvckN1cnJlbnQgPSBTVEVQUEVSX0NVUlJFTlRfU1RFUF9DT0xPUjtcbiAgICAgICAgdGhpcy5zdGVwQ29sb3JSZW1haW5pbmcgPSBTVEVQUEVSX1JFTUFJTklOR19TVEVQX0NPTE9SO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgY29ubmVjdG9yIHdpZHRoIGJhc2VkIG9uIGhvdyBtYW55IHN0ZXBzXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGVwcykgJiYgdGhpcy5zdGVwcy5sZW5ndGggPiAxKSB7XG5cbiAgICAgICAgICAgIC8vICgxMDAlIC0gMjAlIChzaWRlIG1hcmdpbnMpKSAvIChOdW1PZlN0ZXBzIC0xKVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3JXaWR0aCA9IE1hdGguY2VpbCg4MCAvICh0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpKSArICclJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhlIGNvbG9yIGFycmF5IGlmIGl0J3MgZGVmaW5lZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jb2xvcnMpKSB7XG5cbiAgICAgICAgICAgIHRoaXMuYlVzZUNvbG9yQXJyYXkgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcnMubGVuZ3RoICE9PSB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNpemUgb2YgdGhlIHN0ZXBzIGFuZCBjb2xvcnMgZG9uJ3QgbWF0Y2g6XG4gICAgICAgICAgICAgICAgICAoc3RlcHMubGVuZ3RoID0gJHt0aGlzLnN0ZXBzLmxlbmd0aH0pLCAoY29sb3JzLmxlbmd0aCA9ICR7dGhpcy5jb2xvcnMubGVuZ3RofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0dGluZyB0aGUgY29sb3Igb2YgdGhlIHN0ZXAgZm9yIHRoZSBjdXJyZW50IGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBnZXRTdGVwQ29sb3IoaW5kZXg6IG51bWJlcilcbiAgICB7XG4gICAgICAgIC8vIENvbG9yIEFycmF5IG92ZXJyaWRlcyBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0aGlzLmJVc2VDb2xvckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5jdXJyZW50U3RlcCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JDb21wbGV0ZWQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U3RlcCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JDdXJyZW50O1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvclJlbWFpbmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0b3IgY29sb3JzIGFyZSBkcml2ZW4gYnkgdGhlIHN0ZXAgY29sb3JzLlxuICAgICAqXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdG9yQ29sb3IoaW5kZXg6IG51bWJlcilcbiAgICB7XG4gICAgICAgIC8vIENvbG9yIEFycmF5IG92ZXJyaWRlcyBldmVyeXRoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0aGlzLmJVc2VDb2xvckFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xvcnNbaW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5jdXJyZW50U3RlcCkge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JDb21wbGV0ZWQ7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yUmVtYWluaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGVwLlxuICAgICAqL1xuICAgIG5leHRTdGVwKClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXArKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmV2aW91cyBzdGVwLlxuICAgICAqL1xuICAgIHByZXZTdGVwKClcbiAgICB7XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAtLTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBJbnB1dCwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmt9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCBzdGVwIGNvbXBvbmVudFxuICpcbiAqICAqIFVzYWdlOlxuICogICAgICAgU3RyYWlnaHQgZm9yd2FyZCB0byB1c2UuIEJ1dCBtb3N0bHkgaXQgd291bGQgYmUgdXNlZCBhcyBwYXJ0IG9mIHRoZSBzdGVwcGVyIGNvbXBvbmVudC5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RlcCBbdGl0bGVdPVwic3RlcFwiIFtjb2xvcl09XCJjb2xvclwiPjwvYXctc3RlcD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxuICovXG5cbiAgICAvLyBEZWZhdWx0IGNvbG9yIGZvciB0aGlzIHN0ZXAuXG5jb25zdCBERUZBVUxUX0NPTE9SID0gJyM1OGI5NTcnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXN0ZXAnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInN0ZXAtY29udGFpbmVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm91dGVyLWNpcmNsZVwiIFtzdHlsZS5ib3JkZXJDb2xvcl09XCJjb2xvclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaW5uZXItY2lyY2xlXCIgW3N0eWxlLmJvcmRlckNvbG9yXT1cImNvbG9yXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJjb2xvclwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInN0ZXAtdGl0bGVcIj57e3RpdGxlfX08L2Rpdj5cbjwvZGl2PlxuXG5gLFxuICAgIHN0eWxlczogW2Auc3RlcC1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MzJweH0ub3V0ZXItY2lyY2xle3dpZHRoOjI2cHg7aGVpZ2h0OjI2cHg7Ym9yZGVyLXJhZGl1czo1MCU7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjozcHggc29saWQgIzU4Yjk1Nztwb3NpdGlvbjpyZWxhdGl2ZX0uaW5uZXItY2lyY2xle3dpZHRoOjhweDtoZWlnaHQ6OHB4O2JvcmRlci1yYWRpdXM6NTAlO2JvcmRlcjoycHggc29saWQgIzU4Yjk1NztiYWNrZ3JvdW5kLWNvbG9yOiM1OGI5NTc7bWFyZ2luOjAgYXV0bztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO2xlZnQ6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKX0uc3RlcC10aXRsZXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxNTBweDt0b3A6NDBweDtsZWZ0Oi02MHB4O3RleHQtYWxpZ246Y2VudGVyfWBdXG59KVxuZXhwb3J0IGNsYXNzIFN0ZXBDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXRcbntcbiAgICAvKipcbiAgICAgKiBUaGUgY29sb3Igb2Ygc3RlcCBpY29uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29sb3I6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIHRpdGxlIGFwcGVhcnMgdW5kZXIgdGhlIHN0ZXAgZ3JhcGhpY3MuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY29sb3IpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gREVGQVVMVF9DT0xPUjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7U3RlcHBlckNvbXBvbmVudH0gZnJvbSAnLi9zdGVwcGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1N0ZXBDb21wb25lbnR9IGZyb20gJy4vc3RlcC9zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFN0ZXBDb21wb25lbnQsXG4gICAgICAgIFN0ZXBwZXJDb21wb25lbnRcblxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFN0ZXBDb21wb25lbnQsXG4gICAgICAgIFN0ZXBwZXJDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTdGVwcGVyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQYWdlTGlmZUN5Y2xlU2VydmljZX0gZnJvbSAnLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7T2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnR9IGZyb20gJy4vb2JqZWN0LXBhZ2Utd3JhcHBlci9vYmplY3QtcGFnZS13cmFwcGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VBY3Rpb25zQ29tcG9uZW50fSBmcm9tICcuL3BhZ2UtYWN0aW9ucy9wYWdlLWFjdGlvbnMuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUNvbnRlbnRDb21wb25lbnR9IGZyb20gJy4vcGFnZS1jb250ZW50L3BhZ2UtY29udGVudC5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL3BhZ2UtZm9vdGVyL3BhZ2UtZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VIZWFkZXJDb21wb25lbnR9IGZyb20gJy4vcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdGVwcGVyTW9kdWxlfSBmcm9tICcuLi9zdGVwcGVyL3N0ZXBwZXIubW9kdWxlJztcbmltcG9ydCB7U2lkZW5hdkNvbXBvbmVudH0gZnJvbSAnLi9zaWRlbmF2L3NpZGVuYXYuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7QVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlfSBmcm9tICcuLi9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtSb3V0ZXJNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE9iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgUGFnZUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIFBhZ2VGb290ZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIFNpZGVuYXZDb21wb25lbnRcblxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJvdXRlck1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV1N0ZXBwZXJNb2R1bGUsXG4gICAgICAgIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFBhZ2VGb290ZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBQYWdlQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFBhZ2VDb250ZW50Q29tcG9uZW50LFxuICAgICAgICBQYWdlRm9vdGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBTaWRlbmF2Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtQYWdlTGlmZUN5Y2xlU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQVdQYWdlV3JhcHBlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIFJpY2hUZXh0QXJlYSBjb21wb25lbnQgcmVwcmVzZW50cyBhIHRleHQgZWRpdG9yIHdoaWNoIGFsbG93cyB1c2VycyB0byBmb3JtYXQgdGV4dCBpbnB1dC5cbiAqIFRoZSBlZGl0b3IncyB0b29sYmFyIGlzIHByZS1jb25maWd1cmVkIHRvIGNvbnRhaW4gZnVuY3Rpb25hbGl0aWVzIHRoYXQgYXJlIGluIG91ciBkZXNpZ24uXG4gKiBAc2VlIHtAbGluayBlZGl0b3IvZWRpdG9yLmNvbXBvbmVudC5odG1sfVxuICpcbiAqICAjIyMgRXhhbXBsZVxuICogIGBgYFxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmZ4LWV2ZW50JyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICpcbiAqICAgICAgICA8IS0tIEJhc2ljIFVzYWdlLiAtLT5cbiAqICAgICAgICA8YXctcmljaHRleHRhcmVhIFtuYW1lXT1cIidkZXNjcmlwdGlvbidcIiBbdmFsdWVdPVwiZGVzY3JpcHRpb25cIiBwbGFjZUhvbGRlcj1cInB1dFxuICogICAgICAgIGRlc2NyaXB0aW9uXCI+XG4gKiAgICAgICAgPC9hdy1yaWNodGV4dGFyZWE+XG4gKlxuICogICAgICAgIDwhLS0gRWRpdG9yIHdpdGggRnVsbCBmdW5jdGlvbmFsaXR5IC0tPlxuICogICAgICA8YXctcmljaHRleHRhcmVhIFtuYW1lXT1cIidjb21tZW50J1wiIFt0eXBlXT1cImVkaXRvclR5cGVcIiBbdmFsdWVdPVwidmFsdWVcIlxuICogICAgICBwbGFjZUhvbGRlcj1cImhvbGQgdGhpc1wiPlxuICogICAgICA8L2F3LXJpY2h0ZXh0YXJlYT5cbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlDb21wb25lbnRcbiAqICAgIHtcbiAqICAgICAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICBlZGl0b3JUeXBlOkVkaXRvclR5cGUgPSBFZGl0b3JUeXBlLkZ1bGw7XG4gKiAgICAgICAgdmFsdWU6U3RyaW5nO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKiAgICB9XG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2YgdGV4dCBlZGl0b3IuIFRoZXkgYXJlIHByZWNvbmZpZ3VyZWQgd2l0aFxuICogZnVuY3Rpb25hbGl0eSBiYXNlZCBvbiB0eXBlLiBVc2UgY3VzdG9tIHRvIGFkZCB5b3VyIG93biB0b29sYmFyIG1lbnUuXG4gKi9cbmV4cG9ydCBlbnVtIEVkaXRvclR5cGUge1xuICAgIERlZmF1bHQsICAgIC8vIERlZmF1bHQgRWRpdG9yIHN1cHBvcnRzIE1pbmltYWwgc2V0IG9mIGZ1bmN0aW9uYWxpdHlcbiAgICAvLyBbIGJvbGQgfCBpdGFsaWMgfCB1bmRlcmxpbmUgfCBvcmRlcmVkIHwgYnVsbGV0IHwgYWxpZ25tZW50XVxuICAgIEZ1bGwsICAgICAgIC8vIFRoZSBmdWxsIGxpc3Qgb2YgZnVuY3Rpb25hbGl0eSxcbiAgICBUZXh0Rm9ybWF0LCAvLyBGdW5jdGlvbmFsaXRpZXMgdGhhdCBhZmZlY3RzIHRleHQgZm9ybWF0dGluZy5cbiAgICBDdXN0b20gICAgIC8vIEN1c3RvbSB0b29sYmFyLlxufVxuXG5cbmV4cG9ydCBjb25zdCBFRElUT1JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJpY2hUZXh0QXJlYUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yaWNodGV4dGFyZWEnLFxuICAgIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImVkaXRhYmxlXCI+XG5cbiAgICA8IS0tIEJhc2ljIGVkaXRvciwgYWxzbyB0aGUgZGVmYXVsdCwgd2hpY2ggdGhlIG1vc3QgdXNlZCBmZWF0dXJlcyBlbmFibGVkLiAtLT5cbiAgICA8ZGl2ICpuZ0lmPVwidHlwZSA9PT0gRWRpdG9yVHlwZS5EZWZhdWx0XCI+XG4gICAgICAgIDxwLWVkaXRvciBbKG5nTW9kZWwpXT1cInZhbHVlXCIgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFtzdHlsZV09XCJ7J2hlaWdodCc6JzE4MHB4J31cIlxuICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCI+XG4gICAgICAgICAgICA8cC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWJvbGRcIiBhcmlhLWxhYmVsPVwiQm9sZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWl0YWxpY1wiIGFyaWEtbGFiZWw9XCJJdGFsaWNcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC11bmRlcmxpbmVcIiBhcmlhLWxhYmVsPVwiVW5kZXJsaW5lXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1saXN0XCIgdmFsdWU9XCJvcmRlcmVkXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtbGlzdFwiIHZhbHVlPVwiYnVsbGV0XCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwibGVmdFwiIHNlbGVjdGVkPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJjZW50ZXJcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwicmlnaHRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwianVzdGlmeVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L3AtaGVhZGVyPlxuICAgICAgICA8L3AtZWRpdG9yPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBFZGl0b3Igd2l0aCBhbGwgdGhlIGZlYXR1cmVzIGVuYWJsZWQgLS0+XG4gICAgPGRpdiAqbmdJZj1cInR5cGUgPT09IEVkaXRvclR5cGUuRnVsbFwiPlxuICAgICAgICA8cC1lZGl0b3IgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbc3R5bGVdPVwieydoZWlnaHQnOicxODBweCd9XCJcbiAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiPjwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEVkaXRvciB3aXRoIGFsbCBUZXh0IGZvcm1hdHRpbmcgIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJ0eXBlID09PSBFZGl0b3JUeXBlLlRleHRGb3JtYXRcIj5cbiAgICAgICAgPHAtZWRpdG9yIFsobmdNb2RlbCldPVwidmFsdWVcIiBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW3N0eWxlXT1cInsnaGVpZ2h0JzonMTgwcHgnfVwiXG4gICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIj5cbiAgICAgICAgICAgIDxwLWhlYWRlcj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0LWdyb3VwXCI+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJGb250XCIgY2xhc3M9XCJxbC1mb250XCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInNhbnMtc2VyaWZcIiBzZWxlY3RlZD1cIlwiPlNhbnMgU2VyaWY8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwic2VyaWZcIj5TZXJpZjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJtb25vc3BhY2VcIj5Nb25vc3BhY2U8L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJTaXplXCIgY2xhc3M9XCJxbC1zaXplXCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEwcHhcIj5TbWFsbDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxM3B4XCIgc2VsZWN0ZWQ9XCJcIj5Ob3JtYWw8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMThweFwiPkxhcmdlPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjMycHhcIj5IdWdlPC9vcHRpb24+XG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtYm9sZFwiIGFyaWEtbGFiZWw9XCJCb2xkXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1pdGFsaWNcIiBhcmlhLWxhYmVsPVwiSXRhbGljXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC11bmRlcmxpbmVcIiBhcmlhLWxhYmVsPVwiVW5kZXJsaW5lXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0LWdyb3VwXCI+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJUZXh0IENvbG9yXCIgY2xhc3M9XCJxbC1jb2xvclwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMCwgMClcIiBsYWJlbD1cInJnYigwLCAwLCAwKVwiIHNlbGVjdGVkPVwiXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzAsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMjMwLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAxNTMsIDApXCIgbGFiZWw9XCJyZ2IoMjU1LCAxNTMsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMClcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDEzOCwgMClcIiBsYWJlbD1cInJnYigwLCAxMzgsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAxMDIsIDIwNClcIiBsYWJlbD1cInJnYigwLCAxMDIsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE1MywgNTEsIDI1NSlcIiBsYWJlbD1cInJnYigxNTMsIDUxLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjU1KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTAsIDIwNCwgMjA0KVwiIGxhYmVsPVwicmdiKDI1MCwgMjA0LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDIzNSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjM1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIzMiwgMjA0KVwiIGxhYmVsPVwicmdiKDIwNCwgMjMyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIyNCwgMjQ1KVwiIGxhYmVsPVwicmdiKDIwNCwgMjI0LCAyNDUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzUsIDIxNCwgMjU1KVwiIGxhYmVsPVwicmdiKDIzNSwgMjE0LCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxODcsIDE4NywgMTg3KVwiIGxhYmVsPVwicmdiKDE4NywgMTg3LCAxODcpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNDAsIDEwMiwgMTAyKVwiIGxhYmVsPVwicmdiKDI0MCwgMTAyLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDE5NCwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMTk0LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE4NSwgMTAyKVwiIGxhYmVsPVwicmdiKDEwMiwgMTg1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE2MywgMjI0KVwiIGxhYmVsPVwicmdiKDEwMiwgMTYzLCAyMjQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxOTQsIDEzMywgMjU1KVwiIGxhYmVsPVwicmdiKDE5NCwgMTMzLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMzYsIDEzNiwgMTM2KVwiIGxhYmVsPVwicmdiKDEzNiwgMTM2LCAxMzYpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNjEsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMTYxLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTc4LCAxMDcsIDApXCIgbGFiZWw9XCJyZ2IoMTc4LCAxMDcsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNzgsIDE3OCwgMClcIiBsYWJlbD1cInJnYigxNzgsIDE3OCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDk3LCAwKVwiIGxhYmVsPVwicmdiKDAsIDk3LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNzEsIDE3OClcIiBsYWJlbD1cInJnYigwLCA3MSwgMTc4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTA3LCAzNiwgMTc4KVwiIGxhYmVsPVwicmdiKDEwNywgMzYsIDE3OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDY4LCA2OCwgNjgpXCIgbGFiZWw9XCJyZ2IoNjgsIDY4LCA2OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDkyLCAwLCAwKVwiIGxhYmVsPVwicmdiKDkyLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCA2MSwgMClcIiBsYWJlbD1cInJnYigxMDIsIDYxLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxMDIsIDApXCIgbGFiZWw9XCJyZ2IoMTAyLCAxMDIsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA1NSwgMClcIiBsYWJlbD1cInJnYigwLCA1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDQxLCAxMDIpXCIgbGFiZWw9XCJyZ2IoMCwgNDEsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDYxLCAyMCwgMTAyKVwiIGxhYmVsPVwicmdiKDYxLCAyMCwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXQtc2VwYXJhdG9yXCI+PC9zcGFuPlxuICAgICAgICAgICAgICA8c2VsZWN0IHRpdGxlPVwiQmFja2dyb3VuZCBDb2xvclwiIGNsYXNzPVwicWwtYmFja2dyb3VuZFwiPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMCwgMClcIiBsYWJlbD1cInJnYigwLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjMwLCAwLCAwKVwiIGxhYmVsPVwicmdiKDIzMCwgMCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMTUzLCAwKVwiIGxhYmVsPVwicmdiKDI1NSwgMTUzLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDApXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAxMzgsIDApXCIgbGFiZWw9XCJyZ2IoMCwgMTM4LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMTAyLCAyMDQpXCIgbGFiZWw9XCJyZ2IoMCwgMTAyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNTMsIDUxLCAyNTUpXCIgbGFiZWw9XCJyZ2IoMTUzLCA1MSwgMjU1KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMjU1KVwiIHNlbGVjdGVkPVwiXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTAsIDIwNCwgMjA0KVwiIGxhYmVsPVwicmdiKDI1MCwgMjA0LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDIzNSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjM1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjA0KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIzMiwgMjA0KVwiIGxhYmVsPVwicmdiKDIwNCwgMjMyLCAyMDQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMDQsIDIyNCwgMjQ1KVwiIGxhYmVsPVwicmdiKDIwNCwgMjI0LCAyNDUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzUsIDIxNCwgMjU1KVwiIGxhYmVsPVwicmdiKDIzNSwgMjE0LCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxODcsIDE4NywgMTg3KVwiIGxhYmVsPVwicmdiKDE4NywgMTg3LCAxODcpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNDAsIDEwMiwgMTAyKVwiIGxhYmVsPVwicmdiKDI0MCwgMTAyLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDE5NCwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMTk0LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMTAyKVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE4NSwgMTAyKVwiIGxhYmVsPVwicmdiKDEwMiwgMTg1LCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDE2MywgMjI0KVwiIGxhYmVsPVwicmdiKDEwMiwgMTYzLCAyMjQpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxOTQsIDEzMywgMjU1KVwiIGxhYmVsPVwicmdiKDE5NCwgMTMzLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMzYsIDEzNiwgMTM2KVwiIGxhYmVsPVwicmdiKDEzNiwgMTM2LCAxMzYpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNjEsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMTYxLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTc4LCAxMDcsIDApXCIgbGFiZWw9XCJyZ2IoMTc4LCAxMDcsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNzgsIDE3OCwgMClcIiBsYWJlbD1cInJnYigxNzgsIDE3OCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDk3LCAwKVwiIGxhYmVsPVwicmdiKDAsIDk3LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNzEsIDE3OClcIiBsYWJlbD1cInJnYigwLCA3MSwgMTc4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTA3LCAzNiwgMTc4KVwiIGxhYmVsPVwicmdiKDEwNywgMzYsIDE3OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDY4LCA2OCwgNjgpXCIgbGFiZWw9XCJyZ2IoNjgsIDY4LCA2OClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDkyLCAwLCAwKVwiIGxhYmVsPVwicmdiKDkyLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCA2MSwgMClcIiBsYWJlbD1cInJnYigxMDIsIDYxLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTAyLCAxMDIsIDApXCIgbGFiZWw9XCJyZ2IoMTAyLCAxMDIsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA1NSwgMClcIiBsYWJlbD1cInJnYigwLCA1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDQxLCAxMDIpXCIgbGFiZWw9XCJyZ2IoMCwgNDEsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDYxLCAyMCwgMTAyKVwiIGxhYmVsPVwicmdiKDYxLCAyMCwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtbGlzdFwiIHZhbHVlPVwib3JkZXJlZFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1saXN0XCIgdmFsdWU9XCJidWxsZXRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdHNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImxlZnRcIiBzZWxlY3RlZD48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImNlbnRlclwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwicmlnaHRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImp1c3RpZnlcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvcC1oZWFkZXI+XG4gICAgICAgIDwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEN1c3RvbSBoZWFkZXIgVGV4dCBFZGl0b3IgLS0+XG4gICAgPGRpdiAqbmdJZj1cInR5cGUgPT09IEVkaXRvclR5cGUuQ3VzdG9tXCI+XG4gICAgICAgIDxwLWVkaXRvciBbKG5nTW9kZWwpXT1cInZhbHVlXCIgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFtzdHlsZV09XCJ7J2hlaWdodCc6JzE4MHB4J31cIlxuICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCI+XG4gICAgICAgICAgICA8cC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiY3VzdG9tLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvcC1oZWFkZXI+XG4gICAgICAgIDwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFlZGl0YWJsZVwiPlxuICAgIDxhdy1zdHJpbmcgW3ZhbHVlXT1cInZhbHVlXCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC51aS1lZGl0b3ItdG9vbGJhcntiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjU7Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3fS9kZWVwLyBwLWVkaXRvcjphY3RpdmUgL2RlZXAvIC51aS1lZGl0b3ItdG9vbGJhci5xbC10b29sYmFyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmZvY3VzIC9kZWVwLyAudWktZWRpdG9yLXRvb2xiYXIucWwtdG9vbGJhci5xbC1zbm93LC9kZWVwLyBwLWVkaXRvcjpob3ZlciAvZGVlcC8gLnVpLWVkaXRvci10b29sYmFyLnFsLXRvb2xiYXIucWwtc25vd3tib3JkZXItY29sb3I6IzE5OWRlMH0vZGVlcC8gcC1lZGl0b3I6YWN0aXZlIC9kZWVwLyAudWktZWRpdG9yLWNvbnRlbnQucWwtY29udGFpbmVyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmZvY3VzIC9kZWVwLyAudWktZWRpdG9yLWNvbnRlbnQucWwtY29udGFpbmVyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmhvdmVyIC9kZWVwLyAudWktZWRpdG9yLWNvbnRlbnQucWwtY29udGFpbmVyLnFsLXNub3d7Ym9yZGVyLWNvbG9yOiMxOTlkZTB9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIEVESVRPUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJpY2hUZXh0QXJlYUNvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIFJpY2hUZXh0QXJlYUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgZWRpdG9yLiAgU2VlIEVkaXRvclR5cGUgZm9yIGRlc2NyaXB0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogRWRpdG9yVHlwZTtcblxuICAgIC8qKlxuICAgICAqIEEgdmFsdWUgdXNlZCB0byBzYXZlIGFuZCByZWFkIHdoZW4gcmVuZGVyaW5nIGFuZCB1cGRhdGluZyB0aGlzIGNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIGVkaXRvclR5cGUgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiB0aGlzIGNvbXBvbmVudHMgdGVtcGxhdGUuXG4gICAgICovXG4gICAgRWRpdG9yVHlwZTogYW55ID0gRWRpdG9yVHlwZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLnR5cGUgPSBFZGl0b3JUeXBlLkRlZmF1bHQ7XG4gICAgICAgIHRoaXMuc3R5bGVDbGFzcyA9ICdkZWZhdWx0LWVkaXRvcic7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgICApLnN1YnNjcmliZSh2YWwgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0VkaXRvck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtSaWNoVGV4dEFyZWFDb21wb25lbnR9IGZyb20gJy4uL3JpY2gtdGV4dC1hcmVhL3JpY2gtdGV4dC1hcmVhLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmljaFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFJpY2hUZXh0QXJlYUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSaWNoVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmljaFRleHRBcmVhTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgT3V0cHV0LFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0FjY29yZGlvblRhYn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBBbGxvdyBkZXZlbG9wZXIgdG8gb3ZlcnJpZGUgZGVmYXVsdCBhY3Rpb25zLiBNdXN0IGhhdmUgdGhpcyBkZWNsYXJlZCBiZWZvcmUgY2xhc3Mgd2hlbiB3ZVxuICogd2FudCB0byBoYXZlIHRoaXMgZGVjbGFyYXRpb24gaW5zaWRlIHRoZSBzYW1lIGZpbGUuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2VjdGlvbi1hY3Rpb25zJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD4gYCxcbn0pXG5leHBvcnQgY2xhc3MgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbntcblxufVxuXG5cbi8qKlxuICpcbiAqIFNlY3Rpb24gY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBhIHNlY3Rpb24gb2YgdGhlIHBhZ2UuIEl0J3MgYW4gb3V0bGluZSBib3ggdGhhdFxuICogaGFzIHRoZSBhYmlsaXR5IHRvIGV4cGFuZCBhbmQgaGlkZSBpdHMgY29udGVudC5cbiAqXG4gKiBgYGB0c1xuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZngtZGV0YWlscycgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJTb3VyY2luZyByZXF1ZXN0IGluZm9cIiAob25FZGl0KT1cIm9uU3RhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICogICAgICAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICAgPG0tY29udGV4dCBbb2JqZWN0XT1cInJmeEVudGl0eS5oZWFkZXJJbmZvXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlcmF0aW9uXT1cInRoaXMuZWRpdGFiaWxpdHlTdGF0ZS5oZWFkZXJJbmZvT3BcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dD1cIkluc3BlY3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHVpR3JvdXA9XCJIZWFkZXJHZW5lcmFsXCI+XG4gKiAgICAgICAgICAgICAgICAgICA8bS1pbmNsdWRlLWNvbXBvbmVudD48L20taW5jbHVkZS1jb21wb25lbnQ+XG4gKiAgICAgICAgICAgICAgIDwvbS1jb250ZXh0PlxuICogICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKlxuICogICAgICAgICAgIDxhdy1zZWN0aW9uICNzdXBwbGllclNlY3Rpb24gdGl0bGU9XCJTZWxlY3RlZCBzdXBwbGllcnNcIiAob25PcGVuKT1cIm9uT3BlbigpXCJcbiAgICogICAgICAgICAgICAgICAgW29wZW5lZF09XCJmYWxzZVwiPlxuICogICAgICAgICAgICAgICA8c3VwcGxpZXItcHJvZmlsZS1jYXJkPjwvc3VwcGxpZXItcHJvZmlsZS1jYXJkPlxuICogICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKiAgICAgICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJSRlEgRGV0YWlsc1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb249XCJSZXZpZXcgYW5kIHVwZGF0ZSBpbmZvcm1hdGlvbiBmb3Igc3VwcGxpZXJzIHRvIHJlc3BvbmQuXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZUNsb3NlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgIDxhdy1zdWJzZWN0aW9uIHRpdGxlPVwiRXZlbnQgdGltZWxpbmVcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXRhYmxlIFt1c2VGaXZlWm9uZV09XCJmYWxzZVwiIFtlZGl0YWJsZV09XCJ0cnVlXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1N0YXJ0IERhdGUnXCIgW25hbWVdPVwiJ3N0YXJ0RGF0ZSdcIiBbc2l6ZV09XCInc21hbGwnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaGlnaGxpZ2h0Um93XT1cInRydWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRhdGUtdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0TmFtZT1cImRhdGVUaW1lXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJzdGFydERhdGVcIiBbdmFsdWVdPVwicmZ4RW50aXR5LmNyZWF0ZWRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Nob3dUaW1lXT1cInRydWVcIj48L2F3LWRhdGUtdGltZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXRhYmxlPlxuICogICAgICAgICAgICAgICA8L2F3LXN1YnNlY3Rpb24+XG4gKiAgICAgICAgICA8L2F3LXNlY3Rpb24+XG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIFNlY3Rpb24gY29tcG9uZW50IGFsc28gc3VwcG9ydHMgZWRpdGFiaWxpdHkgbW9kZXMgYW5kIGlmIGVuYWJsZWQgaXQgd2lsbCByZW5kZXIgYWN0aW9uIGJ1dHRvbnNcbiAqIGluIHRoZSBmb290ZXIuIERldmVsb3BlciBjYW4gYWxzbyBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yIGFuZCBwcm92aWRlIGN1c3RvbSBhY3Rpb25zLlxuICpcbiAqXG4gKiBlLmc6XG4gKlxuICogYGBgXG4gKiAgICAgIDxhdy1zZWN0aW9uIFt0aXRsZV09XCJ0aXRsZVwiIFtlZGl0YWJsZV09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAob25DYW5jZWxBY3Rpb24pPVwic29tZUhhbmRsZXIxKCRldmVudClcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvblNhdmVBY3Rpb24pPVwic29tZUhhbmRsZXIyKCRldmVudClcIiA+XG4gKiAgICAgICAgICAgICAgc2VjdGlvbiBjb250ZW50XG4gKlxuICpcbiAqICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqIGBgYFxuICpcbiAqIG9yIGN1c3RvbSBhY3Rpb24gYnV0dG9uczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqICAgICAgIDxhdy1zZWN0aW9uLWFjdGlvbnM+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uID5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1dHRvblRlc3QxXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdXR0b25UZXN0MlxuICogICAgICAgICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgPC9hdy1zZWN0aW9uLWFjdGlvbnM+XG4gKlxuICogYGBgXG4gKlxuICpcbiAqIFRoZXJlIGFyZSB0d28gZWRpdCBtb2Rlc1xuICogICMgRGVmYXVsdFxuICogICAgICBSZW5kZXJzIGFjdGlvbiBidXR0b25zIGluIHRoZSBmb290ZXJzIGFuZCBlbWl0IGFjdGlvbnMgdG8gdGhlIGFwcGxpY2F0aW9uXG4gKlxuICogICMgRXh0ZXJuYWxcbiAqICAgICBObyBhY3Rpb24gYnV0dG9ucyBhcmUgc2hvd24gaW4gdGhlIGZvb3RlciBhbmQgYmVoYXZpb3IgaXMgaGFuZGxlZCBieSBhcHBsaWNhdGlvbi4gT25seSBldmVudFxuICogICAgIGlzIGVtaXRlZC5cbiAqXG4gKlxuICogIGUuZzpcbiAqXG4gKiAgYGBgdHNcbiAqXG4gKiAgICAgIDxhdy1zZWN0aW9uIHRpdGxlPVwiVXNlciBJbmZvcm1hdGlvblwiIChvbkVkaXQpPVwib25BZGRTb21ldGhpbmcoJGV2ZW50KVwiXG4gKiAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJ0cnVlXCIgW2VkaXRNb2RlXT1cIidleHRlcm5hbCdcIiA+XG4gKiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgICBDb250ZW50XG4gKiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L2F3LXNlY3Rpb24+XG4gKlxuICogIGBgYFxuICpcbiAqIE5vdGU6IFdoZW4gdXNpbmcgZWRpdGluZyBtb2RlIHlvdSBoYXZlIHRvIGNhbGwgYXQgdGhlIGVuZCBvZiB0aGUgZWRpdGluZyBjeWNsZSBtZXRob2RcbiAqIGBjb21wbGV0ZUVkaXRpbmcoKWAgdG8gY29tbWl0IGVkaXRpbmcgd2hpY2ggY2hhbmdlcyBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgU2VjdGlvbi5cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zZWN0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHNlY3Rpb24tY29udGFpbmVyXCJcbiAgICAgW2NsYXNzLmVkaXRpbmddPVwiZWRpdGFibGUgJiYgZWRpdFN0YXRlICYmIGVkaXRNb2RlID09PSAnZGVmYXVsdCdcIj5cblxuICAgIDxwLWFjY29yZGlvbiAob25PcGVuKT1cIm9uU2VjdGlvbk9wZW4oJGV2ZW50KVwiIChvbkNsb3NlKT1cIm9uU2VjdGlvbkNsb3NlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICBbc3R5bGVDbGFzc109XCJhQ2xhc3MoKVwiPlxuICAgICAgICA8cC1hY2NvcmRpb25UYWIgI2FjY29yZGlvblRhYiBbc2VsZWN0ZWRdPVwib3BlbmVkXCIgW2Rpc2FibGVkXT1cImRpc2FibGVDbG9zZVwiPlxuICAgICAgICAgICAgPHAtaGVhZGVyPlxuICAgICAgICAgICAgICAgIDwhLS0gdGl0bGUgYW5kIGRlc2NyaXB0aW9uIC0tPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWhlYWRlci1jb250YWluZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24tdGl0bGVcIj57e3RpdGxlfX08L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhhc0Rlc2NyaXB0aW9uKClcIiBjbGFzcz1cInNlY3Rpb24tZGVzY3JpcHRpb25cIj57e2Rlc2NyaXB0aW9ufX08L2Rpdj5cblxuICAgICAgICAgICAgICAgICAgICA8IS0tIGFjdGlvbnM6IEhpZGUgd2hlbiBpbiBlZGl0aW5nIGFuZCBlZGl0TW9kZSBpcyBkZWZhdWx0IC0tPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiKGVkaXRhYmxlICYmICFlZGl0U3RhdGUgJiYgZWRpdE1vZGUgPT09ICdkZWZhdWx0JykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChlZGl0YWJsZSAmJiBlZGl0TW9kZSA9PT0gJ2V4dGVybmFsJylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwic2VjdGlvbi1hY3Rpb25zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YXctaHlwZXJsaW5rIChhY3Rpb24pPVwib25FZGl0QWN0aW9uKCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cInNhcC1pY29uIHNlY3Rpb24tZWRpdC1hY3Rpb25cIiBbbmdDbGFzc109XCJhY3Rpb25JY29uXCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1oeXBlcmxpbms+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9wLWhlYWRlcj5cblxuICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8L3AtYWNjb3JkaW9uVGFiPlxuICAgIDwvcC1hY2NvcmRpb24+XG4gICAgPCEtLVxuICAgICAgICBuZWVkIHRvIHB1dCBpdCBvdXRzaWRlIG9mIHAtYWNjb3JkaW9uIG90aGVyd2lzZSBidXR0b24gd2lsbCBpbmhlcml0IGRpZmZlcmVudFxuICAgICAgICBjb2xvciBzY2hlbWVcbiAgICAtLT5cbiAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi1mb290ZXItY29udGFpbmVyXCIgKm5nSWY9XCJlZGl0YWJsZSAmJiBlZGl0U3RhdGUgJiZcbiAgICAgICAgICAgIGVkaXRNb2RlID09PSAnZGVmYXVsdCdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvb3Rlci1hY3Rpb25zXCI+XG5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzQ3VzdG9tQWN0aW9ucygpXCI+XG4gICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIiBzaXplPVwic21hbGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNhbmNlbEFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgQ2FuY2VsXG4gICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBzaXplPVwic21hbGxcIiAoYWN0aW9uKT1cIm9uU2F2ZUFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICAgICAgU2F2ZVxuICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctc2VjdGlvbi1hY3Rpb25zXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnNlY3Rpb24taGVhZGVyLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0uc2VjdGlvbi1jb250YWluZXJ7bWFyZ2luOjEwcHggMDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7cGFkZGluZzouMmVtIC41ZW07Ym9yZGVyOjJweCBkYXNoZWQgdHJhbnNwYXJlbnR9LnNlY3Rpb24tY29udGFpbmVyLmVkaXRpbmd7Ym9yZGVyLWNvbG9yOiMxOTlkZTB9LnNlY3Rpb24tY29udGFpbmVyIDo6bmctZGVlcCAudWktYWNjb3JkaW9uLWhlYWRlcj5he2Rpc3BsYXk6ZmxleH0uc2VjdGlvbi1jb250YWluZXIgOjpuZy1kZWVwIC51aS1hY2NvcmRpb24taGVhZGVyPmEgLnVpLWFjY29yZGlvbi10b2dnbGUtaWNvbntmbGV4OjAgMCAzMHB4O3BhZGRpbmctdG9wOjJweH0uc2VjdGlvbi1jb250YWluZXIgOjpuZy1kZWVwIC51aS1hY2NvcmRpb24taGVhZGVyPmEgcC1oZWFkZXJ7ZmxleDoxIDB9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlci51aS1zdGF0ZS1kaXNhYmxlZHtvcGFjaXR5OjF9LnNlY3Rpb24tdGl0bGV7Zm9udC1zaXplOjEuMWVtfS5zZWN0aW9uLWRlc2NyaXB0aW9ue2ZvbnQtc2l6ZTouOWVtO3BhZGRpbmc6LjZlbSAwIC4yZW19LnNlY3Rpb24tZm9vdGVyLWNvbnRhaW5lcnttYXJnaW46MWVtIDJlbSAwO3BhZGRpbmc6LjhlbSAwIDEuNWVtIC44ZW07Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkN30uc2VjdGlvbi1mb290ZXItY29udGFpbmVyIC5mb290ZXItYWN0aW9uc3tkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOnJpZ2h0O3dpZHRoOjEwMCV9LnNlY3Rpb24tYWN0aW9uc3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtyaWdodDowO3otaW5kZXg6MX0uc2VjdGlvbi1hY3Rpb25zIC9kZWVwLyBhLmxpbmssLnNlY3Rpb24tYWN0aW9ucyAvZGVlcC8gYS5saW5rOmhvdmVye3BhZGRpbmc6MDt0ZXh0LWRlY29yYXRpb246bm9uZX0uc2VjdGlvbi1lZGl0LWFjdGlvbntmb250LXNpemU6MS41ZW07cG9zaXRpb246cmVsYXRpdmU7cGFkZGluZzouMWVtIDAgLjFlbSAuNWVtO2N1cnNvcjpwb2ludGVyfS5zZWN0aW9uLWVkaXQtYWN0aW9uLmljb24tZWRpdHtmb250LXNpemU6MS40ZW19LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlcntjb2xvcjojMzYzNjM2O2JvcmRlcjpub25lO2JhY2tncm91bmQ6I2ZmZiFpbXBvcnRhbnQ7cGFkZGluZzowIDFlbX0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC51aS1hY2NvcmRpb24tY29udGVudHtib3JkZXI6bm9uZTtwYWRkaW5nOjFlbSAyZW19LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gYVtyb2xlPXRhYl17cGFkZGluZzouNzVlbSAwO3RleHQtZGVjb3JhdGlvbjpub25lfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtYWN0aXZlIC9kZWVwLyBhW3JvbGU9dGFiXXtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZDdkN2Q3O2NvbG9yOiMzNjM2MzZ9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAuc2VjdGlvbi1uby1oZWFkZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVye2hlaWdodDoxcHh9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAuc2VjdGlvbi1uby1oZWFkZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyLnVpLXN0YXRlLWFjdGl2ZSAvZGVlcC8gYVtyb2xlPXRhYl17Ym9yZGVyLWJvdHRvbTpub25lfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnNlY3Rpb24tbm8taGVhZGVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAuc2VjdGlvbi1lZGl0LWFjdGlvbntjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnR9Omhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyAucGkucGktY2FyZXQtZG93biw6aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgL2RlZXAvIC5waS5waS1jYXJldC1yaWdodHtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Zm9udC1zaXplOjEuMWVtO3RvcDouOGVtO2xlZnQ6LjFlbTtjb2xvcjojNzY3Njc2O21hcmdpbi10b3A6MH06aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtZGlzYWJsZWQgL2RlZXAvIC5mYSw6aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtZGlzYWJsZWQgL2RlZXAvIC5waXtkaXNwbGF5Om5vbmV9Omhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyAucGkucGktY2FyZXQtcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6XCJcXFxcZTFlZFwifTpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gLnBpLnBpLWNhcmV0LWRvd246YmVmb3Jle2NvbnRlbnQ6XCJcXFxcZTFlZlwifWBdXG59KVxuZXhwb3J0IGNsYXNzIFNlY3Rpb25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBzZWN0aW9uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0aXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlc2NyaXB0aW9uIG9mIHRoaXMgc2VjdGlvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgdGhpcyBzZWN0aW9uIGJlIG9wZW5lZCBhdCB0aGUgc3RhcnQuIERlZmF1bHQgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb3BlbmVkOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBzZWN0aW9uIGNhbiBiZSBjbG9zZWQgb3Igbm90LlxuICAgICAqKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc2FibGVDbG9zZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHNlY3Rpb24gaXMgaW4gRWRpdFN0YXRlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIFdoZW4gaW4gZWRpdGluZyBzdGF0ZSBhbmQgd2Ugc2hvdyBcIkNhbmNlbCAvIFNhdmVcIiBidXR0b24gZGV2ZWxvcGVyIG5lZWRzIHVzZSB0aGlzIGJpbmRpbmdcbiAgICAgKiB0byBjb250cm9sIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVkaXRTdGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IEVkaXRpbmcgbW9kZS4gVGVsbHMgdGhlIGNvbXBvbmVudHMgaWYgaXRzIGl0cyBkZWZhdWx0IGJlaGF2aW9yIG9yIGRyaXZlbiBieVxuICAgICAqIGFwcGxpY2F0aW9uIHVzaW5nIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICoge0BzZWUgRWRpdE1vZGV9XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVkaXRNb2RlOiBFZGl0TW9kZSA9ICdkZWZhdWx0JztcblxuXG4gICAgLyoqXG4gICAgICogRGV2ZWxvcGVyIGNhbiBwcm92aWRlIGN1c3RvbSBFZGl0IGFjdGlvbiBpY29uIHRoYXQgd2lsbCBhcHBlYXIgaW4gdGhlIHJpZ2h0IHRvcCBjb3JuZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFjdGlvbkljb246IHN0cmluZyA9ICdpY29uLWVkaXQnO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWN0aW9uIGlzIGZ1bGx5IG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBzZWN0aW9uIGlzIGZ1bGx5IGNsb3NlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEVkaXQgc3RhdGUgdG8gYnJvYWRjYXN0IHN0YXRlIG9mIGN1cnJlbnQgc2VjdGlvblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uRWRpdDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaW4gZWRpdGluZyBzdGF0ZSBhbmQgZGVmYXVsdCBidXR0b25zIGFyZSByZW5kZXJlZCBvbiBjbGljayBicm9hZGNhc3QgQ2FuY2VsIGFjdGlvblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2FuY2VsQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbiBlZGl0aW5nIHN0YXRlIGFuZCBkZWZhdWx0IGJ1dHRvbnMgYXJlIHJlbmRlcmVkIG9uIGNsaWNrIGJyb2FkY2FzdCBTYXZlIGFjdGlvblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2F2ZUFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIEBPdXRwdXQoKVxuICAgIG9uRWRpdGluZ0NvbXBsZXRlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIExvY2FsIHZhcmlhYmxlIG9uIHdoZXRoZXIgdGhpcyBzZWN0aW9uIGlzIGV4cGFuZGVkIG9yIG5vdC5cbiAgICAgKiBEaWZmZXJzIGZyb20gJ29wZW5lZCcuIG9wZW5lZCBpcyBhbiBpbnB1dCBwYXJhbWV0ZXIgYW5kIGl0IGRvZXNuJ3QgdHJhY2tcbiAgICAgKiBjdXJyZW50IHNlY3Rpb24gZXhwYW5kZWQgc3RhdGUuXG4gICAgICovXG4gICAgZXhwYW5kZWQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBhY2NvcmRpb25UYWJcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdhY2NvcmRpb25UYWInKVxuICAgIHByaXZhdGUgYWNjb3JkaW9uVGFiOiBBY2NvcmRpb25UYWI7XG5cblxuICAgIC8qKlxuICAgICAqIFNhdmUgcmVmZXJlbmNlIHRvIGRldmVsb3BlcidzIGRlZmluZWQgYWN0aW9ucyBzbyBpZiB3ZSBjYW4gaGlkZSBkZWZhdWx0IG9uZXNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50KVxuICAgIGN1c3RvbUFjdGlvbnM6IFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgdGhpcy5lZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIC8vIElmIEkgaGF2ZSBub3QgaGVhZGVyLCB0aGVuIEkgY2FuJ3QgY2xvc2UgdGhlIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5pc0hlYWRlckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBJIGNhbid0IGNsb3NlIHRoZSBzZWN0aW9uLCB0aGVuIGl0IHNob3VsZCBkZWZhdWx0IG9wZW4uXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBleHBhbmRlZCBzdGF0ZS5cbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRoaXMub3BlbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvbid0IGRpc3BsYXkgaGVhZGVyIGFyZWEgaWYgSSBkb24ndCBoYXZlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaXNIZWFkZXJEaXNwbGF5ZWQoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQodGhpcy50aXRsZSkgfHwgaXNQcmVzZW50KHRoaXMuZGVzY3JpcHRpb24pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDc3MgQ2xhc3MgdGhhdCBjb250cm9sIHRoZSBsb29rIGFuZCBmZWVsIGZvciBzZWN0aW9uIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBhQ2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuaXNIZWFkZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdzZWN0aW9uLW5vLWhlYWRlcic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UgaW50cm9kdWNlZCBidXR0b25zIGFuZCBlZGl0U3RhdGUgdGhlIGRlY2lzaW9uIG9uIHdoZW4gdG8gZXhpdCBlZGl0aW5nIG1vZGVcbiAgICAgKiBzaG91bGQgYmUgb24gdGhlIGRldmVsb3BlciB1c2luZyB0aGlzIGNvbXBvbmVudCB0aGVyZWZvcmUgb25seSBzdGFydEVkaXRpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRWRpdEFjdGlvbigkZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgLy8gd2hlbiBpbiBlZGl0aW5nIG1ha2Ugc3VyZSB3ZSBkb250IHN3aXRjaCBzdGF0ZSBhcyB0aGVyZSBjYW4gYmUgc29tZSBGb3JtIGVycm9yc1xuICAgICAgICAvLyB3aGljaCBuZWVkcyB0byBiZSBoYW5kbGVkIGJ5IGRldmVsb3BlciBhbmQgb25seSB0aGVuIGNoYW5nZSB0aGUgZWRpdFN0YXRlXG4gICAgICAgIGlmICghdGhpcy5lZGl0U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdFN0YXRlID0gIXRoaXMuZWRpdFN0YXRlO1xuICAgICAgICAgICAgbGV0IHN0YXRlOiBzdHJpbmcgPSAodGhpcy5lZGl0U3RhdGUpID8gJ2luRWRpdCcgOiAnbm90SW5FZGl0JztcblxuICAgICAgICAgICAgdGhpcy5vbkVkaXQuZW1pdChzdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIG9yaWdpbmFsIGV2ZW50IGZyb20gYnViYmxpbmcgdXAuIEJlY2F1c2UgdGhlIGVkaXQgaWNvbiBpcyBpbnNpZGVcbiAgICAgICAgLy8gdGhlIGhlYWRlci4gSWYgdGhlIGNsaWNrIGV2ZW4gaXMgYnViYmxlZCB1cCwgdGhpcyBldmVudCB3aWxsIGNhdXNlIHRoZSBzZWN0aW9uIHRvXG4gICAgICAgIC8vIGV4cGFuZCBvciBjb2xsYXBzZS5cbiAgICAgICAgaWYgKGlzUHJlc2VudCgkZXZlbnQuZXZlbnQpKSB7XG4gICAgICAgICAgICAkZXZlbnQuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkZXZlbnQuZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc0Rlc2NyaXB0aW9uKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5kZXNjcmlwdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiB0aGlzIHNlY3Rpb24sIGlmIGl0J3MgYWxyZWFkeSBvcGVuLCB3aWxsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgb3BlbihldmVudD86IGFueSk6IHZvaWRcbiAgICB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvblRhYi50b2dnbGUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhpcyBzZWN0aW9uLCBpZiBpdCdzIGFscmVhZHkgY2xvc2UsIHdpbGwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBjbG9zZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3JkaW9uVGFiLnRvZ2dsZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYWNjb3JkaW9uIGlzIG9wZW5lZFxuICAgICAqXG4gICAgICovXG4gICAgb25TZWN0aW9uT3BlbihldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoJ29wZW4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW4gYWNjb3JkaW9uIGlzIGNsb3NlZFxuICAgICAqXG4gICAgICovXG4gICAgb25TZWN0aW9uQ2xvc2UoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHVzIGlmIHdlIG5lZWQgdG8gcmVuZGVyIGFwcGxpY2F0aW9uIGRlZmluZWQgY3VzdG9tIGFjdGlvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0N1c3RvbUFjdGlvbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmN1c3RvbUFjdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXQgdGhlIGVkaXRpbmcgc3RhdGUgYmFjayB0byBub24tZWRpdGFibGVcbiAgICAgKi9cbiAgICBjb21wbGV0ZUVkaXRpbmcoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5lZGl0U3RhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkVkaXRpbmdDb21wbGV0ZS5lbWl0KHRoaXMuZWRpdFN0YXRlKTtcbiAgICB9XG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3Vic2VjdGlvbicsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwic3Vic2VjdGlvbi10aXRsZVwiPnt7dGl0bGV9fTwvaDQ+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICAgYCxcbiAgICBzdHlsZXM6IFsnLnN1YnNlY3Rpb24tdGl0bGUge2NvbG9yOiAjMzYzNjM2OyB9J11cbn0pXG5leHBvcnQgY2xhc3MgU3ViU2VjdGlvbkNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoaXMgc3ViIHNlY3Rpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG59XG5cblxuLyoqXG4gKiBEZWZpbmVzIGVkaXRpbmcgbW9kZXMgZm9yIHRoZSBTZWN0aW9ucy4gRGVmYXVsdCBtZWFucyB3ZSBzaG93IGNhbmNlbCAvIHNhdmUgYnV0dG9ucyBhbmQgaGlkZVxuICogZWRpdCBpY29ucyB3aGVuIGluIGVkaXRpbmcuIGV4dGVybmFsIGlzIGRyaXZlbiBieSBhcHBsaWNhdGlvblxuICovXG5leHBvcnQgdHlwZSBFZGl0TW9kZSA9ICdkZWZhdWx0JyB8ICdleHRlcm5hbCc7XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QXJpYmFDb3JlTW9kdWxlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtBY2NvcmRpb25Nb2R1bGUsIFNoYXJlZE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7U2VjdGlvbkFjdGlvbnNDb21wb25lbnQsIFNlY3Rpb25Db21wb25lbnQsIFN1YlNlY3Rpb25Db21wb25lbnR9IGZyb20gJy4vc2VjdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi4vaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFN1YlNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQWNjb3JkaW9uTW9kdWxlLFxuICAgICAgICBBcmliYUNvcmVNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgU2hhcmVkTW9kdWxlXG4gICAgXSxcblxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTdWJTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgU3ViU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdTZWN0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBJbnB1dCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FXRGF0YVRhYmxlfSBmcm9tICcuLi9hdy1kYXRhdGFibGUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jvb2xlYW5XcmFwcGVyLCBFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuZXhwb3J0IHR5cGUgRFRIQWxpZ25tZW50ID0gJ2xlZnQnIHwgJ2NlbnRlcicgfCAncmlnaHQnO1xuXG5cbi8qKlxuICogRFRDb2x1bW4gcmVwcmVzZW50IHNpbmdsZSBjb2x1bW4gaW5jbHVkaW5nIGhlYWRlciBhbmQgaXRzIGJvZHkuIEVhY2ggY29sdW1uIGhhcyBpdHMgb3duXG4gKiByZW5kZXJlclRlbXBsYXRlIHdoaWNoIGEgZW50cnkgdG8gdGhpcyBjb21wb25lbnQuXG4gKlxuICogS2VlcGluZyB0aGlzIHNlcGFyYXRlIGZyb20gdGhlIGRhdGF0YWJsZSB3aGVyZSBEVCBpcyBub3QgcmVhbGx5IGF3YXJlIHdoYXQgaXQgaXMgcmVuZGVyaW5nLFxuICogaXQgYWxsb3dzIHVzIG1vcmUgZmxleGliaWxpdHkgaW4gdGVybXMgb2YgZGlmZmVyZW50IHR5cGUgb2YgY29sdW1uIGluaGVyaXRpbmcgZnJvbSB0aGlzXG4gKiBvbmUuLiBTdWNoIGFzOlxuICogIERUUm93RGV0YWlsICBjb2x1bW5cbiAqICBEVFNpbmdsZVNlbGVjdGlvbiBjb2x1bW5cbiAqICBEVE11bHRpU2VsZWN0aW9uIGNvbHVtblxuICpcbiAqIFRoaXMgd2F5IHdlIGRvbid0IGRvIElGL1RIRU4vRUxTRSBpbnNpZGUgdGhlIGRhdGF0YWJsZSBhbmQgdHJ5aW5nIHRvIGNyZWF0ZSBkaWZmZXJlbnQgY2FzZXMuXG4gKlxuICogIFRoZW4gbGF0ZXIgb24gdGhpcyB3aWxsIGxldCB1cyBjcmVhdGUgYWRkaXRpb25hbCBsb2dpYyBmb3IgdGhlIHBpdm90YWwgbGF5b3V0LiBCZWNhdXNlIERUXG4gKiAgZG9lcyBrbm93IGFueXRoaW5nIGFib3V0IHRoZSB0eXBlIG9mIHRoZSBjb2x1bW4gc28gd2hhdGV2ZXIgaXMgYWRkZWQgdG8gdGhlIERULmNvbHVtbnMgaXRcbiAqICB3aWxsIGJlIHJlbmRlcmVkLlxuICpcbiAqXG4gKiAgQ29sdW1ucyBjYW4gYmUgYWxzbyBmcm96ZW4gbWVhbmluZyBpZiB0aGUgY29udGVudCBvdmVyZmxvd3MgdGhleSBkb250IHNjcm9sbC4gVG8gbWFrZSB0aGVcbiAqICBjb2x1bW4gZnJvemVuIHdlIG5lZWQgdG8gdXNlIFtmcm96ZW5dIGJpbmRpbmcgYW5kIHNlIGl0IHRvIFRSVUUgcGx1cyBpdCByZXF1aXJlcyBhIFt3aWR0aF1cbiAqICBiaW5kaW5nIHRvIGJlIHNldCAoaW4gcHgpLlxuICogIFdlIG5lZWQgdGhpcyB0byBiZSBhYmxlIHRvIHByb3Blcmx5IHBvc2l0aW9uIHRoZSBzZWNvbmQgdGFibGUgd2hpY2ggaXMgY2hhbmdlZCB0byBhYnNvbHV0ZVxuICogIHBvc2l0aW9uaW5nLlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWNvbHVtbjInLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFRvIG1ha2UgaXQgbW9yZSByZWFkYWJsZSBFYWNoIENvbHVtbiB0eXBlIGhhcyBpdHMgb3duIHJlbmRlcmluZyB0ZW1wbGF0ZSBpbnN0ZWFkIG9mIHB1dHRpbmdcbiAgICBhbGwgdGhpcyBpbnRvIGRhdGF0YWJsZSBhcyB0aGlzIGlzIG1vcmUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGNvbHVtbi4gQW5kIHRoZSBtYWluIGdvYWxcbiAgICB3YXMgdHJ5IHRvIGJlIG1vZHVsYXIgYXMgcG9zc2libGUuIFdoZW4gVGhlcmUgd2lsbCBiZSBkaWZmZXJlbnQgdHlwZXMgb2YgY29sdW1uc1xuXG4gICAgLSBSZWd1bGFyIERUQ29sdW1uIChjdXJyZW50IGltcGxlbWVudGF0aW9uKSxcbiAgICAtIFNlbGVjdGlvbkNvbHVtbiAoU2luZ2xlL011bHRpIHNlbGVjdCkgLSB0b2RvLFxuICAgIC0gRGV0YWlsUm93IGNvbHVtbiwgdGhlbiBwaXZvdGFsIGNvbGx1bW4gdG8gcmVuZGVyIHJvdy9jb2x1bW4vZGV0YWlsIGF0dHJpYnV0ZXMgLSB0b2RvLlxuXG4gICAgV2hlbiBpbXBsZW1lbnRpbmcgbmV3IGNvbHVtbiB0eXBlIHlvdSBqdXN0IGluaGVyaXQgdGhpcyBEVENvbHVtbkNvbXBvbmVudCBhbmQgcHJvdmlkZSB5b3VyXG4gICAgb3duIHJlbmRlcmluZyB0ZW1wbGF0ZSBhbmQgRFQgdGFrZSBjYXJlIG9mIHRoZSByZXN0LlxuXG4gICAgdG9kbzogV2UgaGF2ZSBTaW5nbGVTZWxlY3QsIE11bHRpc2VsZWN0IHJlbmRlcmluZyB0ZW1wbGF0ZSB0aGF0IGlzIEFkZGVkIHByb2dyYW1hdGljYWxseVxuICAgIHRvZG86IFdlIGhhdmUgcGl2b3RhbCByZW5kZXJpbmcgdGVtcGxhdGVcblxuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjcmVuZGVyaW5nVGVtcGxhdGUgbGV0LWlzSGVhZGVyIGxldC1pc1N1YkhlYWRlcj1cImlzU3ViSGVhZGVyXCIgbGV0LWNvbHVtbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgbGV0LWRhdGFUb1JlbmRlcj1cImRhdGFcIlxuICAgICAgICAgICAgIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xIZWFkZXJcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXNTdWJIZWFkZXIsIGNvbHVtbkluZGV4OmNvbHVtbkluZGV4LCBkYXRhOiBkYXRhVG9SZW5kZXIsXG4gICAgICAgICAgICAgICAgIHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xCb2R5XCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGNvbHVtbiwgZGF0YTpkYXRhVG9SZW5kZXIscm93SW5kZXg6cm93SW5kZXh9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvbmctdGVtcGxhdGU+XG5cblxuPCEtLVxuICAgIFRlbXBsYXRlcyBmb3IgaGVhZGVyIGNvbHVtbnMuIEhlcmUgd2UgYXJlIHJlbmRlcmluZyB0d28gdHlwZXMuIEhlYWRlciBhbmQgU3ViaGVhZGVyIHRoYXQgd2VcbiAgICB1c3VhbGx5IHVzZSBoZXJlIGFzIHNvbWUga2luZCBvZiBzdW1tYXJ5IGNvbHVtbnMuIE5vdCByZWFsbHkgaGF2aW5nIHN1bW1hcnkgYXQgdGhlIGJvdHRvbSBsaWtlIG90aGVyXG4gICAgRFQuXG5cbiAgICBUSCBjb2x1bW4gYW5kIHRoZWlyIHRleHQgYXJlIHVzdWFsbHkgdW5zZWxlY3RhYmxlIGFuZCBtb3N0IG9mIHRoZXNlIHdlcmUgaW5oZXJpdGVkIGZyb21cbiAgICBvcmlnaW5hbCBQcmltZU5nIERUIGV2ZW4gbm90IG1hbnkgdGhpbmdzIGdvdCBsZWZ0IGFmdGVyIHdlIHJlZmFjdG9yIHRoaXMgYnV0IHRoZSBpZGVhIGlzIHRoZVxuICAgIHNhbWUuXG5cbiAgICBFYWNoIGNlbGwgaGFzIGl0cyBkdC1jZWxsLWRlZiBjbGFzcyB0aGF0IHNldHMgZGVmYXVsdCBzdHlsaW5nIGxpa2UgZm9udCwgYmFja2dyb3VuZCwgYWxpZ25tZW50XG4gICAgcGFkZGluZywgZXRjcy4uXG5cblxuLS0+XG48bmctdGVtcGxhdGUgI2NvbEhlYWRlciBsZXQtaXNTdWJIZWFkZXIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIiBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPHRoICNoZWFkZXJDZWxsMSBbY2xhc3NdPVwiaGVhZGVyU3R5bGVDbGFzc3x8c3R5bGVDbGFzc1wiICpuZ0lmPVwiIWlzU3ViSGVhZGVyXCJcbiAgICAgICAgKGNsaWNrKT1cImhhbmRsZUhlYWRlckNsaWNrKCRldmVudCwgaGVhZGVyQ2VsbDEpXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LXUtdW5zZWxlY3RhYmxlLXRleHQnIDp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtY2VsbC1kZWYnOiBkdC5zZWxlY3Rpb25Nb2RlICE9PSAnY2VsbCcgfHwgKCFkdC5pc091dGxpbmUoKSB8fCAhZHQucGl2b3RhbExheW91dCksXG4gICAgICAgICAgICAgICAgICAgICdkdC11LXNvcnRhYmxlJzogc29ydGFibGUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1pcy1hY3RpdmUnOiBpc1NvcnRlZCgpLFxuICAgICAgICAgICAgICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWlzVmlzaWJsZX1cIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmFsaWduXT1cImFsaWduXCJcbiAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwic29ydGFibGUgPyAxIDogbnVsbFwiXG4gICAgICAgIFttYXhXaWR0aF09XCJtYXhXaWR0aFB4XCJcbiAgICA+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImR0LmhlYWRlckZpbHRlclRlbXBsYXRlICYmIGNvbHVtbkluZGV4ID09PSAwIFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImR0LmhlYWRlckZpbHRlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPCEtLVxuICAgICAgICAgICAgd2hlbiBjZWxsIGFyZSBzZWxlY3RhYmxlIHdlIG5lZWQgdHdvIHZlcnNpb24gd2hlcmUgb25lIHdyYXAgdGhlIGNlbGwgY29udGVudCBpbiBkaXZcbiAgICAgICAgLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc0hlYWRlclNlbGVjdGFibGUoKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInNlbGVjdGFibGVIZWFkZXJDZWxsOyBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzSGVhZGVyU2VsZWN0YWJsZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9uU2VsZWN0YWJsZUhlYWRlckNlbGw7IGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXN9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RoPlxuXG4gICAgPHRoICNoZWFkZXJDZWxsMiBbY2xhc3NdPVwiaGVhZGVyU3R5bGVDbGFzc3x8c3R5bGVDbGFzc1wiICpuZ0lmPVwiaXNTdWJIZWFkZXJcIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmFsaWduXT1cImFsaWduXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LWNlbGwtZGVmIGR0LXN1Yi1oZWFkZXIgZHQtdS11bnNlbGVjdGFibGUtdGV4dCc6dHJ1ZX1cIlxuICAgICAgICBbbWF4V2lkdGhdPVwibWF4V2lkdGhQeFwiPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLXRpdGxlXCIgKm5nSWY9XCJkdC5zaG93U3ViSGVhZGVyICYmIHN1YkhlYWRlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic3ViSGVhZGVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIHJvd0RhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgPC90aD5cbjwvbmctdGVtcGxhdGU+XG5cblxuPCEtLVxuICAgIFRlbXBsYXRlIGZvciB0aGUgYm9keSA9IHRoZSBURC4gRm9yIHRoZSBib2R5IGFuZCB3ZSBtaWdodCB3YW50IHRvIGRvIHRoZSBzYW1lIGZvciBoZWFkZXIgd2VcbiAgICBhbGxvdyB0byBoYXZlIGNhbGN1bGF0ZWQgYm9keSBjbGFzcyB0aGF0IGNvbWVzIGZyb20gdGhlIGFwcGxpY2F0aW9uLiBTbyBiYXNlZCBvbiB0aGUgZGF0YSB0eXBlc1xuICAgIHlvdSBtaWdodCB3YW50IHRvIGFwcGx5IGRpZmZlcmVudCBjbGFzcyBpbiBvcmRlciB0byBhcHBseSBjdXN0b20gc3R5bGluZy5cbi0tPlxuPG5nLXRlbXBsYXRlICNjb2xCb2R5IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8dGQgI2NlbGwgW2NsYXNzXT1cImR5bmFtaWNCb2R5Q2xhc3MoZGF0YSlcIlxuICAgICAgICAoY2xpY2spPVwiZHQub25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGwsIHRoaXMsIGRhdGEpXCJcbiAgICAgICAgW2F0dHIud2lkdGhdPVwid2lkdGhcIlxuICAgICAgICBbYXR0ci5hbGlnbl09XCJhbGlnblwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQnOiB0cnVlLFxuICAgICAgICAnZHQtY2VsbC1kZWYnOiAhaXNDZWxsU2VsZWN0YWJsZShkYXRhKSxcbiAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFpc1Zpc2libGV9XCJcbiAgICAgICAgW21heFdpZHRoXT1cIm1heFdpZHRoUHhcIj5cblxuICAgICAgICA8IS0tXG4gICAgICAgICAgICBTaW5jZSB3ZSBuZWVkIHRvIHN1cHBvcnQgY2VsbCBzZWxlY3Rpb24gd2hlbiB3ZSBuZWVkIHRvIGRyYXcgYm9yZGVyIGFyb3VuZCBpdFxuICAgICAgICAgICAgV2UgYXJlIHdyYXBwaW5nIHN1Y2ggc2VsbHMgd2l0aCBkaXYgd2hpY2ggZ2l2ZXMgdXMgYmV0dGVyIGZsZXhpYmlsaXR5XG4gICAgICAgIC0tPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNDZWxsU2VsZWN0YWJsZShkYXRhKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInNlbGVjdGFibGVCb2R5Q2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIGRhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleCB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc0NlbGxTZWxlY3RhYmxlKGRhdGEpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9uU2VsZWN0YWJsZUJvZHlDZWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8L3RkPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLVxuICAgIFRvZG86IGNyZWF0ZSBiZXR0ZXIgc29sdXRpb24gaW5zdGVhZCBvZiB1c2luZyBkaWZmZXJlbnQgdGVtcGxhdGUgY3JlYXRlIGRpcmVjdGl2ZSB0aGF0IHdyYXBzXG4gICAgaXQgd2l0aCB0aGUgZGl2IGNvbmRpdGlvbmFsbHlcbi0tPlxuPG5nLXRlbXBsYXRlICNzZWxlY3RhYmxlSGVhZGVyQ2VsbCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cImR0LWNlbGwtZGVmLXNlbGVjdGFibGVcIlxuICAgICAgICAgW25nQ2xhc3NdPVwieydkdC1jZWxsLXNlbGVjdGVkJzogZHQuaXNIZWFkZXJTZWxlY3RlZCh0aGlzKX1cIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlckNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNub25TZWxlY3RhYmxlSGVhZGVyQ2VsbCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXJDZWxsQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIGRhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNoZWFkZXJDZWxsQ29udGVudCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLXRpdGxlXCIgKm5nSWY9XCJzaG93Q29sdW1uTGFiZWwgJiYgIWhlYWRlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAge3tsYWJlbH19XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtdGl0bGVcIiAqbmdJZj1cInNob3dDb2x1bW5MYWJlbCAmJiBoZWFkZXJUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCByb3dEYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXggfVwiPlxuICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3NwYW4+XG5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC1zb3J0YWJsZS1pY29uIHNhcC1pY29uIGljb24tc29ydFwiICpuZ0lmPVwic29ydGFibGVcIlxuICAgICAgICAgIFtuZ0NsYXNzXT1cInsnaWNvbi1zb3J0LWRlc2NlbmRpbmcnOiAoZ2V0U29ydE9yZGVyKCkgPT0gLTEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ljb24tc29ydC1hc2NlbmRpbmcnOiAoZ2V0U29ydE9yZGVyKCkgPT0gMSl9XCI+XG4gICAgPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI3NlbGVjdGFibGVCb2R5Q2VsbCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgIDxkaXYgY2xhc3M9XCJkdC1jZWxsLWRlZi1zZWxlY3RhYmxlXCJcbiAgICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtY2VsbC1zZWxlY3RlZCc6IGR0LmlzQm9keUNlbGxTZWxlY3RlZCh0aGlzLCBkYXRhKX1cIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlDZWxsQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIGRhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjbm9uU2VsZWN0YWJsZUJvZHlDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlDZWxsQ29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIGRhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNib2R5Q2VsbENvbnRlbnQgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICA8IS0tXG4gICAgICAgICAgIHdoZW4gbm8gdGVtcGxhdGUgaXMgdXNlZCB1c2Ugb3VyIEZpZWxkUGF0aCB0byBhY2Nlc3MgdGhlIG9iamVjdCB2YWx1ZSBiYXNlZCBvbiB0aGVcbiAgICAgICAgICAga2V5IGJpbmRpbmdcbiAgICAgICAgLS0+XG4gICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtY2VsbC1kYXRhXCIgKm5nSWY9XCIhYm9keVRlbXBsYXRlXCI+XG4gICAgICAgICAgICB7e2R0LmdldFZhbHVlKGRhdGEsIGtleSl9fVxuICAgICAgICA8L3NwYW4+XG5cblxuICAgIDwhLS1cbiAgICAgICAgSW4gY2FzZSBhcHBsaWNhdGlvbiB3YW50cyB0byBwcm92aWRlIHRoZWlyIG93biBjZWxsIGNvbXBvbmVudCB0aGV5IHVzZVxuICAgICAgICAjYm9keSBuZy10ZW1wbGF0ZSB0byBkbyBzby5cbiAgICAtLT5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC1jZWxsLWRhdGFcIiAqbmdJZj1cImJvZHlUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlUZW1wbGF0ZTtcbiAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIHJvd0RhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYC5kdC1zb3J0YWJsZS1jb2x7Y3Vyc29yOnBvaW50ZXJ9LmR0LWNvbC1zb3J0YWJsZS1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1sZWZ0Oi4xMjVlbX10aC5kdC1jZWxsLWRlZntmb250LXdlaWdodDo0MDA7Y29sb3I6IzRhNGE0YX10aC5kdC1pcy1kZWZhdWx0e2JhY2tncm91bmQtY29sb3I6I2YyZjJmMjt3aGl0ZS1zcGFjZTpub3dyYXB9dGguZHQtaXMtZGVmYXVsdC5kdC1jZWxsLWRlZjpub3QoLmR0LXN1Yi1oZWFkZXIpe2JvcmRlci1ib3R0b20tY29sb3I6I2YyZjJmMn10aC5kdC1zdWItaGVhZGVye2JhY2tncm91bmQtY29sb3I6I2ZmZn10aCAuZHQtY2VsbC1zZWxlY3RlZHtib3JkZXItY29sb3I6IzU4Yjk1N310ZCAuZHQtY2VsbC1zZWxlY3RlZHtib3JkZXItbGVmdC1jb2xvcjojNGY5ZmNmfS5kdC1yb290LXNlY3Rpb24gLmR0LXNlbGVjdGlvbi1jb2x1bW4sLmR0LXNlbGVjdGlvbi1jb2x1bW57d2lkdGg6NDZweDtwYWRkaW5nOjAgMTJweH0uZHQtcGl2b3QtbGF5b3V0IHRkLmR0LXNlbGVjdGlvbi1jb2x1bW4sdGguZHQtc2VsZWN0aW9uLWNvbHVtbntib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9dGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGh7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudH10Ym9keSB0cjpsYXN0LWNoaWxkOm5vdCguZHQtZHJhZy1yb3ctYm90dG9tKSB0ZHtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50fXRkOmZpcnN0LWNoaWxkLHRoOmZpcnN0LWNoaWxke2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50fXRkOmxhc3QtY2hpbGQsdGg6bGFzdC1jaGlsZHtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9dGJvZHkgLmR0LWRyYWctcm93LXRvcD50ZHtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgwZGVnLCNmZmYgMCwjZmZmIDk3JSwjMDI3MWQyIDEwMCUpfXRib2R5IC5kdC1kcmFnLXJvdy1ib3R0b20+dGR7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMTgwZGVnLCNmZmYgMCwjZmZmIDk3JSwjMDI3MWQyIDEwMCUpfXRib2R5IC5kdC1kcmFnLXJvdy1ib3RoPnRke2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KDBkZWcsIzAyNzFkMiAwLCNmZmYgMyUsI2ZmZiA5NyUsIzAyNzFkMiAxMDAlKX10Ym9keSAuZHQtcm93LWRyYWdnaW5nPnRke2JhY2tncm91bmQtY29sb3I6I2VjZWNlYztjb2xvcjojYjliOWI5fXRib2R5IC5kdC1yb3ctZHJhZ2dpbmcgLnVpLXN0YXRlLWFjdGl2ZXtvcGFjaXR5Oi41O2N1cnNvcjpub3QtYWxsb3dlZH1gXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIHByb3ZpZGVyczogW0RvbUhhbmRsZXJdXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRDb2x1bW4yQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBoZWFkZXIgbGFiZWwuXG4gICAgICpcbiAgICAgKiBPciB5b3UgY2FuIHVzZSBoZWFkZXJUZW1wbGF0ZSB0byBkZWZpbmUgeW91ciBvd24gdGVtcGxhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGZpZWxkIG5hbWUgdG8gcmVhZCBmcm9tIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDZWxsIGFsaWdubWVudC4gSXQgaW5zZXJ0cyByZWd1bGFyIGFsaWduIGF0dHJpYnV0ZSB0byB0aGUgdGFibGUgY2VsbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbjogRFRIQWxpZ25tZW50ID0gJ2xlZnQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZHluYW1pYyBjbGFzcyBiYXNlZCBvbiBkYXRhIGFuZCB0aGVuIGl0cyBhZGRlZCB0byB0aGUgdGFibGUgY2VsbCBURFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElmIGZhbHNlIGFwcGxpZXMgZHQtaXMtaGlkZGVuIHN0eWxlIHRoYXQgaGlkZXMgdGhlIGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpc1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogTWFya3MgY29sdW1uIGFzIHNvcnRhYmxlIHdoaWNoIG1lYW5zIHNvcnRpbmcgaWNvbiBpcyBhZGRlZCB0byB0aGUgaGVhZGVyIHdpdGggc3BlY2lhbFxuICAgICAqIHNvcnRpbmcgaGFuZGxpbmdcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNvcnRhYmxlOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0aW5nIGRpcmVjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzb3J0T3JkZXJpbmc6IHN0cmluZyA9ICdkZXNjZW5kaW5nJztcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSB0ZW1wbGF0ZSBpZiB3aGV0aGVyIHRvIHJlbmRlciBhIGxhYmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dDb2x1bW5MYWJlbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGljIGNsYXNzIHRoYXQgaXMgYWRkZWQgdG8gdGhlIFRIIGludG8gdGhlIGhlYWRlci4gSXQgZG9lcyBub3QgcmVseSBvbiBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlYWRlclN0eWxlQ2xhc3M6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgc3RhdGljIGNsYXNzIHRoYXQgaXMgYWRkZWQgdG8gdGhlIHRkIGludG8gdGhlIGJvZHkuIEl0IGRvZXMgbm90IHJlbHkgb24gZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5U3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHRvZ2V0aGVyIHdpdGggY2VsbCBzZWxlY3Rpb25Nb2RlIHRvIHRlbGwgd2hpY2ggY29sdW1uIGlzIHNlbGVjdGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgSEVBREVSIHRlbXBsYXRlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgU3ViSGVhZGVyIHRlbXBsYXRlIGZvciBjdXJyZW50IGNvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxTdWJIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVXNlIGdsb2JhbGx5IGRlZmluZWQgYm9keSB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VHbG9iYWxCb2R5OiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGNvbHVtbiBpcyBkYXRhIGNvbHVtbiAgLSBpZiBpdCBpcyByZW5kZXJpbmcgZGF0YSBvciBqdXN0IGEgbGFiZWwgb3Igc29tZVxuICAgICAqIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgaW1wb3J0YW50IHdoZW4gY2FsY3VsYXRpbmcgYSBjb2x1bW4gc3BhbiBhbmQgd2UgbmVlZCB0byBrbm93IHdoaWNoIGNvbHVtbnMgYXJlIG9yXG4gICAgICogd2lsbCBiZSBqdXN0IGZvciBzZWxlY3Rpb24gY29udHJvbHMgYW5kIHdoaWNoIGhvbGRzIGRhdGFcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzRGF0YUNvbHVtbjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGNvbHVtbiB0aGF0IHdpbGwgbm90IHNjcm9sbCBob3Jpem9udGFsbHkgd2l0aCBvdGhlciBjb2x1bW5zLiBDb2x1bW4gaXNcbiAgICAgKiBmcm96ZW4uXG4gICAgICpcbiAgICAgKiBGb3Igc3VjaCBjb2x1bW5zIHRoYXQgYXJlIG1hcmtlZCBhcyBmcm96ZW4gYmluZGluZyBbd2lkdGhdIGlzIHJlcXVpcmVkLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmcm96ZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIE1heCBXaWR0aCBmb3IgdGhlIFRELiBFdmVuIFREIGRvZXMgbm90IHN1cHBvcnQgd2UgY2FsY3VsYXRlIHRoZSBjb250ZW50IHdpZHRoXG4gICAgICogZm9yIGVhY2ggY2VsbCBhbmQgdGhlbiBkZWNpZGUgaWYgd2UgbmVlZCB0byBlbmxhcmdlIHRoZSBjb2x1bW4uXG4gICAgICpcbiAgICAgKiBARXhwZXJpbWFudGFsIGJpbmRpbmcgdGhhdCBpcyBjdXJyZW50bHkgd29ya2luZyBpZiB0aGUgY29udGVudCBvZiB0aGUgY2VsbCBpcyBpbmxpbmVcbiAgICAgKiBlbGVtZW50IHdoZXJlIHdlIGNhbiBjb250cm9sIHdoaXRlc3BhY2Ugd3JhcHBpbmcgaW4gb3JkZXIgdG8gZmluZCBvdXQgdGhlIHJlYWwgd2lkdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heFdpZHRoOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1pbldpZHRoIG9uIHRoZSBjZWxsLiBBZ2FpbiBqdXN0IGxpa2UgbWF4V2lkdGggY3NzIHByb3Blcmx5IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAgICAgKiB0aGUgdGFibGUgc28gdGhlcmUgaXMgYSB3b3JrYXJvdW5kIHdoZXJlIHdlIGNyZWF0ZSBhZGRpdGlvbmFsIHJvdyB0aGF0IHNldHMgcGFkZGluZyByaWdodFxuICAgICAqIGFuZCB0aGlzIHdpbGwgcHJldmVudCB0aGUgY29sdW1uIHRvIGNvbGxhcHNlIHVuZGVyIHNwZWNpZmllZCB3aWR0aFxuICAgICAqXG4gICAgICogdG9kbzogc3RpbGwgVEJEXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtaW5XaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogTWFpbiByZW5kZXJpbmcgdGVtcGxhdGUgdXNlZCBieSBkYXRhdGFibGUgdG8gcmVuZGVyIGVhY2ggY29sdW1uLlxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3JlbmRlcmluZ1RlbXBsYXRlJylcbiAgICByZW5kZXJlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGhlYWRlciB0ZW1wbGF0ZS4gSXQgd2lsbCBvdmVycmlkZSBwcm92aWRlZCBsYWJlbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlcicpXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gc3ViSGVhZGVyIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ3N1YkhlYWRlcicpXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gYm9keSB0ZW1wbGF0ZSB0aGF0IHdpbGwgb3ZlcnJpZGUgcmVhZCB2YWx1ZSBmcm9tIHRoZSBba2V5XSBiaW5kaW5nXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4uLlxuICAgICAqL1xuICAgIHNvcnRPcmRlcjogbnVtYmVyO1xuICAgIG1heFdpZHRoUHg6IG51bWJlciA9IDA7XG4gICAgbWluV2lkdGhQeDogbnVtYmVyID0gMDtcbiAgICB3aWR0aFB4OiBudW1iZXIgPSAwO1xuICAgIHdpZGVzdENlbGw6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gRGF0YXRhYmxlIEltcGxlbWVudGF0aW9uc1xuICAgICAqL1xuICAgIGR0OiBBV0RhdGFUYWJsZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuc29ydE9yZGVyaW5nKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmJvZHlUZW1wbGF0ZSkgJiYgdGhpcy51c2VHbG9iYWxCb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmJvZHlUZW1wbGF0ZSA9IHRoaXMuZHQuYm9keVRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5oZWFkZXJUZW1wbGF0ZSkgJiYgdGhpcy51c2VHbG9iYWxIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyVGVtcGxhdGUgPSB0aGlzLmR0LmhlYWRlclRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdWJIZWFkZXJUZW1wbGF0ZSkgJiYgdGhpcy51c2VHbG9iYWxTdWJIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3ViSGVhZGVyVGVtcGxhdGUgPSB0aGlzLmR0LnN1YkhlYWRlclRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5ib2R5Q2xhc3NGbikpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keUNsYXNzRm4gPSB0aGlzLmR0LmJvZHlDbGFzc0ZuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5rZXkpICYmIGlzQmxhbmsodGhpcy5sYWJlbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBiaW5kaW5nOiAnICtcbiAgICAgICAgICAgICAgICAnW2tleV0gb3IgW2xhYmVsXSBiaW5kaW5ncyBtdXN0IGJlIHVzZWQgYXQgbWluaW11bScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gYmUgYWJsZSB0byBwb3NpdGlvbiBzZWNvbmQgRFQgd2UgcmVxdWlyZSBbd2lkdGhdIHRvIGJlIHNldCBhcyB3ZWxsXG4gICAgICAgIGlmICh0aGlzLmZyb3plbiAmJiBpc0JsYW5rKHRoaXMud2lkdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYmluZGluZyBbd2lkdGhdOiAnICtcbiAgICAgICAgICAgICAgICAnd2hlbiBbZnJvemVuXT10cnVlIHRoZW4gW3dpZHRoXSBiaW5kaW5nIG5lZWRzIHRvIGJlIHNwZWNpZmllZC4nKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIG5lZWQgdG8gZGVmZmVyIHRoaXMgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiBvdGhlcndpc2UgSSBnZXRcbiAgICAgICAgLy8gdmFsdWUgd2FzIGNoYW5nZWQgYWZ0ZXIgaXQgd2FzIGNoZWNrZWQgZXJyb3JcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1heFdpZHRoUHggPSB0aGlzLndpZHRoVG9QeCh0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgICAgIHRoaXMubWluV2lkdGhQeCA9IHRoaXMud2lkdGhUb1B4KHRoaXMubWluV2lkdGgpO1xuICAgICAgICAgICAgdGhpcy53aWR0aFB4ID0gdGhpcy53aWR0aFRvUHgodGhpcy53aWR0aCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBjZWxsIHNlbGVjdGlvbk1vZGUgaXMgZW5hYmxlZCB0aGlzIG1ldGhvZCBpcyB0cmlnZ2VyZWQgd2hlbiB3ZSBjbGljayBvbiBoZWFkZXIuXG4gICAgICogSXQgZGVsZWdhdGVzIHRoZSBjYWxsIHRvIHRoZSBEVCB3aGVyZSBpdCB0b2dnbGVzIGN1cnJlbnRseSBzZWxlY3RlZCB2YWx1ZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlSGVhZGVyQ2xpY2soZXZlbnQ6IGFueSwgZWxlbWVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyU2VsZWN0YWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmR0Lm9uSGVhZGVyU2VsZWN0aW9uQ2hhbmdlKGVsZW1lbnQsIHRoaXMpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVG9kbzogSW1wbGVtZW50IG91ciBvd24gc29ydGluZyBtZWNoYW5pc20gb25jZSB3ZSBleHRyYWN0IHRoZSBzb3J0aW5nIGxvZ2ljIHRvIGl0cyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnQoZXZlbnQ6IGFueSkge1xuICAgICAgICBpZiAoIXRoaXMuc29ydGFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgaWYgKHRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyh0YXJnZXROb2RlLCAnZHQtdS1zb3J0YWJsZScpIHx8XG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3ModGFyZ2V0Tm9kZSwgJ2R0LWNvbC10aXRsZScpIHx8XG4gICAgICAgICAgICB0aGlzLmRvbUhhbmRsZXIuaGFzQ2xhc3ModGFyZ2V0Tm9kZSwgJ2R0LWNvbC1zb3J0YWJsZS1pY29uJykpIHtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LnNvcnRDb2x1bW4pICYmIHRoaXMuZHQuc29ydENvbHVtbi5rZXkgPT09IHRoaXMua2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0T3JkZXIgPSB0aGlzLnNvcnRPcmRlciAqIC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyaW5nID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JOdW1iZXIodGhpcy5zb3J0T3JkZXIpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuc29ydENvbHVtbiA9IHRoaXM7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5zb3J0S2V5ID0gdGhpcy5rZXk7XG4gICAgICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuc29ydE9yZGVyID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5zb3J0T3JkZXJpbmcpO1xuXG4gICAgICAgICAgICB0aGlzLmR0LnNvcnRTaW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR0LnVwZGF0ZURhdGFUb1JlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZWQgc3R5bGUgY2xhc3MgYmFzZWQgb24gZGF0YVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBkeW5hbWljQm9keUNsYXNzKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgZHluQ2xhc3MgPSBpc1ByZXNlbnQodGhpcy5ib2R5Q2xhc3NGbilcbiAgICAgICAgICAgID8gdGhpcy5ib2R5Q2xhc3NGbi5hcHBseSh0aGlzLmR0LmNvbnRleHQsIFt0aGlzLCBpdGVtXSkgOiAnJztcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYm9keVN0eWxlQ2xhc3MpKSB7XG4gICAgICAgICAgICBkeW5DbGFzcyArPSAnICcgKyB0aGlzLmJvZHlTdHlsZUNsYXNzO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIGR5bkNsYXNzICs9ICcgJyArIHRoaXMuc3R5bGVDbGFzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkeW5DbGFzcztcbiAgICB9XG5cblxuICAgIGlzUm93U2VsZWN0YWJsZShpdGVtOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LmlzUm93U2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmR0LmlzUm93U2VsZWN0YWJsZShpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc0NlbGxTZWxlY3RhYmxlKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5zZWxlY3Rpb25Nb2RlID09PSAnY2VsbCcgJiYgdGhpcy5pc1Jvd1NlbGVjdGFibGUoaXRlbSkgJiYgdGhpcy5zZWxlY3RhYmxlO1xuXG4gICAgfVxuXG5cbiAgICBpc0hlYWRlclNlbGVjdGFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LnNlbGVjdGlvbk1vZGUgPT09ICdjZWxsJyAmJiB0aGlzLnNlbGVjdGFibGU7XG5cbiAgICB9XG5cblxuICAgIGdldFNvcnRPcmRlcigpIHtcbiAgICAgICAgbGV0IG9yZGVyID0gMDtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuc29ydENvbHVtbikgJiYgdGhpcy5rZXkgPT09IHRoaXMuZHQuc29ydENvbHVtbi5rZXkpIHtcbiAgICAgICAgICAgIG9yZGVyID0gdGhpcy5kdC5zb3J0Q29sdW1uLnNvcnRPcmRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuXG4gICAgaXNTb3J0ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmtleSA9PT0gdGhpcy5kdC5zb3J0Q29sdW1uLmtleTtcbiAgICB9XG5cbiAgICBpbml0aWFsaXplKHRhYmxlOiBBV0RhdGFUYWJsZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmR0ID0gdGFibGU7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmR0LmluaXRpYWxTb3J0S2V5KSAmJiB0aGlzLmR0LmluaXRpYWxTb3J0S2V5ID09PSB0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHRoaXMuZHQuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuZHQuaW5pdGlhbFNvcnRPcmRlcik7XG4gICAgICAgICAgICB0aGlzLmR0LnNvcnRDb2x1bW4gPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF0IHRoZSBlbmQgb2YgdGhlIHZpZXcgaW5pdCBjeWNsZSBmcm9tIHRoZSBkdC5uZ0FmdGVyVmlld0NoZWNrZWQuXG4gICAgICpcbiAgICAgKiBJbiBjYXNlIHdlIHVzZSBNYXhXaWR0aCBkaXJlY3RpdmUgd2Ugc2V0IG5ldyB3aWR0aCBvbmNlIGZvciBhbGwgY29sdW1zblxuICAgICAqL1xuICAgIHBvc3RJbml0aWFsaXplKG15SW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBjb2xJbmRleCA9IG15SW5kZXggKyAxO1xuICAgICAgICBsZXQgdGFibGU7XG5cbiAgICAgICAgaWYgKHRoaXMuZHQuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICB0YWJsZSA9ICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbFxuICAgICAgICAgICAgICAgIC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LWZyb3plbiB0YWJsZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFibGUgPSAoPERhdGF0YWJsZTJDb21wb25lbnQ+dGhpcy5kdCkuZWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAodGhpcy53aWRlc3RDZWxsID4gMCkge1xuICAgICAgICAgICAgbGV0IGFsbCA9IHRhYmxlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RyIHRoOm50aC1jaGlsZCgnICsgY29sSW5kZXggKyAnKSwgJyArXG4gICAgICAgICAgICAgICAgJ3RyIHRkOm50aC1jaGlsZCgnICsgY29sSW5kZXggKyAnKScpLmZvckVhY2goKG5vZGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUud2lkdGggPSB0aGlzLndpZGVzdENlbGwgKyAncHgnO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFlvdSBlaXRoZXIgdXNlIHRoaXMgYmluZGluZyBkaXJlY3RseSBhbmQgc2F5IGl0cyBkYXRhY29sdW1uIG9yIHdoZW4gdGhlcmUgaXMgYSBba2V5XVxuICAgICAqIGJpZGluZyB3ZSBrbm93IGl0IHJlZmVycyB0byBzb21lIGZpZWxkLlxuICAgICAqXG4gICAgICovXG4gICAgaXNWYWx1ZUNvbHVtbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQodGhpcy5pc0RhdGFDb2x1bW4pICYmIEJvb2xlYW5XcmFwcGVyLmlzVHJ1ZSh0aGlzLmlzRGF0YUNvbHVtbikpIHx8XG4gICAgICAgICAgICBpc1ByZXNlbnQodGhpcy5rZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgYXJlIGluIG91dGxpbmUgbW9kZSAgd2UgbmVlZCB0byBhbHNvIGluZGVuZCBlYWNoIHNlbGVjdGlvbiBjb250cm9sIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogaW5kZW50IC0gMSA+IG9ubHkgb2Zmc2V0IHdpdGhcbiAgICAgKiBpbmRlbnRcbiAgICAgKi9cbiAgICBpbmRlbnRGb3JDb250cm9sKGNlbGw6IGFueSwgbGV2ZWw6IG51bWJlcik6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLmR0LmlzT3V0bGluZSgpICYmIGxldmVsID4gMCAmJiBjZWxsLm9mZnNldFdpZHRoID4gMFxuICAgICAgICAgICAgJiYgaXNQcmVzZW50KGNlbGwubmV4dEVsZW1lbnRTaWJsaW5nKSkge1xuXG4gICAgICAgICAgICBsZXQgb3V0bGluZU5vZGVQYWRkaW5nID1cbiAgICAgICAgICAgICAgICBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGNlbGwubmV4dEVsZW1lbnRTaWJsaW5nKS5wYWRkaW5nTGVmdCkgfHwgMDtcblxuICAgICAgICAgICAgLy8gMXN0IGxldmVsIGlzIHB1c2hlZCBhcyByb290XG4gICAgICAgICAgICBpZiAodGhpcy5kdC5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGxldmVsID09PSAxKSA/IG51bGwgOiAodGhpcy5kdC5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpXG4gICAgICAgICAgICAgICAgICAgIC0gb3V0bGluZU5vZGVQYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuZHQuaW5kZW50YXRpb25QZXJMZXZlbCAqIGxldmVsKSArIG91dGxpbmVOb2RlUGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcml2YXRlIHdpZHRoVG9QeCh3aWR0aDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHB4O1xuICAgICAgICBpZiAoaXNQcmVzZW50KHdpZHRoKSkge1xuICAgICAgICAgICAgaWYgKHdpZHRoLmluZGV4T2YoJyUnKSA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub25QYyA9IHBhcnNlRmxvYXQod2lkdGgpIC8gMTAwO1xuICAgICAgICAgICAgICAgIHB4ID0gbm9uUGMgKiAoPERhdGF0YWJsZTJDb21wb25lbnQ+dGhpcy5kdCkuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHggPSBwYXJzZUZsb2F0KHdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBweDtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGRhdGF0YWJsZSBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIERhdGFUYWJsZUNvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtaGVhZGVyMicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBEVEhlYWRlckNvbXBvbmVudDJcbntcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDdXN0b20gY29sdW1uIGltcGxlbWVudGF0aW9uIHRvIHJlbmRlciBkZXRhaWwgcm93IHNwYW5pbmcgaXRzIGNvbHVtbiBhY3Jvc3Mgd2hvbGUgdGFibGUgd2lkdGguXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1kZXRhaWwtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBSZW5kZXJzIGFwcGxpY2F0aW9uIGRlZmluZWQgZGV0YWlsIGNvbHVtbi4gVGhpcyB0ZW1wbGF0ZSBqdXN0IHJlbmRlcnMgYSBkZXRhaWwgcm93IGFuZFxuICAgIG5vdCBleHBhbnNpb24gY29udHJvbC4gVGhpcyBpcyBpbXBsZW1lbnRlZCBieSBkaWZmZXJlbnQgRHRDb2x1bW4gaW1wbGVtZW50YXRpb24gYW5kIGl0cyBhZGRlZFxuICAgICh3aWxsIGJlKSBhZGRlZCBwcm9ncmFtbWF0aWNhbGx5IGR1cmluZyBjb2x1bW4gaW5pdGlhbGl6YXRpb25cbi0tPlxuPG5nLXRlbXBsYXRlICNyZW5kZXJpbmdUZW1wbGF0ZSBsZXQtY29sdW1uPVwiY29sdW1uXCIgbGV0LXJvd0RhdGE9XCJkYXRhXCI+XG5cbiAgICA8dHIgI2RldGFpbFJvd0VsZW1lbnQgY2xhc3M9XCJkdC1ib2R5LXJvdyBkdC1kZXRhaWwtcm93XCI+XG5cbiAgICAgICAgPHRkICpuZ0lmPVwiZHQuaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKClcIiB3aWR0aD1cIjFweFwiPjwvdGQ+XG4gICAgICAgIDx0ZCAqbmdJZj1cInZpc2libGVMZWFkaW5nQ29scygpID4gMFwiIGNvbHNwYW49XCJ2aXNpYmxlTGVhZGluZ0NvbHMoKVwiIHdpZHRoPVwiMXB4XCI+XG4gICAgICAgICAgICAmbmJzcDsmbmJzcDtcbiAgICAgICAgPC90ZD5cbiAgICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiZHQuc3RhcnRPZkZpcnN0RGF0YUNvbHVtblwiIFtjbGFzc109XCJkeW5hbWljQm9keUNsYXNzKHJvd0RhdGEpXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQgZHQtY2VsbC1kZWYnOiB0cnVlfVwiPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5VGVtcGxhdGU7IGNvbnRleHQ6eyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTpyb3dEYXRhfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvdGQ+XG4gICAgPC90cj5cbjwvbmctdGVtcGxhdGU+XG5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVERldGFpbFJvd0NvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudCB7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGN1cnJlbnQgdmlzaWJpbGl0eSBmb3IgY3VycmVudCBkYXRhIHJvdyB1c2luZyBtZXRob2QgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzVmlzaWJsZUZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiB0ZWxscyBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhIGxpbmUgYmV0d2VlbiBpdGVtIHJvdyBhbmQgaXRzIGRldGFpbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Um93TGluZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcikge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIGp1c3QgdG8gZ2V0IGFyb3VuZCB0aGUgY2hlY2sgaW4gcGFyZW50IGNsYXNzXG4gICAgICAgIHRoaXMua2V5ID0gJyc7XG5cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSAhdGhpcy5kdC5pc091dGxpbmUoKSB8fCAhdGhpcy5kdC5waXZvdGFsTGF5b3V0O1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UgbmVlZCB0byBrZWVwIHNvbWUgbGVhZGluZyBURHNcbiAgICAgKlxuICAgICAqL1xuICAgIHZpc2libGVMZWFkaW5nQ29scygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5udW1iZXJPZkNvbHNCZWZvcmVEYXRhIC0gKHRoaXMuZHQuaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCkgPyAxIDogMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHdlIGNhbiBzaG93IGRldGFpbCByb3cvY29sdW1uIHVzaW5nIGVpdGhlciBbaXNWaXNpYmxlXSBvciBbaXNWaXNpYmxlRm5dIGJpbmRpbmdzLlxuICAgICAqIEhlcmUgY2FuIGhvb2sgb24gYXBwbGljYXRpb24gbGV2ZWwgY3VzdG9tIG1ldGhvZCB0byBkZWNpZGUgaWYgY3VycmVudCBpdGVtIGhhcyBkZXRhaWwgcm93XG4gICAgICogb3Igbm90XG4gICAgICpcbiAgICAgKiBPciB3ZSBjYW4gdXNlIGlzVmlzaWJsZT10cnVlIHRvIHRlbGwgYWxsIHJvdyBoYXZlIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dEZXRhaWxSb3coaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBpc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmlzVmlzaWJsZUZuKSkge1xuICAgICAgICAgICAgaXNWaXNpYmxlID0gdGhpcy5pc1Zpc2libGVGbi5hcHBseSh0aGlzLmR0LmNvbnRleHQsIFt0aGlzLCBpdGVtXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uLy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1kZXRhaWwtY29sdW1uLWV4cGFuZCcsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICBTcGVjaWFsIGNvbHVtbiB0aGF0IHJlbmRlcnMgZXhwYW5kL2NvbGxhcHNlIGNvbnRyb2wgZm9yIGRldGFpbCByb3cgd2hlbiBkZXRhaWwgcm93IGlzIGVuYWJsZWQuXG5cbiAgIEp1c3QgbGlrZSBmb3IgdGhlIG90aGVyIGNvbHVtbiBpdCByZW5kZXJzIGhlYWRlciBzZWN0aW9uIGFzIHdlbGwgYXMgYm9keSBzZWN0aW9uIHdpdGhcbiAgIGV4cGFuZCBjb250cm9sIHRvIHRvZ2dsZSB0aGUgZXhwYW5zaW9uXG5cbi0tPlxuPG5nLXRlbXBsYXRlICNyZW5kZXJpbmdUZW1wbGF0ZSBsZXQtaXNIZWFkZXIgbGV0LWlzU3ViSGVhZGVyPVwiaXNTdWJIZWFkZXJcIiBsZXQtY29sdW1uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICBsZXQtZGF0YVRvUmVuZGVyPVwiZGF0YVwiIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzSGVhZGVyICYmICFpc1N1YkhlYWRlclwiPlxuICAgICAgICA8dGggI2hlYWRlckNlbGwxIFtjbGFzc109XCJoZWFkZXJTdHlsZUNsYXNzfHxzdHlsZUNsYXNzXCJcbiAgICAgICAgICAgIGNsYXNzPVwiZHQtcm93LWNlbGwtZXhwYW5kb1wiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtdS11bnNlbGVjdGFibGUtdGV4dCBkdC1jZWxsLWRlZicgOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAnZHQtZGV0LXJvdy1leHBhbmRlZCc6IGR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoZGF0YVRvUmVuZGVyKX1cIj5cbiAgICAgICAgPC90aD5cblxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzSGVhZGVyICYmICFpc1N1YkhlYWRlclwiPlxuICAgICAgICA8dGQgI2NlbGxcbiAgICAgICAgICAgIGNsYXNzPVwiZHQtcm93LWNlbGwtZXhwYW5kb1wiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdkdC1pcy1kZWZhdWx0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWNlbGwtZGVmJzogIWlzQ2VsbFNlbGVjdGFibGUoZGF0YVRvUmVuZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWRldC1yb3ctZXhwYW5kZWQnOiBkdC5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5pc0V4cGFuZGVkKGRhdGFUb1JlbmRlciksXG4gICAgICAgICAgICAgICAgICAgICdkdC1kZXQtcm93LXdpdGgtbG4nIDogZHQucm93RGV0YWlsQ29sdW1uLnNob3dSb3dMaW5lfVwiPlxuXG4gICAgICAgICAgICA8c3BhbiAoY2xpY2spPVwidG9nZ2xlRXhwYW5zaW9uKCRldmVudCwgZGF0YVRvUmVuZGVyKVwiXG4gICAgICAgICAgICAgICAgICBjbGFzcz1cImR0LWRldC1yb3ctZXhwYW5kIHNhcC1pY29uXCJcbiAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImNhbGN1bGF0ZVN0eWxlQ2xhc3MoZGF0YVRvUmVuZGVyKVwiPlxuXG4gICAgICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPC90ZD5cblxuICAgIDwvbmctdGVtcGxhdGU+XG5cblxuPC9uZy10ZW1wbGF0ZT5cblxuYCxcbiAgICBzdHlsZXM6IFtgLmR0LXJvdy1jZWxsLWV4cGFuZG97d2lkdGg6MTRweDt0ZXh0LWFsaWduOnJpZ2h0O3BhZGRpbmc6MTdweCA1cHggMTdweCAxN3B4O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH0uZHQtcm93LWNlbGwtZXhwYW5kbyAuZHQtZGV0LXJvdy1leHBhbmR7Y3Vyc29yOnBvaW50ZXI7bGluZS1oZWlnaHQ6MjFweH10ZC5kdC1kZXQtcm93LWV4cGFuZGVkOm5vdCguZHQtZGV0LXJvdy13aXRoLWxuKSx0ZC5kdC1kZXQtcm93LWV4cGFuZGVkOm5vdCguZHQtZGV0LXJvdy13aXRoLWxuKX50ZHtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50fWBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcikge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIHdlIGRvbnQgd2FudCB0byBzaG93IHRoZSByb3cvY29sdW1uIHVubGVzcyBhcHBsaWNhdGlvbiBzYXlzIHNvXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xcbiAgICAgICAgdGhpcy53aWR0aCA9ICc0NXB4JztcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBqdXN0IHRvIGdldCBhcm91bmQgdGhlIGNoZWNrIGluIHBhcmVudCBjbGFzc1xuICAgICAgICB0aGlzLmtleSA9ICcnO1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLnRvZ2dsZShpdGVtKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlU3R5bGVDbGFzcyhpdGVtOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5kdC5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5pc0V4cGFuZGVkKGl0ZW0pID9cbiAgICAgICAgICAgICdpY29uLXNsaW0tYXJyb3ctZG93bicgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5cbmltcG9ydCB7VGVtcGxhdGVSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtTZWxlY3Rpb25Nb2RlfSBmcm9tICcuL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuaW1wb3J0IHtEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSwgRFQyRGF0YVNvdXJjZX0gZnJvbSAnLi9kYXRhdGFibGUyLWRhdGEtc291cmNlJztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuLi9vdXRsaW5lJztcbmltcG9ydCB7RFREZXRhaWxSb3dDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQnO1xuXG5cbmV4cG9ydCBjb25zdCBEcmFnRXZlbnRzOiBzdHJpbmdbXSA9IFsnbW91c2Vkb3duJywgJ2RyYWdzdGFydCcsICdkcmFnb3ZlcicsICdkcmFnZW50ZXInLCAnZHJhZ2xlYXZlJyxcbiAgICAnZHJvcCcsICdkcmFnZW5kJ107XG5cbmV4cG9ydCBlbnVtIERyYWdEaXJlY3Rpb25cbntcbiAgICBOb25lID0gJ25vbmUnLFxuICAgIFVwID0gJ2R0LWRyYWctcm93LXRvcCcsXG4gICAgRG93biA9ICdkdC1kcmFnLXJvdy1ib3R0b20nLFxuICAgIE1pZGRsZSA9ICdkdC1kcmFnLXJvdy1ib3RoJ1xufVxuXG5cbmV4cG9ydCBlbnVtIERyb3BQb3NpdGlvblxue1xuICAgIEJlZm9yZSA9ICdiZWZvcmUnLFxuICAgIEFmdGVyID0gJ2FmdGVyJyxcbiAgICBJbnRvID0gJ2ludG8nXG59XG5cblxuLyoqXG4gKiBBYnN0cmFjdCB0eXBlIHRoYXQgaXMgc2hhcmFibGUgYW1vbmcgZGVwZW5kYW50IERUIG9iamVjdCBzdWNoIGFzIENvbHVtbnMsIERhdGFTb3VyY2VzLFxuICogRGlyZWN0aXZlcyB0byBiZSBhYmxlIHRvIGNvbW11bmljYXRlIGJhY2sgdG8gdGhlIGRhdGF0YWJsZSBtYWlubHkgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFXRGF0YVRhYmxlIHtcblxuICAgIC8qKlxuICAgICAqIEFsbG93cyB5b3UgdG8gcGFzcyB5b3VyIG93biBkYXRhc291cmNlIHRvIG92ZXJyaWRlIGRlZmF1bHQgb25lLiBBbHNvIHdoZW4gZGF0YVNvdXJjZSBpc1xuICAgICAqIHVzZWQgdGhlIGRlc3RpbmF0aW9uQ2xhc3Mgb3IgbGlzdCBhcmUgaWdub3JlZFxuICAgICAqL1xuICAgIGRhdGFTb3VyY2U6IERUMkRhdGFTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIG91dGxpbmUgc3RhdGVzIGZvciBEYXRhdGFibGVzIHVzaW5nIG91dGxpbmUgY29udHJvbFxuICAgICAqL1xuICAgIG91dGxpbmVTdGF0ZTogT3V0bGluZVN0YXRlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIHdlIGhhdmUgZGV0YWlsIHJvdyByZW1lbWJlciBpdHMgZXhwYW5zaW9uIHN0YXRlXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5zaW9uU3RhdGU6IERldGFpbFJvd0V4cGFuc2lvblN0YXRlO1xuXG4gICAgLyoqXG4gICAgICogV2hhdCBjb2x1bW4gaXMgdXNlZCBhcyBmaXJzdCBmb3Igc29ydGluZ1xuICAgICAqL1xuICAgIGluaXRpYWxTb3J0S2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBBbGxvdyB0byBjaGFuZ2Ugc29ydGluZyBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBpbml0aWFsU29ydE9yZGVyOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIERUIGlmIHdlIHN1cHBvcnQgY2VsbCBzZWxlY3Rpb24gb3Igcm93IGJhc2VkIHNlbGVjdGlvbiB3aGljaCBpcyByZWd1bGFyIERULlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZTtcblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugb2Ygc2luZ2xlIG9yIG11bHRpc2VsZWN0aW9uIHNob3cgY29udHJvbHNcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTZWxlY3Rpb25Db2x1bW46IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB3ZSB3YW50IHRvIHJlbmRlciBvbmUgc2VsZWN0aW9uIGNvbnRyb2wgaW4gdGhlIGhlYWRlciB0byBzZWxlY3QgYWxsIHRoZVxuICAgICAqIHJvd3MuIEFwcGxpY2FibGUgZm9yIG11bHRpc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93U2VsZWN0QWxsOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogSWRlbnRpZnkgaWYgcm93IG9yIGNlbGwgaXMgc2VsZWN0YWJsZSBiYXNlZCBvbiBkYXRhXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RhYmxlOiAoaXRlbTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBFYWNoIERUQ29sdW1uIGhhdmUgaGF2ZSBpdHMgb3duIHRlbXBsYXRlIHRvIHByb3ZpZGUgY29udGVudCBmb3IgaGVhZGVyLCBzdWJoZWFkZXIgYW5kXG4gICAgICogYm9keSBidXQgaWYgdGhvc2UgdGVtcGxhdGUgYXJlIGlkZW50aWNhbCB0aGVyZSB3b3VsZCBiZSB0b28gbXVjaCBkdXBsaWNhdGUgY29kZSB0byByZXBsaWNhdGVcbiAgICAgKiBmb3IgZWFjaCBjb2x1bW4gdGhlIHNhbWUuIFRoZXJlZm9yZSB3ZSBoYXZlIHRoZXNlIGdsb2JhbCB0ZW1wbGF0ZXMgdGhhdCB5b3UgY2FuIGRlY2xhcmVcbiAgICAgKiBvbiBEVCBsZXZlbCAobm90IHVuZGVyIGNvbHVtbnMpIGFuZCBjb250ZW50IG9mIHRoZXNlIHRlbXBsYXRlIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBjb2x1bW5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gbWl4IHRoZW0gYXMgd2VsbC4gWW91IGNhbiBoYXZlIGdsb2JhbCB0ZW1wbGF0ZXMgYXMgd2VsbCBhcyB0ZW1wbGF0ZSBvbiB0aGUgQ29sdW1uXG4gICAgICogbGV2ZWwgd2hpY2ggd291bGQgb3ZlcnJpZGUgdGhlIGdsb2JhbCBvbmVcbiAgICAgKlxuICAgICAqL1xuICAgIGhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBzdWJIZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIC8qKlxuICAgICAqIFNlZSBoZWFkZXJUZW1wbGF0ZSBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICovXG4gICAgaGVhZGVyRmlsdGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJlbmRlciBhIHN1YkhlYWRlciB0ZW1wbGF0ZSBpZiBwcmVzZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93U3ViSGVhZGVyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBnbG9iYWwgc3R5bGUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgYm91bmQgdG8gdGFibGUgYW5kIHJlYWQgYnkgZWFjaCBjb2x1bW4uXG4gICAgICogVGhlIHNhbWUgeW91IGNhbiBzZWUgb24gdGhlIERUQ29sdW1uXG4gICAgICovXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbnRleHQgaXMgaW1wb3J0YW50IHdoZW4gd2UgZXhlY3V0ZSBhbnkgZnVuY3Rpb24gdGhhdCBpcyBwYXNzZWQgaW4gYXMgaW5wdXQuIFdlIG5lZWQgdG9cbiAgICAgKiBnaXZlIG9wdGlvbiB0byBiZSBleGVjdXRlZCB3aXRoaW4gdGhlIGNvbnRleHQgKHRoaXMpIG9mIHRoZSBjb2RlIHVzaW5nIHRoaXMgY29tcG9uZW50LlxuICAgICAqXG4gICAgICovXG4gICAgY29udGV4dDogYW55O1xuXG4gICAgLy8gT3V0bGluZSBuZWVkZWQgcHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogUHVzaGVzIG91dGxpbmVGb3Igc2VjdGlvbiBvbiB0aGUgbmV3IGxpbmUgYW5kIDJuZCBsZXZlbCBjaGlsZCBtYWtlIGl0IHJvb3QgZm9yIHRoaXNcbiAgICAgKiBzZWN0aW9uXG4gICAgICovXG4gICAgcHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogWW91IGNhbiBjaGFuZ2UgZGVmYXVsdCBpbmRlbnRhdGlvbiBmb3IgdGhlIG91dGxpbmUgbm9kZXNcbiAgICAgKlxuICAgICAqL1xuICAgIGluZGVudGF0aW9uUGVyTGV2ZWw6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYWN0aXZlIGFwcGxpZXMgc3BlY2lhbCBzdHlsZXMgdG8gdGhlIERULiBMYXRlciBvbiBvbmNlIHBpdm90IGlzIGltcGxlbWVudGVkIHRoaXMgd2lsbFxuICAgICAqIGFsc28gYWRkIGFkZGl0aW9uYWwgYmVoYXZpb3IgdG8gdGhlIERUXG4gICAgICpcbiAgICAgKi9cbiAgICBwaXZvdGFsTGF5b3V0OiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHNvcnRpbmcgaXMgZW5hYmxlZCB0aGlzIGlzIGN1cnJlbnQgYWN0aXZlIGNvbHVtbiBiZWluZyBzb3J0ZWQuXG4gICAgICpcbiAgICAgKiAgLSB3ZSBkb250IHN1cHBvcnQgbXVsdGlwbGUgY29sdW1uIHNvcnRpbmdcbiAgICAgKi9cbiAgICBzb3J0Q29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gYXctZHQtZGV0YWlsLWNvbHVtbiBpZiBwcmVzZW50IGRldGFpbCByb3cgaXMgcmVuZGVyZWQgZm9yIHNwZWNpZmllZFxuICAgICAqIGl0ZW1zXG4gICAgICovXG4gICAgcm93RGV0YWlsQ29sdW1uOiBEVERldGFpbFJvd0NvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHNwYW5pbmcgY2FsY3VsYXRpb24gb3IgZm9yIHRoZSBkZXRhaWwgcm93IHRvIGlkZW50aWZ5IGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiB0byBzcGFuLCB3aGVuIHRoZXkgYXJlIHNvbWUgbm9uLWRhdGEgY29sdW1uIChleHBhbnNpb24gY29udHJvbCwgc2luZ2xlL211bHRpIHNlbGVjdGlvbilcbiAgICAgKi9cbiAgICBudW1iZXJPZkNvbHNCZWZvcmVEYXRhOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqICB3aGF0IGlzIHRoZSBpbmRleCBvZiBmaXJzdCBkYXRhIGNvbHVtbnNcbiAgICAgKi9cbiAgICBzdGFydE9mRmlyc3REYXRhQ29sdW1uOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIGluIGNlbGwgc2VsZWN0aW9uIG1vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2VsbFNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgYnkgY29sdW1uIHdoZSBoZWFkZXIgaXMgc2VsZWN0ZWQuIEN1cnJlbnQgd2UgYXNzdW1lIHRoZSBvbmx5IG9uZSBoZWFkZXIgY2FuIGJlXG4gICAgICogc2VsZWN0ZWQgYXQgdGhlIHRpbWUuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhlYWRlclNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50KTogdm9pZDtcblxuXG4gICAgb25IYW5kbGVSb3dDbGlja2VkKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhhbmRsZXMgcm93IHNlbGVjdGlvbiBsb2dpYyB3aGVyZSBpZiB0aGUgaXRlbSBpcyBmb3VuZCBpbnNpZGUgdGhlIHNlbGVjdGVkIGl0ZW1zLCB0aGVuXG4gICAgICogaXRzIHJlbW92ZWQgb3RoZXJ3aXNlIGl0cyBhZGRlZC5cbiAgICAgKlxuICAgICAqIFRvZG86IFN5bmMgJiByZWZhY3RvciB0aGlzIHdpdGggZHQub25DZWxsU2VsZWN0aW9uQ2hhbmdlIC0gcHJldHR5IHNpbWlsYXIgY29kZVxuICAgICAqXG4gICAgICogV2Ugd2FudCB0byBoYXZlIHJvd1RvZ2dsZSBhcyB3ZWxsIGFzIHdlIHdpbGwgaGF2ZSByb3dTZWxlY3Qgb3Igc29tZXRoaWduIHNpbWlsYXIgdG9cbiAgICAgKiBpZGVudGlmeSB3ZSBhcmUgZGVhbGluZyB3aXRoIG11bHRpc2VsZWN0IGFuZCBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICovXG4gICAgb25Sb3dUb2dnbGUoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBIYW5kbGVzIHJvdyBzaW5nbGUgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBvblJvd1NlbGVjdChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZWFsaW5nIHdpdGggb3V0bGluZSAodHJlZSkgd2UgbmVlZCB0byBtYWtlIHN1cmUgd2hlbiB3ZSBzZWxlY3Qgc29tZSByb290IGl0ZW0gaXRcbiAgICAgKiB3aWxsIGF1dG9tYXRpY2FsbHkgYWxzbyBzZWxlY3QgYWxsIGl0cyBjaGlsZHJlblxuICAgICAqXG4gICAgICovXG4gICAgb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBKdXN0IGxpa2UgZm9yIG9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4gdGhlIHNhbWUgYmVoYXZpb3IgbmVlZHMgdG8gYmUgYXBwbGllZCBmb3JcbiAgICAgKiB0b3dhcmRzIHVwLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbGxlZCBieSBEJkQgcm93IGRpcmVjdGl2ZSB0byB1cGRhdGUgdGhpcyBURCB0aGF0IHJvdyByZW9yZGVyaW5nIG5lZWRzIHRvIGhhcHBlbi4gV2VcbiAgICAgKiByZWNlaXZlIGFuIElOREVYIG9mIHJvdyB3ZSBhcmUgZHJhZ2dpbmcgYW5kIG5ldyBkcm9wIHBvc2l0aW9uLCBwbHVzIGluZm9ybWF0aW9uIGlmIGl0XG4gICAgICogbmVlZHMgdG8gYmUgZHJvcHBlZCBiZWZvcmUgbmV3IHJvdyBwb3NpdGlvbiBvciBhZnRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG5EUm93RHJvcChvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gZGV0YWlsIHJvdyBpcyBjb21iaW5lZCB3aXRoIG91dGxpbmUgY29udHJvbCB3ZSBuZWVkIG1ha2Ugc3VyZSB0aGF0IHdlIG1haW50YWluIHRoZVxuICAgICAqIGNvcnJlY3Qgc3RhdGUgZm9yIGl0ZW1zIHRoYXQgYXJlIGVsaWdpYmxlIGZvciBkZXRhaWwgcm93XG4gICAgICpcbiAgICAgKiBJbiB0aGlzIHNwZWNpZmljIGNhc2UgdGhlIGRldGFpbCByb3cgZG9lcyBub3QgaGF2ZSBpdHMgb3duIGV4cGFuZGVyIGJ1dCB1dGlsaXppbmcgdGhlXG4gICAgICogb3V0bGluZUNvbnRyb2xcbiAgICAgKi9cbiAgICBvbk91dGxpbmVFeHBhbmRDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgZm9yIHNpbmdsZSBjb2x1bW4gc29ydGluZ1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0U2luZ2xlKCk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRhdGEgY2hhbmdlcywgZWl0aGVyIHRoZXkgYXJlIGxhemlseSBmZXRjaGVkIG9yIEBJbnB1dCBMSVNUIGlzIHVwZGF0ZWQgd2UgbmVlZFxuICAgICAqIHJlc29ydCBvdXQgZGF0YSBiYXNlZCBvbiBjdXJyZW50IHN0YXRlIGFuZCB1cGRhdGUgaW50ZXJuYWwgbGlzdCBkYXRhVG9SZW5kZXIgc28gbmV3XG4gICAgICogZGF0YSBjYW4gcmUtcmVuZGVyZWQgKyB0cmlnZ2VycyBldmVudCB2YWx1ZUNoYW5nZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUNoYW5nZSgpOiB2b2lkO1xuXG4gICAgdXBkYXRlRGF0YVRvUmVuZGVyKGRhdGFzb3VyY2U/OiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3Qgb3IgdW5zZWxlY3QgYWxsIHJvd3MuIFVzZWQgYnkgaGVhZGVyIGNoZWNrYm94XG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVBbGxDb2x1bW5zKGV2ZW50OiBhbnkpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogTW9yZSBsaWtlIHV0aWxpdHkgbWV0aG9kcyB0byB0cmFuc2xhdGUgc3RyaW5nPC0tPm51bWJlciB2YWx1ZSBmb3Igc29ydGluZ1xuICAgICAqXG4gICAgICogQ3VycmVudGx5IHVzZWQgb25seSBieSBEVENvbHVtbi4gV2UgbWlnaHQgd2FudCB0byBtb3ZlIHRoaXMgaXRzIG93biBjb21wb25lbnQgZm9yXG4gICAgICogaGVhZGVyU29ydCBhbmQgb3JkZXJpbmdcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRPcmRlcmluZ0ZvclN0cmluZyhkaXJlY3Rpb246IHN0cmluZyk6IG51bWJlcjtcblxuICAgIHNvcnRPcmRlcmluZ0Zvck51bWJlcihkaXJlY3Rpb246IG51bWJlcik6IHN0cmluZztcblxuICAgIHZpc2libGVDb2x1bW5zKCk6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG4gICAgaGFzRnJvemVuQ29sdW1ucygpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUGxhY2Vob2xkZXIgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIHNpbmdsZS9tdWx0aXNlbGVjdCBmdW5jdGlvbmFsaXR5IHdoZXJlIHdlIG5lZWQgdG8gdHJhY2sgaWZcbiAgICAgKiB3ZSBzdXBwb3J0IHNlbGVjdGlvbiBwbHVzIGhvdyBtYW55IGNvbHVtbiBpdCBvY2N1cGllcyBhbmQgaWYgdGhlIHNlbGVjdGlvbiBjb250cm9scyBhcmVcbiAgICAgKiB2aXNpYmxlIG9yIGhpZGRlbi5cbiAgICAgKi9cbiAgICBoYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQbGFjZWhvbGRlciB0byBpZGVudGlmeSBpZiB0aGV5IGFyZSBub24tdmFsdWUgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCk6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFRvIGNvbXBhcmUgdGhlIGRhdGEgaWYgd2UgdXNlIGRlZXAgb2JqZWN0IGVxdWFsaXR5IGFuZCB0aGlzIGlzIHVzZWQgd2l0aGluIHRoaXMgY2xhc3MgYXNcbiAgICAgKiB3ZWxsIGFzIGZyb20gdGhlIERUQ29sdW1uIHRvIGNvbmRpdGlvbmFsbHkgYWRkIGNsYXNzIHdoaWNoIHNlbGVjdCB0aGUgY2VsbFxuICAgICAqXG4gICAgICogV2UgbWlnaHQgd2FudCB0byBjaGFuZ2UgdG8gY2hlY2sgb25seSBhIGtleSBvZiB0aGUgb2JqZWN0IHNvbWUgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAgICovXG4gICAgaXNIZWFkZXJTZWxlY3RlZChpdGVtOiBEVENvbHVtbjJDb21wb25lbnQpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgc3BlY2lmaWMgY2VsbCBpcyBzZWxlY3RlZC4gV2UgbmVlZCB0d28gcG9pbnRzIHRvIGlkZW50aWZ5IGlmIGNlbGwgaXMgc2VsZWN0ZWRcbiAgICAgKiB0aGUgYWN0dWFsIEl0ZW0gdGhhdCBjb3VsZCByZXByZXNlbnQgd2hvbGUgcm93IGFuZCBDb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIGlzQm9keUNlbGxTZWxlY3RlZChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqICBDaGVjayBpZiB0aGUgZ2l2ZW4gaXRlbSBpcyBhbW9uZyB0aGUgc2VsZWN0ZWQgb25lc1xuICAgICAqXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZChpdGVtOiBhbnkpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIFtjaGlsZHJlbl0gYmluZGluZyBpcyBwcmVzZW50IHRoZW4gaXQgbWVhbnMgd2UgbmVlZCB0byByZW5kZXIgaXQgYXMgYSB0cmVlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc091dGxpbmUoKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZWZhdWx0cyB0aGUgY2hlY2tib3ggdG8gZWl0aGVyIHNlbGVjdGVkIGFuZCBub3Qgc2VsZWN0ZWQgZGVwZW5kZWQgb24gaW50ZXJuYWwgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzVG9nZ2xlQWxsQ29sdW1uU2VsZWN0ZWQoKTogYm9vbGVhbjtcblxuICAgIGlzVG9nZ2xlQWxsQ29sdW1uRGlzYWJsZWQoKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VzIGFyZSBmaWVsZCBwYXRoIHV0aWxpdHkgY2xhc3MgdG8gcmV0cmlldmUgZGF0YSBmcm9tIG9iamVjdFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmFsdWUoZGF0YTogYW55LCBmaWVsZDogc3RyaW5nKTogYW55O1xuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgYXNzZXJ0LFxuICAgIEVudGl0eSxcbiAgICBlcXVhbHMsXG4gICAgaXNCbGFuayxcbiAgICBpc0VudGl0eSxcbiAgICBpc1ByZXNlbnQsXG4gICAgaXNTdHJpbmcsXG4gICAgTWFwV3JhcHBlclxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0RhdGFTb3VyY2UsIERTSW5pdFBhcmFtc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQge0RhdGFGaW5kZXIsIERhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZSwgRHJvcFBvc2l0aW9ufSBmcm9tICcuL2F3LWRhdGF0YWJsZSc7XG5cblxuLyoqXG4gKiBDb25jcmV0ZSBEYXRhU291cmNlIGltcGxlbWVudGF0aW9uIGZvciBEYXRhdGFibGUgd2hpY2ggZGVmaW5lcyBzdGF0ZSBhbmQgY29sdW1uIGRlZmluaXRpb24gdGhhdFxuICogY2FuIHByb2dyYW1tYXRpY2FsbHkgbW9kaWZ5IHJlbmRlcmVkIGNvbHVtbnMgKGlmIHByb3ZpZGVkKSBhbmQgbWV0aG9kIGZvciBpbnNlcnRpbmcgYW5kXG4gKiBhbmQgZGVsZXRpbmcgcmVjb3JkcztcbiAqXG4gKiBBbGwgb3BlcmF0aW9ucyBkZWFsaW5nIHdpdGggZGF0YSB1c2UgT2JzZXJ2YWJsZTxUPiBhbmQgaW5zdGFudCgpIG1ldGhvZCB0byByZXRyaWV2ZSBjdXJyZW50XG4gKiBzdGF0ZSBpcyBub3QgaW1wbGVtZW50ZWQuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIERUMkRhdGFTb3VyY2UgZXh0ZW5kcyBEYXRhU291cmNlIHtcbiAgICBzdGF0aWMgcmVhZG9ubHkgTWF4TGltaXQgPSAxMDA7XG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGluZyBkYXRhUHJvdmlkZXJzIGFuZCBmaW5kZXJzXG4gICAgICovXG4gICAgZGF0YVByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcbiAgICBkYXRhRmluZGVyOiBEYXRhRmluZGVyO1xuXG4gICAgLyoqXG4gICAgICogS2VlcCB0cmFjayBvZiBjdXJyZW50IGRhdGF0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIHN0YXRlOiBEYXRhdGFibGUyU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIG9iamVjdCBiZWluZyByZW5kZXJlZFxuICAgICAqL1xuICAgIHByaXZhdGUgZW50aXR5OiBFbnRpdHlEZWYyO1xuXG5cbiAgICBpbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgZGVidWdUaW1lOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0YVByb3ZpZGVycz86IERhdGFQcm92aWRlcnMsIHB1YmxpYyBmaW5kZXJzPzogRGF0YUZpbmRlcnMpIHtcbiAgICAgICAgc3VwZXIoZGF0YVByb3ZpZGVycywgZmluZGVycyk7XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IERhdGF0YWJsZTJTdGF0ZS5jcmVhdGUoKTtcblxuICAgICAgICB0aGlzLmRlYnVnVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cblxuXG4gICAgaW5pdCguLi5hcmdzOiBhbnlbXSk6IHZvaWQge1xuICAgICAgICBpZiAoaXNCbGFuayhhcmdzKSB8fCBhcmdzLmxlbmd0aCAhPT0gMSAmJiAhaXNEVEluaXRQYXJhbXMoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gaW5pdGlhbGl6ZSBEUyB3aXRoIChEU0Nob29zZXJJbml0UGFyYW1zKScpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbml0OiBEVERTSW5pdFBhcmFtcyA9IGFyZ3NbMF07XG5cbiAgICAgICAgLy8gdXNlIGV4aXN0aW5nIG9yIGZpbmQgYmVzdCBtYXRjaCBmb3IgZGF0YVByb3ZpZGVyXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YVByb3ZpZGVyKSA/IGluaXQuZGF0YVByb3ZpZGVyXG4gICAgICAgICAgICA6IHRoaXMuZGF0YVByb3ZpZGVycy5maW5kKGluaXQub2JqKTtcblxuICAgICAgICAvLyB1c2UgZXhpc3Rpbmcgb3IgZmluZCBiZXN0IG1hdGNoIGZvciBkYXRhRmluZGVyXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IGlzUHJlc2VudChpbml0LmRhdGFGaW5kZXIpID8gaW5pdC5kYXRhRmluZGVyXG4gICAgICAgICAgICA6IHRoaXMuZmluZGVycy5maW5kKHRoaXMuZGF0YVByb3ZpZGVyLCBpbml0LnF1ZXJ5VHlwZSk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmRhdGFQcm92aWRlcikgJiYgaXNQcmVzZW50KHRoaXMuZGF0YUZpbmRlciksXG4gICAgICAgICAgICAnRGF0YVNvdXJjZSBpbmNvcnJlY3RseSBpbml0aWFsaXplZC4gKERhdGFQcm92aWRlciwgRGF0YUZpbmRlcikgbWlzc2luZy4gJyk7XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmxvb2t1cEtleSA9IGluaXQubG9va3VwS2V5O1xuICAgICAgICBpZiAoaXNCbGFuayhpbml0LnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBEYXRhdGFibGUyU3RhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBpbml0LnN0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhc3luYyBmZXRjaCBkYXRhIHJlcXVlc3QgYW5kIHJlc3VsdCBpcyBnaXZlbiBiYWNrIHVzaW5nIGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlc1xuICAgICAqXG4gICAgICovXG4gICAgZmV0Y2god2l0aFBhcmFtcz86IERhdGF0YWJsZTJTdGF0ZSk6IHZvaWQge1xuICAgICAgICBsZXQgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh3aXRoUGFyYW1zKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gbmV3IE1hcCgpLnNldCgnb2Zmc2V0Jywgd2l0aFBhcmFtcy5vZmZzZXQpXG4gICAgICAgICAgICAgICAgLnNldCgnbGltaXQnLCB3aXRoUGFyYW1zLmxpbWl0KVxuICAgICAgICAgICAgICAgIC5zZXQoJ29yZGVyYnknLCB3aXRoUGFyYW1zLnNvcnRLZXkpXG4gICAgICAgICAgICAgICAgLnNldCgnc2VsZWN0b3InLCB3aXRoUGFyYW1zLnNvcnRPcmRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5mZXRjaChwYXJhbXMpLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHdpdGhQYXJhbXMub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpbmNyRGF0YSA9IFsuLi50aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpLCAuLi5yZXN1bHRdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoaW5jckRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHVzZXMgdGhpcyBtZXRob2QgdG8gb3BlbiB1cCBjb250aW51b3VzIHN0cmVhbSB0byBsaXN0ZW4gZm9yIGFueSBjaGFuZ2VzIHdoaWNoXG4gICAgICogbmVlZCB0byBiZSByZWZsZWN0ZWQgb24gdGhlIFVJLlxuICAgICAqXG4gICAgICogRG9udCBmb3JnZXQgdG8gdW5zdWJzY3JpYmUgd2hlbiBjb21wb25lbnQgaXMgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cblxuICAgIGNsb3NlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IG51bGw7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJZiBDUlVEIGlzIGVuYWJsZWQgd2UgZGVsZWdhdGUgY2FsbHMgdG8gRGF0YVByb3ZpZGVyIHRoYXQgaXMgcmVzcG9uc2libGUgdG8gdGVsbCB0aGVcbiAgICAgKiBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMgdGhhdCBhcmUgbmV3IGRhdGEuIElmIG5vdCBlbmFibGVkIHdlIGhhdmUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxuICAgICAqIHdoaWNoIHdvcmtzIHdpdGggbG9jYWwgYXJyYXlcbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydChvYmplY3Q6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kYXRhUHJvdmlkZXIuY2FuQ1JVRCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5pbnNlcnQob2JqZWN0KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkucHVzaChvYmplY3QpO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KGNvcHkpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQbGVhc2Ugc2VlIHtAbGluayBpbnNlcnR9IG1ldGhvZFxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlKG9iamVjdDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm92aWRlci5jYW5DUlVEKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLnJlbW92ZShvYmplY3QpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKS5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IGFmdGVyRGVsZXRlID0gY29weS5maWx0ZXIoKGVsZW06IGFueSkgPT4gIWVxdWFscyhlbGVtLCBvYmplY3QpKTtcblxuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChhZnRlckRlbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFByb3ZpZGVzIGFjY2VzcyB0byBEYXRhRmluZGVyIHdoaWNoIGNhbiBhY2NlcHQgZWl0aGVyIHBsYWluIHN0cmluZyBvciBNYXAuXG4gICAgICpcbiAgICAgKiBUbyBiZSBhYmxlIHRvIHByb3ZpZGUgY29ycmVjdCBpbnB1dCB3ZSBuZWVkIHRvIGFzayBEYXRhRmluZGVyIGlmIGl0IHN1cHBvcnRzIEZ1bGxUZXh0IGxpa2VcbiAgICAgKiB0eXBlIHF1ZXJ5IG9yIFByZWRpY2F0ZS4gSW4gY2FzZSBvZiBQcmVkaWNhdGUgd2UgYnVpbGQgdGhlIE1hcCB3aXRoIGRpZmZlcmVudCBrZXkvdmFsdWVcbiAgICAgKiBwYWlyc1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBmaW5kKHBhdHRlcm4/OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzQmxhbmsocGF0dGVybikgfHwgcGF0dGVybi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIHJlY2VpdmVkIGVtcHR5IHN0cmluZyByZXR1cm4gb3JnaW5hbCBsaXN0XG4gICAgICAgICAgICB0aGlzLmZldGNoKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNlYXJjaFBhcmFtOiBhbnkgPSBwYXR0ZXJuO1xuICAgICAgICBpZiAodGhpcy5kYXRhRmluZGVyLmFjY2VwdHModGhpcy5kYXRhUHJvdmlkZXIsIFF1ZXJ5VHlwZS5QcmVkaWNhdGUpKSB7XG4gICAgICAgICAgICBzZWFyY2hQYXJhbSA9IG5ldyBNYXAoKS5zZXQoJ3F1ZXJ5JywgcGF0dGVybikuc2V0KCdsaW1pdCcsIERUMkRhdGFTb3VyY2UuTWF4TGltaXQpO1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbS5zZXQoJ29yZGVyYnknLCB0aGlzLnN0YXRlLnNvcnRLZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbS5zZXQoJ3NlbGVjdG9yJywgdGhpcy5zdGF0ZS5zb3J0T3JkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXNzZXJ0KGlzU3RyaW5nKHBhdHRlcm4pLCAnQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB2YWx1ZSB0byBGdWxsVGV4dCBGaW5kZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5tYXRjaDxhbnk+KHNlYXJjaFBhcmFtKS5zdWJzY3JpYmUoKHJlc3VsdDogYW55W10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQocmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERhdGEgc291cmNlIGRlbGVnYXRlcyB0aGUgcmVzcG9uc2liaWxpdHkgdG8gdGhlIGdpdmVuIGRhdGEgcHJvdmlkZXIgd2hpY2ggbmVlZHMgdG8gaW1wbGVtZW50XG4gICAgICogc3BlY2lmaWMgc29ydGluZyBtZWNoYW5pc21cbiAgICAgKlxuICAgICAqIFRvZG86IEV4dGVuZCB0byBzb3J0IGJ5IG11bHRpcGxlIGNvbHVtbnNcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnQoa2V5OiBzdHJpbmcsIHNvcnRPcmRlcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKSkgfHwgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydEtleSA9IGtleTtcbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0T3JkZXIgPSBzb3J0T3JkZXI7XG4gICAgICAgIHRoaXMuZmV0Y2godGhpcy5zdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBQZXJzaXN0IGRiIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVTdGF0ZShvZmZzZXQ6IG51bWJlciwgc29ydEZpZWxkOiBzdHJpbmcsIHNPcmRlcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RhdGUub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSBzb3J0RmllbGQ7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gc09yZGVyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiByZXNodWZmbGVzIGN1cnJlbnQgYXJyYXkgYmFzZWQgb24gbmV3IHJvdyBEJkQgcmVzdWx0LlxuICAgICAqXG4gICAgICogU2luY2UgdGhlcmUgaXMgYSBkaWZmZXJlbmNlIGlmIHdlIG1vdmUgaXRlbSBmcm9tIGJvdHRvbSBvciBmcm9tIHRoZSB0b3AgYW5kIHRoZW4gYWNjb3JkaW5nbHlcbiAgICAgKiBoaWdobGlnaHRpbmcgYSBzcGFjZSBiZXR3ZWVuIHJvd3MuIFdlIG5lZWQgdG8gcmVmbGVjdCB0aGlzIGluIGhlcmUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIFVzZUNhc2UgMTpcbiAgICAgKlxuICAgICAqIDEuIFlvdSBjYW4gZ3JhYiBpdGVtIHdpdGggaW5kZXggMCBhbmQgbW92ZSBpdCBkb3duIHNvIHRoYXQgeW91IGNhbiBzZWUgYSBkcm9wcGluZyBsaW5lXG4gICAgICogYmV0d2VlbiByb3cgd2l0aCBpbmRleCAyIC0gM1xuICAgICAqXG4gICAgICogMi4gSW4gdGhpcyBjYXNlIHNwbGljZSgpIHN0YXJ0cyBmcm9tIHBvc2l0aW9uIDIgYW5kIGluc2VydCBhbGwgZWxlbWVudHMgYWZ0ZXIgMlxuICAgICAqICAgICAgc3BsaWNlKHN0YXJ0OiBudW1iZXIsIGRlbGV0ZUNvdW50OiBudW1iZXIsIC4uLml0ZW1zOiBUW10pOiBUW107XG4gICAgICpcbiAgICAgKiAzLiBubyBuZWVkIHRvIHVwZGF0ZSBuZXdQb3NcbiAgICAgKlxuICAgICAqIFVzZUNhc2UgMjpcbiAgICAgKlxuICAgICAqIDEuIFlvdSBjYW4gZ3JhYiBpdGVtIHdpdGggaW5kZXggMCBhbmQgbW92ZSBhbGwgdGhlIHdheSBkb3duIG9mIHRoZSBEVCBhbmQgbm93IG1vdmUgdGhlXG4gICAgICogcm93IHRvd2FyZCBUT1AgYW5kIHNwYWNlIGJldHdlZW4gcm93cyB3aXRoIGluZGV4IDIgLSAzIGlzIGhpZ2hsaWdodGVkIGFnYWluLlxuICAgICAqXG4gICAgICogMi4gSGVyZSBpcyB0aGUgZGlmZmVyZW5jZSwgYmVmb3JlIHdlIGhpZ2hsaWdodGVkIHJvdyAjMiB3aXRoIGxpbmUgYXQgdGhlIGJvdHRvbSwgbm93XG4gICAgICogaXQgc2VlbXMgdGhlIHNhbWUgYnV0IGl0cyBoaWdobGlnaHRlZCByb3cgIzMgd2l0aCBsaW5lIGF0IHRoZSBUT1AuXG4gICAgICpcbiAgICAgKiAqIFRoaXMgaXMgdGhlIHJlYXNvbiB3aGV5IHdlIG5lZWQgdG8gZG8gbmV3UG9zIC09IDEgb3IgbmV3UG9zICs9IDE7IGRlcGVuZGluZyBvdXIgZGlyZWN0aW9uXG4gICAgICogd2hlcmUgd2hlcmUgdGhlIGxpbmUgYmV0d2VlbiByb3dzIGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKlxuICAgICAqIFdlIGRvbid0IG5lZWQgYW55IGNvbXBsaWNhdGVkIGNhbGN1bGF0aW9uIHRyeWluZyB0byBmaW5kIG91dCBpZiB3ZSBhcmUgb24gb25lIGhhbGYgb2YgdGhlIHJvd1xuICAgICAqIG9yIHNlY29uZCBoYWxmIGFuZCBiYXNlZCBvbiB0aGlzIHRyeSB0byBhcHBseSBjZXJ0YWluIHN0eWxlLiBUaGlzIHdvdWxkIG5vdCBnaXZlIHNvIG11Y2hcbiAgICAgKiBzcGFjZSBpZiB3ZSB3YW50IGRyb3Agcm93IGludG8gdGhlIHJvdy4gQW5kIHRoZSBjYWxjdWxhdGlvbiB3aXRoIGNvb3JkaW5hdGVzIHdvdWRsIGJlIHRvb1xuICAgICAqIGNvbXBsaWNhdGVkLlxuICAgICAqXG4gICAgICogV2Ugc2ltcGx5IHJlbWVtYmVyIHRoZSBkaXJlY3Rpb24gd2UgYXJlIG1vdmluZyBhbmQgYmFzZWQgb24gdGhpcyB3ZSBhcHBseSBzdHlsZSB0b1xuICAgICAqIHRvIGNyZWF0ZSBhIGxpbmUgYXQgdGhlIFRPUCBpZiB3ZSBhcmUgZ29pbmcgdXB3YXJkcyBvciBib3R0b20gb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICByZW9yZGVyUm93cyhvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkIHtcbiAgICAgICAgbGV0IGFycmF5ID0gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gdGFrZSBzb21ldGhpbmcgZnJvbSB0b3AgYW5kIGRyYWcmZHJvcCB1bmRlclxuICAgICAgICBpZiAobmV3UG9zID4gb3JpZ1BvcyAmJiBkcm9wUG9zID09PSBEcm9wUG9zaXRpb24uQmVmb3JlICYmIG5ld1BvcyA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgbmV3UG9zIC09IDE7XG5cbiAgICAgICAgICAgIC8vIHRha2Ugc29tZXRoaW5nIGZyb20gYm90dG9tIGFuZCBkcmFnJmRyb3AgYWJvdmVcbiAgICAgICAgfSBlbHNlIGlmIChuZXdQb3MgPCBvcmlnUG9zICYmIGRyb3BQb3MgPT09IERyb3BQb3NpdGlvbi5BZnRlciAmJiBuZXdQb3MgPj0gMCkge1xuICAgICAgICAgICAgbmV3UG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheS5zcGxpY2UobmV3UG9zLCAwLCAuLi5hcnJheS5zcGxpY2Uob3JpZ1BvcywgMSlbMF0pO1xuICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KGFycmF5KTtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBFbnRpdHkgZGVmaW5pdGlvbiB0byBiZSB1c2VkIHRvIGluaXRpYWxpemUgcHJvZ3JhbW1hdGljYWxseSBjb2x1bW5zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRW50aXR5RGVmMiB7XG4gICAgcHJvcGVydHlLZXlzOiBzdHJpbmdbXTtcblxuICAgIGRlZmF1bHRGb3JtYXR0ZXI6IChrZXk6IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgZGlzcGxheVN0cmluZ0ZvcktleTogKGtleTogc3RyaW5nKSA9PiBzdHJpbmc7XG5cbiAgICBkZWZhdWx0QWxpZ25tZW50Rm9yS2V5OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcbn1cblxuLyoqXG4gKiBLZWVwcyBjdXJyZW50IGRhdGF0YWJsZSBzdGF0ZSB0aGUgc3RhdGUgd2hpY2ggZHJpdmVycyB0aGUgd2F5IHdoaWxlIGZldGNoaW5nIHRoZSBkYXRhIGFzIHdlbGxcbiAqIGVuY2Fwc3VsYXRlIHNldCBvZiBwcm9wZXJ0aWVzIHRoYXQgbmVlZHMgdG8gYmUgcGVyc2lzdGV0IGluIG9yZGVyIHRvIHJlY292ZXIgYSBzdGF0ZSBhZnRlciBlLmcuXG4gKiBicm93c2VyIHJlZnJlc2hcbiAqXG4gKlxuICogdG9kbzogQ3JlYXRlIG1ldGhvZHMgdG8gY29udmVydCB0aGlzIHN0YXRlIGZyb20gYW5kIHRvIEpTT04gZm9yIGVhc2llciBzZXJpYWxpemF0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhdGFibGUyU3RhdGUge1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgQXNjZW5kaW5nID0gMTtcbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IERlc2NlbmRpbmcgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgZm9yIHBhZ2luZyBhbmQgZmV0Y2hpbmdcbiAgICAgKi9cbiAgICBvZmZzZXQ6IG51bWJlciA9IDA7XG4gICAgbGltaXQ6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGRlZmF1bHQgdmFsdWUgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciBOIG51bWJlciBvZiByb3dzIGluIG5vbi1mdWxsc2NyZWVuXG4gICAgICogbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheUxpbWl0OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzb3J0aW5nIGZpZWxkXG4gICAgICovXG4gICAgc29ydEtleTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU29ydGluZyBvcmRlciBvZiB0aGUgc29ydCBmaWVsZC4gRGF0YVRhYmxlIHN1cHBvcnQgc29ydGluZyBmb3IgbXVsdGlwbGUgY29sdW1uIGJ1dCB3ZVxuICAgICAqIGRvbnQgcGVyc2lzdCBpdCBub3cuIE1heWJlIGluIHRoZSBmdXR1cmVcbiAgICAgKi9cbiAgICBzb3J0T3JkZXI6IG51bWJlciA9IERhdGF0YWJsZTJTdGF0ZS5Bc2NlbmRpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBhcmUgdXNpbmcgZ2xvYmFsIGZpbHRlciBmb3IgY3VycmVudCBkYXRhdGFibGUgdGhlbiBzYXZlIGl0IGhlcmVcbiAgICAgKi9cbiAgICBjdXJyZW50U2VhcmNoUXVlcnk6IHN0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBpZiBhbnkgcHJlc2VsZWN0ZWQgZmlsdGVyXG4gICAgICovXG4gICAgY3VycmVudEZpbHRlcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50IGN1cnJlbnQgc2VsZWN0aW9uIGRlcGVuZGluZyBvbiBzZWxlY3Rpb24gbW9kZS5cbiAgICAgKlxuICAgICAqIEN1cnJlbnQgc2VsZWN0aW9uIHVzZWQgYm90aCBmb3Igcm93IHNlbGVjdGlvbiBhbmQgY2VsbCBzZWxlY3Rpb24uIFJvdyBzZWxlY3Rpb24gaXMgdXNlZCB3aGVuXG4gICAgICogU2luZ2xlU2VsZWN0IGFuZCBNdWx0aVNlbGVjdCBvbmNlIHdlIGltcGxlbWVudCB0aGlzLlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0aW9uOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gaGVhZGVyIHNlbGVjdGlvbiBpcyBlbmFibGVkIGl0IGNhcHR1cmVzIGN1cnJlbnRseSBzZWxlY3RlZCBjb2x1bW5cbiAgICAgKi9cbiAgICBoZWFkZXJTZWxlY3Rpb246IERUQ29sdW1uMkNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgSG9sZHMgY3VycmVudCBzdGF0ZSBvZiB0aGUgb3V0bGluZSB0cmVlIGlmIHVzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG91dGxpbmVTdGF0ZT86IE1hcDxhbnksIGJvb2xlYW4+O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgSG9sZHMgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGV0YWlsIHJvd3MgaWYgdXNlZFxuICAgICAqXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5kU3RhdGU/OiBNYXA8YW55LCBib29sZWFuPjtcblxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMub3V0bGluZVN0YXRlID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKG9mZnNldDogbnVtYmVyID0gMCwgbGltaXQ6IG51bWJlciA9IDE1LCBkaXNwbGF5TGltaXQ6IG51bWJlciA9IDUsXG4gICAgICAgICAgICAgICAgICBzb3J0RmllbGQ6IHN0cmluZyA9ICcnLCBzT3JkZXI6IG51bWJlciA9IDAsIHNlYXJjaFF1ZXJ5Pzogc3RyaW5nLCBmaWx0ZXI/OiBhbnksXG4gICAgICAgICAgICAgICAgICBvdXRsaW5lU3RhdGU6IE1hcDxhbnksIGJvb2xlYW4+ID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCksXG4gICAgICAgICAgICAgICAgICBkZXRhaWxSb3dTdGF0ZTogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKSk6IERhdGF0YWJsZTJTdGF0ZSB7XG4gICAgICAgIGxldCBzID0gbmV3IERhdGF0YWJsZTJTdGF0ZSgpO1xuICAgICAgICBzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgcy5saW1pdCA9IGxpbWl0O1xuICAgICAgICBzLmRpc3BsYXlMaW1pdCA9IGRpc3BsYXlMaW1pdDtcbiAgICAgICAgcy5zb3J0S2V5ID0gc29ydEZpZWxkO1xuICAgICAgICBzLnNvcnRPcmRlciA9IHNPcmRlcjtcbiAgICAgICAgcy5jdXJyZW50U2VhcmNoUXVlcnkgPSBzZWFyY2hRdWVyeTtcbiAgICAgICAgcy5jdXJyZW50RmlsdGVyID0gZmlsdGVyO1xuICAgICAgICBzLm91dGxpbmVTdGF0ZSA9IG91dGxpbmVTdGF0ZTtcbiAgICAgICAgcy5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IGRldGFpbFJvd1N0YXRlO1xuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHN0YXRpYyBmcm9tSlNPTihkYXRhOiBzdHJpbmcpOiBEYXRhdGFibGUyU3RhdGUge1xuICAgICAgICBsZXQgc3RhdGU6IERUU3RhdGVTZXJpYWxpemFibGVIZWxwZXIgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICBsZXQgZHMgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIGRzLm9mZnNldCA9IHN0YXRlLm9mZnNldDtcbiAgICAgICAgZHMubGltaXQgPSBzdGF0ZS5saW1pdDtcbiAgICAgICAgZHMuZGlzcGxheUxpbWl0ID0gc3RhdGUuZGlzcGxheUxpbWl0O1xuICAgICAgICBkcy5zb3J0S2V5ID0gc3RhdGUuc29ydEtleTtcbiAgICAgICAgZHMuc29ydE9yZGVyID0gc3RhdGUuc29ydE9yZGVyO1xuICAgICAgICBkcy5jdXJyZW50U2VhcmNoUXVlcnkgPSBzdGF0ZS5jdXJyZW50U2VhcmNoUXVlcnk7XG4gICAgICAgIGRzLm91dGxpbmVTdGF0ZSA9IE1hcFdyYXBwZXIuY3JlYXRlRnJvbUFueU1hcDxib29sZWFuPihzdGF0ZS5vdXRsaW5lU3RhdGUpO1xuICAgICAgICBkcy5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IE1hcFdyYXBwZXIuY3JlYXRlRnJvbUFueU1hcDxib29sZWFuPihzdGF0ZS5kZXRhaWxSb3dFeHBhbmRTdGF0ZSk7XG5cbiAgICAgICAgcmV0dXJuIGRzO1xuICAgIH1cblxuXG4gICAgc3RhdGljIHRvSlNPTihkYXRhOiBEYXRhdGFibGUyU3RhdGUpOiBzdHJpbmcge1xuICAgICAgICBsZXQgdG9Db252ZXJ0OiBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyID0ge1xuICAgICAgICAgICAgb2Zmc2V0OiBkYXRhLm9mZnNldCxcbiAgICAgICAgICAgIGxpbWl0OiBkYXRhLmxpbWl0LFxuICAgICAgICAgICAgZGlzcGxheUxpbWl0OiBkYXRhLmRpc3BsYXlMaW1pdCxcbiAgICAgICAgICAgIHNvcnRLZXk6IGRhdGEuc29ydEtleSxcbiAgICAgICAgICAgIHNvcnRPcmRlcjogZGF0YS5zb3J0T3JkZXIsXG4gICAgICAgICAgICBjdXJyZW50U2VhcmNoUXVlcnk6IGRhdGEuY3VycmVudFNlYXJjaFF1ZXJ5LFxuICAgICAgICAgICAgb3V0bGluZVN0YXRlOiBNYXBXcmFwcGVyLnRvQW55TWFwKGRhdGEub3V0bGluZVN0YXRlKSxcbiAgICAgICAgICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlOiBNYXBXcmFwcGVyLnRvQW55TWFwKGRhdGEuZGV0YWlsUm93RXhwYW5kU3RhdGUpXG5cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRvQ29udmVydCk7XG4gICAgfVxuXG59XG5cblxuLyoqXG4gKiBUaGlzIG5lZWRzIHRvIGdvIHRvIERURGF0YVNvdXJjZSB0byBrZWVwIGFuZCBtYW5hZ2UgdGhlIHN0YXRlIG9mIHRoZSBkZXRhaWwgcm93LiBUaGUgaWRlYSBpc1xuICogc2ltcGxlIHdlIGhhdmUgYSBtYXAgaG9sZGluZyBpdGVtIHJlZmVyZW5jZSBhcyBhIGtleSBhbmQgYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoZVxuICogZGV0YWlsIHJvdyBpcyB2aXNpYmxlXG4gKlxuICogVG9kbzogbW92ZSB0aGlzIG91dCB0byBEU1xuICovXG5leHBvcnQgY2xhc3MgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGUge1xuXG4gICAgZXhwYW5zaW9uU3RhdGVzOiBNYXA8YW55LCBib29sZWFuPjtcblxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBkdDogQVdEYXRhVGFibGUpIHtcbiAgICB9XG5cbiAgICBwcml2YXRlIGl0ZW1Ub0tleShpdGVtOiBhbnkpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gaXNFbnRpdHkoaXRlbSkgPyAoPEVudGl0eT5pdGVtKS5pZGVudGl0eSgpIDogaXRlbTtcbiAgICB9XG5cbiAgICBnZXQgZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmV4cGFuc2lvblN0YXRlcyk7XG4gICAgfVxuXG4gICAgc2V0IGRldGFpbEV4cGFuc2lvbkVuYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGUoaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhwYW5kZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLnNldChrZXksIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuZGV0YWlsUm93RXhwYW5kU3RhdGUgPSB0aGlzLmV4cGFuc2lvblN0YXRlcztcbiAgICB9XG5cbiAgICBpc0V4cGFuZGVkKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQga2V5ID0gdGhpcy5pdGVtVG9LZXkoaXRlbSk7XG4gICAgICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgY29sbGFwc2UgcGFyZW50IG9mIHBhcmVudCB3aGlsZSBkZXRhaWwgcm93IGlzIGV4cGFuZGVkXG4gICAgICAgIGlmICh0aGlzLmR0LmlzT3V0bGluZSgpICYmICF0aGlzLmR0Lm91dGxpbmVTdGF0ZS5pc0V4cGFuZGVkKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGlzT3V0bGluZUV4cGFuZGVkID0gdGhpcy5kdC5pc091dGxpbmUoKSA/IHRoaXMuZHQub3V0bGluZVN0YXRlLmlzRXhwYW5kZWQoa2V5KSA6IHRydWU7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoa2V5KSAmJiB0aGlzLmV4cGFuc2lvblN0YXRlcy5oYXMoa2V5KTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRFRTdGF0ZVNlcmlhbGl6YWJsZUhlbHBlciB7XG4gICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgbGltaXQ6IG51bWJlcjtcbiAgICBkaXNwbGF5TGltaXQ6IG51bWJlcjtcbiAgICBzb3J0S2V5OiBzdHJpbmc7XG4gICAgc29ydE9yZGVyOiBudW1iZXI7XG4gICAgY3VycmVudFNlYXJjaFF1ZXJ5OiBzdHJpbmc7XG4gICAgY3VycmVudEZpbHRlcj86IGFueTtcbiAgICBvdXRsaW5lU3RhdGU6IGFueTtcbiAgICBkZXRhaWxSb3dFeHBhbmRTdGF0ZTogYW55O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RUSW5pdFBhcmFtcyhpbml0OiBEVERTSW5pdFBhcmFtcyk6IGluaXQgaXMgRFREU0luaXRQYXJhbXMge1xuICAgIHJldHVybiBpc1ByZXNlbnQoaW5pdC5vYmopIHx8IGlzUHJlc2VudChpbml0LnF1ZXJ5VHlwZSkgfHwgaXNQcmVzZW50KGluaXQuZW50aXR5KTtcbn1cblxuLyoqXG4gKiBUbyBtYWtlIGluaXRpYWxpemF0aW9uIGVhc2llciB3ZSBoYXZlIHRoaXMgY29tbW9uIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBEVERTSW5pdFBhcmFtcyBleHRlbmRzIERTSW5pdFBhcmFtcyB7XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgZGVmaW5pdGlvbiBmb3IgdGhlIGRhdGFcbiAgICAgKi9cbiAgICBlbnRpdHk/OiBFbnRpdHlEZWYyO1xuXG4gICAgc3RhdGU/OiBEYXRhdGFibGUyU3RhdGU7XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBJbmplY3QsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogQ29sdW1uIGltcGxlbWVudGF0aW9uIGZvciB0aGUgTXVsdGlzZWxlY3Rpb24gd2hlcmUgd2Ugc2hvdyBjaGVja2JveCBjb250cm9sXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1tdWx0aS1zZWxlY3QtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBNYW5hZ2VzIG11bHRpIHNlbGVjdGlvbiBhbmQgcmVuZGVycyBjaGVja2JveGVzIGJvdGggZm9yIGhlYWRlciBpbiBjYXNlIFtzaG93U2VsZWN0QWxsXSBpc1xuICAgIGVuYWJsZWQgYXMgd2VsbCBhcyBlYWNoIGNoZWNrYm94IHBlciByb3dcbi0tPlxuPG5nLXRlbXBsYXRlICNyZW5kZXJpbmdUZW1wbGF0ZSBsZXQtaXNIZWFkZXIgbGV0LWlzU3ViSGVhZGVyPVwiaXNTdWJIZWFkZXJcIiBsZXQtY29sdW1uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICBsZXQtZGF0YVRvUmVuZGVyPVwiZGF0YVwiXG4gICAgICAgICAgICAgbGV0LWxldmVsPVwibmVzdGluZ0xldmVsXCJcbiAgICAgICAgICAgICBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiXG4gICAgICAgICAgICAgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sSGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGlzU3ViSGVhZGVyLCBjb2x1bW5JbmRleDpjb2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgICAgbGV2ZWw6bGV2ZWx9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIiFpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEJvZHlcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogY29sdW1uLCBsZXZlbDpsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTpkYXRhVG9SZW5kZXIscm93SW5kZXg6cm93SW5kZXh9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNjb2xIZWFkZXIgbGV0LWlzU3ViSGVhZGVyIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCI+XG4gICAgPHRoIFtuZ0NsYXNzXT1cInsnZHQtaXMtZGVmYXVsdCBkdC11LXVuc2VsZWN0YWJsZS10ZXh0IGR0LXNlbGVjdGlvbi1jb2x1bW4nIDp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtY2VsbC1kZWYnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtc3ViLWhlYWRlcic6IGlzU3ViSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWR0LnNob3dTZWxlY3Rpb25Db2x1bW59XCIgYWxpZ249XCJjZW50ZXJcIj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZHQuc2hvd1NlbGVjdEFsbFwiPlxuICAgICAgICAgICAgPGF3LWNoZWNrYm94IFt0eXBlXT1cIidhY3Rpb24nXCIgKGFjdGlvbik9XCJkdC50b2dnbGVBbGxDb2x1bW5zKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJkdC5pc1RvZ2dsZUFsbENvbHVtblNlbGVjdGVkKClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkdC5pc1RvZ2dsZUFsbENvbHVtbkRpc2FibGVkKClcIj5cbiAgICAgICAgICAgIDwvYXctY2hlY2tib3g+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFkdC5zaG93U2VsZWN0QWxsXCI+Jm5ic3A7XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC90aD5cblxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2NvbEJvZHkgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIiAsIGxldC1sZXZlbD1cImxldmVsXCI+XG5cbiAgICA8dGQgI2NlbGwgW2NsYXNzXT1cImR5bmFtaWNCb2R5Q2xhc3MoZGF0YSlcIlxuICAgICAgICBbc3R5bGUucGFkZGluZy1sZWZ0LnB4XT1cImluZGVudEZvckNvbnRyb2woY2VsbCwgbGV2ZWwpXCJcbiAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICBbbmdDbGFzc109XCJ7ICdkdC1pcy1kZWZhdWx0IGR0LXNlbGVjdGlvbi1jb2x1bW4nOiB0cnVlLFxuICAgICAgICAnZHQtY2VsbC1kZWYnOiB0cnVlLFxuICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWR0LnNob3dTZWxlY3Rpb25Db2x1bW59XCI+XG5cbiAgICAgICAgPGF3LWNoZWNrYm94IFt0eXBlXT1cIidhY3Rpb24nXCIgW3ZhbHVlXT1cImR0LmlzUm93U2VsZWN0ZWQoZGF0YSlcIiA+XG4gICAgICAgIDwvYXctY2hlY2tib3g+XG5cbiAgICA8L3RkPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcikge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiBjb250cm9sXG4gICAgICAgIHRoaXMud2lkdGggPSAnNDVweCc7XG4gICAgfVxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDb2x1bW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBTaW5nbGVTZWxlY3Qgd2hlcmUgd2Ugc2hvdyBjaGVja2JveCBjb250cm9sXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1zaW5nbGUtc2VsZWN0LWNvbHVtbicsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgTWFuYWdlcyBtdWx0aSBzZWxlY3Rpb24gYW5kIHJlbmRlcnMgY2hlY2tib3hlcyBib3RoIGZvciBoZWFkZXIgaW4gY2FzZSBbc2hvd1NlbGVjdEFsbF0gaXNcbiAgICBlbmFibGVkIGFzIHdlbGwgYXMgZWFjaCBjaGVja2JveCBwZXIgcm93XG4tLT5cbjxuZy10ZW1wbGF0ZSAjcmVuZGVyaW5nVGVtcGxhdGUgbGV0LWlzSGVhZGVyIGxldC1pc1N1YkhlYWRlcj1cImlzU3ViSGVhZGVyXCIgbGV0LWNvbHVtbj1cImNvbHVtblwiXG4gICAgICAgICAgICAgbGV0LWRhdGFUb1JlbmRlcj1cImRhdGFcIlxuICAgICAgICAgICAgIGxldC1sZXZlbD1cIm5lc3RpbmdMZXZlbFwiXG4gICAgICAgICAgICAgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEhlYWRlclwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpc1N1YkhlYWRlciwgY29sdW1uSW5kZXg6Y29sdW1uSW5kZXgsXG4gICAgICAgICAgICAgICAgIGxldmVsOmxldmVsfVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xCb2R5XCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGNvbHVtbiwgbGV2ZWw6bGV2ZWwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6ZGF0YVRvUmVuZGVyLHJvd0luZGV4OnJvd0luZGV4fVwiPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjY29sSGVhZGVyIGxldC1pc1N1YkhlYWRlciBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiPlxuICAgIDx0aCBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtdS11bnNlbGVjdGFibGUtdGV4dCBkdC1zZWxlY3Rpb24tY29sdW1uJyA6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWNlbGwtZGVmJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LXN1Yi1oZWFkZXInOiBpc1N1YkhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFkdC5zaG93U2VsZWN0aW9uQ29sdW1ufVwiIGFsaWduPVwiY2VudGVyXCI+XG4gICAgICAgICZuYnNwO1xuICAgIDwvdGg+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNjb2xCb2R5IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCIgLCBsZXQtbGV2ZWw9XCJsZXZlbFwiPlxuXG4gICAgPHRkICNjZWxsIFtjbGFzc109XCJkeW5hbWljQm9keUNsYXNzKGRhdGEpXCJcbiAgICAgICAgW3N0eWxlLnBhZGRpbmctbGVmdC5weF09XCJpbmRlbnRGb3JDb250cm9sKGNlbGwsIGxldmVsKVwiXG4gICAgICAgIGFsaWduPVwiY2VudGVyXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCBkdC1zZWxlY3Rpb24tY29sdW1uJzogdHJ1ZSxcbiAgICAgICAgJ2R0LWNlbGwtZGVmJzogdHJ1ZSxcbiAgICAgICAgJ2R0LWlzLWhpZGRlbic6ICFkdC5zaG93U2VsZWN0aW9uQ29sdW1ufVwiPlxuXG4gICAgICAgIDxhdy1yYWRpb2J1dHRvbiBbbmFtZV09XCInRFRSYWRpbydcIiBbdmFsdWVdPVwiZGF0YVwiIFsobmdNb2RlbCldPVwiZHQuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3Rpb25cIj5cbiAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAgICA8L3RkPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCBleHRlbmRzIERUQ29sdW1uMkNvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGRvbUhhbmRsZXI6IERvbUhhbmRsZXIpIHtcbiAgICAgICAgc3VwZXIoZW52LCBkb21IYW5kbGVyKTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxuXG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqICBAb3JpZ2luYWwtbGljZW5zZVxuICogIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogIENvcHlyaWdodCAoYykgMjAxNi0yMDE3IFByaW1lVGVrXG4gKlxuICogIENyZWRpdDogRGVyaXZlZCBhbmQgZXh0ZW5kZWQgZnJvbSBQcmltZS1uZyBkYXRhYmxlIHdoZXJlIHdlIG5lZWRlZCBtb3JlIG1vZHVsYXIgc29sdXRpb24uXG4gKiAgV2UgcmV1c2VkIHRoZSBjb3JlIHN0cnVjdHVyZSBhbmQgbGF5b3V0IGJ1dCBoYWQgdG8gcmVmYWN0b3IgYm90aCBjb2RlIGFuZCB0ZW1wbGF0ZSB0byBtYXRjaCBvdXJcbiAqICBuZWVkcy4gTW9yZSBpbiB0aGUgZGVzY3JpcHRpb25cbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbmplY3QsXG4gICAgSW5qZWN0b3IsXG4gICAgSW5wdXQsXG4gICAgTmdab25lLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JqZWN0VXRpbHN9IGZyb20gJ3ByaW1lbmcvY29tcG9uZW50cy91dGlscy9vYmplY3R1dGlscyc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge091dGxpbmVTdGF0ZX0gZnJvbSAnLi4vb3V0bGluZS9pbmRleCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBhc3NlcnQsXG4gICAgQm9vbGVhbldyYXBwZXIsXG4gICAgRW52aXJvbm1lbnQsXG4gICAgZXF1YWxzLFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0JsYW5rLFxuICAgIGlzUHJlc2VudCxcbiAgICBMaXN0V3JhcHBlclxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QVdEYXRhVGFibGUsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi9hdy1kYXRhdGFibGUnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtEVEhlYWRlckNvbXBvbmVudDJ9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy1leHBhbmRlci9kdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RBVEFfU09VUkNFfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YXRhYmxlMlN0YXRlLCBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSwgRFQyRGF0YVNvdXJjZX0gZnJvbSAnLi9kYXRhdGFibGUyLWRhdGEtc291cmNlJztcbmltcG9ydCB7XG4gICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdtdWx0aScgfCAnc2luZ2xlJyB8ICdjZWxsJyB8ICdub25lJztcblxuLyoqXG4gKiBEVCBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIHRoZSBkYXRhIGdyaWQgdGhhdCBzaG93cyB0YWJ1bGFyIGRhdGEuIEV2ZW4gdGhlIGJhc2ljXG4gKiBzdHJ1Y3R1cmUgaXMgYmFzZWQgb24gUHJpbWVORyBkYXRhdGFibGUgaXRzIGNvbXBsZXRlbHkgcmVmYWN0b3JlZCBpbnRvIHNtYWxsZXIgcGllY2VzIHRoYXRcbiAqIGFsbG93cyBtb3JlIGV4dGVuc2liaWxpdHkgYW5kIHRyeWluZyB0byBzdGF5IGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGV4aXN0aW5nIEFXTCBpbXBsZW1lbnRhdGlvblxuICpcbiAqIFRoZXJlIGFyZSAzIG1haW4gcGllY2VzOlxuICpcbiAqICBUYWJsZSBXcmFwcGVyIC0gZm9jdXNlcyBvbiB0aGUgb3V0ZXIgc3RydWN0dXJlLiBDb250YWluZXIgd2l0aCBiYXNpYyBkYXRhYmxlIGxheW91dCBwbHVzXG4gKiAgY29udGFpbnMgYW55IGFkZGl0aW9uYWwgcGFuZWxzIHRoYXQgZGF0YXRhYmxlIG5lZWRzIHN1Y2ggYXMgb3VyIG5ldyBjb25jZXB0IGhvdyBlZGl0aW5nIHdpbGxcbiAqICB3b3JrIC0gc2xpZGluZyBwYW5lbCBmcm9tIHRoZSBib3R0b21cbiAqXG4gKiAgRGF0YXRhYmxlIENvbHVtbiAtIEluc3RlYWQgb2YgcmVuZGVyaW5nIGV2ZXJ5dGhpbmcgaW5zaWRlIERUIEkgc3BsaXQgdGhlIHBhcnQgdGhhdCByZW5kZXJzXG4gKiAgY29sdW1uIGludG8gc2VwYXJhdGUgY29tcG9uZW50LiBUaGlzIHdheSBjb21wb25lbnQgY29sdW1uIGhhcyBpdHMgb3duIHJlbmRlcmVyIHRlbXBsYXRlIHdoaWNoXG4gKiAgY2FuIHJlbmRlciBib3RoIGhlYWRlciBhbmQgZGF0YSBjZWxscy5cbiAqICBMYXRlciBvbiBEVENvbHVtbiBpcyB0aGVuIGV4dGVuZGVkIHRvIHN1cHBvcnQgb3RoZXIgYWRkaXRpb25hbCBjb2x1bW4gdHlwZXNcbiAqICBTaW5nbGVTZWxlY3Rpb25Db2x1bW4sIE11bHRpU2VsZWN0aW9uQ29sdW1uLCBib3RoIHJlc3BvbnNpYmxlIGZvciByZW5kZXJpbmcgc2VsZWN0aW9uIGNvbnRyb2xzLlxuICpcbiAqIFRvIHN1cHBvcnQgcGl2b3RhbCBsYXlvdXQgdGhpcyBjYW4gYmUgZXh0ZW5kZWQgZm9yIG90aGVyIGFkZGl0aW9uYWwgY29sdW1ucyB0aGF0IGltcGxlbWVudHMgdGhlaXJcbiAqIG93biByZW5kZXJpbmcgdGVtcGxhdGVzXG4gKlxuICogRGF0YXRhYmxlIC0gVGhlIG1haW4gY29tcG9uZW50IHRoYXQgaXMgb25seSBmb2N1cyBvbiBoZWFkZXIgYW5kIGJvZHkgcmVuZGVyaW5nIGFuZCBiYXNhZWQgb24gdGhlXG4gKiBjb2x1bW4gdHlwZSBpdCB3aWxsIHJlbmRlciB0aGUgY29ycmVjdCB0ZW1wbGF0ZVxuICogY29sdW1uIHR5cGUgaXQgd2lsbCByZW5kZXIgdGhlIGNvcnJlY3QgdGVtcGxhdGVcbiAqXG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRhdGF0YWJsZTInLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFRoaXMgdGVtcGxhdGUgZm9jdXMgb25seSBvbiBoZWFkZXIgYW5kIGJvZHkgcmVuZGVyaW5nLlxuXG4gICAgVGhpcyBkYXRhdGFibGUgYWxzbyBzdXBwb3J0cyBmcm96ZW4gY29sdW1uIGFuZCBmb3IgdGhpcyByZW5kZXJpbmcgaXQgaXMgcHJldHR5IG11Y2ggdHJhbnNwYXJlbnRcbiAgICBhcyBpdCByZWNlaXZlZCBzZXRzIG9mIGNvbHVtbiB0aGF0IGl0IG5lZWRzIHRvIHJlbmRlciBmcm9tIHRoZSBUYWJsZVdyYXBwZXIuXG5cbiAgICBUYWJsZVdyYXBwZXIgaW4gY2FzZSBvZiBmcm96ZW4gY29sdW1ucyBjYWxscyAjaGVhZGVyUm93cyBhbmQgI2JvZHlSb3dzIHRlbXBsYXRlcyB0d2ljZSB0b1xuICAgIHJlbmRlciB0byBzZXBhcmF0ZSB0YWJsZXMgd2hlcmUgb25lIGhhcyBmcm96ZW4gY29sdW1ucyBhbmQgYW5vdGhlciBvbmUgaGFzIHRoZSByZXN0IGFuZCBpdHNcbiAgICBzY3JvbGxhYmxlXG4tLT5cblxuPGF3LWR0LXdyYXBwZXIgI2R0V3JhcHBlcj5cbiAgICA8bmctdGVtcGxhdGUgI2hlYWRpbmdBcmVhPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1kdC1oZWFkZXIyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgI2hlYWRlclJvd3MgbGV0LWNvbHNUb1JlbmRlciBsZXQtZnJvemVuVmlldz1cImZyb3plbkNvbHVtbnNcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXI7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sc1RvUmVuZGVyLCBmcm96ZW46ZnJvemVuVmlldyB9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgI2JvZHlSb3dzIGxldC1jb2xzVG9SZW5kZXI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc091dGxpbmUoKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keU91dGxpbmU7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sc1RvUmVuZGVyfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzT3V0bGluZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5UGxhaW47IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sc1RvUmVuZGVyfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L2F3LWR0LXdyYXBwZXI+XG5cblxuPCEtLVxuICAgIEVhY2ggcmVuZGVyaW5nIGNvbHVtbiBoYXMgaXRzIG93biByZW5kZXJUZW1wbGF0ZSB3aGljaCBkZWZpbmUgaG93IHRoaW5ncyBzaG91bGQgYmUgcmVuZGVyLlxuICAgIEJhc2VkIG9uIGRpZmZlcmVudCBjb2x1bW4gdHlwZXMgdGhpcyBjb2RlIHNob3VsZCBiZSB0cmFuc3BhcmVudCBhcyB3ZSBkb250IGNhcmUgb24gdGhpc1xuICAgIGxldmVsIHdoYXQga2luZCBvZiBjb2x1bW4gd2UgYXJlIHJlbmRlcmluZy5cblxuICAgIExhdGVyIG9uIHdoZW4gd2Ugd2lsbCBzdXBwb3J0IHNpbmdsZS9tdWx0aSBzZWxlY3Rpb24sIHRoaXMgd2lsbCBiZSBqdXN0IGFub3RoZXIgY29sdW1uIGV4dGVuZGluZ1xuICAgIERUQ29sdW1uIGFuZCBwcm92aWRpbmcgaXRzIG93biB0ZW1wbGF0ZVxuXG4gICAgV2UgcGFzcyBpbnRvIHRoaXMgdGVtcGxhdGUgaWYgd2UgYXJlIHJlbmRlcmluZyBoZWFkZXIsIHN1YkhlYWRlciwgb3IgZGF0YVxuLS0+XG48bmctdGVtcGxhdGUgI2hlYWRlciBsZXQtY29sc1RvUmVuZGVyIGxldC1mcm96ZW49XCJmcm96ZW5cIj5cbiAgICA8dHI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cImNvbHNUb1JlbmRlclwiIGxldC1sYXN0Q29sPVwibGFzdFwiXG4gICAgICAgICAgICAgICAgICAgICBsZXQtY29sdW1uSW5kZXg9XCJpbmRleFwiPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiB0cnVlLCBpc1N1YkhlYWRlcjpmYWxzZSxcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleDooZnJvemVuID8gY29sdW1uSW5kZXg6IChjb2x1bW5zLmxlbmd0aCArIGNvbHVtbkluZGV4KSl9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RyPlxuXG4gICAgPHRyICpuZ0lmPVwic2hvd1N1YkhlYWRlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWNvbCBbbmdGb3JPZl09XCJjb2xzVG9SZW5kZXJcIiBsZXQtbGFzdENvbD1cImxhc3RcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2wucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IHRydWUsIGlzU3ViSGVhZGVyOnRydWV9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2JvZHlQbGFpbiBsZXQtY29sc1RvUmVuZGVyPlxuXG4gICAgPHRib2R5IFtuZ0NsYXNzXT1cInsnZHQtY29udGVudCBkdC1kYXRhLWNlbGxzICc6IHRydWUsICdkdC1pcy1ob3ZlcmFibGUtcm93Jzogcm93SG92ZXJ9XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LXJvd0RhdGEgW25nRm9yT2ZdPVwiZGF0YVRvUmVuZGVyXCIgbGV0LWV2ZW49XCJldmVuXCIgbGV0LW9kZD1cIm9kZFwiXG4gICAgICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cImluZGV4XCIgW25nRm9yVHJhY2tCeV09XCJyb3dUcmFja0J5XCI+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd1RlbXBsYXRlOyBjb250ZXh0OnskaW1wbGljaXQ6IHJvd0RhdGEsIGV2ZW46ZXZlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9kZDpvZGQsIHJvd0luZGV4OnJvd0luZGV4LCBjb2xzVG9SZW5kZXI6Y29sc1RvUmVuZGVyfVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwic2hvd0RldGFpbENvbHVtbihyb3dEYXRhKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd0RldGFpbENvbHVtbi5yZW5kZXJlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IGZhbHNlLCBkYXRhOnJvd0RhdGEsIHJvd0luZGV4Oihyb3dJbmRleCl9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5vRGF0YVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvdGJvZHk+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjYm9keU91dGxpbmUgbGV0LWNvbHNUb1JlbmRlcj5cbiAgICA8dGJvZHkgI291dGxpbmVGb3IgYXdPdXRsaW5lRm9yIFtsaXN0XT1cImRhdGFUb1JlbmRlclwiXG4gICAgICAgICAgIFtjb250ZXh0XT1cImNvbnRleHRcIlxuICAgICAgICAgICBbaW5kZW50YXRpb25QZXJMZXZlbF09XCJpbmRlbnRhdGlvblBlckxldmVsXCJcbiAgICAgICAgICAgW3B1c2hSb290U2VjdGlvbk9uTmV3TGluZV09XCJwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmVcIlxuICAgICAgICAgICBbY2hpbGRyZW5dPVwiY2hpbGRyZW5cIiBbZXhwYW5kQWxsXT1cImV4cGFuZEFsbFwiXG4gICAgICAgICAgIFtzdGF0ZV09XCJvdXRsaW5lU3RhdGVcIlxuICAgICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWNvbnRlbnQgZHQtZGF0YS1jZWxscyAnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWhvdmVyYWJsZS1yb3cnOiByb3dIb3Zlcn1cIlxuICAgICAgICAgICAob25FeHBhbmRDaGFuZ2UpPVwib25PdXRsaW5lRXhwYW5kQ2hhbmdlKCRldmVudClcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtcm93RGF0YSBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInJvd1RlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IHJvd0RhdGEsIG5lc3RpbmdMZXZlbDpuZXN0aW5nTGV2ZWwsIGNvbHNUb1JlbmRlcjpjb2xzVG9SZW5kZXJ9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJzaG93RGV0YWlsQ29sdW1uKHJvd0RhdGEpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93RGV0YWlsQ29sdW1uLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogZmFsc2UsIGRhdGE6cm93RGF0YSwgcm93SW5kZXg6KHJvd0luZGV4KX1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9EYXRhXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC90Ym9keT5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS1cbiAgICBEZWZhdWx0IHRlbXBsYXRlIHRoYXQgaXMgZGlzcGxheSB3aGVuIHRoZXJlIGFyZSBubyBkYXRhXG4tLT5cbjxuZy10ZW1wbGF0ZSAjbm9EYXRhPlxuICAgIDx0ciAqbmdJZj1cImlzRW1wdHkoKVwiIGNsYXNzPVwiIGR0LWVtcHR5bWVzc2FnZS1yb3dcIlxuICAgICAgICBbc3R5bGUudmlzaWJpbGl0eV09XCJsb2FkaW5nID8gJ2hpZGRlbicgOiAndmlzaWJsZSdcIj5cblxuICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJ2aXNpYmxlQ29sdW1ucygpLmxlbmd0aFwiIGNsYXNzPVwiZHQtZW1wdHltZXNzYWdlXCI+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFlbXB0eU1lc3NhZ2VUZW1wbGF0ZVwiPnt7ZW1wdHlNZXNzYWdlfX08L3NwYW4+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZW1wdHlNZXNzYWdlVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC90ZD5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLVxuICAgIFRlbXBsYXRlIHRoYXQgcmVuZGVycyBhY3R1YWwgcm93LiBSZW5kZXJzIGJvdGggaGVhZGVyIGFuZCBib2R5IGNvbHVtbi4gRWFjaCByZW5kZXJlZFxuICAgIGNvbHVtbiBoYXMgaXRzIG93biB0ZW1wbGF0ZSBjYWxsZWQgcmVuZGVyZXJUZW1wbGF0ZSB0aGF0IGhhcyBhbGwgdGhpbmdzIHRoYXQgbmVlZHMgdG8gYmVcbiAgICByZW5kZXJlZCBhbmQgd2UganVzdCB0ZWxsIHRoZSB0ZW1wbGF0ZSBpZiB3ZSBhcmUgcmVuZGVyaW5nIGhlYWRlciwgc3ViaGVhZGVyIG9yIGJvZHlcbi0tPlxuPG5nLXRlbXBsYXRlICNyb3dUZW1wbGF0ZSBsZXQtcm93RGF0YSBsZXQtZXZlbj1cImV2ZW50XCIgbGV0LW9kZD1cIm9kZFwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCJcbiAgICAgICAgICAgICBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCIgbGV0LWNvbHNUb1JlbmRlcj1cImNvbHNUb1JlbmRlclwiPlxuXG5cbiAgICA8dHIgI3Jvd0VsZW1lbnQgZHREcmFnZ2FibGVSb3cgW2RuZFJvd0luZGV4XT1cInJvd0luZGV4XCJcbiAgICAgICAgY2xhc3M9XCJkdC1ib2R5LXJvd1wiXG4gICAgICAgIChjbGljayk9XCJvbkhhbmRsZVJvd0NsaWNrZWQoJGV2ZW50LCByb3dEYXRhKVwiXG4gICAgICAgIFthdHRyLm5lc3RpbmdMZXZlbF09XCJuZXN0aW5nTGV2ZWxcIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWV2ZW4tcm93JzogZXZlbiwgJ2R0LW9kZC1yb3cnOiBvZGQsXG4gICAgICAgICAgICAnZHQtcm93LXNlbGVjdGVkJzogaXNSb3dTZWxlY3RlZChyb3dEYXRhKSxcbiAgICAgICAgICAgICdkdC1yb3ctZHJhZ2dhYmxlJzogZG5kUm93RW5hYmxlZCxcbiAgICAgICAgICAgICdkdC1yb290LXNlY3Rpb24nOiBuZXN0aW5nTGV2ZWwgPT09IDAgfVwiPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cImNvbHNUb1JlbmRlclwiIGxldC1jb2xJbmRleD1cImluZGV4XCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29sLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogZmFsc2UsIGRhdGE6cm93RGF0YSwgcm93SW5kZXg6cm93SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIG5lc3RpbmdMZXZlbDpuZXN0aW5nTGV2ZWx9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG5gLFxuICAgIHN0eWxlczogW2Audy1kYXRhdGFibGV7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3h9LnctZGF0YXRhYmxlIHRhYmxle2JvcmRlci1jb2xsYXBzZTpjb2xsYXBzZTt3aWR0aDoxMDAlO3RhYmxlLWxheW91dDpmaXhlZH0udy1kYXRhdGFibGUgdGJvZHksLnctZGF0YXRhYmxlIHRkLC53LWRhdGF0YWJsZSB0aHtvdXRsaW5lOjB9LmR0LWNlbGwtZGVmLC5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2JvcmRlcjoxcHggc29saWQgdHJhbnNwYXJlbnQ7cGFkZGluZzoxN3B4IDE2cHg7Ym94LXNpemluZzpib3JkZXItYm94fS5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2N1cnNvcjpwb2ludGVyO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9dGggLmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7Ym9yZGVyLXdpZHRoOjRweCAxcHggMXB4O3BhZGRpbmc6MTRweCAxNnB4IDE3cHh9dGQgLmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7Ym9yZGVyLXdpZHRoOjAgMXB4IDAgNXB4O3BhZGRpbmc6MTdweCAxNnB4IDE3cHggMTNweH0uZHQtZGF0YS1jZWxscyB0ci5kdC1pcy1oaWdobGlnaHQsLmR0LWRhdGEtY2VsbHMgdHIuZHQtaXMtaG92ZXJ7Ym9yZGVyLWNvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdDtjdXJzb3I6cG9pbnRlcn0udy1kYXRhdGFibGUtcnRse2RpcmVjdGlvbjpydGx9LnctZGF0YXRhYmxlLXJ0bC53LWRhdGF0YWJsZS1ydGwudy1kYXRhdGFibGUgdGhlYWQgdGh7dGV4dC1hbGlnbjpyaWdodH0uZHQtcm9vdC1zZWN0aW9uIC5kdC1jZWxsLWRlZiwuZHQtcm9vdC1zZWN0aW9uIC5kdC1jZWxsLWRlZi1zZWxlY3RhYmxle2JhY2tncm91bmQtY29sb3I6I2YzZjZmODtwYWRkaW5nOjEwcHggMTZweDtib3JkZXItYm90dG9tLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH0uZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1hY3RpdmUsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtZGVmYXVsdCwuZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1oaWdobGlnaHQsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtaG92ZXIsLmR0LXBsYWluLWxheW91dCAuZHQtaXMtaG92ZXJhYmxlLXJvd3tib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmR0LWlzLWFjdGl2ZSwuZHQtaXMtZGVmYXVsdCwuZHQtaXMtaGlnaGxpZ2h0LC5kdC1pcy1ob3ZlciwuZHQtaXMtaG92ZXJhYmxlLXJvd3tib3JkZXI6MXB4IHNvbGlkICNkN2Q3ZDc7YmFja2dyb3VuZC1jb2xvcjojZmZmO2NvbG9yOiMzNjM2MzZ9LmR0LXJvdy1zZWxlY3RlZCB0ZHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjM4LDI1NSwyMzgsLjcxKX0uZHQtaXMtYWN0aXZle2JvcmRlci1jb2xvcjojMDY1ZDljO2NvbG9yOiMxOTlkZTB9LmR0LWlzLWhpZ2hsaWdodHtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNjUsMTE3LDUsLjE4KX0uZHQtaXMtaGlkZGVue2Rpc3BsYXk6bm9uZX0uZHQtdS11bnNlbGVjdGFibGUtdGV4dHstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1vLXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uZHQtdS1zb3J0YWJsZXtjdXJzb3I6cG9pbnRlcn1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgT2JqZWN0VXRpbHMsXG4gICAgICAgIE91dGxpbmVTdGF0ZSxcbiAgICAgICAge3Byb3ZpZGU6IERBVEFfU09VUkNFLCB1c2VDbGFzczogRFQyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX0sXG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG5cbn0pXG5leHBvcnQgY2xhc3MgRGF0YXRhYmxlMkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBV0RhdGFUYWJsZSwgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LCBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIC8qKlxuICAgICAqICBMaXN0IG9mIGl0ZW1zIHRvIHNob3cgaW4gdGhlIGRhdGF0YWJsZS5cbiAgICAgKlxuICAgICAqICB0b2RvOiBpbXBsZW1lbnQgdGhlIHNhbWUgRGF0YXNvdXJjZSBhbmQgbGF6eSBsb2FkaW5nIGp1c3QgbGlrZSBJIGRpZCBpdCBmb3IgZGF0YXRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGVudGl0eSBmb3Igd2hpY2ggRGF0YVByb3ZpZGVyIHdpbGwgYmUgbG9hZGVkLiBZb3UgY2FuIGVpdGhlciBwYXNzIGxpc3Qgb2YgaXRlbXNcbiAgICAgKiBvciB1c2UgdGhpcyBkZXN0aW5hdGlvbkNsYXNzLiBOb3QgYm90aFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGVzdGluYXRpb25DbGFzczogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IFRhYmxlV3JhcHBlciB0byBhZGQgdXNlciBkZWZpbmVkIGNsYXMgaW50byB0aGUgdGFibGUgdGFnXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhYmxlU3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHlDbGFzc0ZuOiAoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSkgPT4gc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzUm93U2VsZWN0YWJsZTogKGl0ZW06IGFueSkgPT4gYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogIEhpZGVzIG9yIHNob3dzIHRhYmxlIGhlYWRpbmcgd2hlcmUgd2UgaGF2ZSBmaWx0ZXJzIGFuZCB0b29scyBtZW51c1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1RhYmxlSGVhZGVyOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBpdm90YWxMYXlvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb250ZXh0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluaXRpYWxTb3J0T3JkZXI6IHN0cmluZyA9ICdkZXNjZW5kaW5nJztcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5pdGlhbFNvcnRLZXk6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBEVCBpcyBsb2FkZWQgaW4gdGhlIHBhZ2UgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZ1bGwgc2NyZWVuIChmdWxsIHBhZ2UgbW9kZSksIHRoaXNcbiAgICAgKiBpcyBodGUgbnVtYmVyIG9mIGxpbmVzIHRoYXQgRFQgd2lsbCBzaG93XG4gICAgICpcbiAgICAgKiB0b2RvOiBjb21lIHVwIHdpdGggYmV0dGVyIG5hbWVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc3BsYXlSb3dTaXplOiBudW1iZXIgPSAxMDtcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgcGFnaW5nIG9uIGxhenkgbG9hZGluZyB1c2luZyBpbmZpbml0ZSBzY3JvbGxlciB0byBzZXQgaW5pdGlhbCBmZXRjaCBsaW1pdCBzaXplXG4gICAgICpcbiAgICAgKiB0b2RvOiBjb21lIHVwIHdpdGggYmV0dGVyIG5hbWUgISEhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhZ2VTaXplOiBudW1iZXIgPSAxNTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkYXRhU291cmNlOiBEVDJEYXRhU291cmNlO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBtZXNzYWdlIHdoZW4gdGhlcmUgYXJlIG5vIGRhdGEgLlxuICAgICAqXG4gICAgICogdG9kbzogVXNlIGkxOG4gdmFsdWUgYW5kIGNyZWF0ZSByZXNvdXJjZSBmaWxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlbXB0eU1lc3NhZ2U6IHN0cmluZyA9ICdObyByZWNvcmRzIGZvdW5kJztcblxuXG4gICAgLyoqXG4gICAgICogRGV2ZWxvcGVyIGNhbiBwcm92aWRlIGN1c3RvbSB0cmFja0J5IGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGl0ZXJhdGUgb3ZlciB0aGVcbiAgICAgKiByZWNvcmRzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb3dUcmFja0J5OiAoaW5kZXg6IG51bWJlciwgaXRlbTogYW55KSA9PiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRydWUgYWRkcyBjdXN0b20gaG92ZXJpbmcgY2xhc3MgdG8gdGhlIHRib2R5XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByb3dIb3ZlcjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIERvIHdlIHNob3cgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgKlxuICAgICAqIFRvZG86IHJlbmFtZSB0byBzaG93TG9hZGluZ1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbG9hZGluZzogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uTW9kZTogU2VsZWN0aW9uTW9kZSA9ICdub25lJztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FuIHByb3ZpZGUgY3VzdG9tIGljb24uIFRoZXNlIGljb25zIGFyZSBub3QgYW5pbWF0ZWQgZGl2cywgd2UgdXNlZCBjc3NcbiAgICAgKiB0cmFuc2Zvcm1hdGlvbiB0byByb3RhdGUgdGhlbS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbG9hZGluZ0ljb246IHN0cmluZyA9ICdpY29uLXN5bmNocm9uaXplJztcblxuXG4gICAgLyoqXG4gICAgICogQWRkaXRpb25hbCBpbmRlbnQgY2FuIGJlIGFkZGVkIHdoZW4gcmVuZGVyaW5nIGRldGFpbCByb3dcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluZGVudERldGFpbFJvdzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGluZGVudGF0aW9uUGVyTGV2ZWw6IG51bWJlciA9IDI1O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiAgU3ViSGVhZGVyIGlzIHVzZWQgdG8gc2hvdyBzdW1tYXJ5IGNvbHVtbnMsIHdoaWNoIGluIG91ciBVWCBpcyBzaG93biBhdCB0aGUgdG9wIGp1c3QgdW5kZXJcbiAgICAgKiAgdGhlIHJlZ3VsYXIgdGFibGUgaGVhZGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNoaWxkcmVuOiAodmFsdWU6IGFueSkgPT4gYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFdlIG1pZ2h0IGhhdmUgdGhpcyBjb25kaXRpb25hbCBhcyB0aGlzIGNhbiBiZSBkeW5hbWljIGJhc2VkIG9uIHZhbHVlLCBzbyB0aGUgc2FtZVxuICAgICAqIGFzIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBTZWUgT3V0bGluZUZvciAtIG9ubHkgdXNlZCBpbiB0aGUgdHJlZSBtb2RlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93RXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZEFsbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXIgb3IgaGlkZSBleHBhbnNpb24gY29udHJvbCBmb3Igcm93IGRldGFpbCBjb2x1bW5zLiBFeHBhbnNpb24gY29udHJvbCBtYWtlcyBzZW5zZSBmb3JcbiAgICAgKiBzaW1wbGUgdGFibGUsIHdoZW4gdXNpbmcgdGhpcyBpbnNpZGUgb3V0bGluZSAodHJlZSB0YWJsZSksIGl0cyBkcml2ZW4gYnkgb3V0bGluZSBjb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Um93RGV0YWlsRXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1NlbGVjdGlvbkNvbHVtbjogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U2VsZWN0QWxsOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2hvdyBvciBoaWRlIGdsb2JhbCBzZWFyY2ggdGVybSBpbnB1dCBmaWVsZCBpbiB0aGUgaGVhZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93R2xvYmFsU2VhcmNoOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBmcm96ZW4gY29sdW1uIGFyZSB1c2luZyB3ZSBjYW4gc3BlY2lmeSBvbiBnbG9iYWwgbGV2ZWwgdG90YWwgd2lkdGggb2YgdGhlIHRhYmxlIHRoZVxuICAgICAqIG92ZXJmbG93aW5nIGNvbnRlbnQgb3Igd2lkdGggZm9yIGVhY2ggY29sdW1uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2Nyb2xsV2lkdGg6IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlcyByb3cgcmVvcmRlcmluZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkbmRSb3dFbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVzIGV2ZW50IHRoYXQgc29ydGluZyBpcyBlbmFibGVkIGZvciBjb2x1bW4gYW5kIHdlIHRyaWdnZXIgc29ydGluZ1xuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Tb3J0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gc2VsZWN0aW9uIG1vZGUgaXQgdHJpZ2dlcnMgZXZlblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Sb3dDbGljazogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gbXVsdGkgb3Igc2luZ2xlIHNlbGVjdGlvbiBtb2RlIGlzIGVuYWJsZWQgaXQgd2lsbCB0cmlnZ2VyIGV2ZW50IHdoZW4gY2hlY2tib3ggb3JcbiAgICAgKiByYWRpbyBidXR0b25zIGlzIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiB0b2RvOiBpbXBsZW1lbnQgU2luZ2xlU2VsZWN0aW9uRFRDb2x1bW4sIE11bHRpU2VsZWN0aW9uRFRDb2x1bW4gd2l0aCB0aGVpciByZW5kZXJlcnNcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblJvd1NlbGVjdGlvbkNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2VsbCBib2R5IHNlbGVjdGlvbiBjaGFuZ2VzIHdlIGZpcmUgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2VsbENoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNlbGwgaGVhZGVyIHNlbGVjdGlvbiBjaGFuZ2VzIHdlIGZpcmUgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uSGVhZGVyU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgQENvbnRlbnRDaGlsZChEVEhlYWRlckNvbXBvbmVudDIpXG4gICAgaGVhZGVyOiBEVEhlYWRlckNvbXBvbmVudDI7XG5cblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tIHRlbXBsYXRlIHRoYXQgY2FuIGJlIGltcGxlbWVudGVkIGJ5IGFwcGxpY2F0aW9uIHRvIHNob3cgd2hlbiB0aGVyZSBhcmVcbiAgICAgKiBubyBkYXRhIGluIHRoZSBkYXRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbm9EYXRhVGVtcGwnKVxuICAgIGVtcHR5TWVzc2FnZVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdEhlYWRlcicpXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdFN1YkhlYWRlcicpXG4gICAgc3ViSGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdkdEJvZHknKVxuICAgIGJvZHlUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyRmlsdGVyJylcbiAgICBoZWFkZXJGaWx0ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdHMgdXNlZCBEVENvbHVtbiBpbnNpZGUgZGF0YXRhYmxlIGFuZCB0aGVuIHRoZXkgYXJlIHVzZWQgaW5zaWRlIHRoZSB0ZW1wbGF0ZSB0b1xuICAgICAqIGl0ZXJhdGUgb3ZlciBhbmQgdXNlIGl0cyByZW5kZXJlclRlbXBsYXRlLlxuICAgICAqXG4gICAgICogV2hlbiB3ZSB3aWxsIGJlIGRlZmluaW5nIG5ldyBjb2x1bW5zIGl0cyBpbXBvcnRhbnQgdGhhdCBpdCBjYW4gYWxzbyBtYXRjaCBhbGwgdGhlXG4gICAgICogaW5oZXJpdGVkIG9uZXMuIHNvIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGRlZmluZSBhIHByb3ZpZGVyIHRob3NlIHRob3NlIGNvbHVtbnMgdG8gcG9pbnRcbiAgICAgKiB0byB0aGUgRFRDb2x1bW5Db21wb25lbnRcbiAgICAgKlxuICAgICAqIGUuZy46XG4gICAgICpcbiAgICAgKiB7cHJvdmlkZTogRFRDb2x1bW5Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERldGFpbFJvd0NvbHVtbil9XG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKERUQ29sdW1uMkNvbXBvbmVudClcbiAgICBjb2xzUXVlcnk6IFF1ZXJ5TGlzdDxEVENvbHVtbjJDb21wb25lbnQ+O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKERURGV0YWlsUm93Q29tcG9uZW50KVxuICAgIHJvd0RldGFpbENvbHVtbjogRFREZXRhaWxSb3dDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgd2hlbiBpdGVtcyBpbiB0aGUgbGlzdCBhcmUgdXBkYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgICBjbGFzc0xpc3Q6IHN0cmluZyA9ICd3LWRhdGF0YWJsZSAnO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3IgaW50ZXJuYWwgdXNlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGRhdGFzZXQgdGhhdCBpcyBiZWluZyByZW5kZXJlZC4gU2V0IGZyb20gdGhlIFtsaXN0XSBiaW5kaW5nIG9yIGJ5IGxhenkgbG9hZCBmcm9tXG4gICAgICogZGF0YXNvdXJjZVxuICAgICAqL1xuICAgIHB1YmxpYyBkYXRhVG9SZW5kZXI6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogV2UgY29udmVydCBRdWVyeUxpc3Q8RFRDb2x1bW4yQ29tcG9uZW50PiB0byB0aGlzIGFycmF5IGZvciBlYXNpZXIgbWFuaXB1bGF0aW9uXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbnM6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHNlY29uZGFyeSBsaXN0IG9mIGNvbHVtbnMgd2hpY2ggaXMgdXNlZCBpbiBjYXNlIHdlIGhhdmUgaGF2ZSBlbmFibGVkXG4gICAgICogZnJvemVuIGNvbHVtbnMuIENvbHVtbnMgdGhhdCBhcmUgbWFya2VkIGFzIGZyb3plbiBuZWVkcyB0byBiZSBwbGFjZWQgaW50byBzZXBhcmF0ZSBhcnJheVxuICAgICAqIHRvIGJlIHJlbmRlcmVkIHdheSB0aGFuIHJlZ3VsYXIgY29sdW1ucyB3aGljaCBhcmUgc3RvcmVkIGluIHRoZSBjb2x1bW5zIGFycmF5LlxuICAgICAqL1xuICAgIHB1YmxpYyBmcm96ZW5Db2x1bW5zOiBEVENvbHVtbjJDb21wb25lbnRbXTtcblxuXG4gICAgLyoqXG4gICAgICogIEluZGljYXRlcyB0aGF0IGNvbHVtbnMgd2VyZSBpbml0aWFsZWQgQWxzbyB1c2VkIHdoZW4gd2UgaGlkZSBhbmQgc2hvdyBjb2x1bW4gdG8gdHJpZ2dlclxuICAgICAqICBjaGFuZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uc0NoYW5nZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgcHVibGljIHNvcnRDb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIGNvbHNRdWVyeSBhbmQgaXRzIGNoYW5nZXMgc28gd2UgY2FuIGxhdGVyIG9uIHJlbGVhc2UgdGhlIHN1YnNjcmlwdGlvblxuICAgICAqL1xuICAgIGNvbHVtbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBpbml0aWFsaXplZDogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgZGV0YWlsUm93RXhwYW5zaW9uU3RhdGU6IERldGFpbFJvd0V4cGFuc2lvblN0YXRlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBudW1iZXJPZkNvbHNCZWZvcmVEYXRhOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBzdGFydE9mRmlyc3REYXRhQ29sdW1uOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWN0aW9uIGZvciBwcm9ncmFtbWF0aWNhbGx5IGluc3RhbnRpYXRlZCBjb2x1bW5zIHRoYXQgYXJlIGFkZGVkIHRvIHRoZSBsaXN0IGlmIGFkZGl0aW9uYWxcbiAgICAgKiBzcGFuIG9yIGxvZ2ljIGlzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRvIHByb2dyYW1tYXRpY2FsbHkgaW5zZXJ0IGEgbmV3IGNvbHVtbiBpbnRvIGNvbHVtbnMgYXJyYXkgbGlrZSBleHBhbmRvIGNvbHVtbiBmb3IgZGV0YWlsXG4gICAgICogcm93LCBvciBTaW5nbGVTZWxlY3QsIE11bHRpU2VsZWN0IGNvbHVtbiB3aGVuIHNlbGVjdGlvbiBpcyBlbmFibGVkIHdlIG5lZWQgdG8gdXNlXG4gICAgICogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGluc3RhbnRpYXRlIGEgbmV3IGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgcm93RGV0YWlsRXhwYW5kQ29sdW1uOiBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50O1xuICAgIHByaXZhdGUgbXVsdGlTZWxlY3RDb2x1bW46IERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQ7XG4gICAgcHJpdmF0ZSBzaW5nbGVTZWxlY3RDb2x1bW46IERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEluIGNhc2Ugb2Ygb3V0bGluZSB0YWJsZSB3ZSBhcmUgaW5qZWN0IE91dGxpbmVTdGF0ZSB3aGljaCBpcyBwcm92aWRlZCBpbiB0aGUgRFQgY29tcG9uZW50XG4gICAgICogZGVmaW5pdGlvbi4gVGhpcyBpcyB1c2VkIGJ5IG5lc3RlZCBvdXRsaW5lRm9yIGNvbXBvbmVudCBpdCBzZXQgaXRzZWxmIGFzIHJlZmVyZW5jZSBhbmRcbiAgICAgKiBpbml0aWFsaXplIHRoZSBzdGF0ZSBzbyBpdCBjYW4gYmUgdXNlZCBsYXRlciBvbiBpbnNpZGUgT3V0bGluZUNvbnRyb2xcbiAgICAgKlxuICAgICAqXG4gICAgICogRWFjaCBEYXRhdGFibGUgaXMgcHJlLWRlZmF1bHRlZCB3aXRoIGl0cyBvd24gdmVyc2lvbiBvZiBEYXRhU291cmNlIHNvIGFsbCB0aGUgb2JzZXJ2ZXJzXG4gICAgICogaW5zaWRlIGFyZSB1bmlxdWUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoREFUQV9TT1VSQ0UpIHByaXZhdGUgX2RlZmF1bHREUzogRFQyRGF0YVNvdXJjZSxcbiAgICAgICAgICAgICAgICBwdWJsaWMgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBmYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwdWJsaWMgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGUsXG4gICAgICAgICAgICAgICAgcHVibGljIHpvbmU6IE5nWm9uZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IHRoaXMuX2RlZmF1bHREUztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCB1c2UgYm90aCBiaW5kaW5ncyBbbGlzdF0gYW5kIFtkZXN0aW5hdGlvbkNsYXNzXSEnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlID0gbmV3IERldGFpbFJvd0V4cGFuc2lvblN0YXRlKHRoaXMpO1xuXG4gICAgICAgIC8vIGluaXQgZGVmYXVsdCBjb2x1bW5zXG4gICAgICAgIHRoaXMucm93RGV0YWlsRXhwYW5kQ29sdW1uID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50KS5jcmVhdGUodGhpcy5pbmplY3RvcikuaW5zdGFuY2U7XG5cblxuICAgICAgICB0aGlzLm11bHRpU2VsZWN0Q29sdW1uID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50KS5jcmVhdGUodGhpcy5pbmplY3RvcikuaW5zdGFuY2U7XG5cbiAgICAgICAgdGhpcy5zaW5nbGVTZWxlY3RDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50KS5jcmVhdGUodGhpcy5pbmplY3RvcikuaW5zdGFuY2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBkYXRhIGFyZSBub3QgZGVmZXJyZWQgYW5kIHdlIGdldCBsaXN0IGRpcmVjdGx5IHRoZW4gaXQgY3JlYXRlcyBEUy4gSWZcbiAgICAgICAgICogbmdPbkNoYW5nZXMgaXMgY2FsbGVkIGZpcnN0IHdlIHByb3Blcmx5IGluaXQgRFMgYW5kIGNsZWFuIHRoaXMubGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpIHx8IGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2luY2Ugd2Ugd29yayB3aXRoIHJlZmVyZW5jZXMgbGV0J3MgcGFzcyBjcmVhdGVkIG1hcCBpbnNpZGUgb3VyIHN0YXRlXG4gICAgICAgIHRoaXMub3V0bGluZVN0YXRlLmV4cGFuc2lvblN0YXRlcyA9IHRoaXMuc3RhdGUub3V0bGluZVN0YXRlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkYXRhIGFycml2ZXMgbGF0ZXIgbWF5YmUgZHVlIHRvIFJFU1QgQVBJIGxhdGVuY3ksIGluaXRpYWxpemUgRFMgb25seSB3aGVuIHdlIGhhdmUgYVxuICAgICAqIGRhdGEsIG90aGVyd2lzZSBpZiBkYXRhIGNoYW5nZWQgdGhydSB0aGUgYmluZGluZ3MganVzdCB0cmlnZ2VyIGRhdGFDaGFuZ2UgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdPbkNoYW5nZXMoY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGNoYW5nZXNbJ2xpc3QnXSAmJiBpc1ByZXNlbnQoY2hhbmdlc1snbGlzdCddLmN1cnJlbnRWYWx1ZSlcbiAgICAgICAgICAgICYmICF0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpIHtcblxuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZSgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhU291cmNlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQodGhpcy5saXN0KTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBpbml0IGEgc3RhdGUgd2hlbiBkZXRhaWwgY29sdW1uIGlzIHByZXNlbnRcbiAgICAgICAgLy8gdG9kbzogbW92ZSB0aGlzIGluaXRpYWxpemF0aW9uIHRvIGRhdGFzb3VyY2VcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkID0gaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKTtcblxuICAgICAgICB0aGlzLmluaXRDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbiA9IHRoaXMuY29sc1F1ZXJ5LmNoYW5nZXMuc3Vic2NyaWJlKF8gPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0Q29sdW1ucygpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICAvLyBhc3NpZ24gaXQgcHJvZ3JhbWF0aWNhbGx5IGFzIHdlIHdhbnQgdG8gaGF2ZSBhIGNvbnRleHQgZm9yIHRoZSBmaWx0ZXJcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiYgaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmZpbHRlck91dCA9IHRoaXMuc2tpcE91dGxpbmVJdGVtLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmNoYW5nZURldGVjdG9yLmRldGFjaCgpO1xuICAgICAgICAgICAgLy8gdGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvci5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbnNDaGFuZ2VkICYmIHRoaXMuZWwubmF0aXZlRWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICAgICAgICAgIGNvbC5wb3N0SW5pdGlhbGl6ZShpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICAgICAgICAgIGNvbC5wb3N0SW5pdGlhbGl6ZShpbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5IGVudHJ5IG1ldGhvZCB0aGF0IGluaXRpYWxpemVkIG91ciBjb2x1bW5zLiBMYXRlciBvbiB3aGVuIHdlIHdpbGwgc3VwcG9ydCBzZWxlY3Rpb24gYW5kXG4gICAgICogbXVsdGlzZWxlY3Rpb24gd2Ugd2lsbCBwcm9ncmFtbWF0aWNhbGx5IGluc3RhbnRpYXRlIFNpbmdsZVNlbGVjdGlvbiwgTXVsdGlTZWxlY3Rpb24gY29sdW1uXG4gICAgICogY29tcG9uZW50cyBhbmQgYWRkIHRoZW0gdG8gdGhlIGxpc3Qgc28gdGhleSBjYW4gYmUgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBzbyB0aGUgaWRlYSBoZXJlIGlzOlxuICAgICAqXG4gICAgICogV2hlbiBEVCBjb21wb25lbnQgaW5pdGlhbGl6ZSBhbmQgd2UgYXJlIGluIGVkaXRpbmcgbW9kZSBhbmQgd2Ugc3VwcG9ydCBTaW5nbGUvTXVsdGkgc2VsZWN0aW9uXG4gICAgICogd2Ugd2lsbCB1c2UgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGNyZWF0ZSBjb21wb25lbnQgYW5kIGFkZCBpdCBhcyBmaXJzdCBpdGVtIHRvIHRoZSBsaXN0XG4gICAgICogYW5kIHRoZW4gaXQgd2lsbCBiZSByZW5kZXJlZCBqdXN0IGxpa2UgYW55dGhpZ24gZWxzZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRDb2x1bW5zKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zID0gW107XG5cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGV0YWlsQ29sdW1uRXhwYW5zaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmIHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2godGhpcy5tdWx0aVNlbGVjdENvbHVtbik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLnB1c2godGhpcy5zaW5nbGVTZWxlY3RDb2x1bW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBleHBhbnNpb24gY29sdW1uIHdoZW4gZGV0YWlsIHJvdyBpcyBlbmFibGVkXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkICYmICF0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLnJvd0RldGFpbEV4cGFuZENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbHNRdWVyeVxuICAgICAgICAgICAgLmZpbHRlcigoY29sMTogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiAhY29sMS5mcm96ZW4pXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb2wuaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChjb2wpO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICB0aGlzLmluaXRGcm96ZW5Db2x1bW5zKCk7XG4gICAgICAgIHRoaXMuaW5pdENvbHVtbkluZm8oKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoYXQgd2UgYWxzbyBpbmNsdWRlIHByb2dyYW1tYXRpYyBjb2x1bW4gaWYgcHJlc2VudC4gTW92ZSB0aGVtIHRvIHRoZSBjb3JyZWN0XG4gICAgICogYXJyYXlcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdEZyb3plbkNvbHVtbnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29sc1F1ZXJ5XG4gICAgICAgICAgICAuZmlsdGVyKChjb2wxOiBEVENvbHVtbjJDb21wb25lbnQpID0+IGNvbDEuZnJvemVuKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29sLmluaXRpYWxpemUodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zLnB1c2goY29sKTtcblxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZnJvemVuQ29sdW1ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBmaW5kIGxhc3QgaW5kZXggb2YgY29sdW1uIHRoYXQgaXMgaW50ZXJuYWwgLyBwcm9ncmFtbWF0aWNcblxuICAgICAgICAgICAgbGV0IGxhc3RJbnggPSB0aGlzLmNvbHVtbnMuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICAuZmluZEluZGV4KChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gdGhpcy5pc0ludGVybmFsQ29sdW1uKGNvbCkpO1xuXG4gICAgICAgICAgICBpZiAobGFzdElueCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5jb2x1bW5zLmxlbmd0aCAtIDEgLSBsYXN0SW54O1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcm5hbENvbHMgPSB0aGlzLmNvbHVtbnMuc3BsaWNlKDAsIGlkeCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvemVuQ29sdW1ucyA9IFsuLi5pbnRlcm5hbENvbHMsIC4uLnRoaXMuZnJvemVuQ29sdW1uc107XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGhhc1ZhbGlkQ29scyA9IHRoaXMuY29sdW1uc1xuICAgICAgICAgICAgICAgIC5maW5kSW5kZXgoKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiBpc0JsYW5rKGNvbC53aWR0aCkpID09PSAtMTtcblxuICAgICAgICAgICAgYXNzZXJ0KGhhc1ZhbGlkQ29scyB8fCBpc1ByZXNlbnQodGhpcy5zY3JvbGxXaWR0aCksXG4gICAgICAgICAgICAgICAgJ1doZW4gdXNpbmcgW2Zyb3plbl0gYmluZGluZyB5b3UgbmVlZCBzcGVjaWZ5IFt3aWR0aF0gZm9yIGVhY2ggJyArXG4gICAgICAgICAgICAgICAgJ2NvbHVtbiBvciBbc2Nyb2xsV2lkdGhdIG9uIGRhdGF0YWJsZSEnKTtcblxuXG4gICAgICAgICAgICBhc3NlcnQoaXNCbGFuayh0aGlzLnJvd0RldGFpbENvbHVtbiksXG4gICAgICAgICAgICAgICAgJ1lvdSBjYW5ub3QgY29tYmluZSBhdy1kdC1kZXRhaWwtY29sdW1uIHdpdGggZnJvemVuIGNvbHVtbnMhJyk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGN1cnJlbnQgY29sdW1uIGlzIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZFxuICAgICAqXG4gICAgICovXG4gICAgaXNJbnRlcm5hbENvbHVtbihjb2w6IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gY29sIGluc3RhbmNlb2YgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQgfHxcbiAgICAgICAgICAgIGNvbCBpbnN0YW5jZW9mIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQgfHxcbiAgICAgICAgICAgIGNvbCBpbnN0YW5jZW9mIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQ7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgbmV3IERhdGFzb3VyY2UgYmFzZWQgb24gcGFzc2VkIHZhbHVlcy4gSXQgdHJpZXMgdG8gaW5pdGlhbGl6ZSBEUyBmb3IgZmlyc3QgdGltZVxuICAgICAqIGluc2lkZSB0aGUgbmdJbml0IGJ1dCBpbiBjYXNlIERhdGEgYXJyaXZlcyBsYXRlciBtYXliZSBkdWUgdG8gc29tZSBSRVNUIEFQSSBjYWxscyB0aGlzXG4gICAgICogY2FuIGJlIHRyaWdnZXJlZCBhbHNvIGZyb20gbmdPbkNoYW5nZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0RGF0YXNvdXJjZShpbml0aWFsaXplOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IERhdGF0YWJsZTJTdGF0ZS5jcmVhdGUoMCwgdGhpcy5wYWdlU2l6ZSwgdGhpcy5kaXNwbGF5Um93U2l6ZSxcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxTb3J0S2V5LCB0aGlzLnNvcnRPcmRlcmluZ0ZvclN0cmluZyh0aGlzLmluaXRpYWxTb3J0T3JkZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubGltaXQgPSB0aGlzLnN0YXRlLmRpc3BsYXlMaW1pdCA9IHRoaXMuZGlzcGxheVJvd1NpemU7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaW5pdGlhbFNvcnRLZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zb3J0S2V5ID0gdGhpcy5pbml0aWFsU29ydEtleTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnRPcmRlciA9IHRoaXMuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuaW5pdGlhbFNvcnRPcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICAgICAgICAgICAgICAgIG9iajogaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykgPyB0aGlzLmRlc3RpbmF0aW9uQ2xhc3MgOiB0aGlzLmxpc3QsXG4gICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IGZhbHNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZmV0Y2godGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgLy8gcmVzZXQgbGlzdCB0byBtYWtlIHN1cmUgaXQgY29tZXMgZnJvbSBEYXRhUHJvdmlkZXIsIHdlIHVzZSBsaXN0ICB0byBpbml0aWFsaXplXG4gICAgICAgIHRoaXMubGlzdCA9IG51bGw7XG5cbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgRU5UUlkgcG9pbnQgZm9yIHRoZSBEQVRBIENIQU5HRVMuIEFsbCBhZGRpdGlvbiwgZWRpdHMsIGRlbGV0aW9uIGVuZHMgdXBcbiAgICAgICAgLy8gaGVyZS4gV2UgZG9udCB3b3JrIGRpcmVjdGx5IHdpdGggTElTVC4gQW55IGNoYW5nZSBpcyByZWFjdGl2ZSBhbmQgaGVyZSBpcyBsaXN0ZW5lclxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uub3BlbigpLnN1YnNjcmliZSgoZGF0YTogYW55W10pID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTGlzdChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBkZXRhaWxSb3cgY29sdW1uIGlzIHByZXNlbnQgd2UgaW5pdGlhbGl6ZSBhIHN0YXRlIGhvbGRpbmcgaW5mb3JtYXRpb24gd2hpY2ggaXRlbSBpc1xuICAgICAqIGV4cGFuZGVkLlxuICAgICAqXG4gICAgICogdG9kbzogVGhpcyBpcyB0ZW1wb3JhcnkgaGVyZSBhbmQgb25jZSB3ZSBzdXBvcnQgbGF6eSBsb2FkaW5nIG1vdmUgdGhpcyB0byBkYXRhc291cmNlLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUgZm9yIG91dGxpbmUgdHJlZSB0YWJsZSB3ZSBuZWVkIHRvIGNvbm5lY3QgYSBzdGF0ZSBmcm9tIG91dGxpbmUgd2l0aCBhIHN0YXRlIGluXG4gICAgICogaGVyZSBhcyB3ZSBhcmUgdXNpbmcgb3V0bGluZSBjb250cm9sIHRvIGV4cGFuZCBhbmQgY29sbGFwc2UgaXRlbXNcbiAgICAgKi9cbiAgICBpbml0RGV0YWlsQ29sdW1uRXhwYW5zaW9uKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgPSBpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pICYmXG4gICAgICAgICAgICBCb29sZWFuV3JhcHBlci5pc1RydWUodGhpcy5zaG93Um93RGV0YWlsRXhwYW5zaW9uQ29udHJvbCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBleGVjdXRlZCBhZnRlciB3ZSBpbml0aWFsaXplIGFsbCB0aGUgY29sdW1ucyBpbiBvcmRlciB0byBjYWxjdWxhdGUgY29ycmVjdFxuICAgICAqIG51bWJlcnMgdXNlZCBmb3IgaW5kZW50YXRpb24gd2hpbGUgcmVuZGVyaW5nIHNlbGVjdGlvbiBjb2x1bW5zIGFzIHdlbGwgYXMgZGV0YWlsIHJvdyBjb2x1bW5zLlxuICAgICAqXG4gICAgICogSGVyZSB3ZSBuZWVkIHRvIGJlIGF3YXJlIGhvdyBtYW55IGNvbHVtbnMgdG8gc3BhblxuICAgICAqXG4gICAgICovXG4gICAgaW5pdENvbHVtbkluZm8oKTogdm9pZCB7XG4gICAgICAgIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YSA9IDA7XG5cbiAgICAgICAgdGhpcy5jb2x1bW5zLmZvckVhY2goKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbC5pc1ZhbHVlQ29sdW1uKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGErKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuaW5kZW50RGV0YWlsUm93KSB7XG4gICAgICAgICAgICB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGErKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3RhcnRPZkZpcnN0RGF0YUNvbHVtbiA9IHRoaXMuY29sdW1ucy5sZW5ndGggLSB0aGlzLm51bWJlck9mQ29sc0JlZm9yZURhdGE7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgYSBzdGF0ZSBvdXQgdG8gYXBwbGljYXRpb24uIENhbiBiZSB1c2UgYXMgdHdvIHdheSBiaW5kaW5nc1xuICAgICAqXG4gICAgICogWyhzdGF0ZSldPWR0U3RhdGUocylcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHN0YXRlKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgc2V0IHN0YXRlKHZhbDogYW55KSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZSA9IHZhbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2VsbFNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSAhPT0gJ2NlbGwnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvb2t1cEtleSA9IHtcbiAgICAgICAgICAgIGNvbDogY29sdW1uLmtleSB8fCBjb2x1bW4ubGFiZWwsXG4gICAgICAgICAgICBpdGVtOiBpdGVtXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pICYmIHRoaXMuc3RhdGUuc2VsZWN0aW9uLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBsb29rdXBLZXkpO1xuICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWQgPSBmb3VuZEluZGV4ICE9PSAtMTtcblxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gZm91bmRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0aW9uLCBsb29rdXBLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbbG9va3VwS2V5XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQ2VsbENoYW5nZS5lbWl0KHRoaXMuc3RhdGUuc2VsZWN0aW9uKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25IZWFkZXJTZWxlY3Rpb25DaGFuZ2UoY2VsbDogYW55LCBjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJTZWxlY3RlZChjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uID0gY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25IZWFkZXJTZWxlY3Rpb24uZW1pdCh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgb25IYW5kbGVSb3dDbGlja2VkKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICAvLyBzcGVjaWFsIGFsdCBrZXkgbW9kaWZpZXIuIFdoZW4gdXNlZCB3aXRoIHJvd3MgaXQgaW5kaWNhdGVzIHRoZXJlIGlzIGEgRCZEIGVuYWJsZWRcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgdGhpcy5vblJvd1RvZ2dsZShldmVudCwgaXRlbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICB0aGlzLm9uUm93U2VsZWN0KGV2ZW50LCBpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvblJvd1RvZ2dsZShldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IHJvd1NlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiYgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtKTtcbiAgICAgICAgICAgIGxldCBpc1NlbGVjdGVkID0gZm91bmRJbmRleCAhPT0gLTE7XG5cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgcm93U2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBmb3IgdGhlIG91dGxpbmUgZ28gdXAgYW5kIGRvd24gdGhlIHN5bmMgd2l0aCB0cmVlaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMub0hhbmRsZU91dGxpbmVSb3dUb2dnbGVUb1BhcmVudChpdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW2l0ZW1dO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc091dGxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihpdGVtLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Sb3dTZWxlY3Rpb25DaGFuZ2UuZW1pdCh7XG4gICAgICAgICAgICBpc1NlbGVjdGVkOiByb3dTZWxlY3RlZCxcbiAgICAgICAgICAgIGl0ZW06IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25Sb3dTZWxlY3QoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gaXRlbTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5vblJvd1NlbGVjdGlvbkNoYW5nZS5lbWl0KGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjdXJyZW50SXRlbTogYW55LCBpc1NlbGVjdGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGxldCBjaGlsZHJlbkZvck5vZGUgPSB0aGlzLmNoaWxkcmVuLmFwcGx5KHRoaXMuY29udGV4dCwgW2N1cnJlbnRJdGVtXSkgfHwgW107XG5cbiAgICAgICAgaWYgKGNoaWxkcmVuRm9yTm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiBpcyBzZWxlY3RlZCBjdXJyZW50bHkgdGhlbiB0b2dnbGUgdG8gb3RoZXIgc3RhdGVcbiAgICAgICAgICAgIGlmICghaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gY2hlY2tpbmcgYWxsIGZyb20gcm9vdCwgZGVzZWxlY3QgY2hpbGRyZW4gYW5kIGFkZCBhbGxcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oY3VycmVudEl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gWy4uLnRoaXMuc3RhdGUuc2VsZWN0aW9uLCAuLi5jaGlsZHJlbkZvck5vZGVdO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBlYWNoIGNoaWxkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW5Gb3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZEluZGV4ID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IGZvdW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIHNhbWUgZm9yIGNoaWxkcmVuIG9mIGNoaWxkcmVuXG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbkZvck5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oY2hpbGQsIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnRJdGVtLiQkcGFyZW50SXRlbTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChwYXJlbnQpKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW5Gb3JOb2RlID0gdGhpcy5jaGlsZHJlbi5hcHBseSh0aGlzLmNvbnRleHQsIFtwYXJlbnRdKSB8fCBbXTtcblxuICAgICAgICAgICAgbGV0IGFsbFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgIGFsbFNlbGVjdGVkID0gTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgY2hpbGQpICE9PSAtMVxuICAgICAgICAgICAgICAgICAgICAmJiBhbGxTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhbGxTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyZW50SW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlLnNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBwYXJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGN1cnJlbnRJdGVtLiQkcGFyZW50SXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uRG5EUm93RHJvcChvcmlnUG9zOiBudW1iZXIsIG5ld1BvczogbnVtYmVyLCBkcm9wUG9zOiBEcm9wUG9zaXRpb24pOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRHJvcHBpbmcgcm93ICM6ICcsIG9yaWdQb3MgKyAnICcgKyBkcm9wUG9zICsgJyByb3cgIzogJyArIG5ld1Bvcyk7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UucmVvcmRlclJvd3Mob3JpZ1BvcywgbmV3UG9zLCBkcm9wUG9zKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk91dGxpbmVFeHBhbmRDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgaXRlbSA9IGV2ZW50Lml0ZW07XG5cbiAgICAgICAgLy8gV2UgZG9udCByZWFsbHkgbmVlZCB0byBzdG9yZSBhIHN0YXRlIGZvcm0gb3V0bGluZSBsb2NhbGx5IGFzIHdlIGFyZSB1c2luZyB0aGUgc2FtZSBvYmplY3RcbiAgICAgICAgLy8gcmVmZXJlbmNlXG4gICAgICAgIC8vIHRoaXMuc3RhdGUub3V0bGluZVN0YXRlID0gdGhpcy5vdXRsaW5lU3RhdGUuZXhwYW5zaW9uU3RhdGVzO1xuXG4gICAgICAgIGlmICh0aGlzLmNhblVzZUZvckRldGFpbFJvdyhpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS50b2dnbGUoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0U2luZ2xlKCk6IHZvaWQge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkgJiYgaXNQcmVzZW50KHRoaXMuc29ydENvbHVtbikpIHtcblxuICAgICAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLnNvcnRDb2x1bW4ua2V5KSwgJ0ludmFsaWQgY29sdW1uIHRvIHNvcnQnKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zb3J0KHRoaXMuc29ydENvbHVtbi5rZXksIHRoaXMuc29ydENvbHVtbi5zb3J0T3JkZXIpO1xuXG4gICAgICAgICAgICB0aGlzLm9uU29ydC5lbWl0KHtcbiAgICAgICAgICAgICAgICBmaWVsZDogdGhpcy5zb3J0Q29sdW1uLmtleSxcbiAgICAgICAgICAgICAgICBvcmRlcjogdGhpcy5zb3J0Q29sdW1uLnNvcnRPcmRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhbmRsZURhdGFDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNvcnRLZXkgfHwgdGhpcy5zb3J0Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc29ydENvbHVtbiAmJiB0aGlzLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRDb2x1bW4gPSB0aGlzLmNvbHVtbnMuZmluZChcbiAgICAgICAgICAgICAgICAgICAgY29sID0+IGNvbC5rZXkgPT09IHRoaXMuc3RhdGUuc29ydEtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZURhdGFUb1JlbmRlcigpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy5saXN0KTtcbiAgICB9XG5cbiAgICB1cGRhdGVEYXRhVG9SZW5kZXIoZGF0YXNvdXJjZT86IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGFUb1JlbmRlciA9IGRhdGFzb3VyY2UgfHwgdGhpcy5saXN0O1xuICAgICAgICAvLyB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGN1cnJlbnQgaW1tdXRhYmxlIGxpc3QgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbi4gTmVlZCB0byB3cmFwIGl0IHdpdGhcbiAgICAgKiBzZXRUaW1lb3V0IGFzIHRoZSBjaGFuZ2UgY2FuIGVhc2lseSBjb21lIGFmdGVyIHZpZXcgY2hlY2tlZCBhbmQgdGhpcyB3b3VsZCByZXN1bHQgc29tZSBlcnJvcnNcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlTGlzdChuZXdMaXN0OiBhbnlbXSk6IHZvaWQge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IG5ld0xpc3Q7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURhdGFDaGFuZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc29ydENvbHVtbiA9IG51bGw7XG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBpc0hlYWRlclNlbGVjdGVkKGl0ZW06IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjb2xNYXRjaGVkID0gaXRlbS5rZXkgfHwgaXRlbS5sYWJlbDtcbiAgICAgICAgbGV0IGN1cnJlbnRDb2wgPSB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbi5rZXkgfHwgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24ubGFiZWw7XG4gICAgICAgIHJldHVybiBjb2xNYXRjaGVkID09PSBjdXJyZW50Q29sO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0JvZHlDZWxsU2VsZWN0ZWQoY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgbG9va3VwS2V5ID0ge1xuICAgICAgICAgICAgY29sOiBjb2x1bW4ua2V5IHx8IGNvbHVtbi5sYWJlbCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiZcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGxvb2t1cEtleSkgIT09IC0xO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaXNSb3dTZWxlY3RlZChpdGVtOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmIGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBpdGVtKSAhPT0gLTE7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnc2luZ2xlJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcXVhbHModGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRG8gd2UgaGF2ZSBkYXRhIHRvIHJlbmRlciBVc2VkIGluc2lkZSB0ZW1wbGF0ZSB0byB0ZWxsIGlmIHdlIHNob3VsZCB1c2UgdGhlIE5vRGF0YSB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIGlzQmxhbmsodGhpcy5kYXRhVG9SZW5kZXIpIHx8ICh0aGlzLmRhdGFUb1JlbmRlci5sZW5ndGggPT09IDApO1xuICAgIH1cblxuXG4gICAgaGFzRnJvemVuQ29sdW1ucygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmZyb3plbkNvbHVtbnMpICYmIHRoaXMuZnJvemVuQ29sdW1ucy5sZW5ndGggPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIGhhc0ludmlzaWJsZVNlbGVjdGlvbkNvbHVtbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpICYmICF0aGlzLnNob3dTZWxlY3Rpb25Db2x1bW47XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzTGVhZGluZ1NlbGVjdENvbHVtbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZSAhPT0gJ25vbmUnICYmIHRoaXMuc2VsZWN0aW9uTW9kZSAhPT0gJ2NlbGwnO1xuICAgIH1cblxuXG4gICAgdmlzaWJsZUNvbHVtbnMoKTogRFRDb2x1bW4yQ29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zID8gdGhpcy5jb2x1bW5zLmZpbHRlcihjID0+IGMuaXNWaXNpYmxlKSA6IFtdO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBzb3J0T3JkZXJpbmdGb3JTdHJpbmcoZGlyZWN0aW9uOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gJ2FzY2VuZGluZycpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09ICdkZXNjZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IGxvZyBiYWQga2V5XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuXG4gICAgc29ydE9yZGVyaW5nRm9yTnVtYmVyKGRpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiAnYXNjZW5kaW5nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZXNjZW5kaW5nJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0b2RvOiBsb2cgYmFkIGtleVxuICAgICAgICByZXR1cm4gJ2FzY2VuZGluZyc7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUFsbENvbHVtbnMoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uIHx8IFtdO1xuICAgICAgICBpZiAoc2VsZWN0ZWRPYmplY3QubGVuZ3RoID49IGN1cnJlbnRJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4uY3VycmVudEl0ZW1zXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1RvZ2dsZUFsbENvbHVtblNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG4gICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uIHx8IFtdO1xuXG4gICAgICAgIHJldHVybiBjdXJyZW50SXRlbXMubGVuZ3RoID4gMCAmJiBzZWxlY3RlZE9iamVjdC5sZW5ndGggPj0gY3VycmVudEl0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICBpc1RvZ2dsZUFsbENvbHVtbkRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgY3VycmVudEl0ZW1zID0gdGhpcy5kYXRhVG9SZW5kZXIgfHwgW107XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtcy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgYnkgdGVtcGxhdGUgdG8gZGVjaWRlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIERldGFpbFJvdyB0ZW1wbGF0ZS4gV2UgbmVlZCB0byBoYXZlXG4gICAgICogRGV0YWlsUm93IENvbnRlbnRDaGlsZCBhbmQgdXNpbmcgRGV0YWlsUm93IGNvbXBvbmVudCBbaXNWaXNpYmxlRm5dIGZ1bmN0aW9uIGJpbmRpbmcgd2VcbiAgICAgKiBjaGVjayBpZiB0aGUgaXRlbSB0aGF0IGlzIGFib3V0IHRvIGJlIHJlbmRlcmVkIGlzIGVsaWdpYmxlIGZvciBkZXRhaWwgcm93XG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93RGV0YWlsQ29sdW1uKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5jYW5Vc2VGb3JEZXRhaWxSb3coaXRlbSkgJiYgdGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5pc0V4cGFuZGVkKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYW5Vc2VGb3JEZXRhaWxSb3coaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pICYmXG4gICAgICAgICAgICAoPERURGV0YWlsUm93Q29tcG9uZW50PnRoaXMucm93RGV0YWlsQ29sdW1uKS5zaG93RGV0YWlsUm93KGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc091dGxpbmUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jaGlsZHJlbik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gZGVhbGluZyB3aXRoIGRldGFpbCBjb2x1bW4gKGRldGFpbCByb3cpIGFuZCBvdXRsaW5lIGFsbCB0b2dldGhlciB3ZSBuZWVkIGhhdmUgYVxuICAgICAqIG1lY2hhbmlzbSB0byB0ZWxsIHRvIHRoZSBvdXRsaW5lIFwiZG9uJ3QgcmVuZGVyIHRoZSBuZXh0IGxldmVsIG9mIGl0ZW1zXCIgYW5kIHVzZSBkZXRhaWwgcm93LlxuICAgICAqIFNvIGNlcnRhaW4gaXRlbSB0eXBlIG5lZWRzIHRvIGJlIHNraXBwZWQuXG4gICAgICpcbiAgICAgKiBUaGUgd2F5IHdlIHNraXAgdGhvc2UgaXRlbSBpcyB3ZSB1c2UgaXNWaXNpYmxlRm4gY29uZGl0aW9uIG9mIHRoZSBkZXRhaWwgcm93IGFuZCBsb29rIGFoZWFkXG4gICAgICogaWYgd2Ugc2hvdWxkIHNraXAgbmV4dCBsZXZlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHNraXBPdXRsaW5lSXRlbShpdGVtOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0VmFsdWUoZGF0YTogYW55LCBmaWVsZDogc3RyaW5nKTogYW55IHtcbiAgICAgICAgcmV0dXJuIEZpZWxkUGF0aC5nZXRGaWVsZFZhbHVlKGRhdGEsIGZpZWxkKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBQTEFURk9STV9JRCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24sIG9mfSBmcm9tICdyeGpzJztcbmltcG9ydCB7ZGVib3VuY2VUaW1lLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc3dpdGNoTWFwfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge2lzUGxhdGZvcm1Ccm93c2VyfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtJbmZpbml0ZVNjcm9sbENvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9pbmZpdGUtc2Nyb2xsL2luZml0ZS1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBQbGVhc2Ugc2VlIGRhdGF0YWJsZSBmb3IgbW9yZSBkZXRhaWwgZGVzY3JpcHRpb24uIEJ1dCB0aGUgbWFpbiBnb2FsIG9mIHRoaXMgd3JhcHBlciB0byByZW1vdmVcbiAqIGFsbCB0aGUgY29tbW9uIHN1cnJvdW5kaW5nIHBhcnRzIGFyb3VuZCB0aGUgZGF0YXRhYmxlIGFuZCBtYWtlIHN1cmUgRFQgY2FuIGZvY3VzIG9ubHkgYWN0dWFsXG4gKiBoZWFkZXIgYW5kIGJvZHkgc3RydWN0dXJlXG4gKlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB3cmFwcGVyIGFsc28gcHJvdmlkZXMgc29tZSBjb2RlIGZvciB0aGUgc2xpZGluZyB1cCBwYW5lbCBjb250YWluaW5nXG4gKiBidXR0b25zIGFuZCBvdGhlciBhY3Rpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGR1cmluZyBlZGl0aW5nXG4gKlxuICpcbiAqIFRvZG86IEV4dHJhY3QgdGhlIGV4cGFuZCBsb2dpYyBvdXQgaW50byBzb21lIGRpcmVjdGl2ZSBvciBjb21wb25lbnQgb3IganVzdCBhIGNsYXNzXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LXdyYXBwZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBbbmdDbGFzc109XCJkdC5zdHlsZUNsYXNzXCIgW2NsYXNzLmR0LWZ1bGwtc2NyZWVuLW1vZGVdPVwiaXNGdWxsU2NyZWVuTW9kZVwiXG4gICAgIFtzdHlsZS53aWR0aF09XCJkdC53aWR0aFwiXG4+XG4gICAgPGRpdiBjbGFzcz1cImR0LWxvYWRpbmctb3ZlcmxheVwiICpuZ0lmPVwiZHQubG9hZGluZ1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJkdC1sb2FkaW5nLWNvbnRlbnRcIiAqbmdJZj1cImR0LmxvYWRpbmdcIj5cbiAgICAgICAgPGkgW2NsYXNzXT1cIidzYXAtaWNvbiB1LWR0LXNwaW4taWNvbiAnICsgZHQubG9hZGluZ0ljb25cIj48L2k+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtaGVhZGVyXCIgKm5nSWY9XCJkdC5zaG93VGFibGVIZWFkZXJcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiZHQuaGVhZGVyOyB0aGVuIGFwcERlZmluZWRIZWFkZXIgZWxzZSBkZWZhdWx0SGVhZGVyXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRFQgQk9EWSB3aXRoIHRhYmxlIGhlYWRlcnMgYW5kIHZhbHVlcyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtYm9keS13cmFwcGVyLXZpZXdcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICAqbmdJZj1cImR0Lmhhc0Zyb3plbkNvbHVtbnMoKTsgdGhlbiBkdEJvZHlXaXRoRnJvemVuQ29sdW1ucyBlbHNlIGR0Qm9keU5vRnJvemVuQ29sdW1uc1wiPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLTxkaXYgY2xhc3M9XCJkdC1mb290ZXJcIiAqbmdJZj1cImZvb3RlclwiPi0tPlxuICAgIDwhLS0mbHQ7ISZuZGFzaDsgZm9vdGVyQXJlYSZuZGFzaDsmZ3Q7LS0+XG4gICAgPCEtLTxuZy1jb250ZW50IHNlbGVjdD1cImF3LWR0LWZvb3RlclwiPjwvbmctY29udGVudD4tLT5cbiAgICA8IS0tPC9kaXY+LS0+XG48L2Rpdj5cblxuPCEtLSB0b2RvOiBkb250IGFjdGl2YXRlIHRoaXMgaWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIGxpc3QgLSAtLT5cbjxhdy1pbmZpbml0ZS1zY3JvbGwgI2luZmluaXRlU2Nyb2xsICpuZ0lmPVwiaXNGdWxsU2NyZWVuTW9kZVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXN0YW5jZV09XCInMTAlJ1wiXG4gICAgICAgICAgICAgICAgICAgIFtmZXRjaFNpemVdPVwiZHQuc3RhdGUubGltaXRcIlxuICAgICAgICAgICAgICAgICAgICAob25Mb2FkKT1cIm9uTGF6eUxvYWQoJGV2ZW50KVwiPlxuPC9hdy1pbmZpbml0ZS1zY3JvbGw+XG5cblxuPG5nLXRlbXBsYXRlICNhcHBEZWZpbmVkSGVhZGVyPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkaW5nO1wiPjwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0SGVhZGVyPlxuICAgIDxkaXYgY2xhc3M9XCJkdC1nbG9iYWwtZmlsdGVyXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb24gaWNvbi1maWx0ZXJcIj48L3NwYW4+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtZ2xvYmFsLWFjdGlvbnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImR0LWFjdGlvbi1jb21ib1wiPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJzdXBwb3J0RnVsbFNjcmVlblwiIGNsYXNzPVwic2FwLWljb24gaWNvbi1yZXNpemVcIlxuICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUZ1bGxTY3JlZW4oJGV2ZW50KVwiPjwvc3Bhbj5cblxuICAgICAgICAgICAgPGF3LWlucHV0LWZpZWxkICpuZ0lmPVwiZHQuc2hvd0dsb2JhbFNlYXJjaFwiIHN0eWxlQ2xhc3M9XCJkdC10YWJsZS1zZWFyY2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwiZHQuc3RhdGUuY3VycmVudFNlYXJjaFF1ZXJ5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZUhvbGRlcj1cInNlYXJjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWNvbj1cImljb24tc2VhcmNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJzZWFyY2hUZXJtcy5uZXh0KCRldmVudClcIj5cbiAgICAgICAgICAgIDwvYXctaW5wdXQtZmllbGQ+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImFyaWJhLWljb24gaWNvbi1tb3JlXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNkdEJvZHlOb0Zyb3plbkNvbHVtbnM+XG4gICAgPCEtLVxuICAgICAgICBGb3Igbm9uLWZyb3plbiBjYXNlIHdlIGFsc28gbmVlZCB0byBzZXQgVFJVRSBhcyB0aGUgdmlldyBpcyBhY3R1YWxseSBmcm96ZW4gYW5kIGRvZXMgbm90XG4gICAgICAgIHNjcm9sbC5cbiAgICAgICAgV2UgdXNlIHRoaXMgZnJvemVuQ29sdW1ucyBmbGFnIGluc2lkZSBEVCB0byBwcm9wZXJseSBzZXQgY29sdW1uIGluZGV4IG9uIHRoZSBoZWFkZXIgbGV2ZWxcbiAgICAgICAgY29sdW1uSW5kZXg6KGZyb3plbiA/IGNvbHVtbkluZGV4OiAoY29sdW1ucy5sZW5ndGggKyBjb2x1bW5JbmRleCkpXG5cbiAgICAgICAgdGhlcmVmb3JlIHdlIG5lZWQgdG8gc2V0IHRydWUgZXZlbiBpbiB0aGlzIGNhc2UgdG8gcmV0dXJuIHJlYWwgY29sdW1uSW5kZXggc2luY2Ugd2UgZG9udFxuICAgICAgICBoYXZlIHRoZSBzZWNvbmQgdGFibGUuXG4gICAgLS0+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImR0Qm9keTsgY29udGV4dDp7JGltcGxpY2l0OiBkdC5jb2x1bW5zLCBmcm96ZW5Db2x1bW5zOiB0cnVlIH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZHRCb2R5V2l0aEZyb3plbkNvbHVtbnM+XG4gICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImR0Qm9keTsgY29udGV4dDp7JGltcGxpY2l0OiBkdC5mcm96ZW5Db2x1bW5zLCBmcm96ZW5Db2x1bW5zOiB0cnVlIH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8bmctY29udGFpbmVyXG4gICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHRCb2R5OyBjb250ZXh0OnskaW1wbGljaXQ6IGR0LmNvbHVtbnMsIGZyb3plbkNvbHVtbnM6IGZhbHNlIH1cIj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNkdEJvZHkgbGV0LWNvbHVtbnMgbGV0LWZyb3plbkNvbHVtbnM9XCJmcm96ZW5Db2x1bW5zXCI+XG5cbiAgICA8ZGl2ICNkdENvbnRhaW5lciBjbGFzcz1cImR0LWJvZHktd3JhcHBlclwiXG4gICAgICAgICBbc3R5bGUud2lkdGgucHhdPVwidGhpcy5jYWxjdWxhdGVGcm96ZW5XaWR0aCgpXCJcbiAgICAgICAgIFtjbGFzcy5kdC1ib2R5LXVuZnJvemVuXT1cImR0Lmhhc0Zyb3plbkNvbHVtbnMoKSAmJiAhZnJvemVuQ29sdW1uc1wiXG4gICAgICAgICBbY2xhc3MuZHQtYm9keS1mcm96ZW5dPVwiZHQuaGFzRnJvemVuQ29sdW1ucygpICYmIGZyb3plbkNvbHVtbnNcIlxuICAgID5cblxuICAgICAgICA8dGFibGUgW25nQ2xhc3NdPVwiZHQudGFibGVTdHlsZUNsYXNzXCJcbiAgICAgICAgICAgICAgIFtzdHlsZS53aWR0aF09XCJmcm96ZW5Db2x1bW5zID8gbnVsbCA6IGR0LnNjcm9sbFdpZHRoXCJcbiAgICAgICAgICAgICAgIFtjbGFzcy5kdC1waXZvdC1sYXlvdXRdPVwiZHQucGl2b3RhbExheW91dFwiXG4gICAgICAgICAgICAgICBbY2xhc3MuZHQtcGxhaW4tbGF5b3V0XT1cIiFkdC5waXZvdGFsTGF5b3V0ICYmICFkdC5pc091dGxpbmUoKVwiPlxuXG4gICAgICAgICAgICA8IS0tIFJlbmRlciBUSCBoZWFkZXIgcm93cy0tPlxuICAgICAgICAgICAgPHRoZWFkIGNsYXNzPVwiZHQtdGhlYWRcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyUm93czsgY29udGV4dDp7JGltcGxpY2l0OiBjb2x1bW5zLGZyb3plbkNvbHVtbnM6ZnJvemVuQ29sdW1ucyB9XCI+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L3RoZWFkPlxuXG4gICAgICAgICAgICA8IS0tXG4gICAgICAgICAgICAgICAgUmVuZGVyIGRhdGEgcm93cy4gRm9yIGRhdGEgcm93cyB3ZSBuZWVkIHRvIGtlZXAgdGJvZHkgdGFnIGluc2lkZSBEVCB0YWJsZVxuICAgICAgICAgICAgICAgIGR1ZSB0byBPdXRsaW5lXG4gICAgICAgICAgICAgLS0+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVJvd3M7IGNvbnRleHQ6eyRpbXBsaWNpdDogY29sdW1ucywgIGZyb3plbkNvbHVtbnM6ZnJvemVuQ29sdW1ucyB9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC90YWJsZT5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPGRpdiAjZHRGdWxsU2NyZWVuT3ZlcmxheSBjbGFzcz1cImR0LWZ1bGwtc2NyZWVuLW92ZXJsYXkgdS1mdWxsLXNjcmVlbi1lbGVtZW50XCI+PC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2AuZHQtZm9vdGVyLC5kdC1oZWFkZXJ7dGV4dC1hbGlnbjpjZW50ZXI7cGFkZGluZzouNWVtIC43NWVtO2JveC1zaXppbmc6Ym9yZGVyLWJveH0uZHQtZm9vdGVye2JvcmRlci10b3A6MH0uZHQtdGhlYWQgdHJ7Ym9yZGVyLXdpZHRoOjB9LmR0LWJvZHktd3JhcHBlci12aWV3e3Bvc2l0aW9uOnJlbGF0aXZlfS5kdC1ib2R5LXdyYXBwZXJ7b3ZlcmZsb3c6aGlkZGVuO2JvcmRlcjoxcHggc29saWQgI2Q3ZDdkN30uZHQtYm9keS13cmFwcGVyLmR0LWJvZHktdW5mcm96ZW57Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7b3ZlcmZsb3cteDphdXRvfS5kdC1sb2FkaW5nLW92ZXJsYXl7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjojOWI5YjliO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7b3BhY2l0eTouMTt6LWluZGV4OjF9LmR0LWxvYWRpbmctY29udGVudHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTt0b3A6MjUlO3otaW5kZXg6Mn0uZHQtaGVhZGVye3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4O2ZsZXgtZmxvdzpyb3cgbm93cmFwO2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2NvbG9yOiMzNjM2MzY7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2YxZjFmMTttYXJnaW4tYm90dG9tOjMwcHh9LmR0LWhlYWRlciAuZHQtZ2xvYmFsLWZpbHRlcntmbGV4OjAgMDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0O2ZvbnQtc2l6ZToxOHB4fS5kdC1oZWFkZXIgLmR0LWdsb2JhbC1hY3Rpb25ze2ZsZXg6MCAwO2FsaWduLWl0ZW1zOmZsZXgtZW5kfS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ib3tkaXNwbGF5OmZsZXg7ZmxleC1mbG93OnJvdyBub3dyYXA7Y29sb3I6IzdkN2Q3ZH0uZHQtaGVhZGVyIC5kdC1hY3Rpb24tY29tYm8gLmFyaWJhLWljb24sLmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJvIC5zYXAtaWNvbnttYXJnaW4tbGVmdDoxNXB4O2ZvbnQtc2l6ZToyMHB4O2FsaWduLXNlbGY6Y2VudGVyO2N1cnNvcjpwb2ludGVyfS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ibyAuZHQtdGFibGUtc2VhcmNoe2JvcmRlci10b3AtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ibyAuaWNvbi1yZXNpemV7Y29sb3I6IzRhNGE0YTtmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoxOHB4O21hcmdpbi1yaWdodDoxNXB4fS51LWR0LXNwaW4taWNvbntkaXNwbGF5OmlubGluZS1ibG9jazstd2Via2l0LWFuaW1hdGlvbjoycyBsaW5lYXIgaW5maW5pdGUgZG9TcGluO2FuaW1hdGlvbjoycyBsaW5lYXIgaW5maW5pdGUgZG9TcGlufUAtd2Via2l0LWtleWZyYW1lcyBkb1NwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9MTAwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fUBrZXlmcmFtZXMgZG9TcGluezAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgwKTt0cmFuc2Zvcm06cm90YXRlKDApfTEwMCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDM2MGRlZyk7dHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpfX0uZHQtZnVsbC1zY3JlZW4tb3ZlcmxheXtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwMDstd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSA1MCU7dHJhbnNpdGlvbjphbGwgLjRzIGVhc2UtaW4tb3V0fS5kdC1mdWxsLXNjcmVlbnt3aWR0aDo5OHZ3O3otaW5kZXg6MTIwO3Bvc2l0aW9uOmFic29sdXRlO3RvcDoxNXB4O3BvaW50ZXItZXZlbnRzOmFsbDt0cmFuc2l0aW9uOm9wYWNpdHkgLjVzIGVhc2UtaW4tb3V0fS51LWZzLWVsZW1lbnQtb3V0e2Rpc3BsYXk6bm9uZX1gXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG5cbn0pXG5leHBvcnQgY2xhc3MgRFRXcmFwcGVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWRcbntcblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRoYXQgaXMgdXNlZCBieSBmdWxsIHNjcmVlbiBkaXYgb3ZlcmxheSB0byBjcmVhdGUgZXhwYW5kaW5nIGVmZmVjdCB3aGljaCBuZWVkcyB0byBoYXZlXG4gICAgICogbGl0dGxlIHRlbnQ7XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZENvbG9yRnJvbTogc3RyaW5nID0gJyNmM2YzZjMnO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xvciB0aGF0IGlzIHVzZWQgdG8gc2V0IGFmdGVyIHdlIGFyZSBpbiB0aGUgZnVsbCBzY3JlZW4gc28gb3VyIG92ZXJsYXkgZGl2IGhpZGUgZXZlcnl0aGluZ1xuICAgICAqIG9uIHRoZSBwYWdlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZENvbG9yVG86IHN0cmluZyA9ICcjRkZGRkZGJztcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUYWJsZSBoZWFkaW5nIGFyZWEgb2ZmZXJzIGRldmVsb3BlciB0byBjb21wbGV0ZWx5IG92ZXJyaWRlIHRoZSB0b3AgYmFyIHdoZXJlIHdlIGhhdmUgZmlsdGVyc1xuICAgICAqIGFuZCBvdGhlcnMgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRpbmdBcmVhJylcbiAgICBoZWFkaW5nOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRhYmxlIGhlYWRlcnMgYW5kIHdyYXBzIHRoZW0gd2l0aGluIHRoZWFkIHRhZ1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2hlYWRlclJvd3MnKVxuICAgIGhlYWRlclJvd3M6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGFibGUgYm9keVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2JvZHlSb3dzJylcbiAgICBib2R5Um93czogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgaGVhZGluZyB0ZW1wbGF0ZS4gV2UgbmVlZCB0byByZW1vdmUgdGhpcyBkZXBlbmRlbmN5IG9uIHByaW1lTkcgc28gZmFyIGl0IGlzIHVzaW5nXG4gICAgICogcC1mb290ZXJcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdmb290ZXJBcmVhJylcbiAgICBmb290ZXI6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIERpdiB1c2VkIHRvIG1ha2UgdGhlIGZ1bGwgc2NyZWVuIGV4cGFuc2lvbiBlZmZlY3RcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkdEZ1bGxTY3JlZW5PdmVybGF5JylcbiAgICBkdEZ1bGxTY3JlZW5PdmVybGF5OiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gaW5maXRlIHNjcm9sbC4gV2UgYXJlIHVzaW5nIHRoaXMgdG8gdHJpZ2dlciBsb2FkaW5nIGZpbmlzaCBldmVudCBzbyB3ZSBjYW5cbiAgICAgKiBoaWRlIGxvYWRpbmcgYW5pbWF0aW9uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaW5maW5pdGVTY3JvbGwnKVxuICAgIGluZmluaXRlU2Nyb2xsOiBJbmZpbml0ZVNjcm9sbENvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogSW4gb3JkZXIgdG8gZGVib3VuY2UgdGhlIHR5cGluZyB3ZSBuZWVkIHRvIHVzZSBzdWJqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBzZWFyY2hUZXJtcyA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuXG4gICAgLyoqXG4gICAgICogIFNwZWNpZmllcyBpZiB3ZSBhcmUgaW4gdmlld2luZy9lZGl0aW5nIG1vZGUgdGhhdCBjYW4gYnJvd3NlIHdob2xlIGRhdGFzZXQgbGF6aWx5XG4gICAgICpcbiAgICAgKi9cbiAgICBpc0Z1bGxTY3JlZW5Nb2RlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB3ZSBjYW4gc3VwcG9ydCBmdWxsIHNjcmVlbiBtb2RlIC0gb25seSBhdmFpbGFibGUgZm9yIHRoZSBicm93c2VyXG4gICAgICpcbiAgICAgKi9cbiAgICBzdXBwb3J0RnVsbFNjcmVlbjogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqICBTYXZlcyBvcmlnaW5hbCBib3VuZGluZyByZWN0IGNvb3JkaW5hdGVzIGJlZm9yZSB3ZSBleHBhbmQgdGhlIERUIHRvIGZ1bGwgc2NyZWVuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGR0Qm91bmRpbmdDbGllbnRSZWN0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZW1lbWJlcnMgb3JpZ2luYWwgc2Nyb2xsIHBvc2l0aW9uIGJlZm9yZSB3ZSBzd2l0Y2ggdG8gZnVsbCBzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIHByaXZhdGUgb3JpZ2luYWxTY3JvbGxQb3NpdGlvbjogbnVtYmVyO1xuXG4gICAgcXVlcnlTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBsb2FkaW5nU3ViOiBTdWJzY3JpcHRpb247XG5cblxuICAgIGNvbnN0cnVjdG9yIChwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSByZW5kZXI6IFJlbmRlcmVyMixcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSB0aGlzRWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIHBsYXRmb3JtSWQ6IE9iamVjdCxcbiAgICAgICAgICAgICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IERhdGF0YWJsZTJDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgICBwdWJsaWMgZHQ6IERhdGF0YWJsZTJDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5xdWVyeVN1YnNjcmlwdGlvbiA9IHRoaXMuc2VhcmNoVGVybXMucGlwZShcbiAgICAgICAgICAgIC8vIHdhaXQgMzAwbXMgYWZ0ZXIgZWFjaCBrZXlzdHJva2UgYmVmb3JlIGNvbnNpZGVyaW5nIHRoZSB0ZXJtXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMzAwKSxcblxuICAgICAgICAgICAgLy8gaWdub3JlIG5ldyB0ZXJtIGlmIHNhbWUgYXMgcHJldmlvdXMgdGVybVxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcblxuICAgICAgICAgICAgc3dpdGNoTWFwKCh0ZXJtOiBzdHJpbmcpID0+IG9mKHRlcm0pKVxuICAgICAgICApLnN1YnNjcmliZSgodGVybTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGVybSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5maW5kKHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxvYWRpbmdTdWIgPSB0aGlzLmR0LnZhbHVlQ2hhbmdlXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChkYXRhOiBhbnkpID0+IHRoaXMubG9hZGluZ0ZpbmlzaGVkKCkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBhbGwgY29sdW1ucyBtYXJrZWQgYXMgZnJvemVuIGFuZCByZXRyaWV2ZSBhIHdpZHRoIHNvIHdlIGNhbiB1cGRhdGVcbiAgICAgKiBwYXJlbnQgZGl2XG4gICAgICpcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVGcm96ZW5XaWR0aCAoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuZHQuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBmV2lkdGggPSAwO1xuICAgICAgICB0aGlzLmR0LmZyb3plbkNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChjb2wubWF4V2lkdGhQeCA+IDApIHtcbiAgICAgICAgICAgICAgICBmV2lkdGggKz0gY29sLndpZGVzdENlbGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZXaWR0aCArPSBwYXJzZUludChjb2wud2lkdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZldpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBoYXZpbmcgdHdvIHNlcGFyYXRlIHRhYmxlcyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHJvd3Mgb2YgdGhlIHRhYmxlcyBhcmUgYWxpZ25lZC5cbiAgICAgKlxuICAgICAqIFRoZXJlZm9yZSB0aGlzIG1ldGhvZCB0YWtlcyBmaXJzdCBjb2x1bW4gZnJvbSBlYWNoIHRhYmxlIHJlYWQgdGhlIGhlaWdodCBvZiB0aGUgcm93cyBhbmQgc2V0XG4gICAgICogdGhlIG1heCBoZWlnaHQgdG8gYm90aCByb3dzLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBhbGlnblRhYmxlc0hlaWdodHMgKGZyb3plblZpZXc6IGFueSwgdW5Gcm96ZW5WaWV3OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KGZyb3plblZpZXcpICYmIGlzUHJlc2VudChmcm96ZW5WaWV3KSxcbiAgICAgICAgICAgICdDYW50IGFsaWduIHRhYmxlIHZpZXdzIGFzIG9uZSBvZiB0aGUgdmlldyBpcyB1bmRlZmluZWQnKTtcblxuICAgICAgICBsZXQgZnJvemVuUm93czogYW55W10gPSBmcm96ZW5WaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRyJyk7XG4gICAgICAgIGxldCB1bkZyb3plblJvd3M6IGFueVtdID0gdW5Gcm96ZW5WaWV3LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRyJyk7XG5cbiAgICAgICAgYXNzZXJ0KGZyb3plblJvd3MubGVuZ3RoID09PSB1bkZyb3plblJvd3MubGVuZ3RoLFxuICAgICAgICAgICAgJ0Zyb3plbiBDb2x1bW46IFR3byB0YWJsZXMgZG9lcyBub3QgbXVjaCEnKTtcblxuICAgICAgICBBcnJheS5mcm9tKGZyb3plblJvd3MpLmZvckVhY2goKGZyb3plbjogYW55LCBpbmRleDogbnVtYmVyKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBsZXQgaCA9IE1hdGgubWF4KGZyb3plbi5vZmZzZXRIZWlnaHQsIHVuRnJvemVuUm93c1tpbmRleF0ub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIGZyb3plbi5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgICAgIHVuRnJvemVuUm93c1tpbmRleF0uc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0RnVsbFNjcmVlbigpO1xuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkICgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIGxldCBmcm96ZW5WaWV3ID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LWZyb3plbicpO1xuICAgICAgICAgICAgbGV0IHVuRnJvemVuVmlldyA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtYm9keS11bmZyb3plbicpO1xuXG4gICAgICAgICAgICBsZXQgZnJvemVuV2lkdGggPSB0aGlzLmNhbGN1bGF0ZUZyb3plbldpZHRoKCk7XG4gICAgICAgICAgICBmcm96ZW5WaWV3LnN0eWxlLndpZHRoID0gZnJvemVuV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCh1bkZyb3plblZpZXcpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW5jbHVkZSBib3JkZXIgYW5kIGNyZWF0ZSBpbmRlbnQgZWZmZWN0IGJ5IGhhdmluZyAxcHggd2hpdGUgc3BhY2VcbiAgICAgICAgICAgICAgICB1bkZyb3plblZpZXcuc3R5bGUubGVmdCA9IChmcm96ZW5XaWR0aCArIDIpICsgJ3B4JztcbiAgICAgICAgICAgICAgICB1bkZyb3plblZpZXcuc3R5bGUud2lkdGggPSB1bkZyb3plblZpZXcucGFyZW50RWxlbWVudC5vZmZzZXRXaWR0aFxuICAgICAgICAgICAgICAgICAgICAtIGZyb3plblZpZXcub2Zmc2V0V2lkdGggKyAncHgnO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hbGlnblRhYmxlc0hlaWdodHMoZnJvemVuVmlldywgdW5Gcm96ZW5WaWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95ICgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5xdWVyeVN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5sb2FkaW5nU3ViKSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nU3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZVTEwgU0NSRUVOIE1PREUgbWV0aG9kc1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGZ1bGxzY3JlZW4gZnVuY3Rpb25hbGl0eSBpcyBlbmFibGVkIHRoaXMgbWV0aG9kIHN3aXRjaGVzIGJldHdlZW4gbm9ybWwgYW5kIGZ1bGwgc2NyZWVuXG4gICAgICogbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbFNjcmVlbiAoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlzRnVsbFNjcmVlbk1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGdWxsU2NyZWVuKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkZ1bGxTY3JlZW4oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gcHVzaCB0aGlzIGNvbXBvbmVudCB0byBmdWxsIHNjcmVlbiBtb2RlIG9yIG1heWJlIGZ1bGwgcGFnZSBtb2RlIHdlIG5lZWQgcnVuIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqICAtIEV4ZWN1dGUgZXhwYW5kIHRyYW5zZm9ybWF0aW9uLCB3aGVyZSB3ZSBoYXZlIGFkZGl0aW9uYWwgb3ZlcmxheSBkaXYgdGhhdCB3ZSBzbG93bHkgZXhwYW5kXG4gICAgICogIGFuZCB0aGlzIGNyZWF0ZXMgaW1wcmVzc2lvbiB0aGUgRFQgaXMgZXhwYW5kaW5nXG4gICAgICpcbiAgICAgKiAgLSBhcHBseSBmdWxsLXNjcmVlbiBjbGFzcyBvbiB0b3AgaG9zdCBlbGVtZW50ICAtIGluIHRoaXMgY2FzZSBpdHMgRGF0YVRhYmxlIHRvIHN3aXRjaFxuICAgICAqICB0byBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAqXG4gICAgICogIC0gbWFrZSBzdXJlIHdlIGFyZSBzY3JvbGxlZCBhbGwgdGhlIHdheSB1cFxuICAgICAqXG4gICAgICogIC0gaGlkZSBhbGwgdGhlIGVsZW1lbnRzIG9uIHRoZSBwYWdlIHNvIHRoZWlyIGRpbWVuc2lvbiBkb24ndCBpbnRlcmZlcmUgd2l0aCB0aGlzIHRhYmxlLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuRnVsbFNjcmVlbiAoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaXNGdWxsU2NyZWVuTW9kZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5ydW5FeHBhbmRFZmZlY3QoKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFNjcm9sbFBvc2l0aW9uID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIDApO1xuICAgICAgICB0aGlzLnRvZ2dsZUZ1bGxTY3JlZW5PbkRUKHRydWUpO1xuXG5cbiAgICAgICAgLy8gbWFyayBteSBlbGVtZW50IGluIHRoZSBwYXRoIHRoYXQgbmVlZHMgdG8gc3RheVxuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoaXNQcmVzZW50KHBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUudGFnTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ3UtZnVsbC1zY3JlZW4tZWxlbWVudCcpO1xuICAgICAgICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhpZGVOb25GdWxsU2NyZWVuRWxlbWVudChkb2N1bWVudC5ib2R5KTtcblxuICAgICAgICB0aGlzLmR0LnN0YXRlLmxpbWl0ID0gTWF0aC5yb3VuZCh0aGlzLmNhbGN1bGF0ZUxpbWl0KCkpO1xuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2UuZmV0Y2godGhpcy5kdC5zdGF0ZSk7XG5cbiAgICAgICAgLy8gb25jZSBsb2FkZWQgc2V0IGJhY2sgY29ycmVjdCBwYWdlIHNpemUgd2UgdXNlIHdoZW4gbG9hZGluZyBkYXRhXG4gICAgICAgIHRoaXMuZHQuc3RhdGUubGltaXQgPSB0aGlzLmR0LnBhZ2VTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhlIHNhbWUgbGlrZSBhYm92ZSBtZXRob2QgKG9wZW5GdWxsU2NyZWVuKSBidXQgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGNsb3NlRnVsbFNjcmVlbiAoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaXNGdWxsU2NyZWVuTW9kZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuc2hvd05vbkZ1bGxTY3JlZW5FbGVtZW50KCk7XG4gICAgICAgIHRoaXMucnVuQ29sbGFwc2VFZmZlY3QoKTtcbiAgICAgICAgdGhpcy50b2dnbGVGdWxsU2NyZWVuT25EVChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmxpbWl0ID0gdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLmRpc3BsYXlMaW1pdDtcbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgd2luZG93LnNjcm9sbCgwLCB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmltYXRpb24gZWZmZWN0IHRvIG1ha2UgaXQgZmVlbCBsaWtlIHRoZSBlbGVtZW50IChpbiB0aGlzIGNhc2UgRFQpIGlzIGV4cGFuZGluZ1xuICAgICAqIGZyb20gdGhlIG1pZGRsZSB0byB0aGUgZnVsbCBwYWdlIG1vZGUuXG4gICAgICpcbiAgICAgKiBXZSB0YWtlIHRoZSBkaW1lbnNpb24gb2YgdGhlIHRhYmxlIHRoZW4gaXQgaXMgc2NhbGVkIHNsb3dseSB0byB0aGUgZnVsbCBwYWdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5FeHBhbmRFZmZlY3QgKClcbiAgICB7XG4gICAgICAgIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZXhwYW5kQ29sb3JGcm9tO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKHRydWUpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5leHBhbmRDb2xvclRvO1xuICAgICAgICB9LCAzMDApO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgdHJhbnNmb3JtYXRpb24gYW5kIHNjYWxlIHRoZSBoZWxwZXIgZGl2IChvdmVybGF5KSBkb3duIHRvIG1ha2UgaXQgbG9vayBsaWtlXG4gICAgICogaXQgY29sbGFwc2VzXG4gICAgICovXG4gICAgcHJpdmF0ZSBydW5Db2xsYXBzZUVmZmVjdCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbihmYWxzZSk7XG5cblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCgpO1xuICAgICAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICAgICAgfSwgMjAwKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudCh0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQsIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wLCAwLFxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9LCA0MDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERGUyAgLSB0byBnbyB0aHJ1IGFsbCB0aGUgZWxlbWVudCB1bmRlciBCT0RZIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBwYWdlLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBoaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQgKHBhcmVudEVsZW1lbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSA9PT0gcGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnRFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IHBhcmVudEVsZW1lbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkVHJhdmVyc2VEb3duKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkdC1mdWxsLXNjcmVlbicpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCd1LWZzLWVsZW1lbnQtb3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXQgYWxsIHRoZSBlbGVtZW50IHRoYXQgd2VyZSBwcmV2aW91c2x5IHJlbW92ZWQgYnkgaGlkZU5vbkZ1bGxTY3JlZW5FbGVtZW50KCkgYmFja1xuICAgICAqL1xuICAgIHByaXZhdGUgc2hvd05vbkZ1bGxTY3JlZW5FbGVtZW50ICgpOiB2b2lkXG4gICAge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy51LWZzLWVsZW1lbnQtb3V0JykpXG4gICAgICAgICAgICAuZm9yRWFjaCgoZWxlbTogYW55KSA9PiBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3UtZnMtZWxlbWVudC1vdXQnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG5lZWRUcmF2ZXJzZURvd24gKGVsZW1lbnQ6IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoZWxlbWVudCkgJiYgZWxlbWVudC50YWdOYW1lICE9PSAnU0NSSVBUJyAmJlxuICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3UtZnVsbC1zY3JlZW4tZWxlbWVudCcpICYmXG4gICAgICAgICAgICAhZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2R0LWZ1bGwtc2NyZWVuJyk7XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZW50ZXIgZnVsbCBzY3JlZW4gL3BhZ2UgbW9kZSB3aGVuIG5lZWQgdG8gY2FsY3VsYXRlIGhvdyBtYW55IHJvd3MgdG8gbG9hZCBpbml0aWFsbHlcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FsY3VsYXRlTGltaXQgKCk6IG51bWJlclxuICAgIHtcbiAgICAgICAgbGV0IGJyb3dzZXJIID0gdGhpcy5kb21VdGlscy5icm93c2VyRGltZW50aW9ucygpLmhlaWdodDtcbiAgICAgICAgbGV0IHJvd0ggPSB0aGlzLmR0LmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHkgdHI6Zmlyc3QtY2hpbGQnKS5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIChpc1ByZXNlbnQocm93SCkgJiYgcm93SCA+IDApID8gKGJyb3dzZXJIIC8gcm93SCkgKyAyMCA6IDUwO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUVsZW1lbnQgKGw6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IG51bWJlciA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QuaGVpZ2h0KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGwgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSB0ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSB3ICsgJ3B4JztcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGFwcGx5VHJhbnNmb3JtYXRpb24gKGV4cGFuZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB4LCB5LCB0eCwgdHk7XG4gICAgICAgIGlmIChleHBhbmQpIHtcbiAgICAgICAgICAgIHggPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgICB5ID0gd2luZG93LmlubmVySGVpZ2h0IC8gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB0eCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAvIDIgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoIC8gMlxuICAgICAgICAgICAgICAgIC0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0KSAvIHg7XG4gICAgICAgICAgICB0eSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLyAyIC0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgLyAyXG4gICAgICAgICAgICAgICAgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LnRvcCkgLyB5O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4ID0gMTtcbiAgICAgICAgICAgIHkgPSAxO1xuICAgICAgICAgICAgdHggPSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQ7XG4gICAgICAgICAgICB0eSA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID1cbiAgICAgICAgICAgICdzY2FsZVgoJyArIHggKyAnKSBzY2FsZVkoJyArIHkgKyAnKSB0cmFuc2xhdGUzZCgnICsgKHR4KSArICdweCwgJyArICh0eSkgKyAncHgsIDBweCknO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5pdEZ1bGxTY3JlZW4gKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgdGhpcy5zdXBwb3J0RnVsbFNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgc2V0IG9mIHNldCBvZiBjc3MgcHJvcGVydGllcyB0byBtYWtlIHRoZSBEVCBtYWluIGNvbXBvbmVudCBvbiB0aGUgcGFnZSBleHBhbmQgdG9cbiAgICAgKiBmdWxsIHBhZ2UgbW9kZSBhbmQgYmFja1xuICAgICAqXG4gICAgICogV2Ugd2FudCB0byBtYWtlIGl0IHdpdGggbGl0dGxlIGRlbGF5IHRvIGxldCBvdGhlciBhbmltYXRpb24gZmluaXNoXG4gICAgICovXG4gICAgdG9nZ2xlRnVsbFNjcmVlbk9uRFQgKGZ1bGxTY3JlZW46IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0LmVsLm5hdGl2ZUVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmNsYXNzTGlzdCArPSAnZHQtZnVsbC1zY3JlZW4nO1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0LmNsYXNzTGlzdCA9IHRoaXMuZHQuY2xhc3NMaXN0LnJlcGxhY2UoJ2R0LWZ1bGwtc2NyZWVuJyxcbiAgICAgICAgICAgICAgICAgICAgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSU5GSU5JVEUgU0NST0xMSU5HIE1FVEhPRFNcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgaW5maW5pdGUgc2Nyb2xsIGV2ZW50IGFuZCByZXF1ZXN0IG5ldyBkYXRhIGZyb20gZGF0YSBzb3VyY2VcbiAgICAgKlxuICAgICAqL1xuICAgIG9uTGF6eUxvYWQgKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoZXZlbnQuaXNMb2FkKSB7XG4gICAgICAgICAgICB0aGlzLmR0LnN0YXRlLm9mZnNldCA9IGV2ZW50Lm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LnN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkYXRhUHJvdmlkZXIgPSB0aGlzLmR0LmRhdGFTb3VyY2UuZGF0YVByb3ZpZGVyO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBkYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KGRhdGEuc2xpY2UoMCwgZXZlbnQub2Zmc2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gbG9hZGluZyBpcyBmaW5pc2hlZCBtYXJrIGxvYWRpbmcgaWNvbiBpcyBkb25lIHNvIHdlIGNhbiBoaWRlIGl0LiBJIGFtIHVzaW5nIGxpdHRsZVxuICAgICAqIGRlbGF5IHRvIG1ha2UgdGhlIGFuaW1hdGlvbiB2aXNpYmxlXG4gICAgICovXG4gICAgcHJpdmF0ZSBsb2FkaW5nRmluaXNoZWQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pbmZpbml0ZVNjcm9sbCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5pbmZpbml0ZVNjcm9sbC5jb21wbGV0ZSgpLCAyMDApO1xuXG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQge0FmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uSW5pdCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIHJlc3BvbnNpYmxlIGZvciBjaGVja2luZyBhbmQgc2V0dGluZyB0aGUgd2lkZXN0IGNvbnRlbnQgd2lkdGggb250b1xuICogQ29sdW1uIGNvbXBvbmVudCBhcyB0aGUgd2lkZXN0Q2VsbCBwcm9wZXJ0eS5cbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW21heFdpZHRoXSdcbn0pXG5leHBvcnQgY2xhc3MgU2V0Q2VsbE1heFdpZHRoRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0XG57XG5cbiAgICBASW5wdXQoKVxuICAgIG1heFdpZHRoOiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvciAocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIHRkOiBEVENvbHVtbjJDb21wb25lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG5cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5tYXhXaWR0aCkgJiYgdGhpcy5tYXhXaWR0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmxpbmVEYXRhID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWNvbC1jZWxsLWRhdGEnKTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQoaW5saW5lRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhLnN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgICAgICAgICBsZXQgY2VsbFdpZHRoID0gaW5saW5lRGF0YS5vZmZzZXRXaWR0aDsgLy8gdGRcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhLnN0eWxlLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgICAgICAgICAgICAgICBpbmxpbmVEYXRhLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0luVGhyZXNIb2xkKGNlbGxXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNlbGxXaWR0aCArPSB0aGlzLnRkUGFkZGluZygpO1xuICAgICAgICAgICAgICAgIGlmIChjZWxsV2lkdGggPiB0aGlzLnRkLndpZHRoUHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxXaWR0aCA8IHRoaXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbCA9IGNlbGxXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbCA/IGNlbGxXaWR0aCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbFdpZHRoID49IHRoaXMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbCA9IHRoaXMubWF4V2lkdGggPiB0aGlzLnRkLndpZGVzdENlbGwgPyB0aGlzLm1heFdpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRkLndpZGVzdENlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIHRoZSBuZXcgd2lkdGggdGhlIHNhbWUgYXMgdGhlIG9uZSBhbHJlYWR5IHNldCBvbiB0aGUgY29sdW1uPyBJZiB5ZXMgdGhlbiBwcm9iYWJseVxuICAgICAqIG5ldyBjb250ZW50IGRvZXMgbm90IGRpZmZlciB0aGF0IG11Y2guIFdlIHN0aWxsIGtlZXAgY2VydGFpbiB0aHJlc2hvbGQgYXMgdGhlIG5ldyBjb250ZW50XG4gICAgICogd2lkdGggbWlnaHQgZGlmZmVyIDEgb3IgMiBwaXhlcyBkZXBlbmRpbmcgaG93IHNldCB0aGUgY3NzLlxuICAgICAqXG4gICAgICogVG8gbWFrZSBzdXJlIHdlIHJlc2l6ZSBjb2x1bW4gb25seSBpZiBuZWNlc3NhcnkgYmVjYXVzZSBpdCBjb3VsZCBiZSBvcmlnaW5hbCBzaXplXG4gICAgICogaXMgNDAwcHggYnV0IHRoZSBuZXcgb25lIGlzIDQwMXB4IHNpbmNlIHNvbWV3aGVyZSBhZGQgc29tZSBleHRyYSBib3JkZXIgd2UgaGF2ZSB0aGlzXG4gICAgICogc2FmZSB0aHJlc2hvbGRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzSW5UaHJlc0hvbGQgKG5ld1dpZHRoOiBudW1iZXIpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy50ZC53aWRlc3RDZWxsID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMudGQud2lkZXN0Q2VsbCAtIG5ld1dpZHRoKSA+IDMgJiYgbmV3V2lkdGggPiB0aGlzLnRkLndpZGVzdENlbGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIHRkUGFkZGluZyAoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBsZXQgY2VsbCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nUmlnaHQpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJSaWdodFdpZHRoKSB8fCAwO1xuICAgICAgICBjZWxsICs9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyTGVmdFdpZHRoKSB8fCAwO1xuXG4gICAgICAgIC8vIHBsdXMgZ2l2ZSBpdCBzb21lIGxpdHRsZSBzcGFjZSBhcm91bmQgdGhlIHRleHQgc28gaXQgbm90cyBweCB0byBweCBpbm5lciB3aWR0aCBvZiB0aGUgdGRcbiAgICAgICAgLy8gY3V6IGl0IGNvdWxkIHdyYXBcbiAgICAgICAgY2VsbCArPSA1O1xuXG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuXG5pbXBvcnQge1xuICAgIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksXG4gICAgT25Jbml0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi4vLi4vLi4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RyYWdEaXJlY3Rpb24sIERyYWdFdmVudHMsIERyb3BQb3NpdGlvbn0gZnJvbSAnLi4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqIERpcmVjdGl2ZSB1c2VkIGluc2lkZSBEVCBpbiBvcmRlciB0byBzdXBwb3J0IHRhYmxlIHJvd3MgcmUtb3JkZXJpbmcuIFRoaXMgbWFuYWdlcyBhbGwgdGhlXG4gKiBEJkQgbmVjZXNzYXJ5IGxvZ2ljIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogW2R0RHJhZ2dhYmxlUm93XSBpcyB1c2VkIGluc2lkZSB0aGUgYHJvd1RlbXBsYXRlYCBsaWtlIHRoaXM6XG4gKlxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiA8bmctdGVtcGxhdGUgI3Jvd1RlbXBsYXRlIGxldC1yb3dEYXRhIGxldC1ldmVuPSdldmVudFwiIGxldC1vZGQ9XCJvZGRcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiXG4gKiAgICAgICAgICAgICAgbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1jb2xzVG9SZW5kZXI9XCJjb2xzVG9SZW5kZXJcIj5cbiAqXG4gKiAgICAgPHRyICNyb3dFbGVtZW50IGR0RHJhZ2dhYmxlUm93IFtkbmRSb3dJbmRleF09XCJyb3dJbmRleFwiXG4gKiAgICAgICAgICBjbGFzcz1cImR0LWJvZHktcm93XCJcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIHdoaWNoIGVuYWJsZWQgb3IgZGlzYWJsZXMgYmFzZWQgb24gdGhlIHVzZWQgRFQgYmluZGluZyBbZG5kUm93RW5hYmxlZF0uIEJ5IGRlZmF1bHQgaXRzIGRpc2FibGVkLlxuICpcbiAqXG4gKlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tkdERyYWdnYWJsZVJvd10nXG59KVxuZXhwb3J0IGNsYXNzIERURHJhZ2dhYmxlUm93RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUZWxscyB0aGUgZGlyZWN0aXZlIGlmIHdlIGVuYWJsZSBtaWRkbGUgcm93IHpvbmUgdG8gY3JlYXRlIGFuIGVmZmVjdCB0aGF0IHdlIGFyZSBkcm9wcGluZ1xuICAgICAqIGludG8gdGhlIHJvdy4gVXNlZCBmb3Igb3V0bGluZSBEVCBtYWlubHkuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRyb3BJbnRvRW5hYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBUUiBpbmRleCBudW1iZXJcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZG5kUm93SW5kZXg6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBvdXIgZHJhZ2dpbmcgZGlyZWN0aW9uIFVQIGFuZCBET1dOIGluIG9yZGVyIHRvIGFzc2lnbiBjb3JyZWN0IHN0eWxlXG4gICAgICogdGhhdCBoaWdobGlnaHRzIHRoZSByb3cgYXQgdGhlIHRvcCBvciBib3R0b21cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHJhZ0RpcjogRHJhZ0RpcmVjdGlvbiA9IERyYWdEaXJlY3Rpb24uTm9uZTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHdlIGRyYWdnZWQgb3VyIHJvdyBhbmQgc3RvcHBlZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBvdGhlciByb3dcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5NaWRkbGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ3VycmVudCBkcmFnIFkgY29vcmRpbmF0ZXMgd2hpY2ggaXMgdXNlZCB0b2dldGhlciB3aXRoIHRoZSBkcmFnRGlyIHdoZW4gYXNzaW5naW5nIGRyYWdnaW5nXG4gICAgICogZGlyZWN0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnWTogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIGxpc3RlbmVycyBoYW5kbGVycyBoZXJlIC0gdGhlIHJldHVybiBmcm9tIC5iaW5kKHRoaXMpLlxuICAgICAqL1xuICAgIHByaXZhdGUgZXZlbnRIYW5kbGVyczogeyBbbmFtZTogc3RyaW5nXTogYW55IH07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IERhdGF0YWJsZTJDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByaXZhdGUgZHQ6IERhdGF0YWJsZTJDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkb21VdGlsczogRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kdC5kbmRSb3dFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmR0LmRuZFJvd0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cHMgbGlzdGVuZXJzIGFuZCByZXR1cm5zIGhhbmRsZSB0byB0aGVtIHNvIHdlIGNhbiBsYXRlciBvbiB1bnN1YnNjcmliZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNldHVwRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydtb3VzZWRvd24nXSA9IHRoaXMub25Nb3VzZURvd25FdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ21vdXNlZG93biddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnc3RhcnQnXSA9IHRoaXMub25EcmFnU3RhcnRFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdzdGFydCddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnb3ZlciddID0gdGhpcy5vbkRyYWdPdmVyRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdvdmVyJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdsZWF2ZSddID0gdGhpcy5vbkRyYWdMZWF2ZUV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2xlYXZlJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2Ryb3AnXSA9IHRoaXMub25Ecm9wRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJvcCddKTtcblxuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnZW5kJ10gPSB0aGlzLm9uRHJhZ0VuZEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJyxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdlbmQnXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSBjcmVhdGVkIGxpc3RlbmVycyBpbnNpZGUgZGVzdHJveSgpIGNhbGxiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSByZWxlYXNlRXZlbnRMaXN0ZW5lcnMoKTogdm9pZCB7XG4gICAgICAgIERyYWdFdmVudHMuZm9yRWFjaCgobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCduYW1lJywgdGhpcy5ldmVudEhhbmRsZXJzW25hbWVdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgZmlyc3QgZXZlbnQgd2hlcmUgd2U6XG4gICAgICpcbiAgICAgKiAgLSBNYXJrIGVsZW1lbnQgZHJhZ2dhYmxlIHRvIGVuYWJsZSBEJkRcbiAgICAgKiAgLSBTZXQgY2xpY2sgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIG1pZGRsZSBvZiB0aGUgY3VycmVudCByb3dcbiAgICAgKiAgICAgIFRoaXMgaXMgbWFpbmx5IG5lZWRlZCB3aGVuIHdlIGFyZSB0cnlpbmcgdG8gY2FsY3VsYXRlIHNvbWV0aGluZyBmb3JcbiAgICAgKiAgICAgIGRyb3BJbnRvIHJvdyAob3V0bGluZSlcbiAgICAgKlxuICAgICAqIGV2ZW50LnRhcmdldCB1c3VhbGx5IGNvbnRhaW5zIHJlZmVyZW5jZSB0byBURCBlbGVtZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBvbk1vdXNlRG93bkV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSAmJiB0aGlzLmRvbVV0aWxzLmhhc1BhcmVudChldmVudC50YXJnZXQsICcuZHQtcm93LWRyYWdnYWJsZScpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGVsVG9CZURyYWdnZWQgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnZGRDbGlja0RldmlhbmNlJywgKGVsVG9CZURyYWdnZWQuaGVpZ2h0IC8gMikgLSBldmVudC5vZmZzZXRZKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2Vjb25kIHRyaWdnZXJlZCBldmVudCB3aGVuIHRoZSBhY3R1YWwgZHJhZ2dpbmcgc3RhcnRzLiBIZXJlIHdlIG5lZWQgdG8gZGlzYWJsZVxuICAgICAqIGRyYWdnZWQgcm93IGFuZCBzYXZlIGluZm9ybWF0aW9uIHRoYXQgYXJlIGNvbW1vbiB0byBhIHRhYmxlLlxuICAgICAqXG4gICAgICogTWFya2luZyByb3cgZGlzYWJsZWQgd2l0aCB0aGUgc3R5bGUgLmR0LXJvdy1kcmFnZ2luZyB1c2luZyBzZXRUaW1lb3V0IGlzIG5lZWRlZCBhc1xuICAgICAqIGlmIHdlIHdvdWxkIGdvIHdpdGhvdXQgaXQgdGhlbiBEJkQgZnJhbWV3b3JrIHdvdWxkIGNyZWF0ZSBhIGNvcHkgb2Ygcm93IGluIGRpc2FibGVkIHN0YXRlLlxuICAgICAqIE5vdyB3ZSBncmFiIGEgcm93IHdpdGggYWN0aXZlIHN0YXRlIGFuZCBhZnRlciBhIDIwMG1zIGRlbGF5IHdlIGRpc2FibGUgdGhlIG9yaWdpbmFsIHJvdy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnU3RhcnRFdmVudChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChldmVudC50YXJnZXQuY2xhc3NMaXN0KSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QuYWRkKCdkdC1yb3ctZHJhZ2dpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcblxuICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnaXNEcmFnZ2luZycsIHRydWUpO1xuICAgICAgICB0aGlzLmR0LmVudi5zZXRWYWx1ZSgnZG5kSWQnLCB0aGlzLmRuZFJvd0luZGV4KTtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoJ3RleHQnLCB0aGlzLmRuZFJvd0luZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZXZlbnRzIGhhcHBlbnMgYW55dGltZSBhcyB3ZSBkcmFnIG92ZXIgcm93cy4gVGhpcyBldmVudCB0cmlnZ2VyZWQgYWZ0ZXIgY2VydGFpblxuICAgICAqIGRlbGF5LiBJbiBoZXJlIHdlIGNhbGN1bGF0ZSB0aGUgbW91c2UgbW92ZW1lbnQgdG8gaWRlbnRpZnkgaWYgd2UgYXJlIGdvaW5nIFVQIG9yIERPV04uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG1haW5seSBuZWVkZWQgdG8gbWFyayBhIHJvdyB3aXRoIHRoZSBjb3JyZWN0IGxpbmUgb24gVE9QIG9yIEJPVFRPTSB0byB2aXN1YWxseVxuICAgICAqIHNob3cgYSB1c2VyIHdoZXJlIHdlIGFyZS5cbiAgICAgKlxuICAgICAqIE9uY2Ugd2Uga25vdyB0aGUgZGlyZWN0aW9uIGFuZCB0aGUgZHJvcCB0YXJnZXQgaXMgdmFsaWQgd2UgbWFyayB0aGUgcm93IHdpdGggY29ycmVjdCBjbGFzc1xuICAgICAqIHRoYXQgZG9lcyB0aGUgdHJpY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ092ZXJFdmVudChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICAgICAgICBpZiAodGhpcy5kcmFnWSA8IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLkRvd247XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kcmFnWSA+IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPSBEcmFnRGlyZWN0aW9uLlVwO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbnQgc2V0IGFnYWluIHVubGVzcyBpdHMgZGlmZmVyZW50XG4gICAgICAgIGlmICh0aGlzLmRyYWdZICE9PSBldmVudC5wYWdlWSkge1xuICAgICAgICAgICAgdGhpcy5kcmFnWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERyb3BUYXJnZXQoZXZlbnQpKSB7XG4gICAgICAgICAgICAvLyB0b2RvIHRlc3QgdGhpcyBwcmV2ZW50RGVmYXVsdCgpIHNvIGl0IGRvZXMgbm90IGNyZWF0ZSBzb21lIHNpZGVlZmZlY3RcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm1hcmtSb3dXaXRoQ2xhc3MoZXZlbnQsIHRoaXMuZG9tVXRpbHMuY2xvc2VzdChldmVudC50YXJnZXQsICd0cicpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZmluaXNoaW5nIGV2ZW50IGp1c3QgYmVmb3JlIEQmRCBpcyBkb25lLiBJdCB0YWtlcyBjdXJyZW50IGluZm9ybWF0aW9uIGFuZFxuICAgICAqIGJyb2FkY2FzdCB0aGVtIHRvIHRoZSBEVCBzbyBEVCBjYW4gZG8gbmVjZXNzYXJ5IHJvdyByZW9yZGVyaW5nXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25Ecm9wRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmNsZWFyQ2xhc3NlcyhldmVudC50YXJnZXQucGFyZW50RWxlbWVudCk7XG4gICAgICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbGV0IG9yaWdJbmR4ID0gdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIGxldCBkcm9wUG9zOiBEcm9wUG9zaXRpb24gPSB0aGlzLmluTWlkZGxlID8gRHJvcFBvc2l0aW9uLkludG8gOiAoXG4gICAgICAgICAgICB0aGlzLmRyYWdEaXIgPT09IERyYWdEaXJlY3Rpb24uVXAgPyBEcm9wUG9zaXRpb24uQmVmb3JlIDogRHJvcFBvc2l0aW9uLkFmdGVyXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuZHQub25EbkRSb3dEcm9wKG9yaWdJbmR4LCB0aGlzLmRuZFJvd0luZGV4LCBkcm9wUG9zKTtcblxuICAgICAgICB0aGlzLmluTWlkZGxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZHJhZ1kgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5IHRpbWUgd2UgZHJhZyBvdmVyIHRoZSBlbGVtZW50IHdlIGFwcGx5IHNvbWUgY2xhc3NlcyB0byB0aGUgaXQuIHRoaXMgbWV0aG9kIGRvZXMgdGhlXG4gICAgICogb3Bwb3NpdGUgd2hpY2ggaXMgdG8gcmVtb3ZlIGV2ZXJ5dGhpbmcgc28gd2UgYXJlIHJlYWR5IGZvciB0aGUgbmV4dCByb3dcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdMZWF2ZUV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRyID0gdGhpcy5kb21VdGlscy5jbG9zZXN0KGV2ZW50LnRhcmdldCwgJ3RyJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKHRyKTtcblxuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnZG5kT25Ib2xkSW5kZXgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbGFzdCBldmVudCB3aXRoaW4gRCZEIGZsb3cuIE1haW5seSB1c2VkIHRvIGNsZWFuIHVwIGFsbCB0aGUgcmVzb3VyY2UgdGhhdCBoYXMgbm90XG4gICAgICogYmVlbiBjbGVhbiB1cCBhbHJlYWR5IGluc2lkZSBvbkRyb3BFdmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnRW5kRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGV2ZW50LnRhcmdldC5jbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHQtcm93LWRyYWdnaW5nJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyQ2xhc3NlcyhldmVudC50YXJnZXQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2lzRHJhZ2dpbmcnKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIHRoaXMuZHQuZW52LmRlbGV0ZVZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbiBDU1MgY2xhc3NlcyB0byB0aGUgcm93IHRvIGNyZWF0ZSBhbiBoaWdobGlnaHRpbmcgZWZmZWN0IHRvIGNhcHR1cmUgY3VycmVudCBwb3NpdGlvblxuICAgICAqIGZvciB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEJhc2VkIG9uIHRoZSBEcmFnIGRpcmVjdGlvbiB3ZSBlaXRoZXIgYXBwbHlcbiAgICAgKiBjc3MgY2xhc3MgdGhhdCBjcmVhdGVzIGEgbGluZSBvbiB0b3Agb3IgYm90dG9tLiAgT25seSBmb3IgdGhlIGRyb3BJbnRvIGZ1bmN0aW9uYWxpdHkgd2VcbiAgICAgKiBuZWVkIHRvIGNhbGN1bGF0ZSBzb21lIG1vcmUgdG8gaWRlbnRpZnkgaWYgd2UgYXJlIHJlYWxseSBpbiB0aGUgbWlkZGxlIG9mIHRoZSByb3cuXG4gICAgICpcbiAgICAgKiBEcm9wSW50bzpcbiAgICAgKiAtLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIEluaXRpYWxseSB3ZSBjYXB0dXJlZCBhIHBvc2l0aW9uIChpbiBtb3VzZWRvd24pIHRoZSBkaXN0YW5jZSB0byB0aGUgbWlkZGxlIG9mIHRoZSByb3cgYW5kXG4gICAgICogdGhpcyB3ZSBhcmUgdXNpbmcgaGVyZSB3aXRoIHNvbWUgdGhyZXNob2xkIG9mIDIgcGl4ZXMgc28gd2UgZG9udCBoYXZlIHRvIGJlIGV4YWN0bHkgb24gcGl4ZWxcbiAgICAgKiBwZXJmZWN0LlxuICAgICAqXG4gICAgICogLSBsZXQgY3VycmVudFRyQ2VudGVyID0gdGhpcy5kb21VdGlscy5lbGVtZW50RGltZW5zaW9ucyhhY3RpdmVSb3cpLmhlaWdodCAvIDI7XG4gICAgICogICAgICBSZWFkIGNlbnRlciBvZiBjdXJyZW50IHJvd1xuICAgICAqXG4gICAgICogLSBsZXQgZHJhZ2dlZFRyQ2VudGVyID0gZXZlbnQub2Zmc2V0WSArIHRoaXMuZHQuZW52LmdldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnKTtcbiAgICAgKiAgICAgIFJlYWQgbW91c2UgY29vcmRpbmF0ZXMgcmVsYXRpdmUgdG8gY3VycmVudCByb3cvdGQgYW5kIGFkZCB0byBpdCBvdXIgZGV2aWF0aW9uLlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG1hcmtSb3dXaXRoQ2xhc3MoZXZlbnQ6IGFueSwgYWN0aXZlUm93OiBhbnkpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmNsZWFyQ2xhc3NlcyhhY3RpdmVSb3cpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIGRyYWcgaXRlbSBpcyBpbiB0aGUgbWlkZGxlIG9mIG90aGVyIHJvd1xuICAgICAgICBsZXQgY3VycmVudFRyQ2VudGVyID0gdGhpcy5kb21VdGlscy5lbGVtZW50RGltZW5zaW9ucyhhY3RpdmVSb3cpLmhlaWdodCAvIDI7XG4gICAgICAgIGxldCBkcmFnZ2VkVHJDZW50ZXIgPSBldmVudC5vZmZzZXRZICsgdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuXG4gICAgICAgIGlmICh0aGlzLmRyb3BJbnRvRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbk1pZGRsZSA9IE1hdGguYWJzKGN1cnJlbnRUckNlbnRlciAtIGRyYWdnZWRUckNlbnRlcikgPCAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW5NaWRkbGUpIHtcbiAgICAgICAgICAgIGFjdGl2ZVJvdy5jbGFzc0xpc3QuYWRkKERyYWdEaXJlY3Rpb24uTWlkZGxlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlUm93LmNsYXNzTGlzdC5hZGQodGhpcy5kcmFnRGlyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRHJvcCB0YXJnZXQgbXVzdCBiZSBvbmx5IGFub3RoZXIgVFIgYW5kIGl0IGNhbm5vdCBiZSB0aGUgZWxlbWVudCBpdHNlbGYgdGhlIG9uZSB3ZSBhcmVcbiAgICAgKiBkcmFnZ2luZyBhbmQgaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byBhbGxvdyB0byBkcm9wIHRvIHRoZSBzYW1lIHBvc2l0aW9uIHdlIHN0YXJ0ZWQgZnJvbVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc1ZhbGlkRHJvcFRhcmdldChldmVudDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBvcmlnSW54ID0gdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RuZElkJyk7XG4gICAgICAgIGxldCBzaWJsaW5nUm93ID0gdGhpcy5kbmRSb3dJbmRleCAtIG9yaWdJbng7XG5cbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50LnRhZ05hbWUgPT09ICdUUicgJiYgdGhpcy5kbmRSb3dJbmRleCAhPT0gb3JpZ0lueCAmJlxuICAgICAgICAgICAgIShzaWJsaW5nUm93ID09PSAxICYmIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5VcCkgJiZcbiAgICAgICAgICAgICEoc2libGluZ1JvdyA9PT0gLTEgJiYgdGhpcy5kcmFnRGlyID09PSBEcmFnRGlyZWN0aW9uLkRvd24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgY2xlYXJDbGFzc2VzKHRyOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdHIuY2xhc3NMaXN0LnJlbW92ZSgnZHQtZHJhZy1yb3ctdG9wJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5yZW1vdmUoJ2R0LWRyYWctcm93LWJvdHRvbScpO1xuICAgICAgICB0ci5jbGFzc0xpc3QucmVtb3ZlKCdkdC1kcmFnLXJvdy1ib3RoJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIHByaXZhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHJhZ0RpclRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5kcmFnRGlyKSB7XG4gICAgICAgICAgICBjYXNlIERyYWdEaXJlY3Rpb24uVXA6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVcCc7XG4gICAgICAgICAgICBjYXNlIERyYWdEaXJlY3Rpb24uRG93bjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Rvd24nO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05vdCBTdXJlJztcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7QVdPdXRsaW5lRm9yTW9kdWxlfSBmcm9tICcuLi9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtEVFdyYXBwZXJ9IGZyb20gJy4vdGFibGUtd3JhcHBlci90YWJsZS13cmFwcGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXSW5wdXRGaWVsZE1vZHVsZX0gZnJvbSAnLi4vaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlJztcbmltcG9ydCB7RFRIZWFkZXJDb21wb25lbnQyfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7RFREZXRhaWxSb3dDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL2RldGFpbC1yb3ctZXhwYW5kZXIvZHQtZGV0YWlsLXJvdy1leHBhbmRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL211bHRpLXNlbGVjdC9kdC1tdWx0aS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuaW1wb3J0IHtcbiAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25Nb2R1bGV9IGZyb20gJy4uL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlJztcbmltcG9ydCB7U2V0Q2VsbE1heFdpZHRoRGlyZWN0aXZlfSBmcm9tICcuL2RpcmVjdGl2ZXMvZHQtY2VsbC1kaXJlY3RpdmVzJztcbmltcG9ydCB7RFREcmFnZ2FibGVSb3dEaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9kdC1kcmFnZ2FibGUtcm93LmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRGF0YXRhYmxlMkNvbXBvbmVudCxcbiAgICAgICAgRFRXcmFwcGVyLFxuICAgICAgICBEVENvbHVtbjJDb21wb25lbnQsXG4gICAgICAgIERUSGVhZGVyQ29tcG9uZW50MixcbiAgICAgICAgRFREZXRhaWxSb3dDb21wb25lbnQsXG4gICAgICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQsXG4gICAgICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICBTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmUsXG4gICAgICAgIERURHJhZ2dhYmxlUm93RGlyZWN0aXZlXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZSxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBBV1JhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0lucHV0RmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBEVERldGFpbFJvd0V4cGFuZGVyQ29tcG9uZW50LFxuICAgICAgICBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50LFxuICAgICAgICBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEYXRhdGFibGUyQ29tcG9uZW50LFxuICAgICAgICBEVENvbHVtbjJDb21wb25lbnQsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgRFRIZWFkZXJDb21wb25lbnQyLFxuICAgICAgICBEVERldGFpbFJvd0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0RhdGF0YWJsZTJNb2R1bGVcbntcbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGNvbmZpcm1hdGlvbiBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIENvbmZpcm1hdGlvbkNvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY29uZmlybWF0aW9uLWhlYWRlcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnRcbntcbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gY29uZmlybWF0aW9uIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29uZmlybWF0aW9uQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24tZm9vdGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtNb2RhbENvbnRhaW5lcn0gZnJvbSAnLi4vLi4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLWNvbnRhaW5lcic7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQ29uZmlybWF0aW9uIENvbXBvbmVudCBpcyBhIHNwZWNpZmljIHZlcnNpb24gb2YgdGhlIGRpYWxvZyB3aGVyZSBpdCBzdXBwb3J0cyBjb25maXJtIGFuZCBjYW5jZWxcbiAqIGZ1bmN0aW9uYWxpdHkuIEl0IGJlaGF2ZXMgbGlrZSBhIGRpYWxvZywgaXMgbW9kYWwsIGFuZCBub3QgY2xvc2FibGUgYnkgZGVmYXVsdC5cbiAqXG4gKiBUaGVyZSBhcmUgdGhyZWUgdHlwZXMgb2YgcG9wdXAuXG4gKiAgIDEuICBhIHJlZ3VsYXIgZGlhbG9nIGJveCB0aGF0IGhhcyBoZWFkZXIsIGJvZHkgYW5kIGZvb3Rlci4gSXQncyB0aGUgbW9zdCBjdXN0b21pemFibGUuXG4gKiAgIDIuICBhIGNvbmZpcm1hdGlvbiBib3ggaXMgc2ltaWxhciB0byBhIGRpYWxvZyBib3ggYnV0IGhhcyBhY2NlcHQgYW5kIHJlamVjdCBhY3Rpb24gYnV0dG9ucy5cbiAqICAgMy4gIGEgb3ZlcmxheSwgd2hpY2ggaXMgYSB2ZXJ5IGJhc2ljIHBvcHVwIHdpdGggd2hhdCB5b3UgcHV0IGluc2lkZS5cbiAqICAgICAgIEl0IGRvZXNuJ3QgaGF2ZSBoZWFkZXIgYW5kIGZvb3Rlci5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gdXNlIGFueSBwb3B1cCBjb21wb25lbnQuXG4gKiAgIDEuICBFaXRoZXIgZGlyZWN0bHkgYnkgdXNpbmcgY29tcG9uZW50LCBhdy1kaWFsb2csIGF3LWNvbmZpcm1hdGlvbiBvciBhdy1vdmVybGF5XG4gKiAgIDIuICBvciB0aGUgTW9kYWxTZXJ2aWNlICBzZXJ2aWNlLm9wZW4oPENvbmZpcm1hdGlvbkNvbXBvbmVudD4pLCBzZXJ2aWNlLmNsb3NlKClcbiAqXG4gKiBVc2FnZTpcbiAqICAgIDEuICBVc2luZyBNb2RhbFNlcnZpY2UgZGlyZWN0bHkgdG8gZGlzcGxheSBhIG1vZGFsIHBvcHVwLiBUaGlzIHVzYWdlIGlzIGEgcXVpY2sgd2F5IHRvIHNob3dcbiAqICAgICAgICBhIGNvbmZpcm1hdGlvbiB0byB0aGUgdXNlci5cbiAqXG4gKiAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5vcGVuPENvbmZpcm1hdGlvbkNvbXBvbmVudD4oQ29uZmlybWF0aW9uQ29tcG9uZW50LCB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnQ29uZmlybWF0aW9uJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYCBBcmUgeW91IHN1cmUgPyBgLFxuICogICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMzAwLFxuICogICAgICAgICAgICAgICAgICAgICAgICBvbkNvbmZpcm06ICgpID0+IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiAoKSA9PiB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICB9KTtcbiAqXG4gKlxuICogICAyLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLlxuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1jb25maXJtYXRpb24gW3RpdGxlXT1cIidDb25maXJtYXRpb24nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKHZpc2libGUpXT1cImRpc3BsYXlcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uQ29uZmlybSk9XCJjb25maXJtQWN0aW9uKClcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25DYW5jZWwpPVwiY2FuY2VsQWN0aW9uKClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJzYXAtaWNvbiBpY29uLWFsZXJ0XCI+PC9pPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHlvdXIgaGFyZCBkcml2ZT9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctY29uZmlybWF0aW9uPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzaXplXT1cIidzbWFsbCdcIiAoY2xpY2spPVwib3BlbigpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wZW4gQ29uZmlybWF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgZXhwb3J0IGNsYXNzIE15UGFnZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBib29sZWFuID0gZmFsc2U7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjb25maXJtQWN0aW9uOiBzdHJpbmc7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgIG5nT25Jbml0KCkgeyB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBvcGVuKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSB0cnVlO1xuICogICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjb25maXJtQWN0aW9uKCkgIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uID0gXCJjb25maXJtZWRcIjtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICBjbG9zZSgpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IGZhbHNlO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbEFjdGlvbigpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24gPSBcImNhbmNlbGVkXCI7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgfVxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY29uZmlybWF0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDxhdy1kaWFsb2cgW3RpdGxlXT1cInRpdGxlXCIgWyh2aXNpYmxlKV09XCJ2aXNpYmxlXCJcbiAgICAgICAgICAgW21vZGFsXT1cInRydWVcIiBbY2xvc2FibGVdPVwiY2xvc2FibGVcIiBbd2lkdGhdPVwid2lkdGhcIiBbaGVpZ2h0XT1cImhlaWdodFwiXG4gICAgICAgICAgIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbYXBwZW5kVG9dPVwiYXBwZW5kVG9cIiAob25PcGVuKT1cIm9wZW4oKVwiIChvbkNsb3NlKT1cImNsb3NlKClcIj5cblxuICAgIDxhdy1kaWFsb2ctaGVhZGVyICpuZ0lmPVwiaGFzSGVhZGVyKClcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY29uZmlybWF0aW9uLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICA8L2F3LWRpYWxvZy1oZWFkZXI+XG5cbiAgICB7e2JvZHl9fVxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cblxuXG4gICAgPGF3LWRpYWxvZy1mb290ZXIgKm5nSWY9XCJoYXNGb290ZXIoKTsgZWxzZSBkZWZhdWx0Rm9vdGVyXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWNvbmZpcm1hdGlvbi1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9hdy1kaWFsb2ctZm9vdGVyPlxuXG4gICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0Rm9vdGVyPlxuICAgICAgICA8YXctZGlhbG9nLWZvb3Rlcj5cbiAgICAgICAgICAgIDxhdy1idXR0b24gbmFtZT1cImNvbmZpcm1cIiBbc3R5bGVdPVwiJ3ByaW1hcnknXCIgKGFjdGlvbik9XCJjb25maXJtKClcIj5cbiAgICAgICAgICAgICAgICB7e2NvbmZpcm1BY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuICAgICAgICAgICAgPGF3LWJ1dHRvbiBuYW1lPVwiY2FuY2VsXCIgW3N0eWxlXT1cIidzZWNvbmRhcnknXCIgKGFjdGlvbik9XCJjYW5jZWwoKVwiPlxuICAgICAgICAgICAgICAgIHt7Y2FuY2VsQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG5cbiAgICAgICAgPC9hdy1kaWFsb2ctZm9vdGVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbjwvYXctZGlhbG9nPlxuYCxcbiAgICBzdHlsZXM6IFtgLmNvbmZpcm1hdGlvbi1mb290ZXItc2VwYXJhdG9ye2JvcmRlci10b3A6MXB4IHNvbGlkICNkN2Q3ZDc7aGVpZ2h0OjE0cHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uQ29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXJcbntcbiAgICAvKipcbiAgICAgKiBUaXRsZSBmb3IgdGhlIERpYWxvZy4gIGlmIHRpdGxlIGFuZCAnVGl0bGVUZW1wbGF0ZScgYXJlIGJvdGggc2V0LCB0aXRsZVRlbXBsYXRlIHRha2VzXG4gICAgICogcHJlY2VkZW5jZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBCb2R5IHNlY3Rpb24gZm9yIERpYWxvZy4gQ2FsbGVyIHNob3VsZCB1c2UgZWl0aGVyIHRoZSBib2R5IHN0cmluZywgb3IgY29udGVudCBwcm9qZWN0aW9uXG4gICAgICogdG8gYWRkIHZhbHVlcyB0byB0aGUgZGlhbG9nLiBJZiBib3RoIGFyZSB1c2VkLCB0aGV5IHdpbGwgYm90aCBzaG93IHVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gT0sgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb25maXJtQWN0aW9uTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSBhcmUgbm90IHVzaW5nIGN1c3RvbSBidXR0b25zIHlvdSBjYW4gcGFzcyBhIGxhYmVsIHRvIENhbmNlbCBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNhbmNlbEFjdGlvbkxhYmVsOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHN1cHBvcnQgdHdvIHdheSBkYXRhIGJpbmRpbmcgb24gdmlzaWJsZSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2aXNpYmxlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlcmUncyBhbiB4IGF0IHRoZSB0b3AgcmlnaHQgdGhhdCBtYWtlcyB0aGUgZGlhbG9nIGNsb3NhYmxlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2xvc2FibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgZGlhbG9nLiBcImJvZHlcIiBvciBsb2NhbCBuZy10ZW1wbGF0ZSB2YXJpYWJsZSBhcmUgdmFsaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRUbzogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBkaWFsb2cgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgZGlhbG9nIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB1c2VyIGNsaWNrZWQgb24gY29uZmlybSBidXR0b24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Db25maXJtOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdXNlciBjbGlja2VkIG9uIGNhbmNlbCBidXR0b24uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DYW5jZWw6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogSGVhZGVyIGNvbXBvbmVudC4gVXN1YWxseSBjb250YWlucyB0aGUgdGl0bGUuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQpIGhlYWRlcjogQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogRGlhbG9nIGZvb3Rlci4gVXN1YWxseSBjb250YWlucyBidXR0b25zXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnQpIGZvb3RlcjogQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50O1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy53aWR0aCA9IDQwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgIC8vIFRvZG86IGludGVybmF0aW9uYWxpemUuXG4gICAgICAgIHRoaXMuY29uZmlybUFjdGlvbkxhYmVsID0gJ0NvbmZpcm0nO1xuICAgICAgICB0aGlzLmNhbmNlbEFjdGlvbkxhYmVsID0gJ0NhbmNlbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogb3BlbiBjb25maXJtYXRpb24uXG4gICAgICovXG4gICAgb3BlbigpXG4gICAge1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xvc2UgY29uZmlybWF0aW9uLlxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgpO1xuXG4gICAgICAgIC8vIEltcG9ydGFudCB0byBtYWtlIHN1cmUgY2hhbmdlIGlzIHNldCBvbiBwYXJlbnQgYmluZGluZy5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgdmFyaWFibGUgYW5kIGRpYWxvZyBvcGVuL2Nsb3NlIHN0YXRlIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2Ygc3luYyBhbmQgd2Ugd291bGRuJ3QgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLlxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgY29uZmlybWF0aW9uIGhhdmUgaGVhZGVyIGNvbnRlbnQ/XG4gICAgICovXG4gICAgaGFzSGVhZGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5oZWFkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhlIGNvbmZpcm1hdGlvbiBoYXZlIGZvb3RlciBjb250ZW50P1xuICAgICAqL1xuICAgIGhhc0Zvb3RlcigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZm9vdGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25maXJtIGFjdGlvbi5cbiAgICAgKi9cbiAgICBjb25maXJtKClcbiAgICB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5vbkNvbmZpcm0uZW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhY3Rpb24uXG4gICAgICovXG4gICAgY2FuY2VsKClcbiAgICB7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5vbkNhbmNlbC5lbWl0KCk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtDb25maXJtYXRpb25Db21wb25lbnR9IGZyb20gJy4vY29uZmlybWF0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7QVdEaWFsb2dNb2R1bGV9IGZyb20gJy4uL2RpYWxvZy9kaWFsb2cubW9kdWxlJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4uL2J1dHRvbi9idXR0b24ubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdEaWFsb2dNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgTW9kYWxDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NvbmZpcm1hdGlvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0LCBTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBDb250YWluZXIgcGFuZWwgcHJvdmlkaW5nIHNjcm9sbGluZyBmdW5jdGlvbmFsaXR5IGZvciBpdHMgY2hpbGRyZW4uIFlvdSBjYW4gY29uZmlndXJlIHRoaXNcbiAqIGNvbnRhaW5lciB0byBsZXQgaXQgdG8gc2Nyb2xsIGl0cyBjb250ZW50IGVpdGhlciBob3Jpem9udGFsbHksIHZlcnRpY2FsbHkgb3IgbGV0IHRoZSBjb250ZW50XG4gKiB3cmFwLlxuICpcbiAqXG4gKiBVc2FnZSBpcyBwcmV0dHkgc2ltcGxlOlxuICpcbiAqICAjIyMgRXhhbXBsZSB1c2luZyBob3Jpem9udGFsIHNjcm9sbCAoZGVmYXVsdCBiZWhhdmlvcik6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZT5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDE8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAzPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDQ8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA2PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDc8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgODwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA5PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICA8L2F3LXNjcm9sbGFibGU+XG4gKlxuICogIGBgYFxuICpcbiAqICAjIyMgRXhhbXBsZSB1c2luZyB2ZXJ0aWNhbCBzY3JvbGw6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZSBbZGlyZWN0aW9uXT1cIid2ZXJ0aWNhbCdcIiBbaGVpZ2h0XT1cIic0MHZoJ1wiPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAyPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDM8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNDwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA1PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDY8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA4PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDk8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgIDwvYXctc2Nyb2xsYWJsZT5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIyMjIEV4YW1wbGUgc2Nyb2xsaW5nIGlzIGRpc2FibGVkIGFuZCBjb250ZW50IHdyYXBzIGFuZCBjZW50ZXJzOlxuICpcbiAqICBgYGBcbiAqICAgICAgICAgICAgPGF3LXNjcm9sbGFibGUgW2RpcmVjdGlvbl09XCInbm9uZSdcIiBbYWxpZ25tZW50XT1cIidjZW50ZXInXCI+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAxPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDI8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA0PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDU8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA3PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDg8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgOTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgPC9hdy1zY3JvbGxhYmxlPlxuICogIGBgYFxuICpcbiAqICMjIyBIZWlnaHQgcHJvcGVydHk6XG4gKlxuICogV2hlbiB1c2luZyBcImhvcml6b250YWwgc2Nyb2xsaW5nXCIgaXQgc2V0IFwiZmxleGJveC1kaXJlY3Rpb25cIiB0byBcInJvd1wiIHdoZXJlIGhlaWdodFxuICogaXMgc2V0IGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gaXRzIGNvbnRlbnQuIFRoZSBoZWlnaHQgc2hvdWxkIGJlIGFsd2F5cyAxMDAlIHdoZW4gdXNpbmdcbiAqIHRoaXMgaW4gcGFyZW50IGNvbnRhaW5lci5cbiAqXG4gKiBJZiBcInZlcnRpY2FsIHNjcm9sbGluZ1wiIGlzIHVzZWQgeW91IG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQ6XG4gKiAgIC0geW91ciBwYXJlbnQgY29udGFpbmVyIHNldHMgdGhlIGJvdW5kYXJpZXMgd2l0aCBjb3JyZWN0bHkgc2V0IHdpZHRoIGFuZCBoZWlnaHRcbiAqICAgb3RoZXJ3aXNlIGl0IHdpbGwgdXNlIDEwMCUgb2YgdGhlIHZpZXdwb3J0XG4gKiAgIC0gaWYgdXNlZCBhcyBzdGFuZGFsb25lIHlvdSBuZWVkIHRvIGxpbWl0IHRoZSBoZWlnaHQgb3RoZXJ3aXNlIGl0IHdpbGwgZXhwYW5kIHRvIDEwMCUgb2ZcbiAqICAgdGhlIGRvY3VtZW50XG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNjcm9sbGFibGUnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctc2Nyb2xsYWJsZVwiIFtuZ0NsYXNzXT1cImxheW91dENsYXNzXCIgW3N0eWxlLndpZHRoXT1cIndpZHRoXCJcbiAgICAgW3N0eWxlLmhlaWdodF09XCJoZWlnaHRcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC53LXNjcm9sbGFibGV7ZGlzcGxheTpmbGV4O2Rpc3BsYXk6LXdlYmtpdC1mbGV4O2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47d2lsbC1jaGFuZ2U6b3ZlcmZsb3d9Lnctc2Nyb2xsYWJsZSAvZGVlcC8+KntmbGV4OjAgMCBhdXRvOy13ZWJraXQtZmxleDowIDAgYXV0bzstbXMtZmxleDowIDAgYXV0bzttYXJnaW46MTBweH0udS1zY3JvbGxhYmxlLWZoe2ZsZXgtZmxvdzpyb3cgbm93cmFwO292ZXJmbG93LXg6YXV0bztvdmVyZmxvdy15OmhpZGRlbn0udS1zY3JvbGxhYmxlLWZ2e2ZsZXgtZmxvdzpjb2x1bW4gbm93cmFwO292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6YXV0b30udS1zY3JvbGxhYmxlLWZie2ZsZXgtZmxvdzpyb3cgbm93cmFwO292ZXJmbG93LXg6YXV0bztvdmVyZmxvdy15OmF1dG99LnUtc2Nyb2xsYWJsZS1mdi1yb3d7ZmxleC1mbG93OnJvdyB3cmFwO292ZXJmbG93LXg6aGlkZGVuO292ZXJmbG93LXk6YXV0b30udS1zY3JvbGxhYmxlLWZue2ZsZXgtZmxvdzpyb3cgd3JhcH0udS1zY3JvbGxhYmxlLWFse2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0Oy13ZWJraXQtanVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnR9LnUtc2Nyb2xsYWJsZS1hcntqdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmQ7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6ZmxleC1lbmR9LnUtc2Nyb2xsYWJsZS1hY3tqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyOy13ZWJraXQtanVzdGlmeS1jb250ZW50OmNlbnRlcn0udS1zY3JvbGxhYmxlLWFqLC51LXNjcm9sbGFibGUtYWotYXJvdW5ke2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuOy13ZWJraXQtanVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59YF1cbn0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBzY3JvbGxpbmcgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluZXIgbWVhbmluZyB0ZWxscyB3aGljaCBvdmVyZmxvdyBheGllcyB3aWxsIGJlXG4gICAgICogZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgXCJob3Jpem9udGFsXCI6IEhlcmUgd2UgbG9jayBvdmVyZmxvdy15IGFuZCBvdmVyZmxvdy14IHNldCB0byBhdXRvLlxuICAgICAqXG4gICAgICogV2hlbiBzY3JvbGxpbmcgZGlyZWN0aW9uIGlzIFwidmVydGljYWxcIiBwbGVhc2UgbWFrZSBzdXJlIHlvdSBtYWludGFpbiBjb3JyZWN0IGhlaWdodCBhbmRcbiAgICAgKiB3aWR0aC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlyZWN0aW9uOiBTY3JvbGxpbmdEaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCc7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIGhvdyBmbGV4Ym94IGNvbnRhaW5lciBpdGVtcyBzaG91bGQgYmUgYWxpZ25lZC4gRGVmYXVsdCBiZWhhdmlvciBpcyBMRUZUXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsaWdubWVudDogQ29udGFpbmVySXRlbXNBbGlnbm1lbnQgPSAnbGVmdCc7XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIHByb3BlcnRpZXMgZm9yIGNhbGN1bGF0ZWQgY2xhc3MgbGlzdFxuICAgICAqL1xuXG4gICAgbGF5b3V0Q2xhc3M6IHN0cmluZztcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy53aWR0aCA9ICcxMDAlJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmluaXREZWZhdWx0KCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgd2UgcmUtaW5pdGlhbGl6ZSBkZWZhdWx0IHdoZW4gSW5wdXQgQmluZGluZ3MgY2hhbmdlc1xuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdERlZmF1bHQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZGVmYXVsdCB2YWx1ZXMgYW5kIENhbGN1bGF0ZXMgbGF5b3V0IGFuZCBhbGlnbm1lbnQgY2xhc3MuIFRoZSByZWFzb24gZm9yIHVzaW5nXG4gICAgICogdGhlc2UgdXRpbGl0eSBjbGFzc2VzIGlzIHRoYXQgd2UgY2FuIGNoYW5nZSB0aGUgYmVoYXZpb3IgYW55dGltZSBhcyBjb21wYXJlZCB0byB1c2luZ1xuICAgICAqIGRpcmVjdGx5IFtzdHlsZS54eHhdIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICogIyMjIERpcmVjdGlvbiBmbG93IGNsYXNzOlxuICAgICAqICAtIHUtc2Nyb2xsYWJsZS1mPGRpcmVjdGlvbj5cbiAgICAgKlxuICAgICAqICMjIyBBbGlnbm1lbnQgY2xhc3M6XG4gICAgICogIC0gdS1zY3JvbGxhYmxlLWE8YWxpZ25tZW50PlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0RGVmYXVsdCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1maCc7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZnYnO1xuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwtcm93Jykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZnYtcm93JztcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYm90aCcpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZiJztcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgKz0gJyB1LXNjcm9sbGFibGUtYScgKyB0aGlzLmFsaWdubWVudC5zdWJzdHJpbmcoMCwgMSk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0eWxlQ2xhc3MpKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzICs9IGAgJHt0aGlzLnN0eWxlQ2xhc3N9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkZWZhdWx0IHdpZHRoIGFuZCBoZWlnaHQgdG8gc29tZSB2YWx1ZSBpbiBjYXNlIHNvbWVib2R5IHBhc3NlcyBudWxsXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gJzEwMCUnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0hvcml6b250YWxTY3JvbGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LXNjcm9sbGFibGUnKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxXaWR0aCA+IHNjcm9sbENvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzVmVydGljYWxTY3JvbGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IHNjcm9sbENvbnRhaW5lciA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LXNjcm9sbGFibGUnKTtcbiAgICAgICAgcmV0dXJuIHNjcm9sbENvbnRhaW5lci5zY3JvbGxIZWlnaHQgPiBzY3JvbGxDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBTY3JvbGxpbmdEaXJlY3Rpb24gaXMgYSBuZXcgdHlwZSB0aGF0IGRyaXZlcyBzY3JvbGxpbmcgYmVoYXZpb3I6XG4gKiAgLSBob3Jpem9udGFsID0+IG92ZXJmbG93LXg6IGF1dG8sIG92ZXJmbG93LXk6aGlkZGVuXG4gKiAgLSB2ZXJ0aWNhbCA9PiBvdmVyZmxvdy14OiBoaWRkZW4sIG92ZXJmbG93LXk6YXV0b1xuICogIC0gdmVydGljYWwtcm93ID0+IG92ZXJmbG93LXg6IGhpZGRlbiwgb3ZlcmZsb3cteTphdXRvOyBmbG93OiByb3cgd3JhcFxuICogIC0gYm90aCA9PiBvdmVyZmxvdy14OiBhdXRvLCBvdmVyZmxvdy15OmF1dG9cbiAqICAtIG5vbmUgPT4gc2V0cyBmbG93LWZsb3cgdG8gcm93IHdyYXBcbiAqL1xuZXhwb3J0IHR5cGUgU2Nyb2xsaW5nRGlyZWN0aW9uID0gJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyB8ICd2ZXJ0aWNhbC1yb3cnIHwgJ2JvdGgnIHwgJ25vbmUnO1xuXG5cbi8qKlxuICpcbiAqIENvbnRyb2xzIHRoZSBqdXN0aWZ5LWNvbnRlbnQgcHJvcGVydHk6XG4gKlxuICogLSBsZWZ0ID0+IGZsZXgtc3RhcnRcbiAqIC0gcmlnaHQgPT4gZmxleC1lbmRcbiAqIC0gY2VudGVyID0+IGNlbnRlclxuICogLSBqdXN0aWZ5ID0+IHNwYWNlLWJldHdlZW5cbiAqXG4gKi9cbmV4cG9ydCB0eXBlIENvbnRhaW5lckl0ZW1zQWxpZ25tZW50ID0gJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInIHwgJ2p1c3RpZnknO1xuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1Njcm9sbGFibGVDb250YWluZXJDb21wb25lbnR9IGZyb20gJy4vc2Nyb2xsYWJsZS1jb250YWluZXIuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0xpc3Rib3gsIFNlbGVjdEl0ZW19IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0NoZWNrYm94Q29tcG9uZW50fSBmcm9tICcuLi9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQnO1xuXG5cbmV4cG9ydCBjb25zdCBMQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTGlzdENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbi8qKlxuICpcbiAqIFRoZSBMaXN0IGNvbXBvbmVudCByZXByZXNlbnQgYSBzdHJ1Y3R1cmUgd2hpY2ggY29udGFpbnMgYSBsaXN0IG9mIHNlbGVjdGFibGUgaXRlbXMuIEl0ZW1zXG4gKiBzZWxlY3Rpb24gY2FuIGJlIGNvbmZpZ3VyZWQgaW4gc2luZ2xlLXNlbGVjdGlvbiwgbXVsdGktc2VsZWN0aW9uIG9yIG11bHRpLXNlbGVjdGlvbiB3aXRoIHZpc2libGVcbiAqIGNoZWNrYm94ZXMgbW9kZS5cbiAqIEluIGFkZGl0aW9uIGl0IGNhbiBkaXNwbGF5IGRhdGEgaW5zaWRlIDMgem9uZXMgTEVGVCwgTUlERExFIGFuZCBSSUdIVCBpbiBvcmRlciB0byBwcm92aWRlXG4gKiBlYXN5IHdheSBmb3IgYXBwbGljYXRpb24gZGV2ZWxvcGVyIHRvIGxheW91dCBpdHMgb3duIGN1c3RvbSBjb250ZW50IG9yIGV2ZW4gY2hhbmdlIG91dCBvZiBib3hcbiAqIGJlaGF2aW9yLlxuICpcbiAqXG4gKiAgIyMjIEV4YW1wbGVzXG4gKlxuICogIDEuIFJlbmRlciBzaW1wbGUgc2luZ2xlIHNlbGVjdGlvbiBsaXN0XG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgICAgIDxhdy1saXN0IFtsaXN0XT1cImxpc3RcIj48L2F3LWxpc3Q+XG4gKlxuICogIGBgYFxuICogIDIuIFJlbmRlciBsaXN0IC0gbXVsdGkgc2VsZWN0aW9uIHdpdGggY3VzdG9tIFJJR0hUIGNvbnRlbnQgdG8gc2hvdyBhIENoZWNrTWFyayB3aGVuIGl0ZW1cbiAqICBpcyBzZWxlY3RlZFxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICA8YXctbGlzdCAjYXdsaXN0IFtsaXN0XT1cImxpc3RcIlxuICogICAgICAgICAgICAgICAgICAgICAgIGhlaWdodD1cIjE1MHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjI1MHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uTW9kZV09XCInbXVsdGknXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI3JpZ2h0IGxldC1pdGVtPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb25cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwieydpY29uLWFjY2VwdCc6IGF3bGlzdC5wTGlzdEJveC5pc1NlbGVjdGVkKGl0ZW0pLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgJyc6ICFhd2xpc3QucExpc3RCb3guaXNTZWxlY3RlZChpdGVtKX1cIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgIDwvYXctbGlzdD5cbiAqXG4gKiAgYGBgXG4gKlxuICogMy4gUmVuZGVyIGxpc3QgLSBtdWx0aSBzZWxlY3Rpb24gd2l0aCB2aXNpYmxlIGNoZWNrYm94ZXMgYW5kIGN1c3RvbSBNSURETEUgY29udGVudCB0byBjaGFuZ2VcbiAqICB0aGUgd2F5IGl0ZW0gbmFtZSBpcyByZW5kZXJlZFxuICpcbiAqXG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgIDxhdy1saXN0IFtsaXN0XT1cImxpc3RcIiBoZWlnaHQ9XCIxODBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg9XCIyMDBweFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJzZWxlY3Rpb25cIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25Nb2RlXT1cIidtdWx0aVdpdGhDaGVja2JveCdcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjbWlkZGxlIGxldC1pdGVtPlxuICogICAgICAgICAgICAgICAgICAgICAgWFgte3tpdGVtLnZhbHVlfX1cbiAqICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgIDwvYXctbGlzdD5cbiAqXG4gKiAgYGBgXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbGlzdCcsXG4gICAgdGVtcGxhdGU6IGA8cC1saXN0Ym94ICNsaXN0Ym94IFtvcHRpb25zXT1cImludGVybmFsTGlzdFwiIFttdWx0aXBsZV09XCJpc011bHRpcGxlXCIgW2NoZWNrYm94XT1cInNob3dDaGVja2JveFwiXG4gICAgICAgICAgIFsobmdNb2RlbCldPVwic2VsZWN0aW9uXCIgW2Rpc2FibGVkXT1cImRpc2FibGVkXCIgW3N0eWxlXT1cImxpc3RTdHlsZVwiIFtzaG93VG9nZ2xlQWxsXT1cImZhbHNlXCJcbiAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uSXRlbVNlbGVjdGVkKCRldmVudClcIiAob25EYmxDbGljayk9XCJhY3Rpb24uZW1pdCgkZXZlbnQudmFsdWUpXCJcbiAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiPlxuXG5cbiAgICA8bmctdGVtcGxhdGUgbGV0LWl0ZW0gcFRlbXBsYXRlPVwiaXRlbVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidy1saS13cmFwcGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy1saS1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaGFzTGVmdFRlbXBsKCk7IGVsc2UgZGVmYXVsdExlZnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJsWm9uZVRlbXBsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGl0ZW19XCI+PC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0TGVmdD5cbiAgICAgICAgICAgICAgICAgICAgPGF3LWNoZWNrYm94ICNjaGVjayAqbmdJZj1cImlzTXVsdGlwbGUgJiYgc2hvd0NoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImxpc3Rib3guaXNTZWxlY3RlZChpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiYWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhY3Rpb24pPVwiaXRlbUNsaWNrZWQoJGV2ZW50LCBpdGVtLCBjaGVjaylcIj5cbiAgICAgICAgICAgICAgICAgICAgPC9hdy1jaGVja2JveD5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LWxpLW1pZGRsZVwiIChjbGljayk9XCJpdGVtQ2xpY2tlZCgkZXZlbnQsIGl0ZW0sIG51bGwpXCI+XG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJoYXNNaWRkbGVUZW1wbCgpOyBlbHNlIGRlZmF1bHRNaWRkbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldF09XCJtWm9uZVRlbXBsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGl0ZW19XCI+PC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdE1pZGRsZT5cbiAgICAgICAgICAgICAgICAgICAge3tpdGVtLmxhYmVsfX1cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInctbGktcmlnaHRcIiAqbmdJZj1cImhhc1JpZ2h0VGVtcGwoKVwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJyWm9uZVRlbXBsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGl0ZW19XCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvbmctdGVtcGxhdGU+XG48L3AtbGlzdGJveD5cbmAsXG4gICAgc3R5bGVzOiBbYDo6bmctZGVlcCAudWktbGlzdGJveC1pdGVtPi51aS1jaGtib3h7ZGlzcGxheTpub25lfTo6bmctZGVlcCAudWktbGlzdGJveC1pdGVtIC51aS1jaGtib3h7bWFyZ2luLXJpZ2h0OjFlbX0udy1saS13cmFwcGVye2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpmbGV4LXN0YXJ0fS53LWxpLXdyYXBwZXIgLnctbGktbGVmdCwudy1saS13cmFwcGVyIC53LWxpLXJpZ2h0e2ZsZXg6MCAxIGF1dG99LnctbGktd3JhcHBlciAudy1saS1taWRkbGV7ZmxleDoxIDEgYXV0b31gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgTEJfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMaXN0Q29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIExpc3RDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBvcHRpb24gdGhhdCB3aWxsIHNob3cgaW4gdGhlIGxpc3QuIFBsZWFzZSBub3QgdGhhdCB0aGlzIGxpc3QgaXMgY3VycmVudCB1c2VkIHRvXG4gICAgICogc2hvdyBsaW1pdGVkIG51bWJlciBvZiBpdGVtcy4gSXQgZG9lcyBub3QgaGF2ZSBhbnkgc2Nyb2xsaW5nIGZlYXR1cmUgYW5kIGxhenkgbG9hZGluZ1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEl0ZW1zIHdoaWNoIHdhcyBzZWxlY3RlZCBhcyBhIGRlZmF1bHQgdmFsdWVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb246IGFueTtcblxuICAgIC8qKlxuICAgICAqIENvbXBvbmVudCByZWNvZ25pemVzIDMgbW9kZXM6IHNpbmdsZSwgbXVsdGksIG11bHRpIHdpdGggdmlzaWJsZSBjaGVja2JveGVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlID0gJ3NpbmdsZSc7XG5cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHRlciB1c2VkIHRvIGZvcm1hdCBlYWNoIHNlbGVjdGlvbiBmb3IgZGlzcGxheS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWVUcmFuc2Zvcm1lcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFVzZWQgd2hlbiBkZWFsaW5nIHdpdGggb2JqZWN0IHRvIGlkZW50aWZ5IHNwZWNpZmljIGZpZWxkIG9uIHRoZSBvYmplY3QgZm9yY29tcGFyaXNvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZmllbGQ6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRG9uJ3QgcmVuZGVyIExpc3Rib3ggYm9yZGVyLiBVc2VkIGZvciBlbWJlZGRpbmcgdGhpcyBpbnNpZGUgb3RoZXIgY29tcG9uZW50c1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib3JkZXJsZXNzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiB3ZSBkb3VibGUgY2xpY2sgb24gdGhlIGxpc3QgSXRlbVxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNlbGVjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2Ugd2FudCB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yIG9yIExlZnQgem9uZS4gV2UgZXhwb3NlIHRoaXMgbGlzdEJveCBpbiBvcmRlciB0b1xuICAgICAqIGhhdmUgYWNjZXNzIHByaW1lTmcgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdsaXN0Ym94JylcbiAgICBwTGlzdEJveDogTGlzdGJveDtcblxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHRlbXBsYXRlcyB0byBvdmVycmlkZSBkZWZhdWx0IGJlaGF2aW9yLiBUaGUgbGlzdCBpdGVtIGlzIGRpdmlkZWQgaW50byAzIHpvbmVzXG4gICAgICpcbiAgICAgKlxuICAgICAqICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiAgfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gICAgICogIHwgICBMICAgfCAgICAgICAgICAgICBNICAgICAgICAgICAgICAgICAgICAgfCAgIFIgICAgfFxuICAgICAqICB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAgICAgKiAgfCAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICB8XG4gICAgICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdsZWZ0JylcbiAgICBsWm9uZVRlbXBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQENvbnRlbnRDaGlsZCgnbWlkZGxlJylcbiAgICBtWm9uZVRlbXBsOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQENvbnRlbnRDaGlsZCgncmlnaHQnKVxuICAgIHJab25lVGVtcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbFxuICAgICAqL1xuICAgIGludGVybmFsTGlzdDogU2VsZWN0SXRlbVtdO1xuXG4gICAgbGlzdFN0eWxlOiB7W25hbWU6IHN0cmluZ106IGFueX0gPSB7fTtcblxuICAgIGlzTXVsdGlwbGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93Q2hlY2tib3g6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEJhc2VGb3JtQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpJyB8fFxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGlXaXRoQ2hlY2tib3gnO1xuICAgICAgICB0aGlzLnNob3dDaGVja2JveCA9IHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ211bHRpV2l0aENoZWNrYm94JztcblxuICAgICAgICAvLyBjYW5ub3QgaGF2ZSBib3RoIGVpdGhlciB3ZSB1c2UgZmllbGQgdG8gZ2V0IGRpc3BsYXkgdmFsdWUgb3IgdmFsdWVUcmFuc2Zvcm1lclxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmllbGQpICYmIGlzUHJlc2VudCh0aGlzLnZhbHVlVHJhbnNmb3JtZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW4gaGF2ZSBlaXRoZXIgW2ZpZWxkXSBvciBbdmFsdWVUcmFuc2Zvcm1lcl0uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdExpc3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBbbGlzdF0gYmluZGluZy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsc28gYWRkIG92ZXJmbG93WSB0byBtYWtlIHN1cmUgaXQgY2FuIHNjcm9sbCBhbmQgZG9lcyBub3QgZXhwYW5kIGJhc2VkIG9uIGl0cyBjb250ZW50XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5oZWlnaHQpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnaGVpZ2h0J10gPSB0aGlzLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWydvdmVyZmxvdy15J10gPSAnYXV0byc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnd2lkdGgnXSA9IHRoaXMud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5ib3JkZXJsZXNzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RTdHlsZVsnYm9yZGVyLWNvbG9yJ10gPSAndHJhbnNwYXJlbnQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMuc2VsZWN0aW9uKTtcblxuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNpbmNlIHdlIGFyZSB1c2luZyA8YXctY2hlY2tib3g+IHdlIG5lZWQgdG8gaGF2ZSBjdXN0b20gaGFuZGxpbmcgYm90aCB3aGVuIGNsaWNraW5nIG9uIHRoZVxuICAgICAqIGNoZWNrYm94IGFzIHdlbGwgYXMgaXRlbSB0ZXh0LlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBpdGVtQ2xpY2tlZChldmVudDogYW55LCBpdGVtOiBhbnksIGNoZWNrYm94OiBDaGVja2JveENvbXBvbmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hlY2tib3gpKSB7XG4gICAgICAgICAgICB0aGlzLnBMaXN0Qm94Lm9uQ2hlY2tib3hDbGljayhldmVudCwgaXRlbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5wTGlzdEJveCkpIHtcbiAgICAgICAgICAgIHRoaXMucExpc3RCb3gub25PcHRpb25DbGljayhldmVudCwgaXRlbSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNSaWdodFRlbXBsKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5yWm9uZVRlbXBsKTtcbiAgICB9XG5cbiAgICBoYXNMZWZ0VGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmxab25lVGVtcGwpO1xuICAgIH1cblxuXG4gICAgaGFzTWlkZGxlVGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLm1ab25lVGVtcGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcmVkIGJ5IHAtbGlzdGJveCBjb21wb25lbnQgd2hlbiBpdGVtIGlzIHNlbGVjdGVkLiBXaGVuIHN0YXRlIGlzIG1hbmFnZWQgaW50ZXJuYWxseVxuICAgICAqIHdlIGFsc28gdXBkYXRlIEZvcm1Db250cm9sIG1vZGVsLlxuICAgICAqXG4gICAgICovXG4gICAgb25JdGVtU2VsZWN0ZWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGV2ZW50LnZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KGV2ZW50LnZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKGV2ZW50LnZhbHVlLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZChldmVudC52YWx1ZSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCFlcXVhbHModmFsdWUsIHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyBleHRlcm5hbCBmb3JtIG9mIHRoZSBsaXN0IGludG8gUHJpbWVORyBleHBlY3RlZCBmb3JtYXQgd2hlcmUgaXQgdXNlc1xuICAgICAqIFNlbGVjdGlvbkl0ZW0gaW50ZXJmYWNlXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0TGlzdCgpXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gdGhpcy5saXN0Lm1hcCgoaXRlbTogYW55KSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiB7bGFiZWw6IHRoaXMuZGlzcGxheVZhbHVlKGl0ZW0pLCB2YWx1ZTogaXRlbX07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIEdlbmVyYXRlcyBsYWJlbCB2YWx1ZSBmb3IgdGhlIGxpc3QgYm94LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkaXNwbGF5VmFsdWUoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHZhbCA9IGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZpZWxkKSkge1xuICAgICAgICAgICAgdmFsID0gaXRlbVt0aGlzLmZpZWxkXTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnZhbHVlVHJhbnNmb3JtZXIpKSB7XG4gICAgICAgICAgICB2YWwgPSB0aGlzLnZhbHVlVHJhbnNmb3JtZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59XG5cbi8qKlxuICogTGlzdCBzdXBwb3J0IHRoZXNlIHRocmVlIHNlbGVjdGlvbiBtb2Rlc1xuICpcbiAqL1xuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdzaW5nbGUnIHwgJ211bHRpJyB8ICdtdWx0aVdpdGhDaGVja2JveCc7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0xpc3Rib3hNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0xpc3RDb21wb25lbnR9IGZyb20gJy4vbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuLi9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBMaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIExpc3Rib3hNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGVcblxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTGlzdENvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdMaXN0TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7T3ZlcmxheVBhbmVsfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogT3ZlcmxheSBDb21wb25lbnQgaXMgYSBzaW1wbGUgdmVyc2lvbiBvZiB0aGUgZGlhbG9nIHdoZXJlIHRoZXJlJ3Mgb25seSBjb250ZW50LlxuICogT3ZlcmxheSB3aWxsIGFwcGVhciBhdCB0aGUgcG9zaXRpb24gd2hlcmUgdGhlIGFjdGlvbiBwZXJmb3JtZWQgdHJpZ2dlciBhbiBvdmVybGF5LlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBwb3B1cC5cbiAqICAgMS4gIGEgcmVndWxhciBkaWFsb2cgYm94IHRoYXQgaGFzIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyLiBJdCdzIHRoZSBtb3N0IGN1c3RvbWl6YWJsZS5cbiAqICAgMi4gIGEgY29uZmlybWF0aW9uIGJveCBpcyBzaW1pbGFyIHRvIGEgZGlhbG9nIGJveCBidXQgaGFzIGFjY2VwdCBhbmQgcmVqZWN0IGFjdGlvbiBidXR0b25zLlxuICogICAzLiAgYSBvdmVybGF5LCB3aGljaCBpcyBhIHZlcnkgYmFzaWMgcG9wdXAgd2l0aCB3aGF0IHlvdSBwdXQgaW5zaWRlLlxuICogICAgICAgSXQgZG9lc24ndCBoYXZlIGhlYWRlciBhbmQgZm9vdGVyLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgYW55IHBvcHVwIGNvbXBvbmVudC5cbiAqICAgMS4gIEVpdGhlciBkaXJlY3RseSBieSB1c2luZyBjb21wb25lbnQsIGF3LWRpYWxvZywgYXctY29uZmlybWF0aW9uIG9yIGF3LW92ZXJsYXlcbiAqICAgMi4gIG9yIHRoZSBNb2RhbFNlcnZpY2UgIHNlcnZpY2Uub3Blbig8T3ZlcmxheUNvbXBvbmVudD4pLCBzZXJ2aWNlLmNsb3NlKClcbiAqXG4gKiBVc2FnZTpcbiAqICAgIDEuICBVc2luZyBNb2RhbFNlcnZpY2UgZGlyZWN0bHkgdG8gZGlzcGxheSBhIG1vZGFsIHBvcHVwLiBUaGUgdXNhZ2UgaXMgYSBsaXR0bGUgdHJpY2t5XG4gKiAgICAgICAgYmVjYXVzZSBhbmd1bGFyIGN1cnJlbnRseSBkb2Vzbid0IHN1cHBvcnQgZHluYW1pYyBjb250ZW50IHByb2plY3Rpb24uXG4gKlxuICogICAgICAgICAgbGV0IG92ZXJsYXkgPSB0aGlzLm1vZGFsU2VydmljZS5vcGVuPE92ZXJsYXlDb21wb25lbnQ+KE92ZXJsYXlDb21wb25lbnQsIHt9KTtcbiAqXG4gKiAgICAgICAgICAgIC8vIEFkZCBjb250ZW50LiBUaGVyZSdzIG5vdCBzdXBwb3J0IGZvciBkeW5hbWljIGNvbnRlbnQgcHJvamVjdGlvbiB5ZXQuXG4gKiAgICAgICAgICAgIC8vIFNvIGhhdmUgYWRkIGNvbnRlbnQgZGlyZWN0bHkuXG4gKiAgICAgICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHRoZSBiZXN0IHdheS5cbiAqICAgICAgICAgIG92ZXJsYXkuaW5zdGFuY2Uub3ZlcmxheS5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCIudWktb3ZlcmxheXBhbmVsLWNvbnRlbnRcIilcbiAqICAgICAgICAgICAgICAgLmlubmVySFRNTCA9IGA8aW1nIHN0eWxlPSd3aWR0aDozMDBweDsnIHNyYz1cInNhbGVzLnBuZ1wiIGFsdD1cIlNhbGVzIENoYXJ0XCIgLz5gO1xuICpcbiAqICAgICAgICAgIC8vIGRlbGF5IHRoZSBvcGVuaW5nIGFmdGVyIG5nIGxpZmVjeWNsZSBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAqICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyBvdmVybGF5Lmluc3RhbmNlLm9wZW4oZXZlbnQpOyB9LCAxKTtcbiAqXG4gKlxuICogICAyLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLlxuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LW92ZXJsYXkgI292ZXJsYXkgKG9uT3Blbik9XCJvdmVybGF5QWN0aW9uPSdvcGVuJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uQ2xvc2UpPVwib3ZlcmxheUFjdGlvbj0nY2xvc2UnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJzYWxlcy5wbmdcIiBhbHQ9XCJDaGFydFwiLz5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LW92ZXJsYXk+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIChjbGljayk9XCJvdmVybGF5Lm9wZW4oJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPcGVuIE92ZXJsYXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXlBY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqICAgICAgIH1cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW92ZXJsYXknLFxuICAgIHRlbXBsYXRlOiBgPHAtb3ZlcmxheVBhbmVsIFtkaXNtaXNzYWJsZV09XCJkaXNtaXNzYWJsZVwiIFtzaG93Q2xvc2VJY29uXT1cInNob3dDbG9zZUljb25cIlxuICAgICAgICAgICAgICAgIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbYXBwZW5kVG9dPVwiYXBwZW5kVG9cIlxuICAgICAgICAgICAgICAgIChvbkFmdGVySGlkZSk9XCJvbkNsb3NlZCgkZXZlbnQpXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9wLW92ZXJsYXlQYW5lbD5cbmAsXG4gICAgc3R5bGVzOiBbYDo6bmctZGVlcCAudWktb3ZlcmxheXBhbmVse2JvcmRlcjoxcHggc29saWQgI2Q3ZDdkNztib3gtc2hhZG93OjAgMnB4IDRweCAwIHJnYmEoMCwwLDAsLjIpfTo6bmctZGVlcCAudWktb3ZlcmxheXBhbmVsLWNvbnRlbnR7cGFkZGluZzoyZW0gMy40ZW0gLjZlbSAxLjQzZW19OjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWwtY2xvc2V7Ym9yZGVyLXJhZGl1czowO3RvcDouNWVtO3JpZ2h0Oi41ZW19OjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWwtY2xvc2UudWktc3RhdGUtZGVmYXVsdHtib3JkZXI6bm9uZX1gXVxufSlcbmV4cG9ydCBjbGFzcyBPdmVybGF5Q29tcG9uZW50IGV4dGVuZHMgTW9kYWxDb250YWluZXIgaW1wbGVtZW50cyBPbkluaXRcbntcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGhpZGUgb3ZlcmxheSB3aGVuIG91dHNpZGUgaXMgY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRpc21pc3NhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBjbG9zZSBpY29uICd4JyBhdCB0b3Agb2YgcmlnaHQgY29ybmVyLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0Nsb3NlSWNvbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRhcmdldCBlbGVtZW50IHRvIGF0dGFjaCB0aGUgb3ZlcmxheS4gXCJib2R5XCIgb3IgbG9jYWwgbmctdGVtcGxhdGUgdmFyaWFibGUgYXJlIHZhbGlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kVG86IGFueTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gb3ZlcmxheSBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBvdmVybGF5IGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbk9wZW46IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVybmFsIG92ZXJsYXkgcGFuZWwuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZChPdmVybGF5UGFuZWwpXG4gICAgb3ZlcmxheTogT3ZlcmxheVBhbmVsO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbiBPdmVybGF5XG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgb3BlbihldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnNob3coZXZlbnQpO1xuICAgICAgICB0aGlzLm9uT3BlbmVkKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIE92ZXJsYXlcbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICB0aGlzLm92ZXJsYXkuaGlkZSgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogdG9nZ2xlIG9wZW4gYW5kIGNsb3NlLlxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIHRvZ2dsZShldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vdmVybGF5LnRvZ2dsZShldmVudCk7XG4gICAgfVxuXG5cbiAgICBvbk9wZW5lZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdChldmVudCk7XG4gICAgfVxuXG4gICAgb25DbG9zZWQoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KGV2ZW50KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBJbnB1dCxcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdmVybGF5Q29tcG9uZW50fSBmcm9tICcuLi9vdmVybGF5L292ZXJsYXkuY29tcG9uZW50JztcblxuXG4vKipcbiAqIERlZmluZXMgd2hlcmUgdGhlIENhcmQgaXMgcG9zaXRpb25lZC4gSXQgY2FuIGJlIGVpdGhlcjpcbiAqICAgIC0gYWJvdmUgdGhlIHRyaWdnZXJpbmcgbGlua1xuICogICAgLSB1bmRlciB0aGUgdHJpZ2dlcmluZyBsaW5rXG4gKiAgICAtIGNvbXBsZXRlbHkgb24gdG9wIG9mIGl0IC0gY292ZXJpbmcgaXQuIEZvciB0aGlzIGNhc2UgdGhlcmUgaXMgbm9uZSBhcyBubyBzdHlsZSBpcyBhcHBsaWVkXG4gKi9cbmV4cG9ydCBlbnVtIEhDQ2FyZFBvc2l0aW9uIHtcbiAgICB0b3AsXG4gICAgYm90dG9tLFxuICAgIG5vbmVcbn1cblxuLyoqXG4gKiBEZWZpbmVzIHdoZXJlIHRoZSBDYXJkIGlzIHBvc2l0aW9uZWQgYnkgZGVmYXVsdC4gTWVhbmluZyB3aGVyZSBwcmltZU5HIGNvZGUgcHV0IGl0LlxuICpcbiAqIFdoZW4gdGhlcmUgaXMgYWxsb3Qgb2Ygc3BhY2Ugb24gdGhlIHNpZGVzID49ICAoTGVmdCBvciBSaWdodCkgaXMgdXNlZFxuICogKHBhZGRlZExlZnQsIHBhZGRlZFJpZ2h0KSBvdGhlcndpc2UuIFdoZW4gdGhlcmUgaXMgbm90IG11Y2ggc3BhY2UgYW5kIGNhcmQgY29udGFpbmVyXG4gKiAgaXMgbm90IGFsaWduZWQgKGxlZnQsIHJpZ2h0KSB3aXRoIHRoZSB0cmlnZXJpbmcgaWNvbiBidXQgaXQgaXMgc2hpZnRlZCB0byBmaXQgaW50byB0aGUgc2NyZWVuXG4gKi9cbmVudW0gSENDYXJkQWxpZ25tZW50IHtcbiAgICBsZWZ0LFxuICAgIHBhZGRlZExlZnQsXG4gICAgcmlnaHQsXG4gICAgcGFkZGVkUmlnaHQsXG4gICAgZGVmYXVsdFxufVxuXG4vKipcbiAqIE1hcHMgcG9zaXRpb24gdG8gc3R5bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIENhcmQgY29udGFpbmVyLiBUaGlzIGlzIGp1c3QgdG8gbWFrZSBpdCBlYXNpZXJcbiAqIGFzIHdlIGFyZSB3b3JraW5nIHdpdGggZW51bWVyYXRpb25zIGFuZCBoYXZlIGFscmVhZHkgZW51bSB0eXBlLlxuICpcbiAqIHUtaGMtYXJyb3ctYjogQXJyb3cgd2lsbCBhcHBlYXIgYXQgdGhlIGJvdHRvbVxuICogdS1oYy1hcnJvdy10OiBBcnJvdyB3aWxsIGFwcGVhciBhdCB0aGUgdG9wXG4gKlxuICogdS1oYy1zaGFkb3ctdDogQm9yZGVyIHNoYWRvdyB3aWxsIGFwcGVhciBhdCB0aGUgdG9wXG4gKiB1LWhjLXNoYWRvdy1iOiBCb3JkZXIgc2hhZG93IHdpbGwgYXBwZWFyIGF0IHRoZSBib3R0b21cbiAqL1xuY29uc3QgUG9zaXRpb25Ub1N0eWxlID0ge1xuICAgIHRvcDogJyB3LWhjLXBhbmVsLWFycm93IHUtaGMtYXJyb3ctYiB1LWhjLXNoYWRvdy10JyxcbiAgICBib3R0b206ICcgdy1oYy1wYW5lbC1hcnJvdyB1LWhjLWFycm93LXQgdS1oYy1zaGFkb3ctYicsXG4gICAgbm9uZTogJydcbn07XG5cblxuLyoqXG4gKlxuICogTWFwcyBhbGlnbmVkIENhcmQgY29udGFpbmVyIHRvIGN1c3RvbSBzdHlsZXMgaW4gb3JkZXIgdG8gYXBwbHkgY29ycmVjdCBhcnJvd1xuICpcbiAqIC1sbDogU3RhbmRzIGZvciBMYXJnZSBMZWZ0IChsYXJnZTogdGhlcmUgaXMgcGxlbnR5IG9mIHNwYWNlIGFyb3VuZCApXG4gKiAtbHI6IFN0YW5kcyBmb3IgTGFyZ2UgcmlnaHRcbiAqIC1zbDogU3RhbmRzIGZvciBTbWFsbCBsZWZ0IChTbWFsbCBhbmQgcmVzaXplZCBzY3JlZW4gd2hlcmUgd2UgdHJ5IHRvIGZpdCBjYXJkIGNvbnRhaW5lclxuICogc29tZXdoZXJlIGluIGJldHdlZW4pXG4gKiAtc3I6IFN0YW5kcyBmb3IgTGFyZ2UgcmlnaHRcbiAqXG4gKi9cbmNvbnN0IEFsaWdubWVudFRvU3R5bGUgPSB7XG4gICAgbGVmdDogJyB1LWhjLWFycm93LWxsJyxcbiAgICByaWdodDogJyB1LWhjLWFycm93LWxyJyxcbiAgICBwYWRkZWRMZWZ0OiAnIHUtaGMtYXJyb3ctc2wnLFxuICAgIHBhZGRlZFJpZ2h0OiAnIHUtaGMtYXJyb3ctc3InLFxuICAgIGRlZmF1bHQ6ICcgdS1oYy1hcnJvdy1sbCcsXG59O1xuXG4vKipcbiAqIFRoZSBIb3ZlckNhcmQgY29tcG9uZW50cyBhZGRzIGhvdmVyIGJlaGF2aW9yIHRvIHRleHQsIHRoZSBzcGVjaWZpZWQgY29udGVudCBpcyBsb2FkZWRcbiAqIG9uIHRoZSBsZWZ0IG9yIHJpZ2h0IHNpZGUgb2YgdGhlIGVsZW1lbnQuXG4gKlxuICogVG9kbzogZXh0ZW5kcyBzbyB3ZSBjYW4gd3JhcCBhbnkgZWxlbWVudCBhbmQgYW55IGVsZW1lbnQgY2FuIGJlIHRyaWdnZXJpbmcgdGhpcy4gTm90IG9ubHlcbiAqIGxpbmtUaXRsZVxuICpcbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqXG4gKiAgIDxhdy1ob3Zlci1jYXJkIFtsaW5rVGl0bGVdPVwiJ0ZyYW5rIGtvbGFyJ1wiPlxuICogICAgICAgPGgzPk15IENhcmQgVGl0bGU8L2gzPlxuICogICAgICAgPGRpdj5cbiAqXG4gKiAgICAgICAgICAgVGhpcyBpcyBteSBjb250ZW50c1xuICpcbiAqICAgICAgIDwvZGl2PlxuICpcbiAqXG4gKiAgICA8L2F3LWhvdmVyLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0IHRoZXJlIGlzIFtmb3JjZUNsb3NlXT10cnVlIHdoaWNoIGZvcmNlcyB0aGUgdXNlciB0byB1c2UgWCBjbG9zZSBpY29uXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctaG92ZXItY2FyZCcsXG4gICAgdGVtcGxhdGU6IGA8c3BhbiBjbGFzcz1cInctaGNcIj5cbiAgICA8c3BhbiBjbGFzcz1cInctaGMtdGl0bGVcIj5cbiAgICAgICAgPGF3LXN0cmluZyBbdmFsdWVdPVwibGlua1RpdGxlXCI+PC9hdy1zdHJpbmc+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb24gaWNvbi1zbGltLWFycm93LWRvd25cIiAobW91c2VvdmVyKT1cIm9wZW5DYXJkKCRldmVudClcIj48L3NwYW4+XG4gICAgPC9zcGFuPlxuXG4gICAgPGRpdiBjbGFzcz1cInctaGMtYm9keVwiPlxuXG4gICAgICAgICA8YXctb3ZlcmxheSAjb3ZlcmxheSBbc2hvd0Nsb3NlSWNvbl09XCJmb3JjZUNsb3NlXCIgW2Rpc21pc3NhYmxlXT1cIiFmb3JjZUNsb3NlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtzdHlsZUNsYXNzXT1cImFycm93Q2xhc3NcIlxuICAgICAgICAgICAgICAgICAgICAgW2FwcGVuZFRvXT1cImFwcGVuZFRvXCJcbiAgICAgICAgICAgICAgICAgICAgIChvbk9wZW4pPVwiY2FyZE9wZW5lZCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgIChvbkNsb3NlKT1cImNhcmRDbG9zZWQoJGV2ZW50KVwiPlxuXG4gICAgICAgIDwhLS0gdGhpcyBpcyB3b3JrYXJvdW5kIHRvIGNyZWF0ZSBhIF9uZ2NvbnRlbnQtSU5ERVggcmVmZXJlbmNlIHNvIHdlIGNhblxuICAgICAgICByZWZlciB0byB0aGlzIG5nLWNvbnRlbnQuIEFuZ3VsYXIgZG9lcyBub3QgaGF2ZSBhbnkgd2F5IHJpZ2h0IG5vdyB0byB0cmFjayB0aGlzXG4gICAgICAgIC0tPlxuICAgICAgICA8c3BhbiBjbGFzcz1cInUtbmdjb250ZW50XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9zcGFuPlxuXG4gICAgPC9hdy1vdmVybGF5PlxuXG4gICAgPC9kaXY+XG48L3NwYW4+XG5cblxuPCEtLTxuZy10ZW1wbGF0ZSAjY29udGVudFRvQm9keT4tLT5cbiAgICA8IS0tPGF3LW92ZXJsYXkgI292ZXJsYXkgW3Nob3dDbG9zZUljb25dPVwiZm9yY2VDbG9zZVwiIFtkaXNtaXNzYWJsZV09XCIhZm9yY2VDbG9zZVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLVtzdHlsZUNsYXNzXT1cImFycm93Q2xhc3NcIi0tPlxuICAgICAgICAgICAgICAgIDwhLS1bYXBwZW5kVG9dPVwiYXBwZW5kVG9cIi0tPlxuICAgICAgICAgICAgICAgIDwhLS0ob25PcGVuKT1cImNhcmRPcGVuZWQoJGV2ZW50KVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbkNsb3NlKT1cImNhcmRDbG9zZWQoJGV2ZW50KVwiPi0tPlxuXG4gICAgICAgIDwhLS0mbHQ7ISZuZGFzaDsgdGhpcyBpcyB3b3JrYXJvdW5kIHRvIGNyZWF0ZSBhIF9uZ2NvbnRlbnQtSU5ERVggcmVmZXJlbmNlIHNvIHdlIGNhbi0tPlxuICAgICAgICA8IS0tcmVmZXIgdG8gdGhpcyBuZy1jb250ZW50LiBBbmd1bGFyIGRvZXMgbm90IGhhdmUgYW55IHdheSByaWdodCBub3cgdG8gdHJhY2sgdGhpcy0tPlxuICAgICAgICA8IS0tJm5kYXNoOyZndDstLT5cbiAgICAgICAgPCEtLTxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj4tLT5cbiAgICAgICAgICAgICAgICA8IS0tPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pi0tPlxuICAgICAgICAgICAgPCEtLTwvc3Bhbj4tLT5cblxuICAgIDwhLS08L2F3LW92ZXJsYXk+LS0+XG5cbjwhLS08L25nLXRlbXBsYXRlPi0tPlxuXG5cbjwhLS08bmctdGVtcGxhdGUgI2NvbnRlbnRUb092ZXJsYXk+LS0+XG5cbiAgICA8IS0tPGF3LW92ZXJsYXkgI292ZXJsYXkgW3Nob3dDbG9zZUljb25dPVwiZm9yY2VDbG9zZVwiIFtkaXNtaXNzYWJsZV09XCIhZm9yY2VDbG9zZVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLVtzdHlsZUNsYXNzXT1cImFycm93Q2xhc3NcIi0tPlxuICAgICAgICAgICAgICAgIDwhLS0ob25PcGVuKT1cImNhcmRPcGVuZWQoJGV2ZW50KVwiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbkNsb3NlKT1cImNhcmRDbG9zZWQoJGV2ZW50KVwiPi0tPlxuXG4gICAgICAgIDwhLS0mbHQ7ISZuZGFzaDsgdGhpcyBpcyB3b3JrYXJvdW5kIHRvIGNyZWF0ZSBhIF9uZ2NvbnRlbnQtSU5ERVggcmVmZXJlbmNlIHNvIHdlIGNhbi0tPlxuICAgICAgICA8IS0tcmVmZXIgdG8gdGhpcyBuZy1jb250ZW50LiBBbmd1bGFyIGRvZXMgbm90IGhhdmUgYW55IHdheSByaWdodCBub3cgdG8gdHJhY2sgdGhpcy0tPlxuICAgICAgICA8IS0tJm5kYXNoOyZndDstLT5cbiAgICAgICAgPCEtLTxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj4tLT5cbiAgICAgICAgICAgICAgICA8IS0tPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pi0tPlxuICAgICAgICAgICAgPCEtLTwvc3Bhbj4tLT5cblxuICAgIDwhLS08L2F3LW92ZXJsYXk+LS0+XG48IS0tPC9uZy10ZW1wbGF0ZT4tLT5cblxuXG5gLFxuICAgIHN0eWxlczogW2Audy1oYy10aXRsZXtwYWRkaW5nLXJpZ2h0OjEuNGVtO3Bvc2l0aW9uOnJlbGF0aXZlO3doaXRlLXNwYWNlOm5vd3JhcH0udy1oYy10aXRsZSAuc2FwLWljb257Zm9udC1zaXplOjFlbTtjb2xvcjojMDA2NzllO3Bvc2l0aW9uOmFic29sdXRlO3BhZGRpbmctdG9wOi4yZW07cmlnaHQ6MH06Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3cudS1oYy1zaGFkb3ctYntib3gtc2hhZG93OjAgMnB4IDRweCAwIHJnYmEoMCwwLDAsLjIpfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdy51LWhjLXNoYWRvdy10e2JveC1zaGFkb3c6MCAtMnB4IDRweCAwIHJnYmEoMCwwLDAsLjIpfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdzphZnRlciw6Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3c6YmVmb3Jle2xlZnQ6MjUlO2JvcmRlcjpzb2xpZCB0cmFuc3BhcmVudDtjb250ZW50OlwiIFwiO2hlaWdodDowO3dpZHRoOjA7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6bm9uZX06Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3c6YWZ0ZXJ7Ym9yZGVyLWNvbG9yOnJnYmEoMTM2LDE4MywyMTMsMCk7Ym9yZGVyLXdpZHRoOi43ZW07bWFyZ2luLWxlZnQ6LS43ZW19OjpuZy1kZWVwIC53LWhjLXBhbmVsLWFycm93OmJlZm9yZXtib3JkZXItY29sb3I6cmdiYSgyNTUsMTM2LDU2LDApO2JvcmRlci13aWR0aDouOGVtO21hcmdpbi1sZWZ0Oi0uOGVtfTo6bmctZGVlcCAudS1oYy1hcnJvdy1sbDphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctbGw6YmVmb3Jle2xlZnQ6MjUlfTo6bmctZGVlcCAudS1oYy1hcnJvdy1scjphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctbHI6YmVmb3Jle2xlZnQ6NzUlfTo6bmctZGVlcCAudS1oYy1hcnJvdy1zbDphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctc2w6YmVmb3Jle2xlZnQ6MTAlfTo6bmctZGVlcCAudS1oYy1hcnJvdy1zcjphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctc3I6YmVmb3Jle2xlZnQ6OTAlfTo6bmctZGVlcCAudS1oYy1hcnJvdy10OmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy10OmJlZm9yZXtib3R0b206MTAwJX06Om5nLWRlZXAgLnUtaGMtYXJyb3ctdDphZnRlcntib3JkZXItYm90dG9tLWNvbG9yOiNmZmZ9OjpuZy1kZWVwIC51LWhjLWFycm93LXQ6YmVmb3Jle2JvcmRlci1ib3R0b20tY29sb3I6I2Q3ZDdkN306Om5nLWRlZXAgLnUtaGMtYXJyb3ctYjphZnRlciw6Om5nLWRlZXAgLnUtaGMtYXJyb3ctYjpiZWZvcmV7dG9wOjEwMCV9OjpuZy1kZWVwIC51LWhjLWFycm93LWI6YWZ0ZXJ7Ym9yZGVyLXRvcC1jb2xvcjojZmZmfTo6bmctZGVlcCAudS1oYy1hcnJvdy1iOmJlZm9yZXtib3JkZXItdG9wLWNvbG9yOiNkN2Q3ZDd9YF1cbn0pXG5leHBvcnQgY2xhc3MgSG92ZXJDYXJkQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0NoZWNrZWQge1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBwYWRkaW5nIHJlcHJlc2VudGluZyBhIGhlaWdodCBvZiB0aGUgQXJyb3cgZm9yIHdoaWNoIHdlIG5lZWQgdG8gdmVydGljYWxseSBhZGp1c3RcbiAgICAgKiBDYXJkIGNvbnRhaW5lclxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBBcnJvd1BhZCA9IDEwO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBzYWZlIHRocmVzaG9sZCB3aGVyZSB0aGVyZSBtaWdodCBub3QgYmUgZW5vdWdoIHNwYWNlIGFyb3VuZCBvciBDYXJkIGlzIGFsaWduZWQgd2l0aFxuICAgICAqIHRoZSBsZWZ0IG9yIHJpZ2h0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGZvciB3aGljaCB3ZSBuZWVkIHRvIHBvc2l0aW9uIHRoZSBBcnJvdyBjbG9zZXIgdG8gdGhlXG4gICAgICogc2lkZSBvZiB0aGUgY2FyZFxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBTcGFjaW5nTGltaXQgPSA1MDtcblxuXG4gICAgQElucHV0KClcbiAgICBsaW5rVGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB3ZSBrZWVwIHRoZSBob3ZlciBjYXJkIG9wZW4gYW5kIGZvcmNlIHVzZXIgdG8gbWFudWFsbHkgY2xvc2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9yY2VDbG9zZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBjdXJyZW50IHdvcmthcm91bmQgdW50aWwgd2UgZmluZCBiZXR0ZXIgc29sdXRpb24uIFByaW1lTkcgb3ZlcmxheXMgb3BlcmF0ZXMgd2l0aGluXG4gICAgICogaXRzIHJlbGF0aXZlIGVsZW1lbnQgc28gaWYgdGhlIG92ZXJsYXkgaXMgd3JhcHBlZCBpbnNpZGUgc29tZSBvdGhlciByZWxhdGl2ZSBjb250YWluZXJcbiAgICAgKiB0aGUgb3ZlcmxheSBjb250ZW50IGlzIGNyb3BlZCBieSBpdHMgcGFyZW50IGFuZCBjb250ZW50IGlzIG5vdCB2aXNpYmxlLlxuICAgICAqXG4gICAgICogVGhleSBoYXZlIFthcHBlbmRUb10gYmluZGluZyB3aGljaCB3ZSBuZWVkIHRvIHVzZSBmb3IgdGhpcyBwdXJwb3NlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZENvbnRlbnRUb0JvZHk6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIE92ZXJsYXlDb21wb25lbnQgdG8gY2FuIGFjY2VzcyBQcmltZU5HIGNvbXBvbmVudCBhcyB3ZWxsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnb3ZlcmxheScpXG4gICAgYXdPdmVybGF5OiBPdmVybGF5Q29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEludGVybmFsIHN0eWxlIGNsYXNzIHRvIHVzZSB0byBhcHBseSBhZGRpdGlvbmFsIHN0eWxlcyB3aGVuIGl0IG5lZWRzIHRvIHNob3cgYSBBcnJvdyBvbiB0aGVcbiAgICAgKiBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBhcnJvd0NsYXNzOiBzdHJpbmcgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgcHJvcGVydGllcyB0byByZWZlcmVuY2VzIHRlbXBsYXRlIGVsZW1lbnRzIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbmluZ1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB0aXRsZUFyZWFSZWN0OiBhbnk7XG4gICAgdHJpZ1JlY3Q6IGFueTtcbiAgICB0cmlnSWNvbk1pZGRsZTogYW55O1xuXG4gICAgb3BlbmluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgYXBwZW5kVG86ICdib2R5JztcblxuICAgIGN1cnJyZW50UG9zaXRpb246IEhDQ2FyZFBvc2l0aW9uID0gSENDYXJkUG9zaXRpb24ubm9uZTtcblxuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW06IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmxpbmtUaXRsZSksICdZb3UgbXVzdCBwcm92aWRlIFtsaW5rVGl0bGVdIGJpbmRpbmcgIScpO1xuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGVyZSBpcyBvcGVuIEhDIHdoZW4gd2Ugc3RhcnQgbmV3IGNvbXBvbmVudFxuICAgICAgICB0aGlzLmVudi5kZWxldGVWYWx1ZSgnaGMtb3BlbicpO1xuXG4gICAgICAgIGlmICghdGhpcy5hcHBlbmRDb250ZW50VG9Cb2R5KSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZFRvID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXMgb2YgQW5ndWxhciA1IHdlIGhhdmUgdG8gaW50cm9kdWNlIHRoaXMgVmlld0NoZWNrZWQgYXMgUHJpbWVORyBkb2VzIGZpbmFsIGNhbGN1bGF0aW9uXG4gICAgICogZHVyaW5nIHRoaXMgcGhhc2UuXG4gICAgICpcbiAgICAgKiBTbyBub3cgaXRzIGJyb2tlbiBkb3duIGludG8gdHdvIHBhcnRzOlxuICAgICAqICAgLSBBcHBseSBjbGFzcyBzdHlsZXNcbiAgICAgKiAgIC0gUG9zaXRpb24gaXQuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vcGVuaW5nKSB7XG4gICAgICAgICAgICBsZXQgY29udGFpbmVyID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS5jb250YWluZXI7XG5cbiAgICAgICAgICAgIGxldCBjbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycnJlbnRQb3NpdGlvbiAhPT0gSENDYXJkUG9zaXRpb24ubm9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRqdXN0Q2FyZChjb250YWluZXIsIGNudFJlY3QsIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9wZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdCBlbGVtZW50cyBCb3VuZGluZ0NsaWVudFJlY3QgdGhhdCB3ZSB1c2UgZm9yIGNhbGN1bGF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0RWxlbWVudHMoKTogdm9pZCB7XG4gICAgICAgIGxldCB0aXRsZUVsZW0gPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudy1oYy10aXRsZScpO1xuICAgICAgICBsZXQgdHJpZ2dlckVsZW0gPSB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuc2FwLWljb24nKTtcbiAgICAgICAgdGhpcy50aXRsZUFyZWFSZWN0ID0gdGl0bGVFbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnRyaWdSZWN0ID0gdHJpZ2dlckVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudHJpZ0ljb25NaWRkbGUgPSB0aGlzLnRyaWdSZWN0LndpZHRoIC8gMjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZXMgd2hlbiB1c2VyIG1vdXNlIG92ZXIgdGhlIHRyaWdnZXJpbmcgaWNvbiBhbmQgb3BlbnMgdXAgb3ZlcmxheSBjb21wb25lbnQuIFRvIG1ha2Ugc3VyZVxuICAgICAqIG9ubHkgb25lIENhcmQgaXMgb3BlbmVkIGF0IHRoZSB0aW1lIGl0IHVzZXMgRW52aXJvbm1lbnQgdG8gc2F2ZSBleHRyYSBpbmZvcm1hdGlvbiBmb3IgaXRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgb3BlbkNhcmQoZXZlbnQ6IGFueSk6IGFueSB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5hd092ZXJsYXkpICYmICF0aGlzLmVudi5oYXNWYWx1ZSgnaGMtb3BlbicpKSB7XG4gICAgICAgICAgICB0aGlzLmF3T3ZlcmxheS5vcGVuKGV2ZW50KTtcblxuICAgICAgICAgICAgdGhpcy5lbnYuc2V0VmFsdWUoJ2hjLW9wZW4nLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlZCBhdCB0aGUgZW5kIG9mIHRoZSBvcGVuaW5nIGN5Y2xlIHdoZW4gYWxsIGlzIGluaXRpYWxpemVkIGFuZCB0aGUgY2FyZCBpcyBhYm91dCB0b1xuICAgICAqIGZhZGUgaW4uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBmaXJzdCBzaW11bGF0ZXMgZGlzcGxheWluZyBjYXJkIGJ5IHNldHRpbmcgZGlzcGxheTpibG9jayBhbmRcbiAgICAgKiBkb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24gc28gd2UgY2FuIHJlYWQgZGltZW5zaW9ucyBhbmQgdGhlbiBsYXRlciBvbiBwb3NpdGlvbiB0aGUgY2FyZFxuICAgICAqIGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICovXG4gICAgY2FyZE9wZW5lZChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmNvbnRhaW5lcjtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkudGFyZ2V0O1xuICAgICAgICB0aGlzLm9wZW5Gb3JBZGp1c3RtZW50cyhjb250YWluZXIpO1xuXG4gICAgICAgIC8vIHByZS1ydW4gcG9zaXRpb25pbmcgc28gd2UgY2FuIGNhbGN1bGF0ZSBuZXcgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5hd092ZXJsYXkub3ZlcmxheS5kb21IYW5kbGVyLmFic29sdXRlUG9zaXRpb24oY29udGFpbmVyLCB0YXJnZXQpO1xuICAgICAgICBsZXQgY250UmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5jdXJycmVudFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkZvckNhcmQoY29udGFpbmVyLCBjbnRSZWN0KTtcblxuICAgICAgICB0aGlzLmFwcGx5U3R5bGVDbGFzcyhjb250YWluZXIsIGNudFJlY3QsIHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2VGb3JBZGp1c3RtZW50cyhjb250YWluZXIpO1xuICAgICAgICB0aGlzLm9wZW5pbmcgPSB0cnVlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNhcmQgaXMgY2xvc2VkIHdlIG5lZWQgdG8gcmVsZWFzZSBpdCBhbmQgZGVsZXRlIGFsbCB0aGUgcmVmZXJlbmNlcyBmcm9tIEVudmlyb25tZW50XG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGNhcmRDbG9zZWQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmVudi5kZWxldGVWYWx1ZSgnaGMtb3BlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQXBwbGllcyBzdHlsZS5UT1AgYW5kIHN0eWxlLkxFRlQgdG8gdGhlIGNvbnRhaW5lciBpbiBvcmRlciB0byByZXBvc2l0aW9uIGl0IGFuZCBhZGRcbiAgICAgKiBleHRyYSBhcnJvdy5cbiAgICAgKlxuICAgICAqIEZpcnN0IGJhc2VkIG9uIHRoZSBpbml0aWFsIHBvc2l0aW9uIHdlIGFwcGx5IHN0eWxlLlRPUCBhbmQgZGVwZW5kaW5nIGlmIGl0cyBvbiB0aGVcbiAgICAgKiB0b3Agb3IgYm90dG9tIHdlIGFwcGx5IGVpdGhlciAtSG92ZXJDYXJkQ29tcG9uZW50LkFycm93UGFkIG9yICtIb3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQuXG4gICAgICpcbiAgICAgKiBUaGVuIGZvciBwb3NpdGlvbmluZyBob3Jpem9udGFsbHkgd2UgdXNlIHR3byB0eXBlcy5cbiAgICAgKiAgLSBXaGVuIHRoZXJlIGlzIGFsbG90IG9mIHNwYWNlIHRoZSBhcnJvdyBpcyAyNSUgZnJvbSB0aGUgZWRnZVxuICAgICAqXG4gICAgICogICAgLS0tLS1eLS0tLS0tLS0tLS0tICAgb3IgICAgICAgLS0tLS0tLS0tLS1eLS0tLVxuICAgICAqXG4gICAgICpcbiAgICAgKiAgLSBXaGVuIHRoZXJlIGlzIGxlc3Mgb3Igbm9uZSBzcGFjZSB3ZSBoYXZlIG9ubHkgMTAlIGZhciBhd2F5IGZvcm0gdGhlIGVkZ2VcbiAgICAgKlxuICAgICAqICAgIC0tXi0tLS0tLS0tLS0tLSAgIG9yICAgICAgIC0tLS0tLS0tLS0tXi0tXG4gICAgICpcbiAgICAgKiAgT25jZSB3ZSBwaWNrIHRoZSBjb3JyZWN0IHBvc2l0aW9uaW5nICgyNSUsIDEwJSkgd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBhbmQgc2hpZnQgdGhlIGNhcmRcbiAgICAgKiAgZWl0aGVyIHRvIHRoZSBsZWZ0IG9yIHJpZ2h0LlxuICAgICAqXG4gICAgICovXG4gICAgYWRqdXN0Q2FyZChjb250YWluZXI6IGFueSwgY29udGFpbmVyUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBkaWZmID0gKHRoaXMuY3VycnJlbnRQb3NpdGlvbiA9PT0gSENDYXJkUG9zaXRpb24uYm90dG9tKSA/IDEgOiAtMTtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IG1vZGFsQ29udGFpbmVyLmRvbUhhbmRsZXIuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGxldCBwb3NXaXRoU2Nyb2xsID0gY29udGFpbmVyUmVjdC50b3AgKyBzY3JvbGxUb3A7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSAocG9zV2l0aFNjcm9sbCArIChIb3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQgKiBkaWZmKSkgKyAncHgnO1xuXG4gICAgICAgIGxldCBhbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudEZvckNhcmQoY29udGFpbmVyUmVjdCwgbW9kYWxDb250YWluZXIpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUubGVmdCA9IHRoaXMuY2FsY0xlZnRGb3JBbGlnbm1lbnQoY29udGFpbmVyUmVjdCwgYWxpZ25tZW50KSArICdweCc7XG4gICAgfVxuXG5cbiAgICBhcHBseVN0eWxlQ2xhc3MoY29udGFpbmVyOiBhbnksIGNvbnRhaW5lclJlY3Q6IGFueSwgbW9kYWxDb250YWluZXI6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJyZW50UG9zaXRpb24gIT09IEhDQ2FyZFBvc2l0aW9uLm5vbmUpIHtcbiAgICAgICAgICAgIGxldCBhbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudEZvckNhcmQoY29udGFpbmVyUmVjdCwgbW9kYWxDb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAoPGFueT5Qb3NpdGlvblRvU3R5bGUpWyg8YW55PkhDQ2FyZFBvc2l0aW9uKVt0aGlzLmN1cnJyZW50UG9zaXRpb25dXTtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyArPSAoPGFueT5BbGlnbm1lbnRUb1N0eWxlKVsoPGFueT5IQ0NhcmRBbGlnbm1lbnQpW2FsaWdubWVudF1dO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFycm93Q2xhc3MgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGV0ZWN0cyBpZiB0aGUgY2FyZCBpcyBnb2luZyB0byBiZSBzaG93biBvbiB0aGUgdG9wIG9mIHRoZSBMaW5rIGxhYmVsIG9yIHVuZGVyLiBPciBpZlxuICAgICAqIGl0cyBjb3ZlcmluZyBpdC5cbiAgICAgKlxuICAgICAqL1xuICAgIHBvc2l0aW9uRm9yQ2FyZChjb250YWluZXI6IGFueSwgYm91bmRpbmdSZWN0OiBhbnkpOiBIQ0NhcmRQb3NpdGlvbiB7XG4gICAgICAgIC8vIHNlY3VyZSB0aGlzIGluIGNhc2Ugb2YgSUUgcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICBsZXQgYm9yZGVyV2lkdGggPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcikuYm9yZGVyV2lkdGg7XG4gICAgICAgIGxldCBjbnRXaWR0aCA9IHBhcnNlRmxvYXQoYm9yZGVyV2lkdGggfHwgJzAnKTtcbiAgICAgICAgbGV0IHBvcyA9IEhDQ2FyZFBvc2l0aW9uLm5vbmU7XG5cbiAgICAgICAgaWYgKHRoaXMudHJpZ1JlY3QuYm90dG9tIDwgYm91bmRpbmdSZWN0LnRvcCkge1xuICAgICAgICAgICAgcG9zID0gSENDYXJkUG9zaXRpb24uYm90dG9tO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJpZ1JlY3QudG9wID4gKGJvdW5kaW5nUmVjdC5ib3R0b20gLSBjbnRXaWR0aCkpIHtcbiAgICAgICAgICAgIHBvcyA9IEhDQ2FyZFBvc2l0aW9uLnRvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERldGVjdCBob3Jpem9udGFsIGFsaWdubWVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgYWxpZ25tZW50Rm9yQ2FyZChib3VuZGluZ1JlY3Q6IGFueSwgbW9kYWxDb250YWluZXI6IGFueSk6IEhDQ2FyZEFsaWdubWVudCB7XG4gICAgICAgIGxldCBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQubGVmdDtcbiAgICAgICAgbGV0IHZpZXdQb3J0ID0gbW9kYWxDb250YWluZXIuZG9tSGFuZGxlci5nZXRWaWV3cG9ydCgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdSZWN0LmxlZnQudG9GaXhlZCgwKSA9PT0gYm91bmRpbmdSZWN0LmxlZnQudG9GaXhlZCgwKSAmJlxuICAgICAgICAgICAgYm91bmRpbmdSZWN0LmxlZnQgPiBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQubGVmdDtcblxuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kaW5nUmVjdC5sZWZ0IDwgSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnBhZGRlZExlZnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICgodmlld1BvcnQud2lkdGggLSBib3VuZGluZ1JlY3QucmlnaHQpIDwgSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnBhZGRlZFJpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnUmVjdC5yaWdodC50b0ZpeGVkKDApID09PSBib3VuZGluZ1JlY3QucmlnaHQudG9GaXhlZCgwKSB8fFxuICAgICAgICAgICAgKHZpZXdQb3J0LndpZHRoIC0gYm91bmRpbmdSZWN0LnJpZ2h0KSA+IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5yaWdodDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LmRlZmF1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsaWdubWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR1cm4gb24gdGVtcG9yYXJ5IGRpc3BsYXkgdG8gQkxPQ0sgc28gd2UgY2FuIHJlYWQgZGltZW5zaW9uc1xuICAgICAqXG4gICAgICovXG4gICAgb3BlbkZvckFkanVzdG1lbnRzKGNvbnRhaW5lcjogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgICAgICB0aGlzLmluaXRFbGVtZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUdXJuIG9mZiBkaXNwbGF5IGJhY2sgTk9ORVxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VGb3JBZGp1c3RtZW50cyhjb250YWluZXI6IGFueSk6IHZvaWQge1xuICAgICAgICBjb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgLy8gY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENhbGN1bGF0ZXMgcG9zaXRpb25pbmcgZm9yIHN0eWxlLkxFRlQuIEFzIGFscmVhZHkgc2FpZCB0aGV5IGFyZSB0d28gdHlwZXMgb2YgdHJpYW5nbGVzIHRoYXRcbiAgICAgKiBhcmUgYXBwbGllcyBmb3IgdGhlc2UgY2FzZTpcbiAgICAgKlxuICAgICAqXG4gICAgICogYSkgTGFyZ2UgbGVmdCwgTGFyZ2UgcmlnaHRcbiAgICAgKlxuICAgICAqICBQcmltZU5HIGFsaWducyB0aGUgY2FyZCB3aXRoIGVpdGhlciB0aGUgcmlnaHQgc2lkZSBvciBsZWZ0IHNpZGUgb2YgdGhlIHRyaWdnZXJpbmcgaWNvblxuICAgICAqXG4gICAgICpcbiAgICAgKiAgViAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogIC4uLi4uLl4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4gb3IgIC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uXi4uLi4uLlxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICogIGIpIFNtYWxsIGxlZnQgLCBzbWFsbCByaWdodFxuICAgICAqXG4gICAgICogIFRoaXMgaXMgZm9yIGNhc2VzIHdoZXJlIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgYW5kIFByaW1lTkcgcG9zaXRpb24gdGhlIGNhcmQgb2ZmIHRvIHRoZVxuICAgICAqICB0cmlnZ2VyaW5nIGljb25zLCBzbyBldmVuIHByaW1lTmcgZG9lcyBub3QgaGF2ZSBzcGFjZSB0byBhbGlnbiBpdCB3aXRoIHRoZSBWXG4gICAgICpcbiAgICAgKlxuICAgICAqICAgICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuICAgICAqICAuLi4uXi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvciAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5eLi4uLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBjKUFsaWduZWQgd2l0aCB0aGUgZWRnZSBvZiBicm93c2VyXG4gICAgICpcbiAgICAgKiBPbiB0aGUgcmlnaHQgc2lkZSB0aGlzIGlzIHByb2JsZW0gYXMgd2UgY2Fubm90IGNhbGN1bGF0ZSBmdWxsIGZ1dHVyZSB3aWR0aCBvZiB0aGUgY2FyZC5cbiAgICAgKiBidXQgd2UgYXBwbGx5IGZvciB0aGlzIGNhc2UgI2IgKGFycm93IDEwJSApXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjTGVmdEZvckFsaWdubWVudChib3VuZGluZ1JlY3Q6IGFueSwgYWxpZ25tZW50OiBIQ0NhcmRBbGlnbm1lbnQpOiBudW1iZXIge1xuICAgICAgICAvLyB3aWR0aCBmb3Igd2hpY2ggd2UgbmVlZCB0byBzaGlmdCBjYXJkLiAyNSUgb3IgMTAlIG9mIHRoZSBjb250YWluZXIgd2lkdGhcbiAgICAgICAgbGV0IHdMYXJnZVRyaWFuZ2xlID0gYm91bmRpbmdSZWN0LndpZHRoICogMC4yNTtcbiAgICAgICAgbGV0IHdTbWFsbFRyaWFuZ2xlID0gYm91bmRpbmdSZWN0LndpZHRoICogMC4xMDtcblxuICAgICAgICBzd2l0Y2ggKGFsaWdubWVudCkge1xuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQucmlnaHQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0UmlnaHQgPSBib3VuZGluZ1JlY3QubGVmdCArIHdMYXJnZVRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIGxldCB0cmlnUmlnaHQgPSB0aGlzLnRyaWdSZWN0LnJpZ2h0IC0gdGhpcy50cmlnSWNvbk1pZGRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRSaWdodCAtIChib3VuZGluZ1JlY3QucmlnaHQgLSB0cmlnUmlnaHQpO1xuXG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5wYWRkZWRSaWdodDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRSaWdodFMgPSBib3VuZGluZ1JlY3QubGVmdCArIHdTbWFsbFRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIGxldCB0cmlnUmlnaHRTID0gdGhpcy50cmlnUmVjdC5yaWdodCAtIHRoaXMudHJpZ0ljb25NaWRkbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0UmlnaHRTIC0gKGJvdW5kaW5nUmVjdC5yaWdodCAtIHRyaWdSaWdodFMpO1xuXG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LnBhZGRlZExlZnQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0TGVmdFBhZCA9IGJvdW5kaW5nUmVjdC5sZWZ0IC0gd1NtYWxsVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0TGVmdFBhZCArIHRoaXMudHJpZ0ljb25NaWRkbGU7XG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LmxlZnQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdExlZnQgPSBib3VuZGluZ1JlY3QubGVmdCAtIHdMYXJnZVRyaWFuZ2xlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdExlZnQgKyB0aGlzLnRyaWdJY29uTWlkZGxlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudENoZWNrZWQsXG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgRGlyZWN0aXZlLFxuICAgIERvQ2hlY2ssXG4gICAgRWxlbWVudFJlZixcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBTaW1wbGVDaGFuZ2Vcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudCwgcHJpbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU3B5IGxpZmVjeWNsZSBkaXJlY3RpdmUgaXMgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIHRvIHRyYWNrIGxpZmVjeWNsZSBjYWxsYmFja1xuICpcbiAqICMjI1VzYWdlXG4gKlxuICogYGBgXG4gKiAgIDxteS1kaXJlY3RpdmUgc3B5aG9va3M+PG15LWRpcmVjdGl2ZT5cbiAqXG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7c2VsZWN0b3I6ICdbc3B5SG9va3NdJ30pXG5leHBvcnQgY2xhc3MgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCwgRG9DaGVjaywgT25DaGFuZ2VzLFxuICAgIEFmdGVyQ29udGVudEluaXQsIEFmdGVyQ29udGVudENoZWNrZWQsIEFmdGVyVmlld0luaXQsIEFmdGVyVmlld0NoZWNrZWRcbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZilcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCdvbkluaXQnKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCdvbkRlc3Ryb3knKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHtbIHByb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2V9KVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdPbkNoYW5nZXMgPSAnICsgY2hhbmdlcyk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nRG9DaGVjaycpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyQ29udGVudEluaXQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudENoZWNrZWQoKVxuICAgIHtcblxuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyQ29udGVudENoZWNrZWQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlclZpZXdJbml0Jyk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJWaWV3Q2hlY2tlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgbG9nSXQobXNnOiBzdHJpbmcpXG4gICAge1xuICAgICAgICBsZXQgbGV2ZWwgPSAwO1xuICAgICAgICBsZXQgbWUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgbGV0IHRhZ0JvZHkgPSBtZTtcblxuICAgICAgICB3aGlsZSAoKHRhZ0JvZHkgPSB0YWdCb2R5LnBhcmVudE5vZGUpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldmVsKys7XG4gICAgICAgICAgICBpZiAodGFnQm9keS50YWdOYW1lID09PSAnQVBQLVJPT1QnIHx8IGxldmVsID09PSA2KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGVudCA9ICcnO1xuICAgICAgICBsZXQgaW5kZW50TnVtYmVyID0gbGV2ZWw7XG4gICAgICAgIHdoaWxlIChsZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnXFx0JztcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIH1cblxuXG4gICAgICAgIGxldCBwYXJhbXMgPSAnJztcbiAgICAgICAgaWYgKGlzUHJlc2VudChtZS5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGF0dHI6IEF0dHIgPSBtZS5hdHRyaWJ1dGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWdub3JlKGF0dHIubmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHBhcmFtcyArPSAnKCcgKyBhdHRyLm5hbWUgKyAnPScgKyBhdHRyLnZhbHVlICsgJyksICAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByaW50KGluZGVudCArIG1lLnRhZ05hbWUgKyAnKCcgKyBpbmRlbnROdW1iZXIgKyAnKTogJyArIG1zZyArICcgPT4gJyArIHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpZ25vcmUobmFtZTogc3RyaW5nKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5hbWUuaW5kZXhPZignX25nJykgPiAtMSB8fFxuICAgICAgICAgICAgbmFtZS5pbmRleE9mKCduZy0nKSA+IC0xIHx8XG4gICAgICAgICAgICBuYW1lLmluZGV4T2YoJ3NweWhvb2tzJykgPiAtMTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge092ZXJsYXlDb21wb25lbnR9IGZyb20gJy4vb3ZlcmxheS5jb21wb25lbnQnO1xuaW1wb3J0IHtPdmVybGF5UGFuZWxNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIE92ZXJsYXlDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudCxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXT3ZlcmxheU1vZHVsZVxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtIb3ZlckNhcmRDb21wb25lbnR9IGZyb20gJy4vaG92ZXItY2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV092ZXJsYXlNb2R1bGV9IGZyb20gJy4uL292ZXJsYXkvb3ZlcmxheS5tb2R1bGUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEhvdmVyQ2FyZENvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0hvdmVyQ2FyZE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBUFBfSU5JVElBTElaRVIsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtcbiAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgIEJ1dHRvbk1vZHVsZSxcbiAgICBDYWxlbmRhck1vZHVsZSxcbiAgICBDaGVja2JveCxcbiAgICBDaGVja2JveE1vZHVsZSxcbiAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgRGlhbG9nLFxuICAgIERpYWxvZ01vZHVsZSxcbiAgICBEcm9wZG93bk1vZHVsZSxcbiAgICBFZGl0b3JNb2R1bGUsXG4gICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgTWVudU1vZHVsZSxcbiAgICBPdmVybGF5UGFuZWxNb2R1bGUsXG4gICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgIFBhbmVsTW9kdWxlLFxuICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgIFNoYXJlZE1vZHVsZSxcbiAgICBUYWJNZW51TW9kdWxlLFxuICAgIFRvb2xiYXJNb2R1bGVcbn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QXJpYmFDb3JlTW9kdWxlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7U3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmV9IGZyb20gJy4vc3B5LWxpZmVjeWNsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHtFbWJlZGRlZEl0ZW1EaXJlY3RpdmV9IGZyb20gJy4vY29yZS9lbWJlZGRlZC1pdGVtJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vZW50cnktY29tcG9uZW50cyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7QVdCYXNpY05hdmlnYXRvck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Jhc2ljLW5hdmlnYXRvci9iYXNpYy1uYXZpZ2F0b3IubW9kdWxlJztcbmltcG9ydCB7QVdDaGVja0JveExpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0NoZWNrQm94TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hvb3Nlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvbmZpcm1hdGlvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24ubW9kdWxlJztcbmltcG9ydCB7QVdDdXJyZW5jeU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2N1cnJlbmN5L2N1cnJlbmN5Lm1vZHVsZSc7XG5pbXBvcnQge0FXRGF0ZUFuZFRpbWVNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kYXRlLWFuZC10aW1lL2RhdGEtYW5kLXRpbWUubW9kdWxlJztcbmltcG9ydCB7QVdEaWFsb2dNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLm1vZHVsZSc7XG5pbXBvcnQge0FXRHJvcGRvd25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuaW1wb3J0IHtBV0dlbmVyaWNDaG9vc2VyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUnO1xuaW1wb3J0IHtBV0h5cGVybGlua01vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlJztcbmltcG9ydCB7QVdJbnB1dEZpZWxkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlJztcbmltcG9ydCB7QVdPdXRsaW5lRm9yTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvb3V0bGluZS9vdXRsaW5lLWZvci5tb2R1bGUnO1xuaW1wb3J0IHtBV092ZXJsYXlNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9vdmVybGF5L292ZXJsYXkubW9kdWxlJztcbmltcG9ydCB7QVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcGFnZS1ub3RpZmljYXRpb24vcGFnZS1ub3RpZmljYXRpb24ubW9kdWxlJztcbmltcG9ydCB7QVdQYWdlV3JhcHBlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlJztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlJztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbkxpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV1JpY2hUZXh0QXJlYU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JpY2gtdGV4dC1hcmVhL3JpY2gtdGV4dC1hcmVhLm1vZHVsZSc7XG5pbXBvcnQge0FXSG92ZXJDYXJkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaG92ZXItY2FyZC9ob3Zlci1jYXJkLm1vZHVsZSc7XG5pbXBvcnQge1xuICAgIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZVxufSBmcm9tICcuL3dpZGdldHMvc2Nyb2xsYWJsZS1jb250YWluZXIvc2Nyb2xsYWJsZS1jb250YWluZXIubW9kdWxlJztcbmltcG9ydCB7QVdTZWN0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLm1vZHVsZSc7XG5pbXBvcnQge0FXU3RlcHBlck1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3N0ZXBwZXIvc3RlcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtBV1RleHRBcmVhTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlJztcbmltcG9ydCB7QVdGb3JtVGFibGVNb2R1bGV9IGZyb20gJy4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUubW9kdWxlJztcbmltcG9ydCB7QVdMaXN0TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2FyZE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NhcmQvY2FyZC5tb2R1bGUnO1xuaW1wb3J0IHtBV0RhdGF0YWJsZTJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTIubW9kdWxlJztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtNb2RhbFNlcnZpY2V9IGZyb20gJy4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZXJyb3ItbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7QXdOYW1lU3RvcmV9IGZyb20gJy4vY29yZS9hdy1uYW1lL2F3LW5hbWUuc3RvcmUnO1xuaW1wb3J0IHtEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG4vKipcbiAqIENvbXBvbmVudCBtb2R1bGUgaXMgY29yZSBtb2R1bGUgZm9yIHRoZSBjb21tb24gbGF5b3V0cyBhbmQgd2lkZ2V0cyBsaWJyYXJpZXMuXG4gKlxuICogdG9kbzogVGhlcmUgYXJlIHNvbWUgdGhpbmdzIHRoYXQgSSBzdGlsbCBuZWVkIHRvIHJlc29sdmUgLSBwbGVhc2Ugc2VlIGFuZCBub3RpY2VzIEBEdXBsaWNhdGVzXG4gKiBqc2RvYyBJIHdhbnQgdG8ga2VlcCB0aGlzIHRoZXJlIHRvIHJlbWluZCBtZSB0aGF0IEkgbmVlZCB0byByZWZhY3RvciB0aGlzIGFzIG9mIG5vdyB0aGVyZSBhcmVcbiAqIG5vdCBtdWNoIG9wdGlvbiB3aXRoIGFuZ3VsYXIuXG4gKlxuICovXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQXJpYmFDb3JlTW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdCYXNpY05hdmlnYXRvck1vZHVsZSxcbiAgICAgICAgQVdDYXJkTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TGlzdE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZSxcbiAgICAgICAgQVdDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0NvbmZpcm1hdGlvbk1vZHVsZSxcbiAgICAgICAgQVdDdXJyZW5jeU1vZHVsZSxcbiAgICAgICAgQVdEYXRlQW5kVGltZU1vZHVsZSxcbiAgICAgICAgQVdEaWFsb2dNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXR2VuZXJpY0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0lucHV0RmllbGRNb2R1bGUsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXUGFnZVdyYXBwZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlLFxuICAgICAgICBBV1JpY2hUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlLFxuICAgICAgICBBV1NlY3Rpb25Nb2R1bGUsXG4gICAgICAgIEFXU3RlcHBlck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdGb3JtVGFibGVNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0hvdmVyQ2FyZE1vZHVsZSxcbiAgICAgICAgQVdMaXN0TW9kdWxlLFxuICAgICAgICBBV0RhdGF0YWJsZTJNb2R1bGUsXG5cbiAgICAgICAgLy8gUHJpbWVORyByZW1vdmUgd2hlbiBhbGwgQVcgYXJlIGltcG9ydGVkXG4gICAgICAgIFBhbmVsTW9kdWxlLFxuICAgICAgICBCdXR0b25Nb2R1bGUsXG4gICAgICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQXV0b0NvbXBsZXRlTW9kdWxlLFxuICAgICAgICBEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgIENoZWNrYm94TW9kdWxlLFxuICAgICAgICBSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgU2hhcmVkTW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGUsXG4gICAgICAgIE1lbnVNb2R1bGUsXG4gICAgICAgIFRhYk1lbnVNb2R1bGUsXG4gICAgICAgIEFjY29yZGlvbk1vZHVsZSxcbiAgICAgICAgRWRpdG9yTW9kdWxlLFxuICAgICAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgICAgIFBhZ2luYXRvck1vZHVsZSxcbiAgICAgICAgT3ZlcmxheVBhbmVsTW9kdWxlXG5cbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZSxcbiAgICAgICAgLy8gM3RoIHBhcnR5IGRlY2xhcmF0aW9uXG4gICAgXSxcbiAgICBib290c3RyYXA6IFtdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuXG4gICAgICAgIC8vIFByaW1lTkdcbiAgICAgICAgQ2hlY2tib3gsXG4gICAgICAgIERpYWxvZ1xuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgU3B5TGlmZUN5Y2xlSG9va3NEaXJlY3RpdmUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdCYXNpY05hdmlnYXRvck1vZHVsZSxcbiAgICAgICAgQVdDYXJkTW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TGlzdE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZSxcbiAgICAgICAgQVdDaG9vc2VyTW9kdWxlLFxuICAgICAgICBBV0NvbmZpcm1hdGlvbk1vZHVsZSxcbiAgICAgICAgQVdDdXJyZW5jeU1vZHVsZSxcbiAgICAgICAgQVdEYXRlQW5kVGltZU1vZHVsZSxcbiAgICAgICAgQVdEaWFsb2dNb2R1bGUsXG4gICAgICAgIEFXRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXR2VuZXJpY0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0lucHV0RmllbGRNb2R1bGUsXG4gICAgICAgIEFXT3V0bGluZUZvck1vZHVsZSxcbiAgICAgICAgQVdPdmVybGF5TW9kdWxlLFxuICAgICAgICBBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGUsXG4gICAgICAgIEFXUGFnZVdyYXBwZXJNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlLFxuICAgICAgICBBV1JpY2hUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlLFxuICAgICAgICBBV1NlY3Rpb25Nb2R1bGUsXG4gICAgICAgIEFXU3RlcHBlck1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdUZXh0QXJlYU1vZHVsZSxcbiAgICAgICAgQVdGb3JtVGFibGVNb2R1bGUsXG4gICAgICAgIEVtYmVkZGVkSXRlbURpcmVjdGl2ZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSG92ZXJDYXJkTW9kdWxlLFxuICAgICAgICBBV0xpc3RNb2R1bGUsXG4gICAgICAgIEFXRGF0YXRhYmxlMk1vZHVsZSxcblxuICAgICAgICAvLyBQcmltZU5HXG4gICAgICAgIFNoYXJlZE1vZHVsZSxcbiAgICAgICAgUGFuZWxNb2R1bGUsXG4gICAgICAgIEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgVG9vbGJhck1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgICAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBEaWFsb2dNb2R1bGUsXG4gICAgICAgIE1lbnVNb2R1bGUsXG4gICAgICAgIFRhYk1lbnVNb2R1bGUsXG4gICAgICAgIEVkaXRvck1vZHVsZSxcbiAgICAgICAgRGF0YVRhYmxlTW9kdWxlLFxuICAgICAgICBQYWdpbmF0b3JNb2R1bGUsXG4gICAgICAgIE92ZXJsYXlQYW5lbE1vZHVsZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQXJpYmFDb21wb25lbnRzTW9kdWxlXG57XG5cblxuICAgIHN0YXRpYyBmb3JSb290ICgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzXG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFyaWJhQ29tcG9uZW50c01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1vZGFsU2VydmljZSxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBFcnJvck1hbmFnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBEYXRhRmluZGVycyxcbiAgICAgICAgICAgICAgICBBd05hbWVTdG9yZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcmVnaXN0ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbQ29tcG9uZW50UmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRzIChjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KTogRnVuY3Rpb25cbntcbiAgICByZXR1cm4gY29tcFJlZ2lzdHJ5LmluaXRpYWxpemUuYmluZChjb21wUmVnaXN0cnksIGNvbXBvbmVudHMpO1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtBUFBfSU5JVElBTElaRVIsIE1vZHVsZVdpdGhQcm92aWRlcnMsIE5nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29yZS9jb21wb25lbnQtcmVnaXN0cnkuc2VydmljZSc7XG5pbXBvcnQgKiBhcyBjb21wb25lbnRzIGZyb20gJy4vZW50cnktY29tcG9uZW50cyc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7TW9kYWxTZXJ2aWNlfSBmcm9tICcuL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC5zZXJ2aWNlJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVyc30gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RXJyb3JNYW5hZ2VyU2VydmljZX0gZnJvbSAnLi9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZSc7XG5pbXBvcnQge0F3TmFtZVN0b3JlfSBmcm9tICcuL2NvcmUvYXctbmFtZS9hdy1uYW1lLnN0b3JlJztcbmltcG9ydCB7RGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5fSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcblxuXG4vKipcbiAqXG4gKiBUaGlzIG1vZHVsZSBpcyB1c2VkIG1haW5seSBmb3IgdGVzdHMgYXMgaW1wb3J0aW5nIGEgbW9kdWxlIHdpdGggYWxsIHRoZSBjb21wb25lbnRzIGFuZCB5b3VcbiAqIHVzZSBvbmx5IDEgb3IgdHdvIGhhcyBhIGJpZyBpbXBhY3Qgb24gdGhlIHBlcmZvcm1hbmNlIGV4ZWN1dGlvbi4gZS5nLiBmcm9tIGV4ZWN1dGluZyBjb3VwbGVcbiAqIHRlc3RzIHVuZGVyIDEgc2VjIGNhbiBnbyB1cCB0byAxMHNlYyBpZiB5b3UgaW1wb3J0IGFsbCB0aGUgdGhpbmdzIHRoYXQgeW91IGFyZSBub3QgdXNpbmcuXG4gKlxuICogSSBoYXZlbnQgbm90aWNlZCBhbnl0aGluZyBzaW1pbGFyIGluIGFwcGxpY2F0aW9uIGl0cyBvbmx5IGphc21pbmUva2FybWEgdGhhdCBuZWVkcyB0byBpbml0XG4gKiBjb21wb25lbnRzIGZvciBldmVyeSB0ZXN0LlxuICpcbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBcmliYUNvbXBvbmVudHNUZXN0UHJvdmlkZXJNb2R1bGUge1xuXG5cbiAgICBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBBcmliYUNvbXBvbmVudHNUZXN0UHJvdmlkZXJNb2R1bGUsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBNb2RhbFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgQ29tcG9uZW50UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRXJyb3JNYW5hZ2VyU2VydmljZSxcbiAgICAgICAgICAgICAgICBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIERhdGFQcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgRGF0YUZpbmRlcnMsXG4gICAgICAgICAgICAgICAgQXdOYW1lU3RvcmUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBBUFBfSU5JVElBTElaRVIsXG4gICAgICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IHJlZ2lzdGVyQ29tcG9uZW50cyxcbiAgICAgICAgICAgICAgICAgICAgZGVwczogW0NvbXBvbmVudFJlZ2lzdHJ5XSxcbiAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9uZW50cyhjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KTogRnVuY3Rpb24ge1xuICAgIHJldHVybiBjb21wUmVnaXN0cnkuaW5pdGlhbGl6ZS5iaW5kKGNvbXBSZWdpc3RyeSwgY29tcG9uZW50cyk7XG59XG5cblxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19leHRlbmRzIiwib2JzZXJ2YWJsZU9mIiwiSW5wdXRUZXh0TW9kdWxlIiwic3RhdGUiLCJ0c2xpYl8xLl9fdmFsdWVzIiwicmVnaXN0ZXJDb21wb25lbnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrRkksK0JBQW9CLGNBQWdDO1FBQWhDLG1CQUFjLEdBQWQsY0FBYyxDQUFrQjtLQUVuRDtJQVpELHNCQUNJLHVDQUFJOzs7OztRQURSLFVBQ1MsSUFBUztZQUVkLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO1NBQzlCOzs7T0FBQTs7Ozs7Ozs7O0lBYUQsMkNBQVc7Ozs7O0lBQVgsVUFBWSxPQUFzQjtRQUU5QixJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDMUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsSUFBSSxD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