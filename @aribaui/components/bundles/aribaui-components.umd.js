(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@aribaui/core'), require('@angular/forms'), require('@angular/platform-browser'), require('@angular/common'), require('rxjs'), require('primeng/components/inputtext/inputtext'), require('rxjs/operators'), require('primeng/primeng'), require('@angular/animations'), require('@angular/router'), require('primeng/components/utils/objectutils')) :
    typeof define === 'function' && define.amd ? define('@aribaui/components', ['exports', '@angular/core', '@aribaui/core', '@angular/forms', '@angular/platform-browser', '@angular/common', 'rxjs', 'primeng/components/inputtext/inputtext', 'rxjs/operators', 'primeng/primeng', '@angular/animations', '@angular/router', 'primeng/components/utils/objectutils'], factory) :
    (factory((global.aribaui = global.aribaui || {}, global.aribaui.components = {}),global.ng.core,null,global.ng.forms,global.ng.platformBrowser,global.ng.common,global.rxjs,null,global.rxjs.operators,null,global.ng.animations,global.ng.router,null));
}(this, (function (exports,core,core$1,forms,platformBrowser,common,rxjs,inputtext,operators,primeng,animations,router,objectutils) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * When we have a custom component like dropdown, radiobuttonlist and
     * many more we want to provide a custom content to it like so:
     *
     * ```
     *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
     *      {{item.userName}}
     *
     *   <aw-dropdown
     *
     * ```
     * Who else would know how to render list of objects..
     *
     * But its not possible in current form. if I do not provide Angular some as they call it this
     * syntactic sugar *,
     *
     *
     * ```
     *  <aw-dropdown *mySugerDirective=.....>
     *      {{item.userName}}
     *
     *   <aw-dropdown
     * ```
     *
     *
     * then angular will not know  inside is a template and I wont be able to get hold of TemplateRef
     * inside the component
     *
     * So the only way I found (expecting I do not want to change anything in terms of bindings and the
     * signature I use it. I have to use it like this:
     *
     * ```
     *  <aw-dropdown [list]="listOfUsers" let somehowGetItemOut>
     *      <ng-template let-item> {{item.userName}}</ng-template>
     *
     *   <aw-dropdown
     *
     * ```
     *
     *  This way it could work. Since I am inside ngFor I want to render the item into the correct
     * viewContainer of ngFor's current item.
     *
     *  This way I can also expose item outside using Angular's special local variable called:
     * $implicit.
     *
     * This gets even more complex if we try to pass this template 2 levels down, like in case of
     * RadioButtonList. But later on I might want to refactor this into custom NG FOR
     *
     * @deprecated in favor of ngTemplateOutlet (will be removed in the next version)
     *
     */
    var EmbeddedItemDirective = (function () {
        function EmbeddedItemDirective(_viewContainer) {
            this._viewContainer = _viewContainer;
        }
        Object.defineProperty(EmbeddedItemDirective.prototype, "item", {
            set: /**
             * @param {?} item
             * @return {?}
             */ function (item) {
                this._implicitValue = item;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        /**
         *
         * @param {?} changes
         * @return {?}
         */
        EmbeddedItemDirective.prototype.ngOnChanges = /**
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (core$1.isPresent(this._viewRef)) {
                    this._viewContainer.remove(this._viewContainer.indexOf(this._viewRef));
                }
                if (core$1.isPresent(this.embeddedItem)) {
                    var /** @type {?} */ context = new EmbededItem(this._implicitValue);
                    this._viewRef = this._viewContainer.createEmbeddedView(this.embeddedItem, context);
                }
            };
        EmbeddedItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[embeddedItem]' },] },
        ];
        /** @nocollapse */
        EmbeddedItemDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef }
            ];
        };
        EmbeddedItemDirective.propDecorators = {
            embeddedItem: [{ type: core.Input }],
            item: [{ type: core.Input }]
        };
        return EmbeddedItemDirective;
    }());
    /**
     * Wrapper class around Angular's EmbeddedViewRef.context()
     *
     */
    var /**
     * Wrapper class around Angular's EmbeddedViewRef.context()
     *
     */ EmbededItem = (function () {
        function EmbededItem($implicit) {
            this.$implicit = $implicit;
        }
        return EmbededItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * GenericContainerComponent is used by include-component.directive to dynamically create an
     * HTMLElement and use this element to wrap a child component. This is very useful when we want to
     * modify a child by wrapping it with a border, a background, or bold its text.
     *
     * The wrapper element is dynamically created. It's element is specified by the tagName property in
     * the bindings \@Input.
     *
     *  ### Example.  Directly in html
     *
     *   app.html
     *      <aw-generic-container tagName="tagName" bindings="bindings">
     *          <my-component ..bindings..></my-component>
     *      </aw-generic-container>
     *
     *   app.component.ts
     *
     *       tagName = (bBold) ? 'h1' : 'span';
     *       bindings = {  style: 'background-color: red' }
     *
     */
    var GenericContainerComponent = (function () {
        /**
         * param renderer - Renderer is used to create 'tagName' element.
         */
        function GenericContainerComponent(renderer, element) {
            this.renderer = renderer;
            this.element = element;
            this.nativeElement = element.nativeElement;
        }
        /**
         * During the initialization, verify that at least one input has been set.
         */
        /**
         * During the initialization, verify that at least one input has been set.
         * @return {?}
         */
        GenericContainerComponent.prototype.ngOnInit = /**
         * During the initialization, verify that at least one input has been set.
         * @return {?}
         */
            function () {
                // If there's no input, this component wouldn't know what to do and throw exception.
                if (core$1.isBlank(this.bindings) && core$1.isBlank(this.tagName)) {
                    throw new Error('GenericContainerComponent input bindings or tagName ' +
                        'have not been set.');
                }
                // If the tagName is blank, the get it from bindings.
                if (core$1.isBlank(this.tagName)) {
                    this.tagName = this.bindings.get('tagName');
                    if (core$1.isBlank(this.tagName)) {
                        this.tagName = GenericContainerComponent.DefaultTagName;
                    }
                }
                // Save first added
                this.childElement = this.nativeElement.firstChild;
                this.doRender();
            };
        /**
         * @return {?}
         */
        GenericContainerComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.childElement) &&
                    this.childElement.parentNode !== this.nativeElement.firstChild) {
                    this.nativeElement.firstChild.appendChild(this.childElement);
                }
            };
        /**
         * After content has been initialized. Create the tagName element. Apply all the bindings on to
         * the element as attribute. Finally, move the child element, <ng-content>, to inside the
         * wrapper component.
         * @return {?}
         */
        GenericContainerComponent.prototype.doRender = /**
         * After content has been initialized. Create the tagName element. Apply all the bindings on to
         * the element as attribute. Finally, move the child element, <ng-content>, to inside the
         * wrapper component.
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ el = this.renderer.createElement(this.tagName);
                if (core$1.isPresent(this.nativeElement)) {
                    this.renderer.appendChild(this.nativeElement, el);
                }
                // Loop through all the bindings and add them to the element.
                core$1.MapWrapper.iterable(this.bindings).forEach(function (v, k) {
                    _this.renderer.setStyle(el, k, v);
                });
                // Attach the component to this divElement.
                el.appendChild(this.childElement);
            };
        /**
         * Default tagName if none is specified inside bindings.
         *
         */
        GenericContainerComponent.DefaultTagName = 'div';
        GenericContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-generic-container',
                        template: '<ng-content></ng-content>',
                        styles: []
                    },] },
        ];
        /** @nocollapse */
        GenericContainerComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.ElementRef }
            ];
        };
        GenericContainerComponent.propDecorators = {
            bindings: [{ type: core.Input }],
            tagName: [{ type: core.Input }]
        };
        return GenericContainerComponent;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (b.hasOwnProperty(p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  Base component shares common functionality among all the components (layouts, widgets).
     *
     * @abstract
     */
    var BaseComponent = (function () {
        function BaseComponent(env) {
            this.env = env;
            /**
             * Adds disabled flag to the component
             *
             */
            this.disabled = false;
            /**
             * Weather this component is visible
             * Default is false;
             */
            this.visible = false;
            /**
             * Tell  the component if we are in editing mode.
             *
             */
            this.editable = true;
            /**
             * Removes padding from the component. Usually used when we are nesting other component with
             * its own grid.
             */
            this.omitPadding = false;
            /**
             * Prefix for the correct asset path
             */
            this.assetFolder = 'assets';
            this.extBindings = new Map();
            this.omitPadding = false;
        }
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.assetFolder = this.env.getValue(core$1.AppConfig.AssetFolder);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        BaseComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
            };
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        BaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
            };
        BaseComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            visible: [{ type: core.Input }],
            editable: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            styleClass: [{ type: core.Input }],
            omitPadding: [{ type: core.Input }]
        };
        return BaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var WidgetSizeColumns = {
        xsmall: 1,
        small: 3,
        medium: 6,
        large: 9,
        xlarge: 12,
    };
    WidgetSizeColumns[WidgetSizeColumns.xsmall] = "xsmall";
    WidgetSizeColumns[WidgetSizeColumns.small] = "small";
    WidgetSizeColumns[WidgetSizeColumns.medium] = "medium";
    WidgetSizeColumns[WidgetSizeColumns.large] = "large";
    WidgetSizeColumns[WidgetSizeColumns.xlarge] = "xlarge";
    /**
     *  BaseFormComponnet extends BaseComponent for add specific form behavior
     *
     * @abstract
     */
    var BaseFormComponent = (function (_super) {
        __extends(BaseFormComponent, _super);
        /**
         * Some of the BaseFormComponent can wrap other component and in these cases we want to
         * inherit some of the behavior from parent
         *
         * @Inject(Environment) public env: Environment : is tem a workaround as without inject
         * on this specific component it complains that Environment is unresolved symbol
         *
         */
        function BaseFormComponent(env, parentContainer) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * Is current element visible
             */
            _this.hidden = false;
            /**
             * Renders required flex around the component
             *
             */
            _this.required = false;
            /**
             *  a text displayed when value is empty or NULL
             */
            _this.placeHolder = '';
            /**
             * Identify if this control is used directly or if its part of some other control
             * e.g. GenericChooser and managed by this control.
             * Meaning State is mananged outside of this component
             *
             */
            _this.isStandalone = true;
            _this.onModelChanged = core$1.noop;
            _this.onModelTouched = core$1.noop;
            return _this;
        }
        /**
         * @return {?}
         */
        BaseFormComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.parentContainer)) {
                    this.formGroup = this.parentContainer.formGroup;
                    this.editable = this.parentContainer.editable;
                }
                this.checkInitForm();
            };
        /**
         * Make sure that we have available formGroup and Name and ID
         *
         */
        /**
         * Make sure that we have available formGroup and Name and ID
         *
         * @return {?}
         */
        BaseFormComponent.prototype.checkInitForm = /**
         * Make sure that we have available formGroup and Name and ID
         *
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.env.currentForm)) {
                    this.env.currentForm = new forms.FormGroup({});
                }
                /**
                         * Todo: Right now I just need to initialize name , but ideally it needs to be generated
                         * number basedon some semantics app.page.component if there are more component on the page
                         * then app.page.componentNumber. Simple solution is to is to get Elementref and query it.
                         */
                if (core$1.isBlank(this.name)) {
                    this.name = core$1.uuid();
                }
                if (core$1.isBlank(this.id)) {
                    this.id = core$1.uuid();
                }
            };
        /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        BaseFormComponent.prototype.doRegister = /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
            function (name, value) {
                var /** @type {?} */ fControl;
                if (core$1.isBlank(this.formGroup.controls[name])) {
                    this.formGroup.registerControl(name, new forms.FormControl(value));
                    fControl = /** @type {?} */ (this.formGroup.controls[name]);
                }
                else {
                    fControl = /** @type {?} */ (this.formGroup.controls[name]);
                    var /** @type {?} */ updatedValue = core$1.isPresent(fControl.value) ? fControl.value : value;
                    fControl.patchValue(updatedValue, { onlySelf: true, emitEvent: false });
                }
                return fControl;
            };
        /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param value default value to be pre-set
         */
        /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param {?} value default value to be pre-set
         * @return {?}
         */
        BaseFormComponent.prototype.registerFormControl = /**
         * When we are dealing with Forms this is a helper method to register control
         *
         *
         * @param {?} value default value to be pre-set
         * @return {?}
         */
            function (value) {
                this.formControl = this.doRegister(this.name, value);
                if (this.disabled) {
                    this.formControl.disable();
                }
            };
        Object.defineProperty(BaseFormComponent.prototype, "formGroup", {
            get: /**
             * @return {?}
             */ function () {
                return core$1.isPresent(this._formGroup) ? this._formGroup : this.env.currentForm;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._formGroup = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         */
        /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         * @return {?}
         */
        BaseFormComponent.prototype.canSetType = /**
         * Indicates if we can pass field type as a binding to the components. e.g. InputField need
         * such type to correctly render input type=text, number
         *
         * todo: is this needed? can we maybe pass this to the formRow?
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        BaseFormComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        BaseFormComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onModelChanged = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        BaseFormComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onModelTouched = fn;
            };
        /*
             *  Supported layout constants. It is expected there will be more options as we currently
             *  support only these two there will be other variations of it. e.g. for stacked it will not
             *  be 1 columns like it is now but multiple columns
             *
             */
        BaseFormComponent.LayoutStacked = 'stacked';
        BaseFormComponent.LayoutInline = 'inline';
        /** @nocollapse */
        BaseFormComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment, decorators: [{ type: core.Inject, args: [core$1.Environment,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        BaseFormComponent.propDecorators = {
            name: [{ type: core.Input }],
            id: [{ type: core.Input }],
            hidden: [{ type: core.Input }],
            required: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            isStandalone: [{ type: core.Input }],
            formGroup: [{ type: core.Input }]
        };
        return BaseFormComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Simple component rendering values in the read only mode. Just needed some component used
     * to render Strings in read only mode
     *
     *
     *  ### Example
     *
     * Using it inside form container along with label
     *
     *
     *  ```
     * \@Component({
     *              selector: 'userInfo' ,
     *              template: `
     *                      <aw-form-table [editable]="false" >
     *                          <aw-form-row [name]="fieldName"  [label]="label">
     *                                 <aw-string [value]="inputValue" ></aw-string>
     *                           </aw-form-row>
     *                      </aw-form-table>
     *
     *                  `
     *          })
     *          export class UserProfileComponent
     *          {
     *              inputValue: string = 'Some text';
     *              inputType: string = 'string';
     *              fieldName: string = 'firstName';
     *              label: string = 'My Name';
     *              required: boolean = true;
     *              editing: boolean = true;
     *              labelsOnTop: boolean = false;
     *
     *          }
     *
     *  ```
     *
     * You can also pass html tags.
     *
     */
    var StringComponent = (function (_super) {
        __extends(StringComponent, _super);
        function StringComponent(env, sanitizer, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.sanitizer = sanitizer;
            _this.parentContainer = parentContainer;
            /**
             *  Value to be interpolated
             *
             */
            _this._value = '';
            return _this;
        }
        Object.defineProperty(StringComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.sanitizer.bypassSecurityTrustHtml(this._value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        StringComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-string',
                        template: "\n        <span class=\"w-string-field\" [innerHTML]=\"value\"></span>\n    ",
                        styles: [".w-string-field{display:inline-block}"]
                    },] },
        ];
        /** @nocollapse */
        StringComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: platformBrowser.DomSanitizer },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        StringComponent.propDecorators = {
            value: [{ type: core.Input }]
        };
        return StringComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A class holding a references to components. The methods are self-explanatory.
     *
     */
    var ComponentRegistry = (function () {
        function ComponentRegistry(env) {
            this.env = env;
            this._nameToType = new Map();
        }
        /**
         * @param {?} references
         * @return {?}
         */
        ComponentRegistry.prototype.initialize = /**
         * @param {?} references
         * @return {?}
         */
            function (references) {
                this.registerTypes(references);
                var /** @type {?} */ promise = new Promise(function (resolve) {
                    resolve(true);
                });
                return promise;
            };
        /**
         * @param {?} name
         * @param {?} type
         * @return {?}
         */
        ComponentRegistry.prototype.registerType = /**
         * @param {?} name
         * @param {?} type
         * @return {?}
         */
            function (name, type) {
                if (!this.nameToType.has(name)) {
                    this._nameToType.set(name, type);
                }
            };
        /**
         * @param {?} references
         * @return {?}
         */
        ComponentRegistry.prototype.registerTypes = /**
         * @param {?} references
         * @return {?}
         */
            function (references) {
                var _this = this;
                if (!core$1.isStringMap(references)) {
                    return;
                }
                Object.keys(references).forEach(function (name) {
                    _this.registerType(name, references[name]);
                });
            };
        Object.defineProperty(ComponentRegistry.prototype, "nameToType", {
            get: /**
             * @return {?}
             */ function () {
                return this._nameToType;
            },
            enumerable: true,
            configurable: true
        });
        ComponentRegistry.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ComponentRegistry.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        return ComponentRegistry;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  `IncludeComponent` directive dynamically instantiate and insert a components into the screen
     * based on the name. It can accepts bindings as well which will be automatically bound and applied
     * to the component
     *
     *  ### usage:
     *
     *  Instead of inserting component in the way:
     *
     *  ```
     *    <textfield value="some value">
     *
     *  ```
     *
     *  you can do so dynamically like this:
     *
     * ```
     *  <aw-include-component 'TextfieldComponent' [bindings]=bindings ></aw-include-component>
     * ```
     *
     * This is the main building block to dynamically generated UI.
     *
     *
     * Todo: Currently the way Angular API work and we use it to create programatically components
     * is too complext we need to create everything 3 different calls to place a component to the
     * container. What I want is is to create some kind of representation of ContainerElement and this
     * can be also parent for our BaseComponent with method add and remove content. Then we could have
     * some AWContent.
     *
     * e.g.: to replace applyContentElementIfAny where we have several calls to create and add
     * component to the view.
     *
     * ```ts
     *  let containerElement = AWConcreteTemplate(viewContainer, factoryResolver)
     *  containerElement.add('Clck Me')
     * ```
     *
     * To assemble different components together - not only adding string content
     *
     * ```ts
     *  let content = new AWContent(ButtonComponent, bindingsMap)
     *  content.add('Click Me');
     *  containerElement.add(content)
     *
     * ```
     *
     * add more component hierarchy:
     *
     * ```ts
     *  let content = new AWContent(HoverCardComponnets, bindingsMap)
     *  content.add(createLayout();
     *  containerElement.add(content)
     *
     * ```
     *
     *
     *
     *
     */
    var IncludeComponentDirective = (function () {
        function IncludeComponentDirective(viewContainer, factoryResolver, cd, compRegistry) {
            this.viewContainer = viewContainer;
            this.factoryResolver = factoryResolver;
            this.cd = cd;
            this.compRegistry = compRegistry;
            /**
             * I use this flag to identify that component is rendering for first time or its updated during
             * change detection
             *
             */
            this.initRenderInProgress = false;
            /**
             * Not sure if we need this, but want to keep it here or maybe move it to some service so we
             * can cache created components and maybe reuse them.
             *
             */
            this.componentReferences = new Map();
            this.bindings = new Map();
        }
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initRenderInProgress = true;
                // todo: check if this the right lifecycle callback, this is called only once and you want
                // to probably listen for changes, and change dection decide there is some change and we
                // need to re-draw the view
                this.viewContainer.clear();
                this.doRenderComponent();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (core$1.isPresent(changes['name']) &&
                    (changes['name'].currentValue !== changes['name'].previousValue)) {
                    this.viewContainer.clear();
                    this.doRenderComponent();
                }
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.initRenderInProgress = false;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // check to see if we need to render and reposition DOM element both for wrapper and
                // content
                this.createWrapperElementIfAny();
                this.createContentElementIfAny();
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         */
        /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.createWrapperElementIfAny = /**
         * Handles a case where we need to resolve additional component and wrap the current one.
         * Just like reateContentElementIfAny() this method needs to be executed after all
         * is created and initialized (inside the ngAfterViewInit() )
         *
         * @return {?}
         */
            function () {
            };
        /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         */
        /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         * @return {?}
         */
        IncludeComponentDirective.prototype.doRenderComponent = /**
         * Renders a component into actual View Container. The process goes as this.
         *  1. We retrieve component Type based on the component name, which creates componentRef
         *  2. Place the component onto the screen
         *  3. Read component metadata, mainly INPUTs and apply bindings for each of them
         *  4. Manually spin change detection to update the screen. Mainly for case where I need to
         * redraw a screen
         * @return {?}
         */
            function () {
                var _this = this;
                this.placeTheComponent();
                // this.currentComponent.changeDetectorRef.detach();
                this.applyBindings(this.componentReference(), this.currentComponent, this.bindings);
                // this.currentComponent.changeDetectorRef.detectChanges();
                // Still not sure about this what all I should release here.
                this.currentComponent.onDestroy(function () {
                    // this.bindings.clear();
                    // this.bindings = undefined;
                    //
                    // this.componentReferences.clear();
                    // this.componentReferences = undefined;
                    // this.bindings.clear();
                    // this.bindings = undefined;
                    //
                    // this.componentReferences.clear();
                    // this.componentReferences = undefined;
                    _this.destroy();
                });
            };
        /**
         * Place actual component onto the screen using ViewContainerRef
         *
         */
        /**
         * Place actual component onto the screen using ViewContainerRef
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.placeTheComponent = /**
         * Place actual component onto the screen using ViewContainerRef
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ reference = this.componentReference();
                this.currentComponent = this.viewContainer.createComponent(reference.resolvedCompFactory);
            };
        /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return need to run detect changes ? default is false
         */
        /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return {?} need to run detect changes ? default is false
         */
        IncludeComponentDirective.prototype.createContentElementIfAny = /**
         * When inserting Component that needs to have a content like e.g. hyperlink or button
         *
         * ```
         *   <button> MY NG CONTENT </button>
         *
         * ```
         *  this method applies and insert a child content into the main component. This method insert
         * a simple string. We are not wrapping existing component with another component here.
         *
         * @return {?} need to run detect changes ? default is false
         */
            function () {
                var /** @type {?} */ detectChanges = false;
                var /** @type {?} */ ngContent = this.ngContent();
                var /** @type {?} */ ngContentElement = this.ngContentElement();
                if (core$1.isPresent(ngContent)) {
                    var /** @type {?} */ awContentComponent = this.factoryResolver.resolveComponentFactory(StringComponent);
                    var /** @type {?} */ component = this.viewContainer.createComponent(awContentComponent, 0);
                    ((component.instance)).value = ngContent;
                    var /** @type {?} */ awContentContainer = this.currentComponent.location.nativeElement.firstChild;
                    awContentContainer.appendChild(component.location.nativeElement);
                    detectChanges = true;
                }
                else if (core$1.isPresent(ngContentElement)) ;
                return detectChanges;
            };
        /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         */
        /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngContent = /**
         *
         * Retrieve a NG Content from binding list and remove it so it its not prepagated down when
         * applying other bindings.
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ content;
                if (core$1.isPresent(content = this.bindings.get(IncludeComponentDirective.NgContent))) {
                    this.bindings.delete(IncludeComponentDirective.NgContent);
                }
                return content;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngContentElement = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ content;
                if (core$1.isPresent(content = this.bindings.get(IncludeComponentDirective.NgContentElement))) {
                    this.bindings.delete(IncludeComponentDirective.NgContentElement);
                }
                return content;
            };
        /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         */
        /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         * @return {?}
         */
        IncludeComponentDirective.prototype.componentReference = /**
         * We need to convert a component name to actual a type and then use ComponentFactoryResolver
         * to instantiate a a component and save its information into our component references. The
         * reason why we have this component reference is we need to store Angular's component metadata
         * so we can iterate thru all the inputs and bind them to the context.
         *
         * returns {ComponentReference} a reference representing a compoent currently being rendered
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.resolvedComponentRef)) {
                    return this.resolvedComponentRef;
                }
                var /** @type {?} */ currType = this.resolveComponentType();
                var /** @type {?} */ componentFactory = this.factoryResolver
                    .resolveComponentFactory(currType);
                var /** @type {?} */ componentMeta = this.resolveDirective(componentFactory);
                var /** @type {?} */ compReference = {
                    metadata: componentMeta,
                    resolvedCompFactory: componentFactory,
                    componentType: currType,
                    componentName: this.name
                };
                this.resolvedComponentRef = compReference;
                return compReference;
            };
        /**
         * Iterates thru ComponentMetadata @Inputs() and check if we have available binding inside the
         * 'this.bindings'
         */
        /**
         * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
         * 'this.bindings'
         * @param {?} cRef
         * @param {?} component
         * @param {?} bindings
         * @return {?}
         */
        IncludeComponentDirective.prototype.applyBindings = /**
         * Iterates thru ComponentMetadata \@Inputs() and check if we have available binding inside the
         * 'this.bindings'
         * @param {?} cRef
         * @param {?} component
         * @param {?} bindings
         * @return {?}
         */
            function (cRef, component, bindings) {
                var /** @type {?} */ inputs = cRef.metadata.inputs;
                if (core$1.isBlank(inputs) || inputs.length === 0) {
                    return;
                }
                // should we do any type conversion?
                core$1.MapWrapper.iterable(bindings).forEach(function (v, k) {
                    if (core$1.isPresent(component.instance[k])) {
                        component.instance[k] = v;
                    }
                });
            };
        /**
         * Resolves a component Type based on the string literal
         *
         * @returns component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
        /**
         * Resolves a component Type based on the string literal
         *
         * @return {?} component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
        IncludeComponentDirective.prototype.resolveComponentType = /**
         * Resolves a component Type based on the string literal
         *
         * @return {?} component type used by `ComponentFactoryResolver`
         *
         * todo: rename the method so its clear that it returns component type based on string.
         */
            function () {
                var /** @type {?} */ componentType = this.compRegistry.nameToType.get(this.name);
                if (core$1.isBlank(componentType)) {
                    core$1.assert(false, this.name + ' component does not exists. Create Dummy Component instead' +
                        ' of throwing this error');
                    return;
                }
                return componentType;
            };
        /**
         * @param {?} compFactory
         * @return {?}
         */
        IncludeComponentDirective.prototype.resolveDirective = /**
         * @param {?} compFactory
         * @return {?}
         */
            function (compFactory) {
                var /** @type {?} */ compMeta = {
                    inputs: [],
                    outputs: []
                };
                if (core$1.isPresent(compFactory.inputs) && compFactory.inputs.length > 0) {
                    compFactory.inputs.forEach(function (input) {
                        compMeta.inputs.push(input.propName);
                    });
                }
                if (core$1.isPresent(compFactory.outputs) && compFactory.outputs.length > 0) {
                    compFactory.outputs.forEach(function (output) {
                        compMeta.outputs.push(output.propName);
                    });
                }
                return compMeta;
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.currentComponent)) {
                    this.currentComponent.destroy();
                    this.currentComponent = undefined;
                }
                if (core$1.isPresent(this.viewContainer)) {
                    this.viewContainer.clear();
                }
            };
        /**
         * @return {?}
         */
        IncludeComponentDirective.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.currentComponent)) {
                    this.currentComponent = null;
                    this.resolvedComponentRef = null;
                }
            };
        IncludeComponentDirective.NgContent = 'ngcontent';
        IncludeComponentDirective.NgContentElement = 'ngcontentElement';
        IncludeComponentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'aw-include-component'
                    },] },
        ];
        /** @nocollapse */
        IncludeComponentDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.ComponentFactoryResolver },
                { type: core.ChangeDetectorRef },
                { type: ComponentRegistry }
            ];
        };
        IncludeComponentDirective.propDecorators = {
            name: [{ type: core.Input }],
            bindings: [{ type: core.Input }]
        };
        return IncludeComponentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Error Manager is a service used by Forms components to map error codes into meaningful messages.
     * Currently it does not have much but once we plug in localization it will make more sense
     *
     *
     * todo: Once ng-translate is implemented replace this with ng-translate functionality so we can
     * externalize these messages into locale files.
     *
     */
    var ErrorManagerService = (function () {
        function ErrorManagerService() {
            this.messages = {
                'required': 'Required field',
                'minlength': 'Field does not meet minimum length',
                'maxlength': 'Field does not meet maximum length',
                'customMsg': '%s',
                'metavalid': '%s'
            };
        }
        /**
         * @param {?} validatorName
         * @param {?=} validatorValue
         * @return {?}
         */
        ErrorManagerService.prototype.errorMessage = /**
         * @param {?} validatorName
         * @param {?=} validatorValue
         * @return {?}
         */
            function (validatorName, validatorValue) {
                var /** @type {?} */ message = this.messages[validatorName];
                if (core$1.StringWrapper.contains(message, '%s')) {
                    // todo: use ng-translate with proper message formatting
                    return core$1.StringWrapper.replace(message, '%s', validatorValue.msg);
                }
                return message;
            };
        ErrorManagerService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ErrorManagerService.ctorParameters = function () { return []; };
        return ErrorManagerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * ErrorMessagesComponent is used by form's component like FormRow to print its validation errors.
     * Its  based on ModelDriven (Reactive forms) and it reads errors from FormControl
     *
     *
     *
     */
    var ErrorMessagesComponent = (function () {
        function ErrorMessagesComponent(errManager) {
            this.errManager = errManager;
        }
        /**
         * @return {?}
         */
        ErrorMessagesComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        ErrorMessagesComponent.prototype.hasMessage = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ msg = this.errorMsg;
                return core$1.isPresent(msg);
            };
        Object.defineProperty(ErrorMessagesComponent.prototype, "errorMsg", {
            /**
             * Retrieve a messages if any registered by added validators
             *
             */
            get: /**
             * Retrieve a messages if any registered by added validators
             *
             * @return {?}
             */ function () {
                for (var /** @type {?} */ propertyName in this.control.errors) {
                    if (this.control.errors.hasOwnProperty(propertyName) && this.control.touched) {
                        return this.errManager.errorMessage(propertyName, this.control.errors[propertyName]);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         */
        /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         * @return {?}
         */
        ErrorMessagesComponent.prototype.showErrors = /**
         *
         * Show errors? We currently shows errors if the control is not valid, it was touched by user.
         * Most of the type on blur event  and at last its not pristine anymore (its dirty)
         *
         * @return {?}
         */
            function () {
                return !this.control.valid && !this.control.pristine && this.control.touched;
            };
        ErrorMessagesComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'a-error-messages',
                        template: "\n            <div class=\"ui-g\">\n                    <small *ngIf=\"hasMessage()\"\n                        class=\"ui-g-12 ui-message ui-messages-error ui-corner-all\">\n                        {{ errorMsg }}\n                    </small>\n            </div>\n    ",
                        styles: [""]
                    },] },
        ];
        /** @nocollapse */
        ErrorMessagesComponent.ctorParameters = function () {
            return [
                { type: ErrorManagerService }
            ];
        };
        ErrorMessagesComponent.propDecorators = {
            control: [{ type: core.Input }]
        };
        return ErrorMessagesComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Modal service is used to to create modal dialogs. It creates modal dialogs dynamically.
     * The service also keeps track of the created modal dialog and can close it by calling the
     * service's close()
     *
     * Modal service requires a ViewContainer to insert newly created modals. This is taken care
     * by the ModalComponent.
     *
     * Usage:
     *     Add   <aw-modal></aw-modal>  into your application main html. It needs to be on every
     *     page where a modal dialog will appear.
     *
     *    1.  Popup a dialog without creating your own component.
     *        Use the existing DialogComponent in widgets.
     *
     *             this.modalService.open<DialogComponent>(DialogComponent, {
     *                     title: 'My Popup Title',
     *                     body: 'My Popup Body'
     *              });
     *
     *
     *   2.   Creating your own Dialog Component to popup.
     *
     *         let componentRef = this.modalService.open<MyDialogComponent>(MyDialogComponent,
     * {inputs});
     *
     * \@Component({
     *                selector: 'aw-mydialog' ,
     *                           template: `
     *                                         <aw-dialog (onClose)="closePopup()">
     *                                              <ng-template #titleTemplate>
     *                                                 <span><i class="fa fa-envira" ></i>This is my
     *     Title </span>
     *                                              </ng-template>
     *                                              <ng-template #bodyTemplate>
     *                                                 <span><i class="fa fa-envira" ></i>This is my
     *     Body </span>
     *                                              </ng-template>
     *                                        </aw-dialog>
     *                                     `
     *         })
     *         export class MyDialogComponent extends DialogComponent implements OnInit {
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     closePopup() {
     *                            this.modalService.close();
     *                      }
     *         }
     */
    var ModalService = (function () {
        /**
         * DI ComponentFactoryResolver to be used to create modal component.
         *
         * @param cfr
         */
        function ModalService(cfr) {
            this.cfr = cfr;
        }
        /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param vcRef
         */
        /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param {?} vcRef
         * @return {?}
         */
        ModalService.prototype.registerViewContainerRef = /**
         *  PlaceHolder for modal to be inserted.
         *
         * @param {?} vcRef
         * @return {?}
         */
            function (vcRef) {
                this.vcRef = vcRef;
            };
        /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         */
        /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         * @template T
         * @param {?} component
         * @param {?=} parameters
         * @return {?}
         */
        ModalService.prototype.open = /**
         * Opens the modal dialog by dynamically creating the component and adding it to vcRef.
         *
         * @template T
         * @param {?} component
         * @param {?=} parameters
         * @return {?}
         */
            function (component, parameters) {
                var /** @type {?} */ cf = this.cfr.resolveComponentFactory(component);
                var /** @type {?} */ componentRef = this.vcRef.createComponent(cf);
                // Auto set visiblity to true. So that the Dialog will display
                parameters = (parameters) ? parameters : {};
                parameters['visible'] = true;
                // Handle output parameters.
                ModalService.OUTPUT_PARAMETERS.forEach(function (param) {
                    if (parameters[param]) {
                        ((componentRef.instance))[param].subscribe(parameters[param]);
                        delete parameters[param];
                    }
                });
                Object.assign(componentRef.instance, parameters);
                // had to cast it in order to avoid any index Error
                // Attach a destroy method to the newly created component.
                ((componentRef.instance))['destroy'] = function () {
                    componentRef.destroy();
                };
                // Save the instance, so it can be destroyed later.
                this.instance = componentRef;
                return componentRef;
            };
        /**
         * Calling close() will remove the modal from view.
         */
        /**
         * Calling close() will remove the modal from view.
         * @return {?}
         */
        ModalService.prototype.close = /**
         * Calling close() will remove the modal from view.
         * @return {?}
         */
            function () {
                if (this.instance) {
                    this.instance.destroy();
                    this.instance = null;
                }
            };
        /**
         * This is a static list of output parameter from Dialog, Confirmation components
         * that needs to be handled.
         *
         */
        ModalService.OUTPUT_PARAMETERS = ['onClose', 'onConfirm', 'onCancel'];
        ModalService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ModalService.ctorParameters = function () {
            return [
                { type: core.ComponentFactoryResolver }
            ];
        };
        return ModalService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Place holder for all modal dialogs. This component works with the modalService by providing
     * a place holder for it to inject Dialog component into.
     */
    var ModalComponent = (function () {
        function ModalComponent(modalService) {
            this.modalService = modalService;
        }
        /**
         * @return {?}
         */
        ModalComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.modalService.registerViewContainerRef(this.viewContainerRef);
            };
        ModalComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-modal',
                        template: "<div #modal></div>\n",
                        styles: [""]
                    },] },
        ];
        /** @nocollapse */
        ModalComponent.ctorParameters = function () {
            return [
                { type: ModalService }
            ];
        };
        ModalComponent.propDecorators = {
            viewContainerRef: [{ type: core.ViewChild, args: ['modal', { read: core.ViewContainerRef },] }]
        };
        return ModalComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This currency formatter will ignore null and empty string for value.
     * Issue : https://github.com/angular/angular/issues/8694  DI fails when extends other classes
     */
    var CurrencyFormatPipe = (function () {
        function CurrencyFormatPipe(currencyPipe) {
            this.currencyPipe = currencyPipe;
        }
        /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
        CurrencyFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {...?} args
         * @return {?}
         */
            function (value) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                // Default values
                var /** @type {?} */ currencyCode = 'USD', /** @type {?} */ symbolDisplay = true, /** @type {?} */ digits = '1.0-2';
                if (!value || value.length === 0) {
                    return value;
                }
                if (args && args.length > 0) {
                    var /** @type {?} */ code = args[0];
                    if (code && code.length > 0) {
                        currencyCode = code;
                    }
                }
                return this.currencyPipe.transform(value, currencyCode, symbolDisplay, digits);
            };
        CurrencyFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'currencyFormat',
                        pure: false
                    },] },
        ];
        /** @nocollapse */
        CurrencyFormatPipe.ctorParameters = function () {
            return [
                { type: common.CurrencyPipe }
            ];
        };
        return CurrencyFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Simple utility directive that is used by NG For cycle in situation where we need to call a
     * or execute some logic after each iteration
     */
    var NgForSetDirective = (function () {
        function NgForSetDirective() {
            this.onItem = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        NgForSetDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.onItem.emit('--');
            };
        NgForSetDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngForSet]'
                    },] },
        ];
        /** @nocollapse */
        NgForSetDirective.ctorParameters = function () { return []; };
        NgForSetDirective.propDecorators = {
            onItem: [{ type: core.Output }]
        };
        return NgForSetDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Simple convenient service to work with the dom. All the future logic related to DOM manipulation
     * or traversal should be put into this service
     *
     */
    var DomUtilsService = (function () {
        function DomUtilsService() {
        }
        /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         */
        /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
        DomUtilsService.prototype.hasParent = /**
         * goes all the way up to the body and checks if there is a element identified by a 'selector'
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
            function (nativeElement, selector) {
                return core$1.isPresent(this.closest(nativeElement, selector));
            };
        /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         */
        /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
        DomUtilsService.prototype.closest = /**
         *  Travels all the way up to the BODY and retrieve element identified by 'selector' or NULL if
         * not found
         *
         * @param {?} nativeElement
         * @param {?} selector
         * @return {?}
         */
            function (nativeElement, selector) {
                var /** @type {?} */ firstChar = selector.charAt(0);
                var /** @type {?} */ parentNode = nativeElement;
                while (core$1.isPresent((parentNode = parentNode.parentNode))) {
                    if (firstChar === '.' && parentNode.classList.contains(selector.substr(1))) {
                        return parentNode;
                    }
                    if (firstChar === '#' && parentNode.id === selector.substr(1)) {
                        return parentNode;
                    }
                    // If selector is a tag
                    if (parentNode.nodeType === 1 && parentNode.tagName.toLowerCase() === selector) {
                        return parentNode;
                    }
                    if (parentNode.nodeType === 1 && parentNode.tagName === 'BODY') {
                        return null;
                    }
                }
                return null;
            };
        /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         */
        /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         * @param {?} parentNativeEl
         * @param {?} childNativeEl
         * @return {?}
         */
        DomUtilsService.prototype.insertIntoParentNgContent = /**
         * When angular component is rendered along with NGContent it has its own _ngContent_INDEX
         * which always corresponds with _nghost_INDEX, this works fine if we have actual component
         * that is already rendered. If we are creating component programatically there is no way to
         * identify where the actual ng-content is placed within the component
         *
         * e.g. Consider following example:
         *
         *
         * Button Component Template:
         *
         * ```
         *  <span class=mybuttonTitle><ng-content></ng-content></span>
         * ```
         *
         * When you use button component as <aw-button>ClickMe</aw-button>  then its rendered as
         *
         * ```
         * <aw-button _nghost_123>
         *  <span _ngcontent_123 class=mybuttonTitle>ClickMe</span>
         * </aw-button>
         * ```
         *
         * But with programmatic API you instantiate Button and since it created without a Content it
         * looks like this;
         *
         *  ```
         * <aw-button _nghost_123>
         *  <span class=mybuttonTitle></span>
         * </aw-button>
         * ```
         *
         * Where do you place you child (content component)? Therefore utility css class was created
         * to wrap <ng-content> to get around this limitation.
         *
         *  ```
         *   <span class="u-ngcontent">
         *      <ng-content></ng-content>
         *   </span>
         *  ````
         *
         *
         *
         *
         * @param {?} parentNativeEl
         * @param {?} childNativeEl
         * @return {?}
         */
            function (parentNativeEl, childNativeEl) {
                // default behavior is to insert it as child to parentNativeEl
                var /** @type {?} */ ngContentParent = parentNativeEl;
                var /** @type {?} */ foundNgContent = parentNativeEl.querySelector('.u-ngcontent');
                if (core$1.isPresent(foundNgContent)) {
                    // we don't cover a case where there could be multiple ngcontents
                    ngContentParent = foundNgContent;
                }
                ngContentParent.appendChild(childNativeEl);
            };
        /**
         *
         * Retrieves current browser window width and height
         *
         */
        /**
         *
         * Retrieves current browser window width and height
         *
         * @return {?}
         */
        DomUtilsService.prototype.browserDimentions = /**
         *
         * Retrieves current browser window width and height
         *
         * @return {?}
         */
            function () {
                return {
                    width: (window.innerWidth || document.documentElement.clientWidth
                        || document.body.clientWidth),
                    height: (window.innerHeight || document.documentElement.clientHeight
                        || document.body.clientHeight)
                };
            };
        /**
         *
         * Retrieves elemements dimensions
         *
         */
        /**
         *
         * Retrieves elemements dimensions
         *
         * @param {?} element
         * @return {?}
         */
        DomUtilsService.prototype.elementDimensions = /**
         *
         * Retrieves elemements dimensions
         *
         * @param {?} element
         * @return {?}
         */
            function (element) {
                if (core$1.isPresent(element.getBoundingClientRect)) {
                    return element.getBoundingClientRect();
                }
                return { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0, width: 0, height: 0 };
            };
        DomUtilsService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DomUtilsService.ctorParameters = function () { return []; };
        return DomUtilsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The Infinite Scroll allows you to perform an action when the user
     * scrolls a specified distance from the bottom or top of the page.
     *
     * The expression assigned to the `infinite` event is called when
     * the user scrolls to the specified distance. When this expression
     * has finished its tasks, it should call the `complete()` method
     * on the infinite scroll instance.
     *
     * ## Usage
     *
     * ```html
     *
     *  <div  *ngFor="let item of items">{{item}} </div>
     *   <aw-infinite-scroll (onLoad)="doInfinite($event)">
     *  </aw-infinite-scroll>
     *
     * ```
     *
     *
     * You can also set a threshold to change the distance when the lazy load kicks
     * in.
     * ## Usage
     *
     * ```html
     *
     *  <div  *ngFor="let item of items">{{item}} </div>
     *   <aw-infinite-scroll (onLoad)="doInfinite($event)"  [distance]="'15%'">
     *  </aw-infinite-scroll>
     *
     * ```
     */
    var InfiniteScrollComponent = (function () {
        function InfiniteScrollComponent(_render, _zone, domUtils, _cd) {
            this._render = _render;
            this._zone = _zone;
            this.domUtils = domUtils;
            this._cd = _cd;
            this._lastCheck = 0;
            this._lastScrollTop = 0;
            this._thr = '10%';
            this._thrPx = 0;
            this._thrPc = 0.10;
            this._init = false;
            /**
             * \@internal
             */
            this.state = STATE_ENABLED;
            /**
             * \@output {event} Emitted when the scroll reaches
             * the threshold distance. From within your infinite handler,
             * you must call the infinite scroll's `complete()` method when
             * your async operation has completed.
             */
            this.onLoad = new core.EventEmitter();
            /**
             *
             * Lazy load current numbers. tell the app starting point and what is the size of loaded
             * list
             *
             */
            this.fetchSize = 0;
            this.loadOffset = 0;
        }
        Object.defineProperty(InfiniteScrollComponent.prototype, "distance", {
            /**
             * @input {string} The threshold distance from the bottom
             * of the content to call the `onLoad` output event when scrolled.
             * The threshold value can be either a percent, or
             * in pixels. For example, use the value of `10%` for the `infinite`
             * output event to get called when the user has scrolled 10%
             * from the bottom of the page. Use the value `100px` when the
             * scroll is within 100 pixels from the bottom of the page.
             * Default is `15%`.
             */
            get: /**
             * \@input {string} The threshold distance from the bottom
             * of the content to call the `onLoad` output event when scrolled.
             * The threshold value can be either a percent, or
             * in pixels. For example, use the value of `10%` for the `infinite`
             * output event to get called when the user has scrolled 10%
             * from the bottom of the page. Use the value `100px` when the
             * scroll is within 100 pixels from the bottom of the page.
             * Default is `15%`.
             * @return {?}
             */ function () {
                return this._thr;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this._thr = val;
                if (val.indexOf('%') > -1) {
                    this._thrPx = 0;
                    this._thrPc = (parseFloat(val) / 100);
                }
                else {
                    this._thrPx = parseFloat(val);
                    this._thrPc = 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollComponent.prototype, "enabled", {
            /**
             * @input {boolean} If true, Whether or not the infinite scroll should be
             * enabled or not. Setting to `false` will remove scroll event listeners
             * and hide the display.
             */
            set: /**
             * \@input {boolean} If true, Whether or not the infinite scroll should be
             * enabled or not. Setting to `false` will remove scroll event listeners
             * and hide the display.
             * @param {?} shouldEnable
             * @return {?}
             */ function (shouldEnable) {
                this.enable(shouldEnable);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._render.addClass(document.body, 'has-infinite-scroll');
            };
        /**
         * @param {?} ev
         * @return {?}
         */
        InfiniteScrollComponent.prototype._onScroll = /**
         * @param {?} ev
         * @return {?}
         */
            function (ev) {
                if (this.state === STATE_LOADING || this.state === STATE_DISABLED) {
                    return;
                }
                // must throttle the class by 100ms
                if (this._lastCheck + 100 > ev.timeStamp) {
                    // no need to check less than every XXms
                    return;
                }
                this._lastCheck = ev.timeStamp;
                var /** @type {?} */ scrollTop = this.scrollTop();
                var /** @type {?} */ winHeight = this.domUtils.browserDimentions().height;
                var /** @type {?} */ height = Math.max(this._docBody.scrollHeight, this._docBody.offsetHeight, winHeight, this._content.scrollHeight, this._content.offsetHeight);
                if (!height) {
                    // if there is no height of this element then do nothing
                    return;
                }
                var /** @type {?} */ threshold = this._thrPc ? (height * this._thrPc) : this._thrPx;
                var /** @type {?} */ distanceFromInfinite = this._content.scrollHeight - winHeight - scrollTop - threshold;
                // console.log('Document height (' + height + ') , Distance from bottom '
                // + distanceFromInfinite + ',  => threshold = ' +
                //     this.distance + ' (' + threshold + ')');
                if (distanceFromInfinite < 0 && this._lastScrollTop < scrollTop) {
                    this.fireOnLazyLoad();
                }
                else if (this._lastScrollTop > scrollTop && scrollTop < winHeight
                    && this.loadOffset !== this.fetchSize) {
                    this.fireOnLazyUnLoad();
                }
                this._lastScrollTop = scrollTop;
                return;
            };
        /**
         * Todo: refactor to one method
         * @return {?}
         */
        InfiniteScrollComponent.prototype.fireOnLazyLoad = /**
         * Todo: refactor to one method
         * @return {?}
         */
            function () {
                var _this = this;
                this._zone.run(function () {
                    if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                        _this.state = STATE_LOADING;
                        _this.onLoad.emit({
                            isLoad: true,
                            limit: _this.fetchSize,
                            offset: _this.loadOffset
                        });
                        // start on the next record
                        // start on the next record
                        _this.loadOffset += _this.fetchSize;
                    }
                });
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.fireOnLazyUnLoad = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._zone.run(function () {
                    if (_this.state !== STATE_LOADING && _this.state !== STATE_DISABLED) {
                        _this.state = STATE_LOADING;
                        // start on the next record
                        // start on the next record
                        _this.loadOffset = _this.fetchSize;
                        _this.onLoad.emit({
                            isLoad: false,
                            limit: _this.fetchSize,
                            offset: _this.loadOffset
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.scrollTop = /**
         * @return {?}
         */
            function () {
                return (window.pageYOffset || this._content.scrollTop);
            };
        /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         */
        /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         * @return {?}
         */
        InfiniteScrollComponent.prototype.complete = /**
         * Call `complete()` within the `infinite` output event handler when
         * your async operation has completed. For example, the `loading`
         * state is while the app is performing an asynchronous operation,
         * such as receiving more data from an AJAX request to add more items
         * to a data list. Once the data has been received and UI updated, you
         * then call this method to signify that the loading has completed.
         * This method will change the infinite scroll's state from `loading`
         * to `enabled`.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.state !== STATE_LOADING) {
                    return;
                }
                setTimeout(function () {
                    _this.state = STATE_ENABLED;
                    // need to trigger extra detect changes to rerender loading icon
                    // need to trigger extra detect changes to rerender loading icon
                    _this._cd.detectChanges();
                }, 100);
            };
        /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         */
        /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param {?} shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @return {?}
         */
        InfiniteScrollComponent.prototype.enable = /**
         * Call `enable(false)` to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This method is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         * @param {?} shouldEnable  If the infinite scroll should be
         * enabled or not. Setting to `false` will remove scroll event listeners
         * and hide the display.
         * @return {?}
         */
            function (shouldEnable) {
                this.state = (shouldEnable ? STATE_ENABLED : STATE_DISABLED);
                this._setListeners(shouldEnable);
            };
        /**
         * Subscribes to native windows scroll event
         */
        /**
         * Subscribes to native windows scroll event
         * @param {?} shouldListen
         * @return {?}
         */
        InfiniteScrollComponent.prototype._setListeners = /**
         * Subscribes to native windows scroll event
         * @param {?} shouldListen
         * @return {?}
         */
            function (shouldListen) {
                var _this = this;
                if (this._init) {
                    if (shouldListen) {
                        if (!this._scLsn) {
                            this._zone.runOutsideAngular(function () {
                                _this._scLsn = _this._onScroll.bind(_this);
                                window.addEventListener('scroll', _this._scLsn);
                            });
                        }
                    }
                    else {
                        if (core$1.isPresent(this._scLsn)) {
                            window.removeEventListener('scroll', this._scLsn);
                            this._scLsn = null;
                        }
                    }
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.isLoading = /**
         * @return {?}
         */
            function () {
                return this.state === STATE_LOADING;
            };
        /**
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this._init = true;
                this._docBody = document.body;
                this._content = document.documentElement;
                this._setListeners(this.state !== STATE_DISABLED);
                if (this.loadOffset === 0) {
                    this.fireOnLazyLoad();
                }
            };
        /**
         * @hidden
         */
        /**
         * @hidden
         * @return {?}
         */
        InfiniteScrollComponent.prototype.ngOnDestroy = /**
         * @hidden
         * @return {?}
         */
            function () {
                this._setListeners(false);
            };
        InfiniteScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-infinite-scroll',
                        template: "<div class=\"w-infinite-loader-panel\" *ngIf=\"isLoading()\">\n    <span class=\"sap-icon icon-synchronize u-spin-icon\"></span>\n</div>\n",
                        styles: [".w-infinite-loader-panel{display:flex;align-items:center;justify-content:center;background-color:#fff;width:100%;height:100px;z-index:300;bottom:100px}.w-infinite-loader-panel span{color:#4a4a4a;font-size:2em}"],
                    },] },
        ];
        /** @nocollapse */
        InfiniteScrollComponent.ctorParameters = function () {
            return [
                { type: core.Renderer2 },
                { type: core.NgZone },
                { type: DomUtilsService },
                { type: core.ChangeDetectorRef }
            ];
        };
        InfiniteScrollComponent.propDecorators = {
            distance: [{ type: core.Input }],
            enabled: [{ type: core.Input }],
            onLoad: [{ type: core.Output }],
            loadPanel: [{ type: core.ViewChild, args: ['loadinPanel',] }],
            fetchSize: [{ type: core.Input }]
        };
        return InfiniteScrollComponent;
    }());
    var /** @type {?} */ STATE_ENABLED = 'enabled';
    var /** @type {?} */ STATE_DISABLED = 'disabled';
    var /** @type {?} */ STATE_LOADING = 'loading';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AwNameStore = (function () {
        function AwNameStore() {
            this.store = new Map();
        }
        /**
         * @param {?} name
         * @param {?} el
         * @return {?}
         */
        AwNameStore.prototype.add = /**
         * @param {?} name
         * @param {?} el
         * @return {?}
         */
            function (name, el) {
                if (this.collides(name)) {
                    throw new Error('Name is not unique!');
                }
                return this.store.set(name, el);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        AwNameStore.prototype.remove = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return this.store.delete(name);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        AwNameStore.prototype.collides = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return this.store.has(name);
            };
        /**
         * @return {?}
         */
        AwNameStore.prototype.clear = /**
         * @return {?}
         */
            function () {
                this.store.clear();
            };
        AwNameStore.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        AwNameStore.ctorParameters = function () { return []; };
        return AwNameStore;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The 'awName' directive attaches a identifier to decorated element to aid selectors for testing
     * purposes. The 'awName' directive tries to generate a unique identifier based on contextual data
     * and inherant immutable element attributes.
     *
     * **Generating the Base Name**
     *
     * The 'awName' directive generates a base name from element tag name and attributes which are
     * static by nature.
     *
     *     Example:
     *         <button name="order" awName>
     *
     *     Result:
     *         <button name="order" awname="button_order">
     *
     * If the element has an 'id', that value takes precedent and is used instead of a generated
     * name.
     *
     *     Example:
     *         <button name="order" id="myOrderButton" awName>
     *
     *     Result:
     *         <button name="order" id="myOrderButton" awname="button_myOrderButton">
     *
     *
     * **Repeated Elements and the 'ext' Parameter**
     *
     * There are many cases where elements are generated dynamically in the code as lists or tables.
     * In such cases, it may not be easy to distinguish individual elements by standard HTML
     * attributes, so the 'awName' directive allows custom extentions to the base name to be provided
     * using the 'ext' attribute.
     *
     *    Example:
     *        fruits = ['apple', 'banana', 'orange'];
     *
     *        <ul>
     *            <li *ngFor="let fruit of fruits" awName ext="{{fruit}}">{{fruit}}</li>
     *        </ul>
     *
     *   Result:
     *       <ul>
     *           <li awname="li_apple">apple</li>
     *           <li awname="li_banana">banana</li>
     *           <li awname="li_orane">orange</li>
     *       </ul>
     *
     * **Adding Context Through Ancestor Inspection**
     *
     * In order to provide context to the element naming, the 'awName' directive loops through the
     * parent ancestry and searches for any unique element 'id' to prepend to the base name.
     *
     *     Example:
     *         <form id="applicant">
     *            <input type="text" name="firstName" awName>
     *            <input type="text" name="lastName" awName>
     *         </form>
     *         <form id="spouse">
     *            <input type="text" name="firstName" awName>
     *            <input type="text" name="lastName" awName>
     *         </form>
     *
     *     Result:
     *         <form id="applicant">
     *            <input type="text" name="firstName" awname="applicant_input_firstName">
     *            <input type="text" name="lastName" awname="applicant_input_lastName">
     *         </form>
     *         <form id="spouse">
     *            <input type="text" name="firstName" awname="spouse_input_firstName">
     *            <input type="text" name="lastName" awname="spouse_input_lastname">
     *         </form>
     *
     * **Uniqueness Check**
     *
     * 'awName' keeps track of the names it creates by adding them to a map store. Whenever it
     * creates a new name during the `ngOnInit` phase it checks it against the existing map,
     * and will throw an error if it encounters a duplicate. Moreover during the element destruction
     * phase, `ngOnDestroy`, 'awName' removes the generated name from the store.
     *
     *
     * **In Production**
     *
     * Using 'awName' adds a small bit of rendering overhead for each element it is used on. In
     * a production environment, 'awName' serves no functionality to the end user, but may have
     * a performance impact on the application. As such, 'awName' takes into account the
     * `AppConfig` settings and disables name generation when `AppConfig.isProductionMode()`
     * is `true`.
     *
     * In your application, you can turn on production mode by setting `devmode.enabled` to
     * `false` when configuring `AribaCoreModule`:
     *
     *     AribaCoreModule.forRoot({
     *         'devmode.enabled': false
     *     })
     *
     */
    var AwNameDirective = (function () {
        function AwNameDirective(el, store, config) {
            this.el = el;
            this.store = store;
            this.config = config;
            this.separator = '_';
        }
        /**
         * @return {?}
         */
        AwNameDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.config.isProductionMode()) {
                    this.name = this.createName(this.el);
                    this.addElementToStore(this.name, this.el);
                    this.el.nativeElement.setAttribute('awname', this.name);
                }
            };
        /**
         * @return {?}
         */
        AwNameDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.store.remove(this.name);
            };
        /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         */
        /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         * @param {?} name
         * @param {?} elem
         * @return {?}
         */
        AwNameDirective.prototype.addElementToStore = /**
         * Add element name/id and reference to map store. If name/id already
         * exists in store then it throws an error.
         *
         * @param {?} name
         * @param {?} elem
         * @return {?}
         */
            function (name, elem) {
                try {
                    this.store.add(name, elem);
                }
                catch (e) {
                    console.error(e.message + (". \"" + name + "\" is already in use."), elem.nativeElement);
                    return;
                }
            };
        /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @return String Name/ID
         */
        /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @param {?} elem
         * @return {?} String Name/ID
         */
        AwNameDirective.prototype.createName = /**
         * Generate name/id for element.
         *
         * param elem Reference to element
         * @param {?} elem
         * @return {?} String Name/ID
         */
            function (elem) {
                var /** @type {?} */ tagName = this.getTagName(elem);
                // Initialize array of string parts
                var /** @type {?} */ parts = [];
                // Find ancestor tag id, if there is one
                var /** @type {?} */ parentID = this.getAncestorId(elem);
                if (parentID) {
                    parts.push(parentID);
                }
                // Check the tag type
                if (tagName === 'option') {
                    var /** @type {?} */ parentName = this.getParentName(elem);
                    if (parentName) {
                        parts.push(parentName);
                    }
                }
                // Get tagname
                parts.push(tagName);
                // Choose id property if it exists
                if (elem.nativeElement.id) {
                    parts.push(elem.nativeElement.id);
                    // Otherwise build extension from tag properties
                }
                else {
                    // check for a name attribute
                    if (elem.nativeElement.hasAttribute('name')) {
                        parts.push(elem.nativeElement.name);
                    }
                    // check for value attribute if 'option' tag
                    if (tagName === 'option') {
                        if (elem.nativeElement.hasAttribute('value')) {
                            parts.push(this.spacesToUnderscore(elem.nativeElement.value));
                        }
                    }
                }
                // Add custom extension if it exists
                if (this.ext) {
                    parts.push(this.spacesToUnderscore(this.ext));
                }
                return parts.join(this.separator);
            };
        /**
         * Get tag name from element reference.
         * @param elem Reference to element
         */
        /**
         * Get tag name from element reference.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getTagName = /**
         * Get tag name from element reference.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                return elem.nativeElement.tagName.toLowerCase();
            };
        /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param elem Reference to element
         */
        /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getAncestorId = /**
         * Traverse element ancestry and return first id attribute
         * encountered.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                var /** @type {?} */ parent = elem.nativeElement.parentNode;
                var /** @type {?} */ id = '';
                while (parent && !id) {
                    if (parent.id) {
                        id = parent.id;
                    }
                    parent = parent.parentNode;
                }
                return id;
            };
        /**
         * Get name attribute from parent if name attribute exists.
         * @param elem Reference to element
         */
        /**
         * Get name attribute from parent if name attribute exists.
         * @param {?} elem Reference to element
         * @return {?}
         */
        AwNameDirective.prototype.getParentName = /**
         * Get name attribute from parent if name attribute exists.
         * @param {?} elem Reference to element
         * @return {?}
         */
            function (elem) {
                var /** @type {?} */ parent = elem.nativeElement.parentNode;
                return (parent.name && !parent.id) ? parent.name : null;
            };
        /**
         * @param {?} str
         * @return {?}
         */
        AwNameDirective.prototype.spacesToUnderscore = /**
         * @param {?} str
         * @return {?}
         */
            function (str) {
                return str.replace(/\s+/g, '_');
            };
        AwNameDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[awName]',
                    },] },
        ];
        /** @nocollapse */
        AwNameDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: AwNameStore },
                { type: core$1.AppConfig }
            ];
        };
        AwNameDirective.propDecorators = {
            ext: [{ type: core.Input }]
        };
        return AwNameDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCoreComponentModule = (function () {
        function AWCoreComponentModule() {
        }
        AWCoreComponentModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            EmbeddedItemDirective,
                            IncludeComponentDirective,
                            GenericContainerComponent,
                            ErrorMessagesComponent,
                            ModalComponent,
                            CurrencyFormatPipe,
                            NgForSetDirective,
                            InfiniteScrollComponent,
                            AwNameDirective
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            GenericContainerComponent,
                            ModalComponent
                        ],
                        exports: [
                            EmbeddedItemDirective,
                            IncludeComponentDirective,
                            GenericContainerComponent,
                            ErrorMessagesComponent,
                            ModalComponent,
                            CurrencyFormatPipe,
                            NgForSetDirective,
                            InfiniteScrollComponent,
                            AwNameDirective
                        ]
                    },] },
        ];
        return AWCoreComponentModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Parent class for all modal dialogs. Provides defaults functionality for all modals.
     */
    var /**
     * Parent class for all modal dialogs. Provides defaults functionality for all modals.
     */ ModalContainer = (function (_super) {
        __extends(ModalContainer, _super);
        function ModalContainer(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Override function.
             */
            _this.destroy = core$1.noop;
            return _this;
        }
        /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         */
        /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         * @return {?}
         */
        ModalContainer.prototype.closeModal = /**
         * function that closes the dialog by calling destroy on the component reference.
         * Method inherited by all its children.
         * @return {?}
         */
            function () {
                this.destroy();
            };
        return ModalContainer;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * DataTypeProviderRegistry aggregates different DataProviders per type.
     */
    var DataTypeProviderRegistry = (function () {
        function DataTypeProviderRegistry() {
            this.registryByProvider = new Map();
            this.registryNameToClass = new Map();
        }
        /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         */
        /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.registerProvider = /**
         * For every single registered DataProvider implementation we also need store its prototype
         * in order to be able to support some kind of inheritance. You can register a provider for
         * a parent class if needed
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
            function (target, provider) {
                if (core$1.isBlank(target) || (!core$1.isStringMap(target) && !core$1.isType(target))) {
                    throw new Error(' Cannot register non-object');
                }
                var /** @type {?} */ name = core$1.isType(target) ? target.prototype.constructor.name : target.constructor.name;
                this.registryByProvider.set(name, provider);
                var /** @type {?} */ prototype = Object.getPrototypeOf(target);
                this.registryNameToClass.set(name, prototype);
            };
        /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         */
        /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         * @template T
         * @param {?} className
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.bestMatchForClass = /**
         * Search for best matching provider. If not found then use object prototype to get hold of its
         * parent and see if there is a provider registered on this level
         *
         * @template T
         * @param {?} className
         * @return {?}
         */
            function (className) {
                var /** @type {?} */ registeredClassName = className;
                var /** @type {?} */ classProto = this.registryNameToClass.get(className);
                while (core$1.isPresent(registeredClassName)) {
                    var /** @type {?} */ provider = this.registryByProvider.get(registeredClassName);
                    if (core$1.isPresent(provider)) {
                        provider.type = className;
                        return provider;
                    }
                    // Go up to parent
                    if (core$1.isPresent(classProto)) {
                        classProto = Object.getPrototypeOf(classProto);
                        var /** @type {?} */ parentName = core$1.objectToName(classProto);
                        registeredClassName =
                            (core$1.isPresent(parentName) && parentName !== registeredClassName) ? parentName
                                : null;
                    }
                    else {
                        return null;
                    }
                }
                return null;
            };
        /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         */
        /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         * @template T
         * @param {?} type
         * @return {?}
         */
        DataTypeProviderRegistry.prototype.bestMatchForType = /**
         * The same as bestMatchForClass() with the difference to pass a type. If you want to
         * support object inheritance you need this.
         *
         *
         * @template T
         * @param {?} type
         * @return {?}
         */
            function (type) {
                var /** @type {?} */ name = core$1.objectToName(type);
                this.registryNameToClass.set(name, type);
                return this.bestMatchForClass(name);
            };
        DataTypeProviderRegistry.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DataTypeProviderRegistry.ctorParameters = function () { return []; };
        return DataTypeProviderRegistry;
    }());
    /**
     * Provider is a data driver that can access data and retrieve them. It knows how to get 1
     * or more records, maybe do paging and some other things.
     *
     * @abstract
     * @template T
     */
    var /**
     * Provider is a data driver that can access data and retrieve them. It knows how to get 1
     * or more records, maybe do paging and some other things.
     *
     * @abstract
     * @template T
     */ DataProvider = (function () {
        function DataProvider() {
            /**
             * Notifies all the listeners in case of data are available or if they changed due to some user
             * interaction  (search, adding or removing).
             *
             */
            this.dataChanges = new rxjs.BehaviorSubject([]);
        }
        /**
         *  Return size of the source
         *
         */
        /**
         *  Return size of the source
         *
         * @param {?=} params
         * @return {?}
         */
        DataProvider.prototype.expectedCount = /**
         *  Return size of the source
         *
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                return -1;
            };
        /**
         *
         * Returns non-async current state of data
         */
        /**
         *
         * Returns non-async current state of data
         * @return {?}
         */
        DataProvider.prototype.data = /**
         *
         * Returns non-async current state of data
         * @return {?}
         */
            function () {
                return this.dataChanges.getValue();
            };
        /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         */
        /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         * @return {?}
         */
        DataProvider.prototype.canCRUD = /**
         * Tells if this DataProvider supports INSERT, REMOVE
         *
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Tells if this DataProvider supports query capability
         *
         */
        /**
         * Tells if this DataProvider supports query capability
         *
         * @return {?}
         */
        DataProvider.prototype.canQuery = /**
         * Tells if this DataProvider supports query capability
         *
         * @return {?}
         */
            function () {
                return false;
            };
        /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         */
        /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         * @param {?} obj
         * @return {?}
         */
        DataProvider.prototype.insert = /**
         * Implement to support insertion. After record is inserted emit event for dataChanges to
         * inform all subscribers
         *
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
            };
        /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         */
        /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         * @param {?} obj
         * @return {?}
         */
        DataProvider.prototype.remove = /**
         * Implement to support record removal. After record is removed emit event for dataChanges to
         * inform all subscribers.
         *
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
            };
        /**
         * Implement to provide access to low level searcg API.
         *
         */
        /**
         * Implement to provide access to low level searcg API.
         *
         * @param {?} params
         * @return {?}
         */
        DataProvider.prototype.query = /**
         * Implement to provide access to low level searcg API.
         *
         * @param {?} params
         * @return {?}
         */
            function (params) {
            };
        return DataProvider;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Default implementation for Arrays.
     * @template T
     */
    var /**
     * Default implementation for Arrays.
     * @template T
     */ ArrayDataProvider = (function (_super) {
        __extends(ArrayDataProvider, _super);
        function ArrayDataProvider(values) {
            var _this = _super.call(this) || this;
            _this.values = values;
            _this.type = Array;
            _this.dataChanges.next(_this.values);
            return _this;
        }
        /**
         * @param {?=} params
         * @return {?}
         */
        ArrayDataProvider.prototype.expectedCount = /**
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                return this.values.length;
            };
        /**
         * @param {?=} params
         * @return {?}
         */
        ArrayDataProvider.prototype.dataForParams = /**
         * @param {?=} params
         * @return {?}
         */
            function (params) {
                if (core$1.isBlank(params)) {
                    return this.values;
                }
                var /** @type {?} */ data = this.values;
                if (core$1.isPresent(params) && params.has('offset') && params.has('limit')) {
                    var /** @type {?} */ offset = params.get('offset');
                    var /** @type {?} */ limit = params.get('limit');
                    if (data.length > (offset + limit)) {
                        data = data.slice(offset, offset + limit);
                    }
                    else {
                        data = data.slice(offset, data.length);
                    }
                }
                if (params.has('orderby') && params.has('selector')) {
                    this.sort(data, params.get('orderby'), params.get('selector'));
                }
                return data;
            };
        /**
         * @param {?} params
         * @return {?}
         */
        ArrayDataProvider.prototype.fetch = /**
         * @param {?} params
         * @return {?}
         */
            function (params) {
                return rxjs.of(this.dataForParams(params));
            };
        /**
         * Provides default implementation for sorting current dataset by one column / key
         *
         * for sortOrdering please see Datatable and its sortOrderingForNumber()
         *
         *      1  = ascending
         *      -1 = descending
         * @param {?} arrayToSort
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
        ArrayDataProvider.prototype.sort = /**
         * Provides default implementation for sorting current dataset by one column / key
         *
         * for sortOrdering please see Datatable and its sortOrderingForNumber()
         *
         *      1  = ascending
         *      -1 = descending
         * @param {?} arrayToSort
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
            function (arrayToSort, key, sortOrder) {
                arrayToSort.sort(function (data1, data2) {
                    var /** @type {?} */ value1 = core$1.FieldPath.getFieldValue(data1, key);
                    var /** @type {?} */ value2 = core$1.FieldPath.getFieldValue(data2, key);
                    var /** @type {?} */ result = null;
                    if (value1 == null && value2 != null) {
                        result = -1;
                    }
                    else if (value1 != null && value2 == null) {
                        result = 1;
                    }
                    else if (value1 == null && value2 == null) {
                        result = 0;
                    }
                    else if (typeof value1 === 'string' && typeof value2 === 'string') {
                        result = value1.localeCompare(value2);
                    }
                    else {
                        result = (value1 < value2) ? -1 : (value1 > value2) ? 1 : 0;
                    }
                    return (sortOrder * result);
                });
            };
        return ArrayDataProvider;
    }(DataProvider));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Provides top level accessor class in order to make {\@link DataProvider} retrieval process easier.
     * Using {\@link DataTypeProviderRegistry} we either retrieve registered instance of concrete
     * provider or instantiate our implicit provider for native types such as Array.
     *
     *
     */
    var DataProviders = (function () {
        function DataProviders(registry) {
            this.registry = registry;
        }
        /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         */
        /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         * @param {?} target
         * @return {?}
         */
        DataProviders.prototype.find = /**
         * Finds the best matching  DataProvider or create new one in case of Array
         * More room to register and instantiate some other implicit Providers
         * @param {?} target
         * @return {?}
         */
            function (target) {
                if (core$1.isArray(target)) {
                    return new ArrayDataProvider(target);
                }
                else if (core$1.isString(target)) {
                    return this.registry.bestMatchForClass(target);
                }
                return this.registry.bestMatchForType(target);
            };
        /**
         * Registers new provider within DataTypeProviderRegistry
         *
         */
        /**
         * Registers new provider within DataTypeProviderRegistry
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
        DataProviders.prototype.register = /**
         * Registers new provider within DataTypeProviderRegistry
         *
         * @template T
         * @param {?} target
         * @param {?} provider
         * @return {?}
         */
            function (target, provider) {
                this.registry.registerProvider(target, provider);
            };
        DataProviders.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DataProviders.ctorParameters = function () {
            return [
                { type: DataTypeProviderRegistry }
            ];
        };
        return DataProviders;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Provides a registry of different data Finders used mostly by DataSources. All Finders are
     * registered by this class as we don't have any needs right now to expose this to developer.
     *
     */
    var DataFinders = (function () {
        function DataFinders() {
            this.findersByType = new Map();
            this.initFinders();
        }
        /**
         * Finds the best matching DataFinder based on the object type and queryType.
         */
        /**
         * Finds the best matching DataFinder based on the object type and queryType.
         * @param {?} forProvider
         * @param {?} forType
         * @return {?}
         */
        DataFinders.prototype.find = /**
         * Finds the best matching DataFinder based on the object type and queryType.
         * @param {?} forProvider
         * @param {?} forType
         * @return {?}
         */
            function (forProvider, forType) {
                var /** @type {?} */ finderMatch;
                this.findersByType.forEach(function (v, k) {
                    if (k.accepts(forProvider, forType)) {
                        finderMatch = v;
                        return true;
                    }
                });
                if (core$1.isPresent(finderMatch)) {
                    var /** @type {?} */ copy = new finderMatch();
                    copy.forData(forProvider);
                    return copy;
                }
                return null;
            };
        /**
         * @return {?}
         */
        DataFinders.prototype.initFinders = /**
         * @return {?}
         */
            function () {
                // create a prototype for each
                this.findersByType.set(new FullTextArrayDataFinder(), FullTextArrayDataFinder);
            };
        DataFinders.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        DataFinders.ctorParameters = function () { return []; };
        return DataFinders;
    }());
    /** @enum {number} */
    var QueryType = {
        FullText: 0,
        Predicate: 1,
        FullTextAndPredicate: 2,
    };
    QueryType[QueryType.FullText] = "FullText";
    QueryType[QueryType.Predicate] = "Predicate";
    QueryType[QueryType.FullTextAndPredicate] = "FullTextAndPredicate";
    /**
     * This class provides matching capability for given DataProvider.
     * @abstract
     */
    var /**
     * This class provides matching capability for given DataProvider.
     * @abstract
     */ DataFinder = (function () {
        function DataFinder() {
        }
        /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         */
        /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        DataFinder.prototype.accepts = /**
         * In order to find concrete DataFinder we need to know the target type and the query type
         *
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return false;
            };
        /**
         * @template T
         * @param {?} query
         * @param {?=} max
         * @return {?}
         */
        DataFinder.prototype.match = /**
         * @template T
         * @param {?} query
         * @param {?=} max
         * @return {?}
         */
            function (query, max) {
                if (max === void 0) {
                    max = -1;
                }
                return core$1.unimplemented();
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        DataFinder.prototype.matchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                return core$1.unimplemented();
            };
        return DataFinder;
    }());
    /**
     * Simple FullText implementation based on infix string matching which works on top of
     * ArrayDataProvider.
     *
     *
     */
    var /**
     * Simple FullText implementation based on infix string matching which works on top of
     * ArrayDataProvider.
     *
     *
     */ FullTextArrayDataFinder = (function (_super) {
        __extends(FullTextArrayDataFinder, _super);
        function FullTextArrayDataFinder() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.accepts = /**
         * @param {?} forData
         * @param {?} forType
         * @return {?}
         */
            function (forData, forType) {
                return forData instanceof ArrayDataProvider && forType === QueryType.FullText;
            };
        /**
         * @param {?} provider
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.forData = /**
         * @param {?} provider
         * @return {?}
         */
            function (provider) {
                this._provider = provider;
                return this;
            };
        Object.defineProperty(FullTextArrayDataFinder.prototype, "lookupKey", {
            set: /**
             * @param {?} key
             * @return {?}
             */ function (key) {
                this._keyPath = core$1.isPresent(key) ? new core$1.FieldPath(key) : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.instantMatch = /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                var /** @type {?} */ list = this._provider.dataForParams(new Map().set('limit', max));
                return this.instantMatchWithSelections(list, query, max);
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.instantMatchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                core$1.assert(core$1.isPresent(this._provider), 'Missing DataProvider');
                if (core$1.isBlank(query)) {
                    return selections;
                }
                var /** @type {?} */ result = [];
                var /** @type {?} */ toLowerPattern = query.toLowerCase();
                for (var /** @type {?} */ i = 0; i < selections.length; i++) {
                    var /** @type {?} */ item = selections[i];
                    if (this.matches(item, toLowerPattern)) {
                        result.push(item);
                        if (result.length >= max) {
                            break;
                        }
                    }
                }
                return result;
            };
        /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         */
        /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         * @template T
         * @param {?} item
         * @param {?} pattern
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.matches = /**
         *
         * Warning: If you dont supply search Key and you want fulltext search and you use this
         * default implementation be aware that it can  perform poorly as it is naive implementaion
         * that does not do deep compare.
         *
         * @template T
         * @param {?} item
         * @param {?} pattern
         * @return {?}
         */
            function (item, pattern) {
                var /** @type {?} */ val = (core$1.isPresent(this._keyPath)) ? this._keyPath.getFieldValue(item) : item;
                if (core$1.isFunction(val)) {
                    val = val.call(item);
                }
                else if (core$1.isJsObject(item)) {
                    return Object.keys(item).filter(function (key) {
                        return core$1.isPresent(item[key]) && core$1.isString(item[key]) && item[key]
                            .toLowerCase().indexOf(pattern) !== -1;
                    })
                        .length > 0;
                }
                else {
                    return core$1.isBlank(pattern) ||
                        core$1.isPresent(val) && val.toString().toLowerCase().indexOf(pattern) > -1;
                }
            };
        /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.match = /**
         * @template T
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (query, max) {
                return rxjs.of(this.instantMatch(query, max));
            };
        /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
        FullTextArrayDataFinder.prototype.matchWithSelections = /**
         * @template T
         * @param {?} selections
         * @param {?} query
         * @param {?} max
         * @return {?}
         */
            function (selections, query, max) {
                return rxjs.of(this.instantMatchWithSelections(selections, query, max));
            };
        return FullTextArrayDataFinder;
    }(DataFinder));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DATA_SOURCE = new core.InjectionToken('DATA_SOURCE');
    /**
     * DataSource describes basic functionality for handling stream of data specific to component
     *
     * It is expected that DataSource will be defined as component provider using
     *
     * \@Components ({
     *      ...
     *      providers:[
     *
     *          provide: DATA_SOURCE, useClass: ChooserDataSourcePlainArrayExample,
     * deps: [DataProviders, DataFinders]
     *      ]
     *
     * })
     *
     *
     * so all the dependencies (DataProviders, DataFinders) are properly injected.
     *
     * DataProvider uses open() method to broadcast changes to all the subscribers in reactive way.
     * Or you can use instant() method to retrieve current state of this DataSource (sync)
     *
     * @abstract
     */
    var DataSource = (function () {
        /**
         *
         * Each DataSource have injected DataProviders and DataFinders to retrieve concrete
         * implementation
         *
         */
        function DataSource(dataProviders, finders) {
            this.dataProviders = dataProviders;
            this.finders = finders;
        }
        /**
         * Returns a data instantly from the internal state of DataProvider
         */
        /**
         * Returns a data instantly from the internal state of DataProvider
         * @template T
         * @return {?}
         */
        DataSource.prototype.instant = /**
         * Returns a data instantly from the internal state of DataProvider
         * @template T
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        DataSource.MaxLength = 10;
        DataSource.MaxRecentSelected = 5;
        return DataSource;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var TopZoneComponent = (function () {
        function TopZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad ';
        }
        TopZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-top',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        TopZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return TopZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var LeftZoneComponent = (function () {
        function LeftZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        LeftZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-left',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        LeftZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return LeftZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var MiddleZoneComponent = (function () {
        function MiddleZoneComponent() {
            this.classList = 'ui-g-12 ui-md-6 ui-lg-4 ui-g-nopad';
        }
        MiddleZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-middle',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        MiddleZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return MiddleZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var RightZoneComponent = (function () {
        function RightZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        RightZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-right',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        RightZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return RightZoneComponent;
    }());
    /**
     * Common class used used for Five Zone layout. Used for the ng-content selector
     */
    var BottomZoneComponent = (function () {
        function BottomZoneComponent() {
            this.classList = 'ui-g-12 ui-g-nopad';
        }
        BottomZoneComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-bottom',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        BottomZoneComponent.propDecorators = {
            classList: [{ type: core.HostBinding, args: ['class',] }]
        };
        return BottomZoneComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Used by FormTable to layout fields into Rows. Each FormTable row is reasonable for not only to
     * include actual component such is DropDown or InputField but mainly provides a enough context for
     * the component to specify the size, how it should layout, whether we need to show required flag,
     * to show/hide labels in case if we have no label layout and much more.
     *
     * FormRow component also registers angular validator for the current row/field. As already
     * mentioned We treat our widgets with minimal responsibility as possible to present and retrive
     * information to/from user and let somebody else to figure out where it appear and how.
     *
     * todo: Move under FormTable
     */
    var FormRowComponent = (function (_super) {
        __extends(FormRowComponent, _super);
        function FormRowComponent(env, 
        // Event this creates CI depends. Need to have a reference to parent
        // I need to refactor more parent to not use this child and refactor layouting
        parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Hides the label
             *
             */
            _this.noLabelLayout = false;
            /**
             * Renders row with highlighted background
             *
             */
            _this.highlightRow = false;
            /**
             *
             *  Field label that should appear above or next to the control
             *
             */
            _this.label = '';
            /**
             *
             * For single column layout without zones we need to apply grid directly to the FormRow tag
             * so we don't need to introduce extra div level
             *
             */
            _this.classList = '';
            _this._size = 'ui-g-12 ui-md-' + WidgetSizeColumns.medium;
            return _this;
        }
        /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         */
        /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         * @return {?}
         */
        FormRowComponent.prototype.ngOnInit = /**
         * Right now we just initialize this once and use the values we do not expect now to react to
         * changes
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, null);
                this.registerValidators();
                this.omitPadding = this.parentContainer.omitPadding;
                this.classList += core$1.isPresent(this.parentContainer) ? ' ui-g-12 ' : '';
                this.classList = this.highlightRow ? this.classList + ' highlight-row ' : this.classList;
                this.classList = this.omitPadding ? this.classList + ' ui-g-nopad ' : this.classList;
            };
        Object.defineProperty(FormRowComponent.prototype, "size", {
            /**
             * Just a size getter
             *
             */
            get: /**
             * Just a size getter
             *
             * @return {?}
             */ function () {
                return this._size;
            },
            /**
             *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
             * right now. but we should extend this for other screen sizes
             *
             *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
             *
             *  Also check if this is dynamic size that should vary based on the how many number of columns
             * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
             * small.
             */
            set: /**
             *  A size setter we translate custom sizes into actual bootstrap grid system. We use medium
             * right now. but we should extend this for other screen sizes
             *
             *  todo: provide mapping and add other grid classes for other sizes xs, sm, lg, xl
             *
             *  Also check if this is dynamic size that should vary based on the how many number of columns
             * we have. e.g. Date widgets is by default small, but in 2, 3 columns layout this small is too
             * small.
             * @param {?} value
             * @return {?}
             */ function (value) {
                var /** @type {?} */ isDynVal = false;
                if (core$1.StringWrapper.startsWidth(value, 'd-')) {
                    isDynVal = true;
                    value = value.substr(2, value.length - 1);
                }
                if (core$1.isPresent(value)) {
                    this._size = value;
                    var /** @type {?} */ dSize = this.dynSize(value, isDynVal);
                    this._size = 'ui-g-12 ui-md-' + dSize;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FormRowComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngDoCheck.call(this);
                if (core$1.isPresent(this.parentContainer) && this.editable !== this.parentContainer.editable) {
                    this.editable = this.parentContainer.editable;
                }
            };
        /**
         * Push out of box angular validator as well as custom one to current FormControl
         * @return {?}
         */
        FormRowComponent.prototype.registerValidators = /**
         * Push out of box angular validator as well as custom one to current FormControl
         * @return {?}
         */
            function () {
                var /** @type {?} */ validators = [];
                if (core$1.isPresent(this.maxLength)) {
                    validators.push(forms.Validators.maxLength(this.maxLength));
                }
                if (core$1.isPresent(this.minLength)) {
                    validators.push(forms.Validators.minLength(this.minLength));
                }
                if (core$1.isPresent(this.required) && this.required) {
                    validators.push(forms.Validators.required);
                }
                if (core$1.isPresent(this.pattern)) {
                    validators.push(forms.Validators.pattern(this.pattern));
                }
                if (core$1.isPresent(this.customValidators)) {
                    core$1.ListWrapper.addAll(validators, this.customValidators);
                }
                if (validators.length === 1) {
                    this.formControl.setValidators(validators[0]);
                }
                else if (validators.length > 1) {
                    this.formControl.setValidators(forms.Validators.compose(validators));
                }
                if (core$1.isPresent(this.customAsyncValidators) && this.customAsyncValidators.length === 1) {
                    this.formControl.setAsyncValidators(this.customAsyncValidators[0]);
                }
                else if (core$1.isPresent(this.customAsyncValidators) && this.customAsyncValidators.length > 1) {
                    this.formControl.setAsyncValidators(forms.Validators.composeAsync(this.customAsyncValidators));
                }
            };
        Object.defineProperty(FormRowComponent.prototype, "labelsOnTop", {
            /**
             *
             * Do we have labels on TOP, try to read this from Parent
             *
             */
            get: /**
             *
             * Do we have labels on TOP, try to read this from Parent
             *
             * @return {?}
             */ function () {
                if (core$1.isBlank(this._labelsOnTop) && core$1.isPresent(this.parentContainer)) {
                    return ((this.parentContainer)).isLabelsOnTop();
                }
                return false;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         * Can refactor all into 1 line but its hard to debug so this is just for read
         *
         * @param {?} value
         * @param {?} isDynValue
         * @return {?}
         */
        FormRowComponent.prototype.dynSize = /**
         *
         * Can refactor all into 1 line but its hard to debug so this is just for read
         *
         * @param {?} value
         * @param {?} isDynValue
         * @return {?}
         */
            function (value, isDynValue) {
                var /** @type {?} */ normalizeSize = value.toLowerCase().replace('-', '');
                if (core$1.isPresent(this.parentContainer) &&
                    ((this.parentContainer)).hasTwoColumn && isDynValue) {
                    var /** @type {?} */ enumValues = Object.keys(WidgetSizeColumns);
                    normalizeSize = enumValues[enumValues.indexOf(normalizeSize) + 1];
                }
                return ((WidgetSizeColumns))[normalizeSize];
            };
        FormRowComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-form-row',
                        template: "<div *ngIf=\"!hidden\"\n     class=\"w-form-row ui-g\"\n     [class.highlight-row]=\"highlightRow\"\n     [class.required]=\"required\"\n     [class.label-on-top]=\"labelsOnTop\"\n     [class.label-on-side]=\"!labelsOnTop\"\n     [class.has-danger]=\"!formControl.valid && !formControl.pristine \"\n     [ngClass]=\"styleClass\">\n\n    <div class=\"control-label ui-g-12 ui-g-nopad\"\n         *ngIf=\"!noLabelLayout\"\n         [class.ui-md-3]=\"!labelsOnTop\">\n        <label [class.sr-only]=\"noLabelLayout\">{{label}}</label>\n    </div>\n\n    <div class=\"control-value ui-g-nopad\" [ngClass]=\"size\"\n         [class.read-only]=\"!editable\">\n        <ng-content></ng-content>\n        <a-error-messages [control]=\"formControl\"></a-error-messages>\n    </div>\n</div>\n",
                        styles: [".required label:after{content:\"*\";color:red}/deep/ .highlight-row{background-color:#f7f8fa}.w-form-row.highlight-row{background-color:#f7f8fa}.w-form-row.label-on-top{padding-bottom:13px}.w-form-row.label-on-top .control-label,.w-form-row.label-on-top .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-top .control-label{padding-bottom:12px}.w-form-row.label-on-side .control-label,.w-form-row.label-on-side .control-value{padding-top:0;padding-bottom:0}.w-form-row.label-on-side .control-label ::ng-deep .w-string-field,.w-form-row.label-on-side .control-value ::ng-deep .w-string-field{line-height:36px}.w-form-row.label-on-side .control-label ::ng-deep .sap-icon,.w-form-row.label-on-side .control-value ::ng-deep .sap-icon{line-height:26px}.w-form-row.label-on-side .control-label label,.w-form-row.label-on-side .control-value label{line-height:36px}.w-form-row.label-on-side .control-label .fa,.w-form-row.label-on-side .control-value .fa{line-height:18px}.control-label{color:#636363}.u-validation-error{border-color:red}"],
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return FormRowComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        FormRowComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: FormTableComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormTableComponent; }),] }] }
            ];
        };
        FormRowComponent.propDecorators = {
            noLabelLayout: [{ type: core.Input }],
            highlightRow: [{ type: core.Input }],
            label: [{ type: core.Input }],
            maxLength: [{ type: core.Input }],
            minLength: [{ type: core.Input }],
            pattern: [{ type: core.Input }],
            customAsyncValidators: [{ type: core.Input }],
            customValidators: [{ type: core.Input }],
            classList: [{ type: core.HostBinding, args: ['class',] }],
            size: [{ type: core.Input }]
        };
        return FormRowComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * FormTable is a specific layout component for rendering Labels and its controls in two columns
     * and 5 different zones.
     *
     * We support LEFT, MIDDLE, RIGHT, TOP, BOTTOM zone where we can place our component or widgets.
     * This
     * component is used as primary layout to wrap all the common use cases. E.g. When we lay out
     * fields in the form I do not want controls to be aware of error validation, size, labels, and
     * some other things. Control such INPUT is just responsible for retrieve user value but not how it
     * appear on the page.
     *
     * This way we can be flexible how we treat widgets for different kinds of situation depending
     * where they appear
     * FormTable just like the rest of the components are using Model driven approach how to work with
     * data, mean we are using FormGroup, FormControl etc. FormGroup can be passed into the FormTable,
     * otherwise its automatically created when the FormTable is instantiated.
     *
     * FormGroup is saved insode Environment where we are using this to pass this around the pages and
     * components.
     *
     * ### Example
     *
     * Simple Layout fields and its control
     *
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: `
     *  			<aw-form-table [formGroup]="formGroup" (onSubmit)=>
     *  				<aw-form-row [label]="'name'" [name]="'name'">
     *  					<aw-input-field [type]="'string'"></aw-input-field>
     *  				</aw-form-row>
     *
     *  				<aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
     *  					<aw-checkbox-list [list]="checkBoxListValues"
     *  					                 [selections]="selectedValues"
     *  					                 [layout]="'inline'"
     *  					                 (onSelection)="onCBClick($event)">
     *  					</aw-checkbox-list>
     *  				</aw-form-row>
     *  				<aw-form-row [label]="'Gender'" [name]="'gender'">
     *
     *  					<aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
     *
     *  					</aw-radiobutton-list>
     *
     *  				</aw-form-row>
     *  				<aw-form-row [label]="'My birthdate'" [name]="'birthDate'" [size]="'small'">
     *
     *  					<aw-date-time [value]="date" [editable]="editable" [showTime]="showTime">
     *  					</aw-date-time>
     *  				</aw-form-row>
     *  			</aw-form-table>
     *    `
     *  })
     *  export class ShowUserInfoComponent
     *  {
     *       checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' , 'silver'
     *     , 'black' , 'Green'
     *     , 'Gray' , 'Navy' ,
     *          'Olive' , 'Aqua' , 'Purple'];
     *      selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
     *      rbValues: string[] = ['male' , 'female' , 'other'];
     *      rbSelection: string = 'male';
     *      editable: boolean = true;
     *      showTime: boolean = true;
     *
     *      formGroup: FormGroup = new FormGroup({});
     *
     *
     *      onCBClick (event): void
     *      {
     *          console.log('onCBClick = ' + event);
     *      }
     *
     *      onSubmit (model: any): void
     *      {
     *         console.log(model)
     *
     *         // will print { name:null, myColors:['blue' , 'Olive' , 'Aqua' , 'Purple'], gender:
     *     male}
     *      }
     *
     *  }
     *
     *  ```
     *
     *  Or you can use zone to layout these fields into two columns:
     *
     *  Current zones are implement with <ng-content SELECT> which is just a selector to searches for
     *     specific pattern. In our case instead of creating extra wrapper custom component use simple
     *     CSS class
     *
     *
     *  ```
     *            <aw-form-table #metaFormTable [editable]="editing"
     *                          [useFiveZone]="isFiveZoneLayout"
     *                          (onSubmit)="onSaveAction($event)">
     *
     *                <aw-left  *ngIf="canShowZone('zLeft')">
     *
     *                        <aw-form-row [label]="'name'" [name]="'name'">
     *                            <aw-input-field [type]="'string'"></aw-input-field>
     *                        </aw-form-row>
     *
     *                        <aw-form-row [label]="'Preferred Colors'" [name]="'myColors'">
     *                            <aw-checkbox-list [list]="checkBoxListValues"
     *                                             [selections]="selectedValues"
     *                                             [layout]="'inline'"
     *                                             (onSelection)="onCBClick($event)">
     *                            </aw-checkbox-list>
     *                        </aw-form-row>
     *                </aw-left>
     *
     *
     *                <aw-right  *ngIf="canShowZone('zRight')">
     *                        <aw-form-row [label]="'Gender'" [name]="'gender'">
     *                                <aw-radiobutton-list [list]="rbValues" [selection]="rbSelection">
     *                                </aw-radiobutton-list>
     *                        </aw-form-row>
     *
     *                        <aw-form-row [label]="'My birthdate'" [name]="'birthDate'"
     *     [size]="'small'">
     *                            <aw-date-time [value]="date" [editable]="editable"
     *     [showTime]="showTime">
     *                            </aw-date-time>
     *                        </aw-form-row>
     *                </<aw-right>
     *            </aw-form-table>
     *
     *  ```
     *
     *  todo: remove my css selectors for zones and replace it with real component even just a tag
     *  todo: would work file
     *
     */
    var FormTableComponent = (function (_super) {
        __extends(FormTableComponent, _super);
        function FormTableComponent(env) {
            var _this = _super.call(this, env, null) || this;
            _this.env = env;
            /**
             * Used for the form layout to see if we need to render labels stacked  or side by side next to
             * the control
             *
             */
            _this.labelsOnTop = false;
            /**
             *
             * Is this a 4 zone layout
             *
             */
            _this.useFiveZone = false;
            /**
             * For certain usecase we dont want to set automatically this to all children
             */
            _this.editabilityCheck = true;
            /**
             *  Triggers when the <form> is submitted. onSubmit we emit the whole formController objects
             *
             *
             */
            _this.onSubmit = new core.EventEmitter();
            /**
             * Cache calculated properties when init this component
             *
             */
            _this.hasOneColumn = false;
            _this.hasTwoColumn = false;
            _this.hasThreeColumn = false;
            return _this;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        FormTableComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['editable']) &&
                    changes['editable'].previousValue !== changes['editable'].currentValue) {
                    this.updateFormFields();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FormTableComponent.prototype.onSubmitForm = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onSubmit.emit(event);
            };
        /**
         *
         * Are labels on top
         *
         */
        /**
         *
         * Are labels on top
         *
         * @return {?}
         */
        FormTableComponent.prototype.isLabelsOnTop = /**
         *
         * Are labels on top
         *
         * @return {?}
         */
            function () {
                return this.labelsOnTop;
            };
        /**
         *
         * Used by child component to inherit editability
         *
         */
        /**
         *
         * Used by child component to inherit editability
         *
         * @return {?}
         */
        FormTableComponent.prototype.isFormEditable = /**
         *
         * Used by child component to inherit editability
         *
         * @return {?}
         */
            function () {
                return this.editable;
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.applyColumns = /**
         * @return {?}
         */
            function () {
                if (!this.useFiveZone && this.hasAnyZones()) {
                    throw new Error('Zones detected in the FormTable but useFiveZone option is false');
                }
                this.hasOneColumn = !core$1.isPresent(this.rightZone) && !core$1.isPresent(this.middleZone);
                this.hasTwoColumn = core$1.isPresent(this.leftZone) && core$1.isPresent(this.rightZone) &&
                    !core$1.isPresent(this.middleZone);
                this.hasThreeColumn = core$1.isPresent(this.leftZone) && core$1.isPresent(this.rightZone) &&
                    core$1.isPresent(this.middleZone);
                if (this.hasTwoColumn && !this.isTwoZoneReady()) {
                    this.leftZone.classList += ' ui-md-6 ui-lg-6';
                    this.rightZone.classList += ' ui-md-6 ui-lg-6';
                }
                if (this.hasThreeColumn && !this.isThreeZoneReady()) {
                    this.leftZone.classList += ' ui-md-6 ui-lg-4';
                    this.rightZone.classList += ' ui-md-6 ui-lg-4';
                }
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.hasAnyZones = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.leftZone) || core$1.isPresent(this.rightZone) || core$1.isPresent(this.middleZone)
                    || core$1.isPresent(this.topZone) || core$1.isPresent(this.bottomZone);
            };
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         */
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
        FormTableComponent.prototype.isTwoZoneReady = /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
            function () {
                return this.leftZone.classList.indexOf('ui-lg-6') > 0 &&
                    this.leftZone.classList.indexOf('ui-lg-6') > 0;
            };
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         */
        /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
        FormTableComponent.prototype.isThreeZoneReady = /**
         * Helper method to check if we already initialized the classList.
         * the
         *
         * TODO: Probably string array would be easier
         * @return {?}
         */
            function () {
                return this.leftZone.classList.indexOf('ui-lg-4') > 0 &&
                    this.leftZone.classList.indexOf('ui-lg-4') > 0;
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // problem since Angular 4.2, ngAfterContentInit
                // without this I get error that value was changed after view was checked
                // todo: refactor  - mainly our zones left, right middle
                setTimeout(function () {
                    _this.applyColumns();
                    _this.updateFormFields();
                    _this.adjustLayout();
                });
            };
        /**
         * @return {?}
         */
        FormTableComponent.prototype.updateFormFields = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.editabilityCheck && core$1.isPresent(this.formFields) && this.formFields.length > 0) {
                    this.formFields.forEach(function (item) {
                        item.editable = _this.editable;
                        // item.formGroup = this.formGroup;
                    });
                }
            };
        /**
         * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
         * form row.
         * @return {?}
         */
        FormTableComponent.prototype.adjustLayout = /**
         * Based on if we are 2 or 3 or 1 column layout we need to adjust widgets width within the
         * form row.
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.rows) && this.rows.length > 0) {
                    if (this.hasThreeColumn) {
                        this.rows.forEach(function (item) { return item.size = 'large'; });
                    }
                }
            };
        FormTableComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-form-table',
                        template: "<form class=\"w-form-table ui-g ui-fluid\" [formGroup]=\"formGroup\"\n      [ngClass]=\"styleClass\"\n      (ngSubmit)=\"onSubmitForm(formGroup.value)\" novalidate>\n\n    <div class=\"ui-g-12 ui-g-nopad\">\n\n        <div class=\"ui-g\">\n            <ng-content></ng-content>\n        </div>\n\n    </div>\n</form>\n\n",
                        styles: [".page-container>form{margin-top:1em}.w-form-table button{float:right}"],
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return FormTableComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        FormTableComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        FormTableComponent.propDecorators = {
            labelsOnTop: [{ type: core.Input }],
            useFiveZone: [{ type: core.Input }],
            editabilityCheck: [{ type: core.Input }],
            onSubmit: [{ type: core.Output }],
            leftZone: [{ type: core.ContentChild, args: [LeftZoneComponent,] }],
            middleZone: [{ type: core.ContentChild, args: [MiddleZoneComponent,] }],
            rightZone: [{ type: core.ContentChild, args: [RightZoneComponent,] }],
            topZone: [{ type: core.ContentChild, args: [TopZoneComponent,] }],
            bottomZone: [{ type: core.ContentChild, args: [BottomZoneComponent,] }],
            formFields: [{ type: core.ContentChildren, args: [BaseFormComponent, { descendants: true },] }],
            rows: [{ type: core.ContentChildren, args: [core.forwardRef(function () { return FormRowComponent; }), { descendants: true },] }]
        };
        return FormTableComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWFormTableModule = (function () {
        function AWFormTableModule() {
        }
        AWFormTableModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            inputtext.InputTextModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ],
                        exports: [
                            FormTableComponent,
                            FormRowComponent,
                            TopZoneComponent,
                            LeftZoneComponent,
                            RightZoneComponent,
                            MiddleZoneComponent,
                            BottomZoneComponent
                        ]
                    },] },
        ];
        return AWFormTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This component represent a Input field and it can  accept different types of values such as
     * text, number.
     *
     *
     *
     * ### Example
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: '<aw-input-field [value]="inputValue" [type]="inputType"></aw-input-field>'
     *  })
     *  export class TestInputComponent
     *  {
     *      inputValue: string = 'Some text';
     *
     *      // by default input type is text, you can pass string, String, or text
     *      inputType: string = 'string';
     *  }
     *
     * ```
     *
     *
     *
     * ### Example wher input field is initialized with ngModel
     *
     * ```typescript
     * \@Component({
     *      selector: 'wrapper-comp' ,
     *      template: '<aw-input-field [value]="inputValue" [(ngModel)]="inputType"></aw-input-field>'
     *  })
     *  export class TestInputComponent
     *  {
     *      inputValue: string = 'Some text';
     *
     *      // by default input type is text, you can pass string, String, or text
     *      inputType: string = 'string';
     *  }
     *
     * ```
     *
     *  Note: if you are using this outside of FormTable please provide your own FormGroup
     *
     */
    var /** @type {?} */ INPUT_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return InputFieldComponent; }),
        multi: true
    };
    var InputFieldComponent = (function (_super) {
        __extends(InputFieldComponent, _super);
        function InputFieldComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value used to save and read  when rendering and updating a component
             *
             */
            _this.value = '';
            /**
             * Input field type. Currently we support either Number or text
             */
            _this._type = 'string';
            _this.decimalPipe = new common.DecimalPipe(env.locale);
            return _this;
        }
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.bigDecimal);
                this.vchSubscriber = this.formControl.valueChanges
                    .pipe(operators.distinctUntilChanged())
                    .subscribe(function (val) {
                    setTimeout(function () { return _this.value = val; });
                    // this.value = val;
                    // this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        Object.defineProperty(InputFieldComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this._type;
            },
            /**
             *
             * generated setter to check for value and normalizing into expected either number or text
             *
             */
            set: /**
             *
             * generated setter to check for value and normalizing into expected either number or text
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value.toLowerCase() === 'string' || value.toLowerCase() === 'text') {
                    this._type = 'text';
                }
                else if (value.toLowerCase() === 'number') {
                    this._type = 'number';
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputFieldComponent.prototype, "displayValue", {
            get: /**
             * @return {?}
             */ function () {
                if (this.bigDecimal) {
                    this._displayValue = this.formatNumber(this.bigDecimal);
                }
                else {
                    this._displayValue = this.value;
                }
                return this._displayValue;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.canSetType = /**
         * @return {?}
         */
            function () {
                return true;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        InputFieldComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (this.bigDecimal && !core$1.equals(value, this.bigDecimal)) {
                    this.bigDecimal = value;
                    this.formControl.setValue(this.bigDecimal);
                    return;
                }
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value, { onlySelf: true });
                }
            };
        /**
         * Format the number object according to its precision.
         *
         */
        /**
         * Format the number object according to its precision.
         *
         * @param {?} value
         * @return {?}
         */
        InputFieldComponent.prototype.formatNumber = /**
         * Format the number object according to its precision.
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // The default precision is 2. For example, 10.23.
                var /** @type {?} */ digits = '1.0-2';
                // If precision is present, use it for format the bigDecimal value for display.
                if (core$1.isPresent(this.precision) &&
                    this._type === 'number') {
                    digits = '1.0-' + this.precision;
                    return this.decimalPipe.transform(value, digits);
                }
                return value;
            };
        /**
         * @return {?}
         */
        InputFieldComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (core$1.isPresent(this.vchSubscriber)) {
                    this.vchSubscriber.unsubscribe();
                }
            };
        InputFieldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-input-field',
                        template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\" class=\"w-input-wrapper\">\n\n    <input pInputText\n\n           [attr.name]=\"name\"\n           [attr.type]=\"type\"\n           class=\"w-input-field\"\n           [ngClass]=\"styleClass\"\n           [class.has-icon]=\"icon\"\n           placeholder=\"{{placeHolder}}\"\n           [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n           formControlName=\"{{name}}\"\n           [value]=\"displayValue\">\n        <span *ngIf=\"icon\" class=\"sap-icon\" [ngClass]=\"icon\"></span>\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"displayValue\"></aw-string>\n</ng-template>\n",
                        styles: [".w-input-wrapper{position:relative}.w-input-field~span{top:13px;position:absolute;right:15px}"],
                        providers: [
                            INPUT_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return InputFieldComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        InputFieldComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        InputFieldComponent.propDecorators = {
            value: [{ type: core.Input }],
            precision: [{ type: core.Input }],
            bigDecimal: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            type: [{ type: core.Input }]
        };
        return InputFieldComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWStringFieldModule = (function () {
        function AWStringFieldModule() {
        }
        AWStringFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StringComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule
                        ],
                        entryComponents: [
                            StringComponent
                        ],
                        exports: [
                            StringComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWStringFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWInputFieldModule = (function () {
        function AWInputFieldModule() {
        }
        AWInputFieldModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            InputFieldComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            inputtext.InputTextModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            InputFieldComponent
                        ],
                        exports: [
                            InputFieldComponent,
                            AWStringFieldModule,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWInputFieldModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * basic navigation bar provide a main action buttons for its content (page level buttons).
     * This is not the Top level application navigation. This component provides by default action OK,
     * CANCEL and you are free to modify how the OK or CANCEL will be call as well as subscribe to the
     * event. Or you can provide your own buttons template which will be used instead of this default
     * one.
     *
     *
     *
     *
     *
     * ### Example 1:
     *
     * In order to use navigation bar in its basic usage you can do following:
     * this will render buttons on the top as well as on the bottom around the content.
     *
     *
     *  ```html
     *
     *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
     *
     *            <div class="container">
     *                <form>
     *                    User name: <input type=text value="peter.pan">
     *                </<form>>
     *            </div>
     *      </aw-basic-navigator>
     *
     *
     * ```
     *
     *  if you do not want button on the top or bottom you can say thi using binding showTop or
     * showBottom.
     *
     *
     * ### Example 2:
     *  In this example we are providing custom buttons as well as brank section
     *
     *
     *  ```html
     *
     *
     *      <aw-basic-navigator [brandImg]="'img/aribalogobal.png'">
     *            <ng-template #buttons>
     *                <ul class="nav navbar-nav float-md-right collapse navbar-toggleable-xs">
     *                    <li class="nav-item ">
     *                        <button class="btn btn-secondary" type="button"
     * (click)="onSaveAction($evemt)">Cancel</button>
     *                    </li>
     *                    <li class="nav-item active">
     *                        <button class="btn btn-primary" type="button"
     * (click)="onCancelAction($event)"> Save
     *                        </button>
     *                    </li>
     *                </ul>
     *            </ng-template>
     *
     *            <ng-template #brand>
     *                <span class="brand-title">Ariba</span>
     *            </ng-template>
     *
     *
     *            <div class="container">
     *                <form>
     *                    User name: <input type=text value="peter.pan">
     *                </<form>>
     *            </div>
     *      </aw-basic-navigator>
     *
     *
     * ```
     *
     */
    var BasicNavigatorComponent = (function (_super) {
        __extends(BasicNavigatorComponent, _super);
        function BasicNavigatorComponent(env, appConfig) {
            var _this = _super.call(this, env) || this;
            /**
             * Indicates that buttons will be rendered on the top
             *
             * Default value is TRUE
             *
             */
            _this.showTop = true;
            /**
             * Indicates that buttons will be rendered on the bottom
             *
             * Default value is TRUE
             *
             */
            _this.showBottom = true;
            /**
             * Indicates that brand section that is on the left side and only in the top bar is visible
             *
             * Default value is TRUE
             *
             */
            _this.showBrand = true;
            /**
             *
             * EventEmitter that is triggered when you click on default OK Action
             *
             */
            _this.onOKAction = new core.EventEmitter();
            /**
             *
             * EventEmitter that is triggered when you click on default CANCEL Action
             *
             */
            _this.onCancelAction = new core.EventEmitter();
            // todo: load this from resource file using ngTranslate service
            // todo: load this from resource file using ngTranslate service
            _this.okActionLabel = 'OK';
            _this.cancelActionLabel = 'Cancel';
            _this.brandImg = 'images/aribalogobal.png';
            return _this;
        }
        /**
         * @return {?}
         */
        BasicNavigatorComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.showCancelButton)) {
                    this.showCancelButton = this.editable || (this.onCancelAction.observers.length > 0
                        && this.onOKAction.observers.length > 0);
                }
            };
        /**
         * Returns if buttonsTemplate is available
         *
         */
        /**
         * Returns if buttonsTemplate is available
         *
         * @return {?}
         */
        BasicNavigatorComponent.prototype.hasButtonTemplate = /**
         * Returns if buttonsTemplate is available
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.buttonsTemplate);
            };
        /**
         * Returns if brandTemplate is available
         *
         */
        /**
         * Returns if brandTemplate is available
         *
         * @return {?}
         */
        BasicNavigatorComponent.prototype.hasBrandTemplate = /**
         * Returns if brandTemplate is available
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.brandTemplate);
            };
        BasicNavigatorComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-basic-navigator',
                        template: "<p-toolbar *ngIf=\"showTop\" [class]=\"'w-basic-navigator'\">\n    <div class=\"ui-toolbar-group-left\">\n\n        <a class=\"nav-brand\" href=\"#\" *ngIf=\"showBrand\">\n            <ng-template [ngIf]=\"!hasBrandTemplate()\">\n                <img src=\"{{assetFolder}}/{{brandImg}}\" height=\"30\" alt=\"\">\n                <span class=\"nav-brand-title\">Ariba</span>\n            </ng-template>\n\n            <ng-template [embeddedItem]=\"brandTemplate\" [item]=\"context\"\n                         *ngIf=\"hasBrandTemplate()\"></ng-template>\n        </a>\n\n    </div>\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n\n\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n<ng-content></ng-content>\n\n<p-toolbar *ngIf=\"showBottom\">\n\n    <div class=\"ui-toolbar-group-right\">\n        <ng-template [ngIf]=\"!hasButtonTemplate()\">\n\n            <aw-button *ngIf=\"showCancelButton\" [style]=\"'secondary'\"\n                       (action)=\"onCancelAction.emit($event)\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n            <aw-button (action)=\"onOKAction.emit($event)\">\n                {{okActionLabel}}\n            </aw-button>\n        </ng-template>\n        <ng-template [embeddedItem]=\"buttonsTemplate\" [item]=\"context\"\n                     *ngIf=\"hasButtonTemplate()\"></ng-template>\n    </div>\n\n</p-toolbar>\n\n\n\n",
                        styles: ["a.nav-brand{vertical-align:middle;line-height:inherit;text-decoration:none;color:#2d353c}a.nav-brand:focus,a.nav-brand:hover{text-decoration:none}a.nav-brand span{vertical-align:middle}.nav-brand img{display:inline-block;vertical-align:middle;padding:3px}"]
                    },] },
        ];
        /** @nocollapse */
        BasicNavigatorComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core$1.AppConfig }
            ];
        };
        BasicNavigatorComponent.propDecorators = {
            showTop: [{ type: core.Input }],
            showBottom: [{ type: core.Input }],
            showBrand: [{ type: core.Input }],
            brandImg: [{ type: core.Input }],
            okActionLabel: [{ type: core.Input }],
            cancelActionLabel: [{ type: core.Input }],
            context: [{ type: core.Input }],
            showCancelButton: [{ type: core.Input }],
            onOKAction: [{ type: core.Output }],
            onCancelAction: [{ type: core.Output }],
            buttonsTemplate: [{ type: core.ContentChild, args: ['buttons',] }],
            brandTemplate: [{ type: core.ContentChild, args: ['brand',] }]
        };
        return BasicNavigatorComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Button component that implements consistent styling, behavior. Button can be rendered either as
     * a button or as a link. It could be standalone or be part of a form.
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *   <aw-form-table >
     *       <aw-form-row [label]="'Amount'" [name]="'amount'" [size]="'small'">
     *
     *           <aw-button [type]="'submit'" [name]="'button'"
     *                     (action)="onClicked($event)" [value]="command"
     *                     [style]="'warning'" >Button</aw-button>
     *       </aw-form-row>
     *   </aw-form-table>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        command:boolean;
     *
     *        constructor ()
     *        {
     *        }
     *
     *        onClicked(value:string) {
     *           if (value) {
     *              // submit form.
     *           }
     *        }
     *    }
     */
    var ButtonComponent = (function (_super) {
        __extends(ButtonComponent, _super);
        function ButtonComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Button types  [ button | submit | reset ]
             *
             */
            _this.type = 'button';
            /**
             * styling for this button. See ButtonStyle for all supported styles.
             */
            _this.style = 'primary';
            /**
             * sizing for this button. [large, normal, small].
             */
            _this.size = 'normal';
            /**
             * Event fired when user select a item
             */
            _this.action = new core.EventEmitter();
            // Default button class is secondary.
            // Default button class is secondary.
            _this.buttonClass = 'ui-button-secondary';
            // Default disabled
            // Default disabled
            _this.disabled = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // How to style this button.
                if (core$1.isPresent(this.style)) {
                    if (this.style === 'primary') {
                        // Default .ui-button and .ui-button-primary get the same style.
                        // .ui-button-primary is necessary because button style can be overridden
                        // when included inside other widgets. So specify primary
                        this.buttonClass = 'ui-button-primary';
                    }
                    else {
                        this.buttonClass = 'ui-button-' + this.style;
                    }
                }
                // Determine the button class based on input size.
                if (this.size) {
                    switch (this.size) {
                        case 'large':
                            this.buttonClass += ' btn-lg';
                            break;
                        case 'normal':
                            this.buttonClass += ' btn-mid';
                            break;
                        case 'small':
                            this.buttonClass += ' btn-sm';
                            break;
                    }
                }
            };
        /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * @Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         */
        /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * \@Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         * @return {?}
         */
        ButtonComponent.prototype.ngAfterViewInit = /**
         * This is little hacky hackity hack as currently primeng button directive does not work with
         * ngcontent projection but it has a label bindings, which is not the way developers work with
         * button. you want to
         *
         * <button> MY CONTENT</button instead of <button label='MyContent'></button>
         *
         *
         * \@Todo: Change this until the time keep a test that check that they are still using ui-button
         *     that we are expecting and replacing
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.element)) {
                    var /** @type {?} */ button = this.element.nativeElement.querySelector('button');
                    var /** @type {?} */ buttonTitle = button.children[0];
                    button.children[0].textContent = this.element.nativeElement.textContent.trim()
                        .replace('ui-button', '').replace('ui-btn', '');
                    button.classList.remove('ui-button-text-empty');
                    button.textContent = '';
                    button.appendChild(buttonTitle);
                }
            };
        /**
         *  Action clicked. Call parent action.
         */
        /**
         *  Action clicked. Call parent action.
         * @param {?} $event
         * @return {?}
         */
        ButtonComponent.prototype.clicked = /**
         *  Action clicked. Call parent action.
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                this.action.emit(core$1.isBlank(this.value) ? $event : this.value);
            };
        ButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-button',
                        template: "<button\n    pButton\n    [attr.type]=\"type\"\n    [attr.name]=\"name\"\n    [ngClass]=\"buttonClass\"\n    [disabled]=\"disabled\"\n    [attr.value]=\"value\"\n    (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</button>\n",
                        styles: [".ui-button-link{color:#337ab7;font-weight:400;border-radius:0;background-color:transparent}.ui-button-link,.ui-button-link.active,.ui-button-link:active,.ui-button-link:focus,.ui-button-link:hover,.ui-button-link[disabled]{border-color:transparent}.ui-button-link:focus,.ui-button-link:hover{color:#337ab7;-webkit-text-decoration:#337ab7;text-decoration:#337ab7;background-color:transparent}.ui-button-link[disabled]:focus,.ui-button-link[disabled]:hover{color:#2399e5;text-decoration:none}.ui-button{margin-right:5px}.btn-mid{height:36px;padding:5px 10px}.btn-lg{height:42px;font-size:16px;padding:5px 12px}.btn-sm{height:30px;font-size:12px;padding:5px 10px}"]
                    },] },
        ];
        /** @nocollapse */
        ButtonComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        ButtonComponent.propDecorators = {
            type: [{ type: core.Input }],
            name: [{ type: core.Input }],
            style: [{ type: core.Input }],
            size: [{ type: core.Input }],
            target: [{ type: core.Input }],
            value: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return ButtonComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWButtonModule = (function () {
        function AWButtonModule() {
        }
        AWButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.ButtonModule,
                        ],
                        entryComponents: [
                            ButtonComponent
                        ],
                        exports: [
                            ButtonComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWBasicNavigatorModule = (function () {
        function AWBasicNavigatorModule() {
        }
        AWBasicNavigatorModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BasicNavigatorComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.ToolbarModule,
                            AWButtonModule,
                            AWCoreComponentModule
                        ],
                        exports: [
                            BasicNavigatorComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWBasicNavigatorModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardZoneTopComponent = (function () {
        function CardZoneTopComponent() {
        }
        CardZoneTopComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-top",
                        host: {
                            'class': 'w-card-ztop'
                        }
                    },] },
        ];
        return CardZoneTopComponent;
    }());
    var CardZoneBottomComponent = (function () {
        function CardZoneBottomComponent() {
        }
        CardZoneBottomComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-bottom",
                        host: {
                            'class': 'w-card-zbottom'
                        }
                    },] },
        ];
        return CardZoneBottomComponent;
    }());
    /**
     *
     * Card component is a container rendering its content inside 3 different zones.
     *
     *  ------------------------------------------
     *  |   TITLE                       | ACTION |
     *  |-----------------------------------------
     *  |                                        |
     *  |   TOP                                  |
     *  |                                        |
     *  ------------------------------------------
     *  |                                        |
     *  |   BOTTOM                               |
     *  |                                        |
     *  |                                        |
     *  ------------------------------------------
     *
     *
     *  There are 3 zones  + 1 placeholder for the actionIcon
     *
     *  Cards can be selectable which means when you click on it there will be rendered a border with
     *  a check mark inside Action zone (this is default behavior).
     *  You can use [selectable] binding to disable this, in such case card will have just a border
     *  without any check mark.
     *
     *  Cards can also contain custom Action which is rendered inside ACTION zone and on the
     *  application level you can listen for (click) events as well as you can provide your own action
     *  icon
     *
     *  Besides ACTION, TITLE, TOP and BOTTOM content zones cards support hover overlay effect and
     *  when its activated there is a overlay displayed on top of the card with Icon in the middle.
     *  Please note when [hasHover] is TRUE all the actions and selectability are disabled as there is
     *  only one action which click on the hover overlay.
     *
     *
     * ###example 1:
     *  Basic hover card which by default support selectable mode
     *
     * ```
     *          <aw-card #card1 [hasAction]="false" [width]="'202px'" [height]="'154px'">
     *
     *                 <aw-card-title [align]="'bottom-left'">
     *                     <span class="a-supplier-tag">
     *                         Preferred
     *                     </span>
     *                 </aw-card-title>
     *
     *                 <aw-card-top>
     *                     <div class="supplierName">
     *                         Haight Pumps
     *                     </div>
     *                     <div class="supplierLocation">
     *                         Palo Alto, CA, USA
     *                     </div>
     *                 </aw-card-top>
     *
     *                 <aw-card-bottom class="w-card-zbottom">
     *                     some text about the supplier and his parents<br/>
     *                     and some contacts
     *                 </aw-card-bottom>
     *
     *             </aw-card>
     *
     * ```
     *
     *  ###example 2:
     *   Hover card with custom action. when unselected action will appear and user can click on it.
     *
     * ```
     *          <aw-card #card1 [selectable]="true" [actionIcon]="'icon-question-mark'"
     *                     (onAction)="onAction(3, $event)">
     *
     *                 <aw-card-title [align]="'bottom-left'">
     *                     <span class="a-supplier-tag">
     *                         Preferred
     *                     </span>
     *                 </aw-card-title>
     *
     *                 <aw-card-top>
     *                     <div class="supplierName">
     *                         Haight Pumps
     *                     </div>
     *                     <div class="supplierLocation">
     *                         Palo Alto, CA, USA
     *                     </div>
     *                 </aw-card-top>
     *
     *                 <aw-card-bottom class="w-card-zbottom">
     *                     some text about the supplier and his parents<br/>
     *                     and some contacts
     *                 </aw-card-bottom>
     *
     *             </aw-card>
     *
     * ```
     *
     *
     *
     */
    var CardComponent = (function (_super) {
        __extends(CardComponent, _super);
        function CardComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Tells if we should explicitly hide the action
             *
             */
            _this.hasAction = false;
            /**
             *
             * Is selectable mode supported? Saying Yes, card will have by default check-mark in the
             * ACTION zone when selected
             *
             */
            _this.selectable = true;
            /**
             * Option to pass custom "Card Selected" Icon
             *
             */
            _this.selectedIcon = 'icon-accept';
            /*
                 * Enable and disables hover effect on top of the card
                 */
            _this.hasHover = false;
            /**
             *
             * Default icon name for the hover overlay. This icons shows up in the middle over the card
             * vertically and horizontally centered
             *
             */
            _this.hoverIcon = 'icon-add';
            /**
             *  Selection state
             *
             */
            _this.selected = true;
            /**
             * Fired when the card is selected.
             *
             */
            _this.onSelect = new core.EventEmitter();
            /**
             * Fired when action icon is clicked.
             *
             */
            _this.onAction = new core.EventEmitter();
            /**
             * Fired when the user clicks on the hover overlay.
             *
             */
            _this.onHoverAction = new core.EventEmitter();
            /**
             * Usually when template is provided we want to use it and replace internal one but in this
             * case it will be always conditional and application developer can switch between default
             * template with zones and custom one provided by developer.
             *
             */
            _this.useBodyTemplate = false;
            // sets default value
            // sets default value
            _this.width = '202px';
            _this.height = '154px';
            return _this;
        }
        /**
         * @return {?}
         */
        CardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // If application wants to use action it must provide actionIcon
                if (core$1.isBlank(this.actionIcon) && this.hasAction) {
                    throw new Error('You need to provide action icon');
                }
            };
        /**
         * @return {?}
         */
        CardComponent.prototype.showBottomSection = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.bottom);
            };
        /**
         * fires select and unselect event.
         */
        /**
         * fires select and unselect event.
         * @param {?} event
         * @return {?}
         */
        CardComponent.prototype.toggleSelect = /**
         * fires select and unselect event.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.selectable) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                else {
                    this.selected = !this.selected;
                    this.onSelect.emit(this.selected);
                }
            };
        /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         */
        /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         * @param {?} event
         * @return {?}
         */
        CardComponent.prototype.onActionClick = /**
         *
         * Only fired when action is rendered and user clicks on custom actionIcon
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.hasAction && (!this.selected || !this.selectable)) {
                    this.onAction.emit(this.selected);
                }
            };
        /**
         * Triggered  when hover effect is on + user click on the card
         *
         */
        /**
         * Triggered  when hover effect is on + user click on the card
         *
         * @param {?} isEnter
         * @return {?}
         */
        CardComponent.prototype.onHover = /**
         * Triggered  when hover effect is on + user click on the card
         *
         * @param {?} isEnter
         * @return {?}
         */
            function (isEnter) {
                if (core$1.isPresent(this.hoverDiv)) {
                    this.hoverDiv.nativeElement.style.opacity = isEnter ? 0.5 : 0;
                }
            };
        /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         */
        /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         * @return {?}
         */
        CardComponent.prototype.showBodyTemplate = /**
         *
         * Used to decide if we should render implicit card template with our zones or
         * user provided template
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.bodyTemplate) && this.useBodyTemplate;
            };
        CardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-card',
                        template: "<div class=\"w-card\" [style.width]=\"width\" [style.height]=\"height\"\n     [class.u-is-hover]=\"hasHover\"\n     (mouseenter)=\"onHover(true)\"\n     (mouseleave)=\"onHover(false)\"\n     [class.u-card-selected]=\"selected\"\n     [class.u-card-unselected]=\"!selected\"\n     [ngClass]=\"styleClass\"\n>\n\n    <div class=\"card-body ui-g\"  *ngIf=\"!showBodyTemplate()\">\n        <!-- Hover element that is triggered by mouseenter, mouseleave events-->\n        <div #hoverDiv *ngIf=\"hasHover\" class=\"u-card-hover\" (click)=\"onHoverAction.emit($event)\">\n            <span [style.width]=\"'100%'\" class=\"sap-icon\" [ngClass]=\"hoverIcon\"></span>\n        </div>\n        <!-- HEADER HAVING TITLE AND ICONS/ACTIONS-->\n        <div class=\"ui-g-12 ui-g-nopad w-card-header\">\n            <div class=\"w-card-ztitle ui-g-nopad\" (click)=\"toggleSelect($event)\"\n                 [class.u-card-pointer]=\"selectable\"\n                 [ngClass]=\"{'ui-g-9': hasAction || selectable, 'ui-g-11': !hasAction && !selectable}\">\n                <ng-content select=\"aw-card-title\"></ng-content>\n            </div>\n\n            <div *ngIf=\"hasAction || selectable\" class=\"w-card-zaction ui-g-nopad ui-g-3\">\n\n                <span *ngIf=\"selected && selectable\" class=\"sap-icon selection\"\n                      [class.u-card-pointer]=\"selectable\"\n                      [class.u-card-action-bg]=\"selected\"\n                      (click)=\"toggleSelect($event)\"\n                      [ngClass]=\"selectedIcon\"></span>\n\n\n                <span *ngIf=\"hasAction && (!selected || !selectable) \"\n                      class=\"sap-icon action\"\n                      [class.u-card-pointer]=\"true\"\n                      (click)=\"onActionClick($event)\"\n                      [ngClass]=\"actionIcon\"\n                ></span>\n            </div>\n        </div>\n\n        <!--TOP CARD SECTION-->\n        <div class=\"w-card-ztop ui-g-nopad ui-g-12 \"\n             (click)=\"toggleSelect($event)\"\n             [class.u-card-pointer]=\"selectable\">\n            <ng-content select=\"aw-card-top\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-g-nopad w-card-line-divider  \" *ngIf=\"showBottomSection()\"></div>\n        <!--BOTTOM CARD SECTION-->\n        <div *ngIf=\"showBottomSection()\" class=\"ui-g-12 ui-g-nopad w-card-zbottom\"\n             [class.u-card-pointer]=\"selectable\"\n             (click)=\"toggleSelect($event)\">\n            <ng-content select=\"aw-card-bottom\"></ng-content>\n        </div>\n    </div>\n\n    <div *ngIf=\"showBodyTemplate()\" class=\"w-card-user-cnt\" >\n        <ng-container *ngTemplateOutlet=\"bodyTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n",
                        styles: [".w-card{border:2px solid #0076cb;display:inline-block;overflow:hidden;color:#636363;box-sizing:border-box}.w-card-header{position:relative;height:30px;padding-left:1em}.w-card-ztitle{height:100%;padding-top:3px}.w-card-ztitle ::ng-deep .w-card-title{height:100%;width:100%;display:flex}.w-card-ztitle ::ng-deep .w-card-title>*{flex:0 1}.w-card-zaction{height:100%;display:inline-block;text-align:right}.w-card-zaction .sap-icon{width:29px;height:29px;text-align:center;display:inline-block;font-size:1.5em;line-height:1.4em}.w-card-zaction .sap-icon.selection{color:#fff}.w-card-zaction .sap-icon.action{color:#969696}.w-card-zbottom,.w-card-ztop{padding:1em}.w-card-line-divider{border-top:1px solid #d6d6d6;margin:0 14px}.w-card-user-cnt{width:100%;height:100%;position:relative;background-color:#eee}.u-card-hover{position:absolute;height:100%;width:100%;opacity:0;transition:.5s ease;background-color:#0076cb;z-index:100}.u-card-hover .sap-icon{text-align:center;display:inline-block;font-size:4em;color:#fff;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.u-card-action-bg{background:#0076cb}.u-is-hover{position:relative}.u-card-selected{border-color:#0076cb}.u-card-unselected{border-color:#d7d7d7}.u-card-hover,.u-card-pointer{cursor:pointer}"]
                    },] },
        ];
        /** @nocollapse */
        CardComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        CardComponent.propDecorators = {
            hasAction: [{ type: core.Input }],
            selectable: [{ type: core.Input }],
            selectedIcon: [{ type: core.Input }],
            actionIcon: [{ type: core.Input }],
            hasHover: [{ type: core.Input }],
            hoverIcon: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            onSelect: [{ type: core.Output }],
            onAction: [{ type: core.Output }],
            onHoverAction: [{ type: core.Output }],
            bottom: [{ type: core.ContentChild, args: [CardZoneBottomComponent,] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['body',] }],
            hoverDiv: [{ type: core.ViewChild, args: ['hoverDiv',] }]
        };
        return CardComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Maps our internal alignment value to real css values
     *
     */
    var /** @type {?} */ VAlignMap = {
        'top-left': 'flex-start',
        'top-center': 'flex-start',
        'top-right': 'flex-start',
        'center-left': 'center',
        'center-center': 'center',
        'center-right': 'center',
        'bottom-left': 'flex-end',
        'bottom-center': 'flex-end',
        'bottom-right': 'flex-end'
    };
    var /** @type {?} */ HAlignMap = {
        'top-left': 'flex-start',
        'top-center': 'center',
        'top-right': 'flex-end',
        'center-left': 'flex-start',
        'center-center': 'center',
        'center-right': 'flex-end',
        'bottom-left': 'flex-start',
        'bottom-center': 'center',
        'bottom-right': 'flex-end'
    };
    /**
     * Title zone provides a content placeholder for the Title Area. This zone is adding ability
     * to align its content into 9 different position.
     *
     * You can use this Title zone within <aw-card> as:
     *
     *
     * ```html
     *
     *  <aw-card  [width]="'202px'" [height]="'154px'" [hasHover]="true"
     *                       [selectable]="false" [hasAction]="false"
     *                  (onHoverAction)="onAction(7, $event)" >
     *
     *                  <aw-card-title [align]="'bottom-left'">
     *                      <span class="a-supplier-tag">
     *                          Preferred
     *                      </span>
     *                  </aw-card-title>
     *
     *   </aw-card>
     *
     * ```
     * Default alignment is top-left
     *
     *
     *
     *
     */
    var CardZoneTitleComponent = (function (_super) {
        __extends(CardZoneTitleComponent, _super);
        function CardZoneTitleComponent(env, elem) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.elem = elem;
            /**
             * Special property which is used to apply flex properties for aligning content vertically
             * as well as horizontally
             *
             */
            _this.align = 'top-left';
            return _this;
        }
        /**
         * @return {?}
         */
        CardZoneTitleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.elem.nativeElement.style.alignItems = VAlignMap[this.align];
                this.elem.nativeElement.style.justifyContent = HAlignMap[this.align];
            };
        CardZoneTitleComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: "aw-card-title",
                        host: {
                            'class': 'w-card-title'
                        }
                    },] },
        ];
        /** @nocollapse */
        CardZoneTitleComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef }
            ];
        };
        CardZoneTitleComponent.propDecorators = {
            align: [{ type: core.Input }]
        };
        return CardZoneTitleComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCardModule = (function () {
        function AWCardModule() {
        }
        AWCardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            CardComponent,
                            CardZoneTitleComponent,
                            CardZoneTopComponent,
                            CardZoneBottomComponent
                        ],
                        entryComponents: [
                            CardComponent
                        ],
                        exports: [
                            CardComponent,
                            CardZoneTitleComponent,
                            CardZoneTopComponent,
                            CardZoneBottomComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Implements standard HTML checkbox on top of PrimeNG. There are 2 types of
     * {\@link CheckboxComponent}: form and action checkbox as described above.
     *
     *
     * Usage: Basic example having red checkbox checked
     *
     * ```HTML
     *        <aw-checkbox [name]="'color'" [value]="'red'" [label]="'Red'"
     *                                        [(ngModel)]="model">
     *        </aw-checkbox>
     *        <aw-checkbox [name]="'color'" [value]="'blue'" [label]="'Blue'"
     *                                        [(ngModel)]="model">
     *       </aw-checkbox>
     *
     * ```
     *
     * ```ts
     *
     *
     *   class CBBasicWithNgModelComponent
     *   {
     *
     *       model: string[] = ['red'];
     *
     *       constructor()
     *       {
     *       }
     *   }
     *
     * ```
     *
     * For more examples please see a playground or unit test.
     *
     */
    var /** @type {?} */ CB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var CheckboxComponent = (function (_super) {
        __extends(CheckboxComponent, _super);
        function CheckboxComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value associated with this checkbox
             *
             */
            _this.value = '';
            /**
             * Type of checkbox. Form based updates model and Action based only fires click events
             *
             */
            _this.type = 'form';
            /**
             * Trigger click event.
             *
             */
            _this.action = new core.EventEmitter();
            /**
             * PrimeNG has this type called binary which works only with Boolean meaning it does not add or
             * remove values.
             *
             * In our case Checktype = Action is always binary or when this.value is boolean
             *
             */
            _this.isBinary = false;
            return _this;
        }
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.model = this.value;
                this.type = this.action.observers.length > 0 ? 'action' : this.type;
                if (this.isFormType()) {
                    _super.prototype.ngOnInit.call(this);
                    if (this.isStandalone) {
                        _super.prototype.registerFormControl.call(this, this.value);
                        this.model = this.formControl.value;
                        this.onModelChanged(this.model);
                    }
                    else {
                        // get control from parent
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
                // When value is boolean we are dealing with PrimeNg Binary checkbox
                // which only sets TRUE/FALSE and does not add or remove values
                this.isBinary = core$1.isBoolean(this.value);
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['value']) &&
                    (changes['value'].currentValue !== changes['value'].previousValue)) {
                    this.model = changes['value'].currentValue;
                }
            };
        /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         */
        /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         * @param {?} event
         * @return {?}
         */
        CheckboxComponent.prototype.onChange = /**
         * Called when Checkbox is clicked and it either fire action or updates the model.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isFormType()) {
                    this.onModelChanged(this.model);
                    if (this.isStandalone) {
                        this.formControl.setValue(this.model);
                    }
                }
                else {
                    this.action.emit(event);
                }
            };
        /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         */
        /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         * @return {?}
         */
        CheckboxComponent.prototype.isFormType = /**
         *
         * Tell if we are using Form Checkbox. This is used remove some of the bindings that are not
         * applicable for certain type.
         *
         * @return {?}
         */
            function () {
                return this.type === 'form';
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.model && this.isFormType()) {
                    this.model = value;
                    if (this.isStandalone) {
                        this.onModelChanged(this.model);
                        this.formControl.setValue(this.model);
                    }
                }
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-checkbox',
                        template: "<span class=\"w-checkbox\">\n\n    <ng-template [ngIf]=\"editable && isFormType()\">\n        <p-checkbox [name]=\"name\" [value]=\"value\" [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    [binary]=\"isBinary\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\"\n                    [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        >\n        </p-checkbox>\n    </ng-template>\n\n\n    <ng-template [ngIf]=\"!isFormType()\">\n        <p-checkbox [binary]=\"isBinary\"\n                    [label]=\"label\"\n                    [(ngModel)]=\"model\"\n                    (onChange)=\"onChange($event)\"\n                    [disabled]=\"disabled\">\n        </p-checkbox>\n\n    </ng-template>\n</span>\n",
                        styles: ["/deep/ .ui-chkbox .ui-chkbox-box{width:22px;height:22px}/deep/ .ui-chkbox .pi{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.07em;line-height:1.42em}/deep/ .ui-chkbox .pi.pi-check:before{content:'\\e05b'}"],
                        providers: [
                            CB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CheckboxComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        CheckboxComponent.propDecorators = {
            value: [{ type: core.Input }],
            type: [{ type: core.Input }],
            label: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return CheckboxComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCheckBoxModule = (function () {
        function AWCheckBoxModule() {
        }
        AWCheckBoxModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CheckboxComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.CheckboxModule
                        ],
                        entryComponents: [
                            CheckboxComponent
                        ],
                        exports: [
                            CheckboxComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWCheckBoxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  Checkbox list is a wrapper class around 'Checkbox' component to simply assembly of multi choice
     * component
     *
     * In Addition it adds ability to work with complex object. PrimeNG checkboxes work only with
     * primitive values.
     *
     * @see {\@link check-box/check-box.component.ts}
     *
     *
     * ### Example
     *
     *
     * \@Component({
     *       selector: 'showCheckBoxList' ,
     *       template: `
     *           <aw-checkbox-list [list]="checkBoxListValues" [selections]="selectedValues"
     *
     *            [name]="'myColors'" [formGroup]="formGroup" (onSelection)="onCBClick">
     *           </aw-checkbox-list>
     *       `
     *
     *       })
     *        class MyShowCLComponent
     *        {
     *            checkBoxListValues: string[] = ['blue' , 'red' , 'yellow' , 'orange' , 'white' ,
     *     'silver' , 'black' ,
     *            'Green' , 'Gray' , 'Navy' , 'Olive' , 'Aqua' , 'Purple'];
     *
     *            selectedValues: string[] = ['blue' , 'Olive' , 'Aqua' , 'Purple'];
     *
     *
     *            formGroup: FormGroup = new FormGroup({});
     *
     *
     *            onCBClick (event): void
     *            {
     *                console.log('onCBClick = ' + event);
     *            }
     *
     *        }
     * *
     */
    var /** @type {?} */ CB_LIST_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckBoxListComponent; }),
        multi: true
    };
    var CheckBoxListComponent = (function (_super) {
        __extends(CheckBoxListComponent, _super);
        function CheckBoxListComponent(env, cd, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.cd = cd;
            _this.parentContainer = parentContainer;
            /**
             * Fires event when checkbox is selected/clicked. Emits current clicked checkboxed. not the
             * actuall internal model value in this case array of choices
             *
             */
            _this.onSelection = new core.EventEmitter();
            /**
             * Internal model
             */
            _this.model = [];
            return _this;
        }
        /**
         * @return {?}
         */
        CheckBoxListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.selections)) {
                    this.selections = [];
                }
                this.registerFormControl(this.selections);
                this.updateModel(this.selections);
                this.onModelChanged(this.selections);
            };
        /**
         * @return {?}
         */
        CheckBoxListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ updatedModel = [];
                this.model.forEach(function (index) { return updatedModel.push(_this.list[index]); });
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
                this.cd.detectChanges();
            };
        /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         */
        /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         * @param {?} item
         * @return {?}
         */
        CheckBoxListComponent.prototype.labelValue = /**
         * Label is extracted into this method so in the future we can play more how we want to display
         * the value. Since I want to support formatters for each components we might have a chance to
         * decide how label will look like.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.labelFormatter)) {
                    return this.labelFormatter(item);
                }
                return item.toString();
            };
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         */
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         * @param {?} item
         * @return {?}
         */
        CheckBoxListComponent.prototype.value = /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item;
            };
        /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         */
        /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         * @param {?} event
         * @return {?}
         */
        CheckBoxListComponent.prototype.onChange = /**
         * Delegate event outside of this component and convert indexed model to original objects
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                var /** @type {?} */ updatedModel = [];
                this.model.forEach(function (index) {
                    updatedModel.push(_this.list[index]);
                });
                this.onSelection.emit(updatedModel);
                this.onModelChanged(updatedModel);
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
            };
        /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         */
        /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         * @param {?} sourceList
         * @return {?}
         */
        CheckBoxListComponent.prototype.updateModel = /**
         * Since we might be dealing with complex object store only INDEXes number in the model.
         *
         * @param {?} sourceList
         * @return {?}
         */
            function (sourceList) {
                var _this = this;
                sourceList.forEach(function (item) {
                    var /** @type {?} */ index = _this.list.findIndex(function (elem) {
                        return core$1.equals(item, elem);
                    });
                    _this.model.push(index);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CheckBoxListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (core$1.isPresent(this.model) && core$1.isPresent(value)) {
                    var /** @type {?} */ newModel = value;
                    this.updateModel(newModel);
                    // this.cd.markForCheck();
                }
            };
        CheckBoxListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-checkbox-list',
                        template: "<div *ngFor=\"let item of list; let i = index\" class=\"ui-g\">\n\n    <!-- in the future we should be able to to support inline and stack-->\n    <div class=\"ui-g-12\">\n        <aw-checkbox [(ngModel)]=\"model\"\n                     (ngModelChange)=\"onChange($event)\"\n                     [editable]=\"editable\"\n                     [isStandalone]=\"false\"\n                     [name]=\"name\"\n                     [value]=\"i\"\n                     [label]=\"labelValue(item)\">\n\n        </aw-checkbox>\n    </div>\n\n</div>\n\n",
                        styles: [""],
                        providers: [
                            CB_LIST_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CheckBoxListComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        CheckBoxListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ChangeDetectorRef },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        CheckBoxListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selections: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            labelFormatter: [{ type: core.Input }]
        };
        return CheckBoxListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCheckBoxListModule = (function () {
        function AWCheckBoxListModule() {
        }
        AWCheckBoxListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CheckBoxListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCheckBoxModule
                        ],
                        exports: [
                            CheckBoxListComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWCheckBoxListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Hyperlink component that implements consistent styling, behavior. Hyperlink supports all of the
     * native link functionality. In addition, it supports navigation to components through the action
     * binding.
     *
     *
     * for more info please see class Doc of the:
     * @see {\@link button/button.component.ts}
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *           <aw-hyperlink  [type]="'text/html'" [name]="'link'"
     *                        (action)="onClicked($event)" [value]="customerId"
     *                        [size]="'large'" >my link</aw-hyperlink>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        command:boolean;
     *
     *        constructor ()
     *        {
     *        }
     *
     *        onClicked(customerId:string) {
     *           if (customerId) {
     *              // display customer details component.
     *           }
     *        }
     *    }
     */
    var HyperlinkComponent = (function (_super) {
        __extends(HyperlinkComponent, _super);
        function HyperlinkComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * sizing for this link. [large, normal, small].
             */
            _this.size = 'normal';
            /**
             * Event fired when user select a item
             */
            _this.action = new core.EventEmitter();
            /**
             * Internal CSS class that styles this hyperlink based on input 'size'
             */
            _this.linkClass = 'link';
            return _this;
        }
        /**
         * @return {?}
         */
        HyperlinkComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // Determine the link class based on input size.
                if (this.size) {
                    switch (this.size) {
                        case 'large':
                            this.linkClass += ' link-lg';
                            break;
                        case 'normal':
                            this.linkClass += ' link-mid';
                            break;
                        case 'small':
                            this.linkClass += ' link-sm';
                            break;
                    }
                }
                // If I have an action tag, and no href. We add default styling and behavior.
                if (this.action.observers.length > 0) {
                    this.linkClass += ' link-bh';
                }
            };
        /**
         *  Action clicked. Call parent action.
         */
        /**
         *  Action clicked. Call parent action.
         * @param {?} event
         * @return {?}
         */
        HyperlinkComponent.prototype.clicked = /**
         *  Action clicked. Call parent action.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.action.emit({
                    event: event,
                    value: this.value
                });
            };
        HyperlinkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-hyperlink',
                        template: "<a [attr.type]=\"type\"\n   [attr.href]=\"href\"\n   [attr.rel]=\"rel\"\n   [attr.target]=\"target\"\n   [ngClass]=\"linkClass\"\n   [class.disabled]=\"disabled\"\n   (click)=\"clicked($event)\">\n\n    <ng-content></ng-content>\n</a>\n",
                        styles: [".link{color:#0275d8;cursor:pointer}.link.link-bh{color:#0275d8}.link.link-bh:hover{text-decoration:underline;cursor:pointer}.link-sm{font-size:.875em}.link-mid{font-size:1em}.link-lg{font-size:1.25em}.link.disabled{pointer-events:none;cursor:default;color:#ddd}"]
                    },] },
        ];
        /** @nocollapse */
        HyperlinkComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        HyperlinkComponent.propDecorators = {
            type: [{ type: core.Input }],
            href: [{ type: core.Input }],
            rel: [{ type: core.Input }],
            size: [{ type: core.Input }],
            target: [{ type: core.Input }],
            value: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return HyperlinkComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWHyperlinkModule = (function () {
        function AWHyperlinkModule() {
        }
        AWHyperlinkModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            HyperlinkComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            HyperlinkComponent
                        ],
                        exports: [
                            HyperlinkComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWHyperlinkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Selection State for the chooser in order to be able to comunicate with the parent object using a
     * chooser. If I would have to manage only single values with no addional methods i would user
     * emitters to do the job, but in this case we need this interface (abstract class) between a
     * chooser and actual object.
     *
     *
     * @abstract
     */
    var /**
     * Selection State for the chooser in order to be able to comunicate with the parent object using a
     * chooser. If I would have to manage only single values with no addional methods i would user
     * emitters to do the job, but in this case we need this interface (abstract class) between a
     * chooser and actual object.
     *
     *
     * @abstract
     */ ChooserSelectionState = (function () {
        function ChooserSelectionState() {
        }
        /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         */
        /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        ChooserSelectionState.prototype.setSelectionState = /**
         *
         * Set selection state is usually triggered by selecting and unselecting a item (in case of
         * multiselect) and it should update its list of objects with either settings/adding item or
         * removing it.
         *
         *
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
            };
        /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         */
        /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         * @return {?}
         */
        ChooserSelectionState.prototype.selectedObject = /**
         * The most recent selection . Null if last action was a deselection. Usually used by Chooser
         * or ChooserState to get cuurent value.
         *
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        /**
         * The most recent selections.
         *
         */
        /**
         * The most recent selections.
         *
         * @return {?}
         */
        ChooserSelectionState.prototype.selectedObjects = /**
         * The most recent selections.
         *
         * @return {?}
         */
            function () {
                return core$1.unimplemented();
            };
        /**
         *
         * Check if the item selection items is in the selectedObjects
         */
        /**
         *
         * Check if the item selection items is in the selectedObjects
         * @param {?} selection
         * @return {?}
         */
        ChooserSelectionState.prototype.isSelected = /**
         *
         * Check if the item selection items is in the selectedObjects
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                return core$1.unimplemented();
            };
        return ChooserSelectionState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
     * selection as well as it can broadcast any updates.
     *
     *
     */
    var /**
     * ChooserState manages complete lifecycle for the Chooser Component. It keeps track of current
     * selection as well as it can broadcast any updates.
     *
     *
     */ ChooserState = (function () {
        function ChooserState(chooserSelectionState, isMulti) {
            if (isMulti === void 0) {
                isMulti = true;
            }
            /**
             * Indicates if there are any validation like entered value does not much with the source list.
             *
             */
            this.isInvalid = false;
            /**
             *
             * indicates that we started to some editing e.g. starting to type in something into the
             * filter, or removing already selected items
             */
            this.addMode = false;
            this.recentSelectedDisplayed = 0;
            /**
             * When this option is active we do not show all selected items, but max number that is
             * defined. User is able to toggle to expand the view to see all selections and hide them as
             * well
             */
            this.showAllRecentlySelected = false;
            this.selectionState = chooserSelectionState;
            this.multiselect = isMulti;
            if (core$1.isBlank(this.selectionState)) {
                this.selectionState = new DefaultSelectionState(this.multiselect);
            }
        }
        /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         */
        /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         * @param {?} item
         * @return {?}
         */
        ChooserState.prototype.updatedSelectedObjects = /**
         *
         * It will select and persist an item using ChooserSelectionState provider.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    item = this.currentItem;
                }
                if (!this.multiselect) {
                    this.setSelectionState(item, true);
                }
                else {
                    var /** @type {?} */ selectedObject = this.selectedObject();
                    var /** @type {?} */ selectedObjects = this.selectedObjects();
                    if (this.addMode) {
                        if (this.isInvalid) {
                            if (core$1.isPresent(selectedObject)) {
                                this.setSelectionState(selectedObject, false);
                            }
                        }
                        this.setSelectionState(item, !core$1.ListWrapper.containsComplex(selectedObjects, item));
                    }
                    else {
                        if (core$1.isPresent(selectedObject)) {
                            this.setSelectionState(selectedObject, false);
                        }
                        this.setSelectionState(item, true);
                    }
                }
            };
        /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         */
        /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         * @return {?}
         */
        ChooserState.prototype.toggleAllSelected = /**
         * When user selection is large we use this method to check if we need to show all selected
         * items or only MaxRecentSelected
         * @return {?}
         */
            function () {
                this.showAllRecentlySelected = !this.showAllRecentlySelected;
            };
        Object.defineProperty(ChooserState.prototype, "recentSelectedObjects", {
            /**
             *
             * Renders user's selection under the input field
             *
             */
            get: /**
             *
             * Renders user's selection under the input field
             *
             * @return {?}
             */ function () {
                if (!this.multiselect) {
                    return [];
                }
                var /** @type {?} */ recentSelectedObjects = [];
                this.recentSelectedDisplayed = 0;
                var /** @type {?} */ selectedObjects = this.selectedObjects();
                var /** @type {?} */ size = selectedObjects.length;
                var /** @type {?} */ maxCount = DataSource.MaxRecentSelected;
                if (size > DataSource.MaxRecentSelected && !this.showAllRecentlySelected) {
                    maxCount -= 1;
                }
                if (this.showAllRecentlySelected) {
                    maxCount = size;
                }
                for (var /** @type {?} */ i = size - 1; i >= 0 && (this.recentSelectedDisplayed < maxCount); i--) {
                    var /** @type {?} */ selection = selectedObjects[i];
                    recentSelectedObjects.push(selection);
                    this.recentSelectedDisplayed++;
                }
                return recentSelectedObjects;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ChooserState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                return this.selectionState.selectedObject();
            };
        /**
         * @return {?}
         */
        ChooserState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                return this.selectionState.selectedObjects();
            };
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        ChooserState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (core$1.isPresent(selection)) {
                    this.selectionState.setSelectionState(selection, selected);
                }
            };
        return ChooserState;
    }());
    /**
     * Dummy implementation ChooserSelectionState
     */
    var /**
     * Dummy implementation ChooserSelectionState
     */ DefaultSelectionState = (function (_super) {
        __extends(DefaultSelectionState, _super);
        function DefaultSelectionState(multiSelect) {
            var _this = _super.call(this) || this;
            _this.multiSelect = multiSelect;
            return _this;
        }
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        DefaultSelectionState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (selected) {
                    this._selectedObject = selection;
                    if (this.multiSelect && !core$1.ListWrapper.containsComplex(this.selectedObjects(), selection)) {
                        this.selectedObjects().push(selection);
                    }
                }
                else {
                    if (this.multiSelect) {
                        core$1.ListWrapper.removeIfExist(this.selectedObjects(), selection);
                    }
                }
            };
        /**
         * @return {?}
         */
        DefaultSelectionState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                return this._selectedObject;
            };
        /**
         * @return {?}
         */
        DefaultSelectionState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this._selectedObjects)) {
                    this._selectedObjects = [];
                }
                return this._selectedObjects;
            };
        /**
         * @param {?} selection
         * @return {?}
         */
        DefaultSelectionState.prototype.isSelected = /**
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                return _super.prototype.isSelected.call(this, selection);
            };
        return DefaultSelectionState;
    }(ChooserSelectionState));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
     *
     * 1) You can use default DataSource injected inside component constructor and just call
     * initialize to configure it with correct DataProvider and DataFinder:
     *
     *
     * ```
     *   this.dataSource.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     * and then you can use it to simply retrieve data or run queries.
     *
     * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
     * binding
     *
     * ```
     *
     *   this.ds = new ChooserDataSource(this.data, this.finders);
     *   this.ds.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     *
     */
    var /**
     * Concrete DataSource implementation for the Chooser component. There are two ways how to use it:
     *
     * 1) You can use default DataSource injected inside component constructor and just call
     * initialize to configure it with correct DataProvider and DataFinder:
     *
     *
     * ```
     *   this.dataSource.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     * and then you can use it to simply retrieve data or run queries.
     *
     * 2) You will instantiate your own DataSource and pass it into the component using [dataSource]
     * binding
     *
     * ```
     *
     *   this.ds = new ChooserDataSource(this.data, this.finders);
     *   this.ds.init({
     *               obj: this.list,
     *               queryType: QueryType.FullText,
     *               state: null,
     *               multiselect: this.multiselect
     *           });
     *
     * ```
     *
     *
     */ ChooserDataSource = (function (_super) {
        __extends(ChooserDataSource, _super);
        function ChooserDataSource(dataProviders, finders) {
            var _this = _super.call(this, dataProviders, finders) || this;
            _this.dataProviders = dataProviders;
            _this.finders = finders;
            return _this;
        }
        /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         */
        /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         * @param {...?} args
         * @return {?}
         */
        ChooserDataSource.prototype.init = /**
         * To initialize this DataSource with current DataFinder and Provider as well as state we use
         * an interface DSChooserInitParams to have all init values typed checked
         *
         *
         * @param {...?} args
         * @return {?}
         */
            function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (core$1.isBlank(args) || args.length !== 1 && !isDSChooserInitParams(args[0])) {
                    throw new Error('You need to initialize DS with (DSChooserInitParams)');
                }
                var /** @type {?} */ init = args[0];
                this.dataProvider = core$1.isPresent(init.dataProvider) ? init.dataProvider
                    : this.dataProviders.find(init.obj);
                this.dataFinder = core$1.isPresent(init.dataFinder) ? init.dataFinder
                    : this.finders.find(this.dataProvider, init.queryType);
                core$1.assert(core$1.isPresent(this.dataProvider) && core$1.isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
                if (core$1.isPresent(init.state)) {
                    this.state = init.state;
                }
                else {
                    this.state = new ChooserState(null, init.multiselect);
                }
                this.dataFinder.lookupKey = init.lookupKey;
                this.state.lookupKey = init.lookupKey;
            };
        /**
         * @param {?} pattern
         * @param {?} max
         * @return {?}
         */
        ChooserDataSource.prototype.find = /**
         * @param {?} pattern
         * @param {?} max
         * @return {?}
         */
            function (pattern, max) {
                var _this = this;
                this.state.pattern = pattern;
                this.state.lastFullMatchPattern = pattern;
                if (pattern.length === 0) {
                    return;
                }
                if (pattern === '*') {
                    // query everything
                    pattern = '';
                }
                // make sure we dataFinder has expected lookup key
                var /** @type {?} */ origKey = this.dataFinder.lookupKey;
                this.dataFinder.lookupKey = this.state.lookupKey;
                this.dataFinder.forData(this.dataProvider).match(pattern, max)
                    .subscribe(function (result) {
                    _this.state.matches = result;
                    if (_this.state.multiselect) {
                        for (var /** @type {?} */ i = 0; i < _this.state.selectedObjects().length; i++) {
                            var /** @type {?} */ item = _this.state.selectedObjects()[i];
                            core$1.ListWrapper.removeIfExist(_this.state.matches, item);
                        }
                    }
                    _this.dataFinder.lookupKey = origKey;
                });
            };
        /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         */
        /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         * @return {?}
         */
        ChooserDataSource.prototype.showMoreSelected = /**
         *
         * When multiselect this method checks if we need to show SHOW MORE label under the selected
         * items. We do not want show e.g. 50 selection under the chooser that would take up whole
         * page.
         *
         * @return {?}
         */
            function () {
                return this.state.selectedObjects().length >= DataSource.MaxRecentSelected;
            };
        /**
         * @template T
         * @return {?}
         */
        ChooserDataSource.prototype.open = /**
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.dataChanges.asObservable();
            };
        /**
         * @return {?}
         */
        ChooserDataSource.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dataProvider = null;
                this.dataFinder = null;
                this.state = null;
            };
        /**
         * @template T
         * @return {?}
         */
        ChooserDataSource.prototype.instant = /**
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.data();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ChooserDataSource.prototype.updateValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var _this = this;
                this.state.addMode = true;
                if (core$1.isArray(value)) {
                    var /** @type {?} */ items = value;
                    items.forEach(function (item) { return _this.state.updatedSelectedObjects(item); });
                }
                else {
                    this.state.updatedSelectedObjects(value);
                }
                this.state.addMode = false;
            };
        Object.defineProperty(ChooserDataSource.prototype, "lookupKey", {
            get: /**
             * @return {?}
             */ function () {
                return this.dataFinder.lookupKey;
            },
            enumerable: true,
            configurable: true
        });
        return ChooserDataSource;
    }(DataSource));
    /**
     * @param {?} init
     * @return {?}
     */
    function isDSChooserInitParams(init) {
        return core$1.isPresent(init.obj) || core$1.isPresent(init.queryType);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Typeahead chooser that supports both single and multi-select. Not like Dropdown, this chooser
     * requires little bit different setup. It requires at minimum \@Input dataSource or
     * destinationClass
     *
     *
     * By default chooser is multi-select. If you want single select then you must provide multi-select
     * with \@Input.
     *
     * ### Example
     *
     * In simple scenario you can use Chooser like so:
     *
     *
     * ```
     * \@Component({
     *      selector: 'chooser-app' ,
     *      template: `<aw-chooser  [formGroup]="formGroup" name="color"'
     *                      [dataSource]="ds"></aw-chooser>`
     *  })
     *  export class MyChooserApp
     *  {
     *
     *      ds: ChooserDataSource;
     *
     *     constructor(private data: DataProviders, private finders: DataFinders){
     *          this.ds = new ChooserDataSource(this.data, this.finders);
     *
     *       this.ds.init({
     *           obj: ['blue', 'red', 'yellow'], queryType: QueryType.FullText, state: null,
     *            multiselect: true
     *       });
     *
     *     }
     *  }
     *
     * ````
     *  Above example will use provided dataSource and render multi-select chooser. With default
     *  implementation  selected values will appear as a tags under the input box
     *
     *
     *
     * * ### Example
     *
     *  In this example we provide custom template to change the way how chooser's MenuItem are
     *     rendered as well as template for the selection item looks like
     *
     * ```
     * \@Component({
     *      selector: 'chooser-app' ,
     *      template: `<aw-chooser  name="commodity"' [dataSource]="ds">
     *
     *          <ng-template #menuItem let-item>
     *             	<span>
     *             		<i class="fa fa-envira " ></i>
     *             		{{item}}
     *             	</span>
     *
     *          </ng-template>
     *
     *          <ng-template #selectionItem let-item>
     *             	<span class="tag tag-circle">
     *             		item: {{item }}
     *             		<i class="fa fa-close" (click)="chooser.removeValue(item)"></i>
     *             	</span>
     *
     *
     *          </ng-template>
     *
     *
     *          </aw-chooser>
     *      `
     *      style: [`
     *              .tag-circle {
     *              	border-radius: 6rem;
     *              	height: 7rem;
     *              	color: #e8eef1;
     *              	background-color: rgba(53, 56, 58, 0.67);
     *              	line-height: 6rem;
     *              }
     *      `]
     *  })
     *
     * ````
     *
     *  In above example we change how the chooser's menu item look like as well as we define custom
     *     template for selection item to turn all selection to circles with text in the middle.
     *
     *
     *
     */
    var /** @type {?} */ CHOOSER_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ChooserComponent; }),
        multi: true
    };
    var ChooserComponent = (function (_super) {
        __extends(ChooserComponent, _super);
        function ChooserComponent(env, elemementRef, _defaultDS, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.elemementRef = elemementRef;
            _this._defaultDS = _defaultDS;
            _this.parentContainer = parentContainer;
            /**
             * Max number of items return at single Match so we do not return 1000 items at single time.
             *
             */
            _this.maxLength = 10;
            /**
             * Max number of items return at single Match so we do not return 1000 items at single time.
             *
             */
            _this.minLenForSearch = 1;
            /**
             * Is this multiselect
             *
             */
            _this.multiselect = true;
            _this.delay = 300;
            /**
             * Event fired when user select a item
             */
            _this.onSelection = new core.EventEmitter();
            if (core$1.isBlank(_this.placeHolder)) {
                // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
                // this.placeHolder = i18n.instant('Widgets.chooser.placeHolder');
                _this.placeHolder = 'Search';
            }
            // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
            // this.hideLink = i18n.instant('Widgets.chooser.hideSelection');
            _this.hideLink = 'Hide';
            return _this;
        }
        /**
         * @return {?}
         */
        ChooserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.dataSource)) {
                    this.dataSource = this._defaultDS;
                    this.initDatasource();
                }
                if (core$1.isPresent(this.formControl) && core$1.isPresent(this.formControl.value)) {
                    this.dataSource.updateValue(this.formControl.value);
                }
                this.initInternalModel();
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.internalChooserModel);
                }
                else {
                    if (core$1.isPresent(this.name)) {
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
            };
        /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         */
        /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         * @return {?}
         */
        ChooserComponent.prototype.ngAfterViewInit = /**
         * Add Search icon in case of multiselect.
         * todo: Once PrimeNG will provide a template to override default behavior remove it
         *
         * @return {?}
         */
            function () {
                if (!this.dataSource.state.multiselect) {
                    return;
                }
                var /** @type {?} */ searchInput = this.elemementRef.nativeElement.querySelector('.ui-autocomplete-input-token');
                if (core$1.isPresent(searchInput)) {
                    var /** @type {?} */ iconElement = document.createElement('span');
                    iconElement.className = 'search-icon-right fa fa-fw fa-search';
                    searchInput.appendChild(iconElement);
                }
                if (core$1.isPresent(this.selectionAppendTo) && core$1.isPresent(this.selectionViewElem)) {
                    var /** @type {?} */ parentElem = this.selectionAppendTo instanceof core.ElementRef ?
                        this.selectionAppendTo.nativeElement : this.selectionAppendTo;
                    parentElem.appendChild(this.selectionViewElem.nativeElement);
                }
            };
        /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         */
        /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         * @return {?}
         */
        ChooserComponent.prototype.ngAfterViewChecked = /**
         * Need to change current behavior since we want to show selection under the chooser. K
         *
         * @return {?}
         */
            function () {
                if (!this.dataSource.state.multiselect) {
                    return;
                }
                var /** @type {?} */ tokens = this.elemementRef.nativeElement.querySelectorAll('.ui-autocomplete .ui-autocomplete-token');
                if (core$1.isPresent(tokens) && tokens.length > 0) {
                    tokens.forEach(function (item) {
                        item.remove();
                    });
                }
            };
        /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         */
        /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         * @param {?} pattern
         * @return {?}
         */
        ChooserComponent.prototype.match = /**
         *
         * When value is entered into search box, we ask our DataSource to match this pattern
         * against data repository. It will retrieve all possible matches limited by MaxLen and this
         * is again filtered so it does not include already selected items.
         *
         *  the matched resulted is saved in the: this.dataSource.state.matches
         * @param {?} pattern
         * @return {?}
         */
            function (pattern) {
                var /** @type {?} */ maxLen = this.maxLength ? this.maxLength : ChooserDataSource.MaxLength;
                this.dataSource.find(pattern, maxLen);
                // fix: for tests: In version 4 we need to explicitly focus input otherwise autocomplete
                // doesn't give us any popup panel
                if (this.env.inTest && core$1.isPresent(this.autoCompleteComponent)) {
                    this.autoCompleteComponent.focusInput();
                }
            };
        /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         */
        /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         * @param {?} event
         * @return {?}
         */
        ChooserComponent.prototype.onDropdownClick = /**
         *
         * Invoked by Dropdown button in case of single select and here we want to invoke match
         * to retrieve all suggestions without any filter
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.match('*');
                setTimeout(function () {
                    _this.match('*');
                }, 100);
            };
        /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         */
        /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.selectItem = /**
         *
         * Chooser state is updated  with user selection. Please see writeValue. When do not need
         * call anything additional as internalChooserModel and this.chooserState.selectedObjects()
         * shares the same references so its important that we first save reference to
         * this.chooserState.selectedObjects() and then back to internalChooserModel
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.onSelection.emit(this.internalChooserModel);
                this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
                this.formControl.markAsDirty({ onlySelf: true });
                this.dataSource.state.addMode = true;
                this.onModelChanged(this.internalChooserModel);
                this.dataSource.state.updatedSelectedObjects(item);
                this.dataSource.state.addMode = true;
                if (!this.dataSource.state.multiselect) {
                    this.autoCompleteComponent.inputEL.nativeElement.value =
                        this.displayItem(this.internalChooserModel);
                }
            };
        /**
         *
         * Unselect item
         *
         */
        /**
         *
         * Unselect item
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.removeValue = /**
         *
         * Unselect item
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this.dataSource.state.addMode = true;
                this.dataSource.state.updatedSelectedObjects(item);
                this.dataSource.state.addMode = false;
                this.internalChooserModel = this.dataSource.state.selectedObjects();
                this.onSelection.emit(this.internalChooserModel);
                this.formControl.setValue(this.internalChooserModel, { emitEvent: true });
                this.formControl.markAsDirty({ onlySelf: true });
                this.onModelChanged(this.internalChooserModel);
                if (core$1.isPresent(this.autoCompleteComponent)) {
                    this.autoCompleteComponent.focusInput();
                }
            };
        /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         */
        /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         * @param {?} item
         * @return {?}
         */
        ChooserComponent.prototype.displayItem = /**
         *
         * Convert a object if any into the string representation
         *
         * todo: implement better way how to work with objects
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    return null;
                }
                this.dataSource.state.currentItem = item;
                if (core$1.isPresent(this.valueTransformer)) {
                    return this.valueTransformer(item);
                }
                else if (core$1.isPresent(this.dataSource.lookupKey)) {
                    return item[this.dataSource.lookupKey];
                }
                else {
                    return item.toString();
                }
            };
        /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         */
        /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         * @return {?}
         */
        ChooserComponent.prototype.moreSelectString = /**
         *
         * Returns a label that is shown under the selected item when user selection is >
         * MaxRecentSelected
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ moreSelected = this.dataSource.state.selectedObjects().length -
                    this.dataSource.state.recentSelectedDisplayed;
                if (moreSelected < 2 && !this.dataSource.state.showAllRecentlySelected) {
                    return '';
                }
                if (this.dataSource.state.showAllRecentlySelected) {
                    return this.hideLink;
                }
                return moreSelected + " more selected...";
            };
        /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         */
        /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         * @return {?}
         */
        ChooserComponent.prototype.singleValueSelected = /**
         * In case of multiselect = false check if we want to show a selected value inside the input
         * field
         *
         * @return {?}
         */
            function () {
                return !this.dataSource.state && core$1.isPresent(this.dataSource.state.currentItem)
                    && !this.dataSource.state.addMode;
            };
        /**
         * @return {?}
         */
        ChooserComponent.prototype.hasMenuTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.menuTemplate);
            };
        /**
         * @return {?}
         */
        ChooserComponent.prototype.hasSelectionTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.selectionTemplate);
            };
        /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         */
        /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         * @param {?} value
         * @return {?}
         */
        ChooserComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         * As we are using DataSource internally for [(ngModel)] case we need to deffer DataSource
         * initialization once we have a value and we only accept []
         *
         *
         * ? Should we do some deeper comparision?
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (core$1.isBlank(value)) {
                    return;
                }
                if (core$1.isPresent(this.dataSource)) {
                    this.dataSource.updateValue(value);
                }
                else {
                    var /** @type {?} */ selState = new DefaultSelectionState(this.multiselect);
                    var /** @type {?} */ chState = new ChooserState(selState, this.multiselect);
                    this.initDatasource(chState);
                    this.dataSource.updateValue(value);
                }
                this.initInternalModel();
            };
        /**
         * @param {?=} chooserState
         * @return {?}
         */
        ChooserComponent.prototype.initDatasource = /**
         * @param {?=} chooserState
         * @return {?}
         */
            function (chooserState) {
                core$1.assert(core$1.isPresent(this.destinationClass), 'You need to provide destinationClass or custom DataSource');
                this.dataSource.init({
                    obj: this.destinationClass,
                    queryType: QueryType.FullText,
                    lookupKey: this.field,
                    state: chooserState,
                    multiselect: this.multiselect
                });
            };
        /**
         *
         * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
         * ngModel property
         *
         * @return {?}
         */
        ChooserComponent.prototype.initInternalModel = /**
         *
         * Used by ngOnInit and Write value to read state from ChooserState and set it to internal
         * ngModel property
         *
         * @return {?}
         */
            function () {
                if (this.dataSource.state.multiselect) {
                    this.internalChooserModel = this.dataSource.state.selectedObjects();
                }
                else {
                    this.internalChooserModel = this.dataSource.state.selectedObject();
                }
                if (core$1.isPresent(this.formControl)) {
                    this.formControl.setValue(this.internalChooserModel);
                }
            };
        ChooserComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-chooser',
                        template: "<div class=\"w-chooser \">\n\n    <p-autoComplete #autoCompplete [(ngModel)]=\"internalChooserModel\"\n                    [suggestions]=\"dataSource.state.matches\"\n                    [multiple]=\"dataSource.state.multiselect\"\n                    [dropdown]=\"!dataSource.state.multiselect\"\n                    [minLength]=\"minLenForSearch\"\n                    [placeholder]=\"placeHolder\"\n                    [delay]=\"delay\"\n                    [disabled]=\"disabled\"\n                    (onDropdownClick)=\"onDropdownClick($event)\"\n                    (completeMethod)=\"match($event.query)\"\n                    (onSelect)=\"selectItem($event)\"\n                    (onUnselect)=\"removeValue($event)\">\n\n\n        <ng-template let-internalChooserModel pTemplate=\"item\">\n            <ng-template [ngIf]=\"!hasMenuTemplate()\">\n                {{ displayItem(internalChooserModel) }}\n            </ng-template>\n            <ng-template [embeddedItem]=\"menuTemplate\" [item]=\"internalChooserModel\"\n                         *ngIf=\"hasMenuTemplate()\"></ng-template>\n        </ng-template>\n    </p-autoComplete>\n\n    <!--\n        Wrap whole selection with one extra element so we can move it around\n\n         see: selectionAppendTo\n    -->\n    <span #selectionView>\n        <div class=\"w-chooser-selections\"\n             *ngIf=\"multiselect && dataSource.state.recentSelectedObjects.length > 0\">\n\n        <ng-template [ngIf]=\"!hasSelectionTemplate()\">\n\n            <!-- no selection template render it as it is from CORE-->\n            <ul class=\"ui-autocomplete-multiple-container ui-widget ui-state-default \"\n                [ngClass]=\"{'ui-state-disabled':disabled,'ui-state-focus':autoCompleteComponent.focus}\">\n\n                <li #token *ngFor=\"let item of dataSource.state.recentSelectedObjects\"\n                    class=\"ui-autocomplete-token ui-state-highlight ui-corner-all\" tabindex=\"0\"\n                    (keyup.delete)=\"removeValue(item)\"\n                    (keyup.backspace)=\"removeValue(item)\">\n\t\t\t\t\t<span class=\"ui-autocomplete-token-icon sap-icon icon-decline\"\n                          (click)=\"removeValue(item)\"></span>\n                    <span class=\"ui-autocomplete-token-label\">{{ displayItem(item) }}</span>\n                </li>\n            </ul>\n        </ng-template>\n\n            <!--Yes there is selection template let's iterate and push each item to be rendered-->\n        <ng-template ngFor [ngForOf]=\"dataSource.state.recentSelectedObjects\" let-item>\n            <ng-template [embeddedItem]=\"selectionTemplate\" [item]=\"item\"\n                         *ngIf=\"hasSelectionTemplate()\"></ng-template>\n        </ng-template>\n\n        <ng-template [ngIf]=\"dataSource.showMoreSelected()\">\n\t\t\t<span class=\"more-selected\">\n\t\t\t\t<aw-hyperlink [size]=\"'small'\" (action)=\"dataSource.state.toggleAllSelected()\">\n\t\t\t\t\t{{moreSelectString()}}\n\t\t\t\t</aw-hyperlink>\n\t\t\t</span>\n        </ng-template>\n    </div>\n    </span>\n\n\n</div>\n\n",
                        styles: ["/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-input,/deep/ .ui-fluid .ui-autocomplete.ui-autocomplete-dd .ui-autocomplete-multiple-container{width:100%}/deep/ .w-chooser .ui-autocomplete-multiple{line-height:normal}/deep/ .w-chooser .ui-autocomplete-input{width:100%}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button{right:0;position:absolute;border:0;width:30px;background:0 0}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-chooser .ui-autocomplete-dropdown.ui-button input{padding-right:30px}/deep/ .w-chooser .ui-autocomplete-input-token{padding:0;margin:0;vertical-align:baseline;width:inherit}/deep/ .w-chooser .ui-autocomplete-input-token .fa{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.2em}/deep/ .w-chooser .ui-autocomplete-input-token .fa-search:before{content:'\\e00d'}/deep/ .w-chooser .ui-autocomplete-input-token input{width:inherit;padding-right:25px}/deep/ .w-chooser .ui-autocomplete-input-token span{position:absolute;right:5px;top:0;padding-top:.6em}/deep/ .w-chooser .ui-autocomplete-dropdown{height:36px}/deep/ .w-chooser .ui-autocomplete-panel .ui-autocomplete-list-item{padding:.65em 2em .65em .64em;margin:0}/deep/ body .ui-autocomplete.ui-autocomplete-multiple .ui-autocomplete-multiple-container{padding:.4em .5em .4em 1em}.w-chooser-selections{margin-top:2px}.w-chooser-selections ul{margin:0;padding:0}.w-chooser-selections .ui-autocomplete-multiple-container{border:0}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token{font-size:.85em;letter-spacing:.1px;font-weight:400;padding:0;background:#e0f2ff;margin-right:5px;margin-bottom:5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-label{padding:4px 21px 4px 5px}.w-chooser-selections .ui-autocomplete-multiple-container .ui-autocomplete-token-icon{font-size:.78em;padding-right:.28em}.w-chooser-selections .ui-autocomplete-multiple-container .sap-icon{line-height:inherit}.w-chooser-selections .more-selected{display:inline-block}"],
                        providers: [
                            CHOOSER_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return ChooserComponent; }) },
                            { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                        ]
                    },] },
        ];
        /** @nocollapse */
        ChooserComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef },
                { type: ChooserDataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        ChooserComponent.propDecorators = {
            maxLength: [{ type: core.Input }],
            minLenForSearch: [{ type: core.Input }],
            valueTransformer: [{ type: core.Input }],
            multiselect: [{ type: core.Input }],
            dataSource: [{ type: core.Input }],
            selectionAppendTo: [{ type: core.Input }],
            delay: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            field: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            menuTemplate: [{ type: core.ContentChild, args: ['menuItem',] }],
            selectionTemplate: [{ type: core.ContentChild, args: ['selectionItem',] }],
            autoCompleteComponent: [{ type: core.ViewChild, args: ['autoCompplete',] }],
            selectionViewElem: [{ type: core.ViewChild, args: ['selectionView',] }]
        };
        return ChooserComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWChooserModule = (function () {
        function AWChooserModule() {
        }
        AWChooserModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ChooserComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.AutoCompleteModule,
                            AWHyperlinkModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            ChooserComponent
                        ],
                        exports: [
                            ChooserComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWChooserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * A popup like component rendering list of values as. Based on PrimeNG component and one of the
     * main reason why we need to wrap this is to extend its capabilities to accept almost any
     * data type without using Primens's specific SelectItem type.
     *
     *
     * ### Example
     *
     * ```
     * \@Component({
     *      selector: 'showDropDown' ,
     *      template: '<aw-dropdown [list]="testItemSmall"
     *     (onSelection)="onSelection($event)"></aw-dropdown>'
     *  })
     *  export class MyDropComponent
     *  {
     *      testItemSmall: string[] = ['view' , 'edit'];
     *
     *      // when you switch list binding to refert to large item fiilter automatically is shown and
     *     max 10 items are
     *      // visible
     *      testItemLarge: string[] = ['view' , 'edit' , 'frank' , 'kolar' , 'The Sun' , 'Dog' ,
     *     'Computer' , 'A Desk' ,
     *      'My Car' , 'Pencil' , 'This Page' , 'Yesterday' , 'Monday' , 'Tuesday' , 'BMW R1200 GS' ,
     *     'Czech Republic' ,
     *      'Last Item'];
     *
     *
     *      itemSelected: string = 'view';
     *      itemSelectedLg: string = 'Monday';
     *
     *      noselString: string = '(no selection)';
     *
     *
     *      onSelection (event): void
     *      {
     *          this.itemSelected = event;
     *
     *      }
     *  }
     *
     *  ```
     *
     */
    var /** @type {?} */ DD_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return DropdownComponent; }),
        multi: true
    };
    var DropdownComponent = (function (_super) {
        __extends(DropdownComponent, _super);
        function DropdownComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Event fired when user select a item
             */
            _this.onSelection = new core.EventEmitter();
            return _this;
        }
        /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         */
        /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         * @return {?}
         */
        DropdownComponent.prototype.ngOnInit = /**
         * Todo: Put back the scrolling option once we decide so. Currently the requirements are
         * show only 10 items max, no scrolling. Functionality commented out can show scrollbar with
         * search filter.
         * @return {?}
         */
            function () {
                if (this.isStandalone) {
                    _super.prototype.ngOnInit.call(this);
                    _super.prototype.registerFormControl.call(this, this.selection);
                }
                else {
                    if (core$1.isPresent(this.name)) {
                        this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                    }
                }
                // transform a value to PrimeNg Format, we are not really be using a label field only a
                // value.
                this.internalList = [];
                // if (isPresent(this.noSelectionString)) {
                //     this.internalList.push({
                //         label: this.noSelectionString,
                //         value: null
                //     });
                //
                //     if (isBlank(this.selection)) {
                //         this.selection = this.noSelectionString;
                //     }
                // }
                if (core$1.isPresent(this.list) && this.list.length >= DropdownComponent.MaxNumShown) {
                    this.internalList = this.list.slice(0, DropdownComponent.MaxNumShown).map(function (item) {
                        return { label: item.toString(), value: item };
                    });
                }
                else if (core$1.isPresent(this.list)) {
                    this.internalList = this.list.slice(0).map(function (item) {
                        return { label: item.toString(), value: item };
                    });
                }
            };
        /**
         * @return {?}
         */
        DropdownComponent.prototype.hasEmbeddedTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.itemTemplate);
            };
        /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         */
        /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         * @param {?} item
         * @return {?}
         */
        DropdownComponent.prototype.itemExist = /**
         * Check to prevent Empty item to be rendered
         *
         * todo: Report this on PrimeNg
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(item);
            };
        /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         */
        /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         * @return {?}
         */
        DropdownComponent.prototype.showFilter = /**
         * When dropdown list is more then defined constant MaxNumShown (10) automatically show filter
         * input field
         * @return {?}
         */
            function () {
                return false;
                // return isPresent(this.list) && this.list.length > DropdownComponent.MaxNumShown;
            };
        /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         */
        /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         * @param {?} value
         * @return {?}
         */
        DropdownComponent.prototype.onItemSelection = /**
         *
         * Updates internal models of current selections and triggers onSelection event
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selection = value.value;
                this.onSelection.emit(value.value);
                if (this.isStandalone) {
                    this.formControl.setValue(this.selection);
                    this.formControl.markAsDirty({ onlySelf: true });
                }
                this.onModelChanged(value.value);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DropdownComponent.prototype.displayItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(item) ? item.label : 'No Selection';
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        DropdownComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!core$1.equals(value, this.selection)) {
                    this.selection = value;
                    this.formControl.setValue(value);
                }
            };
        DropdownComponent.MaxNumShown = 10;
        DropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dropdown',
                        template: "<div class=\"w-dropdown\" [formGroup]=\"formGroup\">\n\n    <ng-template [ngIf]=\"isStandalone\">\n        <p-dropdown [options]=\"internalList\"\n                    [formControlName]=\"name\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n\n                </ng-template>\n            </ng-template>\n\n\n        </p-dropdown>\n    </ng-template>\n</div>\n\n\n<!-- no formControl Name here. ngModel cannot have formGroup around -->\n<ng-template [ngIf]=\"!isStandalone\">\n    <div class=\"w-dropdown\">\n        <p-dropdown [options]=\"internalList\"\n                    [(ngModel)]=\"selection\"\n                    [placeholder]=\"noSelectionString\"\n                    [autoWidth]=\"false\"\n                    [filter]=\"showFilter()\"\n                    (onChange)=\"onItemSelection($event)\">\n\n            <ng-template let-item pTemplate=\"item\">\n\n                <ng-template [ngIf]=\"!hasEmbeddedTemplate() && itemExist(item)\">\n                    {{item.label }}\n                </ng-template>\n                <ng-template [embeddedItem]=\"itemTemplate\" [item]=\"item\"\n                             *ngIf=\"hasEmbeddedTemplate() && itemExist(item)\">\n                </ng-template>\n            </ng-template>\n        </p-dropdown>\n    </div>\n</ng-template>\n",
                        styles: ["/deep/ .ui-dropdown-panel .ui-dropdown-items-wrapper{max-height:none!important}/deep/ .ui-dropdown-panel .ui-dropdown-item{padding:.65em 2em .65em .64em;margin:0}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container{width:100%}/deep/ .ui-dropdown-panel .ui-dropdown-filter-container .fa{top:1.2em}/deep/ .ui-dropdown-panel .ui-dropdown-list{padding:1em 0}/deep/ .w-dropdown:not(.ng-dirty) label{color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger.ui-corner-right{border-left:none;color:#969696}/deep/ .w-dropdown .ui-dropdown-trigger .pi{font-family:\"SAP icon fonts\";color:#767676;cursor:pointer;font-size:1.4em;margin-left:-.85em}/deep/ .w-dropdown .ui-dropdown-trigger .pi-caret-down:before{content:'\\e1ef'}/deep/ .w-dropdown .ui-dropdown-label{padding-right:2.4em}"],
                        providers: [
                            DD_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return DropdownComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        DropdownComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        DropdownComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            noSelectionString: [{ type: core.Input }],
            onSelection: [{ type: core.Output }],
            itemTemplate: [{ type: core.ContentChild, args: ['itemTemplate',] }]
        };
        return DropdownComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDropdownModule = (function () {
        function AWDropdownModule() {
        }
        AWDropdownModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DropdownComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.DropdownModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            DropdownComponent
                        ],
                        exports: [
                            DropdownComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWDropdownModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Lightweight and configurable Currency component based on the ng bootstrap directive. This
     * component combines an input and currency code dropdown.
     *
     *
     * for more info please see class Doc of the:
     * @see {\@link currency/currency.component.ts}
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'amount' ,
     *    template: `
     *
     *      <aw-currency [money]="price" [currencies]="currencies" [name]="'currency'">
     *      </aw-currency>
     *
     *    `
     *    })
     *    export class MyComponent
     *    {
     *        amount: number = 1000;
     *        currencies: string[] = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
     *        currencyCode: string = this.currencies[0];
     *
     *        constructor ()
     *        {
     *        }
     *    }
     */
    var /** @type {?} */ CURRENCY_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CurrencyComponent; }),
        multi: true
    };
    var CurrencyComponent = (function (_super) {
        __extends(CurrencyComponent, _super);
        function CurrencyComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Disable user to change Money's currency code and still
             * allow user to edit Money's amount.
             */
            _this.readonlyCurrencyCode = false;
            // Initialize currencies.
            // Initialize currencies.
            _this.initCurrencies();
            _this.currencyPipe = new common.CurrencyPipe(env.locale);
            env.onLocaleChange.subscribe(function (locale) {
                _this.currencyPipe = new common.CurrencyPipe(locale);
                if (core$1.isPresent(_this.money)) {
                    _this.displayValue = _this.formatCurrency(_this.money.amount);
                }
            });
            return _this;
        }
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.money);
                this.initCurrencies();
                if (core$1.isBlank(this.currencySelection)) {
                    this.currencySelection = this._currencies[0];
                }
                // ready the money field if it exists. and override the existing values.
                if (this.money) {
                    this.currencySelection = this.money.currency;
                }
                else {
                    this.money = new Money(null, this.currencySelection);
                }
                this.displayValue = this.formatCurrency(this.money.amount);
            };
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.initCurrencies = /**
         * @return {?}
         */
            function () {
                if (!this._currencies || this._currencies.length === 0) {
                    this._currencies = ['USD', 'CNY', 'AUD', 'EUR', 'GBP'];
                }
            };
        /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param el
         */
        /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param {?} el
         * @return {?}
         */
        CurrencyComponent.prototype.onFocus = /**
         * Display the real value when the user clicks in the currency widget. Then he can modify the
         * value without seeing the formatting.
         *
         * @param {?} el
         * @return {?}
         */
            function (el) {
                if (core$1.isPresent(this.money) && core$1.isPresent(this.money.amount)) {
                    this.displayValue = this.money.amount.toString();
                }
            };
        /**
         * display the formatted currency value when the user navigates away.
         * @param el
         */
        /**
         * display the formatted currency value when the user navigates away.
         * @param {?} el
         * @return {?}
         */
        CurrencyComponent.prototype.onBlur = /**
         * display the formatted currency value when the user navigates away.
         * @param {?} el
         * @return {?}
         */
            function (el) {
                this.money = this.money.clone({ amount: Number(el.value) });
                this.displayValue = this.formatCurrency(this.money.amount);
                this.onModelChanged(this.money);
            };
        /**
         * @param {?} currency
         * @return {?}
         */
        CurrencyComponent.prototype.onSelection = /**
         * @param {?} currency
         * @return {?}
         */
            function (currency) {
                this.currencySelection = currency;
                this.displayValue = this.formatCurrency(this.money.amount);
            };
        /**
         * Function will check to see if currency is a valid number before formatting.
         * @param {?} val
         * @return {?}
         */
        CurrencyComponent.prototype.formatCurrency = /**
         * Function will check to see if currency is a valid number before formatting.
         * @param {?} val
         * @return {?}
         */
            function (val) {
                if (!val || val.length === 0) {
                    return val;
                }
                if (isNaN(val)) {
                    return val;
                }
                var /** @type {?} */ code = 'USD';
                if (this.currencySelection) {
                    code = this.currencySelection;
                }
                this.money = this.money.clone({ currency: this.currencySelection });
                // By default, the precision is 2. For example, 10.23 USD.
                var /** @type {?} */ digits = '1.0-2';
                // If precision is present, use it for format the money value for display.
                if (core$1.isPresent(this.precision)) {
                    digits = '1.0-' + this.precision;
                }
                return this.currencyPipe.transform(val, code, 'symbol', digits);
            };
        /**
         * @return {?}
         */
        CurrencyComponent.prototype.getMoneyCurrency = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.displayValue) && this.displayValue.length > 0) {
                    return this.currencySelection;
                }
                return '';
            };
        Object.defineProperty(CurrencyComponent.prototype, "currencies", {
            get: /**
             * @return {?}
             */ function () {
                return this._currencies;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (core$1.isPresent(value)) {
                    this._currencies = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        CurrencyComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if ((value instanceof Money) && !core$1.equals(value, this.money)) {
                    this.money = value;
                    if (core$1.isPresent(this.money.currency)) {
                        this.currencySelection = this.money.currency;
                    }
                    this.displayValue = this.formatCurrency(this.money.amount);
                    this.formControl.setValue(this.money);
                }
            };
        CurrencyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-currency',
                        template: "<ng-template [ngIf]=\"editable\">\n    <div class=\"w-currency-field ui-fluid\" [formGroup]=\"formGroup\">\n        <div class=\"ui-g \">\n            <div class=\"ui-g-8 ui-g-nopad \">\n                <input #currencyInput\n                       pInputText\n                       type=\"text\" class=\"w-text-field currency-format\"\n                       [attr.name]=\"name\"\n                       [attr.placeholder]=\"placeHolder\"\n                       [value]=\"displayValue\"\n                       (focus)=\"onFocus(currencyInput)\"\n                       (blur)=\"onBlur(currencyInput)\"\n                       [disabled]=\"disabled\">\n            </div>\n            <div class=\"ui-g-4 ui-g-nopad w-cc-field\">\n                <aw-dropdown *ngIf=\"!readonlyCurrencyCode\"\n                             [isStandalone]=\"false\" [list]=\"currencies\"\n                             [selection]=\"money.currency\"\n                             (onSelection)=\"onSelection($event)\"\n                             [disabled]=\"disabled\">\n\n                </aw-dropdown>\n                <div *ngIf=\"readonlyCurrencyCode\" class=\"w-cc-readonly-field\">{{money.currency}}</div>\n            </div>\n        </div>\n    </div>\n</ng-template>\n\n<!-- currency:'USD':true -->\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{displayValue}} {{ getMoneyCurrency() }}\"></aw-string>\n</ng-template>\n",
                        styles: [".w-currency-field [readonly],.w-currency-type-field [readonly]{background-color:#fff}.w-currency-field input,.w-currency-type-field input{min-width:80px}.w-currency-field i.fa,.w-currency-type-field i.fa{cursor:pointer}.w-currency-field{margin-top:0}.w-currency-field /deep/ .ui-dropdown{min-width:80px}.w-cc-field{display:flex;align-items:center}.w-cc-readonly-field{padding-left:5px;color:#969696}.no-gutter>[class*=ui-g-]{padding-right:0;padding-left:0}"],
                        providers: [
                            CURRENCY_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return CurrencyComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        CurrencyComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        CurrencyComponent.propDecorators = {
            money: [{ type: core.Input }],
            readonlyCurrencyCode: [{ type: core.Input }],
            currencySelection: [{ type: core.Input }],
            precision: [{ type: core.Input }],
            currencies: [{ type: core.Input }]
        };
        return CurrencyComponent;
    }(BaseFormComponent));
    /**
     * Money object is represented as a value, locale, and currencyCode
     */
    var /**
     * Money object is represented as a value, locale, and currencyCode
     */ Money = (function () {
        function Money(amount, currency, locale) {
            if (amount === void 0) {
                amount = 0;
            }
            if (currency === void 0) {
                currency = 'USD';
            }
            if (locale === void 0) {
                locale = 'en_US';
            }
            this.amount = amount;
            this.currency = currency;
            this.locale = locale;
        }
        /**
         * @return {?}
         */
        Money.prototype.getTypes = /**
         * @return {?}
         */
            function () {
                return {
                    amount: Number,
                    currency: String,
                    locale: String
                };
            };
        /**
         * @return {?}
         */
        Money.prototype.className = /**
         * @return {?}
         */
            function () {
                return 'Money';
            };
        /**
         * @return {?}
         */
        Money.prototype.$proto = /**
         * @return {?}
         */
            function () {
                return new Money(1, '23', '33');
            };
        /**
         * @return {?}
         */
        Money.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.amount + ', locale: ' + this.locale + ', code:  ' + this.currency;
            };
        /**
         * @param {?=} data
         * @return {?}
         */
        Money.prototype.clone = /**
         * @param {?=} data
         * @return {?}
         */
            function (data) {
                if (data === void 0) {
                    data = {};
                }
                return new Money(core$1.isPresent(data.amount) ? data.amount : this.amount, core$1.isPresent(data.currency) ? data.currency : this.currency, core$1.isPresent(data.locale) ? data.locale : this.locale);
            };
        return Money;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWCurrencyModule = (function () {
        function AWCurrencyModule() {
        }
        AWCurrencyModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            CurrencyComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.InputTextModule,
                            primeng.DropdownModule,
                            AWDropdownModule,
                            AWStringFieldModule,
                            AWCoreComponentModule
                        ],
                        entryComponents: [
                            CurrencyComponent
                        ],
                        exports: [
                            CurrencyComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: [common.CurrencyPipe]
                    },] },
        ];
        return AWCurrencyModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Lightweight and configurable Date and Time component based on the primeng. This
     * component combines both date picker as well as time picker
     *
     *
     *  ### Example
     *  ```
     *
     * \@Component({
     *    selector: 'myTimer' ,
     *    template: `
     *    <aw-date-time [value]="date" [editable]="editable"  [name]="'dueDate'">
     *    </aw-date-time>
     *
     *    `
     *    })
     *    export class MyTimmerComponet
     *    {
     *
     *        date: Date = new Date();
     *
     *
     *        constructor ()
     *        {
     *            this.date.setFullYear(2016 , 10 , 3);
     *            this.date.setHours(10 , 10 , 10);
     *        }
     *    }
     *
     * ```
     *
     * By default you will see date field and time field is hidden to show both you just do following:
     *
     *  ```
     *
     * \@Component({
     *    selector: 'myTimer' ,
     *    template: `
     *
     *    <aw-date-time [value]="date"  [showTime]="showTime" [editable]="editable"  [name]="'bbdd'">
     *    </aw-date-time>
     *
     *    `
     *    })
     *    export class MyTimmerComponet
     *    {
     *        date: Date = new Date();
     *        showTime = true;
     *
     *        constructor ()
     *        {
     *            this.date.setFullYear(2016 , 10 , 3);
     *            this.date.setHours(10 , 10 , 10);
     *        }
     *    }
     *
     * ```
     *
     *
     *
     */
    var /** @type {?} */ DATETIME_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return DateAndTimeComponent; }),
        multi: true
    };
    var DateAndTimeComponent = (function (_super) {
        __extends(DateAndTimeComponent, _super);
        function DateAndTimeComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Default date format pattern used if none is passed
             *
             */
            _this.formatPattern = 'mm/dd/yy';
            /**
             * Special workaround as formatters in the primeNG and angular are different so until its
             * fixed we need to keep this extra pattern.
             */
            _this.formatPatternNG = 'MM/dd/yy';
            /**
             * Shows and hides navigation bar with year and months selections
             */
            _this.showNavigation = false;
            /**
             * Shows and hides navigation bar with year and months selections
             */
            _this.showIcon = true;
            /**
             * Whether to show timepicker
             */
            _this.showTime = false;
            /**
             * Whether to show DatePicker. Even we can hide it. it should be for most of the case always
             * true
             */
            _this.showDate = true;
            /**
             *
             * Tells the date picker what format it should use when presenting time. When hourFormat is 12,
             * it shows the AM, PM
             *
             */
            _this.hourFormat = '24';
            /**
             * Triggers event when specific date is clicked inside DatePicker
             *
             */
            _this.onChange = new core.EventEmitter();
            /**
             * Set the date to highlight on first opening if the field is blank.
             *
             */
            _this.defaultDate = new Date();
            _this.timePlaceHolder = 'hh:ss';
            return _this;
        }
        /**
         * @return {?}
         */
        DateAndTimeComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                // default to dateTime pattern which is defined in resource files
                if (this.hourFormat !== '12' && this.hourFormat !== '24') {
                    this.hourFormat = '24';
                }
                this.timePlaceHolder = (this.hourFormat === '12') ?
                    " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
                this.initTranslations();
                this.env.onLocaleChange.subscribe(function (locale) {
                    _this.initTranslations();
                });
            };
        /**
         * Need to refactor this as this really get complicated trying to cover usecase with time
         * and date and every format we have. We should probably have separate patterns for
         * dates only and date + time
         * @return {?}
         */
        DateAndTimeComponent.prototype.initTranslations = /**
         * Need to refactor this as this really get complicated trying to cover usecase with time
         * and date and every format we have. We should probably have separate patterns for
         * dates only and date + time
         * @return {?}
         */
            function () {
                this.formatNameWithTime = this.formatPattern;
                if (!this.showDate) {
                    this.formatPatternNG = this.formatPattern += (this.hourFormat === '12') ?
                        " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                }
                if (this.showTime) {
                    var /** @type {?} */ timeStarts = this.formatPattern.indexOf('h');
                    if (timeStarts !== -1) {
                        this.formatNameWithTime = this.formatPattern.substring(0, timeStarts);
                    }
                    this.formatPatternNG += (this.hourFormat === '12') ?
                        " " + DateAndTimeComponent.NgTime12 : " " + DateAndTimeComponent.NgTime24;
                }
                this.i18n = {
                    firstDayOfWeek: 0,
                    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday',
                        'Saturday'],
                    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                    dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August',
                        'September', 'October', 'November', 'December'],
                    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct',
                        'Nov', 'Dec']
                };
            };
        /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         */
        /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         * @param {?} event
         * @return {?}
         */
        DateAndTimeComponent.prototype.onDateChange = /**
         * Fired when dates changes. Here we update  this.value - > date and also update value inside
         * formController
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isBlank(event)) {
                    // throw some error ?
                    return;
                }
                this.value = core$1.isDate(event) ? event : new Date(event);
                this.formControl.setValue(this.value, { onlySelf: false, emitEvent: true });
                this.onModelChanged(this.value);
                this.onChange.emit(this.value);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        DateAndTimeComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value);
                }
            };
        DateAndTimeComponent.NgTime12 = 'hh:mm a';
        DateAndTimeComponent.NgTime24 = 'HH.mm a';
        DateAndTimeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-date-time',
                        template: "<ng-template [ngIf]=\"editable\">\n\n    <div class=\"w-datetime \" [class.has-time]=\"showTime\" [formGroup]=\"formGroup\">\n\n        <p-calendar formControlName=\"{{name}}\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    dateFormat=\"{{showTime ? formatNameWithTime : formatPattern}}\"\n                    [yearNavigator]=\"showNavigation\"\n                    [monthNavigator]=\"showNavigation\"\n                    [yearRange]=\"yearRange\"\n                    placeholder=\"{{showTime ? formatNameWithTime.toUpperCase() : formatPattern.toUpperCase()}}\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [timeOnly]=\"!showDate\"\n                    [readonlyInput]=\"true\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n        <p-calendar *ngIf=\"showTime\"\n                    icon=\"icon-history\"\n                    formControlName=\"{{name}}\"\n                    [hourFormat]=\"hourFormat\"\n                    [defaultDate]=\"defaultDate\"\n                    [showIcon]=\"showIcon\"\n                    [timeOnly]=\"showTime\"\n                    [showTime]=\"showTime\"\n                    [placeholder]=\"timePlaceHolder\"\n                    (onSelect)=\"onDateChange($event)\"\n                    [locale]=\"i18n\">\n        </p-calendar>\n\n    </div>\n</ng-template>\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string value=\"{{value | date: formatPatternNG}}\"></aw-string>\n</ng-template>\n",
                        styles: ["/deep/ .w-datetime .ui-calendar button{border:0;width:0}/deep/ .w-datetime .ui-calendar.ui-calendar-w-btn .ui-inputtext{width:100%}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left{font-family:\"SAP icon fonts\";color:#199de0;cursor:pointer;font-size:1.4em}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.pi-calendar:before{content:'\\e0e0'}/deep/ .ui-calendar .ui-calendar-button .ui-button-icon-left.icon-history:before{content:'\\e02d'}/deep/ .ui-datepicker{width:24.28em;line-height:25px;padding:0;border-color:#979797;box-shadow:none}/deep/ .ui-datepicker .ui-datepicker-header{padding:.92em 0;font-weight:400;color:#000;font-size:1em}/deep/ .ui-datepicker .ui-datepicker-next,/deep/ .ui-datepicker .ui-datepicker-prev{top:1em}/deep/ .ui-datepicker .ui-datepicker-prev{left:.2em}/deep/ .ui-datepicker .ui-datepicker-next{right:.2em}/deep/ .ui-datepicker table{font-size:1em;margin:0 0 1.5em}/deep/ .ui-datepicker th{font-weight:400;background-color:#ececec;color:#363636;padding:.786em 1.07em}/deep/ .ui-datepicker td{padding:.1em}/deep/ .ui-datepicker td a{text-align:center;width:2.7em;height:2.7em;line-height:2.7em;padding:0;border-radius:50%}/deep/ .ui-datepicker td a.ui-state-default{border-color:transparent}/deep/ .ui-datepicker td a.ui-state-active{background-color:#199de0;color:#fff}/deep/ .ui-datepicker .pi{font-size:1em}/deep/ .ui-datepicker .pi.pi-chevron-left:before{content:'\\e1ee'}/deep/ .ui-datepicker .pi.pi-chevron-right:before{content:'\\e1ed'}/deep/ .ui-datepicker .ui-datepicker-calendar td:not(.ui-state-disabled) a:hover{border-color:transparent;background-color:rgba(25,157,224,.7);opacity:.75;color:#363636}/deep/ .ui-datepicker-timeonly{width:100%}/deep/ .ui-timepicker{font-size:1.14em;color:#767676;font-weight:400}/deep/ .ui-timepicker .pi{font-size:1em}/deep/ .ui-timepicker .pi.pi-chevron-up:before{content:'\\e1f0'}/deep/ .ui-timepicker .pi.pi-chevron-down:before{content:'\\e1ef'}/deep/ .ui-timepicker>div{margin-left:0}/deep/ .ui-timepicker .ui-separator{width:.1em;min-width:.1em}/deep/ .ui-timepicker .ui-separator .pi{font-size:0}/deep/ .ui-datepicker-trigger{background-color:transparent}/deep/ .ui-datepicker-trigger.ui-button:enabled:hover,/deep/ .ui-datepicker-trigger.ui-button:focus{background-color:transparent}/deep/ .has-time{display:flex;flex-wrap:nowrap}/deep/ .has-time p-calendar:first-child{width:55%;margin-right:14px}/deep/ .has-time p-calendar:last-child{width:45%}/deep/ .has-time p-calendar:last-child .ui-datepicker{padding:0}/deep/ .has-time .ui-button-icon-left{line-height:18px}"],
                        providers: [
                            DATETIME_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return DateAndTimeComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        DateAndTimeComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        DateAndTimeComponent.propDecorators = {
            value: [{ type: core.Input }],
            formatPattern: [{ type: core.Input }],
            formatPatternNG: [{ type: core.Input }],
            showNavigation: [{ type: core.Input }],
            yearRange: [{ type: core.Input }],
            showIcon: [{ type: core.Input }],
            showTime: [{ type: core.Input }],
            showDate: [{ type: core.Input }],
            hourFormat: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return DateAndTimeComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDateAndTimeModule = (function () {
        function AWDateAndTimeModule() {
        }
        AWDateAndTimeModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DateAndTimeComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.CalendarModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            DateAndTimeComponent
                        ],
                        exports: [
                            DateAndTimeComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ]
                    },] },
        ];
        return AWDateAndTimeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An dialog header area.
     *
     * See {\@link DialogComponent} for more explanation.
     */
    var DialogHeaderComponent = (function () {
        function DialogHeaderComponent() {
        }
        DialogHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog-header',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return DialogHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An dialog header area.
     *
     * See {\@link DialogComponent} for more explanation.
     */
    var DialogFooterComponent = (function () {
        function DialogFooterComponent() {
        }
        DialogFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog-footer',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return DialogFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Dialog Component that provides the look and feel for a modal dialog. This component has three
     * sections: header, body, and footer. It can be used by itself or extended.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<DialogComponent>), service.close()
     *
     * Usage:
     *    1.  Using Dialog directly to display a modal popup. This usage is a quick way to show a
     * message to the user.
     *
     *             this.modalService.open<DialogComponent>( DialogComponent, {
     *                     title: 'My Popup Title',
     *                     body: 'My Popup Body'
     *              });
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                              <aw-dialog [(visible)]="display" [modal]="true"
     *                                        (onOpen)="openAction()" (onClose)="closeAction()">
     *
     *                                    <aw-dialog-header>Dialog Header</aw-dialog-header>
     *
     *                                     Dialog Body: Creating a dialog using the dialog component
     *
     *                                    <aw-dialog-footer>
     *                                      <aw-button [size]="'small'" [style]="'primary'"
     *                                                 (click)="close()">OK</aw-button>
     *                                    </aw-dialog-footer>
     *                              </aw-dialog>
     *
     *                          <aw-button [size]="'small'" (click)="open()">Open Dialog</aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     display: boolean = false;
     *
     *                     dialogAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     open() {
     *                        this.display = true;
     *                     }
     *
     *                     openAction()  {
     *                        this.dialogAction = "open";
     *                      }
     *       }
     *
     *
     */
    var DialogComponent = (function (_super) {
        __extends(DialogComponent, _super);
        function DialogComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * support two way data binding on visible property.
             */
            _this.visibleChange = new core.EventEmitter();
            /**
             * whether this dialog blocks the rest of the page or not when displayed.
             */
            _this.modal = true;
            /**
             * Whether there's an x at the top right that makes the dialog closable.
             */
            _this.closable = true;
            /**
             * Event fired when dialog is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the dialog is opened.
             */
            _this.onOpen = new core.EventEmitter();
            _this.width = 300;
            _this.height = 'auto';
            return _this;
        }
        /**
         * Open this dialog.
         */
        /**
         * Open this dialog.
         * @return {?}
         */
        DialogComponent.prototype.open = /**
         * Open this dialog.
         * @return {?}
         */
            function () {
                this.visible = true;
                this.onOpen.emit();
                // visible is a 2-way binding variable.
                this.visibleChange.emit(true);
            };
        /**
         * close the dialog
         */
        /**
         * close the dialog
         * @return {?}
         */
        DialogComponent.prototype.close = /**
         * close the dialog
         * @return {?}
         */
            function () {
                this.visible = false;
                this.onClose.emit();
                // Important to make sure change is set on parent binding.
                // Otherwise, the variable and dialog open/close state can be out
                // of sync and we wouldn't trigger change detection.
                this.visibleChange.emit(false);
            };
        /**
         * Does this dialog have header.
         *
         */
        /**
         * Does this dialog have header.
         *
         * @return {?}
         */
        DialogComponent.prototype.hasHeader = /**
         * Does this dialog have header.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.header);
            };
        /**
         * Does this dialog have footer.
         *
         */
        /**
         * Does this dialog have footer.
         *
         * @return {?}
         */
        DialogComponent.prototype.hasFooter = /**
         * Does this dialog have footer.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.footer);
            };
        DialogComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dialog',
                        template: "<p-dialog [header]=\"title\" [(visible)]=\"visible\"\n          [modal]=\"modal\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n          [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onShow)=\"open()\" (onHide)=\"close()\">\n\n    <p-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-dialog-header\"></ng-content>\n    </p-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n    <p-footer *ngIf=\"hasFooter()\">\n        <div class=\"dialog-footer-separator\"></div>\n        <ng-content select=\"aw-dialog-footer\"></ng-content>\n    </p-footer>\n</p-dialog>\n",
                        styles: ["::ng-deep .ui-dialog .ui-dialog-titlebar{background-color:#f2f2f2;padding:15px 20px}::ng-deep .ui-dialog .ui-dialog-titlebar .ui-dialog-titlebar-icon:hover{border-color:transparent}::ng-deep .ui-widget-header{font-weight:400;font-size:16px}::ng-deep .ui-dialog .ui-dialog-content{padding:15px 20px;line-height:1.3em}::ng-deep .ui-dialog .ui-widget-content{border:none}::ng-deep .ui-dialog.ui-widget-content{border:none;box-shadow:0 2px 10px 0 rgba(0,0,0,.3)}::ng-deep .ui-dialog .dialog-footer-separator{border-top:1px solid #d7d7d7;height:14px}::ng-deep .ui-dialog .ui-dialog-footer{padding:0 20px 15px}"]
                    },] },
        ];
        /** @nocollapse */
        DialogComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        DialogComponent.propDecorators = {
            title: [{ type: core.Input }],
            body: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            modal: [{ type: core.Input }],
            closable: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [DialogHeaderComponent,] }],
            footer: [{ type: core.ContentChild, args: [DialogFooterComponent,] }]
        };
        return DialogComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDialogModule = (function () {
        function AWDialogModule() {
        }
        AWDialogModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            primeng.DialogModule
                        ],
                        entryComponents: [
                            ModalComponent,
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent
                        ],
                        exports: [
                            DialogComponent,
                            DialogHeaderComponent,
                            DialogFooterComponent,
                            AWCoreComponentModule
                        ],
                        providers: []
                    },] },
        ];
        return AWDialogModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Convenient wrapper class around controls such as radiobuttons, dropdown, checkboxes,
     * Chooser. The type of the chooser may be determined dynamically based on the number of items in
     * the data source list, or can be specified explicitly via the "type" binding.
     *
     *
     *
     */
    var GenericChooserComponent = (function (_super) {
        __extends(GenericChooserComponent, _super);
        function GenericChooserComponent(env, _viewContainer, dataSource, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this._viewContainer = _viewContainer;
            _this.dataSource = dataSource;
            _this.parentContainer = parentContainer;
            /**
             *  Is this a List property, or a to-one.
             */
            _this.multiselect = false;
            return _this;
        }
        /**
         * @return {?}
         */
        GenericChooserComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.object)) {
                    this.object = ((this._viewContainer.injector)).view.context;
                }
                this.keyPath = new core$1.FieldPath(this.key);
                var /** @type {?} */ defaultDataProvider = null;
                if (core$1.isPresent(this.list)) {
                    defaultDataProvider = this.dataSource.dataProviders.find(this.list);
                }
                else {
                    defaultDataProvider = this.dataSource.dataProviders.find(this.destinationClass);
                }
                var /** @type {?} */ projectedSize = defaultDataProvider.expectedCount(this.choiceProviderParams);
                this.initType(projectedSize);
                if (this.type === 'Chooser') {
                    this.dataSource.init({
                        dataProvider: defaultDataProvider,
                        queryType: QueryType.FullText,
                        lookupKey: this.displayKey,
                        state: new ChooserState(new GCChooserState(this), this.multiselect),
                        multiselect: this.multiselect
                    });
                }
                else {
                    // do we need to read this value in async?
                    this.list = defaultDataProvider.data();
                }
                _super.prototype.registerFormControl.call(this, this.selection);
                this.validateRequired();
                if (core$1.isBlank(this.selection)) {
                    // this.noSelectionString = this.i18n.instant('Widgets.gchooser.noSelString');
                    this.noSelectionString = 'Select a Item';
                }
            };
        /**
         *
         * When \@Input type is not passed we try to guess and select the best type for current data
         *
         * @param {?} projectedSize
         * @return {?}
         */
        GenericChooserComponent.prototype.initType = /**
         *
         * When \@Input type is not passed we try to guess and select the best type for current data
         *
         * @param {?} projectedSize
         * @return {?}
         */
            function (projectedSize) {
                if (core$1.isBlank(this.type)) {
                    if (this.multiselect) {
                        this.type = (projectedSize <= 0 || projectedSize > 8) ? 'Chooser' : 'Checkbox';
                    }
                    else {
                        this.type = (projectedSize <= 0 || projectedSize > 20) ? 'Chooser'
                            : (projectedSize < 6) ? 'Radio' :
                                'Dropdown';
                    }
                }
            };
        /**
         * There are certain properties which are required by this component. As already mentioned
         * above GenericChooser works with references and thefore two key properties are object and key
         * so we can access an object
         *
         *
         * @return {?}
         */
        GenericChooserComponent.prototype.validateRequired = /**
         * There are certain properties which are required by this component. As already mentioned
         * above GenericChooser works with references and thefore two key properties are object and key
         * so we can access an object
         *
         *
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.object)) {
                    throw Error('Cannot continue without a object');
                }
                if (core$1.isBlank(this.key)) {
                    throw Error('Cannot continue without a key binding');
                }
                if (core$1.isBlank(this.list) && core$1.isBlank(this.destinationClass)) {
                    throw Error('Cannot continue without having either list of values or destinationClass');
                }
                if (core$1.isPresent(this.type) &&
                    (this.type !== 'Radio' && this.type !== 'Checkbox' && this.type !== 'Dropdown' &&
                        this.type !== 'Chooser')) {
                    throw Error('Cannot instantiate GenericChooser  - invalid type');
                }
                if (core$1.isBlank(this.displayKey)) {
                    this.displayKey = 'toString';
                }
            };
        /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         */
        /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         * @param {?} item
         * @return {?}
         */
        GenericChooserComponent.prototype.displayValue = /**
         *
         * Used when displaying value both from primitive type as well complex object. If you want to
         * control how item is displayed you can provide display key, which is can be a  method or
         * property of the object you are displaying.
         *
         * Todo: think about formatters as well
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.displayKey)) {
                    return item;
                }
                var /** @type {?} */ fieldValue = core$1.FieldPath.getFieldValue(item, this.displayKey);
                if (core$1.isFunction(fieldValue)) {
                    return fieldValue.call(item);
                }
                return fieldValue;
            };
        Object.defineProperty(GenericChooserComponent.prototype, "selection", {
            /**
             *  Retrieve a current value from the parent/target object
             *
             */
            get: /**
             *  Retrieve a current value from the parent/target object
             *
             * @return {?}
             */ function () {
                return this.keyPath.getFieldValue(this.object);
            },
            /**
             *  set value back to the object
             *
             */
            set: /**
             *  set value back to the object
             *
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.keyPath.setFieldValue(this.object, value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} value
         * @return {?}
         */
        GenericChooserComponent.prototype.onSelection = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.selection = value;
                this.formControl.setValue(this.selection);
                this.formControl.markAsDirty();
            };
        GenericChooserComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-generic-chooser',
                        template: "<ng-container [ngSwitch]=\"type\">\n\n    <ng-template [ngSwitchCase]=\"'Checkbox'\">\n        <aw-checkbox-list [list]=\"list\"\n                          [editable]=\"editable\"\n                          [selections]=\"selection\"\n                          [name]=\"name\"\n                          [disabled]=\"disabled\"\n                          [labelFormatter]=\"displayValue\"\n                          (onSelection)=\"onSelection($event)\">\n        </aw-checkbox-list>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Radio'\">\n        <aw-radiobutton-list [list]=\"list\"\n                             [selection]=\"selection\"\n                             [editable]=\"editable\"\n                             [name]=\"name\"\n                             [disabled]=\"disabled\"\n                             [labelFormatter]=\"displayValue\"\n                             (onSelection)=\"onSelection($event)\">\n        </aw-radiobutton-list>\n    </ng-template>\n\n    <ng-template [ngSwitchCase]=\"'Dropdown'\">\n        <aw-dropdown [list]=\"list\"\n                     [isStandalone]=\"false\"\n                     [editable]=\"editable\"\n                     [noSelectionString]=\"noSelectionString\"\n                     [selection]=\"selection\"\n                     [disabled]=\"disabled\"\n                     [name]=\"name\"\n                     (onSelection)=\"onSelection($event)\">\n            <ng-template #itemTemplate let-item>\n\n                <!-- todo: allow to pass a PIPE to do some additional formatting -->\n                {{ displayValue(item.value) }}\n            </ng-template>\n        </aw-dropdown>\n    </ng-template>\n\n\n    <ng-template [ngSwitchCase]=\"'Chooser'\">\n        <aw-chooser #chooser\n                    [editable]=\"editable\"\n                    [isStandalone]=\"false\"\n                    [name]=\"name\"\n                    [multiselect]=\"multiselect\"\n                    [dataSource]=\"dataSource\"\n                    [valueTransformer]=\"displayValue\"\n                    [disabled]=\"disabled\">\n\n        </aw-chooser>\n\n    </ng-template>\n\n</ng-container>\n",
                        styles: [""],
                        providers: [
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return GenericChooserComponent; }) },
                            { provide: DATA_SOURCE, useClass: ChooserDataSource, deps: [DataProviders, DataFinders] }
                        ]
                    },] },
        ];
        /** @nocollapse */
        GenericChooserComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ViewContainerRef },
                { type: ChooserDataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        GenericChooserComponent.propDecorators = {
            list: [{ type: core.Input }],
            object: [{ type: core.Input }],
            key: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            choiceProviderParams: [{ type: core.Input }],
            multiselect: [{ type: core.Input }],
            type: [{ type: core.Input }],
            displayKey: [{ type: core.Input }],
            noSelectionString: [{ type: core.Input }]
        };
        return GenericChooserComponent;
    }(BaseFormComponent));
    /**
     * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
     *
     */
    var /**
     * GenericChooser implementation of the ChooserSelectionState which is used when Type = Chooser.
     *
     */ GCChooserState = (function (_super) {
        __extends(GCChooserState, _super);
        function GCChooserState(gChooser) {
            var _this = _super.call(this) || this;
            _this.gChooser = gChooser;
            return _this;
        }
        /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
        GCChooserState.prototype.setSelectionState = /**
         * @param {?} selection
         * @param {?} selected
         * @return {?}
         */
            function (selection, selected) {
                if (selected === this.isSelected(selection)) {
                    return;
                }
                if (this.gChooser.multiselect) {
                    // Check if we can implement smarter and more generic way how we use it in java
                    // RelationshipField.addTo(_object, _keyPath, selection);
                    var /** @type {?} */ multiRel = this.gChooser.keyPath.getFieldValue(this.gChooser.object);
                    if (core$1.isBlank(multiRel)) {
                        multiRel = [];
                    }
                    else if (core$1.isPresent(multiRel) && !core$1.isArray(multiRel)) {
                        throw new Error('I can not store multiselect value into non-array object');
                    }
                    if (selected) {
                        multiRel.push(selection);
                        this.gChooser.selection = multiRel;
                    }
                    else {
                        core$1.ListWrapper.removeIfExist(multiRel, selection);
                    }
                }
                else {
                    if (!selection) {
                        selection = null;
                    }
                    this.gChooser.selection = selection;
                }
            };
        /**
         * @return {?}
         */
        GCChooserState.prototype.selectedObject = /**
         * @return {?}
         */
            function () {
                if (this.gChooser.multiselect) {
                    var /** @type {?} */ objects = this.selectedObjects();
                    return (core$1.isBlank(objects) || core$1.ListWrapper.isEmpty(objects)) ? null : core$1.ListWrapper.last(objects);
                }
                return this.gChooser.selection;
            };
        /**
         * @return {?}
         */
        GCChooserState.prototype.selectedObjects = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ selection = this.gChooser.selection;
                if (this.gChooser.multiselect && core$1.isBlank(selection)) {
                    selection = [];
                }
                return (this.gChooser.multiselect && core$1.isArray(selection)) ? selection : [selection];
            };
        /**
         * @param {?} selection
         * @return {?}
         */
        GCChooserState.prototype.isSelected = /**
         * @param {?} selection
         * @return {?}
         */
            function (selection) {
                if (this.gChooser.multiselect) {
                    return core$1.ListWrapper.containsComplex(this.selectedObjects(), selection);
                }
                var /** @type {?} */ curValue = this.selectedObject();
                return core$1.equals(curValue, selection);
            };
        return GCChooserState;
    }(ChooserSelectionState));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Wrapper class for RadioButton component providing convenient way to to render RadioButton Groups
     *
     *
     * ### Example
     *
     *
     * ```
     * \@Component({
     *          selector: 'gender-selector' ,
     *          template: `
     *              <aw-radiobutton-list [list]="rbListValues" [layout]="layout"
     *     [selection]="selectedValue" [name]="'name'">
     *               </aw-radiobutton-list>
     *      `
     *      })
     *      export class GenderSelectorComponent
     *      {
     *          rbListValues: string[] = ['male' , 'female' , 'other'];
     *          selectedValue: string = 'other';
     *          layout: string = 'stacked';
     *
     *
     *          formGroup: FormGroup = new FormGroup({});
     *
     *
     *          onCBClick (event): void
     *          {
     *              console.log('onCBClick = ' + event);
     *          }
     *
     *      }
     *
     * ```
     */
    var /** @type {?} */ RB_LIST_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonListComponent; }),
        multi: true
    };
    var RadioButtonListComponent = (function (_super) {
        __extends(RadioButtonListComponent, _super);
        function RadioButtonListComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * Fires an event when radio button is selected
             *
             */
            _this.onSelection = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        RadioButtonListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.selection)) {
                    this.model = 0;
                }
                this.updateModel(this.selection);
                this.onModelChanged(this.selection);
                this.registerFormControl(this.selection);
            };
        /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         */
        /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         * @param {?} item
         * @return {?}
         */
        RadioButtonListComponent.prototype.labelValue = /**
         * Label is extracted into a method so in the future we can play how we want to display the
         * value. Since I want to support formatters for each components we might have a chance to
         * decide how the label will look like.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.labelFormatter)) {
                    return this.labelFormatter(item);
                }
                return item.toString();
            };
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         */
        /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         * @param {?} item
         * @return {?}
         */
        RadioButtonListComponent.prototype.value = /**
         * In this version of checkboxes we still expect only primitive types. Keep this functionality
         * in extra method so we can work with it even now we just return the same value back
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item;
            };
        /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         */
        /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         * @param {?} event
         * @return {?}
         */
        RadioButtonListComponent.prototype.onChange = /**
         *
         * On NGModel change retrieve actual record based on the INDEX and propagate it to both
         * ngModel as well as FormGroup.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ updatedModel = this.list[this.model];
                this.onSelection.emit(updatedModel);
                this.onModelChanged(updatedModel);
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
            };
        /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         */
        /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         * @param {?} souceItem
         * @return {?}
         */
        RadioButtonListComponent.prototype.updateModel = /**
         * Since we might be dealing with complex object store only INDEX number in the model.
         *
         * @param {?} souceItem
         * @return {?}
         */
            function (souceItem) {
                var /** @type {?} */ index = this.list.findIndex(function (elem) {
                    return souceItem === elem;
                });
                this.model = index === -1 ? 0 : index;
            };
        /**
         * @return {?}
         */
        RadioButtonListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ updatedModel = this.list[this.model];
                this.formControl.setValue(updatedModel, {
                    emitEvent: true,
                    emitViewToModelChange: false
                });
                // this.cd.detectChanges();
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        RadioButtonListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    var /** @type {?} */ newModel = value;
                    this.updateModel(newModel);
                }
            };
        RadioButtonListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-radiobutton-list',
                        template: "<div *ngFor=\"let item of list;  let i = index\" class=\"ui-g\">\n\n    <div class=\"ui-g-12\">\n        <aw-radiobutton\n            [(ngModel)]=\"model\"\n            (ngModelChange)=\"onChange($event)\"\n            [isStandalone]=\"false\"\n            [name]=\"name\"\n            [value]=\"i\"\n            [label]=\"labelValue(item)\">\n        </aw-radiobutton>\n    </div>\n\n</div>\n",
                        styles: [""],
                        providers: [
                            RB_LIST_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RadioButtonListComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RadioButtonListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            labelFormatter: [{ type: core.Input }],
            onSelection: [{ type: core.Output }]
        };
        return RadioButtonListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Implements standard HTML radio button on top of PrimeNG with ariba styling
     *
     * ### Example
     *
     * 1. Basic usage using ngModel pre-selected first radio
     *
     *  ```ts
     *
     * \@Component({
     *          selector: 'demo-comp',
     *          template: `
     *              <aw-radiobutton [name]="'color'" [value]="'red'" [label]="'Red'"
     *                             [(ngModel)]="model">
     *             </aw-radiobutton>
     *              <aw-radiobutton [name]="'color'" [value]="'blue'" [label]="'Blue'"
     *                      [(ngModel)]="model">
     *              </aw-radiobutton>
     *      `
     *      })*
     *      class BasicWithNgModelComponent
     *      {
     *          model: string[] = ['red'];
     *
     *          constructor()
     *          {
     *          }
     *      }
     *
     *  ```
     *
     *
     * 2. Basic usage with formGroup
     *
     *
     * ```ts
     * \@Component({
     *           selector: 'demo-comp',
     *           template: `
     *          <div [formGroup]="env.currentForm">
     *               <aw-radiobutton [name]="'color2'" [value]="'red'" [label]="'Red'"
     *               (onChange)="onChange($event)">
     *               </aw-radiobutton>
     *               <aw-radiobutton [name]="'color2'" [value]="'blue'" [label]="'Blue'"
     *               (onChange)="onChange($event)">
     *               </aw-radiobutton>
     *
     *       </div>
     *       `
     *       })
     *       class BasicWithFormGroupComponent implements OnInit
     *       {
     *           model: string = 'blue';
     *
     *           constructor(public env: Environment)
     *           {
     *           }
     *
     *           ngOnInit(): void
     *           {
     *               this.env.currentForm = new FormGroup({});
     *               this.env.currentForm.registerControl('color2', new FormControl(this.model));
     *           }
     *
     *
     *           onChange(event: any): void
     *           {
     *               this.modelSet = event;
     *           }
     *
     *       }
     *  ````
     *
     *
     *
     *
     */
    var /** @type {?} */ RAB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var RadioButtonComponent = (function (_super) {
        __extends(RadioButtonComponent, _super);
        function RadioButtonComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value associated with this radio
             *
             */
            _this.value = '';
            /**
             * Trigger click event with currrent selected value
             *
             */
            _this.onChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.value);
                    this.model = this.formControl.value;
                    this.onModelChanged(this.model);
                }
                else {
                    this.formControl = /** @type {?} */ (this.formGroup.controls[this.name]);
                }
            };
        /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         */
        /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         * @param {?} newVal
         * @return {?}
         */
        RadioButtonComponent.prototype.onModelChange = /**
         * Called when radio is clicked. Not using PrimeNG click event as it is fired before
         * the model is changed. Therefore need to listen on (ngModelChange)
         *
         * @param {?} newVal
         * @return {?}
         */
            function (newVal) {
                this.onModelChanged(this.model);
                if (this.isStandalone) {
                    this.formControl.setValue(this.model, { emitEvent: true });
                }
                this.onChange.emit(this.model);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.model) {
                    this.model = value;
                    if (this.isStandalone) {
                        this.formControl.setValue(this.model, { emitEvent: true });
                    }
                    this.onModelChanged(this.model);
                }
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-radiobutton',
                        template: "<span class=\"w-radiobutton\">\n\n    <ng-template [ngIf]=\"editable \">\n        <p-radioButton [name]=\"name\"\n                       [value]=\"value\"\n                       [label]=\"label\"\n                       [(ngModel)]=\"model\"\n                       [disabled]=\"disabled\"\n                       (ngModelChange)=\"onModelChange($event)\"\n                       [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\">\n        </p-radioButton>\n    </ng-template>\n</span>\n",
                        styles: ["/deep/ .w-radiobutton .ui-radiobutton-box{width:23px;height:23px;line-height:23px}/deep/ .w-radiobutton .ui-radiobutton-icon{font-size:1.5em;line-height:1em}"],
                        providers: [
                            RAB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RadioButtonComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        RadioButtonComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RadioButtonComponent.propDecorators = {
            value: [{ type: core.Input }],
            label: [{ type: core.Input }],
            onChange: [{ type: core.Output }]
        };
        return RadioButtonComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWRadioButtonModule = (function () {
        function AWRadioButtonModule() {
        }
        AWRadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RadioButtonComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.RadioButtonModule
                        ],
                        entryComponents: [
                            RadioButtonComponent
                        ],
                        exports: [
                            RadioButtonComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWRadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWRadioButtonListModule = (function () {
        function AWRadioButtonListModule() {
        }
        AWRadioButtonListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RadioButtonListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWRadioButtonModule
                        ],
                        entryComponents: [
                            RadioButtonListComponent
                        ],
                        exports: [
                            RadioButtonListComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWRadioButtonListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWGenericChooserModule = (function () {
        function AWGenericChooserModule() {
        }
        AWGenericChooserModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            GenericChooserComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule,
                            AWDropdownModule,
                            AWCheckBoxListModule,
                            AWChooserModule,
                            AWRadioButtonListModule
                        ],
                        entryComponents: [
                            GenericChooserComponent
                        ],
                        exports: [
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            GenericChooserComponent
                        ]
                    },] },
        ];
        return AWGenericChooserModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * OutlineState is the key gluing part for the OutlineFor and OutlineController components. It
     * holds all important information for the current outline tree and manages expansion states in form
     * of so called expansionPath and expansionStates
     *
     * We need to have a way how to work with generic data structure in order not to hold UI specific
     * information on the domain object model just like we had it before, where we had an interface
     * called OutlineNode, with fields (expanded, selected, etc.. )
     *
     *
     * `expansionPath`: Holds an array of currently selected and expanded nodes. This is filled by
     * OutlineController.
     *
     *
     * If we are dealing with Entity or anything that has identity then we have easier situation as we
     * can ask for ID and it is more efficient for serialization
     */
    var OutlineState = (function () {
        function OutlineState() {
            /**
             *
             * When outline is rendered for first time or re-rendered and we set default value for the
             * expansionStates. This way we can pretty easily execute CollapseAll, ExpandAll
             *
             */
            this.globalState = false;
            /**
             *
             * Holds current level during tree node rendering so we can apply correct indentation
             *
             */
            this.currentLevel = -1;
            this.expansionStates = new Map();
        }
        /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         */
        /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         * @return {?}
         */
        OutlineState.prototype.collapseAll = /**
         * For the collapseAll and expandAll we are using simple mechanism where we clean up all
         * selection and then set the global expand state, this whey isExpand method returns the same
         * state for all items
         * @return {?}
         */
            function () {
                this.expansionStates.clear();
                this.globalState = false;
            };
        /**
         * @return {?}
         */
        OutlineState.prototype.expandAll = /**
         * @return {?}
         */
            function () {
                this.expansionStates.clear();
                this.globalState = true;
            };
        Object.defineProperty(OutlineState.prototype, "expansionPath", {
            get: /**
             * @return {?}
             */ function () {
                if (core$1.isBlank(this._expansionPath)) {
                    this._expansionPath = [];
                }
                return this._expansionPath;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                this._expansionPath = value;
                if (core$1.isBlank(this._expansionPath)) {
                    return;
                }
                this._expansionPath.forEach(function (item) {
                    _this.setExpansionState(item, true);
                });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} currentPath
         * @param {?=} chidren
         * @return {?}
         */
        OutlineState.prototype.toggleExpansion = /**
         * @param {?} currentPath
         * @param {?=} chidren
         * @return {?}
         */
            function (currentPath, chidren) {
                var _this = this;
                if (core$1.isBlank(currentPath)) {
                    return;
                }
                var /** @type {?} */ item = core$1.ListWrapper.last(currentPath);
                var /** @type {?} */ itemChildren = chidren || [];
                var /** @type {?} */ newState = !this.isExpanded(item);
                this.setExpansionState(item, newState);
                if (!newState) {
                    core$1.ListWrapper.removeLast(currentPath);
                    itemChildren.forEach(function (child) {
                        _this.setExpansionState(child, newState);
                    });
                }
                this.setExpansionPath(currentPath);
            };
        /**
         * @param {?} item
         * @param {?} isExpanded
         * @return {?}
         */
        OutlineState.prototype.setExpansionState = /**
         * @param {?} item
         * @param {?} isExpanded
         * @return {?}
         */
            function (item, isExpanded) {
                var /** @type {?} */ key = this.itemToKey(item);
                if (isExpanded === this.globalState) {
                    this.expansionStates.delete(key);
                }
                else {
                    this.expansionStates.set(key, (isExpanded) ? true : false);
                }
            };
        /**
         * To improve state persisting lets check if we are dealing with an Object that has Identity
         * so we can extract an ID otherwise use object to compare by reference
         *
         *
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.itemToKey = /**
         * To improve state persisting lets check if we are dealing with an Object that has Identity
         * so we can extract an ID otherwise use object to compare by reference
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isEntity(item) ? ((item)).identity() : item;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.setExpansionPath = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                this.expansionPath = item;
                item.forEach(function (node) {
                    _this.setExpansionState(node, true);
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineState.prototype.isExpanded = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ key = this.itemToKey(item);
                if (!this.expansionStates.has(key)) {
                    return this.globalState;
                }
                return this.expansionStates.get(key);
            };
        OutlineState.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        OutlineState.ctorParameters = function () { return []; };
        return OutlineState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * OutlineForComponent is like ngFor, but for hierarchical (outline/tree) structures -- i.e. in
     * those cases where an item may have children.
     *
     *
     * It uses outline `<aw-outline-control>` to provide expanding functionality, indentation
     * and other things.
     *
     *
     * This component has minimal styling to make sure it can be changed easily.
     *
     * ### Example rendering tree section, where based on the type we format the out plus
     * for the main root section we always render little popup menu.
     *
     * ```
     *
     *   <aw-outline-for [list]="list" [hasChildren]="hasChildren">
     *
     *       <ng-template #outline let-item>
     *
     *           <div class="my-section">
     *               <div class="outline">
     *                   <aw-outline-control>
     *                       <ng-container [ngSwitch]="item.type">
     *                           <ng-template [ngSwitchCase]="'text'">
     *                               <div class="as-paragraf">
     *                                   {{item?.content}}
     *                               </div>
     *                           </ng-template>
     *
     *
     *                           <ng-template ngSwitchDefault>
     *                               {{item?.content}}
     *                           </ng-template>
     *
     *
     *                       </ng-container>
     *
     *
     *                   </aw-outline-control>
     *               </div>
     *
     *               <div class="filters" *ngIf="item.type === 'section'" >
     *
     *                   <aw-hover-card [linkTitle]="'Filter Items'">
     *                       <aw-list [list]="filterItems" [borderless]="true"></aw-list>
     *                   </aw-hover-card>
     *
     *               </div>
     *           </div>
     *     </ng-template>`
     *   </aw-outline-for>
     *
     * ```
     *
     *
     * We can use it also in embedded mode where we use the `awOutlineFor` directive
     *
     * ## Example
     *
     *
     * ````
     *  <table  class="tree-table" >
     *      <thead>
     *          <tr>
     *              <th>Name</th>
     *              <th>Type</th>
     *          </tr>
     *      </thead>
     *      <tbody #ooo2 awOutlineFor [list]="list"
     *             [hasChildren]="hasChildren"
     *             class="outline-table"
     *      >
     *          <ng-template #outline let-item>
     *              <tr>
     *                  <td class="item-name outline-animation">
     *                      <div><aw-outline-control>
     *                          {{item?.content}}
     *                      </aw-outline-control></div>
     *                  </td>
     *                  <td class="item-type outline-animation">
     *                      <div>{{item.type}}</div>
     *                  </td>
     *              </tr>
     *          </ng-template>
     *      </tbody>
     *  </table>
     *
     * ```
     *
     * I was thinking maybe for first time we don't need the same animation like expanding and
     * collapsing. Maybe we need fade-in. In such case I would probably apply \@section anim only
     * on items where level > 0 (in the template I keep levels) and if level == 0 then I would
     * execute the same rendering just without [\@section]
     *
     *
     * Todo: Think about how to do animation for the table case. Must also write unitest - due to
     * AribaLive aggressive schedule we are skipping them for now
     *
     */
    var OutlineForComponent = (function (_super) {
        __extends(OutlineForComponent, _super);
        function OutlineForComponent(env, _viewContainer, builder, element) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this._viewContainer = _viewContainer;
            _this.builder = builder;
            _this.element = element;
            /**
             * Tells the component not to render expansion control, in such case we expandAll as a
             * default behavior
             *
             */
            _this.showExpansionControl = true;
            /**
             * Opens all tree nodes.
             *
             */
            _this.expandAll = false;
            /**
             *
             * Set indentation size to be used for each level
             *
             */
            _this.indentationPerLevel = 25;
            _this.pushRootSectionOnNewLine = false;
            /**
             *
             * Used when in selection mode to push current selected Item to the application
             *
             */
            _this.onItemSelected = new core.EventEmitter();
            /**
             *
             * This event is triggered by OutlineControl when node is expanded or collapsed
             *
             */
            _this.onExpandChange = new core.EventEmitter();
            _this.embedded = false;
            /**
             * Flag that tells us that component is fully rendered
             *
             */
            _this.viewInitialized = false;
            return _this;
        }
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isBlank(this.state)) {
                    this.state = new OutlineState();
                }
                if (core$1.isBlank(this.state.outlineFor)) {
                    this.state.outlineFor = this;
                }
                if (this.expandAll) {
                    this.showExpansionControl = false;
                }
                this.state.globalState = this.expandAll;
                // in case we want to render content of tree outside of outlineFor
                if (core$1.isPresent(this.externalTemplate)) {
                    this.controlTemplate = this.externalTemplate;
                }
                this.embedded = this.element.nativeElement.hasAttribute('awoutlinefor');
                if (core$1.isBlank(this.context)) {
                    this.context = this;
                }
                // // when root section needs to be on new line, then automatically expand second level
                // if (this.pushRootSectionOnNewLine) {
                //     this.list.forEach((item: any) => {
                //         let currentItem = ListWrapper.last(this.state.currentPath);
                //         this.state.toggleExpansion(item);
                //     })
                // }
            };
        /**
         * @return {?}
         */
        OutlineForComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngDoCheck.call(this);
            };
        /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         */
        /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         * @param {?} item
         * @param {?=} currentLevel
         * @return {?}
         */
        OutlineForComponent.prototype.isExpanded = /**
         * Used by template and OutlineControl to identify which item is expanded and collapsed
         *
         * @param {?} item
         * @param {?=} currentLevel
         * @return {?}
         */
            function (item, currentLevel) {
                if (currentLevel === void 0) {
                    currentLevel = -1;
                }
                return (currentLevel === 0 && this.pushRootSectionOnNewLine)
                    ? true : this.state.isExpanded(item);
            };
        /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         */
        /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.childrenForItem = /**
         *
         * Since we have currently two ways how to pass children items we need have this method to
         * unify the way how we access it. If we pass `children` binding we use this instead, otherwise
         * we expect current object to have `children` field
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.hasChildren(item) ? this.doGetChildren(item) : [];
            };
        /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         */
        /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.hasChildren = /**
         *
         * Check if the current item has a children and needs to be rendered
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.children) && core$1.isBlank(item.children)) {
                    core$1.assert(false, 'Missing [children] method binding');
                }
                return this.doGetChildren(item).length > 0;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.doGetChildren = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.children.apply(this.context, [item]);
            };
        /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         */
        /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         * @return {?}
         */
        OutlineForComponent.prototype.toggleExpansion = /**
         *  Uses the `OutlineState` to toggle state of current selectionPath. The `selectionPath` is
         *  put together inside `OutlineControl` where we iterate all the way to the root and add
         *  each item to the `currentPath` array. This way we collect list of item representing current
         *  current expansionPath.
         *
         *
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.animationInProgress) {
                    // backup procedure in case onAnimationDone fails
                    setTimeout(function () {
                        if (_this.animationInProgress) {
                            // change only if its fails
                            _this.animationInProgress = false;
                        }
                    }, 200);
                    return;
                }
                if (!this.embedded) {
                    this.animationInProgress = true;
                }
                var /** @type {?} */ currentItem = core$1.ListWrapper.last(this.state.currentPath);
                this.state.toggleExpansion(this.state.currentPath, this.childrenForItem(currentItem));
                if (this.embedded) ;
            };
        /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         */
        /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         * @param {?} event
         * @return {?}
         */
        OutlineForComponent.prototype.onAnimationDone = /**
         * Angular anim. callback that sets back the flag to make sure we don't trigger animations
         * when one is in progress.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.animationInProgress = false;
            };
        /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         */
        /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         * @param {?} currentLevel
         * @return {?}
         */
        OutlineForComponent.prototype.indentation = /**
         * Calculated indentation used to shift the nested section to the right or later on to the
         * left when RTL is supported
         *
         *
         * @param {?} currentLevel
         * @return {?}
         */
            function (currentLevel) {
                if (this.pushRootSectionOnNewLine && currentLevel > 0) {
                    currentLevel -= 1;
                }
                return (currentLevel === 0 && this.pushRootSectionOnNewLine)
                    ? 0 : (this.indentationPerLevel * currentLevel);
            };
        /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         */
        /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         * @param {?} item
         * @return {?}
         */
        OutlineForComponent.prototype.isVisible = /**
         * Not all rows are visible by default, there can be a case where you dont want to render items
         * using outline. e.g. Datatable with detail row.
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.filterOut)) {
                    return !this.filterOut(item);
                }
                return true;
            };
        OutlineForComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-outline-for, [awOutlineFor]',
                        template: "<!--\n    Starts with the list, where nestingLevel is -1.\n    call template outlineItems to iterate and render each item\n-->\n<ng-container [ngIf]=\"list\" *ngTemplateOutlet=\"outlineItems;\n            context:{ $implicit: list, nestingLevel: 0, parentItem: null, expanded: true}\">\n</ng-container>\n\n<!--\n    Main Entry point for the recursion. this is called by the block above as well as byt the inner\n    piece that calls this template recursively again when an item has children\n-->\n<ng-template #outlineItems let-children let-nestingLevel=\"nestingLevel\"\n             let-parent=\"parentItem\" let-expanded=\"expanded\">\n\n    <ng-template ngFor let-item [ngForOf]=\"children\"  let-rowIndex=\"index\">\n\n        <ng-container *ngTemplateOutlet=\"outlineItem;\n            context:{ $implicit: item, nestingLevel: nestingLevel, parentItem: parent,\n            expanded: expanded, rowIndex:rowIndex}\">\n        </ng-container>\n\n        <!--\n\n            Recursion piece:\n\n            For non embedded case when even if its not expanded we need to iterate children\n            as we want to apply animation that should go with ngIf which inside the outineItem\n            template\n\n            Dont recurse/ render items that are not visible.\n        -->\n\n        <ng-template [ngIf]=\"hasChildren(item) && (isExpanded(item, nestingLevel) || !embedded) && isVisible(item)\">\n            <ng-container *ngTemplateOutlet=\"outlineItems;\n                        context:{ $implicit: childrenForItem(item),\n                                nestingLevel: nestingLevel+1,\n                                expanded: isExpanded(item, nestingLevel),\n                                parentItem:item }\">\n            </ng-container>\n        </ng-template>\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Renders actual outline node and applies animation while expanding and collapsing\n\n    [@section]=\"expanded || isExpanded(item) ? 'visible' : 'hidden'\"\n-->\n<ng-template #outlineItem let-item let-nestingLevel=\"nestingLevel\" let-parent=\"parentItem\"\n             let-rowIndex=\"rowIndex\"\n             let-expanded=\"expanded\">\n\n    <div class=\"w-outline-item\"\n         *ngIf=\"!embedded && expanded\"\n         [style.padding-left.px]=\"indentation(nestingLevel)\"\n         initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n         [setCurrrentItem]=\"item\"\n         [@section]\n         (@section.done)=\"onAnimationDone($event)\">\n\n        <ng-container *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex }\">\n        </ng-container>\n    </div>\n\n    <!--\n        When outline control is used as embedded meaning its inside e..g datatable we\n        cannot have any tags around it.\n\n        Todo: Refactor this in the way so we can do animation when table lines are\n        expanded. Since its embedded we can not have any wrapping element around, the template\n        is fully responsible\n    -->\n    <ng-template [ngIf]=\"embedded && expanded\"\n                 initNesting [setLevel]=\"nestingLevel\" [setParentItem]=\"parent\"\n                 [setCurrrentItem]=\"item\"\n    >\n        <ng-container #renderedItem *ngTemplateOutlet=\"controlTemplate;\n                        context:{ $implicit: item, nestingLevel: nestingLevel, rowIndex:rowIndex  }\">\n        </ng-container>\n    </ng-template>\n\n</ng-template>\n\n\n",
                        styles: [".is-outline-animation>div,::ng-deep .w-outline-item{overflow:hidden}"],
                        animations: [
                            animations.trigger('section', [
                                animations.state('*', animations.style({
                                    'overflow-y': 'hidden',
                                    'height': '*',
                                    'opacity': '1'
                                })),
                                animations.state('void', animations.style({
                                    'height': '0',
                                    'opacity': '0',
                                    'overflow-y': 'hidden'
                                })),
                                animations.transition('* => void', animations.animate('200ms ease-out')),
                                animations.transition('void => *', animations.animate('200ms ease-in'))
                            ]),
                        ]
                    },] },
        ];
        /** @nocollapse */
        OutlineForComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ViewContainerRef },
                { type: animations.AnimationBuilder },
                { type: core.ElementRef }
            ];
        };
        OutlineForComponent.propDecorators = {
            list: [{ type: core.Input }],
            showExpansionControl: [{ type: core.Input }],
            children: [{ type: core.Input }],
            filterOut: [{ type: core.Input }],
            expandAll: [{ type: core.Input }],
            state: [{ type: core.Input }],
            indentationPerLevel: [{ type: core.Input }],
            externalTemplate: [{ type: core.Input }],
            context: [{ type: core.Input }],
            pushRootSectionOnNewLine: [{ type: core.Input }],
            onItemSelected: [{ type: core.Output }],
            onExpandChange: [{ type: core.Output }],
            controlTemplate: [{ type: core.ContentChild, args: ['outline',] }],
            outlineItem: [{ type: core.ViewChild, args: ['renderedItem',] }]
        };
        return OutlineForComponent;
    }(BaseComponent));
    /**
     *
     * Since we can not directly set `*ngTemplateOutlet` context variables to the typescript class we
     * use this directive to do the Job
     *
     */
    var InitNestingDirective = (function () {
        function InitNestingDirective(outline) {
            this.outline = outline;
        }
        /**
         * @return {?}
         */
        InitNestingDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.setLevel)) {
                    this.outline.state.currentLevel = this.setLevel;
                }
                if (core$1.isPresent(this.setCurrrentItem)) {
                    this.outline.currentItem = this.setCurrrentItem;
                }
                if (core$1.isPresent(this.setParentItem)) {
                    this.outline.currentItem['$$parentItem'] = this.setParentItem;
                }
            };
        InitNestingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[initNesting]'
                    },] },
        ];
        /** @nocollapse */
        InitNestingDirective.ctorParameters = function () {
            return [
                { type: OutlineForComponent }
            ];
        };
        InitNestingDirective.propDecorators = {
            setLevel: [{ type: core.Input }],
            setCurrrentItem: [{ type: core.Input }],
            setParentItem: [{ type: core.Input }]
        };
        return InitNestingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * OutlineControlComponent renders the indentation, arrow, and text for a node in an outline.
     * It should be used either in the body of an OutlineFor component, or inside datatable
     *
     *
     * ##Usage inside body:
     *
     *  Here you can see that we need to wrap out content inside ng-template which will push us
     *  give us current item item and then we can place OutlineControlComponent to control
     *  the tree.
     *
     * ```
     *  <aw-outline-for2 #ooo [list]="list" [hasChildren]="hasChildren">
     *
     *      <ng-template #outline let-item>
     *          <div class="my-section">
     *              <div class="outline">
     *                  <aw-outline-control>
     *                      {{item?.content}}
     *                  </aw-outline-control>
     *              </div>*
     *          </div>
     *      </ng-template>
     *  </aw-outline-for2>
     *
     *
     * ```
     *
     * We can
     *
     *
     */
    var OutlineControlComponent = (function (_super) {
        __extends(OutlineControlComponent, _super);
        function OutlineControlComponent(env, outlineState, parentControl, outlineFor) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.outlineState = outlineState;
            _this.parentControl = parentControl;
            _this.outlineFor = outlineFor;
            /**
             *
             *  If TRUE it changes the behavior of the outline node text which click is triggered
             *  it selects the item and broadcast the `onItemSelected` event
             *
             */
            _this.allowSelection = false;
            /**
             *
             * Triggers action when outline item is expanded
             *
             */
            _this.action = new core.EventEmitter();
            _this.isRootItem = false;
            return _this;
        }
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.prepareControl();
            };
        /**
         *
         * We dont show expansion icons when there no children
         *
         */
        /**
         *
         * We dont show expansion icons when there no children
         *
         * @return {?}
         */
        OutlineControlComponent.prototype.hasExpansionControl = /**
         *
         * We dont show expansion icons when there no children
         *
         * @return {?}
         */
            function () {
                return this.outlineFor.hasChildren(this.item) && this.outlineFor.showExpansionControl;
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.isSelected = /**
         * @return {?}
         */
            function () {
                return this.outlineFor.state.selectedItem === this.item;
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.calculateStyleClass = /**
         * @return {?}
         */
            function () {
                if (!this.hasExpansionControl() ||
                    (this.outlineFor.pushRootSectionOnNewLine && core$1.isBlank(this.item.$$parentItem))) {
                    return '';
                }
                if (this.outlineFor.embedded) {
                    return this.outlineFor.isExpanded(this.item) ? 'icon-slim-arrow-down'
                        : 'icon-slim-arrow-right';
                }
                else {
                    return this.outlineFor.isExpanded(this.item)
                        ? 'icon-slim-arrow-right outline-icon-expanded' : 'icon-slim-arrow-right';
                }
            };
        /**
         * Collapses and expands current node
         *
         */
        /**
         * Collapses and expands current node
         *
         * @param {?} event
         * @return {?}
         */
        OutlineControlComponent.prototype.toggleExpansion = /**
         * Collapses and expands current node
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.outlineFor.state.currentPath = [];
                var /** @type {?} */ currentPath = this.item;
                while (core$1.isPresent(currentPath)) {
                    this.outlineFor.state.currentPath.unshift(currentPath);
                    currentPath = currentPath.$$parentItem;
                }
                this.outlineFor.toggleExpansion();
                var /** @type {?} */ payload = {
                    item: this.item,
                    expanded: this.outlineFor.state.isExpanded(this.item)
                };
                this.action.emit(payload);
                this.outlineFor.onExpandChange.emit(payload);
                event.stopPropagation();
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.select = /**
         * @return {?}
         */
            function () {
                this.outlineFor.state.selectedItem = this.item;
                this.outlineFor.onItemSelected.emit(this.item);
            };
        /**
         * @return {?}
         */
        OutlineControlComponent.prototype.prepareControl = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.outlineFor) && core$1.isPresent(this.outlineState)) {
                    this.outlineFor = this.outlineState.outlineFor;
                }
                core$1.assert(core$1.isPresent(this.outlineFor), 'Missing outlineFor component');
                if (this.outlineFor.embedded) {
                    var /** @type {?} */ level = this.outlineFor.state.currentLevel;
                    if (this.outlineFor.pushRootSectionOnNewLine && level > 0) {
                        level -= 1;
                    }
                    this.indentation = (this.outlineFor.indentationPerLevel * level);
                }
                this.item = this.outlineFor.currentItem;
                this.isRootItem = core$1.isBlank(this.item.$$parentItem);
            };
        OutlineControlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-outline-control',
                        template: "<!--\n    Control is just the two flex box items for displaying expand/collapse icon and content\n\n    Since we animate only standalone/non-embedded case now then we need to also animate the icon\n    so we use only icon-slim-arrow-right and do tranformation on top of this to make it rotate.\n\n    If embedded case we use both icons icon-slim-arrow-right / icon-slim-arrow-down\n-->\n<div class=\"w-outline-control\"\n     [ngClass]=\"{'outline-u-unselectable-text': outlineFor.pushRootSectionOnNewLine && !item.$$parentItem}\">\n    <div class=\"outline-icon sap-icon\"\n         *ngIf=\"!outlineFor.pushRootSectionOnNewLine || !isRootItem\"\n         (click)=\"toggleExpansion($event)\"\n         [style.margin-left.px]=\"indentation\"\n         [ngClass]=\"calculateStyleClass()\">\n    </div>\n\n    <ng-container *ngIf=\"allowSelection; then withSelection else withoutSelection\">\n    </ng-container>\n</div>\n\n<!--\n We support two case for the content\n\n Selection: When you click on the content it will add extra class so you can style currently\n selected item as well as broadcast event outside so developer can hook in some custom logic\n\n If we dont support selection: Then clicking on the content is just like clicking on expandable\n icon, it toggles the state\n-->\n\n<ng-template #withSelection>\n     <span class=\"outline-content outline-content-selected\" *ngIf=\"isSelected()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n    <span class=\"outline-content\" *ngIf=\"!isSelected()\" (click)=\"select()\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n\n</ng-template>\n\n\n<ng-template #withoutSelection>\n    <span class=\"outline-content\" (click)=\"toggleExpansion($event)\">\n        <ng-container *ngTemplateOutlet=\"ngContent\"></ng-container>\n    </span>\n</ng-template>\n\n\n<ng-template #ngContent>\n    <ng-content></ng-content>\n</ng-template>\n\n",
                        styles: [".w-outline-control{overflow:hidden;display:flex;flex-wrap:nowrap;cursor:pointer}.w-outline-control .outline-icon{flex:0 0 15px;color:#ababab;font-size:14px;font-weight:700;min-width:11px;align-self:center;transition:-webkit-transform 50ms ease-in;transition:transform 50ms ease-in;transition:transform 50ms ease-in,-webkit-transform 50ms ease-in;-webkit-transform-origin:25% 65%;transform-origin:25% 65%;-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.w-outline-control .outline-icon.outline-icon-expanded{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.w-outline-control .outline-content{flex:1 1 auto;flex-wrap:wrap;padding:0 4px}.w-outline-control .outline-content.outline-content-selected{cursor:default;font-weight:700}.outline-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none;cursor:auto}"],
                    },] },
        ];
        /** @nocollapse */
        OutlineControlComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: OutlineState, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineState; }),] }] },
                { type: OutlineControlComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineControlComponent; }),] }] },
                { type: OutlineForComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return OutlineForComponent; }),] }] }
            ];
        };
        OutlineControlComponent.propDecorators = {
            title: [{ type: core.Input }],
            allowSelection: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return OutlineControlComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWOutlineForModule = (function () {
        function AWOutlineForModule() {
        }
        AWOutlineForModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OutlineForComponent,
                            OutlineControlComponent,
                            InitNestingDirective
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule
                        ],
                        exports: [
                            OutlineForComponent,
                            OutlineControlComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWOutlineForModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders html text area component
     *
     * ### Example
     *
     * ```typescript
     *
     * \@Component({
     *          selector: 'myNote' ,
     *          template: '<aw-text-area [value]="inputValue" [autoResize]="autoResize" >
     *              </aw-text-area>'
     *      })
     *      export class MyNoteComponent
     *      {
     *          inputValue: string = 'Some really long text';
     *          autoResize: false;
     *      }
     *
     * ```
     *  Note: if you are using this outside of FormTable please provide your own FormGroup
     */
    var /** @type {?} */ TEXTAREA_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TextAreaComponent; }),
        multi: true
    };
    var TextAreaComponent = (function (_super) {
        __extends(TextAreaComponent, _super);
        function TextAreaComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             *
             * A value used to store and read user input
             *
             */
            _this.value = '';
            /**
             * Spefifies visible number of lines
             */
            _this.rows = 2;
            /**
             * Specifies visible width
             */
            _this.columns = 20;
            /**
             * when this option is TRUE and user starts typing it will maximize textarea's width and height
             */
            _this.autoResize = true;
            return _this;
        }
        /**
         * @return {?}
         */
        TextAreaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        TextAreaComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value, { onlySelf: true });
                }
            };
        TextAreaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-text-area',
                        template: "<div *ngIf=\"editable\" [formGroup]=\"formGroup\">\n\n\t<textarea\n        pInputTextarea\n        [attr.name]=\"name\"\n        class=\"w-text-area\"\n        [class.u-validation-error]=\"!(formControl.valid || (formControl.pristine))\"\n        [class.disabled]=\"disabled\"\n        formControlName=\"{{name}}\"\n        [rows]=\"rows\"\n        [cols]=\"columns\"\n        [autoResize]=\"autoResize\"\n        [attr.placeholder]=\"placeHolder\"\n\n    ></textarea>\n\n</div>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                        styles: [""],
                        providers: [
                            TEXTAREA_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return TextAreaComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        TextAreaComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        TextAreaComponent.propDecorators = {
            value: [{ type: core.Input }],
            rows: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            autoResize: [{ type: core.Input }]
        };
        return TextAreaComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWTextAreaModule = (function () {
        function AWTextAreaModule() {
        }
        AWTextAreaModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TextAreaComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.InputTextareaModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            TextAreaComponent
                        ],
                        exports: [
                            TextAreaComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWTextAreaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Page-Notification component that implements a notification system for the user regarding
     * the current object he's working on. Typical notification are:
     *      Success - saved.
     *      Warning - Sourcing request requires 3 suppliers.
     *      Error   - cannot connect to server, check internet connection.
     *
     *
     *
     * Usage 1:  As part of page wrapper.
     *
     * \@Component({
     *    selector: 'MyPage' ,
     *    template: `
     *       <aw-object-page-wrapper
     *                        [title]="MyPage"
     *                        [objectType]="MyType"
     *                        [notification]="pageNotification">
     *             page content
     *          `
     *       </aw-object-pager-wrapper>
     *    })
     *    export class MyPage
     *    {
     *
     *        pageNotification: PageNotification = new PageNotification("warn",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *    }
     *
     * Usage 2: directly into the page.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *      <
     *      aw-header></aw-header>
     *        Page Header
     *
     *        <ng-template [ngIf]="hasNotifications()">
     *          <div class="ui-g-12 u-nopadding">
     *            <aw-page-notification [notification]="notification"></aw-page-notification>
     *          </div>
     *        </ng-template>
     *
     *      <aw-footer></aw-footer>
     *    `
     *    })
     *    export class MyPage
     *    {
     *
     *        notification: PageNotification = new PageNotification("warning",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *    }
     *
     */
    var PageNotificationComponent = (function (_super) {
        __extends(PageNotificationComponent, _super);
        function PageNotificationComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        PageNotificationComponent.prototype.notificationClass = /**
         * @return {?}
         */
            function () {
                return "notification-" + this.notification.type;
            };
        /**
         * @return {?}
         */
        PageNotificationComponent.prototype.notificationIcon = /**
         * @return {?}
         */
            function () {
                return "ariba-icon icon-" + this.notification.type;
            };
        PageNotificationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-notification',
                        template: "<div class=\"page-notification\">\n    <div [class]=\"notificationClass()\">\n        <i [class]=\"notificationIcon()\"></i>\n        <span class=\"content\">\n              <span class=\"title\">{{notification.title}}</span>\n              <span class=\"description\">\n                    <ng-template *ngIf=\"notification.hasTemplate(); else description\"\n                                 [ngTemplateOutlet]=\"notification.contentTmpl\">\n                    </ng-template>\n                    <ng-template #description>{{notification.description}}</ng-template>\n              </span>\n      </span>\n    </div>\n</div>\n",
                        styles: [".page-notification{margin:0 0 5px}.notification-error,.notification-info,.notification-success,.notification-warning{padding:9px 8px}.notification-error i,.notification-info i,.notification-success i,.notification-warning i{font-size:24px;margin:10px}.notification-success i{color:#58b957}.notification-info i{color:#199de0}.notification-warning i{color:#f90}.notification-error i{color:#c00}.notification-success{background-color:#f1f9f1;border:1px solid rgba(88,185,87,.5)}.notification-info{background-color:#edf8fd;border:1px solid rgba(25,157,224,.5)}.notification-warning{background-color:#fff8dd;border:1px solid rgba(255,153,0,.5)}.notification-error{background-color:#ffebeb;border:1px solid rgba(204,0,0,.5)}.icon-error:before{content:\"\\EA9D\"}.icon-warning:before{content:\"\\EA9C\"}.content{vertical-align:super}.title{font-weight:700;margin-right:10px}"]
                    },] },
        ];
        /** @nocollapse */
        PageNotificationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        PageNotificationComponent.propDecorators = {
            notification: [{ type: core.Input }]
        };
        return PageNotificationComponent;
    }(BaseComponent));
    /**
     * Page Notification are messages for this page only. It displays in the center of the page
     * right under page title. Typical page notifications are 'save confirmation',
     * 'error during submit', warnings of field requirements, etc.
     */
    var /**
     * Page Notification are messages for this page only. It displays in the center of the page
     * right under page title. Typical page notifications are 'save confirmation',
     * 'error during submit', warnings of field requirements, etc.
     */ PageNotification = (function () {
        function PageNotification(type, title, description, contentTmpl) {
            this.type = type;
            this.title = title;
            this.description = description;
            this.contentTmpl = contentTmpl;
        }
        /**
         * @return {?}
         */
        PageNotification.prototype.hasTemplate = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.contentTmpl);
            };
        /**
         * @return {?}
         */
        PageNotification.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this.type + ', title: ' + this.title + ', description:  ' + this.description;
            };
        return PageNotification;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWPageNotificationModule = (function () {
        function AWPageNotificationModule() {
        }
        AWPageNotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            PageNotificationComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            PageNotificationComponent
                        ],
                        exports: [
                            PageNotificationComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWPageNotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Represents an event triggered when a page has been initialized.
     *
     */
    var /**
     * Represents an event triggered when a page has been initialized.
     *
     */ PageInitialized = (function () {
        function PageInitialized(title) {
            this.title = title;
        }
        /**
         * @return {?}
         */
        PageInitialized.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageInitializied(title: " + this.title + ")";
            };
        return PageInitialized;
    }());
    /**
     * Represents an event triggered when a page has been destroyed.
     *
     */
    var /**
     * Represents an event triggered when a page has been destroyed.
     *
     */ PageDestroyed = (function () {
        function PageDestroyed(title) {
            this.title = title;
        }
        /**
         * @return {?}
         */
        PageDestroyed.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageDestroyed(title: " + this.title + ")";
            };
        return PageDestroyed;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Page LifeCycle Service monitors all page initialization and destructions.
     * The purpose of this service is to help the application monitor page lifecycle, subscribe
     * to lifecycle events and execute actions such as user analytics.
     *
     * Usage:
     *
     *    1.  Inject PageLifeCycleService into your constructor
     *
     *    constructor(pageLifecycle:PageLifeCycleService) {
     *        pageLifecycle.pageEvents.subscribe(event:Event => {
     *            if(event instanceof PageInitialized) {
     *            }
     *            // PageDestroyed
     *
     *        });
     *     }
     */
    var PageLifeCycleService = (function () {
        /**
         *
         */
        function PageLifeCycleService() {
            /**
             * Page event queue when all page lifecycle events: init, destroy are emitted.
             * Listeners can subscribe to these events.
             */
            this.pageEvents = new rxjs.Subject();
        }
        /**
         * Called when page is initialized.
         * @param {?} pageTitle
         * @return {?}
         */
        PageLifeCycleService.prototype.onPageInit = /**
         * Called when page is initialized.
         * @param {?} pageTitle
         * @return {?}
         */
            function (pageTitle) {
                this.pageEvents.next(new PageInitialized(pageTitle));
            };
        /**
         * Call when page has been destroyed
         * @param {?} pageTitle
         * @return {?}
         */
        PageLifeCycleService.prototype.onPageDestroy = /**
         * Call when page has been destroyed
         * @param {?} pageTitle
         * @return {?}
         */
            function (pageTitle) {
                this.pageEvents.next(new PageDestroyed(pageTitle));
            };
        PageLifeCycleService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        PageLifeCycleService.ctorParameters = function () { return []; };
        return PageLifeCycleService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var PageType = {
        Init: 0,
        // Init Page type
        Login: 1,
        // Login Page
        Object: 2,
        // Object detail page
        List: 3,
        // List Page
        MasterDetail: 4,
        // MasterDetail
        Dashboard: 5,
        // Dashboard page
        Modal: 6,
    };
    PageType[PageType.Init] = "Init";
    PageType[PageType.Login] = "Login";
    PageType[PageType.Object] = "Object";
    PageType[PageType.List] = "List";
    PageType[PageType.MasterDetail] = "MasterDetail";
    PageType[PageType.Dashboard] = "Dashboard";
    PageType[PageType.Modal] = "Modal";
    /**
     *  Page wrapper is the base class for all pages. The idea is that there are different page types
     *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
     *  a object page will render one object in detail.
     *
     *  They share common attributes such as page type and page id.
     *
     *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
     *  destroyed, it'll be complete.
     * @abstract
     */
    var /**
     *  Page wrapper is the base class for all pages. The idea is that there are different page types
     *  in an Application. A List Page renders a list of objects, ex: customers, requests, PO.  And
     *  a object page will render one object in detail.
     *
     *  They share common attributes such as page type and page id.
     *
     *  Ariba Page have a life cycle. When page starts up, it's initialized. And when the page is
     *  destroyed, it'll be complete.
     * @abstract
     */ PageWrapper = (function (_super) {
        __extends(PageWrapper, _super);
        function PageWrapper(env, pageType, componentRegistry, pageLifecycleService) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.componentRegistry = componentRegistry;
            _this.pageLifecycleService = pageLifecycleService;
            /**
             * What type of page this is.
             *
             */
            _this.pageType = PageType.Init;
            _this.pageType = pageType;
            return _this;
        }
        /**
         * Get the unique Id for this page.
         *
         * @return {?}
         */
        PageWrapper.prototype.getId = /**
         * Get the unique Id for this page.
         *
         * @return {?}
         */
            function () {
                if (this.id) {
                    return this.id;
                }
                this.id = this.generatePageId();
            };
        return PageWrapper;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Header component that implements consistent styling, behavior for an Ariba page.
     * Header includes a menu, user profile, and alerts.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *                <aw-page-header [showBackAction]="true" userName="Chad Noll"
     *                                 [menuItems]="menuItems" [notifications]="userNotifications">
     *                     <div class="page-header-center">
     *                           <a class="navbar-brand" tabindex="0" href="/">
     *                               <img class="navbar-logo" src="./images/SAP_Ariba_DB.png"
     *                                   alt="Go to homepage" data-pin-nopin="true">
     *                          </a>
     *                     </div>
     *                </aw-page-header>
     *
     *    `
     *    })
     *    export class MyPage
     *    {
     *      menuItems: PageMenuItem[] = [new PageMenuItem('icon-home', 'Home', '/play/'),
     *                                  new PageMenuItem('icon-expense-report', 'Reports',
     *                                                     '/play/pageheader'),
     *                                  new PageMenuItem('icon-sales-order', 'Purchase Order',
     *                                                       '/play/pageheader'),
     *                                  new PageMenuItem('icon-account', 'Accounts',
     *                                                     '/play/pageheader')];
     *
     *     userNotifications: UserNotification[] = [
     *       new UserNotification('icon-expense-report', 'Expense report EXP453 has been approved.',
     *                             '/play/'),
     *         new UserNotification('icon-sales-order', 'Sales Order SO1234 has been created.',
     *                             '/play/'),
     *           new UserNotification('icon-account', 'Supplier account SA1234 has been updated.',
     *                               '/play/')
     *        ];
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var PageHeaderComponent = (function (_super) {
        __extends(PageHeaderComponent, _super);
        function PageHeaderComponent(element, env, routing) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            _this.routing = routing;
            /**
             * Should the user notification icon be hidden. Default it to show the icon even
             * if there's no notifications.
             *
             */
            _this.hideNotification = false;
            /**
             * displays the back link that navigates user to the previous page when clicked.
             */
            _this.showBackAction = false;
            _this.showNotificationPanel = false;
            return _this;
        }
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.backAction = /**
         * @return {?}
         */
            function () {
                this.routing.goBack();
            };
        /**
         * Do i have any menu items.
         *
         */
        /**
         * Do i have any menu items.
         *
         * @return {?}
         */
        PageHeaderComponent.prototype.hasMenuItems = /**
         * Do i have any menu items.
         *
         * @return {?}
         */
            function () {
                return (this.menuItems && this.menuItems.length > 0);
            };
        /**
         * Toggle the side navigation menu.
         */
        /**
         * Toggle the side navigation menu.
         * @return {?}
         */
        PageHeaderComponent.prototype.showHideMenu = /**
         * Toggle the side navigation menu.
         * @return {?}
         */
            function () {
                this.sidenav.toggle();
            };
        /**
         * Do I have any notifications.
         *
         */
        /**
         * Do I have any notifications.
         *
         * @return {?}
         */
        PageHeaderComponent.prototype.hasNotifications = /**
         * Do I have any notifications.
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.notifications) && this.notifications.length > 0;
            };
        /**
         * toggling wheather notification panel is displayed or not.
         */
        /**
         * toggling wheather notification panel is displayed or not.
         * @return {?}
         */
        PageHeaderComponent.prototype.toggleNotificationPanel = /**
         * toggling wheather notification panel is displayed or not.
         * @return {?}
         */
            function () {
                this.showNotificationPanel = !this.showNotificationPanel;
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-header',
                        template: "<nav class=\"navbar page-header\" role=\"navigation\">\n\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-4 navbar-left\">\n\n        <span *ngIf=\"hasMenuItems()\">\n            <a (click)=\"showHideMenu()\">\n                <i class=\"sap-icon icon-paging\"></i>\n            </a>\n\n            <!-- Side menu -->\n            <aw-sidenav #sidemenu [items]=\"menuItems\"></aw-sidenav>\n        </span>\n            <!-- End Hamburger menu. -->\n\n            <!--  back action -->\n            <span class=\"back-action\">\n            <a (click)=\"backAction()\">\n                <i *ngIf=\"showBackAction\" class=\"sap-icon icon-arrow-left\" role=\"button\"></i>\n            </a>\n        </span>\n\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-center\">\n\n            <!-- central section.  Application can add Ariba-logo, search box, etc -->\n            <ng-content select=\".page-header-center\"></ng-content>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4 navbar-right\">\n        <span *ngIf=\"userName\">\n            <img id=\"userProfilePicture\" class=\"profile-logo\" aria-hidden=\"true\"\n                 [title]=\"userName\" src=\"{{assetFolder}}/images/default_image_small.png\">\n            <span class=\"profile-user\" title=\"{{userName}}\">{{userName}}</span>\n        </span>\n\n            <span *ngIf=\"!hideNotification\" class=\"notification-container\">\n\n            <i #notificationIcon class=\"ariba-icon icon-notification\"\n               (click)=\"toggleNotificationPanel()\"></i>\n            <span *ngIf=\"hasNotifications()\" class=\"notification-badge\" aria-hidden=\"true\">{{notifications.length}}</span>\n\n                <!-- Originally I was using p-overlay-panel, however, it doesn't position correctly under the notification icon.\n                     The positioning logic in prime ng needs some more investigation. So for now, use a div instead-->\n            <div *ngIf=\"showNotificationPanel\" class=\"notification-panel\">\n\n                <div class=\"notification-header\">\n                     Notifications\n                </div>\n\n                <ul class=\"notification-content\">\n                    <li *ngFor=\"let noti of notifications\" class=\"notification-item\">\n                        <a [routerLink]=\"noti.link\">\n                            <span class=\"notification-item-icon\"><i\n                                [ngClass]=\"'sap-icon ' + noti.icon\"></i></span>\n                            {{noti.label}}\n                        </a>\n                    </li>\n                </ul>\n            </div>\n        </span>\n        </div>\n\n\n    </div>\n</nav>\n",
                        styles: [".page-header i{font-size:32px}.page-header .icon-paging{font-size:30px;position:relative;top:2px}.back-action{display:inline-block;margin-left:15px}.back-action i{position:relative;top:3px}.navbar{background:#000;color:#fff}.navbar-left{padding-left:15px;height:50px}.navbar-center{text-align:center;height:50px}.navbar-right{text-align:right;height:50px}.profile-logo{width:30px;height:30px;position:relative;top:2px}.profile-user{vertical-align:super;margin-right:30px}.icon-notification:before{content:\"\\eA14\"}.navbar #sidebar-menu-icon{position:relative;top:.5em}.notification-container{position:relative;margin-right:20px;display:inline-block}.notification-badge{display:inline-block;padding:2px 5px;font-size:12px;font-weight:700;color:#fff;background-color:#c00;border-radius:10px;position:absolute;top:0;left:16px}.notification-panel{position:absolute;right:-27px;top:45px;width:350px;color:#767676;box-shadow:0 2px 10px 0 rgba(0,0,0,.13);background-color:#fff;overflow:hidden;transition:all .3s ease-in-out}.notification-panel .notification-header{background-color:#f3f3f3;font-size:16px;height:50px;line-height:50px;text-align:center}.notification-panel .notification-content{padding:0;margin:0}.notification-panel .notification-item{height:50px;border-top:1px solid #d7d7d7;padding:15px 10px;white-space:nowrap;text-overflow:ellipsis}.notification-panel .notification-item a{color:#767676;text-decoration:none;line-height:35px}.notification-panel .notification-item:hover{background-color:#f7f8fa}.notification-panel .notification-item-icon{margin-right:15px;color:#767676;display:inline-block;margin-top:10px;vertical-align:middle}"]
                    },] },
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: core$1.RoutingService }
            ];
        };
        PageHeaderComponent.propDecorators = {
            menuItems: [{ type: core.Input }],
            notifications: [{ type: core.Input }],
            hideNotification: [{ type: core.Input }],
            showBackAction: [{ type: core.Input }],
            userName: [{ type: core.Input }],
            sidenav: [{ type: core.ViewChild, args: ['sidemenu',] }]
        };
        return PageHeaderComponent;
    }(BaseComponent));
    /**
     * PageMenuItem represents an item in the page menu structure.
     */
    var /**
     * PageMenuItem represents an item in the page menu structure.
     */ PageMenuItem = (function () {
        /**
         * @param icon    - Icon of this menu item.
         * @param label   - label of this item.
         * @param link    - link to the destination when user clicks on it.
         */
        function PageMenuItem(icon, label, link) {
            this.icon = icon;
            this.label = label;
            this.link = link;
        }
        /**
         * @return {?}
         */
        PageMenuItem.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageMenuItem: (label, " + this.label + ")";
            };
        return PageMenuItem;
    }());
    /**
     * notification for the current logged in user.
     * Ex:  PR2049 has been approved.
     *      Order PO518 received.
     */
    var /**
     * notification for the current logged in user.
     * Ex:  PR2049 has been approved.
     *      Order PO518 received.
     */ UserNotification = (function () {
        /**
         * @param icon   - alert notification icon
         * @param label  - alert notification label
         * @param link   - link
         */
        function UserNotification(icon, label, link) {
            this.icon = icon;
            this.label = label;
            this.link = link;
        }
        /**
         * @return {?}
         */
        UserNotification.prototype.toString = /**
         * @return {?}
         */
            function () {
                return "PageUserNotification: (label, " + this.label + ")";
            };
        return UserNotification;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Footer component that implements consistent styling, behavior.
     * This footer component self contained.
     *
     * \@Component({
     *    selector: 'registration' ,
     *    template: `
     *
     *          <aw-page-footer>
     *               <div class="page-footer-logo">
     *                   <img src="images/ariba_logo_white_bkgd.png">
     *               </div>
     *               <div class="page-footer-user-info">
     *                   Chad Noll (cnoll) last visit {{last_visited | date:'MM/dd/yyyy h:mma' }}
     *                   | Buyer Organization
     *               </div>
     *               <span class="page-footer-copyright" #copyright>
     *                   <p>© 2020–2028 The Future, Inc. All rights reserved</p>
     *               </span>
     *           </aw-page-footer>
     *    `
     *    })
     *    export class MyPage
     *    {
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var PageFooterComponent = (function (_super) {
        __extends(PageFooterComponent, _super);
        function PageFooterComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * show default copyright. If copyright is passed in, then show the passed in one.
             */
            _this.showDefaultCopyright = true;
            return _this;
        }
        /**
         * @return {?}
         */
        PageFooterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * @return {?}
         */
        PageFooterComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.showDefaultCopyright = !core$1.isPresent(this.copyright);
            };
        PageFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-footer',
                        template: "<div class=\"page-footer\">\n    <div class=\"ui-g\">\n        <div class=\"ui-g-12 ui-md-8\">\n\n            <ng-content select=\".page-footer-logo\"></ng-content>\n\n            <div class=\"user-info\">\n                <ng-content select=\".page-footer-user-info\"></ng-content>\n            </div>\n\n            <ul class=\"footer-links\">\n                <li role=\"presentation\"><a href=\"http://www.ariba.com/legal/ariba_tou.cfm\">Terms of\n                    Use</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_security_policy.cfm\">Security\n                    Disclosure</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba_privacy_statement.cfm\">Privacy\n                    Statement</a></li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Cookie Statement</a>\n                </li>\n                <li role=\"presentation\"><a\n                    href=\"http://www.ariba.com/legal/ariba-privacy-statement\">Participant\n                    Statement</a></li>\n            </ul>\n        </div>\n\n        <div class=\"ui-g-12 ui-md-4\">\n            <div class=\"u-bottom-align\"></div>\n            <div class=\"u-hright copyright\">\n                <ng-content select=\".page-footer-copyright\"></ng-content>\n            </div>\n\n            <!-- Default Copyright -->\n            <div *ngIf=\"showDefaultCopyright\" class=\"u-hright copyright\">\n                <p>\u00A9 1996\u20132017 Ariba, Inc. All rights reserved</p>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                        styles: [".page-footer{background:#fff;padding:15px 0 0;font-size:11px;border-top:1px solid #d7d7d7}.page-footer .user-info{color:#ccc}.page-footer .ui-g{margin:0 auto}.page-footer .copyright{color:#ccc}.footer-links{list-style:none;margin:0 -15px;padding:0;font-size:10px}.footer-links li{float:left}.footer-links:after,.footer-links:before{content:\" \";display:table}.footer-links:after{clear:both}.footer-links>li,.footer-links>li>a{position:relative;display:block}.footer-links>li>a{padding:10px 15px;color:#199de0}"]
                    },] },
        ];
        /** @nocollapse */
        PageFooterComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        PageFooterComponent.propDecorators = {
            copyright: [{ type: core.ContentChild, args: ['copyright',] }]
        };
        return PageFooterComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Object Page Wrapper Component renders any object instance in detail. It has a uniform layout,
     * Header, Page title, Page notification, actions, content, and Footer.
     *
     *
     *  Usage:
     *
     * \@Component({
     *    selector: 'RFXPage' ,
     *    template: `
     *       <aw-object-page-wrapper
     *                        [title]="rfxEntity.headerInfo.title"
     *                        [objectType]="rfxEntity.headerInfo.eventTypeString"
     *                        [notification]="pageNotification">
     *
     *
     *           <aw-page-actions>
     *               <aw-button [type]="'submit'" [name]="'edit'" [value]="edit" [style]="'primary'">
     *                   Edit
     *                </aw-button>
     *               <aw-button [type]="'button'" [name]="'cancel'" [value]="cancel"
     *                                                         [style]="'secondary'">
     *                  Cancel
     *               </aw-button>
     *           </aw-page-actions>
     *
     *           <aw-page-content>
     *             <aw-section title="Sourcing request info" (onStateChanged)="onStateChange($event)">
     *
     *                   <m-context [object]="rfxEntity.headerInfo"
     *                              [operation]="this.editabilityState.headerInfoOp"
     *                              layout="Inspect"
     *                              uiGroup="HeaderGeneral"
     *                   >
     *                       <m-include-component></m-include-component>
     *                   </m-context>
     *
     *             </aw-section>
     *           </aw-page-content>
     *       </aw-object-page-wrapper>
     *    `
     *    })
     *    export class RFXPage
     *    {
     *       // To keep track what section is editable and which read only
     *       editabilityState: EditabilityState;
     *
     *       // Current RFX event
     *       rfxEntity: RfxEventEntity;
     *
     *       // Notifications
     *       notification: PageNotification = new PageNotification("warn",
     *                              "Policy Warning", "This request requires 3 bids.");
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     */
    var ObjectPageWrapperComponent = (function (_super) {
        __extends(ObjectPageWrapperComponent, _super);
        function ObjectPageWrapperComponent(element, env, componentRegistry, pageLifecycleService) {
            var _this = _super.call(this, env, PageType.Object, componentRegistry, pageLifecycleService) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Set true if page should not include any header. Need to set to true even no header
             * object is passed in. Otherwise, a default Header component will be added.
             */
            _this.hideHeader = false;
            /**
             * Set true if page should not include any footer. Need to set to true even no footer
             * object is passed in. Otherwise, a default Footer component will be added.
             */
            _this.hideFooter = false;
            /**
             * The positioning of the page actions (page buttons)
             *   'top' :    page buttons are placed at the top of the page, below the title, to the right.
             *   'bottom' : page buttons are placed at the bottom of the page, above the footer.
             *   'both'   : page buttons are placed at both top and bottom.
             *
             */
            _this.pageActionPosition = 'top';
            /**
             * This flag is driven by pageActionPosition. The default position is top.
             * Value is true for both 'top' and 'both' of pageActionPosition.
             */
            _this.hasTopPageActions = true;
            _this.objectStateIndex = 0;
            // Setting Default header component
            // Setting Default header component
            _this.header = PageHeaderComponent;
            _this.footer = PageFooterComponent;
            return _this;
        }
        /**
         * Generate a unique Id for this object.
         *
         */
        /**
         * Generate a unique Id for this object.
         *
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.generatePageId = /**
         * Generate a unique Id for this object.
         *
         * @return {?}
         */
            function () {
                return this.objectType + '_' + this.title + (this.id) ? ('_' + this.id) : '';
            };
        /**
         * Does my page have page notification?
         *
         */
        /**
         * Does my page have page notification?
         *
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.hasNotifications = /**
         * Does my page have page notification?
         *
         * @return {?}
         */
            function () {
                return (this.notifications && this.notifications.length > 0);
            };
        /**
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.hasObjectStates = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.objectStates);
            };
        /**
         * Initialize my local components
         */
        /**
         * Initialize my local components
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnInit = /**
         * Initialize my local components
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // New Component types that are used in c-include-component
                if (this.header) {
                    this.componentRegistry.registerType(this.header.name, this.header);
                }
                // New Component types that are used in c-include-component
                if (this.footer) {
                    this.componentRegistry.registerType(this.footer.name, this.footer);
                }
                /** notify subscribers of the page lifecycle service  */
                this.pageLifecycleService.onPageInit(this.title);
                // Setting the page action position.
                if (this.pageActionPosition === 'bottom') {
                    this.hasTopPageActions = false;
                    this.hasBottomPageActions = true;
                }
                else if (this.pageActionPosition === 'both') {
                    this.hasTopPageActions = true;
                    this.hasBottomPageActions = true;
                }
                if (core$1.isPresent(this.objectStates) && this.objectStates.length > 1
                    && core$1.isPresent(this.currentState)) {
                    this.objectStateIndex = this.objectStates.indexOf(this.currentState);
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (core$1.isPresent(changes['currentState']) &&
                    changes['currentState'].currentValue !== changes['currentState'].previousValue) {
                    // we dont need to check if objectStates exists
                    this.objectStateIndex = this.objectStates.indexOf(this.currentState);
                }
            };
        /**
         * @return {?}
         */
        ObjectPageWrapperComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.pageLifecycleService.onPageDestroy(this.title);
            };
        ObjectPageWrapperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-object-page-wrapper',
                        template: "<div class=\"page-wrapper\">\n    <ng-template [ngIf]=\"!hideHeader\">\n        <aw-include-component [name]='header.name'></aw-include-component>\n    </ng-template>\n\n    <div class=\"arc-object-detail\">\n\n        <div class=\"ui-g\">\n\n            <!-- page header -->\n            <div class=\"ui-g-12 page-title\">\n\n                <!-- page title -->\n                <div class=\"ui-g-8 ui-md-8 page-title-text\">{{title}}</div>\n\n                <div class=\"ui-g-4 ui-md-4 page-status\">\n                    <span class=\"object-status-label\">{{objectStatusLabel}} &nbsp;</span>\n                    <span class=\"object-status\">{{objectStatus}}</span>\n                </div>\n            </div>\n\n            <!-- page actions -->\n            <div class=\"ui-g-12 page-actions\" *ngIf=\"hasTopPageActions\">\n                <ng-template [embeddedItem]=\"actionsTemplate\"\n                             *ngIf=\"hasTopPageActions\"></ng-template>\n            </div>\n\n            <!-- object states  displays only if state exists. -->\n            <div class=\"ui-g-12 page-state\">\n                <div class=\"ui-g-3 page-state-left\" [class.content]=\"hasObjectStates()\">\n                    <ng-content select=\".page-state-left\"></ng-content>\n                </div>\n                <div class=\"ui-g-6 page-state-center\">\n                    <ng-container *ngIf=\"hasObjectStates()\">\n                        <aw-stepper [steps]=\"objectStates\"\n                                    [currentStep]=\"objectStateIndex\"></aw-stepper>\n                    </ng-container>\n                </div>\n                <div class=\"ui-g-3 page-state-right\">\n                    <ng-content select=\".page-state-right\"></ng-content>\n                </div>\n            </div>\n\n\n            <!-- Page Notification -->\n            <ng-template [ngIf]=\"hasNotifications()\">\n                <div class=\"ui-g-12 u-nopadding\">\n\n                    <aw-page-notification *ngFor=\"let notification of notifications\"\n                                          [notification]=\"notification\"></aw-page-notification>\n                </div>\n            </ng-template>\n\n            <!-- additional content -->\n            <ng-content select=\"aw-page-content\"></ng-content>\n\n        </div>\n\n    </div>\n\n    <!-- page actions -->\n    <div class=\"ui-g-12 page-actions-bottom\" *ngIf=\"hasBottomPageActions\">\n        <ng-template [embeddedItem]=\"actionsTemplate\"\n                     *ngIf=\"hasBottomPageActions\"></ng-template>\n\n    </div>\n\n    <div class=\"page-push\"></div>\n</div>\n\n<ng-template [ngIf]=\"!hideFooter\">\n    <aw-include-component [name]='footer.name'></aw-include-component>\n</ng-template>\n",
                        styles: [".page-wrapper{background-color:#f2f2f2;min-height:100%;margin-bottom:-100px}.arc-object-detail{padding:20px}.page-title-text{font-size:22px;color:#000;padding:14px 0}.page-title{padding:5px 0;border-bottom:1px solid #d7d7d7}.page-actions{padding:15px 0 5px}.page-actions-bottom{padding:0 20px}.page-state,.page-state-center,.page-state-left,.page-state-right{padding:0}.content::after{content:'\\x000a0';font-size:0}.page-title /deep/ .ui-button{min-width:100px}.page-status{text-align:right;padding:18px 0}.page-status .object-status-label{color:#767676}.page-status .object-status{font-weight:700;color:#038719}.page-push{height:100px}"]
                    },] },
        ];
        /** @nocollapse */
        ObjectPageWrapperComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: ComponentRegistry },
                { type: PageLifeCycleService }
            ];
        };
        ObjectPageWrapperComponent.propDecorators = {
            title: [{ type: core.Input }],
            objectType: [{ type: core.Input }],
            objectStatusLabel: [{ type: core.Input }],
            objectStatus: [{ type: core.Input }],
            objectStates: [{ type: core.Input }],
            currentState: [{ type: core.Input }],
            header: [{ type: core.Input }],
            hideHeader: [{ type: core.Input }],
            footer: [{ type: core.Input }],
            hideFooter: [{ type: core.Input }],
            pageActionPosition: [{ type: core.Input }],
            actionsTemplate: [{ type: core.ContentChild, args: ['pageActions',] }],
            notifications: [{ type: core.Input }]
        };
        return ObjectPageWrapperComponent;
    }(PageWrapper));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Page actions is a wrapper for all page actions, buttons, links, menus that interacts it with the
     * page. The wrapper use the ability to position it as needed.
     */
    var PageActionsComponent = (function (_super) {
        __extends(PageActionsComponent, _super);
        function PageActionsComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        PageActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-actions',
                        template: "<div class=\"page-actions\">\n    <ng-content></ng-content>\n</div>\n",
                        styles: [".page-actions{text-align:right;padding-top:0;padding-right:0}"]
                    },] },
        ];
        /** @nocollapse */
        PageActionsComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        return PageActionsComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Page content is a wrapper for page content.
     * Currently, it's pretty bare, but as we add more interactions on the page, like a side bar,
     * the page content area will likely get affected.
     */
    var PageContentComponent = (function (_super) {
        __extends(PageContentComponent, _super);
        function PageContentComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        PageContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-page-content',
                        template: '<ng-content></ng-content>',
                        styles: [':host {width: 100%; padding: 0 .5em;}']
                    },] },
        ];
        /** @nocollapse */
        PageContentComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        return PageContentComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ STEPPER_COMPLETED_STEP_COLOR = '#58b957';
    var /** @type {?} */ STEPPER_CURRENT_STEP_COLOR = '#0076CB';
    var /** @type {?} */ STEPPER_REMAINING_STEP_COLOR = '#D7D7D7';
    /**
     * Stepper component displays a list of steps for user to follow. It can be used as a checklist
     * to indicate completed, current and remaining items. It could be also be used to indicate
     * the state of an document, created, submitted, approved, etc...
     *
     *
     * Usage:
     *   1.   Use the component inside your template. provide a list of steps and the current step.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                <aw-stepper [steps]="steps" [currentStep]="currentStep"></aw-stepper>
     *
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     steps: string[] = ['Monitor', 'Add Supplier', 'Get Quote'];
     *                     currentStep: number = 1;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *       }
     *
     *   2.  Override the default colors.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                            <aw-stepper [steps]="steps" [stepColorCurrent]="'#ff9900'"
     *                                        [stepColorRemaining]="'#CC0000'"
     *                                        [stepColorCompleted]="'#97a822'"
     *                                        [currentStep]="currentStep">
     *                            </aw-stepper>
     *                  `
     */
    var StepperComponent = (function (_super) {
        __extends(StepperComponent, _super);
        function StepperComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Local variable to indicate whether to use the colors array or not.
             */
            _this.bUseColorArray = false;
            /**
             * The current step that's on. If not provided default to the first step.
             */
            _this.currentStep = 0;
            // Initial color for the different stages of steps.
            // Initial color for the different stages of steps.
            _this.stepColorCompleted = STEPPER_COMPLETED_STEP_COLOR;
            _this.stepColorCurrent = STEPPER_CURRENT_STEP_COLOR;
            _this.stepColorRemaining = STEPPER_REMAINING_STEP_COLOR;
            return _this;
        }
        /**
         * @return {?}
         */
        StepperComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // Calculate the connector width based on how many steps
                if (core$1.isPresent(this.steps) && this.steps.length > 1) {
                    // (100% - 20% (side margins)) / (NumOfSteps -1)
                    this.connectorWidth = Math.ceil(80 / (this.steps.length - 1)) + '%';
                }
                /**
                         * Use the color array if it's defined.
                         */
                if (core$1.isPresent(this.colors)) {
                    this.bUseColorArray = true;
                    if (this.colors.length !== this.steps.length) {
                        throw new Error("The size of the steps and colors don't match:\n                  (steps.length = " + this.steps.length + "), (colors.length = " + this.colors.length);
                    }
                }
            };
        /**
         * Getting the color of the step for the current index
         *
         * @param index
         */
        /**
         * Getting the color of the step for the current index
         *
         * @param {?} index
         * @return {?}
         */
        StepperComponent.prototype.getStepColor = /**
         * Getting the color of the step for the current index
         *
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Color Array overrides everything else.
                if (this.bUseColorArray) {
                    return this.colors[index];
                }
                if (index < this.currentStep) {
                    return this.stepColorCompleted;
                }
                else if (index === this.currentStep) {
                    return this.stepColorCurrent;
                }
                else {
                    return this.stepColorRemaining;
                }
            };
        /**
         * The connector colors are driven by the step colors.
         *
         */
        /**
         * The connector colors are driven by the step colors.
         *
         * @param {?} index
         * @return {?}
         */
        StepperComponent.prototype.getConnectorColor = /**
         * The connector colors are driven by the step colors.
         *
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // Color Array overrides everything else.
                if (this.bUseColorArray) {
                    return this.colors[index];
                }
                if (index < this.currentStep) {
                    return this.stepColorCompleted;
                }
                else {
                    return this.stepColorRemaining;
                }
            };
        /**
         * Next step.
         */
        /**
         * Next step.
         * @return {?}
         */
        StepperComponent.prototype.nextStep = /**
         * Next step.
         * @return {?}
         */
            function () {
                this.currentStep++;
            };
        /**
         * previous step.
         */
        /**
         * previous step.
         * @return {?}
         */
        StepperComponent.prototype.prevStep = /**
         * previous step.
         * @return {?}
         */
            function () {
                this.currentStep--;
            };
        StepperComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-stepper',
                        template: "<div class=\"stepper-container\">\n    <div class=\"steps\">\n        <div class=\"step-spacing\"></div>\n\n        <ng-container *ngFor=\"let step of steps; let i=index; let last=last;\">\n            <div class=\"step\">\n                <aw-step [title]=\"step\" [color]=\"getStepColor(i)\"></aw-step>\n            </div>\n            <div *ngIf=\"!last\" class=\"step-connector\" [style.width]=\"connectorWidth\">\n                <div class=\"connector\" [style.borderBottomColor]=\"getConnectorColor(i)\"></div>\n            </div>\n        </ng-container>\n\n        <div class=\"step-spacing\"></div>\n    </div>\n\n    <div class=\"step-labels\"></div>\n</div>\n\n\n",
                        styles: [".stepper-container{display:table;table-layout:fixed;width:100%}.steps{display:table-row}.step-spacing{display:table-cell;width:10%}.step{display:table-cell;width:32px}.step-connector{display:table-cell;vertical-align:middle}.connector{height:1px;border-bottom:3px solid #58b957}.step-labels{display:table-row;height:50px}"]
                    },] },
        ];
        /** @nocollapse */
        StepperComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        StepperComponent.propDecorators = {
            steps: [{ type: core.Input }],
            colors: [{ type: core.Input }],
            stepColorCompleted: [{ type: core.Input }],
            stepColorCurrent: [{ type: core.Input }],
            stepColorRemaining: [{ type: core.Input }],
            currentStep: [{ type: core.Input }]
        };
        return StepperComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Renders html step component
     *
     *  * Usage:
     *       Straight forward to use. But mostly it would be used as part of the stepper component.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                           <aw-step [title]="step" [color]="color"></aw-step>
     *                           `
     */
    var /** @type {?} */ DEFAULT_COLOR = '#58b957';
    var StepComponent = (function () {
        function StepComponent(env) {
            this.env = env;
        }
        /**
         * @return {?}
         */
        StepComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isBlank(this.color)) {
                    this.color = DEFAULT_COLOR;
                }
            };
        StepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-step',
                        template: "<div class=\"step-container\">\n    <div class=\"outer-circle\" [style.borderColor]=\"color\">\n        <div class=\"inner-circle\" [style.borderColor]=\"color\" [style.backgroundColor]=\"color\"></div>\n    </div>\n\n    <div class=\"step-title\">{{title}}</div>\n</div>\n\n",
                        styles: [".step-container{position:relative;width:32px}.outer-circle{width:26px;height:26px;border-radius:50%;background-color:#fff;border:3px solid #58b957;position:relative}.inner-circle{width:8px;height:8px;border-radius:50%;border:2px solid #58b957;background-color:#58b957;margin:0 auto;position:absolute;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.step-title{position:absolute;width:150px;top:40px;left:-60px;text-align:center}"]
                    },] },
        ];
        /** @nocollapse */
        StepComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        StepComponent.propDecorators = {
            color: [{ type: core.Input }],
            title: [{ type: core.Input }]
        };
        return StepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWStepperModule = (function () {
        function AWStepperModule() {
        }
        AWStepperModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StepComponent,
                            StepperComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                        ],
                        entryComponents: [
                            StepComponent,
                            StepperComponent
                        ],
                        exports: [
                            StepComponent,
                            StepperComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWStepperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *  This is a temporary implementation for the page header component.
     *  When the real implementation of side menu is done, PageHeaderComponent will
     *  be swaped to use it.
     *
     */
    var SidenavComponent = (function (_super) {
        __extends(SidenavComponent, _super);
        function SidenavComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        SidenavComponent.prototype.getSidenavClass = /**
         * @return {?}
         */
            function () {
                // Only show if I have items
                return (this.show && this.items) ? 'sidenav sidenav-active' : 'sidenav';
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.open = /**
         * @return {?}
         */
            function () {
                this.show = true;
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.show = false;
            };
        /**
         * @return {?}
         */
        SidenavComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.show = !this.show;
            };
        SidenavComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-sidenav',
                        template: "<div [ngClass]=\"getSidenavClass()\">\n    <div class=\"sidenav-content\">\n        <a *ngFor=\"let item of items\" [routerLink]=\"item.link\">\n            <span class=\"sidenav-icon\"><i [ngClass]=\"'sap-icon ' + item.icon\"></i></span>\n            {{item.label}}\n        </a>\n    </div>\n</div>\n",
                        styles: [".sidenav{height:100%;width:0;position:fixed;z-index:1;top:50px;left:0;background-color:#363636;overflow-x:hidden;padding-top:20px;transition:.5s}.sidenav-active{width:250px}.sidenav a{padding:8px 8px 8px 32px;text-decoration:none;font-size:16px;color:#fff;display:block;transition:.3s}.sidenav a:hover{background-color:#111}.sidenav-icon{font-size:30px;color:#ccc;margin-right:10px}"]
                    },] },
        ];
        /** @nocollapse */
        SidenavComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        SidenavComponent.propDecorators = {
            items: [{ type: core.Input }],
            show: [{ type: core.Input }]
        };
        return SidenavComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWPageWrapperModule = (function () {
        function AWPageWrapperModule() {
        }
        AWPageWrapperModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ObjectPageWrapperComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageFooterComponent,
                            PageHeaderComponent,
                            SidenavComponent
                        ],
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            AWCoreComponentModule,
                            AWStepperModule,
                            AWPageNotificationModule
                        ],
                        entryComponents: [
                            PageFooterComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageHeaderComponent
                        ],
                        exports: [
                            ObjectPageWrapperComponent,
                            PageActionsComponent,
                            PageContentComponent,
                            PageFooterComponent,
                            PageHeaderComponent,
                            SidenavComponent
                        ],
                        providers: [PageLifeCycleService]
                    },] },
        ];
        return AWPageWrapperModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var EditorType = {
        Default: 0,
        // Default Editor supports Minimal set of functionality
        // [ bold | italic | underline | ordered | bullet | alignment]
        Full: 1,
        // The full list of functionality,
        TextFormat: 2,
        // Functionalities that affects text formatting.
        Custom: 3,
    };
    EditorType[EditorType.Default] = "Default";
    EditorType[EditorType.Full] = "Full";
    EditorType[EditorType.TextFormat] = "TextFormat";
    EditorType[EditorType.Custom] = "Custom";
    var /** @type {?} */ EDITOR_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RichTextAreaComponent; }),
        multi: true
    };
    var RichTextAreaComponent = (function (_super) {
        __extends(RichTextAreaComponent, _super);
        function RichTextAreaComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * A value used to save and read when rendering and updating this component
             */
            _this.value = '';
            /**
             * Expose editorType so that it can be used in this components template.
             */
            _this.EditorType = EditorType;
            _this.type = EditorType.Default;
            _this.styleClass = 'default-editor';
            return _this;
        }
        /**
         * @return {?}
         */
        RichTextAreaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                _super.prototype.registerFormControl.call(this, this.value);
                this.formControl.valueChanges.pipe(operators.distinctUntilChanged()).subscribe(function (val) {
                    _this.value = val;
                    _this.onModelChanged(_this.value);
                });
            };
        /**
         * Internal. Please see ControlValueAccessor
         */
        /**
         * Internal. Please see ControlValueAccessor
         * @param {?} value
         * @return {?}
         */
        RichTextAreaComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this.value) {
                    this.value = value;
                    this.formControl.setValue(value);
                }
            };
        RichTextAreaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-richtextarea',
                        template: "<ng-template [ngIf]=\"editable\">\n\n    <!-- Basic editor, also the default, which the most used features enabled. -->\n    <div *ngIf=\"type === EditorType.Default\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                    <span class=\"ql-formats\">\n                        <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                        <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                        <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                        <button class=\"ql-list\" value=\"ordered\"></button>\n                        <button class=\"ql-list\" value=\"bullet\"></button>\n                    </span>\n                <span class=\"ql-formats\">\n                            <button value=\"left\" selected></button>\n                            <button value=\"center\"></button>\n                            <button value=\"right\"></button>\n                            <button value=\"justify\"></button>\n                    </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Editor with all the features enabled -->\n    <div *ngIf=\"type === EditorType.Full\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\"></p-editor>\n    </div>\n\n    <!-- Editor with all Text formatting  -->\n    <div *ngIf=\"type === EditorType.TextFormat\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n            <span class=\"ql-format-group\">\n              <select title=\"Font\" class=\"ql-font\">\n                <option value=\"sans-serif\" selected=\"\">Sans Serif</option>\n                <option value=\"serif\">Serif</option>\n                <option value=\"monospace\">Monospace</option>\n              </select>\n              <select title=\"Size\" class=\"ql-size\">\n                <option value=\"10px\">Small</option>\n                <option value=\"13px\" selected=\"\">Normal</option>\n                <option value=\"18px\">Large</option>\n                <option value=\"32px\">Huge</option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                    <button class=\"ql-bold\" aria-label=\"Bold\"></button>\n                    <button class=\"ql-italic\" aria-label=\"Italic\"></button>\n                    <button class=\"ql-underline\" aria-label=\"Underline\"></button>\n                </span>\n                <span class=\"ql-format-group\">\n              <select title=\"Text Color\" class=\"ql-color\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\" selected=\"\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n              <span class=\"ql-format-separator\"></span>\n              <select title=\"Background Color\" class=\"ql-background\">\n                <option value=\"rgb(0, 0, 0)\" label=\"rgb(0, 0, 0)\"></option>\n                <option value=\"rgb(230, 0, 0)\" label=\"rgb(230, 0, 0)\"></option>\n                <option value=\"rgb(255, 153, 0)\" label=\"rgb(255, 153, 0)\"></option>\n                <option value=\"rgb(255, 255, 0)\" label=\"rgb(255, 255, 0)\"></option>\n                <option value=\"rgb(0, 138, 0)\" label=\"rgb(0, 138, 0)\"></option>\n                <option value=\"rgb(0, 102, 204)\" label=\"rgb(0, 102, 204)\"></option>\n                <option value=\"rgb(153, 51, 255)\" label=\"rgb(153, 51, 255)\"></option>\n                <option value=\"rgb(255, 255, 255)\" label=\"rgb(255, 255, 255)\" selected=\"\"></option>\n                <option value=\"rgb(250, 204, 204)\" label=\"rgb(250, 204, 204)\"></option>\n                <option value=\"rgb(255, 235, 204)\" label=\"rgb(255, 235, 204)\"></option>\n                <option value=\"rgb(255, 255, 204)\" label=\"rgb(255, 255, 204)\"></option>\n                <option value=\"rgb(204, 232, 204)\" label=\"rgb(204, 232, 204)\"></option>\n                <option value=\"rgb(204, 224, 245)\" label=\"rgb(204, 224, 245)\"></option>\n                <option value=\"rgb(235, 214, 255)\" label=\"rgb(235, 214, 255)\"></option>\n                <option value=\"rgb(187, 187, 187)\" label=\"rgb(187, 187, 187)\"></option>\n                <option value=\"rgb(240, 102, 102)\" label=\"rgb(240, 102, 102)\"></option>\n                <option value=\"rgb(255, 194, 102)\" label=\"rgb(255, 194, 102)\"></option>\n                <option value=\"rgb(255, 255, 102)\" label=\"rgb(255, 255, 102)\"></option>\n                <option value=\"rgb(102, 185, 102)\" label=\"rgb(102, 185, 102)\"></option>\n                <option value=\"rgb(102, 163, 224)\" label=\"rgb(102, 163, 224)\"></option>\n                <option value=\"rgb(194, 133, 255)\" label=\"rgb(194, 133, 255)\"></option>\n                <option value=\"rgb(136, 136, 136)\" label=\"rgb(136, 136, 136)\"></option>\n                <option value=\"rgb(161, 0, 0)\" label=\"rgb(161, 0, 0)\"></option>\n                <option value=\"rgb(178, 107, 0)\" label=\"rgb(178, 107, 0)\"></option>\n                <option value=\"rgb(178, 178, 0)\" label=\"rgb(178, 178, 0)\"></option>\n                <option value=\"rgb(0, 97, 0)\" label=\"rgb(0, 97, 0)\"></option>\n                <option value=\"rgb(0, 71, 178)\" label=\"rgb(0, 71, 178)\"></option>\n                <option value=\"rgb(107, 36, 178)\" label=\"rgb(107, 36, 178)\"></option>\n                <option value=\"rgb(68, 68, 68)\" label=\"rgb(68, 68, 68)\"></option>\n                <option value=\"rgb(92, 0, 0)\" label=\"rgb(92, 0, 0)\"></option>\n                <option value=\"rgb(102, 61, 0)\" label=\"rgb(102, 61, 0)\"></option>\n                <option value=\"rgb(102, 102, 0)\" label=\"rgb(102, 102, 0)\"></option>\n                <option value=\"rgb(0, 55, 0)\" label=\"rgb(0, 55, 0)\"></option>\n                <option value=\"rgb(0, 41, 102)\" label=\"rgb(0, 41, 102)\"></option>\n                <option value=\"rgb(61, 20, 102)\" label=\"rgb(61, 20, 102)\"></option>\n              </select>\n            </span>\n                <span class=\"ql-formats\">\n                <button class=\"ql-list\" value=\"ordered\"></button>\n                <button class=\"ql-list\" value=\"bullet\"></button>\n            </span>\n                <span class=\"ql-formats\">\n                    <button value=\"left\" selected></button>\n                    <button value=\"center\"></button>\n                    <button value=\"right\"></button>\n                    <button value=\"justify\"></button>\n            </span>\n            </p-header>\n        </p-editor>\n    </div>\n\n    <!-- Custom header Text Editor -->\n    <div *ngIf=\"type === EditorType.Custom\">\n        <p-editor [(ngModel)]=\"value\" [styleClass]=\"styleClass\" [style]=\"{'height':'180px'}\"\n                  [placeholder]=\"placeHolder\">\n            <p-header>\n                <ng-content select=\"custom-header\"></ng-content>\n            </p-header>\n        </p-editor>\n    </div>\n\n</ng-template>\n\n\n<ng-template [ngIf]=\"!editable\">\n    <aw-string [value]=\"value\"></aw-string>\n</ng-template>\n",
                        styles: ["/deep/ .ui-editor-toolbar{background-color:#f5f5f5;border:1px solid #d7d7d7}/deep/ p-editor:active /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-toolbar.ql-toolbar.ql-snow{border-color:#199de0}/deep/ p-editor:active /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:focus /deep/ .ui-editor-content.ql-container.ql-snow,/deep/ p-editor:hover /deep/ .ui-editor-content.ql-container.ql-snow{border-color:#199de0}"],
                        providers: [
                            EDITOR_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return RichTextAreaComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        RichTextAreaComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return FormRowComponent; }),] }] }
            ];
        };
        RichTextAreaComponent.propDecorators = {
            type: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return RichTextAreaComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWRichTextAreaModule = (function () {
        function AWRichTextAreaModule() {
        }
        AWRichTextAreaModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RichTextAreaComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            primeng.EditorModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            RichTextAreaComponent
                        ],
                        exports: [
                            RichTextAreaComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWRichTextAreaModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Allow developer to override default actions. Must have this declared before class when we
     * want to have this declaration inside the same file.
     */
    var SectionActionsComponent = (function () {
        function SectionActionsComponent() {
        }
        SectionActionsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-section-actions',
                        template: "<ng-content></ng-content> ",
                    },] },
        ];
        return SectionActionsComponent;
    }());
    /**
     *
     * Section component that implements a section of the page. It's an outline box that
     * has the ability to expand and hide its content.
     *
     * ```ts
     * \@Component({
     *    selector: 'rfx-details' ,
     *    template: `
     *         <aw-section title="Sourcing request info" (onEdit)="onStateChange($event)"
     *                          [editable]="true">
     *
     *                <m-context [object]="rfxEntity.headerInfo"
     *                          [operation]="this.editabilityState.headerInfoOp"
     *                          layout="Inspect"
     *                          uiGroup="HeaderGeneral">
     *                   <m-include-component></m-include-component>
     *               </m-context>
     *           </aw-section>
     *
     *
     *           <aw-section #supplierSection title="Selected suppliers" (onOpen)="onOpen()"
     *                [opened]="false">
     *               <supplier-profile-card></supplier-profile-card>
     *           </aw-section>
     *
     *           <aw-section title="RFQ Details"
     *                       description="Review and update information for suppliers to respond."
     *                       [disableClose]="true">
     *
     *               <aw-subsection title="Event timeline">
     *                   <aw-form-table [useFiveZone]="false" [editable]="true">
     *
     *                       <aw-form-row [label]="'Start Date'" [name]="'startDate'" [size]="'small'"
     *                                   [highlightRow]="true">
     *                           <aw-date-time
     *                               formatName="dateTime"
     *                               name="startDate" [value]="rfxEntity.created"
     *                               [showTime]="true"></aw-date-time>
     *                       </aw-form-row>
     *                   </aw-form-table>
     *               </aw-subsection>
     *          </aw-section>
     *    `
     *    })
     *    export class MyPage
     *    {
     *
     *        constructor ()
     *        {
     *        }
     *
     *    }
     *
     * ```
     *
     * Section component also supports editability modes and if enabled it will render action buttons
     * in the footer. Developer can also override default behavior and provide custom actions.
     *
     *
     * e.g:
     *
     * ```
     *      <aw-section [title]="title" [editable]="true"
     *                          (onCancelAction)="someHandler1($event)"
     *                          (onSaveAction)="someHandler2($event)" >
     *              section content
     *
     *
     *   </aw-section>
     *
     * ```
     *
     * or custom action buttons:
     *
     *
     * ```html
     *
     *       <aw-section-actions>
     *                      <aw-button >
     *                            ButtonTest1
     *                      </aw-button>
     *                      <aw-button>
     *                            ButtonTest2
     *                      </aw-button>
     *     </aw-section-actions>
     *
     * ```
     *
     *
     * There are two edit modes
     *  # Default
     *      Renders action buttons in the footers and emit actions to the application
     *
     *  # External
     *     No action buttons are shown in the footer and behavior is handled by application. Only event
     *     is emited.
     *
     *
     *  e.g:
     *
     *  ```ts
     *
     *      <aw-section title="User Information" (onEdit)="onAddSomething($event)"
     *                  [editable]="true" [editMode]="'external'" >
     *                  <div>
     *                      Content
     *                  </div>
     *      </aw-section>
     *
     *  ```
     *
     * Note: When using editing mode you have to call at the end of the editing cycle method
     * `completeEditing()` to commit editing which changes internal state of the Section.
     *
     *
     *
     */
    var SectionComponent = (function (_super) {
        __extends(SectionComponent, _super);
        function SectionComponent(element, env) {
            var _this = _super.call(this, env) || this;
            _this.element = element;
            _this.env = env;
            /**
             * Should this section be opened at the start. Default is opened.
             */
            _this.opened = true;
            /**
             * Whether this section can be closed or not.
             *
             */
            _this.disableClose = false;
            /**
             * Whether this section is in EditState or not.
             *
             * When in editing state and we show "Cancel / Save" button developer needs use this binding
             * to control the state.
             */
            _this.editState = false;
            /**
             * Current Editing mode. Tells the components if its its default behavior or driven by
             * application using this component.
             *
             * {\@see EditMode}
             *
             */
            _this.editMode = 'default';
            /**
             * Developer can provide custom Edit action icon that will appear in the right top corner
             */
            _this.actionIcon = 'icon-edit';
            /**
             * Event emitted when the section is fully opened.
             */
            _this.onOpen = new core.EventEmitter();
            /**
             * Event emitted when the section is fully closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Edit state to broadcast state of current section
             */
            _this.onEdit = new core.EventEmitter();
            /**
             * When in editing state and default buttons are rendered on click broadcast Cancel action
             */
            _this.onCancelAction = new core.EventEmitter();
            /**
             * When in editing state and default buttons are rendered on click broadcast Save action
             */
            _this.onSaveAction = new core.EventEmitter();
            _this.onEditingComplete = new core.EventEmitter();
            _this.editable = false;
            return _this;
        }
        /**
         * @return {?}
         */
        SectionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                // If I have not header, then I can't close the section.
                if (!this.isHeaderDisplayed()) {
                    this.disableClose = true;
                }
                // If I can't close the section, then it should default open.
                if (this.disableClose) {
                    this.opened = true;
                }
                // initialize the expanded state.
                this.expanded = this.opened;
            };
        /**
         * Don't display header area if I don't have title and description.
         *
         * @return {?}
         */
        SectionComponent.prototype.isHeaderDisplayed = /**
         * Don't display header area if I don't have title and description.
         *
         * @return {?}
         */
            function () {
                return (core$1.isPresent(this.title) || core$1.isPresent(this.description));
            };
        /**
         * Css Class that control the look and feel for section component.
         */
        /**
         * Css Class that control the look and feel for section component.
         * @return {?}
         */
        SectionComponent.prototype.aClass = /**
         * Css Class that control the look and feel for section component.
         * @return {?}
         */
            function () {
                if (!this.isHeaderDisplayed()) {
                    return 'section-no-header';
                }
                return '';
            };
        /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         */
        /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         * @param {?} $event
         * @return {?}
         */
        SectionComponent.prototype.onEditAction = /**
         * Since we introduced buttons and editState the decision on when to exit editing mode
         * should be on the developer using this component therefore only startEditing
         *
         * @param {?} $event
         * @return {?}
         */
            function ($event) {
                // when in editing make sure we dont switch state as there can be some Form errors
                // which needs to be handled by developer and only then change the editState
                if (!this.editState) {
                    this.editState = !this.editState;
                    var /** @type {?} */ state = (this.editState) ? 'inEdit' : 'notInEdit';
                    this.onEdit.emit(state);
                    this.open();
                }
                // prevent the original event from bubbling up. Because the edit icon is inside
                // the header. If the click even is bubbled up, this event will cause the section to
                // expand or collapse.
                if (core$1.isPresent($event.event)) {
                    $event.event.stopPropagation();
                    $event.event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        SectionComponent.prototype.hasDescription = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.description);
            };
        /**
         * Open this section, if it's already open, will do nothing.
         */
        /**
         * Open this section, if it's already open, will do nothing.
         * @param {?=} event
         * @return {?}
         */
        SectionComponent.prototype.open = /**
         * Open this section, if it's already open, will do nothing.
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                if (!this.expanded) {
                    this.accordionTab.toggle(event);
                }
            };
        /**
         * Close this section, if it's already close, will do nothing.
         */
        /**
         * Close this section, if it's already close, will do nothing.
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.close = /**
         * Close this section, if it's already close, will do nothing.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.expanded) {
                    this.accordionTab.toggle(event);
                }
            };
        /**
         * Callback to be invoked when accordion is opened
         *
         */
        /**
         * Callback to be invoked when accordion is opened
         *
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.onSectionOpen = /**
         * Callback to be invoked when accordion is opened
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.expanded = true;
                this.onOpen.emit('open');
            };
        /**
         * Callback to be invoked when accordion is closed
         *
         */
        /**
         * Callback to be invoked when accordion is closed
         *
         * @param {?} event
         * @return {?}
         */
        SectionComponent.prototype.onSectionClose = /**
         * Callback to be invoked when accordion is closed
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.expanded = false;
                this.onClose.emit('close');
            };
        /**
         *
         * Tells us if we need to render application defined custom actions
         *
         */
        /**
         *
         * Tells us if we need to render application defined custom actions
         *
         * @return {?}
         */
        SectionComponent.prototype.hasCustomActions = /**
         *
         * Tells us if we need to render application defined custom actions
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.customActions);
            };
        /**
         * Emit the editing state back to non-editable
         */
        /**
         * Emit the editing state back to non-editable
         * @return {?}
         */
        SectionComponent.prototype.completeEditing = /**
         * Emit the editing state back to non-editable
         * @return {?}
         */
            function () {
                this.editState = false;
                this.onEditingComplete.emit(this.editState);
            };
        SectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-section',
                        template: "<div class=\"ui-g-12 section-container\"\n     [class.editing]=\"editable && editState && editMode === 'default'\">\n\n    <p-accordion (onOpen)=\"onSectionOpen($event)\" (onClose)=\"onSectionClose($event)\"\n                 [styleClass]=\"aClass()\">\n        <p-accordionTab #accordionTab [selected]=\"opened\" [disabled]=\"disableClose\">\n            <p-header>\n                <!-- title and description -->\n                <div class=\"section-header-container\">\n                    <div class=\"section-title\">{{title}}</div>\n                    <div *ngIf=\"hasDescription()\" class=\"section-description\">{{description}}</div>\n\n                    <!-- actions: Hide when in editing and editMode is default -->\n                    <div *ngIf=\"(editable && !editState && editMode === 'default') ||\n                        (editable && editMode === 'external')\"\n                         class=\"section-actions\">\n                        <aw-hyperlink (action)=\"onEditAction($event)\">\n                            <i class=\"sap-icon section-edit-action\" [ngClass]=\"actionIcon\"></i>\n                        </aw-hyperlink>\n                    </div>\n                </div>\n            </p-header>\n\n            <ng-content></ng-content>\n        </p-accordionTab>\n    </p-accordion>\n    <!--\n        need to put it outside of p-accordion otherwise button will inherit different\n        color scheme\n    -->\n    <div class=\"section-footer-container\" *ngIf=\"editable && editState &&\n            editMode === 'default'\">\n        <div class=\"footer-actions\">\n\n            <ng-template [ngIf]=\"!hasCustomActions()\">\n                <aw-button [style]=\"'secondary'\" size=\"small\"\n                           (action)=\"onCancelAction.emit($event)\">\n                    Cancel\n                </aw-button>\n                <aw-button size=\"small\" (action)=\"onSaveAction.emit($event)\">\n                    Save\n                </aw-button>\n            </ng-template>\n\n            <ng-content select=\"aw-section-actions\"></ng-content>\n        </div>\n    </div>\n</div>\n",
                        styles: [".section-header-container{position:relative}.section-container{margin:10px 0;background-color:#fff;padding:.2em .5em;border:2px dashed transparent}.section-container.editing{border-color:#199de0}.section-container ::ng-deep .ui-accordion-header>a{display:flex}.section-container ::ng-deep .ui-accordion-header>a .ui-accordion-toggle-icon{flex:0 0 30px;padding-top:2px}.section-container ::ng-deep .ui-accordion-header>a p-header{flex:1 0}.section-container /deep/ .ui-accordion-header.ui-state-disabled{opacity:1}.section-title{font-size:1.1em}.section-description{font-size:.9em;padding:.6em 0 .2em}.section-footer-container{margin:1em 2em 0;padding:.8em 0 1.5em .8em;border-top:1px solid #d7d7d7}.section-footer-container .footer-actions{display:inline-block;text-align:right;width:100%}.section-actions{position:absolute;top:0;right:0;z-index:1}.section-actions /deep/ a.link,.section-actions /deep/ a.link:hover{padding:0;text-decoration:none}.section-edit-action{font-size:1.5em;position:relative;padding:.1em 0 .1em .5em;cursor:pointer}.section-edit-action.icon-edit{font-size:1.4em}.section-container /deep/ .ui-accordion-header{color:#363636;border:none;background:#fff!important;padding:0 1em}.section-container /deep/ .ui-accordion-content{border:none;padding:1em 2em}.section-container /deep/ .ui-accordion-header /deep/ a[role=tab]{padding:.75em 0;text-decoration:none}.section-container /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:1px solid #d7d7d7;color:#363636}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header{height:1px}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header.ui-state-active /deep/ a[role=tab]{border-bottom:none}.section-container /deep/ .section-no-header /deep/ .ui-accordion-header .section-edit-action{cursor:pointer!important}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down,:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right{font-family:\"SAP icon fonts\";font-size:1.1em;top:.8em;left:.1em;color:#767676;margin-top:0}:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .fa,:host /deep/ .ui-accordion-header.ui-state-disabled /deep/ .pi{display:none}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-right:before{content:\"\\e1ed\"}:host /deep/ .ui-accordion-header /deep/ .pi.pi-caret-down:before{content:\"\\e1ef\"}"]
                    },] },
        ];
        /** @nocollapse */
        SectionComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment }
            ];
        };
        SectionComponent.propDecorators = {
            title: [{ type: core.Input }],
            description: [{ type: core.Input }],
            opened: [{ type: core.Input }],
            disableClose: [{ type: core.Input }],
            editState: [{ type: core.Input }],
            editMode: [{ type: core.Input }],
            actionIcon: [{ type: core.Input }],
            onOpen: [{ type: core.Output }],
            onClose: [{ type: core.Output }],
            onEdit: [{ type: core.Output }],
            onCancelAction: [{ type: core.Output }],
            onSaveAction: [{ type: core.Output }],
            onEditingComplete: [{ type: core.Output }],
            accordionTab: [{ type: core.ViewChild, args: ['accordionTab',] }],
            customActions: [{ type: core.ContentChild, args: [SectionActionsComponent,] }]
        };
        return SectionComponent;
    }(BaseComponent));
    var SubSectionComponent = (function () {
        function SubSectionComponent() {
        }
        SubSectionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-subsection',
                        template: "\n                    <h4 class=\"subsection-title\">{{title}}</h4>\n                    <ng-content></ng-content>\n                 ",
                        styles: ['.subsection-title {color: #363636; }']
                    },] },
        ];
        SubSectionComponent.propDecorators = {
            title: [{ type: core.Input }]
        };
        return SubSectionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWSectionModule = (function () {
        function AWSectionModule() {
        }
        AWSectionModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SectionComponent,
                            SubSectionComponent,
                            SectionActionsComponent
                        ],
                        imports: [
                            common.CommonModule,
                            primeng.AccordionModule,
                            core$1.AribaCoreModule,
                            AWStringFieldModule,
                            AWHyperlinkModule,
                            AWButtonModule,
                            primeng.SharedModule
                        ],
                        entryComponents: [
                            SectionComponent,
                            SubSectionComponent,
                            SectionActionsComponent
                        ],
                        exports: [
                            SectionComponent,
                            SectionActionsComponent,
                            SubSectionComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWSectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * DTColumn represent single column including header and its body. Each column has its own
     * rendererTemplate which a entry to this component.
     *
     * Keeping this separate from the datatable where DT is not really aware what it is rendering,
     * it allows us more flexibility in terms of different type of column inheriting from this
     * one.. Such as:
     *  DTRowDetail  column
     *  DTSingleSelection column
     *  DTMultiSelection column
     *
     * This way we don't do IF/THEN/ELSE inside the datatable and trying to create different cases.
     *
     *  Then later on this will let us create additional logic for the pivotal layout. Because DT
     *  does know anything about the type of the column so whatever is added to the DT.columns it
     *  will be rendered.
     *
     *
     *  Columns can be also frozen meaning if the content overflows they dont scroll. To make the
     *  column frozen we need to use [frozen] binding and se it to TRUE plus it requires a [width]
     *  binding to be set (in px).
     *  We need this to be able to properly position the second table which is changed to absolute
     *  positioning.
     *
     *
     *
     */
    var DTColumn2Component = (function (_super) {
        __extends(DTColumn2Component, _super);
        function DTColumn2Component(env, domHandler) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            /**
             *
             * Cell alignment. It inserts regular align attribute to the table cell
             *
             */
            _this.align = 'left';
            /**
             *
             * If false applies dt-is-hidden style that hides the column
             *
             */
            _this.isVisible = true;
            /**
             * Sorting direction
             *
             */
            _this.sortOrdering = 'descending';
            /**
             * Tells the template if whether to render a label
             *
             */
            _this.showColumnLabel = true;
            /**
             *
             * See AWDataTable
             *
             */
            _this.showSubHeader = false;
            /**
             *
             * Used together with cell selectionMode to tell which column is selectable
             *
             */
            _this.selectable = false;
            /**
             * Use globally defined HEADER template for current column
             *
             */
            _this.useGlobalHeader = true;
            /**
             * Use globally defined SubHeader template for current column
             *
             */
            _this.useGlobalSubHeader = true;
            /**
             * Use globally defined body template
             *
             */
            _this.useGlobalBody = true;
            /**
             * Tells if the column is data column  - if it is rendering data or just a label or some
             * control
             *
             * This is important when calculating a column span and we need to know which columns are or
             * will be just for selection controls and which holds data
             */
            _this.isDataColumn = true;
            /**
             * Identifies column that will not scroll horizontally with other columns. Column is
             * frozen.
             *
             * For such columns that are marked as frozen binding [width] is required.
             *
             */
            _this.frozen = false;
            _this.maxWidthPx = 0;
            _this.minWidthPx = 0;
            _this.widthPx = 0;
            _this.widestCell = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
                if (core$1.isBlank(this.bodyTemplate) && this.useGlobalBody) {
                    this.bodyTemplate = this.dt.bodyTemplate;
                }
                if (core$1.isBlank(this.headerTemplate) && this.useGlobalHeader) {
                    this.headerTemplate = this.dt.headerTemplate;
                }
                if (core$1.isBlank(this.subHeaderTemplate) && this.useGlobalSubHeader) {
                    this.subHeaderTemplate = this.dt.subHeaderTemplate;
                }
                if (core$1.isBlank(this.bodyClassFn)) {
                    this.bodyClassFn = this.dt.bodyClassFn;
                }
                if (core$1.isBlank(this.key) && core$1.isBlank(this.label)) {
                    throw new Error('Missing required binding: ' +
                        '[key] or [label] bindings must be used at minimum');
                }
                // To be able to position second DT we require [width] to be set as well
                if (this.frozen && core$1.isBlank(this.width)) {
                    throw new Error('Missing required binding [width]: ' +
                        'when [frozen]=true then [width] binding needs to be specified.');
                }
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // need to deffer this and trigger change detection otherwise I get
                // value was changed after it was checked error
                setTimeout(function () {
                    _this.maxWidthPx = _this.widthToPx(_this.maxWidth);
                    _this.minWidthPx = _this.widthToPx(_this.minWidth);
                    _this.widthPx = _this.widthToPx(_this.width);
                });
            };
        /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         */
        /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         * @param {?} event
         * @param {?} element
         * @return {?}
         */
        DTColumn2Component.prototype.handleHeaderClick = /**
         *
         * When cell selectionMode is enabled this method is triggered when we click on header.
         * It delegates the call to the DT where it toggles currently selected value
         *
         * @param {?} event
         * @param {?} element
         * @return {?}
         */
            function (event, element) {
                if (this.isHeaderSelectable()) {
                    this.dt.onHeaderSelectionChange(element, this);
                }
                else if (this.sortable) {
                    this.sort(event);
                }
                event.preventDefault();
            };
        /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         */
        /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         * @param {?} event
         * @return {?}
         */
        DTColumn2Component.prototype.sort = /**
         *
         * Todo: Implement our own sorting mechanism once we extract the sorting logic to its component
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.sortable) {
                    return;
                }
                var /** @type {?} */ targetNode = event.target;
                if (this.domHandler.hasClass(targetNode, 'dt-u-sortable') ||
                    this.domHandler.hasClass(targetNode, 'dt-col-title') ||
                    this.domHandler.hasClass(targetNode, 'dt-col-sortable-icon')) {
                    if (core$1.isPresent(this.dt.sortColumn) && this.dt.sortColumn.key === this.key) {
                        this.sortOrder = this.sortOrder * -1;
                        this.sortOrdering = this.dt.sortOrderingForNumber(this.sortOrder);
                    }
                    else {
                        this.dt.sortColumn = this;
                    }
                    this.dt.dataSource.state.sortKey = this.key;
                    this.dt.dataSource.state.sortOrder = this.dt.sortOrderingForString(this.sortOrdering);
                    this.dt.sortSingle();
                }
                this.dt.updateDataToRender();
            };
        /**
         * Calculated style class based on data
         *
         *
         */
        /**
         * Calculated style class based on data
         *
         *
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.dynamicBodyClass = /**
         * Calculated style class based on data
         *
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ dynClass = core$1.isPresent(this.bodyClassFn)
                    ? this.bodyClassFn.apply(this.dt.context, [this, item]) : '';
                if (core$1.isPresent(this.bodyStyleClass)) {
                    dynClass += ' ' + this.bodyStyleClass;
                }
                else if (core$1.isPresent(this.styleClass)) {
                    dynClass += ' ' + this.styleClass;
                }
                return dynClass;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.isRowSelectable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isPresent(this.dt.isRowSelectable)) {
                    return this.dt.isRowSelectable(item);
                }
                return false;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTColumn2Component.prototype.isCellSelectable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.dt.selectionMode === 'cell' && this.isRowSelectable(item) && this.selectable;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.isHeaderSelectable = /**
         * @return {?}
         */
            function () {
                return this.dt.selectionMode === 'cell' && this.selectable;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.getSortOrder = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ order = 0;
                if (core$1.isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key) {
                    order = this.dt.sortColumn.sortOrder;
                }
                return order;
            };
        /**
         * @return {?}
         */
        DTColumn2Component.prototype.isSorted = /**
         * @return {?}
         */
            function () {
                if (!this.sortable) {
                    return false;
                }
                return core$1.isPresent(this.dt.sortColumn) && this.key === this.dt.sortColumn.key;
            };
        /**
         * @param {?} table
         * @return {?}
         */
        DTColumn2Component.prototype.initialize = /**
         * @param {?} table
         * @return {?}
         */
            function (table) {
                this.dt = table;
                if (core$1.isPresent(this.dt.initialSortKey) && this.dt.initialSortKey === this.key) {
                    this.sortable = true;
                    this.sortOrder = this.dt.sortOrderingForString(this.dt.initialSortOrder);
                    this.dt.sortColumn = this;
                }
            };
        /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         */
        /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         * @param {?} myIndex
         * @return {?}
         */
        DTColumn2Component.prototype.postInitialize = /**
         * This method is called at the end of the view init cycle from the dt.ngAfterViewChecked.
         *
         * In case we use MaxWidth directive we set new width once for all columsn
         * @param {?} myIndex
         * @return {?}
         */
            function (myIndex) {
                var _this = this;
                var /** @type {?} */ colIndex = myIndex + 1;
                var /** @type {?} */ table;
                if (this.dt.hasFrozenColumns()) {
                    table = ((this.dt)).el
                        .nativeElement.querySelector('.dt-body-frozen table');
                }
                else {
                    table = ((this.dt)).el.nativeElement.querySelector('table');
                }
                if (this.widestCell > 0) {
                    var /** @type {?} */ all = table.querySelectorAll('tr th:nth-child(' + colIndex + '), ' +
                        'tr td:nth-child(' + colIndex + ')').forEach(function (node) {
                        node.style.width = _this.widestCell + 'px';
                    });
                }
            };
        /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         */
        /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         * @return {?}
         */
        DTColumn2Component.prototype.isValueColumn = /**
         * You either use this binding directly and say its datacolumn or when there is a [key]
         * biding we know it refers to some field.
         *
         * @return {?}
         */
            function () {
                return (core$1.isPresent(this.isDataColumn) && core$1.BooleanWrapper.isTrue(this.isDataColumn)) ||
                    core$1.isPresent(this.key);
            };
        /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         */
        /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         * @param {?} cell
         * @param {?} level
         * @return {?}
         */
        DTColumn2Component.prototype.indentForControl = /**
         * When we are in outline mode  we need to also indend each selection control accordingly.
         *
         * indent - 1 > only offset with
         * indent
         * @param {?} cell
         * @param {?} level
         * @return {?}
         */
            function (cell, level) {
                if (this.dt.isOutline() && level > 0 && cell.offsetWidth > 0
                    && core$1.isPresent(cell.nextElementSibling)) {
                    var /** @type {?} */ outlineNodePadding = parseInt(getComputedStyle(cell.nextElementSibling).paddingLeft) || 0;
                    // 1st level is pushed as root
                    if (this.dt.pushRootSectionOnNewLine) {
                        return (level === 1) ? null : (this.dt.indentationPerLevel * level)
                            - outlineNodePadding;
                    }
                    else {
                        return (this.dt.indentationPerLevel * level) + outlineNodePadding;
                    }
                }
                return null;
            };
        /**
         *
         * Internal
         * @param {?} width
         * @return {?}
         */
        DTColumn2Component.prototype.widthToPx = /**
         *
         * Internal
         * @param {?} width
         * @return {?}
         */
            function (width) {
                var /** @type {?} */ px;
                if (core$1.isPresent(width)) {
                    if (width.indexOf('%') > 0) {
                        var /** @type {?} */ nonPc = parseFloat(width) / 100;
                        px = nonPc * ((this.dt)).el.nativeElement.offsetWidth;
                    }
                    else {
                        px = parseFloat(width);
                    }
                }
                return px;
            };
        DTColumn2Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-column2',
                        template: "<!--\n    To make it more readable Each Column type has its own rendering template instead of putting\n    all this into datatable as this is more responsibility of the column. And the main goal\n    was try to be modular as possible. When There will be different types of columns\n\n    - Regular DTColumn (current implementation),\n    - SelectionColumn (Single/Multi select) - todo,\n    - DetailRow column, then pivotal collumn to render row/column/detail attributes - todo.\n\n    When implementing new column type you just inherit this DTColumnComponent and provide your\n    own rendering template and DT take care of the rest.\n\n    todo: We have SingleSelect, Multiselect rendering template that is Added programatically\n    todo: We have pivotal rendering template\n\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex, data: dataToRender,\n                 rowIndex:rowIndex}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<!--\n    Templates for header columns. Here we are rendering two types. Header and Subheader that we\n    usually use here as some kind of summary columns. Not really having summary at the bottom like other\n    DT.\n\n    TH column and their text are usually unselectable and most of these were inherited from\n    original PrimeNg DT even not many things got left after we refactor this but the idea is the\n    same.\n\n    Each cell has its dt-cell-def class that sets default styling like font, background, alignment\n    padding, etcs..\n\n\n-->\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\" let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <th #headerCell1 [class]=\"headerStyleClass||styleClass\" *ngIf=\"!isSubHeader\"\n        (click)=\"handleHeaderClick($event, headerCell1)\"\n        [ngClass]=\"{'dt-is-default dt-u-unselectable-text' :true,\n                    'dt-cell-def': dt.selectionMode !== 'cell' || (!dt.isOutline() || !dt.pivotalLayout),\n                    'dt-u-sortable': sortable,\n                    'dt-is-active': isSorted(),\n                    'dt-is-hidden': !isVisible}\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [attr.tabindex]=\"sortable ? 1 : null\"\n        [maxWidth]=\"maxWidthPx\"\n    >\n\n        <ng-template [ngIf]=\"dt.headerFilterTemplate && columnIndex === 0 \">\n            <ng-container *ngTemplateOutlet=\"dt.headerFilterTemplate\">\n            </ng-container>\n        </ng-template>\n        <!--\n            when cell are selectable we need two version where one wrap the cell content in div\n        -->\n        <ng-template [ngIf]=\"isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"selectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isHeaderSelectable()\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableHeaderCell; context: {$implicit: this}\">\n            </ng-container>\n        </ng-template>\n    </th>\n\n    <th #headerCell2 [class]=\"headerStyleClass||styleClass\" *ngIf=\"isSubHeader\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{'dt-is-default dt-cell-def dt-sub-header dt-u-unselectable-text':true}\"\n        [maxWidth]=\"maxWidthPx\">\n\n        <span class=\"dt-col-title\" *ngIf=\"dt.showSubHeader && subHeaderTemplate\">\n            <ng-container *ngTemplateOutlet=\"subHeaderTemplate;\n                    context: {$implicit: this, rowData: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </span>\n    </th>\n</ng-template>\n\n\n<!--\n    Template for the body = the TD. For the body and we might want to do the same for header we\n    allow to have calculated body class that comes from the application. So based on the data types\n    you might want to apply different class in order to apply custom styling.\n-->\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        (click)=\"dt.onCellSelectionChange(cell, this, data)\"\n        [attr.width]=\"width\"\n        [attr.align]=\"align\"\n        [ngClass]=\"{ 'dt-is-default': true,\n        'dt-cell-def': !isCellSelectable(data),\n        'dt-is-hidden': !isVisible}\"\n        [maxWidth]=\"maxWidthPx\">\n\n        <!--\n            Since we need to support cell selection when we need to draw border around it\n            We are wrapping such sells with div which gives us better flexibility\n        -->\n        <ng-template [ngIf]=\"isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"selectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex }\">\n            </ng-container>\n\n        </ng-template>\n\n\n        <ng-template [ngIf]=\"!isCellSelectable(data)\">\n            <ng-container *ngTemplateOutlet=\"nonSelectableBodyCell;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n            </ng-container>\n        </ng-template>\n\n    </td>\n</ng-template>\n\n<!--\n    Todo: create better solution instead of using different template create directive that wraps\n    it with the div conditionally\n-->\n<ng-template #selectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isHeaderSelected(this)}\">\n        <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableHeaderCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"headerCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #headerCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && !headerTemplate\">\n                {{label}}\n    </span>\n\n    <span class=\"dt-col-title\" *ngIf=\"showColumnLabel && headerTemplate\">\n                    <ng-container *ngTemplateOutlet=\"headerTemplate;\n                        context: {$implicit: this, rowData: data, rowIndex: rowIndex }\">\n                    </ng-container>\n    </span>\n\n    <span class=\"dt-col-sortable-icon sap-icon icon-sort\" *ngIf=\"sortable\"\n          [ngClass]=\"{'icon-sort-descending': (getSortOrder() == -1),\n                           'icon-sort-ascending': (getSortOrder() == 1)}\">\n    </span>\n</ng-template>\n\n\n<ng-template #selectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <div class=\"dt-cell-def-selectable\"\n         [ngClass]=\"{'dt-cell-selected': dt.isBodyCellSelected(this, data)}\">\n        <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n        </ng-container>\n    </div>\n</ng-template>\n\n\n<ng-template #nonSelectableBodyCell let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <ng-container *ngTemplateOutlet=\"bodyCellContent;\n                        context: {$implicit: this, data: data, rowIndex: rowIndex}\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #bodyCellContent let-data=\"data\" let-rowIndex=\"rowIndex\">\n    <!--\n           when no template is used use our FieldPath to access the object value based on the\n           key binding\n        -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"!bodyTemplate\">\n            {{dt.getValue(data, key)}}\n        </span>\n\n\n    <!--\n        In case application wants to provide their own cell component they use\n        #body ng-template to do so.\n    -->\n    <span class=\"dt-col-cell-data\" *ngIf=\"bodyTemplate\">\n            <ng-container *ngTemplateOutlet=\"bodyTemplate;\n            context: {$implicit: this, rowData: data, rowIndex: rowIndex}\"></ng-container>\n        </span>\n</ng-template>\n",
                        styles: [".dt-sortable-col{cursor:pointer}.dt-col-sortable-icon{display:inline-block;margin-left:.125em}th.dt-cell-def{font-weight:400;color:#4a4a4a}th.dt-is-default{background-color:#f2f2f2;white-space:nowrap}th.dt-is-default.dt-cell-def:not(.dt-sub-header){border-bottom-color:#f2f2f2}th.dt-sub-header{background-color:#fff}th .dt-cell-selected{border-color:#58b957}td .dt-cell-selected{border-left-color:#4f9fcf}.dt-root-section .dt-selection-column,.dt-selection-column{width:46px;padding:0 12px}.dt-pivot-layout td.dt-selection-column,th.dt-selection-column{border-right-color:transparent}thead tr:first-child th{border-top-color:transparent}tbody tr:last-child:not(.dt-drag-row-bottom) td{border-bottom-color:transparent}td:first-child,th:first-child{border-left-color:transparent}td:last-child,th:last-child{border-right-color:transparent}tbody .dt-drag-row-top>td{background:linear-gradient(0deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-bottom>td{background:linear-gradient(180deg,#fff 0,#fff 97%,#0271d2 100%)}tbody .dt-drag-row-both>td{background:linear-gradient(0deg,#0271d2 0,#fff 3%,#fff 97%,#0271d2 100%)}tbody .dt-row-dragging>td{background-color:#ececec;color:#b9b9b9}tbody .dt-row-dragging .ui-state-active{opacity:.5;cursor:not-allowed}"],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTColumn2Component.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        DTColumn2Component.propDecorators = {
            label: [{ type: core.Input }],
            key: [{ type: core.Input }],
            align: [{ type: core.Input }],
            bodyClassFn: [{ type: core.Input }],
            isVisible: [{ type: core.Input }],
            sortable: [{ type: core.Input }],
            sortOrdering: [{ type: core.Input }],
            showColumnLabel: [{ type: core.Input }],
            showSubHeader: [{ type: core.Input }],
            headerStyleClass: [{ type: core.Input }],
            bodyStyleClass: [{ type: core.Input }],
            selectable: [{ type: core.Input }],
            useGlobalHeader: [{ type: core.Input }],
            useGlobalSubHeader: [{ type: core.Input }],
            useGlobalBody: [{ type: core.Input }],
            isDataColumn: [{ type: core.Input }],
            frozen: [{ type: core.Input }],
            maxWidth: [{ type: core.Input }],
            minWidth: [{ type: core.Input }],
            rendererTemplate: [{ type: core.ViewChild, args: ['renderingTemplate',] }],
            headerTemplate: [{ type: core.ContentChild, args: ['header',] }],
            subHeaderTemplate: [{ type: core.ContentChild, args: ['subHeader',] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['body',] }]
        };
        return DTColumn2Component;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An datatable header area.
     *
     * See {\@link DataTableComponent} for more explanation.
     */
    var DTHeaderComponent2 = (function () {
        function DTHeaderComponent2() {
        }
        DTHeaderComponent2.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-header2',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return DTHeaderComponent2;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Custom column implementation to render detail row spaning its column across whole table width.
     *
     *
     */
    var DTDetailRowComponent = (function (_super) {
        __extends(DTDetailRowComponent, _super);
        function DTDetailRowComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            /**
             *
             * tells if we need to render a line between item row and its detail
             *
             */
            _this.showRowLine = true;
            return _this;
        }
        /**
         * @return {?}
         */
        DTDetailRowComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // just to get around the check in parent class
                this.key = '';
                this.isVisible = !this.dt.isOutline() || !this.dt.pivotalLayout;
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * Check if we need to keep some leading TDs
         *
         */
        /**
         * Check if we need to keep some leading TDs
         *
         * @return {?}
         */
        DTDetailRowComponent.prototype.visibleLeadingCols = /**
         * Check if we need to keep some leading TDs
         *
         * @return {?}
         */
            function () {
                return this.dt.numberOfColsBeforeData - (this.dt.hasInvisibleSelectionColumn() ? 1 : 0);
            };
        /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         */
        /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         * @param {?} item
         * @return {?}
         */
        DTDetailRowComponent.prototype.showDetailRow = /**
         *
         * Check if we can show detail row/column using either [isVisible] or [isVisibleFn] bindings.
         * Here can hook on application level custom method to decide if current item has detail row
         * or not
         *
         * Or we can use isVisible=true to tell all row have detail row
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ isVisible = this.isVisible;
                if (core$1.isPresent(this.isVisibleFn)) {
                    isVisible = this.isVisibleFn.apply(this.dt.context, [this, item]);
                }
                return isVisible;
            };
        DTDetailRowComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-detail-column',
                        template: "<!--\n    Renders application defined detail column. This template just renders a detail row and\n    not expansion control. This is implemented by different DtColumn implementation and its added\n    (will be) added programmatically during column initialization\n-->\n<ng-template #renderingTemplate let-column=\"column\" let-rowData=\"data\">\n\n    <tr #detailRowElement class=\"dt-body-row dt-detail-row\">\n\n        <td *ngIf=\"dt.hasInvisibleSelectionColumn()\" width=\"1px\"></td>\n        <td *ngIf=\"visibleLeadingCols() > 0\" colspan=\"visibleLeadingCols()\" width=\"1px\">\n            &nbsp;&nbsp;\n        </td>\n        <td [attr.colspan]=\"dt.startOfFirstDataColumn\" [class]=\"dynamicBodyClass(rowData)\"\n            [ngClass]=\"{ 'dt-is-default dt-cell-def': true}\">\n\n            <ng-container\n                *ngTemplateOutlet=\"bodyTemplate; context:{$implicit: this, rowData:rowData}\">\n            </ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n",
                        styles: [""],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTDetailRowComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        DTDetailRowComponent.propDecorators = {
            isVisibleFn: [{ type: core.Input }],
            showRowLine: [{ type: core.Input }]
        };
        return DTDetailRowComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     *
     *
     *
     */
    var DTDetailRowExpanderComponent = (function (_super) {
        __extends(DTDetailRowExpanderComponent, _super);
        function DTDetailRowExpanderComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // we dont want to show the row/column unless application says so
            // we dont want to show the row/column unless application says so
            _this.isVisible = false;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        /**
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // just to get around the check in parent class
                this.key = '';
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.toggleExpansion = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                this.dt.detailRowExpansionState.toggle(item);
                event.stopPropagation();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DTDetailRowExpanderComponent.prototype.calculateStyleClass = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.dt.detailRowExpansionState.isExpanded(item) ?
                    'icon-slim-arrow-down' : 'icon-slim-arrow-right';
            };
        DTDetailRowExpanderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-detail-column-expand',
                        template: "<!--\n   Special column that renders expand/collapse control for detail row when detail row is enabled.\n\n   Just like for the other column it renders header section as well as body section with\n   expand control to toggle the expansion\n\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\" let-columnIndex=\"columnIndex\" let-rowIndex=\"rowIndex\">\n\n\n    <ng-template [ngIf]=\"isHeader && !isSubHeader\">\n        <th #headerCell1 [class]=\"headerStyleClass||styleClass\"\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-cell-def' :true,\n                        'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender)}\">\n        </th>\n\n    </ng-template>\n\n    <ng-template [ngIf]=\"!isHeader && !isSubHeader\">\n        <td #cell\n            class=\"dt-row-cell-expando\"\n            [ngClass]=\"{ 'dt-is-default': true,\n                    'dt-cell-def': !isCellSelectable(dataToRender),\n                    'dt-det-row-expanded': dt.detailRowExpansionState.isExpanded(dataToRender),\n                    'dt-det-row-with-ln' : dt.rowDetailColumn.showRowLine}\">\n\n            <span (click)=\"toggleExpansion($event, dataToRender)\"\n                  class=\"dt-det-row-expand sap-icon\"\n                  [ngClass]=\"calculateStyleClass(dataToRender)\">\n\n            </span>\n\n        </td>\n\n    </ng-template>\n\n\n</ng-template>\n\n",
                        styles: [".dt-row-cell-expando{width:14px;text-align:right;padding:17px 5px 17px 17px;border-right-color:transparent}.dt-row-cell-expando .dt-det-row-expand{cursor:pointer;line-height:21px}td.dt-det-row-expanded:not(.dt-det-row-with-ln),td.dt-det-row-expanded:not(.dt-det-row-with-ln)~td{border-bottom-color:transparent}"],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTDetailRowExpanderComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTDetailRowExpanderComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * @license
     * Copyright 2017 SAP Ariba
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     *
     *
     */
    var /** @type {?} */ DragEvents = ['mousedown', 'dragstart', 'dragover', 'dragenter', 'dragleave',
        'drop', 'dragend'];
    /** @enum {string} */
    var DragDirection = {
        None: 'none',
        Up: 'dt-drag-row-top',
        Down: 'dt-drag-row-bottom',
        Middle: 'dt-drag-row-both',
    };
    /** @enum {string} */
    var DropPosition = {
        Before: 'before',
        After: 'after',
        Into: 'into',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Concrete DataSource implementation for Datatable which defines state and column definition that
     * can programmatically modify rendered columns (if provided) and method for inserting and
     * and deleting records;
     *
     * All operations dealing with data use Observable<T> and instant() method to retrieve current
     * state is not implemented.
     *
     *
     */
    var DT2DataSource = (function (_super) {
        __extends(DT2DataSource, _super);
        function DT2DataSource(dataProviders, finders) {
            var _this = _super.call(this, dataProviders, finders) || this;
            _this.dataProviders = dataProviders;
            _this.finders = finders;
            _this.initialized = false;
            _this.state = Datatable2State.create();
            _this.debugTime = new Date().getTime();
            return _this;
        }
        /**
         * @param {...?} args
         * @return {?}
         */
        DT2DataSource.prototype.init = /**
         * @param {...?} args
         * @return {?}
         */
            function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (core$1.isBlank(args) || args.length !== 1 && !isDTInitParams(args[0])) {
                    throw new Error('You need to initialize DS with (DSChooserInitParams)');
                }
                var /** @type {?} */ init = args[0];
                // use existing or find best match for dataProvider
                this.dataProvider = core$1.isPresent(init.dataProvider) ? init.dataProvider
                    : this.dataProviders.find(init.obj);
                // use existing or find best match for dataFinder
                this.dataFinder = core$1.isPresent(init.dataFinder) ? init.dataFinder
                    : this.finders.find(this.dataProvider, init.queryType);
                core$1.assert(core$1.isPresent(this.dataProvider) && core$1.isPresent(this.dataFinder), 'DataSource incorrectly initialized. (DataProvider, DataFinder) missing. ');
                this.dataFinder.lookupKey = init.lookupKey;
                if (core$1.isBlank(init.state)) {
                    this.state = new Datatable2State();
                }
                else {
                    this.state = init.state;
                }
                this.initialized = true;
            };
        /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         */
        /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         * @param {?=} withParams
         * @return {?}
         */
        DT2DataSource.prototype.fetch = /**
         * Triggers async fetch data request and result is given back using dataProvider.dataChanges
         *
         * @param {?=} withParams
         * @return {?}
         */
            function (withParams) {
                var _this = this;
                var /** @type {?} */ params = null;
                if (core$1.isPresent(withParams)) {
                    params = new Map().set('offset', withParams.offset)
                        .set('limit', withParams.limit)
                        .set('orderby', withParams.sortKey)
                        .set('selector', withParams.sortOrder);
                }
                this.dataProvider.fetch(params).subscribe(function (result) {
                    if (withParams.offset > 0) {
                        var /** @type {?} */ incrData = __spread(_this.dataProvider.dataChanges.getValue(), result);
                        _this.dataProvider.dataChanges.next(incrData);
                    }
                    else {
                        _this.dataProvider.dataChanges.next(result);
                    }
                });
            };
        /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         */
        /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         * @template T
         * @return {?}
         */
        DT2DataSource.prototype.open = /**
         * Component uses this method to open up continuous stream to listen for any changes which
         * need to be reflected on the UI.
         *
         * Dont forget to unsubscribe when component is destroyed.
         * @template T
         * @return {?}
         */
            function () {
                return this.dataProvider.dataChanges.asObservable();
            };
        /**
         * @return {?}
         */
        DT2DataSource.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dataProvider = null;
                this.dataFinder = null;
            };
        /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         */
        /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         * @param {?} object
         * @return {?}
         */
        DT2DataSource.prototype.insert = /**
         * If CRUD is enabled we delegate calls to DataProvider that is responsible to tell the
         * dataProvider.dataChanges that are new data. If not enabled we have default implementation
         * which works with local array
         *
         * @param {?} object
         * @return {?}
         */
            function (object) {
                if (this.dataProvider.canCRUD()) {
                    this.dataProvider.insert(object);
                }
                else {
                    var /** @type {?} */ copy = this.dataProvider.data().slice();
                    copy.push(object);
                    this.dataProvider.dataChanges.next(copy);
                }
            };
        /**
         * Please see {@link insert} method
         *
         */
        /**
         * Please see {\@link insert} method
         *
         * @param {?} object
         * @return {?}
         */
        DT2DataSource.prototype.remove = /**
         * Please see {\@link insert} method
         *
         * @param {?} object
         * @return {?}
         */
            function (object) {
                if (this.dataProvider.canCRUD()) {
                    this.dataProvider.remove(object);
                }
                else {
                    var /** @type {?} */ copy = this.dataProvider.data().slice();
                    var /** @type {?} */ afterDelete = copy.filter(function (elem) { return !core$1.equals(elem, object); });
                    this.dataProvider.dataChanges.next(afterDelete);
                }
            };
        /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         */
        /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         * @param {?=} pattern
         * @return {?}
         */
        DT2DataSource.prototype.find = /**
         *
         * Provides access to DataFinder which can accept either plain string or Map.
         *
         * To be able to provide correct input we need to ask DataFinder if it supports FullText like
         * type query or Predicate. In case of Predicate we build the Map with different key/value
         * pairs
         *
         *
         * @param {?=} pattern
         * @return {?}
         */
            function (pattern) {
                var _this = this;
                if (core$1.isBlank(pattern) || pattern.length === 0) {
                    // if we received empty string return orginal list
                    this.fetch(this.state);
                    return;
                }
                var /** @type {?} */ searchParam = pattern;
                if (this.dataFinder.accepts(this.dataProvider, QueryType.Predicate)) {
                    searchParam = new Map().set('query', pattern).set('limit', DT2DataSource.MaxLimit);
                    if (core$1.isPresent(this.state.sortKey)) {
                        searchParam.set('orderby', this.state.sortKey);
                    }
                    if (core$1.isPresent(this.state.sortKey)) {
                        searchParam.set('selector', this.state.sortOrder);
                    }
                }
                else {
                    core$1.assert(core$1.isString(pattern), 'Cannot pass non-string value to FullText Finder');
                }
                this.dataFinder.match(searchParam).subscribe(function (result) {
                    _this.dataProvider.dataChanges.next(result);
                });
            };
        /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         */
        /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
        DT2DataSource.prototype.sort = /**
         *
         * Data source delegates the responsibility to the given data provider which needs to implement
         * specific sorting mechanism
         *
         * Todo: Extend to sort by multiple columns
         *
         * @param {?} key
         * @param {?} sortOrder
         * @return {?}
         */
            function (key, sortOrder) {
                if (core$1.isBlank(this.dataProvider.data()) || this.dataProvider.data().length === 0) {
                    return;
                }
                this.state.sortKey = key;
                this.state.sortOrder = sortOrder;
                this.fetch(this.state);
            };
        /**
         *
         * Persist db state
         *
         */
        /**
         *
         * Persist db state
         *
         * @param {?} offset
         * @param {?} sortField
         * @param {?} sOrder
         * @return {?}
         */
        DT2DataSource.prototype.updateState = /**
         *
         * Persist db state
         *
         * @param {?} offset
         * @param {?} sortField
         * @param {?} sOrder
         * @return {?}
         */
            function (offset, sortField, sOrder) {
                this.state.offset = offset;
                this.state.sortKey = sortField;
                this.state.sortOrder = sOrder;
            };
        /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         */
        /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
        DT2DataSource.prototype.reorderRows = /**
         *
         * reshuffles current array based on new row D&D result.
         *
         * Since there is a difference if we move item from bottom or from the top and then accordingly
         * highlighting a space between rows. We need to reflect this in here as well.
         *
         * UseCase 1:
         *
         * 1. You can grab item with index 0 and move it down so that you can see a dropping line
         * between row with index 2 - 3
         *
         * 2. In this case splice() starts from position 2 and insert all elements after 2
         *      splice(start: number, deleteCount: number, ...items: T[]): T[];
         *
         * 3. no need to update newPos
         *
         * UseCase 2:
         *
         * 1. You can grab item with index 0 and move all the way down of the DT and now move the
         * row toward TOP and space between rows with index 2 - 3 is highlighted again.
         *
         * 2. Here is the difference, before we highlighted row #2 with line at the bottom, now
         * it seems the same but its highlighted row #3 with line at the TOP.
         *
         * * This is the reason whey we need to do newPos -= 1 or newPos += 1; depending our direction
         * where where the line between rows is created.
         *
         *
         * We don't need any complicated calculation trying to find out if we are on one half of the row
         * or second half and based on this try to apply certain style. This would not give so much
         * space if we want drop row into the row. And the calculation with coordinates woudl be too
         * complicated.
         *
         * We simply remember the direction we are moving and based on this we apply style to
         * to create a line at the TOP if we are going upwards or bottom otherwise.
         *
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
            function (origPos, newPos, dropPos) {
                var /** @type {?} */ array = this.dataProvider.data().slice();
                // take something from top and drag&drop under
                if (newPos > origPos && dropPos === DropPosition.Before && newPos < array.length) {
                    newPos -= 1;
                    // take something from bottom and drag&drop above
                }
                else if (newPos < origPos && dropPos === DropPosition.After && newPos >= 0) {
                    newPos += 1;
                }
                array.splice.apply(array, __spread([newPos, 0], array.splice(origPos, 1)[0]));
                this.dataProvider.dataChanges.next(array);
            };
        DT2DataSource.MaxLimit = 100;
        return DT2DataSource;
    }(DataSource));
    /**
     * Keeps current datatable state the state which drivers the way while fetching the data as well
     * encapsulate set of properties that needs to be persistet in order to recover a state after e.g.
     * browser refresh
     *
     *
     * todo: Create methods to convert this state from and to JSON for easier serialization
     */
    var Datatable2State = (function () {
        function Datatable2State() {
            /**
             * Properties for paging and fetching
             */
            this.offset = 0;
            this.limit = 0;
            /**
             * Identifies default value that is used to render N number of rows in non-fullscreen
             * mode
             *
             */
            this.displayLimit = 0;
            /**
             * Sorting order of the sort field. DataTable support sorting for multiple column but we
             * dont persist it now. Maybe in the future
             */
            this.sortOrder = Datatable2State.Ascending;
            /**
             * If we are using global filter for current datatable then save it here
             */
            this.currentSearchQuery = '';
            this.outlineState = new Map();
            this.detailRowExpandState = new Map();
        }
        /**
         * @param {?=} offset
         * @param {?=} limit
         * @param {?=} displayLimit
         * @param {?=} sortField
         * @param {?=} sOrder
         * @param {?=} searchQuery
         * @param {?=} filter
         * @param {?=} outlineState
         * @param {?=} detailRowState
         * @return {?}
         */
        Datatable2State.create = /**
         * @param {?=} offset
         * @param {?=} limit
         * @param {?=} displayLimit
         * @param {?=} sortField
         * @param {?=} sOrder
         * @param {?=} searchQuery
         * @param {?=} filter
         * @param {?=} outlineState
         * @param {?=} detailRowState
         * @return {?}
         */
            function (offset, limit, displayLimit, sortField, sOrder, searchQuery, filter, outlineState, detailRowState) {
                if (offset === void 0) {
                    offset = 0;
                }
                if (limit === void 0) {
                    limit = 15;
                }
                if (displayLimit === void 0) {
                    displayLimit = 5;
                }
                if (sortField === void 0) {
                    sortField = '';
                }
                if (sOrder === void 0) {
                    sOrder = 0;
                }
                if (outlineState === void 0) {
                    outlineState = new Map();
                }
                if (detailRowState === void 0) {
                    detailRowState = new Map();
                }
                var /** @type {?} */ s = new Datatable2State();
                s.offset = offset;
                s.limit = limit;
                s.displayLimit = displayLimit;
                s.sortKey = sortField;
                s.sortOrder = sOrder;
                s.currentSearchQuery = searchQuery;
                s.currentFilter = filter;
                s.outlineState = outlineState;
                s.detailRowExpandState = detailRowState;
                return s;
            };
        /**
         * @param {?} data
         * @return {?}
         */
        Datatable2State.fromJSON = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var /** @type {?} */ state = JSON.parse(data);
                var /** @type {?} */ ds = new Datatable2State();
                ds.offset = state.offset;
                ds.limit = state.limit;
                ds.displayLimit = state.displayLimit;
                ds.sortKey = state.sortKey;
                ds.sortOrder = state.sortOrder;
                ds.currentSearchQuery = state.currentSearchQuery;
                ds.outlineState = core$1.MapWrapper.createFromAnyMap(state.outlineState);
                ds.detailRowExpandState = core$1.MapWrapper.createFromAnyMap(state.detailRowExpandState);
                return ds;
            };
        /**
         * @param {?} data
         * @return {?}
         */
        Datatable2State.toJSON = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var /** @type {?} */ toConvert = {
                    offset: data.offset,
                    limit: data.limit,
                    displayLimit: data.displayLimit,
                    sortKey: data.sortKey,
                    sortOrder: data.sortOrder,
                    currentSearchQuery: data.currentSearchQuery,
                    outlineState: core$1.MapWrapper.toAnyMap(data.outlineState),
                    detailRowExpandState: core$1.MapWrapper.toAnyMap(data.detailRowExpandState)
                };
                return JSON.stringify(toConvert);
            };
        Datatable2State.Ascending = 1;
        Datatable2State.Descending = -1;
        return Datatable2State;
    }());
    /**
     * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
     * simple we have a map holding item reference as a key and boolean value indicating if the
     * detail row is visible
     *
     * Todo: move this out to DS
     */
    var /**
     * This needs to go to DTDataSource to keep and manage the state of the detail row. The idea is
     * simple we have a map holding item reference as a key and boolean value indicating if the
     * detail row is visible
     *
     * Todo: move this out to DS
     */ DetailRowExpansionState = (function () {
        function DetailRowExpansionState(dt) {
            this.dt = dt;
        }
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.itemToKey = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isEntity(item) ? ((item)).identity() : item;
            };
        Object.defineProperty(DetailRowExpansionState.prototype, "detailExpansionEnabled", {
            get: /**
             * @return {?}
             */ function () {
                return core$1.isPresent(this.expansionStates);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this.expansionStates = new Map();
                }
                else {
                    this.expansionStates = null;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.toggle = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ key = this.itemToKey(item);
                if (!this.isExpanded(item)) {
                    this.expansionStates.set(key, true);
                }
                else {
                    this.expansionStates.delete(key);
                }
                this.dt.dataSource.state.detailRowExpandState = this.expansionStates;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DetailRowExpansionState.prototype.isExpanded = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ key = this.itemToKey(item);
                // handle special case where we collapse parent of parent while detail row is expanded
                if (this.dt.isOutline() && !this.dt.outlineState.isExpanded(key)) {
                    this.expansionStates.delete(key);
                    return false;
                }
                var /** @type {?} */ isOutlineExpanded = this.dt.isOutline() ? this.dt.outlineState.isExpanded(key) : true;
                return core$1.isPresent(key) && this.expansionStates.has(key);
            };
        return DetailRowExpansionState;
    }());
    /**
     * @param {?} init
     * @return {?}
     */
    function isDTInitParams(init) {
        return core$1.isPresent(init.obj) || core$1.isPresent(init.queryType) || core$1.isPresent(init.entity);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Column implementation for the Multiselection where we show checkbox control
     *
     *
     */
    var DTMultiSelectColumnComponent = (function (_super) {
        __extends(DTMultiSelectColumnComponent, _super);
        function DTMultiSelectColumnComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        DTMultiSelectColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-multi-select-column',
                        template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n\n        <ng-template [ngIf]=\"dt.showSelectAll\">\n            <aw-checkbox [type]=\"'action'\" (action)=\"dt.toggleAllColumns($event)\"\n                         [value]=\"dt.isToggleAllColumnSelected()\"\n                         [disabled]=\"dt.isToggleAllColumnDisabled()\">\n            </aw-checkbox>\n        </ng-template>\n\n        <ng-template [ngIf]=\"!dt.showSelectAll\">&nbsp;\n        </ng-template>\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-checkbox [type]=\"'action'\" [value]=\"dt.isRowSelected(data)\" >\n        </aw-checkbox>\n\n    </td>\n</ng-template>\n",
                        styles: [""],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTMultiSelectColumnComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTMultiSelectColumnComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Column implementation for the SingleSelect where we show checkbox control
     *
     *
     */
    var DTSingleSelectColumnComponent = (function (_super) {
        __extends(DTSingleSelectColumnComponent, _super);
        function DTSingleSelectColumnComponent(env, domHandler) {
            var _this = _super.call(this, env, domHandler) || this;
            _this.env = env;
            _this.domHandler = domHandler;
            // default width of the selection control
            // default width of the selection control
            _this.width = '45px';
            return _this;
        }
        DTSingleSelectColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-single-select-column',
                        template: "<!--\n    Manages multi selection and renders checkboxes both for header in case [showSelectAll] is\n    enabled as well as each checkbox per row\n-->\n<ng-template #renderingTemplate let-isHeader let-isSubHeader=\"isSubHeader\" let-column=\"column\"\n             let-dataToRender=\"data\"\n             let-level=\"nestingLevel\"\n             let-columnIndex=\"columnIndex\"\n             let-rowIndex=\"rowIndex\">\n\n    <ng-template *ngIf=\"isHeader\" [ngTemplateOutlet]=\"colHeader\"\n                 [ngTemplateOutletContext]=\"{$implicit: isSubHeader, columnIndex:columnIndex,\n                 level:level}\">\n    </ng-template>\n\n    <ng-template *ngIf=\"!isHeader\" [ngTemplateOutlet]=\"colBody\"\n                 [ngTemplateOutletContext]=\"{$implicit: column, level:level,\n                    data:dataToRender,rowIndex:rowIndex}\">\n    </ng-template>\n</ng-template>\n\n\n<ng-template #colHeader let-isSubHeader let-columnIndex=\"columnIndex\">\n    <th [ngClass]=\"{'dt-is-default dt-u-unselectable-text dt-selection-column' :true,\n                    'dt-cell-def': true,\n                    'dt-sub-header': isSubHeader,\n                    'dt-is-hidden': !dt.showSelectionColumn}\" align=\"center\">\n        &nbsp;\n    </th>\n\n</ng-template>\n\n\n<ng-template #colBody let-data=\"data\" let-rowIndex=\"rowIndex\" , let-level=\"level\">\n\n    <td #cell [class]=\"dynamicBodyClass(data)\"\n        [style.padding-left.px]=\"indentForControl(cell, level)\"\n        align=\"center\"\n        [ngClass]=\"{ 'dt-is-default dt-selection-column': true,\n        'dt-cell-def': true,\n        'dt-is-hidden': !dt.showSelectionColumn}\">\n\n        <aw-radiobutton [name]=\"'DTRadio'\" [value]=\"data\" [(ngModel)]=\"dt.dataSource.state.selection\">\n        </aw-radiobutton>\n    </td>\n</ng-template>\n",
                        styles: [""],
                        encapsulation: core.ViewEncapsulation.None,
                        providers: [primeng.DomHandler]
                    },] },
        ];
        /** @nocollapse */
        DTSingleSelectColumnComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: primeng.DomHandler }
            ];
        };
        return DTSingleSelectColumnComponent;
    }(DTColumn2Component));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * DT component that implements the data grid that shows tabular data. Even the basic
     * structure is based on PrimeNG datatable its completely refactored into smaller pieces that
     * allows more extensibility and trying to stay as close as possible to existing AWL implementation
     *
     * There are 3 main pieces:
     *
     *  Table Wrapper - focuses on the outer structure. Container with basic datable layout plus
     *  contains any additional panels that datatable needs such as our new concept how editing will
     *  work - sliding panel from the bottom
     *
     *  Datatable Column - Instead of rendering everything inside DT I split the part that renders
     *  column into separate component. This way component column has its own renderer template which
     *  can render both header and data cells.
     *  Later on DTColumn is then extended to support other additional column types
     *  SingleSelectionColumn, MultiSelectionColumn, both responsible for rendering selection controls.
     *
     * To support pivotal layout this can be extended for other additional columns that implements their
     * own rendering templates
     *
     * Datatable - The main component that is only focus on header and body rendering and basaed on the
     * column type it will render the correct template
     * column type it will render the correct template
     *
     *
     *
     *
     *
     */
    var Datatable2Component = (function (_super) {
        __extends(Datatable2Component, _super);
        /**
         *
         * In case of outline table we are inject OutlineState which is provided in the DT component
         * definition. This is used by nested outlineFor component it set itself as reference and
         * initialize the state so it can be used later on inside OutlineControl
         *
         *
         * Each Datatable is pre-defaulted with its own version of DataSource so all the observers
         * inside are unique for this component
         *
         */
        function Datatable2Component(env, el, _defaultDS, changeDetector, factoryResolver, outlineState, zone, injector) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.el = el;
            _this._defaultDS = _defaultDS;
            _this.changeDetector = changeDetector;
            _this.factoryResolver = factoryResolver;
            _this.outlineState = outlineState;
            _this.zone = zone;
            _this.injector = injector;
            /**
             *  Hides or shows table heading where we have filters and tools menus
             */
            _this.showTableHeader = true;
            /**
             * See AWDataTable
             *
             */
            _this.pivotalLayout = false;
            /**
             * See AWDataTable
             */
            _this.initialSortOrder = 'descending';
            /**
             * When DT is loaded in the page and we are not in the full screen (full page mode), this
             * is hte number of lines that DT will show
             *
             * todo: come up with better name
             */
            _this.displayRowSize = 10;
            /**
             * Used for paging on lazy loading using infinite scroller to set initial fetch limit size
             *
             * todo: come up with better name !!!
             *
             */
            _this.pageSize = 15;
            /**
             * Default message when there are no data .
             *
             * todo: Use i18n value and create resource file
             */
            _this.emptyMessage = 'No records found';
            /**
             *
             * See AWDataTable
             *
             */
            _this.selectionMode = 'none';
            /**
             *
             * Can provide custom icon. These icons are not animated divs, we used css
             * transformation to rotate them.
             *
             */
            _this.loadingIcon = 'icon-synchronize';
            /**
             * Additional indent can be added when rendering detail row
             */
            _this.indentDetailRow = false;
            /**
             * See AWDataTable
             *
             */
            _this.indentationPerLevel = 25;
            /**
             *
             *  SubHeader is used to show summary columns, which in our UX is shown at the top just under
             *  the regular table header
             *
             */
            _this.showSubHeader = false;
            /**
             * See OutlineFor - only used in the tree mode
             */
            _this.expandAll = false;
            /**
             * See AWDataTable
             */
            _this.pushRootSectionOnNewLine = true;
            /**
             * Render or hide expansion control for row detail columns. Expansion control makes sense for
             * simple table, when using this inside outline (tree table), its driven by outline control
             */
            _this.showRowDetailExpansionControl = true;
            /**
             * See AWDataTable
             *
             */
            _this.showSelectionColumn = true;
            /**
             * See AWDataTable
             *
             */
            _this.showSelectAll = true;
            /**
             * Show or hide global search term input field in the header
             */
            _this.showGlobalSearch = true;
            /**
             * Enables or disables row reordering
             *
             */
            _this.dndRowEnabled = false;
            /**
             *
             * Fires event that sorting is enabled for column and we trigger sorting
             *
             */
            _this.onSort = new core.EventEmitter();
            /**
             * Based on selection mode it triggers even
             *
             */
            _this.onRowClick = new core.EventEmitter();
            /**
             *
             * When multi or single selection mode is enabled it will trigger event when checkbox or
             * radio buttons is selected
             *
             * todo: implement SingleSelectionDTColumn, MultiSelectionDTColumn with their renderers
             */
            _this.onRowSelectionChange = new core.EventEmitter();
            /**
             * When cell body selection changes we fire event
             *
             */
            _this.onCellChange = new core.EventEmitter();
            /**
             * When cell header selection changes we fire event
             *
             */
            _this.onHeaderSelection = new core.EventEmitter();
            /**
             *
             * Triggers when items in the list are updated
             *
             */
            _this.valueChange = new core.EventEmitter();
            _this.classList = 'w-datatable ';
            /**
             *  Indicates that columns were initialed Also used when we hide and show column to trigger
             *  change.
             *
             */
            _this.columnsChanged = false;
            /**
             * See AWDataTable
             */
            _this.numberOfColsBeforeData = 0;
            /**
             * See AWDataTable
             */
            _this.startOfFirstDataColumn = 0;
            _this.dataSource = _this._defaultDS;
            return _this;
        }
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                if (core$1.isPresent(this.list) && core$1.isPresent(this.destinationClass)) {
                    throw new Error('You cannot use both bindings [list] and [destinationClass]!');
                }
                this.detailRowExpansionState = new DetailRowExpansionState(this);
                // init default columns
                this.rowDetailExpandColumn = this.factoryResolver
                    .resolveComponentFactory(DTDetailRowExpanderComponent).create(this.injector).instance;
                this.multiSelectColumn = this.factoryResolver
                    .resolveComponentFactory(DTMultiSelectColumnComponent).create(this.injector).instance;
                this.singleSelectColumn = this.factoryResolver
                    .resolveComponentFactory(DTSingleSelectColumnComponent).create(this.injector).instance;
                /**
                         * If the data are not deferred and we get list directly then it creates DS. If
                         * ngOnChanges is called first we properly init DS and clean this.list
                         *
                         */
                if (core$1.isPresent(this.destinationClass) || core$1.isPresent(this.list)) {
                    this.initDatasource();
                }
                else if (this.dataSource.initialized) {
                    this.initDatasource(false);
                }
                // since we work with references let's pass created map inside our state
                this.outlineState.expansionStates = this.state.outlineState;
            };
        /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         */
        /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         * @param {?} changes
         * @return {?}
         */
        Datatable2Component.prototype.ngOnChanges = /**
         * When data arrives later maybe due to REST API latency, initialize DS only when we have a
         * data, otherwise if data changed thru the bindings just trigger dataChange event
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (changes['list'] && core$1.isPresent(changes['list'].currentValue)
                    && !this.dataSource.initialized) {
                    this.initDatasource();
                }
                else if (this.dataSource.initialized) {
                    this.dataSource.dataProvider.dataChanges.next(this.list);
                }
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // make sure we init a state when detail column is present
                // todo: move this initialization to datasource
                this.detailRowExpansionState.detailExpansionEnabled = core$1.isPresent(this.rowDetailColumn);
                this.initColumns();
                this.columnsSubscription = this.colsQuery.changes.subscribe(function (_) {
                    _this.initColumns();
                    _this.changeDetector.markForCheck();
                });
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // assign it programatically as we want to have a context for the filter
                if (core$1.isPresent(this.rowDetailColumn) && core$1.isPresent(this.outlineState.outlineFor)) {
                    this.outlineState.outlineFor.filterOut = this.skipOutlineItem.bind(this);
                }
                if (core$1.isPresent(this.outlineState.outlineFor)) ;
                this.initialized = true;
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                if (this.columnsChanged && this.el.nativeElement.offsetParent) {
                    this.columnsChanged = false;
                }
                if (this.hasFrozenColumns()) {
                    this.frozenColumns.forEach(function (col, index) {
                        return col.postInitialize(index);
                    });
                }
                else {
                    this.columns.forEach(function (col, index) {
                        return col.postInitialize(index);
                    });
                }
            };
        /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         */
        /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         * @return {?}
         */
        Datatable2Component.prototype.initColumns = /**
         * Key entry method that initialized our columns. Later on when we will support selection and
         * multiselection we will programmatically instantiate SingleSelection, MultiSelection column
         * components and add them to the list so they can be rendered.
         *
         * so the idea here is:
         *
         * When DT component initialize and we are in editing mode and we support Single/Multi selection
         * we will use ComponentFactoryResolver to create component and add it as first item to the list
         * and then it will be rendered just like anythign else.
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.columns = [];
                this.frozenColumns = [];
                if (this.detailRowExpansionState.detailExpansionEnabled) {
                    this.initDetailColumnExpansion();
                }
                if (this.hasLeadingSelectColumn() && this.selectionMode === 'multi') {
                    this.columns.push(this.multiSelectColumn);
                }
                else if (this.hasLeadingSelectColumn() && this.selectionMode === 'single') {
                    this.columns.push(this.singleSelectColumn);
                }
                /**
                         * Add expansion column when detail row is enabled
                         */
                if (this.detailRowExpansionState.detailExpansionEnabled && !this.isOutline()) {
                    this.columns.push(this.rowDetailExpandColumn);
                }
                this.colsQuery
                    .filter(function (col1) { return !col1.frozen; })
                    .forEach(function (col) {
                    col.initialize(_this);
                    _this.columns.push(col);
                });
                this.initFrozenColumns();
                this.initColumnInfo();
                this.columnsChanged = true;
            };
        /**
         * Makes sure that we also include programmatic column if present. Move them to the correct
         * array
         *
         * @return {?}
         */
        Datatable2Component.prototype.initFrozenColumns = /**
         * Makes sure that we also include programmatic column if present. Move them to the correct
         * array
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.colsQuery
                    .filter(function (col1) { return col1.frozen; })
                    .forEach(function (col) {
                    col.initialize(_this);
                    _this.frozenColumns.push(col);
                });
                if (this.frozenColumns.length > 0) {
                    // find last index of column that is internal / programmatic
                    var /** @type {?} */ lastInx = this.columns.slice()
                        .reverse()
                        .findIndex(function (col) { return _this.isInternalColumn(col); });
                    if (lastInx !== -1) {
                        var /** @type {?} */ idx = this.columns.length - 1 - lastInx;
                        var /** @type {?} */ internalCols = this.columns.splice(0, idx + 1);
                        this.frozenColumns = __spread(internalCols, this.frozenColumns);
                    }
                    var /** @type {?} */ hasValidCols = this.columns
                        .findIndex(function (col) { return core$1.isBlank(col.width); }) === -1;
                    core$1.assert(hasValidCols || core$1.isPresent(this.scrollWidth), 'When using [frozen] binding you need specify [width] for each ' +
                        'column or [scrollWidth] on datatable!');
                    core$1.assert(core$1.isBlank(this.rowDetailColumn), 'You cannot combine aw-dt-detail-column with frozen columns!');
                }
            };
        /**
         * Check if current column is programmatically created
         *
         */
        /**
         * Check if current column is programmatically created
         *
         * @param {?} col
         * @return {?}
         */
        Datatable2Component.prototype.isInternalColumn = /**
         * Check if current column is programmatically created
         *
         * @param {?} col
         * @return {?}
         */
            function (col) {
                return col instanceof DTSingleSelectColumnComponent ||
                    col instanceof DTMultiSelectColumnComponent ||
                    col instanceof DTDetailRowExpanderComponent;
            };
        /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         */
        /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         * @param {?=} initialize
         * @return {?}
         */
        Datatable2Component.prototype.initDatasource = /**
         * Create new Datasource based on passed values. It tries to initialize DS for first time
         * inside the ngInit but in case Data arrives later maybe due to some REST API calls this
         * can be triggered also from ngOnChanges.
         *
         * @param {?=} initialize
         * @return {?}
         */
            function (initialize) {
                var _this = this;
                if (initialize === void 0) {
                    initialize = true;
                }
                if (core$1.isBlank(this.state)) {
                    this.state = Datatable2State.create(0, this.pageSize, this.displayRowSize, this.initialSortKey, this.sortOrderingForString(this.initialSortOrder));
                }
                else {
                    this.state.limit = this.state.displayLimit = this.displayRowSize;
                    if (core$1.isPresent(this.initialSortKey)) {
                        this.state.sortKey = this.initialSortKey;
                        this.state.sortOrder = this.sortOrderingForString(this.initialSortOrder);
                    }
                }
                if (initialize) {
                    this.dataSource.init({
                        obj: core$1.isPresent(this.destinationClass) ? this.destinationClass : this.list,
                        queryType: QueryType.FullText,
                        state: this.state,
                        multiselect: false
                    });
                }
                this.dataSource.fetch(this.state);
                // reset list to make sure it comes from DataProvider, we use list  to initialize
                this.list = null;
                // This is the ENTRY point for the DATA CHANGES. All addition, edits, deletion ends up
                // here. We dont work directly with LIST. Any change is reactive and here is listener
                this.dataSource.open().subscribe(function (data) {
                    _this.updateList(data);
                });
            };
        /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         */
        /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         * @return {?}
         */
        Datatable2Component.prototype.initDetailColumnExpansion = /**
         * When detailRow column is present we initialize a state holding information which item is
         * expanded.
         *
         * todo: This is temporary here and once we suport lazy loading move this to datasource.
         *
         * For example for outline tree table we need to connect a state from outline with a state in
         * here as we are using outline control to expand and collapse items
         * @return {?}
         */
            function () {
                this.detailRowExpansionState.detailExpansionEnabled = core$1.isPresent(this.rowDetailColumn) &&
                    core$1.BooleanWrapper.isTrue(this.showRowDetailExpansionControl);
            };
        /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         */
        /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         * @return {?}
         */
        Datatable2Component.prototype.initColumnInfo = /**
         * This method is executed after we initialize all the columns in order to calculate correct
         * numbers used for indentation while rendering selection columns as well as detail row columns.
         *
         * Here we need to be aware how many columns to span
         *
         * @return {?}
         */
            function () {
                var _this = this;
                this.numberOfColsBeforeData = 0;
                this.columns.forEach(function (col) {
                    if (!col.isValueColumn()) {
                        _this.numberOfColsBeforeData++;
                    }
                });
                if (this.indentDetailRow) {
                    this.numberOfColsBeforeData++;
                }
                this.startOfFirstDataColumn = this.columns.length - this.numberOfColsBeforeData;
            };
        Object.defineProperty(Datatable2Component.prototype, "state", {
            /**
             * Pushes a state out to application. Can be use as two way bindings
             *
             * [(state)]=dtState(s)
             *
             */
            get: /**
             * Pushes a state out to application. Can be use as two way bindings
             *
             * [(state)]=dtState(s)
             *
             * @return {?}
             */ function () {
                return this.dataSource.state;
            },
            set: /**
             * @param {?} val
             * @return {?}
             */ function (val) {
                this.dataSource.state = val;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onCellSelectionChange = /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
            function (cell, column, item) {
                if (this.selectionMode !== 'cell') {
                    return;
                }
                var /** @type {?} */ lookupKey = {
                    col: column.key || column.label,
                    item: item
                };
                if (core$1.isPresent(this.state.selection) && this.state.selection.length > 0) {
                    var /** @type {?} */ foundIndex_1 = core$1.ListWrapper.findIndexComplex(this.state.selection, lookupKey);
                    var /** @type {?} */ isSelected = foundIndex_1 !== -1;
                    if (isSelected) {
                        this.state.selection = this.state.selection
                            .filter(function (val, index) { return index !== foundIndex_1; });
                    }
                    else {
                        this.state.selection = __spread(this.state.selection, [lookupKey]);
                    }
                }
                else {
                    this.state.selection = [lookupKey];
                }
                this.onCellChange.emit(this.state.selection);
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @return {?}
         */
        Datatable2Component.prototype.onHeaderSelectionChange = /**
         * See AWDataTable
         *
         * @param {?} cell
         * @param {?} column
         * @return {?}
         */
            function (cell, column) {
                if (core$1.isPresent(this.state.headerSelection)) {
                    if (this.isHeaderSelected(column)) {
                        this.state.headerSelection = null;
                    }
                    else {
                        this.state.headerSelection = column;
                    }
                }
                else {
                    this.state.headerSelection = column;
                }
                this.onHeaderSelection.emit(this.state.headerSelection);
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onHandleRowClicked = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                // special alt key modifier. When used with rows it indicates there is a D&D enabled
                if (event.altKey) {
                    return;
                }
                if (this.selectionMode === 'multi') {
                    this.onRowToggle(event, item);
                }
                else if (this.selectionMode === 'single') {
                    this.onRowSelect(event, item);
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onRowToggle = /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                var /** @type {?} */ rowSelected = true;
                if (core$1.isPresent(this.state.selection) && this.state.selection.length > 0) {
                    var /** @type {?} */ foundIndex_2 = core$1.ListWrapper.findIndexComplex(this.state.selection, item);
                    var /** @type {?} */ isSelected = foundIndex_2 !== -1;
                    if (isSelected) {
                        this.state.selection = this.state.selection
                            .filter(function (val, index) { return index !== foundIndex_2; });
                        rowSelected = false;
                    }
                    else {
                        this.state.selection = __spread(this.state.selection, [item]);
                    }
                    // for the outline go up and down the sync with treeitems
                    if (this.isOutline()) {
                        this.onHandleOutlineRowToggleToChildren(item, isSelected);
                        this.oHandleOutlineRowToggleToParent(item, isSelected);
                    }
                }
                else {
                    this.state.selection = [item];
                    if (this.isOutline()) {
                        this.onHandleOutlineRowToggleToChildren(item, false);
                        this.oHandleOutlineRowToggleToParent(item, false);
                    }
                }
                this.onRowSelectionChange.emit({
                    isSelected: rowSelected,
                    item: this.state.selection
                });
                event.stopPropagation();
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.onRowSelect = /**
         * See AWDataTable
         *
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                this.state.selection = item;
                event.stopPropagation();
                this.onRowSelectionChange.emit(item);
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
        Datatable2Component.prototype.onHandleOutlineRowToggleToChildren = /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
            function (currentItem, isSelected) {
                var /** @type {?} */ childrenForNode = this.children.apply(this.context, [currentItem]) || [];
                if (childrenForNode.length > 0) {
                    // If is selected currently then toggle to other state
                    if (!isSelected) {
                        // when checking all from root, deselect children and add all
                        this.onHandleOutlineRowToggleToChildren(currentItem, true);
                        this.state.selection = __spread(this.state.selection, childrenForNode);
                    }
                    else {
                        var _loop_1 = function (child) {
                            var /** @type {?} */ foundIndex = core$1.ListWrapper.findIndexComplex(this_1.state.selection, child);
                            this_1.state.selection = this_1.state.selection
                                .filter(function (val, index) { return index !== foundIndex; });
                        };
                        var this_1 = this;
                        try {
                            // remove each child
                            for (var childrenForNode_1 = __values(childrenForNode), childrenForNode_1_1 = childrenForNode_1.next(); !childrenForNode_1_1.done; childrenForNode_1_1 = childrenForNode_1.next()) {
                                var child = childrenForNode_1_1.value;
                                _loop_1(child);
                            }
                        }
                        catch (e_1_1) {
                            e_1 = { error: e_1_1 };
                        }
                        finally {
                            try {
                                if (childrenForNode_1_1 && !childrenForNode_1_1.done && (_a = childrenForNode_1.return))
                                    _a.call(childrenForNode_1);
                            }
                            finally {
                                if (e_1)
                                    throw e_1.error;
                            }
                        }
                    }
                    try {
                        // apply the same for children of children
                        for (var childrenForNode_2 = __values(childrenForNode), childrenForNode_2_1 = childrenForNode_2.next(); !childrenForNode_2_1.done; childrenForNode_2_1 = childrenForNode_2.next()) {
                            var child = childrenForNode_2_1.value;
                            this.onHandleOutlineRowToggleToChildren(child, isSelected);
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (childrenForNode_2_1 && !childrenForNode_2_1.done && (_b = childrenForNode_2.return))
                                _b.call(childrenForNode_2);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
                var e_1, _a, e_2, _b;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
        Datatable2Component.prototype.oHandleOutlineRowToggleToParent = /**
         * See AWDataTable
         *
         * @param {?} currentItem
         * @param {?} isSelected
         * @return {?}
         */
            function (currentItem, isSelected) {
                var /** @type {?} */ parent = currentItem.$$parentItem;
                if (core$1.isPresent(parent)) {
                    var /** @type {?} */ childrenForNode = this.children.apply(this.context, [parent]) || [];
                    var /** @type {?} */ allSelected = true;
                    try {
                        for (var childrenForNode_3 = __values(childrenForNode), childrenForNode_3_1 = childrenForNode_3.next(); !childrenForNode_3_1.done; childrenForNode_3_1 = childrenForNode_3.next()) {
                            var child = childrenForNode_3_1.value;
                            allSelected = core$1.ListWrapper.findIndexComplex(this.state.selection, child) !== -1
                                && allSelected;
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (childrenForNode_3_1 && !childrenForNode_3_1.done && (_a = childrenForNode_3.return))
                                _a.call(childrenForNode_3);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                    if (!isSelected) {
                        if (allSelected) {
                            this.state.selection.push(parent);
                        }
                    }
                    else {
                        if (!allSelected) {
                            var /** @type {?} */ parentIndex_1 = core$1.ListWrapper.findIndexComplex(this.state.selection, parent);
                            this.state.selection = this.state.selection
                                .filter(function (val, index) { return index !== parentIndex_1; });
                        }
                    }
                    this.oHandleOutlineRowToggleToParent(currentItem.$$parentItem, isSelected);
                }
                var e_3, _a;
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
        Datatable2Component.prototype.onDnDRowDrop = /**
         * See AWDataTable
         *
         * @param {?} origPos
         * @param {?} newPos
         * @param {?} dropPos
         * @return {?}
         */
            function (origPos, newPos, dropPos) {
                if (core$1.isPresent(this.dataSource)) {
                    console.log('Dropping row #: ', origPos + ' ' + dropPos + ' row #: ' + newPos);
                    this.dataSource.reorderRows(origPos, newPos, dropPos);
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
        Datatable2Component.prototype.onOutlineExpandChange = /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ item = event.item;
                // We dont really need to store a state form outline locally as we are using the same object
                // reference
                // this.state.outlineState = this.outlineState.expansionStates;
                if (this.canUseForDetailRow(item)) {
                    this.detailRowExpansionState.toggle(item);
                }
            };
        /**
         * See AWDataTable
         *
         *
         */
        /**
         * See AWDataTable
         *
         *
         * @return {?}
         */
        Datatable2Component.prototype.sortSingle = /**
         * See AWDataTable
         *
         *
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.list) && core$1.isPresent(this.sortColumn)) {
                    core$1.assert(core$1.isPresent(this.sortColumn.key), 'Invalid column to sort');
                    this.dataSource.sort(this.sortColumn.key, this.sortColumn.sortOrder);
                    this.onSort.emit({
                        field: this.sortColumn.key,
                        order: this.sortColumn.sortOrder
                    });
                }
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.handleDataChange = /**
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.state.sortKey || this.sortColumn) {
                    if (!this.sortColumn && this.columns) {
                        this.sortColumn = this.columns.find(function (col) { return col.key === _this.state.sortKey; });
                    }
                }
                this.updateDataToRender();
                this.valueChange.emit(this.list);
            };
        /**
         * @param {?=} datasource
         * @return {?}
         */
        Datatable2Component.prototype.updateDataToRender = /**
         * @param {?=} datasource
         * @return {?}
         */
            function (datasource) {
                this.dataToRender = datasource || this.list;
                // this.changeDetector.markForCheck();
                this.changeDetector.detectChanges();
            };
        /**
         * Updates current immutable list and trigger change detection. Need to wrap it with
         * setTimeout as the change can easily come after view checked and this would result some errors
         *
         * @param {?} newList
         * @return {?}
         */
        Datatable2Component.prototype.updateList = /**
         * Updates current immutable list and trigger change detection. Need to wrap it with
         * setTimeout as the change can easily come after view checked and this would result some errors
         *
         * @param {?} newList
         * @return {?}
         */
            function (newList) {
                var _this = this;
                setTimeout(function () {
                    _this.list = newList;
                    _this.handleDataChange();
                });
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.reset = /**
         * @return {?}
         */
            function () {
                this.sortColumn = null;
                this.updateDataToRender();
            };
        /**
         * See AWDataTable
         */
        /**
         * See AWDataTable
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isHeaderSelected = /**
         * See AWDataTable
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(this.state.headerSelection)) {
                    return false;
                }
                var /** @type {?} */ colMatched = item.key || item.label;
                var /** @type {?} */ currentCol = this.state.headerSelection.key || this.state.headerSelection.label;
                return colMatched === currentCol;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isBodyCellSelected = /**
         *
         * See AWDataTable
         *
         * @param {?} column
         * @param {?} item
         * @return {?}
         */
            function (column, item) {
                var /** @type {?} */ lookupKey = {
                    col: column.key || column.label,
                    item: item
                };
                return core$1.isPresent(this.state.selection) &&
                    core$1.ListWrapper.findIndexComplex(this.state.selection, lookupKey) !== -1;
            };
        /**
         *  See AWDataTable
         *
         */
        /**
         *  See AWDataTable
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.isRowSelected = /**
         *  See AWDataTable
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.hasLeadingSelectColumn() && core$1.isPresent(this.state.selection)) {
                    if (this.selectionMode === 'multi') {
                        return core$1.ListWrapper.findIndexComplex(this.state.selection, item) !== -1;
                    }
                    else if (this.selectionMode === 'single') {
                        return core$1.equals(this.state.selection, item);
                    }
                }
                return false;
            };
        /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         */
        /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         * @return {?}
         */
        Datatable2Component.prototype.isEmpty = /**
         *
         * Do we have data to render Used inside template to tell if we should use the NoData template
         *
         * @return {?}
         */
            function () {
                return core$1.isBlank(this.dataToRender) || (this.dataToRender.length === 0);
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.hasFrozenColumns = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.frozenColumns) && this.frozenColumns.length > 0;
            };
        /**
         * See AWDataTable
         */
        /**
         * See AWDataTable
         * @return {?}
         */
        Datatable2Component.prototype.hasInvisibleSelectionColumn = /**
         * See AWDataTable
         * @return {?}
         */
            function () {
                return this.hasLeadingSelectColumn() && !this.showSelectionColumn;
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.hasLeadingSelectColumn = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                return this.selectionMode !== 'none' && this.selectionMode !== 'cell';
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.visibleColumns = /**
         * @return {?}
         */
            function () {
                return this.columns ? this.columns.filter(function (c) { return c.isVisible; }) : [];
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} direction
         * @return {?}
         */
        Datatable2Component.prototype.sortOrderingForString = /**
         * See AWDataTable
         *
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                if (core$1.isBlank(direction) || direction === 'ascending') {
                    return 1;
                }
                if (core$1.isBlank(direction) || direction === 'descending') {
                    return -1;
                }
                // todo: log bad key
                return 1;
            };
        /**
         * @param {?} direction
         * @return {?}
         */
        Datatable2Component.prototype.sortOrderingForNumber = /**
         * @param {?} direction
         * @return {?}
         */
            function (direction) {
                if (core$1.isBlank(direction) || direction === 1) {
                    return 'ascending';
                }
                if (core$1.isBlank(direction) || direction === -1) {
                    return 'descending';
                }
                // todo: log bad key
                return 'ascending';
            };
        /**
         * See AWDataTable
         *
         */
        /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
        Datatable2Component.prototype.toggleAllColumns = /**
         * See AWDataTable
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ currentItems = this.dataToRender || [];
                var /** @type {?} */ selectedObject = this.state.selection || [];
                if (selectedObject.length >= currentItems.length) {
                    this.state.selection = [];
                }
                else {
                    this.state.selection = [];
                    this.state.selection = __spread(currentItems);
                }
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.isToggleAllColumnSelected = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ currentItems = this.dataToRender || [];
                var /** @type {?} */ selectedObject = this.state.selection || [];
                return currentItems.length > 0 && selectedObject.length >= currentItems.length;
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.isToggleAllColumnDisabled = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ currentItems = this.dataToRender || [];
                return currentItems.length === 0;
            };
        /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         */
        /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.showDetailColumn = /**
         *
         * Used by template to decide if we need to render DetailRow template. We need to have
         * DetailRow ContentChild and using DetailRow component [isVisibleFn] function binding we
         * check if the item that is about to be rendered is eligible for detail row
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (this.canUseForDetailRow(item) && this.detailRowExpansionState.isExpanded(item)) {
                    return true;
                }
                return false;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.canUseForDetailRow = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return core$1.isPresent(this.rowDetailColumn) &&
                    ((this.rowDetailColumn)).showDetailRow(item);
            };
        /**
         *
         * See AWDataTable
         *
         */
        /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
        Datatable2Component.prototype.isOutline = /**
         *
         * See AWDataTable
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.children);
            };
        /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         */
        /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         * @param {?} item
         * @return {?}
         */
        Datatable2Component.prototype.skipOutlineItem = /**
         *
         * When dealing with detail column (detail row) and outline all together we need have a
         * mechanism to tell to the outline "don't render the next level of items" and use detail row.
         * So certain item type needs to be skipped.
         *
         * The way we skip those item is we use isVisibleFn condition of the detail row and look ahead
         * if we should skip next level.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.canUseForDetailRow(item);
            };
        /**
         *
         * See AWDaTable
         *
         */
        /**
         *
         * See AWDaTable
         *
         * @param {?} data
         * @param {?} field
         * @return {?}
         */
        Datatable2Component.prototype.getValue = /**
         *
         * See AWDaTable
         *
         * @param {?} data
         * @param {?} field
         * @return {?}
         */
            function (data, field) {
                return core$1.FieldPath.getFieldValue(data, field);
            };
        /**
         * @return {?}
         */
        Datatable2Component.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (this.columnsSubscription) {
                    this.columnsSubscription.unsubscribe();
                }
            };
        Datatable2Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-datatable2',
                        template: "<!--\n    This template focus only on header and body rendering.\n\n    This datatable also supports frozen column and for this rendering it is pretty much transparent\n    as it received sets of column that it needs to render from the TableWrapper.\n\n    TableWrapper in case of frozen columns calls #headerRows and #bodyRows templates twice to\n    render to separate tables where one has frozen columns and another one has the rest and its\n    scrollable\n-->\n\n<aw-dt-wrapper #dtWrapper>\n    <ng-template #headingArea>\n        <ng-content select=\"aw-dt-header2\"></ng-content>\n    </ng-template>\n\n    <ng-template #headerRows let-colsToRender let-frozenView=\"frozenColumns\">\n        <ng-container\n            *ngTemplateOutlet=\"header; context:{$implicit: colsToRender, frozen:frozenView }\">\n        </ng-container>\n    </ng-template>\n\n    <ng-template #bodyRows let-colsToRender>\n        <ng-template [ngIf]=\"isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyOutline; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n        <ng-template [ngIf]=\"!isOutline()\">\n            <ng-container\n                *ngTemplateOutlet=\"bodyPlain; context:{$implicit: colsToRender}\"></ng-container>\n        </ng-template>\n    </ng-template>\n</aw-dt-wrapper>\n\n\n<!--\n    Each rendering column has its own renderTemplate which define how things should be render.\n    Based on different column types this code should be transparent as we dont care on this\n    level what kind of column we are rendering.\n\n    Later on when we will support single/multi selection, this will be just another column extending\n    DTColumn and providing its own template\n\n    We pass into this template if we are rendering header, subHeader, or data\n-->\n<ng-template #header let-colsToRender let-frozen=\"frozen\">\n    <tr>\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\"\n                     let-columnIndex=\"index\">\n\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:false,\n                columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n\n    <tr *ngIf=\"showSubHeader\">\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-lastCol=\"last\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                context:{$implicit: true, isSubHeader:true}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n<ng-template #bodyPlain let-colsToRender>\n\n    <tbody [ngClass]=\"{'dt-content dt-data-cells ': true, 'dt-is-hoverable-row': rowHover}\">\n\n    <ng-template ngFor let-rowData [ngForOf]=\"dataToRender\" let-even=\"even\" let-odd=\"odd\"\n                 let-rowIndex=\"index\" [ngForTrackBy]=\"rowTrackBy\">\n\n        <ng-container *ngTemplateOutlet=\"rowTemplate; context:{$implicit: rowData, even:even,\n                                          odd:odd, rowIndex:rowIndex, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n\n<ng-template #bodyOutline let-colsToRender>\n    <tbody #outlineFor awOutlineFor [list]=\"dataToRender\"\n           [context]=\"context\"\n           [indentationPerLevel]=\"indentationPerLevel\"\n           [pushRootSectionOnNewLine]=\"pushRootSectionOnNewLine\"\n           [children]=\"children\" [expandAll]=\"expandAll\"\n           [state]=\"outlineState\"\n           [ngClass]=\"{'dt-content dt-data-cells ': true,\n                           'dt-is-hoverable-row': rowHover}\"\n           (onExpandChange)=\"onOutlineExpandChange($event)\">\n\n    <ng-template #outline let-rowData let-nestingLevel=\"nestingLevel\" let-rowIndex=\"rowIndex\">\n        <ng-container *ngTemplateOutlet=\"rowTemplate;\n                                context:{$implicit: rowData, nestingLevel:nestingLevel, colsToRender:colsToRender}\">\n        </ng-container>\n\n        <ng-template [ngIf]=\"showDetailColumn(rowData)\">\n            <ng-container *ngTemplateOutlet=\"rowDetailColumn.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:(rowIndex)}\">\n            </ng-container>\n        </ng-template>\n\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"noData\"></ng-container>\n    </tbody>\n</ng-template>\n\n<!--\n    Default template that is display when there are no data\n-->\n<ng-template #noData>\n    <tr *ngIf=\"isEmpty()\" class=\" dt-emptymessage-row\"\n        [style.visibility]=\"loading ? 'hidden' : 'visible'\">\n\n        <td [attr.colspan]=\"visibleColumns().length\" class=\"dt-emptymessage\">\n            <span *ngIf=\"!emptyMessageTemplate\">{{emptyMessage}}</span>\n            <ng-container *ngTemplateOutlet=\"emptyMessageTemplate\"></ng-container>\n        </td>\n    </tr>\n</ng-template>\n\n<!--\n    Template that renders actual row. Renders both header and body column. Each rendered\n    column has its own template called rendererTemplate that has all things that needs to be\n    rendered and we just tell the template if we are rendering header, subheader or body\n-->\n<ng-template #rowTemplate let-rowData let-even=\"event\" let-odd=\"odd\" let-rowIndex=\"rowIndex\"\n             let-nestingLevel=\"nestingLevel\" let-colsToRender=\"colsToRender\">\n\n\n    <tr #rowElement dtDraggableRow [dndRowIndex]=\"rowIndex\"\n        class=\"dt-body-row\"\n        (click)=\"onHandleRowClicked($event, rowData)\"\n        [attr.nestingLevel]=\"nestingLevel\"\n        [ngClass]=\"{'dt-even-row': even, 'dt-odd-row': odd,\n            'dt-row-selected': isRowSelected(rowData),\n            'dt-row-draggable': dndRowEnabled,\n            'dt-root-section': nestingLevel === 0 }\">\n\n        <ng-template ngFor let-col [ngForOf]=\"colsToRender\" let-colIndex=\"index\">\n            <ng-container *ngTemplateOutlet=\"col.rendererTemplate;\n                    context:{$implicit: false, data:rowData, rowIndex:rowIndex,\n                    nestingLevel:nestingLevel}\">\n            </ng-container>\n        </ng-template>\n    </tr>\n</ng-template>\n\n\n",
                        styles: [".w-datatable{position:relative;display:block;box-sizing:border-box}.w-datatable table{border-collapse:collapse;width:100%;table-layout:fixed}.w-datatable tbody,.w-datatable td,.w-datatable th{outline:0}.dt-cell-def,.dt-cell-def-selectable{border:1px solid transparent;padding:17px 16px;box-sizing:border-box}.dt-cell-def-selectable{cursor:pointer;width:100%;height:100%}th .dt-cell-def-selectable{border-width:4px 1px 1px;padding:14px 16px 17px}td .dt-cell-def-selectable{border-width:0 1px 0 5px;padding:17px 16px 17px 13px}.dt-data-cells tr.dt-is-highlight,.dt-data-cells tr.dt-is-hover{border-color:inherit;font-weight:inherit;cursor:pointer}.w-datatable-rtl{direction:rtl}.w-datatable-rtl.w-datatable-rtl.w-datatable thead th{text-align:right}.dt-root-section .dt-cell-def,.dt-root-section .dt-cell-def-selectable{background-color:#f3f6f8;padding:10px 16px;border-bottom-color:transparent;border-right-color:transparent}.dt-plain-layout .dt-is-active,.dt-plain-layout .dt-is-default,.dt-plain-layout .dt-is-highlight,.dt-plain-layout .dt-is-hover,.dt-plain-layout .dt-is-hoverable-row{border-right-color:transparent}.dt-is-active,.dt-is-default,.dt-is-highlight,.dt-is-hover,.dt-is-hoverable-row{border:1px solid #d7d7d7;background-color:#fff;color:#363636}.dt-row-selected td{background-color:rgba(238,255,238,.71)}.dt-is-active{border-color:#065d9c;color:#199de0}.dt-is-highlight{background-color:rgba(65,117,5,.18)}.dt-is-hidden{display:none}.dt-u-unselectable-text{-webkit-user-select:none;-moz-user-select:none;-o-user-select:none;-ms-user-select:none;user-select:none}.dt-u-sortable{cursor:pointer}"],
                        providers: [
                            objectutils.ObjectUtils,
                            OutlineState,
                            { provide: DATA_SOURCE, useClass: DT2DataSource, deps: [DataProviders, DataFinders] },
                        ],
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    },] },
        ];
        /** @nocollapse */
        Datatable2Component.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef },
                { type: DT2DataSource, decorators: [{ type: core.Inject, args: [DATA_SOURCE,] }] },
                { type: core.ChangeDetectorRef },
                { type: core.ComponentFactoryResolver },
                { type: OutlineState },
                { type: core.NgZone },
                { type: core.Injector }
            ];
        };
        Datatable2Component.propDecorators = {
            list: [{ type: core.Input }],
            destinationClass: [{ type: core.Input }],
            tableStyleClass: [{ type: core.Input }],
            bodyClassFn: [{ type: core.Input }],
            isRowSelectable: [{ type: core.Input }],
            showTableHeader: [{ type: core.Input }],
            pivotalLayout: [{ type: core.Input }],
            context: [{ type: core.Input }],
            initialSortOrder: [{ type: core.Input }],
            initialSortKey: [{ type: core.Input }],
            displayRowSize: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            dataSource: [{ type: core.Input }],
            emptyMessage: [{ type: core.Input }],
            rowTrackBy: [{ type: core.Input }],
            rowHover: [{ type: core.Input }],
            loading: [{ type: core.Input }],
            selectionMode: [{ type: core.Input }],
            loadingIcon: [{ type: core.Input }],
            indentDetailRow: [{ type: core.Input }],
            indentationPerLevel: [{ type: core.Input }],
            showSubHeader: [{ type: core.Input }],
            children: [{ type: core.Input }],
            showExpansionControl: [{ type: core.Input }],
            expandAll: [{ type: core.Input }],
            pushRootSectionOnNewLine: [{ type: core.Input }],
            showRowDetailExpansionControl: [{ type: core.Input }],
            showSelectionColumn: [{ type: core.Input }],
            showSelectAll: [{ type: core.Input }],
            showGlobalSearch: [{ type: core.Input }],
            scrollWidth: [{ type: core.Input }],
            dndRowEnabled: [{ type: core.Input }],
            onSort: [{ type: core.Output }],
            onRowClick: [{ type: core.Output }],
            onRowSelectionChange: [{ type: core.Output }],
            onCellChange: [{ type: core.Output }],
            onHeaderSelection: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [DTHeaderComponent2,] }],
            emptyMessageTemplate: [{ type: core.ContentChild, args: ['noDataTempl',] }],
            headerTemplate: [{ type: core.ContentChild, args: ['dtHeader',] }],
            subHeaderTemplate: [{ type: core.ContentChild, args: ['dtSubHeader',] }],
            bodyTemplate: [{ type: core.ContentChild, args: ['dtBody',] }],
            headerFilterTemplate: [{ type: core.ContentChild, args: ['headerFilter',] }],
            colsQuery: [{ type: core.ContentChildren, args: [DTColumn2Component,] }],
            rowDetailColumn: [{ type: core.ContentChild, args: [DTDetailRowComponent,] }],
            valueChange: [{ type: core.Output }],
            classList: [{ type: core.HostBinding, args: ['class',] }],
            state: [{ type: core.Input }]
        };
        return Datatable2Component;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Please see datatable for more detail description. But the main goal of this wrapper to remove
     * all the common surrounding parts around the datatable and make sure DT can focus only actual
     * header and body structure
     *
     * It is expected that wrapper also provides some code for the sliding up panel containing
     * buttons and other actions that will be used during editing
     *
     *
     * Todo: Extract the expand logic out into some directive or component or just a class
     *
     */
    var DTWrapper = (function (_super) {
        __extends(DTWrapper, _super);
        function DTWrapper(env, render, thisElement, domUtils, platformId, dt) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.render = render;
            _this.thisElement = thisElement;
            _this.domUtils = domUtils;
            _this.platformId = platformId;
            _this.dt = dt;
            /**
             * Color that is used by full screen div overlay to create expanding effect which needs to have
             * little tent;
             *
             */
            _this.expandColorFrom = '#f3f3f3';
            /**
             * Color that is used to set after we are in the full screen so our overlay div hide everything
             * on the page
             *
             */
            _this.expandColorTo = '#FFFFFF';
            /**
             * In order to debounce the typing we need to use subject
             *
             */
            _this.searchTerms = new rxjs.Subject();
            /**
             *  Specifies if we are in viewing/editing mode that can browse whole dataset lazily
             *
             */
            _this.isFullScreenMode = false;
            /**
             * Tells if we can support full screen mode - only available for the browser
             *
             */
            _this.supportFullScreen = true;
            return _this;
        }
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                _super.prototype.ngOnInit.call(this);
                this.querySubscription = this.searchTerms.pipe(
                // wait 300ms after each keystroke before considering the term
                operators.debounceTime(300), 
                // ignore new term if same as previous term
                operators.distinctUntilChanged(), operators.switchMap(function (term) { return rxjs.of(term); })).subscribe(function (term) {
                    if (term) {
                        _this.dt.dataSource.find(term);
                    }
                });
                this.loadingSub = this.dt.valueChange
                    .subscribe(function (data) { return _this.loadingFinished(); });
            };
        /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         */
        /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         * @return {?}
         */
        DTWrapper.prototype.calculateFrozenWidth = /**
         * Iterates over all columns marked as frozen and retrieve a width so we can update
         * parent div
         *
         * @return {?}
         */
            function () {
                if (!this.dt.hasFrozenColumns()) {
                    return null;
                }
                var /** @type {?} */ fWidth = 0;
                this.dt.frozenColumns.forEach(function (col) {
                    if (col.maxWidthPx > 0) {
                        fWidth += col.widestCell;
                    }
                    else {
                        fWidth += parseInt(col.width);
                    }
                });
                return fWidth;
            };
        /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         */
        /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         * @param {?} frozenView
         * @param {?} unFrozenView
         * @return {?}
         */
        DTWrapper.prototype.alignTablesHeights = /**
         * When having two separate tables we need to make sure that rows of the tables are aligned.
         *
         * Therefore this method takes first column from each table read the height of the rows and set
         * the max height to both rows.
         *
         *
         * @param {?} frozenView
         * @param {?} unFrozenView
         * @return {?}
         */
            function (frozenView, unFrozenView) {
                core$1.assert(core$1.isPresent(frozenView) && core$1.isPresent(frozenView), 'Cant align table views as one of the view is undefined');
                var /** @type {?} */ frozenRows = frozenView.querySelectorAll('table tr');
                var /** @type {?} */ unFrozenRows = unFrozenView.querySelectorAll('table tr');
                core$1.assert(frozenRows.length === unFrozenRows.length, 'Frozen Column: Two tables does not much!');
                Array.from(frozenRows).forEach(function (frozen, index) {
                    var /** @type {?} */ h = Math.max(frozen.offsetHeight, unFrozenRows[index].offsetHeight);
                    frozen.style.height = h + 'px';
                    unFrozenRows[index].style.height = h + 'px';
                });
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.initFullScreen();
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                if (this.dt.hasFrozenColumns()) {
                    var /** @type {?} */ frozenView = this.thisElement.nativeElement.querySelector('.dt-body-frozen');
                    var /** @type {?} */ unFrozenView = this.thisElement.nativeElement.querySelector('.dt-body-unfrozen');
                    var /** @type {?} */ frozenWidth = this.calculateFrozenWidth();
                    frozenView.style.width = frozenWidth + 'px';
                    if (core$1.isPresent(unFrozenView)) {
                        // include border and create indent effect by having 1px white space
                        unFrozenView.style.left = (frozenWidth + 2) + 'px';
                        unFrozenView.style.width = unFrozenView.parentElement.offsetWidth
                            - frozenView.offsetWidth + 'px';
                        this.alignTablesHeights(frozenView, unFrozenView);
                    }
                }
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnDestroy.call(this);
                if (core$1.isPresent(this.querySubscription)) {
                    this.querySubscription.unsubscribe();
                }
                if (core$1.isPresent(this.loadingSub)) {
                    this.loadingSub.unsubscribe();
                }
            };
        /**
         * FULL SCREEN MODE methods
         */
        /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         */
        /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.toggleFullScreen = /**
         *
         * When fullscreen functionality is enabled this method switches between norml and full screen
         * mode
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isFullScreenMode) {
                    this.closeFullScreen(event);
                }
                else {
                    this.openFullScreen(event);
                }
            };
        /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         */
        /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.openFullScreen = /**
         * To push this component to full screen mode or maybe full page mode we need run following:
         *
         *  - Execute expand transformation, where we have additional overlay div that we slowly expand
         *  and this creates impression the DT is expanding
         *
         *  - apply full-screen class on top host element  - in this case its DataTable to switch
         *  to absolute positioning
         *
         *  - make sure we are scrolled all the way up
         *
         *  - hide all the elements on the page so their dimension don't interfere with this table.
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.isFullScreenMode = true;
                this.runExpandEffect();
                this.originalScrollPosition = window.pageYOffset;
                window.scroll(0, 0);
                this.toggleFullScreenOnDT(true);
                // mark my element in the path that needs to stay
                var /** @type {?} */ parentNode = this.thisElement.nativeElement.parentNode;
                while (core$1.isPresent(parentNode) && parentNode.tagName !== 'BODY') {
                    parentNode.classList.add('u-full-screen-element');
                    parentNode = parentNode.parentNode;
                }
                this.hideNonFullScreenElement(document.body);
                this.dt.state.limit = Math.round(this.calculateLimit());
                this.dt.dataSource.fetch(this.dt.state);
                // once loaded set back correct page size we use when loading data
                this.dt.state.limit = this.dt.pageSize;
            };
        /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         */
        /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.closeFullScreen = /**
         *
         * The same like above method (openFullScreen) but in reverse order.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                this.isFullScreenMode = false;
                this.showNonFullScreenElement();
                this.runCollapseEffect();
                this.toggleFullScreenOnDT(false);
                this.dt.dataSource.state.limit = this.dt.dataSource.state.displayLimit;
                this.dt.dataSource.state.offset = 0;
                this.dt.dataSource.fetch(this.dt.dataSource.state);
                setTimeout(function () {
                    window.scroll(0, _this.originalScrollPosition);
                }, 300);
            };
        /**
         * Creates animation effect to make it feel like the element (in this case DT) is expanding
         * from the middle to the full page mode.
         *
         * We take the dimension of the table then it is scaled slowly to the full page
         * @return {?}
         */
        DTWrapper.prototype.runExpandEffect = /**
         * Creates animation effect to make it feel like the element (in this case DT) is expanding
         * from the middle to the full page mode.
         *
         * We take the dimension of the table then it is scaled slowly to the full page
         * @return {?}
         */
            function () {
                var _this = this;
                this.dtBoundingClientRect = this.thisElement.nativeElement.getBoundingClientRect();
                this.updateElement();
                this.dtFullScreenOverlay.nativeElement.style.backgroundColor = this.expandColorFrom;
                this.dtFullScreenOverlay.nativeElement.style.opacity = 1;
                this.applyTransformation(true);
                setTimeout(function () {
                    _this.dtFullScreenOverlay.nativeElement.style.backgroundColor = _this.expandColorTo;
                }, 300);
            };
        /**
         * Applies the transformation and scale the helper div (overlay) down to make it look like
         * it collapses
         * @return {?}
         */
        DTWrapper.prototype.runCollapseEffect = /**
         * Applies the transformation and scale the helper div (overlay) down to make it look like
         * it collapses
         * @return {?}
         */
            function () {
                var _this = this;
                this.updateElement();
                this.applyTransformation(false);
                setTimeout(function () {
                    _this.updateElement();
                    _this.dtFullScreenOverlay.nativeElement.style.opacity = 0;
                }, 200);
                setTimeout(function () {
                    _this.updateElement(_this.dtBoundingClientRect.left, _this.dtBoundingClientRect.top, 0, 0);
                }, 400);
            };
        /**
         * DFS  - to go thru all the element under BODY and remove them from the page.
         *
         * @param {?} parentElement
         * @return {?}
         */
        DTWrapper.prototype.hideNonFullScreenElement = /**
         * DFS  - to go thru all the element under BODY and remove them from the page.
         *
         * @param {?} parentElement
         * @return {?}
         */
            function (parentElement) {
                if (this.thisElement.nativeElement.parentNode === parentElement) {
                    return;
                }
                for (var /** @type {?} */ i = 0; i < parentElement.children.length; i++) {
                    var /** @type {?} */ element = parentElement.children[i];
                    if (this.needTraverseDown(element)) {
                        this.hideNonFullScreenElement(element);
                    }
                    else if (!element.classList.contains('dt-full-screen')) {
                        element.classList.add('u-fs-element-out');
                    }
                }
            };
        /**
         * Put all the element that were previously removed by hideNonFullScreenElement() back
         * @return {?}
         */
        DTWrapper.prototype.showNonFullScreenElement = /**
         * Put all the element that were previously removed by hideNonFullScreenElement() back
         * @return {?}
         */
            function () {
                Array.from(document.querySelectorAll('.u-fs-element-out'))
                    .forEach(function (elem) { return elem.classList.remove('u-fs-element-out'); });
            };
        /**
         * \@Internal
         *
         * @param {?} element
         * @return {?}
         */
        DTWrapper.prototype.needTraverseDown = /**
         * \@Internal
         *
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return core$1.isPresent(element) && element.tagName !== 'SCRIPT' &&
                    element.classList.contains('u-full-screen-element') &&
                    !element.classList.contains('dt-full-screen');
            };
        /**
         * When we enter full screen /page mode when need to calculate how many rows to load initially
         *
         * @return {?}
         */
        DTWrapper.prototype.calculateLimit = /**
         * When we enter full screen /page mode when need to calculate how many rows to load initially
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ browserH = this.domUtils.browserDimentions().height;
                var /** @type {?} */ rowH = this.dt.el.nativeElement.querySelector('tbody tr:first-child').offsetHeight;
                return (core$1.isPresent(rowH) && rowH > 0) ? (browserH / rowH) + 20 : 50;
            };
        /**
         * \@Internal
         *
         * @param {?=} l
         * @param {?=} t
         * @param {?=} w
         * @param {?=} h
         * @return {?}
         */
        DTWrapper.prototype.updateElement = /**
         * \@Internal
         *
         * @param {?=} l
         * @param {?=} t
         * @param {?=} w
         * @param {?=} h
         * @return {?}
         */
            function (l, t, w, h) {
                if (l === void 0) {
                    l = this.dtBoundingClientRect.left;
                }
                if (t === void 0) {
                    t = this.dtBoundingClientRect.top;
                }
                if (w === void 0) {
                    w = this.dtBoundingClientRect.width;
                }
                if (h === void 0) {
                    h = this.dtBoundingClientRect.height;
                }
                this.dtFullScreenOverlay.nativeElement.style.left = l + 'px';
                this.dtFullScreenOverlay.nativeElement.style.top = t + 'px';
                this.dtFullScreenOverlay.nativeElement.style.width = w + 'px';
                this.dtFullScreenOverlay.nativeElement.style.height = h + 'px';
            };
        /**
         * \@Internal
         *
         * @param {?} expand
         * @return {?}
         */
        DTWrapper.prototype.applyTransformation = /**
         * \@Internal
         *
         * @param {?} expand
         * @return {?}
         */
            function (expand) {
                var /** @type {?} */ x, /** @type {?} */ y, /** @type {?} */ tx, /** @type {?} */ ty;
                if (expand) {
                    x = window.innerWidth / this.dtBoundingClientRect.width;
                    y = window.innerHeight / this.dtBoundingClientRect.height;
                    tx = (window.innerWidth / 2 - this.dtBoundingClientRect.width / 2
                        - this.dtBoundingClientRect.left) / x;
                    ty = (window.innerHeight / 2 - this.dtBoundingClientRect.height / 2
                        - this.dtBoundingClientRect.top) / y;
                }
                else {
                    x = 1;
                    y = 1;
                    tx = this.dtBoundingClientRect.left;
                    ty = this.dtBoundingClientRect.top;
                }
                this.dtFullScreenOverlay.nativeElement.style.transform =
                    'scaleX(' + x + ') scaleY(' + y + ') translate3d(' + (tx) + 'px, ' + (ty) + 'px, 0px)';
            };
        /**
         * @return {?}
         */
        DTWrapper.prototype.initFullScreen = /**
         * @return {?}
         */
            function () {
                if (!common.isPlatformBrowser(this.platformId)) {
                    this.supportFullScreen = false;
                    return;
                }
                this.render.appendChild(document.body, this.dtFullScreenOverlay.nativeElement);
            };
        /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         */
        /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         * @param {?} fullScreen
         * @return {?}
         */
        DTWrapper.prototype.toggleFullScreenOnDT = /**
         * Applies set of set of css properties to make the DT main component on the page expand to
         * full page mode and back
         *
         * We want to make it with little delay to let other animation finish
         * @param {?} fullScreen
         * @return {?}
         */
            function (fullScreen) {
                var _this = this;
                this.dt.el.nativeElement.style.opacity = 0;
                setTimeout(function () {
                    if (fullScreen) {
                        _this.dt.classList += 'dt-full-screen';
                        _this.dt.el.nativeElement.style.opacity = 1;
                    }
                    else {
                        _this.dt.classList = _this.dt.classList.replace('dt-full-screen', '');
                        _this.dt.el.nativeElement.style.opacity = 1;
                    }
                }, 200);
            };
        /**
         * INFINITE SCROLLING METHODS
         */
        /**
         * Listen for infinite scroll event and request new data from data source
         *
         */
        /**
         * Listen for infinite scroll event and request new data from data source
         *
         * @param {?} event
         * @return {?}
         */
        DTWrapper.prototype.onLazyLoad = /**
         * Listen for infinite scroll event and request new data from data source
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.isLoad) {
                    this.dt.state.offset = event.offset;
                    this.dt.dataSource.fetch(this.dt.state);
                }
                else {
                    var /** @type {?} */ dataProvider = this.dt.dataSource.dataProvider;
                    var /** @type {?} */ data = dataProvider.dataChanges.getValue();
                    dataProvider.dataChanges.next(data.slice(0, event.offset));
                }
            };
        /**
         * When loading is finished mark loading icon is done so we can hide it. I am using little
         * delay to make the animation visible
         * @return {?}
         */
        DTWrapper.prototype.loadingFinished = /**
         * When loading is finished mark loading icon is done so we can hide it. I am using little
         * delay to make the animation visible
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.infiniteScroll)) {
                    setTimeout(function () { return _this.infiniteScroll.complete(); }, 200);
                }
            };
        DTWrapper.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-dt-wrapper',
                        template: "<div [ngClass]=\"dt.styleClass\" [class.dt-full-screen-mode]=\"isFullScreenMode\"\n     [style.width]=\"dt.width\"\n>\n    <div class=\"dt-loading-overlay\" *ngIf=\"dt.loading\"></div>\n    <div class=\"dt-loading-content\" *ngIf=\"dt.loading\">\n        <i [class]=\"'sap-icon u-dt-spin-icon ' + dt.loadingIcon\"></i>\n    </div>\n\n    <div class=\"dt-header\" *ngIf=\"dt.showTableHeader\">\n        <ng-template *ngIf=\"dt.header; then appDefinedHeader else defaultHeader\"></ng-template>\n    </div>\n\n    <!-- DT BODY with table headers and values -->\n    <div class=\"dt-body-wrapper-view\">\n        <ng-template\n            *ngIf=\"dt.hasFrozenColumns(); then dtBodyWithFrozenColumns else dtBodyNoFrozenColumns\">\n        </ng-template>\n    </div>\n\n    <!--<div class=\"dt-footer\" *ngIf=\"footer\">-->\n    <!--&lt;!&ndash; footerArea&ndash;&gt;-->\n    <!--<ng-content select=\"aw-dt-footer\"></ng-content>-->\n    <!--</div>-->\n</div>\n\n<!-- todo: dont activate this if we reached the end of list - -->\n<aw-infinite-scroll #infiniteScroll *ngIf=\"isFullScreenMode\"\n                    [distance]=\"'10%'\"\n                    [fetchSize]=\"dt.state.limit\"\n                    (onLoad)=\"onLazyLoad($event)\">\n</aw-infinite-scroll>\n\n\n<ng-template #appDefinedHeader>\n    <ng-container *ngTemplateOutlet=\"heading;\"></ng-container>\n</ng-template>\n\n<ng-template #defaultHeader>\n    <div class=\"dt-global-filter\">\n        <span class=\"sap-icon icon-filter\"></span>\n    </div>\n\n    <div class=\"dt-global-actions\">\n        <div class=\"dt-action-combo\">\n            <span *ngIf=\"supportFullScreen\" class=\"sap-icon icon-resize\"\n                  (click)=\"toggleFullScreen($event)\"></span>\n\n            <aw-input-field *ngIf=\"dt.showGlobalSearch\" styleClass=\"dt-table-search\"\n                            [(ngModel)]=\"dt.state.currentSearchQuery\"\n                            placeHolder=\"search\"\n                            icon=\"icon-search\"\n                            (ngModelChange)=\"searchTerms.next($event)\">\n            </aw-input-field>\n            <span class=\"ariba-icon icon-more\"></span>\n        </div>\n    </div>\n</ng-template>\n\n\n<ng-template #dtBodyNoFrozenColumns>\n    <!--\n        For non-frozen case we also need to set TRUE as the view is actually frozen and does not\n        scroll.\n        We use this frozenColumns flag inside DT to properly set column index on the header level\n        columnIndex:(frozen ? columnIndex: (columns.length + columnIndex))\n\n        therefore we need to set true even in this case to return real columnIndex since we dont\n        have the second table.\n    -->\n    <ng-container *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: true }\">\n    </ng-container>\n</ng-template>\n\n<ng-template #dtBodyWithFrozenColumns>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.frozenColumns, frozenColumns: true }\">\n    </ng-container>\n    <ng-container\n        *ngTemplateOutlet=\"dtBody; context:{$implicit: dt.columns, frozenColumns: false }\">\n    </ng-container>\n</ng-template>\n\n\n<ng-template #dtBody let-columns let-frozenColumns=\"frozenColumns\">\n\n    <div #dtContainer class=\"dt-body-wrapper\"\n         [style.width.px]=\"this.calculateFrozenWidth()\"\n         [class.dt-body-unfrozen]=\"dt.hasFrozenColumns() && !frozenColumns\"\n         [class.dt-body-frozen]=\"dt.hasFrozenColumns() && frozenColumns\"\n    >\n\n        <table [ngClass]=\"dt.tableStyleClass\"\n               [style.width]=\"frozenColumns ? null : dt.scrollWidth\"\n               [class.dt-pivot-layout]=\"dt.pivotalLayout\"\n               [class.dt-plain-layout]=\"!dt.pivotalLayout && !dt.isOutline()\">\n\n            <!-- Render TH header rows-->\n            <thead class=\"dt-thead\">\n                <ng-container *ngTemplateOutlet=\"headerRows; context:{$implicit: columns,frozenColumns:frozenColumns }\">\n                </ng-container>\n            </thead>\n\n            <!--\n                Render data rows. For data rows we need to keep tbody tag inside DT table\n                due to Outline\n             -->\n            <ng-container *ngTemplateOutlet=\"bodyRows; context:{$implicit: columns,  frozenColumns:frozenColumns }\">\n            </ng-container>\n        </table>\n    </div>\n</ng-template>\n\n\n<div #dtFullScreenOverlay class=\"dt-full-screen-overlay u-full-screen-element\"></div>\n",
                        styles: [".dt-footer,.dt-header{text-align:center;padding:.5em .75em;box-sizing:border-box}.dt-footer{border-top:0}.dt-thead tr{border-width:0}.dt-body-wrapper-view{position:relative}.dt-body-wrapper{overflow:hidden;border:1px solid #d7d7d7}.dt-body-wrapper.dt-body-unfrozen{border-left-color:transparent;position:absolute;top:0;overflow-x:auto}.dt-loading-overlay{position:absolute;background-color:#9b9b9b;width:100%;height:100%;opacity:.1;z-index:1}.dt-loading-content{position:absolute;left:50%;top:25%;z-index:2}.dt-header{width:100%;display:flex;flex-flow:row nowrap;justify-content:space-between;color:#363636;border-bottom:1px solid #f1f1f1;margin-bottom:30px}.dt-header .dt-global-filter{flex:0 0;align-items:flex-start;font-size:18px}.dt-header .dt-global-actions{flex:0 0;align-items:flex-end}.dt-header .dt-action-combo{display:flex;flex-flow:row nowrap;color:#7d7d7d}.dt-header .dt-action-combo .ariba-icon,.dt-header .dt-action-combo .sap-icon{margin-left:15px;font-size:20px;align-self:center;cursor:pointer}.dt-header .dt-action-combo .dt-table-search{border-top-color:transparent;border-left-color:transparent;border-right-color:transparent}.dt-header .dt-action-combo .icon-resize{color:#4a4a4a;font-size:16px;line-height:18px;margin-right:15px}.u-dt-spin-icon{display:inline-block;-webkit-animation:2s linear infinite doSpin;animation:2s linear infinite doSpin}@-webkit-keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes doSpin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.dt-full-screen-overlay{position:fixed;z-index:100;-webkit-transform-origin:50% 50%;transform-origin:50% 50%;transition:all .4s ease-in-out}.dt-full-screen{width:98vw;z-index:120;position:absolute;top:15px;pointer-events:all;transition:opacity .5s ease-in-out}.u-fs-element-out{display:none}"],
                        encapsulation: core.ViewEncapsulation.None
                    },] },
        ];
        /** @nocollapse */
        DTWrapper.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.Renderer2 },
                { type: core.ElementRef },
                { type: DomUtilsService },
                { type: Object, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
                { type: Datatable2Component, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return Datatable2Component; }),] }] }
            ];
        };
        DTWrapper.propDecorators = {
            expandColorFrom: [{ type: core.Input }],
            expandColorTo: [{ type: core.Input }],
            heading: [{ type: core.ContentChild, args: ['headingArea',] }],
            headerRows: [{ type: core.ContentChild, args: ['headerRows',] }],
            bodyRows: [{ type: core.ContentChild, args: ['bodyRows',] }],
            footer: [{ type: core.ContentChild, args: ['footerArea',] }],
            dtFullScreenOverlay: [{ type: core.ViewChild, args: ['dtFullScreenOverlay',] }],
            infiniteScroll: [{ type: core.ViewChild, args: ['infiniteScroll',] }]
        };
        return DTWrapper;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * This directive is responsible for checking and setting the widest content width onto
     * Column component as the widestCell property.
     *
     *
     *
     *
     */
    var SetCellMaxWidthDirective = (function () {
        function SetCellMaxWidthDirective(element, render, td) {
            this.element = element;
            this.render = render;
            this.td = td;
        }
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (core$1.isPresent(this.maxWidth) && this.maxWidth > 0) {
                    var /** @type {?} */ inlineData = this.element.nativeElement.querySelector('.dt-col-cell-data');
                    if (core$1.isPresent(inlineData)) {
                        inlineData.style.whiteSpace = 'nowrap';
                        inlineData.style.display = 'inline-block';
                        var /** @type {?} */ cellWidth = inlineData.offsetWidth; // td
                        inlineData.style.whiteSpace = 'normal';
                        inlineData.style.display = 'inline';
                        if (!this.isInThresHold(cellWidth)) {
                            return;
                        }
                        cellWidth += this.tdPadding();
                        if (cellWidth > this.td.widthPx) {
                            if (cellWidth < this.maxWidth) {
                                this.td.widestCell = cellWidth > this.td.widestCell ? cellWidth :
                                    this.td.widestCell;
                            }
                            else if (cellWidth >= this.maxWidth) {
                                this.td.widestCell = this.maxWidth > this.td.widestCell ? this.maxWidth :
                                    this.td.widestCell;
                            }
                        }
                    }
                }
            };
        /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         */
        /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         * @param {?} newWidth
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.isInThresHold = /**
         *
         * Is the new width the same as the one already set on the column? If yes then probably
         * new content does not differ that much. We still keep certain threshold as the new content
         * width might differ 1 or 2 pixes depending how set the css.
         *
         * To make sure we resize column only if necessary because it could be original size
         * is 400px but the new one is 401px since somewhere add some extra border we have this
         * safe threshold
         *
         * @param {?} newWidth
         * @return {?}
         */
            function (newWidth) {
                if (this.td.widestCell > 0) {
                    return Math.abs(this.td.widestCell - newWidth) > 3 && newWidth > this.td.widestCell;
                }
                return true;
            };
        /**
         * @return {?}
         */
        SetCellMaxWidthDirective.prototype.tdPadding = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ computedStyle = getComputedStyle(this.element.nativeElement);
                var /** @type {?} */ cell = parseInt(computedStyle.paddingLeft) || 0;
                cell += parseInt(computedStyle.paddingRight) || 0;
                cell += parseInt(computedStyle.borderRightWidth) || 0;
                cell += parseInt(computedStyle.borderLeftWidth) || 0;
                // plus give it some little space around the text so it nots px to px inner width of the td
                // cuz it could wrap
                cell += 5;
                return cell;
            };
        SetCellMaxWidthDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[maxWidth]'
                    },] },
        ];
        /** @nocollapse */
        SetCellMaxWidthDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: DTColumn2Component }
            ];
        };
        SetCellMaxWidthDirective.propDecorators = {
            maxWidth: [{ type: core.Input }]
        };
        return SetCellMaxWidthDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Directive used inside DT in order to support table rows re-ordering. This manages all the
     * D&D necessary logic for this functionality.
     *
     * [dtDraggableRow] is used inside the `rowTemplate` like this:
     *
     *
     * ```html
     *
     * <ng-template #rowTemplate let-rowData let-even='event" let-odd="odd" let-rowIndex="rowIndex"
     *              let-nestingLevel="nestingLevel" let-colsToRender="colsToRender">
     *
     *     <tr #rowElement dtDraggableRow [dndRowIndex]="rowIndex"
     *          class="dt-body-row"
     *
     *
     *
     * ```
     *
     * which enabled or disables based on the used DT binding [dndRowEnabled]. By default its disabled.
     *
     *
     *
     */
    var DTDraggableRowDirective = (function () {
        function DTDraggableRowDirective(element, dt, domUtils, ngZone) {
            this.element = element;
            this.dt = dt;
            this.domUtils = domUtils;
            this.ngZone = ngZone;
            /**
             *
             * Tells the directive if we enable middle row zone to create an effect that we are dropping
             * into the row. Used for outline DT mainly.
             *
             */
            this.dropIntoEnabled = false;
            /**
             * Current TR index number
             *
             */
            this.dndRowIndex = 0;
            /**
             * Holds information about our dragging direction UP and DOWN in order to assign correct style
             * that highlights the row at the top or bottom
             *
             */
            this.dragDir = DragDirection.None;
            /**
             * Indicates that we dragged our row and stopped in the middle of the other row
             *
             */
            this.inMiddle = false;
            /**
             *
             * Current drag Y coordinates which is used together with the dragDir when assinging dragging
             * direction.
             *
             */
            this.dragY = 0;
        }
        /**
         * @return {?}
         */
        DTDraggableRowDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.dt.dndRowEnabled) {
                    this.setupEventListeners();
                }
            };
        /**
         * @return {?}
         */
        DTDraggableRowDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this.dt.dndRowEnabled) {
                    this.releaseEventListeners();
                }
            };
        /**
         * Setups listeners and returns handle to them so we can later on unsubscribe.
         * @return {?}
         */
        DTDraggableRowDirective.prototype.setupEventListeners = /**
         * Setups listeners and returns handle to them so we can later on unsubscribe.
         * @return {?}
         */
            function () {
                var _this = this;
                this.ngZone.runOutsideAngular(function () {
                    _this.eventHandlers = {};
                    _this.eventHandlers['mousedown'] = _this.onMouseDownEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('mousedown', _this.eventHandlers['mousedown']);
                    _this.eventHandlers['dragstart'] = _this.onDragStartEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragstart', _this.eventHandlers['dragstart']);
                    _this.eventHandlers['dragover'] = _this.onDragOverEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragover', _this.eventHandlers['dragover']);
                    _this.eventHandlers['dragleave'] = _this.onDragLeaveEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragleave', _this.eventHandlers['dragleave']);
                    _this.eventHandlers['drop'] = _this.onDropEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('drop', _this.eventHandlers['drop']);
                    _this.eventHandlers['dragend'] = _this.onDragEndEvent.bind(_this);
                    _this.element.nativeElement.addEventListener('dragend', _this.eventHandlers['dragend']);
                });
            };
        /**
         * Removes all the created listeners inside destroy() callback
         * @return {?}
         */
        DTDraggableRowDirective.prototype.releaseEventListeners = /**
         * Removes all the created listeners inside destroy() callback
         * @return {?}
         */
            function () {
                var _this = this;
                DragEvents.forEach(function (name) {
                    document.removeEventListener('name', _this.eventHandlers[name]);
                });
            };
        /**
         *
         * This is first event where we:
         *
         *  - Mark element draggable to enable D&D
         *  - Set click position relative to the middle of the current row
         *      This is mainly needed when we are trying to calculate something for
         *      dropInto row (outline)
         *
         * event.target usually contains reference to TD element
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onMouseDownEvent = /**
         *
         * This is first event where we:
         *
         *  - Mark element draggable to enable D&D
         *  - Set click position relative to the middle of the current row
         *      This is mainly needed when we are trying to calculate something for
         *      dropInto row (outline)
         *
         * event.target usually contains reference to TD element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.altKey && this.domUtils.hasParent(event.target, '.dt-row-draggable')) {
                    this.element.nativeElement.draggable = true;
                    var /** @type {?} */ elToBeDragged = this.domUtils.elementDimensions(event.target);
                    this.dt.env.setValue('ddClickDeviance', (elToBeDragged.height / 2) - event.offsetY);
                }
                else {
                    this.element.nativeElement.draggable = false;
                }
            };
        /**
         * This is second triggered event when the actual dragging starts. Here we need to disable
         * dragged row and save information that are common to a table.
         *
         * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
         * if we would go without it then D&D framework would create a copy of row in disabled state.
         * Now we grab a row with active state and after a 200ms delay we disable the original row.
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragStartEvent = /**
         * This is second triggered event when the actual dragging starts. Here we need to disable
         * dragged row and save information that are common to a table.
         *
         * Marking row disabled with the style .dt-row-dragging using setTimeout is needed as
         * if we would go without it then D&D framework would create a copy of row in disabled state.
         * Now we grab a row with active state and after a 200ms delay we disable the original row.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                setTimeout(function () {
                    if (core$1.isPresent(event.target.classList)) {
                        event.target.classList.add('dt-row-dragging');
                    }
                }, 200);
                this.dt.env.setValue('isDragging', true);
                this.dt.env.setValue('dndId', this.dndRowIndex);
                event.dataTransfer.setData('text', this.dndRowIndex);
            };
        /**
         *
         * This events happens anytime as we drag over rows. This event triggered after certain
         * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
         *
         * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
         * show a user where we are.
         *
         * Once we know the direction and the drop target is valid we mark the row with correct class
         * that does the trick
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragOverEvent = /**
         *
         * This events happens anytime as we drag over rows. This event triggered after certain
         * delay. In here we calculate the mouse movement to identify if we are going UP or DOWN.
         *
         * This is mainly needed to mark a row with the correct line on TOP or BOTTOM to visually
         * show a user where we are.
         *
         * Once we know the direction and the drop target is valid we mark the row with correct class
         * that does the trick
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.dataTransfer.dropEffect = 'move';
                if (this.dragY < event.pageY) {
                    this.dragDir = DragDirection.Down;
                }
                else if (this.dragY > event.pageY) {
                    this.dragDir = DragDirection.Up;
                }
                // dont set again unless its different
                if (this.dragY !== event.pageY) {
                    this.dragY = event.pageY;
                }
                if (this.isValidDropTarget(event)) {
                    // todo test this preventDefault() so it does not create some sideeffect
                    event.preventDefault();
                    this.markRowWithClass(event, this.domUtils.closest(event.target, 'tr'));
                }
            };
        /**
         * This is finishing event just before D&D is done. It takes current information and
         * broadcast them to the DT so DT can do necessary row reordering
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDropEvent = /**
         * This is finishing event just before D&D is done. It takes current information and
         * broadcast them to the DT so DT can do necessary row reordering
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.clearClasses(event.target.parentElement);
                // event.preventDefault();
                var /** @type {?} */ origIndx = this.dt.env.getValue('dndId');
                var /** @type {?} */ dropPos = this.inMiddle ? DropPosition.Into : (this.dragDir === DragDirection.Up ? DropPosition.Before : DropPosition.After);
                this.dt.onDnDRowDrop(origIndx, this.dndRowIndex, dropPos);
                this.inMiddle = false;
                this.dragY = 0;
            };
        /**
         * Every time we drag over the element we apply some classes to the it. this method does the
         * opposite which is to remove everything so we are ready for the next row
         *
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragLeaveEvent = /**
         * Every time we drag over the element we apply some classes to the it. this method does the
         * opposite which is to remove everything so we are ready for the next row
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ tr = this.domUtils.closest(event.target, 'tr');
                this.clearClasses(tr);
                this.dt.env.deleteValue('dndOnHoldIndex');
            };
        /**
         *
         * This is last event within D&D flow. Mainly used to clean up all the resource that has not
         * been clean up already inside onDropEvent.
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.onDragEndEvent = /**
         *
         * This is last event within D&D flow. Mainly used to clean up all the resource that has not
         * been clean up already inside onDropEvent.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isPresent(event.target.classList)) {
                    event.target.classList.remove('dt-row-dragging');
                }
                this.clearClasses(event.target);
                this.element.nativeElement.draggable = false;
                this.dt.env.deleteValue('isDragging');
                this.dt.env.deleteValue('dndId');
                this.dt.env.deleteValue('ddClickDeviance');
            };
        /**
         * Assign CSS classes to the row to create an highlighting effect to capture current position
         * for the user.
         *
         * Based on the Drag direction we either apply
         * css class that creates a line on top or bottom.  Only for the dropInto functionality we
         * need to calculate some more to identify if we are really in the middle of the row.
         *
         * DropInto:
         * ---------
         *
         * Initially we captured a position (in mousedown) the distance to the middle of the row and
         * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
         * perfect.
         *
         * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
         *      Read center of current row
         *
         * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
         *      Read mouse coordinates relative to current row/td and add to it our deviation.
         *
         *
         * @param {?} event
         * @param {?} activeRow
         * @return {?}
         */
        DTDraggableRowDirective.prototype.markRowWithClass = /**
         * Assign CSS classes to the row to create an highlighting effect to capture current position
         * for the user.
         *
         * Based on the Drag direction we either apply
         * css class that creates a line on top or bottom.  Only for the dropInto functionality we
         * need to calculate some more to identify if we are really in the middle of the row.
         *
         * DropInto:
         * ---------
         *
         * Initially we captured a position (in mousedown) the distance to the middle of the row and
         * this we are using here with some threshold of 2 pixes so we dont have to be exactly on pixel
         * perfect.
         *
         * - let currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
         *      Read center of current row
         *
         * - let draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
         *      Read mouse coordinates relative to current row/td and add to it our deviation.
         *
         *
         * @param {?} event
         * @param {?} activeRow
         * @return {?}
         */
            function (event, activeRow) {
                this.clearClasses(activeRow);
                // Check if drag item is in the middle of other row
                var /** @type {?} */ currentTrCenter = this.domUtils.elementDimensions(activeRow).height / 2;
                var /** @type {?} */ draggedTrCenter = event.offsetY + this.dt.env.getValue('ddClickDeviance');
                if (this.dropIntoEnabled) {
                    this.inMiddle = Math.abs(currentTrCenter - draggedTrCenter) < 2;
                }
                if (this.inMiddle) {
                    activeRow.classList.add(DragDirection.Middle);
                }
                else {
                    activeRow.classList.add(this.dragDir);
                }
            };
        /**
         *
         * Drop target must be only another TR and it cannot be the element itself the one we are
         * dragging and it does not make sense to allow to drop to the same position we started from
         *
         * @param {?} event
         * @return {?}
         */
        DTDraggableRowDirective.prototype.isValidDropTarget = /**
         *
         * Drop target must be only another TR and it cannot be the element itself the one we are
         * dragging and it does not make sense to allow to drop to the same position we started from
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ origInx = this.dt.env.getValue('dndId');
                var /** @type {?} */ siblingRow = this.dndRowIndex - origInx;
                return event.target.parentElement.tagName === 'TR' && this.dndRowIndex !== origInx &&
                    !(siblingRow === 1 && this.dragDir === DragDirection.Up) &&
                    !(siblingRow === -1 && this.dragDir === DragDirection.Down);
            };
        /**
         *  private
         *
         * @param {?} tr
         * @return {?}
         */
        DTDraggableRowDirective.prototype.clearClasses = /**
         *  private
         *
         * @param {?} tr
         * @return {?}
         */
            function (tr) {
                tr.classList.remove('dt-drag-row-top');
                tr.classList.remove('dt-drag-row-bottom');
                tr.classList.remove('dt-drag-row-both');
            };
        /**
         *  private
         *
         * @return {?}
         */
        DTDraggableRowDirective.prototype.dragDirToString = /**
         *  private
         *
         * @return {?}
         */
            function () {
                switch (this.dragDir) {
                    case DragDirection.Up:
                        return 'Up';
                    case DragDirection.Down:
                        return 'Down';
                    default:
                        return 'Not Sure';
                }
            };
        DTDraggableRowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[dtDraggableRow]'
                    },] },
        ];
        /** @nocollapse */
        DTDraggableRowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: Datatable2Component, decorators: [{ type: core.Inject, args: [core.forwardRef(function () { return Datatable2Component; }),] }] },
                { type: DomUtilsService },
                { type: core.NgZone }
            ];
        };
        DTDraggableRowDirective.propDecorators = {
            dropIntoEnabled: [{ type: core.Input }],
            dndRowIndex: [{ type: core.Input }]
        };
        return DTDraggableRowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWDatatable2Module = (function () {
        function AWDatatable2Module() {
        }
        AWDatatable2Module.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            Datatable2Component,
                            DTWrapper,
                            DTColumn2Component,
                            DTHeaderComponent2,
                            DTDetailRowComponent,
                            DTDetailRowExpanderComponent,
                            DTMultiSelectColumnComponent,
                            DTSingleSelectColumnComponent,
                            SetCellMaxWidthDirective,
                            DTDraggableRowDirective
                        ],
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            AWCoreComponentModule,
                            AWCheckBoxModule,
                            AWOutlineForModule,
                            AWRadioButtonModule,
                            AWInputFieldModule
                        ],
                        entryComponents: [
                            DTDetailRowExpanderComponent,
                            DTMultiSelectColumnComponent,
                            DTSingleSelectColumnComponent
                        ],
                        exports: [
                            Datatable2Component,
                            DTColumn2Component,
                            AWOutlineForModule,
                            DTHeaderComponent2,
                            DTDetailRowComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWDatatable2Module;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An confirmation header area.
     *
     * See {\@link ConfirmationComponent} for more explanation.
     */
    var ConfirmationHeaderComponent = (function () {
        function ConfirmationHeaderComponent() {
        }
        ConfirmationHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation-header',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return ConfirmationHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * An confirmation header area.
     *
     * See {\@link ConfirmationComponent} for more explanation.
     */
    var ConfirmationFooterComponent = (function () {
        function ConfirmationFooterComponent() {
        }
        ConfirmationFooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation-footer',
                        template: '<ng-content></ng-content>'
                    },] },
        ];
        return ConfirmationFooterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Confirmation Component is a specific version of the dialog where it supports confirm and cancel
     * functionality. It behaves like a dialog, is modal, and not closable by default.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<ConfirmationComponent>), service.close()
     *
     * Usage:
     *    1.  Using ModalService directly to display a modal popup. This usage is a quick way to show
     *        a confirmation to the user.
     *
     *          this.modalService.open<ConfirmationComponent>(ConfirmationComponent, {
     *                        title: 'Confirmation',
     *                        body: ` Are you sure ? `,
     *                        width: 300,
     *                        onConfirm: () => {
     *                              this.confirmAction();
     *                        },
     *                        onCancel: () => {
     *                              this.cancelAction();
     *                        }
     *           });
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                              <aw-confirmation [title]="'Confirmation'"
     *                                      [(visible)]="display"
     *                                     (onConfirm)="confirmAction()"
     *                                    (onCancel)="cancelAction()">
     *                                       <i class="sap-icon icon-alert"></i>
     *                                       Are you sure you want to delete your hard drive?
     *                            </aw-confirmation>
     *
     *                                   <aw-button [size]="'small'" (click)="open()">
     *                                       Open Confirmation
     *                                   </aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     display: boolean = false;
     *
     *                     confirmAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *
     *                     open() {
     *                        this.display = true;
     *                     }
     *
     *                     confirmAction()  {
     *                        this.confirmAction = "confirmed";
     *                      }
     *
     *                      close() {
     *                         this.display = false;
     *                      }
     *
     *                      cancelAction() {
     *                          this.confirmAction = "canceled";
     *                      }
     *
     *       }
     *
     *
     */
    var ConfirmationComponent = (function (_super) {
        __extends(ConfirmationComponent, _super);
        function ConfirmationComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * support two way data binding on visible property.
             */
            _this.visibleChange = new core.EventEmitter();
            /**
             * Whether there's an x at the top right that makes the dialog closable.
             */
            _this.closable = false;
            /**
             * Event fired when dialog is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the dialog is opened.
             */
            _this.onOpen = new core.EventEmitter();
            /**
             * Fired when user clicked on confirm button.
             */
            _this.onConfirm = new core.EventEmitter();
            /**
             * Fired when user clicked on cancel button.
             */
            _this.onCancel = new core.EventEmitter();
            _this.width = 400;
            _this.height = 'auto';
            // Todo: internationalize.
            // Todo: internationalize.
            _this.confirmActionLabel = 'Confirm';
            _this.cancelActionLabel = 'Cancel';
            return _this;
        }
        /**
         * open confirmation.
         */
        /**
         * open confirmation.
         * @return {?}
         */
        ConfirmationComponent.prototype.open = /**
         * open confirmation.
         * @return {?}
         */
            function () {
                this.visible = true;
                this.onOpen.emit();
                this.visibleChange.emit(true);
            };
        /**
         * close confirmation.
         */
        /**
         * close confirmation.
         * @return {?}
         */
        ConfirmationComponent.prototype.close = /**
         * close confirmation.
         * @return {?}
         */
            function () {
                this.visible = false;
                this.onClose.emit();
                // Important to make sure change is set on parent binding.
                // Otherwise, the variable and dialog open/close state can be out
                // of sync and we wouldn't trigger change detection.
                this.visibleChange.emit(false);
            };
        /**
         * Does the confirmation have header content?
         */
        /**
         * Does the confirmation have header content?
         * @return {?}
         */
        ConfirmationComponent.prototype.hasHeader = /**
         * Does the confirmation have header content?
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.header);
            };
        /**
         * Does the confirmation have footer content?
         */
        /**
         * Does the confirmation have footer content?
         * @return {?}
         */
        ConfirmationComponent.prototype.hasFooter = /**
         * Does the confirmation have footer content?
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.footer);
            };
        /**
         * Confirm action.
         */
        /**
         * Confirm action.
         * @return {?}
         */
        ConfirmationComponent.prototype.confirm = /**
         * Confirm action.
         * @return {?}
         */
            function () {
                this.close();
                this.onConfirm.emit();
            };
        /**
         * Cancel action.
         */
        /**
         * Cancel action.
         * @return {?}
         */
        ConfirmationComponent.prototype.cancel = /**
         * Cancel action.
         * @return {?}
         */
            function () {
                this.close();
                this.onCancel.emit();
            };
        ConfirmationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-confirmation',
                        template: "<aw-dialog [title]=\"title\" [(visible)]=\"visible\"\n           [modal]=\"true\" [closable]=\"closable\" [width]=\"width\" [height]=\"height\"\n           [styleClass]=\"styleClass\" [appendTo]=\"appendTo\" (onOpen)=\"open()\" (onClose)=\"close()\">\n\n    <aw-dialog-header *ngIf=\"hasHeader()\">\n        <ng-content select=\"aw-confirmation-header\"></ng-content>\n    </aw-dialog-header>\n\n    {{body}}\n    <ng-content></ng-content>\n\n\n    <aw-dialog-footer *ngIf=\"hasFooter(); else defaultFooter\">\n        <ng-content select=\"aw-confirmation-footer\"></ng-content>\n    </aw-dialog-footer>\n\n    <ng-template #defaultFooter>\n        <aw-dialog-footer>\n            <aw-button name=\"confirm\" [style]=\"'primary'\" (action)=\"confirm()\">\n                {{confirmActionLabel}}\n            </aw-button>\n\n            <aw-button name=\"cancel\" [style]=\"'secondary'\" (action)=\"cancel()\">\n                {{cancelActionLabel}}\n            </aw-button>\n\n        </aw-dialog-footer>\n    </ng-template>\n\n</aw-dialog>\n",
                        styles: [".confirmation-footer-separator{border-top:1px solid #d7d7d7;height:14px}"]
                    },] },
        ];
        /** @nocollapse */
        ConfirmationComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        ConfirmationComponent.propDecorators = {
            title: [{ type: core.Input }],
            body: [{ type: core.Input }],
            confirmActionLabel: [{ type: core.Input }],
            cancelActionLabel: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            closable: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            onConfirm: [{ type: core.Output }],
            onCancel: [{ type: core.Output }],
            header: [{ type: core.ContentChild, args: [ConfirmationHeaderComponent,] }],
            footer: [{ type: core.ContentChild, args: [ConfirmationFooterComponent,] }]
        };
        return ConfirmationComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWConfirmationModule = (function () {
        function AWConfirmationModule() {
        }
        AWConfirmationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            AWDialogModule,
                            AWButtonModule
                        ],
                        entryComponents: [
                            ModalComponent,
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        exports: [
                            ConfirmationComponent,
                            ConfirmationHeaderComponent,
                            ConfirmationFooterComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWConfirmationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * Container panel providing scrolling functionality for its children. You can configure this
     * container to let it to scroll its content either horizontally, vertically or let the content
     * wrap.
     *
     *
     * Usage is pretty simple:
     *
     *  ### Example using horizontal scroll (default behavior):
     *
     *  ```
     *            <aw-scrollable>
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *
     *  ```
     *
     *  ### Example using vertical scroll:
     *
     *  ```
     *            <aw-scrollable [direction]="'vertical'" [height]="'40vh'">
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *
     * ```
     *
     *  ### Example scrolling is disabled and content wraps and centers:
     *
     *  ```
     *            <aw-scrollable [direction]="'none'" [alignment]="'center'">
     *                  <w-demo-card> Card 1</w-demo-card>
     *                  <w-demo-card> Card 2</w-demo-card>
     *                  <w-demo-card> Card 3</w-demo-card>
     *                  <w-demo-card> Card 4</w-demo-card>
     *                  <w-demo-card> Card 5</w-demo-card>
     *                  <w-demo-card> Card 6</w-demo-card>
     *                  <w-demo-card> Card 7</w-demo-card>
     *                  <w-demo-card> Card 8</w-demo-card>
     *                  <w-demo-card> Card 9</w-demo-card>
     *              </aw-scrollable>
     *  ```
     *
     * ### Height property:
     *
     * When using "horizontal scrolling" it set "flexbox-direction" to "row" where height
     * is set automatically based on its content. The height should be always 100% when using
     * this in parent container.
     *
     * If "vertical scrolling" is used you need to make sure that:
     *   - your parent container sets the boundaries with correctly set width and height
     *   otherwise it will use 100% of the viewport
     *   - if used as standalone you need to limit the height otherwise it will expand to 100% of
     *   the document
     *
     *
     *
     *
     */
    var ScrollableContainerComponent = (function (_super) {
        __extends(ScrollableContainerComponent, _super);
        function ScrollableContainerComponent(env, elementRef) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            _this.elementRef = elementRef;
            /**
             * Defines scrolling direction of the container meaning tells which overflow axies will be
             * disabled or enabled.
             *
             * Default value is "horizontal": Here we lock overflow-y and overflow-x set to auto.
             *
             * When scrolling direction is "vertical" please make sure you maintain correct height and
             * width.
             *
             */
            _this.direction = 'horizontal';
            /**
             * Defines how flexbox container items should be aligned. Default behavior is LEFT
             *
             */
            _this.alignment = 'left';
            _this.height = '100%';
            _this.width = '100%';
            return _this;
        }
        /**
         * @return {?}
         */
        ScrollableContainerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.initDefault();
            };
        /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         */
        /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         * @param {?} changes
         * @return {?}
         */
        ScrollableContainerComponent.prototype.ngOnChanges = /**
         * Make sure we re-initialize default when Input Bindings changes
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.initDefault();
            };
        /**
         * Initialize default values and Calculates layout and alignment class. The reason for using
         * these utility classes is that we can change the behavior anytime as compared to using
         * directly [style.xxx] bindings.
         *
         * ### Direction flow class:
         *  - u-scrollable-f<direction>
         *
         * ### Alignment class:
         *  - u-scrollable-a<alignment>
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.initDefault = /**
         * Initialize default values and Calculates layout and alignment class. The reason for using
         * these utility classes is that we can change the behavior anytime as compared to using
         * directly [style.xxx] bindings.
         *
         * ### Direction flow class:
         *  - u-scrollable-f<direction>
         *
         * ### Alignment class:
         *  - u-scrollable-a<alignment>
         *
         * @return {?}
         */
            function () {
                this.layoutClass = 'u-scrollable-fh';
                if (this.direction === 'vertical') {
                    this.layoutClass = 'u-scrollable-fv';
                }
                if (this.direction === 'vertical-row') {
                    this.layoutClass = 'u-scrollable-fv-row';
                }
                else if (this.direction === 'both') {
                    this.layoutClass = 'u-scrollable-fb';
                }
                else if (this.direction === 'none') {
                    this.layoutClass = 'u-scrollable-fn';
                }
                this.layoutClass += ' u-scrollable-a' + this.alignment.substring(0, 1);
                if (core$1.isPresent(this.styleClass)) {
                    this.layoutClass += " " + this.styleClass;
                }
                // make sure we default width and height to some value in case somebody passes null
                if (core$1.isBlank(this.width)) {
                    this.width = '100%';
                }
                if (core$1.isBlank(this.height)) {
                    this.height = '100%';
                }
            };
        /**
         * Tells if the horizontal scrollbar is visible
         *
         */
        /**
         * Tells if the horizontal scrollbar is visible
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.hasHorizontalScroll = /**
         * Tells if the horizontal scrollbar is visible
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
                return scrollContainer.scrollWidth > scrollContainer.clientWidth;
            };
        /**
         * Tells if the vertical scrollbar is visible
         *
         */
        /**
         * Tells if the vertical scrollbar is visible
         *
         * @return {?}
         */
        ScrollableContainerComponent.prototype.hasVerticalScroll = /**
         * Tells if the vertical scrollbar is visible
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ scrollContainer = this.elementRef.nativeElement.querySelector('.w-scrollable');
                return scrollContainer.scrollHeight > scrollContainer.clientHeight;
            };
        ScrollableContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-scrollable',
                        template: "<div class=\"w-scrollable\" [ngClass]=\"layoutClass\" [style.width]=\"width\"\n     [style.height]=\"height\">\n    <ng-content></ng-content>\n</div>\n",
                        styles: [".w-scrollable{display:flex;display:-webkit-flex;backface-visibility:hidden;-webkit-backface-visibility:hidden;will-change:overflow}.w-scrollable /deep/>*{flex:0 0 auto;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;margin:10px}.u-scrollable-fh{flex-flow:row nowrap;overflow-x:auto;overflow-y:hidden}.u-scrollable-fv{flex-flow:column nowrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fb{flex-flow:row nowrap;overflow-x:auto;overflow-y:auto}.u-scrollable-fv-row{flex-flow:row wrap;overflow-x:hidden;overflow-y:auto}.u-scrollable-fn{flex-flow:row wrap}.u-scrollable-al{justify-content:flex-start;-webkit-justify-content:flex-start}.u-scrollable-ar{justify-content:flex-end;-webkit-justify-content:flex-end}.u-scrollable-ac{justify-content:center;-webkit-justify-content:center}.u-scrollable-aj,.u-scrollable-aj-around{justify-content:space-between;-webkit-justify-content:space-between}"]
                    },] },
        ];
        /** @nocollapse */
        ScrollableContainerComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: core.ElementRef }
            ];
        };
        ScrollableContainerComponent.propDecorators = {
            direction: [{ type: core.Input }],
            alignment: [{ type: core.Input }]
        };
        return ScrollableContainerComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWScrollableContainerModule = (function () {
        function AWScrollableContainerModule() {
        }
        AWScrollableContainerModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ScrollableContainerComponent
                        ],
                        imports: [
                            common.CommonModule
                        ],
                        entryComponents: [
                            ScrollableContainerComponent
                        ],
                        exports: [
                            ScrollableContainerComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWScrollableContainerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ LB_CONTROL_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ListComponent; }),
        multi: true
    };
    /**
     *
     * The List component represent a structure which contains a list of selectable items. Items
     * selection can be configured in single-selection, multi-selection or multi-selection with visible
     * checkboxes mode.
     * In addition it can display data inside 3 zones LEFT, MIDDLE and RIGHT in order to provide
     * easy way for application developer to layout its own custom content or even change out of box
     * behavior.
     *
     *
     *  ### Examples
     *
     *  1. Render simple single selection list
     *
     *  ```html
     *
     *      <aw-list [list]="list"></aw-list>
     *
     *  ```
     *  2. Render list - multi selection with custom RIGHT content to show a CheckMark when item
     *  is selected
     *
     *  ```html
     *
     *   <aw-list #awlist [list]="list"
     *                       height="150px"
     *                       width="250px"
     *                       [selectionMode]="'multi'">
     *
     *                  <ng-template #right let-item>
     *
     *                      <span class="sap-icon"
     *                            [ngClass]="{'icon-accept': awlist.pListBox.isSelected(item),
     *                            '': !awlist.pListBox.isSelected(item)}">
     *
     *                      </span>
     *                  </ng-template>
     *   </aw-list>
     *
     *  ```
     *
     * 3. Render list - multi selection with visible checkboxes and custom MIDDLE content to change
     *  the way item name is rendered
     *
     *
     *
     *  ```html
     *
     *   <aw-list [list]="list" height="180px"
     *                       width="200px"
     *                       [selection]="selection"
     *                       [selectionMode]="'multiWithCheckbox'">
     *
     *                  <ng-template #middle let-item>
     *                      XX-{{item.value}}
     *                  </ng-template>
     *    </aw-list>
     *
     *  ```
     *
     *
     *
     */
    var ListComponent = (function (_super) {
        __extends(ListComponent, _super);
        function ListComponent(env, parentContainer) {
            var _this = _super.call(this, env, parentContainer) || this;
            _this.env = env;
            _this.parentContainer = parentContainer;
            /**
             * Component recognizes 3 modes: single, multi, multi with visible checkboxes
             */
            _this.selectionMode = 'single';
            /**
             * Don't render Listbox border. Used for embedding this inside other components
             *
             */
            _this.borderless = false;
            /**
             * Triggered when we double click on the list Item
             *
             */
            _this.action = new core.EventEmitter();
            /**
             * Event fired when user select a item
             *
             */
            _this.onSelection = new core.EventEmitter();
            _this.listStyle = {};
            _this.isMultiple = false;
            _this.showCheckbox = false;
            return _this;
        }
        /**
         * @return {?}
         */
        ListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                this.isMultiple = this.selectionMode === 'multi' ||
                    this.selectionMode === 'multiWithCheckbox';
                this.showCheckbox = this.selectionMode === 'multiWithCheckbox';
                // cannot have both either we use field to get display value or valueTransformer
                if (core$1.isPresent(this.field) && core$1.isPresent(this.valueTransformer)) {
                    throw new Error('You can have either [field] or [valueTransformer].');
                }
                if (core$1.isPresent(this.list)) {
                    this.initList();
                }
                else {
                    throw new Error('Missing [list] binding.');
                }
                // Also add overflowY to make sure it can scroll and does not expand based on its content
                if (core$1.isPresent(this.height)) {
                    this.listStyle['height'] = this.height;
                    this.listStyle['overflow-y'] = 'auto';
                }
                if (core$1.isPresent(this.width)) {
                    this.listStyle['width'] = this.width;
                }
                if (this.borderless) {
                    this.listStyle['border-color'] = 'transparent';
                }
                if (this.isStandalone) {
                    _super.prototype.registerFormControl.call(this, this.selection);
                    if (core$1.isBlank(this.selection)) {
                        this.selection = this.formControl.value;
                    }
                }
            };
        /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         */
        /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         * @param {?} event
         * @param {?} item
         * @param {?} checkbox
         * @return {?}
         */
        ListComponent.prototype.itemClicked = /**
         *
         * Since we are using <aw-checkbox> we need to have custom handling both when clicking on the
         * checkbox as well as item text.
         *
         *
         * @param {?} event
         * @param {?} item
         * @param {?} checkbox
         * @return {?}
         */
            function (event, item, checkbox) {
                if (core$1.isPresent(checkbox)) {
                    this.pListBox.onCheckboxClick(event, item);
                }
                else if (core$1.isPresent(this.pListBox)) {
                    this.pListBox.onOptionClick(event, item);
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * Internal
         *
         */
        /**
         * Internal
         *
         * @return {?}
         */
        ListComponent.prototype.hasRightTempl = /**
         * Internal
         *
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.rZoneTempl);
            };
        /**
         * @return {?}
         */
        ListComponent.prototype.hasLeftTempl = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.lZoneTempl);
            };
        /**
         * @return {?}
         */
        ListComponent.prototype.hasMiddleTempl = /**
         * @return {?}
         */
            function () {
                return core$1.isPresent(this.mZoneTempl);
            };
        /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         */
        /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         * @param {?} event
         * @return {?}
         */
        ListComponent.prototype.onItemSelected = /**
         *
         * Triggered by p-listbox component when item is selected. When state is managed internally
         * we also update FormControl model.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isBlank(event.value)) {
                    return;
                }
                this.onSelection.emit(event.value);
                if (this.isStandalone) {
                    this.formControl.setValue(event.value, { emitEvent: true });
                }
                this.onModelChanged(event.value);
            };
        /**
         * Internal. Please see ControlValueAccessor
         *
         */
        /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
        ListComponent.prototype.writeValue = /**
         * Internal. Please see ControlValueAccessor
         *
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!core$1.equals(value, this.selection)) {
                    this.selection = value;
                    if (this.isStandalone) {
                        this.formControl.setValue(value);
                    }
                }
            };
        /**
         * Translates external form of the list into PrimeNG expected format where it uses
         * SelectionItem interface
         * @return {?}
         */
        ListComponent.prototype.initList = /**
         * Translates external form of the list into PrimeNG expected format where it uses
         * SelectionItem interface
         * @return {?}
         */
            function () {
                var _this = this;
                if (core$1.isPresent(this.list)) {
                    this.internalList = this.list.map(function (item) {
                        return { label: _this.displayValue(item), value: item };
                    });
                }
            };
        /**
         *  Generates label value for the list box.
         *
         * @param {?} item
         * @return {?}
         */
        ListComponent.prototype.displayValue = /**
         *  Generates label value for the list box.
         *
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (core$1.isBlank(item)) {
                    return '';
                }
                var /** @type {?} */ val = item.toString();
                if (core$1.isPresent(this.field)) {
                    val = item[this.field];
                }
                else if (core$1.isPresent(this.valueTransformer)) {
                    val = this.valueTransformer(item);
                }
                return val;
            };
        ListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-list',
                        template: "<p-listbox #listbox [options]=\"internalList\" [multiple]=\"isMultiple\" [checkbox]=\"showCheckbox\"\n           [(ngModel)]=\"selection\" [disabled]=\"disabled\" [style]=\"listStyle\" [showToggleAll]=\"false\"\n           (onChange)=\"onItemSelected($event)\" (onDblClick)=\"action.emit($event.value)\"\n           [styleClass]=\"styleClass\">\n\n\n    <ng-template let-item pTemplate=\"item\">\n        <div class=\"w-li-wrapper\">\n            <div class=\"w-li-left\">\n                <ng-template *ngIf=\"hasLeftTempl(); else defaultLeft\"\n                             [ngTemplateOutlet]=\"lZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n\n                <ng-template #defaultLeft>\n                    <aw-checkbox #check *ngIf=\"isMultiple && showCheckbox\"\n                                 [isStandalone]=\"false\"\n                                 [value]=\"listbox.isSelected(item)\"\n                                 type=\"action\"\n                                 (action)=\"itemClicked($event, item, check)\">\n                    </aw-checkbox>\n                </ng-template>\n            </div>\n\n            <div class=\"w-li-middle\" (click)=\"itemClicked($event, item, null)\">\n\n                <ng-template *ngIf=\"hasMiddleTempl(); else defaultMiddle\"\n                             [ngTemplateOutlet]=\"mZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\"></ng-template>\n\n                <ng-template #defaultMiddle>\n                    {{item.label}}\n                </ng-template>\n\n            </div>\n\n            <div class=\"w-li-right\" *ngIf=\"hasRightTempl()\">\n                <ng-template [ngTemplateOutlet]=\"rZoneTempl\"\n                             [ngTemplateOutletContext]=\"{$implicit: item}\">\n                </ng-template>\n\n            </div>\n        </div>\n    </ng-template>\n</p-listbox>\n",
                        styles: ["::ng-deep .ui-listbox-item>.ui-chkbox{display:none}::ng-deep .ui-listbox-item .ui-chkbox{margin-right:1em}.w-li-wrapper{display:flex;align-items:flex-start}.w-li-wrapper .w-li-left,.w-li-wrapper .w-li-right{flex:0 1 auto}.w-li-wrapper .w-li-middle{flex:1 1 auto}"],
                        providers: [
                            LB_CONTROL_VALUE_ACCESSOR,
                            { provide: BaseFormComponent, useExisting: core.forwardRef(function () { return ListComponent; }) }
                        ]
                    },] },
        ];
        /** @nocollapse */
        ListComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment },
                { type: BaseFormComponent, decorators: [{ type: core.SkipSelf }, { type: core.Optional }, { type: core.Inject, args: [core.forwardRef(function () { return BaseFormComponent; }),] }] }
            ];
        };
        ListComponent.propDecorators = {
            list: [{ type: core.Input }],
            selection: [{ type: core.Input }],
            selectionMode: [{ type: core.Input }],
            valueTransformer: [{ type: core.Input }],
            field: [{ type: core.Input }],
            borderless: [{ type: core.Input }],
            action: [{ type: core.Output }],
            onSelection: [{ type: core.Output }],
            pListBox: [{ type: core.ViewChild, args: ['listbox',] }],
            lZoneTempl: [{ type: core.ContentChild, args: ['left',] }],
            mZoneTempl: [{ type: core.ContentChild, args: ['middle',] }],
            rZoneTempl: [{ type: core.ContentChild, args: ['right',] }]
        };
        return ListComponent;
    }(BaseFormComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWListModule = (function () {
        function AWListModule() {
        }
        AWListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            primeng.ListboxModule,
                            AWCheckBoxModule
                        ],
                        entryComponents: [
                            ListComponent
                        ],
                        exports: [
                            ListComponent,
                            forms.ReactiveFormsModule,
                            forms.FormsModule
                        ],
                        providers: []
                    },] },
        ];
        return AWListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Overlay Component is a simple version of the dialog where there's only content.
     * Overlay will appear at the position where the action performed trigger an overlay.
     *
     * There are three types of popup.
     *   1.  a regular dialog box that has header, body and footer. It's the most customizable.
     *   2.  a confirmation box is similar to a dialog box but has accept and reject action buttons.
     *   3.  a overlay, which is a very basic popup with what you put inside.
     *       It doesn't have header and footer.
     *
     * There are two ways to use any popup component.
     *   1.  Either directly by using component, aw-dialog, aw-confirmation or aw-overlay
     *   2.  or the ModalService  service.open(<OverlayComponent>), service.close()
     *
     * Usage:
     *    1.  Using ModalService directly to display a modal popup. The usage is a little tricky
     *        because angular currently doesn't support dynamic content projection.
     *
     *          let overlay = this.modalService.open<OverlayComponent>(OverlayComponent, {});
     *
     *            // Add content. There's not support for dynamic content projection yet.
     *            // So have add content directly.
     *            // This is probably not the best way.
     *          overlay.instance.overlay.el.nativeElement.querySelector(".ui-overlaypanel-content")
     *               .innerHTML = `<img style='width:300px;' src="sales.png" alt="Sales Chart" />`;
     *
     *          // delay the opening after ng lifecycle has been initialized.
     *          setTimeout(() => { overlay.instance.open(event); }, 1);
     *
     *
     *   2.   Use the component inside your template.
     *
     * \@Component({
     *                selector: 'aw-page' ,
     *                           template: `
     *                                <aw-overlay #overlay (onOpen)="overlayAction='open'"
     *                                                     (onClose)="overlayAction='close'">
     *                                      <img src="sales.png" alt="Chart"/>
     *                                </aw-overlay>
     *
     *                                <aw-button [size]="'small'" (click)="overlay.open($event)">
     *                                    Open Overlay
     *                                </aw-button>
     *                  `
     *         export class MyPageComponent implements OnInit {
     *
     *                     overlayAction: string;
     *
     *                     constructor(private modalService: ModalService) {
     *                          super();
     *                       }
     *                     ngOnInit() { }
     *       }
     *
     *
     */
    var OverlayComponent = (function (_super) {
        __extends(OverlayComponent, _super);
        function OverlayComponent(env) {
            var _this = _super.call(this, env) || this;
            _this.env = env;
            /**
             * Enables hide overlay when outside is clicked.
             */
            _this.dismissable = true;
            /**
             * displays the close icon 'x' at top of right corner.
             */
            _this.showCloseIcon = false;
            /**
             * Event fired when overlay is closed.
             */
            _this.onClose = new core.EventEmitter();
            /**
             * Event fired when the overlay is opened.
             */
            _this.onOpen = new core.EventEmitter();
            return _this;
        }
        /**
         * @return {?}
         */
        OverlayComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
            };
        /**
         * Open Overlay
         * @param event
         */
        /**
         * Open Overlay
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.open = /**
         * Open Overlay
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.overlay.show(event);
                this.onOpened(null);
            };
        /**
         * Close Overlay
         */
        /**
         * Close Overlay
         * @return {?}
         */
        OverlayComponent.prototype.close = /**
         * Close Overlay
         * @return {?}
         */
            function () {
                this.overlay.hide();
            };
        /**
         * toggle open and close.
         * @param event
         */
        /**
         * toggle open and close.
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.toggle = /**
         * toggle open and close.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.overlay.toggle(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.onOpened = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onOpen.emit(event);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        OverlayComponent.prototype.onClosed = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.onClose.emit(event);
            };
        OverlayComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-overlay',
                        template: "<p-overlayPanel [dismissable]=\"dismissable\" [showCloseIcon]=\"showCloseIcon\"\n                [styleClass]=\"styleClass\" [appendTo]=\"appendTo\"\n                (onAfterHide)=\"onClosed($event)\">\n    <ng-content></ng-content>\n</p-overlayPanel>\n",
                        styles: ["::ng-deep .ui-overlaypanel{border:1px solid #d7d7d7;box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .ui-overlaypanel-content{padding:2em 3.4em .6em 1.43em}::ng-deep .ui-overlaypanel-close{border-radius:0;top:.5em;right:.5em}::ng-deep .ui-overlaypanel-close.ui-state-default{border:none}"]
                    },] },
        ];
        /** @nocollapse */
        OverlayComponent.ctorParameters = function () {
            return [
                { type: core$1.Environment }
            ];
        };
        OverlayComponent.propDecorators = {
            dismissable: [{ type: core.Input }],
            showCloseIcon: [{ type: core.Input }],
            appendTo: [{ type: core.Input }],
            onClose: [{ type: core.Output }],
            onOpen: [{ type: core.Output }],
            overlay: [{ type: core.ViewChild, args: [primeng.OverlayPanel,] }]
        };
        return OverlayComponent;
    }(ModalContainer));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /** @enum {number} */
    var HCCardPosition = {
        top: 0,
        bottom: 1,
        none: 2,
    };
    HCCardPosition[HCCardPosition.top] = "top";
    HCCardPosition[HCCardPosition.bottom] = "bottom";
    HCCardPosition[HCCardPosition.none] = "none";
    /** @enum {number} */
    var HCCardAlignment = {
        left: 0,
        paddedLeft: 1,
        right: 2,
        paddedRight: 3,
        default: 4,
    };
    HCCardAlignment[HCCardAlignment.left] = "left";
    HCCardAlignment[HCCardAlignment.paddedLeft] = "paddedLeft";
    HCCardAlignment[HCCardAlignment.right] = "right";
    HCCardAlignment[HCCardAlignment.paddedRight] = "paddedRight";
    HCCardAlignment[HCCardAlignment.default] = "default";
    /**
     * Maps position to styles that are applied to the Card container. This is just to make it easier
     * as we are working with enumerations and have already enum type.
     *
     * u-hc-arrow-b: Arrow will appear at the bottom
     * u-hc-arrow-t: Arrow will appear at the top
     *
     * u-hc-shadow-t: Border shadow will appear at the top
     * u-hc-shadow-b: Border shadow will appear at the bottom
     */
    var /** @type {?} */ PositionToStyle = {
        top: ' w-hc-panel-arrow u-hc-arrow-b u-hc-shadow-t',
        bottom: ' w-hc-panel-arrow u-hc-arrow-t u-hc-shadow-b',
        none: ''
    };
    /**
     *
     * Maps aligned Card container to custom styles in order to apply correct arrow
     *
     * -ll: Stands for Large Left (large: there is plenty of space around )
     * -lr: Stands for Large right
     * -sl: Stands for Small left (Small and resized screen where we try to fit card container
     * somewhere in between)
     * -sr: Stands for Large right
     *
     */
    var /** @type {?} */ AlignmentToStyle = {
        left: ' u-hc-arrow-ll',
        right: ' u-hc-arrow-lr',
        paddedLeft: ' u-hc-arrow-sl',
        paddedRight: ' u-hc-arrow-sr',
        default: ' u-hc-arrow-ll',
    };
    /**
     * The HoverCard components adds hover behavior to text, the specified content is loaded
     * on the left or right side of the element.
     *
     * Todo: extends so we can wrap any element and any element can be triggering this. Not only
     * linkTitle
     *
     *
     * ### Example:
     *
     * ```
     *
     *   <aw-hover-card [linkTitle]="'Frank kolar'">
     *       <h3>My Card Title</h3>
     *       <div>
     *
     *           This is my contents
     *
     *       </div>
     *
     *
     *    </aw-hover-card>
     * ```
     *
     * By default there is [forceClose]=true which forces the user to use X close icon
     *
     *
     *
     */
    var HoverCardComponent = (function (_super) {
        __extends(HoverCardComponent, _super);
        function HoverCardComponent(elem, env, cd) {
            var _this = _super.call(this, env) || this;
            _this.elem = elem;
            _this.env = env;
            _this.cd = cd;
            /**
             * Should we keep the hover card open and force user to manually close
             *
             */
            _this.forceClose = true;
            /**
             *
             * This current workaround until we find better solution. PrimeNG overlays operates within
             * its relative element so if the overlay is wrapped inside some other relative container
             * the overlay content is croped by its parent and content is not visible.
             *
             * They have [appendTo] binding which we need to use for this purpose
             *
             */
            _this.appendContentToBody = true;
            /**
             *
             * Internal style class to use to apply additional styles when it needs to show a Arrow on the
             * card
             *
             */
            _this.arrowClass = '';
            _this.opening = false;
            _this.currrentPosition = HCCardPosition.none;
            return _this;
        }
        /**
         * @return {?}
         */
        HoverCardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                _super.prototype.ngOnInit.call(this);
                core$1.assert(core$1.isPresent(this.linkTitle), 'You must provide [linkTitle] binding !');
                // make sure there is open HC when we start new component
                this.env.deleteValue('hc-open');
                if (!this.appendContentToBody) {
                    this.appendTo = null;
                }
            };
        /**
         * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
         * during this phase.
         *
         * So now its broken down into two parts:
         *   - Apply class styles
         *   - Position it.
         */
        /**
         * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
         * during this phase.
         *
         * So now its broken down into two parts:
         *   - Apply class styles
         *   - Position it.
         * @return {?}
         */
        HoverCardComponent.prototype.ngAfterViewChecked = /**
         * As of Angular 5 we have to introduce this ViewChecked as PrimeNG does final calculation
         * during this phase.
         *
         * So now its broken down into two parts:
         *   - Apply class styles
         *   - Position it.
         * @return {?}
         */
            function () {
                if (this.opening) {
                    var /** @type {?} */ container = this.awOverlay.overlay.container;
                    var /** @type {?} */ cntRect = container.getBoundingClientRect();
                    if (this.currrentPosition !== HCCardPosition.none) {
                        this.adjustCard(container, cntRect, this.awOverlay.overlay);
                    }
                    else {
                        this.arrowClass = '';
                    }
                    this.opening = false;
                }
            };
        /**
         * Init elements BoundingClientRect that we use for calculation
         *
         */
        /**
         * Init elements BoundingClientRect that we use for calculation
         *
         * @return {?}
         */
        HoverCardComponent.prototype.initElements = /**
         * Init elements BoundingClientRect that we use for calculation
         *
         * @return {?}
         */
            function () {
                var /** @type {?} */ titleElem = this.elem.nativeElement.querySelector('.w-hc-title');
                var /** @type {?} */ triggerElem = this.elem.nativeElement.querySelector('.sap-icon');
                this.titleAreaRect = titleElem.getBoundingClientRect();
                this.trigRect = triggerElem.getBoundingClientRect();
                this.trigIconMiddle = this.trigRect.width / 2;
            };
        /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         */
        /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.openCard = /**
         *
         * Fires when user mouse over the triggering icon and opens up overlay component. To make sure
         * only one Card is opened at the time it uses Environment to save extra information for it
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (core$1.isPresent(this.awOverlay) && !this.env.hasValue('hc-open')) {
                    this.awOverlay.open(event);
                    this.env.setValue('hc-open', true);
                }
            };
        /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         */
        /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.cardOpened = /**
         *
         * Fired at the end of the opening cycle when all is initialized and the card is about to
         * fade in.
         *
         * This method first simulates displaying card by setting display:block and
         * domHandler.absolutePosition so we can read dimensions and then later on position the card
         * accordingly.
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ container = this.awOverlay.overlay.container;
                var /** @type {?} */ target = this.awOverlay.overlay.target;
                this.openForAdjustments(container);
                // pre-run positioning so we can calculate new coordinates
                this.awOverlay.overlay.domHandler.absolutePosition(container, target);
                var /** @type {?} */ cntRect = container.getBoundingClientRect();
                this.currrentPosition = this.positionForCard(container, cntRect);
                this.applyStyleClass(container, cntRect, this.awOverlay.overlay);
                this.closeForAdjustments(container);
                this.opening = true;
            };
        /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         */
        /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         * @param {?} event
         * @return {?}
         */
        HoverCardComponent.prototype.cardClosed = /**
         *
         * When card is closed we need to release it and delete all the references from Environment
         *
         *
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.env.deleteValue('hc-open');
            };
        /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         */
        /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.adjustCard = /**
         *
         * Applies style.TOP and style.LEFT to the container in order to reposition it and add
         * extra arrow.
         *
         * First based on the initial position we apply style.TOP and depending if its on the
         * top or bottom we apply either -HoverCardComponent.ArrowPad or +HoverCardComponent.ArrowPad.
         *
         * Then for positioning horizontally we use two types.
         *  - When there is allot of space the arrow is 25% from the edge
         *
         *    -----^------------   or       -----------^----
         *
         *
         *  - When there is less or none space we have only 10% far away form the edge
         *
         *    --^------------   or       -----------^--
         *
         *  Once we pick the correct positioning (25%, 10%) we need to recalculate and shift the card
         *  either to the left or right.
         *
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (container, containerRect, modalContainer) {
                var /** @type {?} */ diff = (this.currrentPosition === HCCardPosition.bottom) ? 1 : -1;
                var /** @type {?} */ scrollTop = modalContainer.domHandler.getWindowScrollTop();
                var /** @type {?} */ posWithScroll = containerRect.top + scrollTop;
                container.style.top = (posWithScroll + (HoverCardComponent.ArrowPad * diff)) + 'px';
                var /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
                container.style.left = this.calcLeftForAlignment(containerRect, alignment) + 'px';
            };
        /**
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.applyStyleClass = /**
         * @param {?} container
         * @param {?} containerRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (container, containerRect, modalContainer) {
                if (this.currrentPosition !== HCCardPosition.none) {
                    var /** @type {?} */ alignment = this.alignmentForCard(containerRect, modalContainer);
                    this.arrowClass = ((PositionToStyle))[((HCCardPosition))[this.currrentPosition]];
                    this.arrowClass += ((AlignmentToStyle))[((HCCardAlignment))[alignment]];
                }
                else {
                    this.arrowClass = '';
                }
            };
        /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         */
        /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         * @param {?} container
         * @param {?} boundingRect
         * @return {?}
         */
        HoverCardComponent.prototype.positionForCard = /**
         *
         * Detects if the card is going to be shown on the top of the Link label or under. Or if
         * its covering it.
         *
         * @param {?} container
         * @param {?} boundingRect
         * @return {?}
         */
            function (container, boundingRect) {
                // secure this in case of IE returning undefined
                var /** @type {?} */ borderWidth = getComputedStyle(container).borderWidth;
                var /** @type {?} */ cntWidth = parseFloat(borderWidth || '0');
                var /** @type {?} */ pos = HCCardPosition.none;
                if (this.trigRect.bottom < boundingRect.top) {
                    pos = HCCardPosition.bottom;
                }
                else if (this.trigRect.top > (boundingRect.bottom - cntWidth)) {
                    pos = HCCardPosition.top;
                }
                return pos;
            };
        /**
         *
         * Detect horizontal alignment.
         *
         * @param {?} boundingRect
         * @param {?} modalContainer
         * @return {?}
         */
        HoverCardComponent.prototype.alignmentForCard = /**
         *
         * Detect horizontal alignment.
         *
         * @param {?} boundingRect
         * @param {?} modalContainer
         * @return {?}
         */
            function (boundingRect, modalContainer) {
                var /** @type {?} */ alignment = HCCardAlignment.left;
                var /** @type {?} */ viewPort = modalContainer.domHandler.getViewport();
                if (this.trigRect.left.toFixed(0) === boundingRect.left.toFixed(0) &&
                    boundingRect.left > HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.left;
                }
                else if (boundingRect.left < HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.paddedLeft;
                }
                else if ((viewPort.width - boundingRect.right) < HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.paddedRight;
                }
                else if (this.trigRect.right.toFixed(0) === boundingRect.right.toFixed(0) ||
                    (viewPort.width - boundingRect.right) > HoverCardComponent.SpacingLimit) {
                    alignment = HCCardAlignment.right;
                }
                else {
                    alignment = HCCardAlignment.default;
                }
                return alignment;
            };
        /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         */
        /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         * @param {?} container
         * @return {?}
         */
        HoverCardComponent.prototype.openForAdjustments = /**
         *
         * Turn on temporary display to BLOCK so we can read dimensions
         *
         * @param {?} container
         * @return {?}
         */
            function (container) {
                container.style.visibility = 'hidden';
                container.style.display = 'block';
                this.initElements();
            };
        /**
         *
         * Turn off display back NONE
         *
         */
        /**
         *
         * Turn off display back NONE
         *
         * @param {?} container
         * @return {?}
         */
        HoverCardComponent.prototype.closeForAdjustments = /**
         *
         * Turn off display back NONE
         *
         * @param {?} container
         * @return {?}
         */
            function (container) {
                container.style.visibility = 'visible';
                // container.style.display = 'none';
            };
        /**
         *
         * Calculates positioning for style.LEFT. As already said they are two types of triangles that
         * are applies for these case:
         *
         *
         * a) Large left, Large right
         *
         *  PrimeNG aligns the card with either the right side or left side of the triggering icon
         *
         *
         *  V                                                                V
         *  ......^........................ or  .......................^......
         *
         *
         *
         *
         *  b) Small left , small right
         *
         *  This is for cases where there is not enough space and PrimeNG position the card off to the
         *  triggering icons, so even primeNg does not have space to align it with the V
         *
         *
         *     V                                                      V
         *  ....^........................ or  .......................^....
         *
         *
         * c)Aligned with the edge of browser
         *
         * On the right side this is problem as we cannot calculate full future width of the card.
         * but we applly for this case #b (arrow 10% )
         *
         *
         *
         * @param {?} boundingRect
         * @param {?} alignment
         * @return {?}
         */
        HoverCardComponent.prototype.calcLeftForAlignment = /**
         *
         * Calculates positioning for style.LEFT. As already said they are two types of triangles that
         * are applies for these case:
         *
         *
         * a) Large left, Large right
         *
         *  PrimeNG aligns the card with either the right side or left side of the triggering icon
         *
         *
         *  V                                                                V
         *  ......^........................ or  .......................^......
         *
         *
         *
         *
         *  b) Small left , small right
         *
         *  This is for cases where there is not enough space and PrimeNG position the card off to the
         *  triggering icons, so even primeNg does not have space to align it with the V
         *
         *
         *     V                                                      V
         *  ....^........................ or  .......................^....
         *
         *
         * c)Aligned with the edge of browser
         *
         * On the right side this is problem as we cannot calculate full future width of the card.
         * but we applly for this case #b (arrow 10% )
         *
         *
         *
         * @param {?} boundingRect
         * @param {?} alignment
         * @return {?}
         */
            function (boundingRect, alignment) {
                // width for which we need to shift card. 25% or 10% of the container width
                var /** @type {?} */ wLargeTriangle = boundingRect.width * 0.25;
                var /** @type {?} */ wSmallTriangle = boundingRect.width * 0.10;
                switch (alignment) {
                    case HCCardAlignment.right:
                        var /** @type {?} */ shiftRight = boundingRect.left + wLargeTriangle;
                        var /** @type {?} */ trigRight = this.trigRect.right - this.trigIconMiddle;
                        return shiftRight - (boundingRect.right - trigRight);
                    case HCCardAlignment.paddedRight:
                        var /** @type {?} */ shiftRightS = boundingRect.left + wSmallTriangle;
                        var /** @type {?} */ trigRightS = this.trigRect.right - this.trigIconMiddle;
                        return shiftRightS - (boundingRect.right - trigRightS);
                    case HCCardAlignment.paddedLeft:
                        var /** @type {?} */ shiftLeftPad = boundingRect.left - wSmallTriangle;
                        return shiftLeftPad + this.trigIconMiddle;
                    case HCCardAlignment.left:
                    default:
                        var /** @type {?} */ shiftLeft = boundingRect.left - wLargeTriangle;
                        return shiftLeft + this.trigIconMiddle;
                }
            };
        /**
         * Default padding representing a height of the Arrow for which we need to vertically adjust
         * Card container
         *
         */
        HoverCardComponent.ArrowPad = 10;
        /**
         * Defines safe threshold where there might not be enough space around or Card is aligned with
         * the left or right edge of the viewport for which we need to position the Arrow closer to the
         * side of the card
         *
         */
        HoverCardComponent.SpacingLimit = 50;
        HoverCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'aw-hover-card',
                        template: "<span class=\"w-hc\">\n    <span class=\"w-hc-title\">\n        <aw-string [value]=\"linkTitle\"></aw-string>\n        <span class=\"sap-icon icon-slim-arrow-down\" (mouseover)=\"openCard($event)\"></span>\n    </span>\n\n    <div class=\"w-hc-body\">\n\n         <aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"\n                     [styleClass]=\"arrowClass\"\n                     [appendTo]=\"appendTo\"\n                     (onOpen)=\"cardOpened($event)\"\n                     (onClose)=\"cardClosed($event)\">\n\n        <!-- this is workaround to create a _ngcontent-INDEX reference so we can\n        refer to this ng-content. Angular does not have any way right now to track this\n        -->\n        <span class=\"u-ngcontent\">\n                <ng-content></ng-content>\n            </span>\n\n    </aw-overlay>\n\n    </div>\n</span>\n\n\n<!--<ng-template #contentToBody>-->\n    <!--<aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"-->\n                <!--[styleClass]=\"arrowClass\"-->\n                <!--[appendTo]=\"appendTo\"-->\n                <!--(onOpen)=\"cardOpened($event)\"-->\n                <!--(onClose)=\"cardClosed($event)\">-->\n\n        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->\n        <!--refer to this ng-content. Angular does not have any way right now to track this-->\n        <!--&ndash;&gt;-->\n        <!--<span class=\"u-ngcontent\">-->\n                <!--<ng-content></ng-content>-->\n            <!--</span>-->\n\n    <!--</aw-overlay>-->\n\n<!--</ng-template>-->\n\n\n<!--<ng-template #contentToOverlay>-->\n\n    <!--<aw-overlay #overlay [showCloseIcon]=\"forceClose\" [dismissable]=\"!forceClose\"-->\n                <!--[styleClass]=\"arrowClass\"-->\n                <!--(onOpen)=\"cardOpened($event)\"-->\n                <!--(onClose)=\"cardClosed($event)\">-->\n\n        <!--&lt;!&ndash; this is workaround to create a _ngcontent-INDEX reference so we can-->\n        <!--refer to this ng-content. Angular does not have any way right now to track this-->\n        <!--&ndash;&gt;-->\n        <!--<span class=\"u-ngcontent\">-->\n                <!--<ng-content></ng-content>-->\n            <!--</span>-->\n\n    <!--</aw-overlay>-->\n<!--</ng-template>-->\n\n\n",
                        styles: [".w-hc-title{padding-right:1.4em;position:relative;white-space:nowrap}.w-hc-title .sap-icon{font-size:1em;color:#00679e;position:absolute;padding-top:.2em;right:0}::ng-deep .w-hc-panel-arrow.u-hc-shadow-b{box-shadow:0 2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow.u-hc-shadow-t{box-shadow:0 -2px 4px 0 rgba(0,0,0,.2)}::ng-deep .w-hc-panel-arrow:after,::ng-deep .w-hc-panel-arrow:before{left:25%;border:solid transparent;content:\" \";height:0;width:0;position:absolute;pointer-events:none}::ng-deep .w-hc-panel-arrow:after{border-color:rgba(136,183,213,0);border-width:.7em;margin-left:-.7em}::ng-deep .w-hc-panel-arrow:before{border-color:rgba(255,136,56,0);border-width:.8em;margin-left:-.8em}::ng-deep .u-hc-arrow-ll:after,::ng-deep .u-hc-arrow-ll:before{left:25%}::ng-deep .u-hc-arrow-lr:after,::ng-deep .u-hc-arrow-lr:before{left:75%}::ng-deep .u-hc-arrow-sl:after,::ng-deep .u-hc-arrow-sl:before{left:10%}::ng-deep .u-hc-arrow-sr:after,::ng-deep .u-hc-arrow-sr:before{left:90%}::ng-deep .u-hc-arrow-t:after,::ng-deep .u-hc-arrow-t:before{bottom:100%}::ng-deep .u-hc-arrow-t:after{border-bottom-color:#fff}::ng-deep .u-hc-arrow-t:before{border-bottom-color:#d7d7d7}::ng-deep .u-hc-arrow-b:after,::ng-deep .u-hc-arrow-b:before{top:100%}::ng-deep .u-hc-arrow-b:after{border-top-color:#fff}::ng-deep .u-hc-arrow-b:before{border-top-color:#d7d7d7}"]
                    },] },
        ];
        /** @nocollapse */
        HoverCardComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core$1.Environment },
                { type: core.ChangeDetectorRef }
            ];
        };
        HoverCardComponent.propDecorators = {
            linkTitle: [{ type: core.Input }],
            forceClose: [{ type: core.Input }],
            appendContentToBody: [{ type: core.Input }],
            awOverlay: [{ type: core.ViewChild, args: ['overlay',] }]
        };
        return HoverCardComponent;
    }(BaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Spy lifecycle directive is used for debugging purposes to track lifecycle callback
     *
     * ###Usage
     *
     * ```
     *   <my-directive spyhooks><my-directive>
     *
     * ```
     */
    var SpyLifeCycleHooksDirective = (function () {
        function SpyLifeCycleHooksDirective(elementRef) {
            this.elementRef = elementRef;
        }
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.logIt('onInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.logIt('onDestroy');
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                this.logIt('ngOnChanges = ' + changes);
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                this.logIt('ngDoCheck');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterContentInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterContentChecked = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterContentChecked');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterViewInit');
            };
        /**
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ngAfterViewChecked = /**
         * @return {?}
         */
            function () {
                this.logIt('ngAfterViewChecked');
            };
        /**
         * @param {?} msg
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.logIt = /**
         * @param {?} msg
         * @return {?}
         */
            function (msg) {
                var /** @type {?} */ level = 0;
                var /** @type {?} */ me = this.elementRef.nativeElement;
                var /** @type {?} */ tagBody = me;
                while ((tagBody = tagBody.parentNode) != null) {
                    level++;
                    if (tagBody.tagName === 'APP-ROOT' || level === 6) {
                        break;
                    }
                }
                var /** @type {?} */ indent = '';
                var /** @type {?} */ indentNumber = level;
                while (level > 0) {
                    indent += '\t';
                    level--;
                }
                var /** @type {?} */ params = '';
                if (core$1.isPresent(me.attributes)) {
                    for (var /** @type {?} */ i = 0; i < me.attributes.length; i++) {
                        var /** @type {?} */ attr = me.attributes.item(i);
                        if (this.ignore(attr.name.toLowerCase())) {
                            continue;
                        }
                        params += '(' + attr.name + '=' + attr.value + '),  ';
                    }
                }
                core$1.print(indent + me.tagName + '(' + indentNumber + '): ' + msg + ' => ' + params);
            };
        /**
         * @param {?} name
         * @return {?}
         */
        SpyLifeCycleHooksDirective.prototype.ignore = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                return name.indexOf('_ng') > -1 ||
                    name.indexOf('ng-') > -1 ||
                    name.indexOf('spyhooks') > -1;
            };
        SpyLifeCycleHooksDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[spyHooks]' },] },
        ];
        /** @nocollapse */
        SpyLifeCycleHooksDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        return SpyLifeCycleHooksDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    var components = /*#__PURE__*/Object.freeze({
        AWCoreComponentModule: AWCoreComponentModule,
        ErrorMessagesComponent: ErrorMessagesComponent,
        ModalContainer: ModalContainer,
        ModalService: ModalService,
        ModalComponent: ModalComponent,
        CurrencyFormatPipe: CurrencyFormatPipe,
        BaseComponent: BaseComponent,
        BaseFormComponent: BaseFormComponent,
        WidgetSizeColumns: WidgetSizeColumns,
        DomUtilsService: DomUtilsService,
        EmbeddedItemDirective: EmbeddedItemDirective,
        EmbededItem: EmbededItem,
        ErrorManagerService: ErrorManagerService,
        GenericContainerComponent: GenericContainerComponent,
        IncludeComponentDirective: IncludeComponentDirective,
        ComponentRegistry: ComponentRegistry,
        DataTypeProviderRegistry: DataTypeProviderRegistry,
        DataProviders: DataProviders,
        DataFinders: DataFinders,
        DataFinder: DataFinder,
        FullTextArrayDataFinder: FullTextArrayDataFinder,
        QueryType: QueryType,
        DATA_SOURCE: DATA_SOURCE,
        DataProvider: DataProvider,
        ArrayDataProvider: ArrayDataProvider,
        NgForSetDirective: NgForSetDirective,
        AwNameDirective: AwNameDirective,
        AwNameStore: AwNameStore,
        FormTableComponent: FormTableComponent,
        AWFormTableModule: AWFormTableModule,
        FormRowComponent: FormRowComponent,
        TopZoneComponent: TopZoneComponent,
        LeftZoneComponent: LeftZoneComponent,
        MiddleZoneComponent: MiddleZoneComponent,
        RightZoneComponent: RightZoneComponent,
        BottomZoneComponent: BottomZoneComponent,
        AWInputFieldModule: AWInputFieldModule,
        AWStringFieldModule: AWStringFieldModule,
        AWBasicNavigatorModule: AWBasicNavigatorModule,
        AWButtonModule: AWButtonModule,
        AWCardModule: AWCardModule,
        AWCheckBoxModule: AWCheckBoxModule,
        AWCheckBoxListModule: AWCheckBoxListModule,
        AWHyperlinkModule: AWHyperlinkModule,
        AWChooserModule: AWChooserModule,
        AWDropdownModule: AWDropdownModule,
        AWCurrencyModule: AWCurrencyModule,
        AWDateAndTimeModule: AWDateAndTimeModule,
        AWDialogModule: AWDialogModule,
        AWGenericChooserModule: AWGenericChooserModule,
        AWRadioButtonModule: AWRadioButtonModule,
        AWRadioButtonListModule: AWRadioButtonListModule,
        AWOutlineForModule: AWOutlineForModule,
        AWTextAreaModule: AWTextAreaModule,
        AWPageNotificationModule: AWPageNotificationModule,
        AWPageWrapperModule: AWPageWrapperModule,
        AWRichTextAreaModule: AWRichTextAreaModule,
        AWSectionModule: AWSectionModule,
        AWStepperModule: AWStepperModule,
        AWDatatable2Module: AWDatatable2Module,
        AWConfirmationModule: AWConfirmationModule,
        AWScrollableContainerModule: AWScrollableContainerModule,
        AWListModule: AWListModule,
        BasicNavigatorComponent: BasicNavigatorComponent,
        ButtonComponent: ButtonComponent,
        CheckBoxListComponent: CheckBoxListComponent,
        CHOOSER_CONTROL_VALUE_ACCESSOR: CHOOSER_CONTROL_VALUE_ACCESSOR,
        ChooserComponent: ChooserComponent,
        ChooserState: ChooserState,
        DefaultSelectionState: DefaultSelectionState,
        ChooserSelectionState: ChooserSelectionState,
        ChooserDataSource: ChooserDataSource,
        isDSChooserInitParams: isDSChooserInitParams,
        CURRENCY_CONTROL_VALUE_ACCESSOR: CURRENCY_CONTROL_VALUE_ACCESSOR,
        CurrencyComponent: CurrencyComponent,
        Money: Money,
        DateAndTimeComponent: DateAndTimeComponent,
        DATETIME_CONTROL_VALUE_ACCESSOR: DATETIME_CONTROL_VALUE_ACCESSOR,
        DialogComponent: DialogComponent,
        DialogHeaderComponent: DialogHeaderComponent,
        DialogFooterComponent: DialogFooterComponent,
        ConfirmationComponent: ConfirmationComponent,
        ConfirmationHeaderComponent: ConfirmationHeaderComponent,
        ConfirmationFooterComponent: ConfirmationFooterComponent,
        OverlayComponent: OverlayComponent,
        DD_CONTROL_VALUE_ACCESSOR: DD_CONTROL_VALUE_ACCESSOR,
        DropdownComponent: DropdownComponent,
        GCChooserState: GCChooserState,
        GenericChooserComponent: GenericChooserComponent,
        HyperlinkComponent: HyperlinkComponent,
        INPUT_CONTROL_VALUE_ACCESSOR: INPUT_CONTROL_VALUE_ACCESSOR,
        InputFieldComponent: InputFieldComponent,
        RadioButtonListComponent: RadioButtonListComponent,
        StringComponent: StringComponent,
        TEXTAREA_CONTROL_VALUE_ACCESSOR: TEXTAREA_CONTROL_VALUE_ACCESSOR,
        TextAreaComponent: TextAreaComponent,
        CardComponent: CardComponent,
        CardZoneTitleComponent: CardZoneTitleComponent,
        CardZoneTopComponent: CardZoneTopComponent,
        CardZoneBottomComponent: CardZoneBottomComponent,
        OutlineForComponent: OutlineForComponent,
        OutlineControlComponent: OutlineControlComponent,
        OutlineState: OutlineState,
        PageContentComponent: PageContentComponent,
        PageNotificationComponent: PageNotificationComponent,
        PageNotification: PageNotification,
        PageInitialized: PageInitialized,
        PageDestroyed: PageDestroyed,
        PageWrapper: PageWrapper,
        PageLifeCycleService: PageLifeCycleService,
        ObjectPageWrapperComponent: ObjectPageWrapperComponent,
        PageHeaderComponent: PageHeaderComponent,
        PageMenuItem: PageMenuItem,
        UserNotification: UserNotification,
        PageFooterComponent: PageFooterComponent,
        SidenavComponent: SidenavComponent,
        PageActionsComponent: PageActionsComponent,
        SectionComponent: SectionComponent,
        SubSectionComponent: SubSectionComponent,
        SectionActionsComponent: SectionActionsComponent,
        EditorType: EditorType,
        RichTextAreaComponent: RichTextAreaComponent,
        CheckboxComponent: CheckboxComponent,
        RadioButtonComponent: RadioButtonComponent,
        StepperComponent: StepperComponent,
        StepComponent: StepComponent,
        ScrollableContainerComponent: ScrollableContainerComponent,
        HoverCardComponent: HoverCardComponent,
        ListComponent: ListComponent,
        Datatable2Component: Datatable2Component,
        DTHeaderComponent2: DTHeaderComponent2,
        DTColumn2Component: DTColumn2Component,
        DTDetailRowComponent: DTDetailRowComponent,
        Datatable2State: Datatable2State,
        isDTInitParams: isDTInitParams,
        DT2DataSource: DT2DataSource,
        DetailRowExpansionState: DetailRowExpansionState,
        DTMultiSelectColumnComponent: DTMultiSelectColumnComponent,
        DomHandler: primeng.DomHandler,
        TreeDragDropService: primeng.TreeDragDropService,
        ConfirmationService: primeng.ConfirmationService,
        Header: primeng.Header,
        Footer: primeng.Footer,
        PrimeTemplate: primeng.PrimeTemplate,
        Column: primeng.Column,
        Row: primeng.Row,
        HeaderColumnGroup: primeng.HeaderColumnGroup,
        FooterColumnGroup: primeng.FooterColumnGroup,
        SharedModule: primeng.SharedModule,
        AccordionTab: primeng.AccordionTab,
        Accordion: primeng.Accordion,
        AccordionModule: primeng.AccordionModule,
        AUTOCOMPLETE_VALUE_ACCESSOR: primeng.AUTOCOMPLETE_VALUE_ACCESSOR,
        AutoComplete: primeng.AutoComplete,
        AutoCompleteModule: primeng.AutoCompleteModule,
        BlockUI: primeng.BlockUI,
        BlockUIModule: primeng.BlockUIModule,
        Breadcrumb: primeng.Breadcrumb,
        BreadcrumbModule: primeng.BreadcrumbModule,
        ButtonDirective: primeng.ButtonDirective,
        Button: primeng.Button,
        ButtonModule: primeng.ButtonModule,
        Captcha: primeng.Captcha,
        CaptchaModule: primeng.CaptchaModule,
        CALENDAR_VALUE_ACCESSOR: primeng.CALENDAR_VALUE_ACCESSOR,
        Calendar: primeng.Calendar,
        CalendarModule: primeng.CalendarModule,
        Card: primeng.Card,
        CardModule: primeng.CardModule,
        Carousel: primeng.Carousel,
        CarouselModule: primeng.CarouselModule,
        UIChart: primeng.UIChart,
        ChartModule: primeng.ChartModule,
        CHECKBOX_VALUE_ACCESSOR: primeng.CHECKBOX_VALUE_ACCESSOR,
        Checkbox: primeng.Checkbox,
        CheckboxModule: primeng.CheckboxModule,
        CHIPS_VALUE_ACCESSOR: primeng.CHIPS_VALUE_ACCESSOR,
        Chips: primeng.Chips,
        ChipsModule: primeng.ChipsModule,
        CodeHighlighter: primeng.CodeHighlighter,
        CodeHighlighterModule: primeng.CodeHighlighterModule,
        COLORPICKER_VALUE_ACCESSOR: primeng.COLORPICKER_VALUE_ACCESSOR,
        ColorPicker: primeng.ColorPicker,
        ColorPickerModule: primeng.ColorPickerModule,
        ConfirmDialog: primeng.ConfirmDialog,
        ConfirmDialogModule: primeng.ConfirmDialogModule,
        ContextMenuSub: primeng.ContextMenuSub,
        ContextMenu: primeng.ContextMenu,
        ContextMenuModule: primeng.ContextMenuModule,
        DataGrid: primeng.DataGrid,
        DataGridModule: primeng.DataGridModule,
        DataList: primeng.DataList,
        DataListModule: primeng.DataListModule,
        DataScroller: primeng.DataScroller,
        DataScrollerModule: primeng.DataScrollerModule,
        DTRadioButton: primeng.DTRadioButton,
        DTCheckbox: primeng.DTCheckbox,
        ColumnHeaders: primeng.ColumnHeaders,
        ColumnFooters: primeng.ColumnFooters,
        TableBody: primeng.TableBody,
        ScrollableView: primeng.ScrollableView,
        DataTable: primeng.DataTable,
        DataTableModule: primeng.DataTableModule,
        DeferredLoader: primeng.DeferredLoader,
        DeferModule: primeng.DeferModule,
        Dialog: primeng.Dialog,
        DialogModule: primeng.DialogModule,
        Draggable: primeng.Draggable,
        Droppable: primeng.Droppable,
        DragDropModule: primeng.DragDropModule,
        DROPDOWN_VALUE_ACCESSOR: primeng.DROPDOWN_VALUE_ACCESSOR,
        Dropdown: primeng.Dropdown,
        DropdownModule: primeng.DropdownModule,
        EDITOR_VALUE_ACCESSOR: primeng.EDITOR_VALUE_ACCESSOR,
        Editor: primeng.Editor,
        EditorModule: primeng.EditorModule,
        Fieldset: primeng.Fieldset,
        FieldsetModule: primeng.FieldsetModule,
        FileUpload: primeng.FileUpload,
        FileUploadModule: primeng.FileUploadModule,
        Galleria: primeng.Galleria,
        GalleriaModule: primeng.GalleriaModule,
        GMap: primeng.GMap,
        GMapModule: primeng.GMapModule,
        Growl: primeng.Growl,
        GrowlModule: primeng.GrowlModule,
        InplaceDisplay: primeng.InplaceDisplay,
        InplaceContent: primeng.InplaceContent,
        Inplace: primeng.Inplace,
        InplaceModule: primeng.InplaceModule,
        INPUTMASK_VALUE_ACCESSOR: primeng.INPUTMASK_VALUE_ACCESSOR,
        InputMask: primeng.InputMask,
        InputMaskModule: primeng.InputMaskModule,
        INPUTSWITCH_VALUE_ACCESSOR: primeng.INPUTSWITCH_VALUE_ACCESSOR,
        InputSwitch: primeng.InputSwitch,
        InputSwitchModule: primeng.InputSwitchModule,
        InputText: primeng.InputText,
        InputTextModule: primeng.InputTextModule,
        InputTextarea: primeng.InputTextarea,
        InputTextareaModule: primeng.InputTextareaModule,
        KEYFILTER_VALIDATOR: primeng.KEYFILTER_VALIDATOR,
        KeyFilter: primeng.KeyFilter,
        KeyFilterModule: primeng.KeyFilterModule,
        Lightbox: primeng.Lightbox,
        LightboxModule: primeng.LightboxModule,
        LISTBOX_VALUE_ACCESSOR: primeng.LISTBOX_VALUE_ACCESSOR,
        Listbox: primeng.Listbox,
        ListboxModule: primeng.ListboxModule,
        MegaMenu: primeng.MegaMenu,
        MegaMenuModule: primeng.MegaMenuModule,
        MenuItemContent: primeng.MenuItemContent,
        Menu: primeng.Menu,
        MenuModule: primeng.MenuModule,
        MenubarSub: primeng.MenubarSub,
        Menubar: primeng.Menubar,
        MenubarModule: primeng.MenubarModule,
        Messages: primeng.Messages,
        MessagesModule: primeng.MessagesModule,
        UIMessage: primeng.UIMessage,
        MessageModule: primeng.MessageModule,
        MULTISELECT_VALUE_ACCESSOR: primeng.MULTISELECT_VALUE_ACCESSOR,
        MultiSelect: primeng.MultiSelect,
        MultiSelectModule: primeng.MultiSelectModule,
        OrderList: primeng.OrderList,
        OrderListModule: primeng.OrderListModule,
        OrganizationChartNode: primeng.OrganizationChartNode,
        OrganizationChart: primeng.OrganizationChart,
        OrganizationChartModule: primeng.OrganizationChartModule,
        OverlayPanel: primeng.OverlayPanel,
        OverlayPanelModule: primeng.OverlayPanelModule,
        Paginator: primeng.Paginator,
        PaginatorModule: primeng.PaginatorModule,
        Panel: primeng.Panel,
        PanelModule: primeng.PanelModule,
        BasePanelMenuItem: primeng.BasePanelMenuItem,
        PanelMenuSub: primeng.PanelMenuSub,
        PanelMenu: primeng.PanelMenu,
        PanelMenuModule: primeng.PanelMenuModule,
        Password: primeng.Password,
        PasswordModule: primeng.PasswordModule,
        PickList: primeng.PickList,
        PickListModule: primeng.PickListModule,
        ProgressBar: primeng.ProgressBar,
        ProgressBarModule: primeng.ProgressBarModule,
        ProgressSpinner: primeng.ProgressSpinner,
        ProgressSpinnerModule: primeng.ProgressSpinnerModule,
        RADIO_VALUE_ACCESSOR: primeng.RADIO_VALUE_ACCESSOR,
        RadioButton: primeng.RadioButton,
        RadioButtonModule: primeng.RadioButtonModule,
        RATING_VALUE_ACCESSOR: primeng.RATING_VALUE_ACCESSOR,
        Rating: primeng.Rating,
        RatingModule: primeng.RatingModule,
        Schedule: primeng.Schedule,
        ScheduleModule: primeng.ScheduleModule,
        ScrollPanel: primeng.ScrollPanel,
        ScrollPanelModule: primeng.ScrollPanelModule,
        SELECTBUTTON_VALUE_ACCESSOR: primeng.SELECTBUTTON_VALUE_ACCESSOR,
        SelectButton: primeng.SelectButton,
        SelectButtonModule: primeng.SelectButtonModule,
        SlideMenuSub: primeng.SlideMenuSub,
        SlideMenu: primeng.SlideMenu,
        SlideMenuModule: primeng.SlideMenuModule,
        SLIDER_VALUE_ACCESSOR: primeng.SLIDER_VALUE_ACCESSOR,
        Slider: primeng.Slider,
        SliderModule: primeng.SliderModule,
        Sidebar: primeng.Sidebar,
        SidebarModule: primeng.SidebarModule,
        SPINNER_VALUE_ACCESSOR: primeng.SPINNER_VALUE_ACCESSOR,
        Spinner: primeng.Spinner,
        SpinnerModule: primeng.SpinnerModule,
        SplitButton: primeng.SplitButton,
        SplitButtonModule: primeng.SplitButtonModule,
        Steps: primeng.Steps,
        StepsModule: primeng.StepsModule,
        TabViewNav: primeng.TabViewNav,
        TabPanel: primeng.TabPanel,
        TabView: primeng.TabView,
        TabViewModule: primeng.TabViewModule,
        TabMenu: primeng.TabMenu,
        TabMenuModule: primeng.TabMenuModule,
        Terminal: primeng.Terminal,
        TerminalModule: primeng.TerminalModule,
        TieredMenuSub: primeng.TieredMenuSub,
        TieredMenu: primeng.TieredMenu,
        TieredMenuModule: primeng.TieredMenuModule,
        TOGGLEBUTTON_VALUE_ACCESSOR: primeng.TOGGLEBUTTON_VALUE_ACCESSOR,
        ToggleButton: primeng.ToggleButton,
        ToggleButtonModule: primeng.ToggleButtonModule,
        Toolbar: primeng.Toolbar,
        ToolbarModule: primeng.ToolbarModule,
        Tooltip: primeng.Tooltip,
        TooltipModule: primeng.TooltipModule,
        UITreeNode: primeng.UITreeNode,
        Tree: primeng.Tree,
        TreeModule: primeng.TreeModule,
        TreeTableService: primeng.TreeTableService,
        TreeTable: primeng.TreeTable,
        TTBody: primeng.TTBody,
        TTScrollableView: primeng.TTScrollableView,
        TTSortableColumn: primeng.TTSortableColumn,
        TTSortIcon: primeng.TTSortIcon,
        TTResizableColumn: primeng.TTResizableColumn,
        TTReorderableColumn: primeng.TTReorderableColumn,
        TTSelectableRow: primeng.TTSelectableRow,
        TTSelectableRowDblClick: primeng.TTSelectableRowDblClick,
        TTContextMenuRow: primeng.TTContextMenuRow,
        TTCheckbox: primeng.TTCheckbox,
        TTHeaderCheckbox: primeng.TTHeaderCheckbox,
        TTEditableColumn: primeng.TTEditableColumn,
        TreeTableCellEditor: primeng.TreeTableCellEditor,
        TreeTableToggler: primeng.TreeTableToggler,
        TreeTableModule: primeng.TreeTableModule,
        TRISTATECHECKBOX_VALUE_ACCESSOR: primeng.TRISTATECHECKBOX_VALUE_ACCESSOR,
        TriStateCheckbox: primeng.TriStateCheckbox,
        TriStateCheckboxModule: primeng.TriStateCheckboxModule
    });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWOverlayModule = (function () {
        function AWOverlayModule() {
        }
        AWOverlayModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OverlayComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWCoreComponentModule,
                            primeng.OverlayPanelModule
                        ],
                        entryComponents: [
                            OverlayComponent
                        ],
                        exports: [
                            OverlayComponent,
                            AWCoreComponentModule
                        ],
                        providers: []
                    },] },
        ];
        return AWOverlayModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AWHoverCardModule = (function () {
        function AWHoverCardModule() {
        }
        AWHoverCardModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            HoverCardComponent
                        ],
                        imports: [
                            common.CommonModule,
                            AWOverlayModule,
                            AWStringFieldModule
                        ],
                        entryComponents: [
                            HoverCardComponent
                        ],
                        exports: [
                            HoverCardComponent
                        ],
                        providers: []
                    },] },
        ];
        return AWHoverCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Component module is core module for the common layouts and widgets libraries.
     *
     * todo: There are some things that I still need to resolve - please see and notices \@Duplicates
     * jsdoc I want to keep this there to remind me that I need to refactor this as of now there are
     * not much option with angular.
     *
     */
    var AribaComponentsModule = (function () {
        function AribaComponentsModule() {
        }
        /**
         * @return {?}
         */
        AribaComponentsModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: AribaComponentsModule,
                    providers: [
                        ModalService,
                        ComponentRegistry,
                        ErrorManagerService,
                        DomUtilsService,
                        DataTypeProviderRegistry,
                        DataProviders,
                        DataFinders,
                        AwNameStore,
                        {
                            provide: core.APP_INITIALIZER,
                            useFactory: registerComponents,
                            deps: [ComponentRegistry],
                            multi: true,
                        }
                    ]
                };
            };
        AribaComponentsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            core$1.AribaCoreModule,
                            common.CommonModule,
                            forms.FormsModule,
                            forms.ReactiveFormsModule,
                            AWCoreComponentModule,
                            AWBasicNavigatorModule,
                            AWCardModule,
                            AWCheckBoxListModule,
                            AWCheckBoxModule,
                            AWChooserModule,
                            AWConfirmationModule,
                            AWCurrencyModule,
                            AWDateAndTimeModule,
                            AWDialogModule,
                            AWDropdownModule,
                            AWGenericChooserModule,
                            AWHyperlinkModule,
                            AWInputFieldModule,
                            AWOutlineForModule,
                            AWOverlayModule,
                            AWPageNotificationModule,
                            AWPageWrapperModule,
                            AWRadioButtonModule,
                            AWRadioButtonListModule,
                            AWRichTextAreaModule,
                            AWScrollableContainerModule,
                            AWSectionModule,
                            AWStepperModule,
                            AWStringFieldModule,
                            AWTextAreaModule,
                            AWFormTableModule,
                            AWButtonModule,
                            AWHoverCardModule,
                            AWListModule,
                            AWDatatable2Module,
                            primeng.PanelModule,
                            primeng.ButtonModule,
                            primeng.ToolbarModule,
                            primeng.InputTextModule,
                            primeng.InputTextareaModule,
                            primeng.AutoCompleteModule,
                            primeng.DropdownModule,
                            primeng.CalendarModule,
                            primeng.CheckboxModule,
                            primeng.RadioButtonModule,
                            primeng.SharedModule,
                            primeng.DialogModule,
                            primeng.MenuModule,
                            primeng.TabMenuModule,
                            primeng.AccordionModule,
                            primeng.EditorModule,
                            primeng.DataTableModule,
                            primeng.PaginatorModule,
                            primeng.OverlayPanelModule
                        ],
                        declarations: [
                            SpyLifeCycleHooksDirective,
                        ],
                        bootstrap: [],
                        entryComponents: [
                            primeng.Checkbox,
                            primeng.Dialog
                        ],
                        exports: [
                            forms.ReactiveFormsModule,
                            forms.FormsModule,
                            SpyLifeCycleHooksDirective,
                            AWCoreComponentModule,
                            AWBasicNavigatorModule,
                            AWCardModule,
                            AWCheckBoxListModule,
                            AWCheckBoxModule,
                            AWChooserModule,
                            AWConfirmationModule,
                            AWCurrencyModule,
                            AWDateAndTimeModule,
                            AWDialogModule,
                            AWDropdownModule,
                            AWGenericChooserModule,
                            AWHyperlinkModule,
                            AWInputFieldModule,
                            AWOutlineForModule,
                            AWOverlayModule,
                            AWPageNotificationModule,
                            AWPageWrapperModule,
                            AWRadioButtonModule,
                            AWRadioButtonListModule,
                            AWRichTextAreaModule,
                            AWScrollableContainerModule,
                            AWSectionModule,
                            AWStepperModule,
                            AWStringFieldModule,
                            AWTextAreaModule,
                            AWFormTableModule,
                            EmbeddedItemDirective,
                            AWButtonModule,
                            AWHoverCardModule,
                            AWListModule,
                            AWDatatable2Module,
                            primeng.SharedModule,
                            primeng.PanelModule,
                            primeng.ButtonModule,
                            primeng.ToolbarModule,
                            primeng.InputTextModule,
                            primeng.InputTextareaModule,
                            primeng.AutoCompleteModule,
                            primeng.DropdownModule,
                            primeng.CalendarModule,
                            primeng.CheckboxModule,
                            primeng.RadioButtonModule,
                            primeng.DialogModule,
                            primeng.MenuModule,
                            primeng.TabMenuModule,
                            primeng.EditorModule,
                            primeng.DataTableModule,
                            primeng.PaginatorModule,
                            primeng.OverlayPanelModule
                        ]
                    },] },
        ];
        return AribaComponentsModule;
    }());
    /**
     * @param {?} compRegistry
     * @return {?}
     */
    function registerComponents(compRegistry) {
        return compRegistry.initialize.bind(compRegistry, components);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     *
     * This module is used mainly for tests as importing a module with all the components and you
     * use only 1 or two has a big impact on the performance execution. e.g. from executing couple
     * tests under 1 sec can go up to 10sec if you import all the things that you are not using.
     *
     * I havent noticed anything similar in application its only jasmine/karma that needs to init
     * components for every test.
     *
     */
    var AribaComponentsTestProviderModule = (function () {
        function AribaComponentsTestProviderModule() {
        }
        /**
         * @return {?}
         */
        AribaComponentsTestProviderModule.forRoot = /**
         * @return {?}
         */
            function () {
                return {
                    ngModule: AribaComponentsTestProviderModule,
                    providers: [
                        ModalService,
                        ComponentRegistry,
                        ErrorManagerService,
                        DomUtilsService,
                        DataTypeProviderRegistry,
                        DataProviders,
                        DataFinders,
                        AwNameStore,
                        {
                            provide: core.APP_INITIALIZER,
                            useFactory: registerComponents$1,
                            deps: [ComponentRegistry],
                            multi: true,
                        }
                    ]
                };
            };
        AribaComponentsTestProviderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: []
                    },] },
        ];
        return AribaComponentsTestProviderModule;
    }());
    /**
     * @param {?} compRegistry
     * @return {?}
     */
    function registerComponents$1(compRegistry) {
        return compRegistry.initialize.bind(compRegistry, components);
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.ErrorMessagesComponent = ErrorMessagesComponent;
    exports.ModalContainer = ModalContainer;
    exports.ModalService = ModalService;
    exports.ModalComponent = ModalComponent;
    exports.CurrencyFormatPipe = CurrencyFormatPipe;
    exports.BaseComponent = BaseComponent;
    exports.WidgetSizeColumns = WidgetSizeColumns;
    exports.DomUtilsService = DomUtilsService;
    exports.EmbeddedItemDirective = EmbeddedItemDirective;
    exports.EmbededItem = EmbededItem;
    exports.ErrorManagerService = ErrorManagerService;
    exports.GenericContainerComponent = GenericContainerComponent;
    exports.IncludeComponentDirective = IncludeComponentDirective;
    exports.ComponentRegistry = ComponentRegistry;
    exports.AWCoreComponentModule = AWCoreComponentModule;
    exports.BaseFormComponent = BaseFormComponent;
    exports.DataTypeProviderRegistry = DataTypeProviderRegistry;
    exports.DataProvider = DataProvider;
    exports.DataProviders = DataProviders;
    exports.DataFinders = DataFinders;
    exports.DataFinder = DataFinder;
    exports.QueryType = QueryType;
    exports.FullTextArrayDataFinder = FullTextArrayDataFinder;
    exports.DATA_SOURCE = DATA_SOURCE;
    exports.ArrayDataProvider = ArrayDataProvider;
    exports.NgForSetDirective = NgForSetDirective;
    exports.AwNameDirective = AwNameDirective;
    exports.AwNameStore = AwNameStore;
    exports.FormTableComponent = FormTableComponent;
    exports.FormRowComponent = FormRowComponent;
    exports.TopZoneComponent = TopZoneComponent;
    exports.LeftZoneComponent = LeftZoneComponent;
    exports.MiddleZoneComponent = MiddleZoneComponent;
    exports.RightZoneComponent = RightZoneComponent;
    exports.BottomZoneComponent = BottomZoneComponent;
    exports.AWFormTableModule = AWFormTableModule;
    exports.BasicNavigatorComponent = BasicNavigatorComponent;
    exports.ButtonComponent = ButtonComponent;
    exports.CheckBoxListComponent = CheckBoxListComponent;
    exports.CHOOSER_CONTROL_VALUE_ACCESSOR = CHOOSER_CONTROL_VALUE_ACCESSOR;
    exports.ChooserComponent = ChooserComponent;
    exports.ChooserState = ChooserState;
    exports.DefaultSelectionState = DefaultSelectionState;
    exports.ChooserSelectionState = ChooserSelectionState;
    exports.CURRENCY_CONTROL_VALUE_ACCESSOR = CURRENCY_CONTROL_VALUE_ACCESSOR;
    exports.CurrencyComponent = CurrencyComponent;
    exports.Money = Money;
    exports.DateAndTimeComponent = DateAndTimeComponent;
    exports.DATETIME_CONTROL_VALUE_ACCESSOR = DATETIME_CONTROL_VALUE_ACCESSOR;
    exports.DialogComponent = DialogComponent;
    exports.DialogHeaderComponent = DialogHeaderComponent;
    exports.DialogFooterComponent = DialogFooterComponent;
    exports.ConfirmationComponent = ConfirmationComponent;
    exports.ConfirmationHeaderComponent = ConfirmationHeaderComponent;
    exports.ConfirmationFooterComponent = ConfirmationFooterComponent;
    exports.OverlayComponent = OverlayComponent;
    exports.DropdownComponent = DropdownComponent;
    exports.GCChooserState = GCChooserState;
    exports.GenericChooserComponent = GenericChooserComponent;
    exports.HyperlinkComponent = HyperlinkComponent;
    exports.INPUT_CONTROL_VALUE_ACCESSOR = INPUT_CONTROL_VALUE_ACCESSOR;
    exports.InputFieldComponent = InputFieldComponent;
    exports.RadioButtonListComponent = RadioButtonListComponent;
    exports.StringComponent = StringComponent;
    exports.TEXTAREA_CONTROL_VALUE_ACCESSOR = TEXTAREA_CONTROL_VALUE_ACCESSOR;
    exports.TextAreaComponent = TextAreaComponent;
    exports.OutlineForComponent = OutlineForComponent;
    exports.OutlineControlComponent = OutlineControlComponent;
    exports.PageActionsComponent = PageActionsComponent;
    exports.PageContentComponent = PageContentComponent;
    exports.PageFooterComponent = PageFooterComponent;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageMenuItem = PageMenuItem;
    exports.UserNotification = UserNotification;
    exports.PageNotificationComponent = PageNotificationComponent;
    exports.PageNotification = PageNotification;
    exports.PageInitialized = PageInitialized;
    exports.PageDestroyed = PageDestroyed;
    exports.PageWrapper = PageWrapper;
    exports.PageLifeCycleService = PageLifeCycleService;
    exports.ObjectPageWrapperComponent = ObjectPageWrapperComponent;
    exports.SectionComponent = SectionComponent;
    exports.SubSectionComponent = SubSectionComponent;
    exports.RichTextAreaComponent = RichTextAreaComponent;
    exports.EditorType = EditorType;
    exports.CheckboxComponent = CheckboxComponent;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.StepperComponent = StepperComponent;
    exports.StepComponent = StepComponent;
    exports.AWInputFieldModule = AWInputFieldModule;
    exports.AWStringFieldModule = AWStringFieldModule;
    exports.AWBasicNavigatorModule = AWBasicNavigatorModule;
    exports.AWButtonModule = AWButtonModule;
    exports.AWHyperlinkModule = AWHyperlinkModule;
    exports.AWCardModule = AWCardModule;
    exports.AWCheckBoxModule = AWCheckBoxModule;
    exports.AWCheckBoxListModule = AWCheckBoxListModule;
    exports.AWChooserModule = AWChooserModule;
    exports.AWDropdownModule = AWDropdownModule;
    exports.AWCurrencyModule = AWCurrencyModule;
    exports.AWDateAndTimeModule = AWDateAndTimeModule;
    exports.AWDialogModule = AWDialogModule;
    exports.AWGenericChooserModule = AWGenericChooserModule;
    exports.AWRadioButtonModule = AWRadioButtonModule;
    exports.AWRadioButtonListModule = AWRadioButtonListModule;
    exports.AWTextAreaModule = AWTextAreaModule;
    exports.AWPageNotificationModule = AWPageNotificationModule;
    exports.AWPageWrapperModule = AWPageWrapperModule;
    exports.AWRichTextAreaModule = AWRichTextAreaModule;
    exports.AWSectionModule = AWSectionModule;
    exports.AWStepperModule = AWStepperModule;
    exports.ScrollableContainerComponent = ScrollableContainerComponent;
    exports.AWScrollableContainerModule = AWScrollableContainerModule;
    exports.AWConfirmationModule = AWConfirmationModule;
    exports.ChooserDataSource = ChooserDataSource;
    exports.isDSChooserInitParams = isDSChooserInitParams;
    exports.HoverCardComponent = HoverCardComponent;
    exports.ListComponent = ListComponent;
    exports.AWListModule = AWListModule;
    exports.CardComponent = CardComponent;
    exports.OutlineState = OutlineState;
    exports.Datatable2Component = Datatable2Component;
    exports.DTColumn2Component = DTColumn2Component;
    exports.DTHeaderComponent2 = DTHeaderComponent2;
    exports.DTDetailRowComponent = DTDetailRowComponent;
    exports.DetailRowExpansionState = DetailRowExpansionState;
    exports.Datatable2State = Datatable2State;
    exports.isDTInitParams = isDTInitParams;
    exports.DT2DataSource = DT2DataSource;
    exports.DTMultiSelectColumnComponent = DTMultiSelectColumnComponent;
    exports.AWDatatable2Module = AWDatatable2Module;
    exports.AribaComponentsModule = AribaComponentsModule;
    exports.AribaComponentsTestProviderModule = AribaComponentsTestProviderModule;
    exports.SpyLifeCycleHooksDirective = SpyLifeCycleHooksDirective;
    exports.ɵq = registerComponents;
    exports.ɵr = registerComponents$1;
    exports.ɵa = DataSource;
    exports.ɵs = InfiniteScrollComponent;
    exports.ɵi = CardZoneTitleComponent;
    exports.ɵh = CardZoneBottomComponent;
    exports.ɵg = CardZoneTopComponent;
    exports.ɵb = AWCardModule;
    exports.ɵd = CB_LIST_CONTROL_VALUE_ACCESSOR;
    exports.ɵn = CB_CONTROL_VALUE_ACCESSOR;
    exports.ɵv = DTDetailRowExpanderComponent;
    exports.ɵw = DTSingleSelectColumnComponent;
    exports.ɵx = SetCellMaxWidthDirective;
    exports.ɵy = DTDraggableRowDirective;
    exports.ɵu = DTWrapper;
    exports.ɵe = DD_CONTROL_VALUE_ACCESSOR;
    exports.ɵba = AWHoverCardModule;
    exports.ɵp = LB_CONTROL_VALUE_ACCESSOR;
    exports.ɵj = InitNestingDirective;
    exports.ɵc = AWOutlineForModule;
    exports.ɵz = AWOverlayModule;
    exports.ɵk = SidenavComponent;
    exports.ɵf = RB_LIST_CONTROL_VALUE_ACCESSOR;
    exports.ɵo = RAB_CONTROL_VALUE_ACCESSOR;
    exports.ɵm = EDITOR_CONTROL_VALUE_ACCESSOR;
    exports.ɵl = SectionActionsComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJpYmF1aS1jb21wb25lbnRzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2VtYmVkZGVkLWl0ZW0udHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9nZW5lcmljLWNvbnRhaW5lci5jb21wb25lbnQudHMiLG51bGwsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2Jhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9lcnJvci1tZXNzYWdlcy9lcnJvci1tZXNzYWdlcy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsL21vZGFsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvb24tbmdmb3Itc2V0LmRpcmVjdGl2ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RvbS11dGlscy5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvaW5maXRlLXNjcm9sbC9pbmZpdGUtc2Nyb2xsLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2F3LW5hbWUvYXctbmFtZS5kaXJlY3RpdmUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvY29yZS9jb3JlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9hcnJheS1kYXRhLXByb3ZpZGVyLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycy50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9jb3JlL2RhdGEvZGF0YS1maW5kZXJzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2NvcmUvZGF0YS9kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9sYXlvdXRzL2ZpdmUtem9uZS1sYXlvdXQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2lucHV0LWZpZWxkL2lucHV0LWZpZWxkLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0cmluZy9zdHJpbmcubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvaW5wdXQtZmllbGQvaW5wdXQtZmllbGQubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9idXR0b24vYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2J1dHRvbi9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jYXJkL2NhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLXRpdGxlL2NhcmQtdGl0bGUuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaGVjay1ib3gtbGlzdC9jaGVjay1ib3gtbGlzdC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9oeXBlcmxpbmsvaHlwZXJsaW5rLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2h5cGVybGluay9oeXBlcmxpbmsubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1zdGF0ZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci1kYXRhLXNvdXJjZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2Nob29zZXIvY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9jaG9vc2VyL2Nob29zZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZHJvcGRvd24vZHJvcGRvd24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0ZS1hbmQtdGltZS9kYXRlLWFuZC10aW1lLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLWZvb3Rlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kaWFsb2cvZGlhbG9nLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9yYWRpby1idXR0b24vcmFkaW8tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmFkaW8tYnV0dG9uLWxpc3QvcmFkaW8tYnV0dG9uLWxpc3QubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZ2VuZXJpYy1jaG9vc2VyL2dlbmVyaWMtY2hvb3Nlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtc3RhdGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL291dGxpbmUvb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3RleHQtYXJlYS90ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvdGV4dC1hcmVhL3RleHQtYXJlYS5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1ldmVudHMudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1saWZlY3ljbGUuc2VydmljZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2UtZm9vdGVyL3BhZ2UtZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9vYmplY3QtcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2UtYWN0aW9ucy9wYWdlLWFjdGlvbnMuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2UtY29udGVudC9wYWdlLWNvbnRlbnQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0ZXBwZXIvc3RlcC9zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3N0ZXBwZXIvc3RlcHBlci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9wYWdlLXdyYXBwZXIvc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3BhZ2Utd3JhcHBlci9wYWdlLXdyYXBwZXIubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvc2VjdGlvbi9zZWN0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL3NlY3Rpb24vc2VjdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvY29sdW1uL2RldGFpbC1yb3cvZHQtZGV0YWlsLXJvdy5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9hdy1kYXRhdGFibGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9tdWx0aS1zZWxlY3QvZHQtbXVsdGktc2VsZWN0LWNvbHVtbi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2NvbHVtbi9zaW5nbGUtc2VsZWN0L2R0LXNpbmdsZS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL3RhYmxlLXdyYXBwZXIvdGFibGUtd3JhcHBlci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9kYXRhdGFibGUyL2RpcmVjdGl2ZXMvZHQtY2VsbC1kaXJlY3RpdmVzLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvZGF0YXRhYmxlMi9kYXRhdGFibGUyLm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24taGVhZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24tZm9vdGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2NvbmZpcm1hdGlvbi9jb25maXJtYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9saXN0L2xpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvbGlzdC9saXN0Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3NweS1saWZlY3ljbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYXJpYmF1aS9jb21wb25lbnRzL3dpZGdldHMvb3ZlcmxheS9vdmVybGF5Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy93aWRnZXRzL2hvdmVyLWNhcmQvaG92ZXItY2FyZC5tb2R1bGUudHMiLCJuZzovL0BhcmliYXVpL2NvbXBvbmVudHMvYXJpYmEuY29tcG9uZW50Lm1vZHVsZS50cyIsIm5nOi8vQGFyaWJhdWkvY29tcG9uZW50cy9hcmliYS5jb21wb25lbnQucHJvdmlkZXIubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBEaXJlY3RpdmUsXG4gICAgRW1iZWRkZWRWaWV3UmVmLFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBXaGVuIHdlIGhhdmUgYSBjdXN0b20gY29tcG9uZW50IGxpa2UgZHJvcGRvd24sIHJhZGlvYnV0dG9ubGlzdCBhbmRcbiAqIG1hbnkgbW9yZSB3ZSB3YW50IHRvIHByb3ZpZGUgYSBjdXN0b20gY29udGVudCB0byBpdCBsaWtlIHNvOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICpcbiAqIGBgYFxuICogV2hvIGVsc2Ugd291bGQga25vdyBob3cgdG8gcmVuZGVyIGxpc3Qgb2Ygb2JqZWN0cy4uXG4gKlxuICogQnV0IGl0cyBub3QgcG9zc2libGUgaW4gY3VycmVudCBmb3JtLiBpZiBJIGRvIG5vdCBwcm92aWRlIEFuZ3VsYXIgc29tZSBhcyB0aGV5IGNhbGwgaXQgdGhpc1xuICogc3ludGFjdGljIHN1Z2FyICosXG4gKlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biAqbXlTdWdlckRpcmVjdGl2ZT0uLi4uLj5cbiAqICAgICAge3tpdGVtLnVzZXJOYW1lfX1cbiAqXG4gKiAgIDxhdy1kcm9wZG93blxuICogYGBgXG4gKlxuICpcbiAqIHRoZW4gYW5ndWxhciB3aWxsIG5vdCBrbm93ICBpbnNpZGUgaXMgYSB0ZW1wbGF0ZSBhbmQgSSB3b250IGJlIGFibGUgdG8gZ2V0IGhvbGQgb2YgVGVtcGxhdGVSZWZcbiAqIGluc2lkZSB0aGUgY29tcG9uZW50XG4gKlxuICogU28gdGhlIG9ubHkgd2F5IEkgZm91bmQgKGV4cGVjdGluZyBJIGRvIG5vdCB3YW50IHRvIGNoYW5nZSBhbnl0aGluZyBpbiB0ZXJtcyBvZiBiaW5kaW5ncyBhbmQgdGhlXG4gKiBzaWduYXR1cmUgSSB1c2UgaXQuIEkgaGF2ZSB0byB1c2UgaXQgbGlrZSB0aGlzOlxuICpcbiAqIGBgYFxuICogIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0T2ZVc2Vyc1wiIGxldCBzb21laG93R2V0SXRlbU91dD5cbiAqICAgICAgPG5nLXRlbXBsYXRlIGxldC1pdGVtPiB7e2l0ZW0udXNlck5hbWV9fTwvbmctdGVtcGxhdGU+XG4gKlxuICogICA8YXctZHJvcGRvd25cbiAqXG4gKiBgYGBcbiAqXG4gKiAgVGhpcyB3YXkgaXQgY291bGQgd29yay4gU2luY2UgSSBhbSBpbnNpZGUgbmdGb3IgSSB3YW50IHRvIHJlbmRlciB0aGUgaXRlbSBpbnRvIHRoZSBjb3JyZWN0XG4gKiB2aWV3Q29udGFpbmVyIG9mIG5nRm9yJ3MgY3VycmVudCBpdGVtLlxuICpcbiAqICBUaGlzIHdheSBJIGNhbiBhbHNvIGV4cG9zZSBpdGVtIG91dHNpZGUgdXNpbmcgQW5ndWxhcidzIHNwZWNpYWwgbG9jYWwgdmFyaWFibGUgY2FsbGVkOlxuICogJGltcGxpY2l0LlxuICpcbiAqIFRoaXMgZ2V0cyBldmVuIG1vcmUgY29tcGxleCBpZiB3ZSB0cnkgdG8gcGFzcyB0aGlzIHRlbXBsYXRlIDIgbGV2ZWxzIGRvd24sIGxpa2UgaW4gY2FzZSBvZlxuICogUmFkaW9CdXR0b25MaXN0LiBCdXQgbGF0ZXIgb24gSSBtaWdodCB3YW50IHRvIHJlZmFjdG9yIHRoaXMgaW50byBjdXN0b20gTkcgRk9SXG4gKlxuICogQGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgbmdUZW1wbGF0ZU91dGxldCAod2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHZlcnNpb24pXG4gKlxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tlbWJlZGRlZEl0ZW1dJ30pXG5leHBvcnQgY2xhc3MgRW1iZWRkZWRJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzXG57XG4gICAgLyoqXG4gICAgICogVGVtcGxhdGUgd2Ugd2FudCB0byByZW5kZXIgTi1UaW1lc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZW1iZWRkZWRJdGVtOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbShpdGVtOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl9pbXBsaWNpdFZhbHVlID0gaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pbXBsaWNpdFZhbHVlOiBhbnk7XG4gICAgcHJpdmF0ZSBfdmlld1JlZjogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fdmlld1JlZikpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIucmVtb3ZlKHRoaXMuX3ZpZXdDb250YWluZXIuaW5kZXhPZih0aGlzLl92aWV3UmVmKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZW1iZWRkZWRJdGVtKSkge1xuICAgICAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgRW1iZWRlZEl0ZW0odGhpcy5faW1wbGljaXRWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl92aWV3UmVmID0gdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5lbWJlZGRlZEl0ZW0sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogV3JhcHBlciBjbGFzcyBhcm91bmQgQW5ndWxhcidzIEVtYmVkZGVkVmlld1JlZi5jb250ZXh0KClcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBFbWJlZGVkSXRlbVxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyAkaW1wbGljaXQ6IGFueSlcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIElucHV0LCBPbkluaXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogR2VuZXJpY0NvbnRhaW5lckNvbXBvbmVudCBpcyB1c2VkIGJ5IGluY2x1ZGUtY29tcG9uZW50LmRpcmVjdGl2ZSB0byBkeW5hbWljYWxseSBjcmVhdGUgYW5cbiAqIEhUTUxFbGVtZW50IGFuZCB1c2UgdGhpcyBlbGVtZW50IHRvIHdyYXAgYSBjaGlsZCBjb21wb25lbnQuIFRoaXMgaXMgdmVyeSB1c2VmdWwgd2hlbiB3ZSB3YW50IHRvXG4gKiBtb2RpZnkgYSBjaGlsZCBieSB3cmFwcGluZyBpdCB3aXRoIGEgYm9yZGVyLCBhIGJhY2tncm91bmQsIG9yIGJvbGQgaXRzIHRleHQuXG4gKlxuICogVGhlIHdyYXBwZXIgZWxlbWVudCBpcyBkeW5hbWljYWxseSBjcmVhdGVkLiBJdCdzIGVsZW1lbnQgaXMgc3BlY2lmaWVkIGJ5IHRoZSB0YWdOYW1lIHByb3BlcnR5IGluXG4gKiB0aGUgYmluZGluZ3MgQElucHV0LlxuICpcbiAqICAjIyMgRXhhbXBsZS4gIERpcmVjdGx5IGluIGh0bWxcbiAqXG4gKiAgIGFwcC5odG1sXG4gKiAgICAgIDxhdy1nZW5lcmljLWNvbnRhaW5lciB0YWdOYW1lPVwidGFnTmFtZVwiIGJpbmRpbmdzPVwiYmluZGluZ3NcIj5cbiAqICAgICAgICAgIDxteS1jb21wb25lbnQgLi5iaW5kaW5ncy4uPjwvbXktY29tcG9uZW50PlxuICogICAgICA8L2F3LWdlbmVyaWMtY29udGFpbmVyPlxuICpcbiAqICAgYXBwLmNvbXBvbmVudC50c1xuICpcbiAqICAgICAgIHRhZ05hbWUgPSAoYkJvbGQpID8gJ2gxJyA6ICdzcGFuJztcbiAqICAgICAgIGJpbmRpbmdzID0geyAgc3R5bGU6ICdiYWNrZ3JvdW5kLWNvbG9yOiByZWQnIH1cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZ2VuZXJpYy1jb250YWluZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PicsXG4gICAgc3R5bGVzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBEb0NoZWNrXG57XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHRhZ05hbWUgaWYgbm9uZSBpcyBzcGVjaWZpZWQgaW5zaWRlIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IERlZmF1bHRUYWdOYW1lID0gJ2Rpdic7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kaW5ncyB0byBiZSBhZGRlZCBhcyBhdHRyaWJ1dGVzIHRvIHRoZSB0YWdOYW1lIGVsZW1lbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnQgdG8gYmUgY3JlYXRlZCB0aGF0IHdyYXBzIGl0J3MgY29udGVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhZ05hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIE5hdGl2ZSByb290IGVsZW1lbnQuIFBvaW50cyB0byA8YXctZ2VuZXJpYy1jb250YWluZXI+XG4gICAgICovXG4gICAgcHJpdmF0ZSBuYXRpdmVFbGVtZW50OiBOb2RlO1xuXG4gICAgcHJpdmF0ZSBjaGlsZEVsZW1lbnQ6IE5vZGU7XG5cblxuICAgIC8qKlxuICAgICAqIHBhcmFtIHJlbmRlcmVyIC0gUmVuZGVyZXIgaXMgdXNlZCB0byBjcmVhdGUgJ3RhZ05hbWUnIGVsZW1lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICB0aGlzLm5hdGl2ZUVsZW1lbnQgPSBlbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHVyaW5nIHRoZSBpbml0aWFsaXphdGlvbiwgdmVyaWZ5IHRoYXQgYXQgbGVhc3Qgb25lIGlucHV0IGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGlucHV0LCB0aGlzIGNvbXBvbmVudCB3b3VsZG4ndCBrbm93IHdoYXQgdG8gZG8gYW5kIHRocm93IGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5iaW5kaW5ncykgJiYgaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dlbmVyaWNDb250YWluZXJDb21wb25lbnQgaW5wdXQgYmluZGluZ3Mgb3IgdGFnTmFtZSAnICtcbiAgICAgICAgICAgICAgICAnaGF2ZSBub3QgYmVlbiBzZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgdGFnTmFtZSBpcyBibGFuaywgdGhlIGdldCBpdCBmcm9tIGJpbmRpbmdzLlxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ05hbWUgPSB0aGlzLmJpbmRpbmdzLmdldCgndGFnTmFtZScpO1xuICAgICAgICAgICAgaWYgKGlzQmxhbmsodGhpcy50YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGFnTmFtZSA9IEdlbmVyaWNDb250YWluZXJDb21wb25lbnQuRGVmYXVsdFRhZ05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlIGZpcnN0IGFkZGVkXG4gICAgICAgIHRoaXMuY2hpbGRFbGVtZW50ID0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuZG9SZW5kZXIoKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY2hpbGRFbGVtZW50KSAmJlxuICAgICAgICAgICAgdGhpcy5jaGlsZEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcblxuICAgICAgICAgICAgdGhpcy5uYXRpdmVFbGVtZW50LmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBZnRlciBjb250ZW50IGhhcyBiZWVuIGluaXRpYWxpemVkLiBDcmVhdGUgdGhlIHRhZ05hbWUgZWxlbWVudC4gQXBwbHkgYWxsIHRoZSBiaW5kaW5ncyBvbiB0b1xuICAgICAqIHRoZSBlbGVtZW50IGFzIGF0dHJpYnV0ZS4gRmluYWxseSwgbW92ZSB0aGUgY2hpbGQgZWxlbWVudCwgPG5nLWNvbnRlbnQ+LCB0byBpbnNpZGUgdGhlXG4gICAgICogd3JhcHBlciBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBkb1JlbmRlcigpXG4gICAge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMucmVuZGVyZXIuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWUpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmF0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYXBwZW5kQ2hpbGQodGhpcy5uYXRpdmVFbGVtZW50LCBlbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBiaW5kaW5ncyBhbmQgYWRkIHRoZW0gdG8gdGhlIGVsZW1lbnQuXG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUodGhpcy5iaW5kaW5ncykuZm9yRWFjaCgodiwgaykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShlbCwgaywgdik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEF0dGFjaCB0aGUgY29tcG9uZW50IHRvIHRoaXMgZGl2RWxlbWVudC5cbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZEVsZW1lbnQpO1xuICAgIH1cblxuXG59XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDApXHJcbiAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XHJcbiAgICByZXN1bHQuZGVmYXVsdCA9IG1vZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtEb0NoZWNrLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgU2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FwcENvbmZpZywgRW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogIEJhc2UgY29tcG9uZW50IHNoYXJlcyBjb21tb24gZnVuY3Rpb25hbGl0eSBhbW9uZyBhbGwgdGhlIGNvbXBvbmVudHMgKGxheW91dHMsIHdpZGdldHMpLlxuICpcbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgRG9DaGVjaywgT25EZXN0cm95XG57XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGRpc2FibGVkIGZsYWcgdG8gdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAvKipcbiAgICAgKiBXZWF0aGVyIHRoaXMgY29tcG9uZW50IGlzIHZpc2libGVcbiAgICAgKiBEZWZhdWx0IGlzIGZhbHNlO1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGVsbCAgdGhlIGNvbXBvbmVudCBpZiB3ZSBhcmUgaW4gZWRpdGluZyBtb2RlLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0YWJsZT86IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogRXZlcnkgY29tcG9uZW50IGhhdmUgb3B0aW9uIHRvIHNldCBhIGN1c3RvbSB3aXRoXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHdpZHRoOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVyeSBjb21wb25lbnQgaGF2ZSBvcHRpb24gdG8gc2V0IGEgY3VzdG9tIHdpdGhcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlaWdodDogYW55O1xuXG4gICAgLyoqXG4gICAgICogb3B0aW9uYWwgY3NzIGNsYXNzIHdoaWNoIGNhbiBiZSB1dGlsaXplZCBieSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0eWxlQ2xhc3M6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcGFkZGluZyBmcm9tIHRoZSBjb21wb25lbnQuIFVzdWFsbHkgdXNlZCB3aGVuIHdlIGFyZSBuZXN0aW5nIG90aGVyIGNvbXBvbmVudCB3aXRoXG4gICAgICogaXRzIG93biBncmlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb21pdFBhZGRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGV4dGVuc2lvbiBzdXBwb3J0IHJlZ2lzdGVyIGhlcmUgYW55IGR5bmFtaWMgZmllbGQgdGhhdCBkb2VzIG5vdCBleGlzdGluZyBvbiB0aGVcbiAgICAgKiBjbGFzcy9jb21wb25lbnRcbiAgICAgKi9cbiAgICBleHRCaW5kaW5nczogTWFwPHN0cmluZywgYW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUHJlZml4IGZvciB0aGUgY29ycmVjdCBhc3NldCBwYXRoXG4gICAgICovXG4gICAgYXNzZXRGb2xkZXI6IHN0cmluZyA9ICdhc3NldHMnO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudj86IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgdGhpcy5leHRCaW5kaW5ncyA9IG5ldyBNYXA8c3RyaW5nLCBhbnk+KCk7XG4gICAgICAgIHRoaXMub21pdFBhZGRpbmcgPSBmYWxzZTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuYXNzZXRGb2xkZXIgPSB0aGlzLmVudi5nZXRWYWx1ZShBcHBDb25maWcuQXNzZXRGb2xkZXIpO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZFxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWRcbiAgICB7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50LCBub29wLCB1dWlkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Zm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFBpcGVUcmFuc2Zvcm0sIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Db250cm9sLCBGb3JtR3JvdXB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogeC1zbWFsbCA9ID4gMTIlICA9ID4gY29sLTFcbiAqIHNtYWxsID0gPiBgXG4gKiBtZWRpdW0gPSA+IDUwJSAgID0gPiBjb2wtNlxuICogbGFyZ2UgPSA+IDc1JSAgICA9ID4gY29sLTlcbiAqIGxhcmdlID0gPiAxMDAlICAgPSA+IGNvbC0xMlxuICpcbiAqL1xuZXhwb3J0IHR5cGUgV2lkZ2V0U2l6ZSA9ICd4LXNtYWxsJyB8ICdzbWFsbCcgfCAnbWVkaXVtJyB8ICdsYXJnZScgfCAneC1sYXJnZSc7XG5cbmV4cG9ydCBlbnVtIFdpZGdldFNpemVDb2x1bW5zXG57XG4gICAgeHNtYWxsID0gMSxcbiAgICBzbWFsbCA9IDMsXG4gICAgbWVkaXVtID0gNixcbiAgICBsYXJnZSA9IDksXG4gICAgeGxhcmdlID0gMTJcbn1cblxuXG4vKipcbiAqICBCYXNlRm9ybUNvbXBvbm5ldCBleHRlbmRzIEJhc2VDb21wb25lbnQgZm9yIGFkZCBzcGVjaWZpYyBmb3JtIGJlaGF2aW9yXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUZvcm1Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3JcbntcbiAgICAvKlxuICAgICAqICBTdXBwb3J0ZWQgbGF5b3V0IGNvbnN0YW50cy4gSXQgaXMgZXhwZWN0ZWQgdGhlcmUgd2lsbCBiZSBtb3JlIG9wdGlvbnMgYXMgd2UgY3VycmVudGx5XG4gICAgICogIHN1cHBvcnQgb25seSB0aGVzZSB0d28gdGhlcmUgd2lsbCBiZSBvdGhlciB2YXJpYXRpb25zIG9mIGl0LiBlLmcuIGZvciBzdGFja2VkIGl0IHdpbGwgbm90XG4gICAgICogIGJlIDEgY29sdW1ucyBsaWtlIGl0IGlzIG5vdyBidXQgbXVsdGlwbGUgY29sdW1uc1xuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlYWRvbmx5IExheW91dFN0YWNrZWQgPSAnc3RhY2tlZCc7XG4gICAgc3RhdGljIHJlYWRvbmx5IExheW91dElubGluZSA9ICdpbmxpbmUnO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgbmFtZSBhdHRyaWJ1dGUuIENhbiBiZSB1c2VkIHRvIGxvb2t1cCBjb21wb25lbnQgaW4gZm9ybS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5hbWU6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IElkLiBDYW4gYmUgdXNlZCB0byBsb29rdXAgY29tcG9uZW50IGluIGZvcm0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIElzIGN1cnJlbnQgZWxlbWVudCB2aXNpYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWRkZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFlvdSBjYW4gcGFzcyBpbiBmb3JtR3JvdXAgd2hpY2ggd2lsbCBiZSB1c2VkIHdpdGggaW4gdGhlIGZvcm1cbiAgICAgKlxuICAgICAqIEBJbnB1dCgpIC0gc2VlIGdldHRlclxuICAgICAqL1xuICAgIHByaXZhdGUgX2Zvcm1Hcm91cDogRm9ybUdyb3VwO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHJlcXVpcmVkIGZsZXggYXJvdW5kIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcmVxdWlyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogIGEgdGV4dCBkaXNwbGF5ZWQgd2hlbiB2YWx1ZSBpcyBlbXB0eSBvciBOVUxMXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwbGFjZUhvbGRlcjogU3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSBpZiB0aGlzIGNvbnRyb2wgaXMgdXNlZCBkaXJlY3RseSBvciBpZiBpdHMgcGFydCBvZiBzb21lIG90aGVyIGNvbnRyb2xcbiAgICAgKiBlLmcuIEdlbmVyaWNDaG9vc2VyIGFuZCBtYW5hZ2VkIGJ5IHRoaXMgY29udHJvbC5cbiAgICAgKiBNZWFuaW5nIFN0YXRlIGlzIG1hbmFuZ2VkIG91dHNpZGUgb2YgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNTdGFuZGFsb25lOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogRm9ybSBDb250cm9sIGZvciB0aGUgY29tcG9uZW50LiBJdHMgZWl0aGVyIGluaGVyaXRlZCBzaW5jZSBpdCB3YXMgcHJlY3JlYXRlZCBpbiBwYXJlbnRcbiAgICAgKiBjb21wb25lbnQgb3IgaXRzIGNyZWF0ZWQgYmFzZWQgb24gcGFzc2VkICduYW1lJyBhbmQgcmVnaXN0ZXJlZCB3aXRoIHRoZSAnZm9ybUdyb3VwJ1xuICAgICAqXG4gICAgICogV2hlbiAgaW5pdGlhbGl6ZSBGb3JtQ29udHJvbCB3ZSBkbyBzZXRWYWx1ZSB3aXRoIG9ubHlTZWxmOnRydWUgZmxhZyBhbmQgd2UgZG8gbm90IGVtaXQgYW55XG4gICAgICogZXZlbnQgb3V0c2lkZVxuICAgICAqXG4gICAgICovXG4gICAgZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0ZXIgdGhhdCBjYW4gYmUgYXNzaWduIHRvIHRoZSBjb21wb25lbnQgaW4gb3JkZXIgdG8gZm9ybWF0IGl0cyBpbnB1dFxuICAgICAqL1xuICAgIGZvcm1hdHRlcjogUGlwZVRyYW5zZm9ybTtcblxuXG4gICAgcHJvdGVjdGVkIG9uTW9kZWxDaGFuZ2VkOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcbiAgICBwcm90ZWN0ZWQgb25Nb2RlbFRvdWNoZWQ6IChfOiBhbnkpID0+IHZvaWQgPSBub29wO1xuXG5cbiAgICAvKipcbiAgICAgKiBTb21lIG9mIHRoZSBCYXNlRm9ybUNvbXBvbmVudCBjYW4gd3JhcCBvdGhlciBjb21wb25lbnQgYW5kIGluIHRoZXNlIGNhc2VzIHdlIHdhbnQgdG9cbiAgICAgKiBpbmhlcml0IHNvbWUgb2YgdGhlIGJlaGF2aW9yIGZyb20gcGFyZW50XG4gICAgICpcbiAgICAgKiBASW5qZWN0KEVudmlyb25tZW50KSBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCA6IGlzIHRlbSBhIHdvcmthcm91bmQgYXMgd2l0aG91dCBpbmplY3RcbiAgICAgKiBvbiB0aGlzIHNwZWNpZmljIGNvbXBvbmVudCBpdCBjb21wbGFpbnMgdGhhdCBFbnZpcm9ubWVudCBpcyB1bnJlc29sdmVkIHN5bWJvbFxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKEBJbmplY3QoRW52aXJvbm1lbnQpIHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGFyZW50Q29udGFpbmVyOiBCYXNlRm9ybUNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtR3JvdXAgPSB0aGlzLnBhcmVudENvbnRhaW5lci5mb3JtR3JvdXA7XG4gICAgICAgICAgICB0aGlzLmVkaXRhYmxlID0gdGhpcy5wYXJlbnRDb250YWluZXIuZWRpdGFibGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoZWNrSW5pdEZvcm0oKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYXZhaWxhYmxlIGZvcm1Hcm91cCBhbmQgTmFtZSBhbmQgSURcbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjaGVja0luaXRGb3JtICgpXG4gICAge1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZW52LmN1cnJlbnRGb3JtKSkge1xuICAgICAgICAgICAgdGhpcy5lbnYuY3VycmVudEZvcm0gPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2RvOiBSaWdodCBub3cgSSBqdXN0IG5lZWQgdG8gaW5pdGlhbGl6ZSBuYW1lICwgYnV0IGlkZWFsbHkgaXQgbmVlZHMgdG8gYmUgZ2VuZXJhdGVkXG4gICAgICAgICAqIG51bWJlciBiYXNlZG9uIHNvbWUgc2VtYW50aWNzIGFwcC5wYWdlLmNvbXBvbmVudCBpZiB0aGVyZSBhcmUgbW9yZSBjb21wb25lbnQgb24gdGhlIHBhZ2VcbiAgICAgICAgICogdGhlbiBhcHAucGFnZS5jb21wb25lbnROdW1iZXIuIFNpbXBsZSBzb2x1dGlvbiBpcyB0byBpcyB0byBnZXQgRWxlbWVudHJlZiBhbmQgcXVlcnkgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB1dWlkKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmlkKSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHV1aWQoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGRvUmVnaXN0ZXIgKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSk6IEZvcm1Db250cm9sXG4gICAge1xuXG4gICAgICAgIGxldCBmQ29udHJvbDogRm9ybUNvbnRyb2w7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV0pKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Hcm91cC5yZWdpc3RlckNvbnRyb2wobmFtZSwgbmV3IEZvcm1Db250cm9sKHZhbHVlKSk7XG4gICAgICAgICAgICBmQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbbmFtZV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZDb250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1tuYW1lXTtcbiAgICAgICAgICAgIGxldCB1cGRhdGVkVmFsdWU6IGFueSA9IGlzUHJlc2VudChmQ29udHJvbC52YWx1ZSkgPyBmQ29udHJvbC52YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgZkNvbnRyb2wucGF0Y2hWYWx1ZSh1cGRhdGVkVmFsdWUsIHtvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmQ29udHJvbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBGb3JtcyB0aGlzIGlzIGEgaGVscGVyIG1ldGhvZCB0byByZWdpc3RlciBjb250cm9sXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBkZWZhdWx0IHZhbHVlIHRvIGJlIHByZS1zZXRcbiAgICAgKi9cbiAgICByZWdpc3RlckZvcm1Db250cm9sICh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IHRoaXMuZG9SZWdpc3Rlcih0aGlzLm5hbWUsIHZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIEBJbnB1dCgpIGdldCBmb3JtR3JvdXAgKCk6IEZvcm1Hcm91cFxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLl9mb3JtR3JvdXApID8gdGhpcy5fZm9ybUdyb3VwIDogdGhpcy5lbnYuY3VycmVudEZvcm07XG4gICAgfVxuXG4gICAgc2V0IGZvcm1Hcm91cCAodmFsdWU6IEZvcm1Hcm91cClcbiAgICB7XG4gICAgICAgIHRoaXMuX2Zvcm1Hcm91cCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB3ZSBjYW4gcGFzcyBmaWVsZCB0eXBlIGFzIGEgYmluZGluZyB0byB0aGUgY29tcG9uZW50cy4gZS5nLiBJbnB1dEZpZWxkIG5lZWRcbiAgICAgKiBzdWNoIHR5cGUgdG8gY29ycmVjdGx5IHJlbmRlciBpbnB1dCB0eXBlPXRleHQsIG51bWJlclxuICAgICAqXG4gICAgICogdG9kbzogaXMgdGhpcyBuZWVkZWQ/IGNhbiB3ZSBtYXliZSBwYXNzIHRoaXMgdG8gdGhlIGZvcm1Sb3c/XG4gICAgICovXG4gICAgY2FuU2V0VHlwZSAoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgd3JpdGVWYWx1ZSAodmFsdWU6IGFueSlcbiAgICB7XG5cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlIChmbjogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkIChmbjogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vbk1vZGVsVG91Y2hlZCA9IGZuO1xuICAgIH1cbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEb21TYW5pdGl6ZXJ9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU2ltcGxlIGNvbXBvbmVudCByZW5kZXJpbmcgdmFsdWVzIGluIHRoZSByZWFkIG9ubHkgbW9kZS4gSnVzdCBuZWVkZWQgc29tZSBjb21wb25lbnQgdXNlZFxuICogdG8gcmVuZGVyIFN0cmluZ3MgaW4gcmVhZCBvbmx5IG1vZGVcbiAqXG4gKlxuICogICMjIyBFeGFtcGxlXG4gKlxuICogVXNpbmcgaXQgaW5zaWRlIGZvcm0gY29udGFpbmVyIGFsb25nIHdpdGggbGFiZWxcbiAqXG4gKlxuICogIGBgYFxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgc2VsZWN0b3I6ICd1c2VySW5mbycgLFxuICogICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS10YWJsZSBbZWRpdGFibGVdPVwiZmFsc2VcIiA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtuYW1lXT1cImZpZWxkTmFtZVwiICBbbGFiZWxdPVwibGFiZWxcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0cmluZyBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiID48L2F3LXN0cmluZz5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS10YWJsZT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqICAgICAgICAgIH0pXG4gKiAgICAgICAgICBleHBvcnQgY2xhc3MgVXNlclByb2ZpbGVDb21wb25lbnRcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBzdHJpbmcgPSAnU29tZSB0ZXh0JztcbiAqICAgICAgICAgICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogICAgICAgICAgICAgIGZpZWxkTmFtZTogc3RyaW5nID0gJ2ZpcnN0TmFtZSc7XG4gKiAgICAgICAgICAgICAgbGFiZWw6IHN0cmluZyA9ICdNeSBOYW1lJztcbiAqICAgICAgICAgICAgICByZXF1aXJlZDogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgICAgICAgICAgZWRpdGluZzogYm9vbGVhbiA9IHRydWU7XG4gKiAgICAgICAgICAgICAgbGFiZWxzT25Ub3A6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICB9XG4gKlxuICogIGBgYFxuICpcbiAqIFlvdSBjYW4gYWxzbyBwYXNzIGh0bWwgdGFncy5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc3RyaW5nJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8c3BhbiBjbGFzcz1cInctc3RyaW5nLWZpZWxkXCIgW2lubmVySFRNTF09XCJ2YWx1ZVwiPjwvc3Bhbj5cbiAgICBgLFxuICAgIHN0eWxlczogW2Audy1zdHJpbmctZmllbGR7ZGlzcGxheTppbmxpbmUtYmxvY2t9YF1cbn0pXG5leHBvcnQgY2xhc3MgU3RyaW5nQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiAgVmFsdWUgdG8gYmUgaW50ZXJwb2xhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIF92YWx1ZTogc3RyaW5nID0gJyc7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIHNhbml0aXplcjogRG9tU2FuaXRpemVyLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG5cbiAgICB9XG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0SHRtbCh0aGlzLl92YWx1ZSk7XG4gICAgfVxufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzU3RyaW5nTWFwfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIEEgY2xhc3MgaG9sZGluZyBhIHJlZmVyZW5jZXMgdG8gY29tcG9uZW50cy4gVGhlIG1ldGhvZHMgYXJlIHNlbGYtZXhwbGFuYXRvcnkuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50UmVnaXN0cnlcbntcbiAgICBwcml2YXRlIF9uYW1lVG9UeXBlOiBNYXA8c3RyaW5nLCBhbnk+ID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBpbml0aWFsaXplKHJlZmVyZW5jZXM6IGFueSk6IFByb21pc2U8YW55PlxuICAgIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlclR5cGVzKHJlZmVyZW5jZXMpO1xuICAgICAgICBsZXQgcHJvbWlzZTogUHJvbWlzZTxhbnk+ID0gbmV3IFByb21pc2UoKHJlc29sdmU6IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuXG4gICAgfVxuXG5cbiAgICByZWdpc3RlclR5cGUobmFtZTogc3RyaW5nLCB0eXBlOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMubmFtZVRvVHlwZS5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX25hbWVUb1R5cGUuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICByZWdpc3RlclR5cGVzKHJlZmVyZW5jZXM6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICghaXNTdHJpbmdNYXAocmVmZXJlbmNlcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKHJlZmVyZW5jZXMpLmZvckVhY2goKG5hbWU6IHN0cmluZykgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlclR5cGUobmFtZSwgcmVmZXJlbmNlc1tuYW1lXSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgZ2V0IG5hbWVUb1R5cGUoKTogTWFwPHN0cmluZywgYW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWVUb1R5cGU7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbXBvbmVudEZhY3RvcnksXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgIENvbXBvbmVudFJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgSW5wdXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgU2ltcGxlQ2hhbmdlcyxcbiAgICBWaWV3Q29udGFpbmVyUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIGlzQmxhbmssIGlzUHJlc2VudCwgTWFwV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1N0cmluZ0NvbXBvbmVudH0gZnJvbSAnLi4vd2lkZ2V0cy9zdHJpbmcvc3RyaW5nLmNvbXBvbmVudCc7XG5pbXBvcnQge0NvbXBvbmVudFJlZmVyZW5jZX0gZnJvbSAnLi9jb21wb25lbnQtcmVmZXJlbmNlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4vY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG4vKipcbiAqIHRoaXMgaXMgc3BlY2lmaWMgaW1wb3J0IHRvIHdlIGNhbiB1c2UgY29tcG9uZW50cyBhcyBjb21wb25lbnRzW3R5cGVuYW1lXSBhbmQgIGdldCBiYWNrIGFcbiAqIHR5cGUuXG4gKiBJIGNvdWxkIG5vdCBmaW5kIGFueSBiZXR0ZXIgZHluYW1pYyB3YXkgdXAgdG8gbm93XG4gKi9cbi8qKlxuICogIGBJbmNsdWRlQ29tcG9uZW50YCBkaXJlY3RpdmUgZHluYW1pY2FsbHkgaW5zdGFudGlhdGUgYW5kIGluc2VydCBhIGNvbXBvbmVudHMgaW50byB0aGUgc2NyZWVuXG4gKiBiYXNlZCBvbiB0aGUgbmFtZS4gSXQgY2FuIGFjY2VwdHMgYmluZGluZ3MgYXMgd2VsbCB3aGljaCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgYm91bmQgYW5kIGFwcGxpZWRcbiAqIHRvIHRoZSBjb21wb25lbnRcbiAqXG4gKiAgIyMjIHVzYWdlOlxuICpcbiAqICBJbnN0ZWFkIG9mIGluc2VydGluZyBjb21wb25lbnQgaW4gdGhlIHdheTpcbiAqXG4gKiAgYGBgXG4gKiAgICA8dGV4dGZpZWxkIHZhbHVlPVwic29tZSB2YWx1ZVwiPlxuICpcbiAqICBgYGBcbiAqXG4gKiAgeW91IGNhbiBkbyBzbyBkeW5hbWljYWxseSBsaWtlIHRoaXM6XG4gKlxuICogYGBgXG4gKiAgPGF3LWluY2x1ZGUtY29tcG9uZW50ICdUZXh0ZmllbGRDb21wb25lbnQnIFtiaW5kaW5nc109YmluZGluZ3MgPjwvYXctaW5jbHVkZS1jb21wb25lbnQ+XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGlzIHRoZSBtYWluIGJ1aWxkaW5nIGJsb2NrIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlZCBVSS5cbiAqXG4gKlxuICogVG9kbzogQ3VycmVudGx5IHRoZSB3YXkgQW5ndWxhciBBUEkgd29yayBhbmQgd2UgdXNlIGl0IHRvIGNyZWF0ZSBwcm9ncmFtYXRpY2FsbHkgY29tcG9uZW50c1xuICogaXMgdG9vIGNvbXBsZXh0IHdlIG5lZWQgdG8gY3JlYXRlIGV2ZXJ5dGhpbmcgMyBkaWZmZXJlbnQgY2FsbHMgdG8gcGxhY2UgYSBjb21wb25lbnQgdG8gdGhlXG4gKiBjb250YWluZXIuIFdoYXQgSSB3YW50IGlzIGlzIHRvIGNyZWF0ZSBzb21lIGtpbmQgb2YgcmVwcmVzZW50YXRpb24gb2YgQ29udGFpbmVyRWxlbWVudCBhbmQgdGhpc1xuICogY2FuIGJlIGFsc28gcGFyZW50IGZvciBvdXIgQmFzZUNvbXBvbmVudCB3aXRoIG1ldGhvZCBhZGQgYW5kIHJlbW92ZSBjb250ZW50LiBUaGVuIHdlIGNvdWxkIGhhdmVcbiAqIHNvbWUgQVdDb250ZW50LlxuICpcbiAqIGUuZy46IHRvIHJlcGxhY2UgYXBwbHlDb250ZW50RWxlbWVudElmQW55IHdoZXJlIHdlIGhhdmUgc2V2ZXJhbCBjYWxscyB0byBjcmVhdGUgYW5kIGFkZFxuICogY29tcG9uZW50IHRvIHRoZSB2aWV3LlxuICpcbiAqIGBgYHRzXG4gKiAgbGV0IGNvbnRhaW5lckVsZW1lbnQgPSBBV0NvbmNyZXRlVGVtcGxhdGUodmlld0NvbnRhaW5lciwgZmFjdG9yeVJlc29sdmVyKVxuICogIGNvbnRhaW5lckVsZW1lbnQuYWRkKCdDbGNrIE1lJylcbiAqIGBgYFxuICpcbiAqIFRvIGFzc2VtYmxlIGRpZmZlcmVudCBjb21wb25lbnRzIHRvZ2V0aGVyIC0gbm90IG9ubHkgYWRkaW5nIHN0cmluZyBjb250ZW50XG4gKlxuICogYGBgdHNcbiAqICBsZXQgY29udGVudCA9IG5ldyBBV0NvbnRlbnQoQnV0dG9uQ29tcG9uZW50LCBiaW5kaW5nc01hcClcbiAqICBjb250ZW50LmFkZCgnQ2xpY2sgTWUnKTtcbiAqICBjb250YWluZXJFbGVtZW50LmFkZChjb250ZW50KVxuICpcbiAqIGBgYFxuICpcbiAqIGFkZCBtb3JlIGNvbXBvbmVudCBoaWVyYXJjaHk6XG4gKlxuICogYGBgdHNcbiAqICBsZXQgY29udGVudCA9IG5ldyBBV0NvbnRlbnQoSG92ZXJDYXJkQ29tcG9ubmV0cywgYmluZGluZ3NNYXApXG4gKiAgY29udGVudC5hZGQoY3JlYXRlTGF5b3V0KCk7XG4gKiAgY29udGFpbmVyRWxlbWVudC5hZGQoY29udGVudClcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnYXctaW5jbHVkZS1jb21wb25lbnQnXG59KVxuZXhwb3J0IGNsYXNzIEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZCxcbiAgICBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIHN0YXRpYyByZWFkb25seSBOZ0NvbnRlbnQgPSAnbmdjb250ZW50JztcbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdDb250ZW50RWxlbWVudCA9ICduZ2NvbnRlbnRFbGVtZW50JztcblxuICAgIC8qKlxuICAgICAqIEZ1bGwgY29tcG9uZW50IG5hbWUgZS5nLjogRHJvcGRvd25Db21wb25lbnQgd2hpY2ggaXMgZ29pbmcgdG8gYmUgaW5zZXJ0ZWQuIFdlIG5lZWQgdG8gdGFrZVxuICAgICAqIHRoaXMgbmFtZSBhbmQgdHJhbnNsYXRlIGl0IGludG8gYWN0dWFsIFRZUEUuIEluIG9yZGVyIHRvIGRvIHRoaXMgd2UgdXNlIGEgdHJpY2sgd2hlcmUgd2VcbiAgICAgKiBhY2Nlc3MgYW4gSU1QT1JURUQgY29tcG9uZW50cy5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi4vY29tcG9uZW50cyc7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGVuIHlvdSBjYW4gcmV0cmlldmUgYSB0eXBlIGJ5IGp1c3QgY29tcG9uZW50c1s8U3RyaW5nIExpdGVyYWwgPl0gPT4gQ29tcG9uZW50IFRZUEVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGJpbmRpbmdzIHdoaWNoIHdpbGwgYmUgcGFzc2VkIGludG8gdGhlIGNvbXBvbmVudCB3aGVuIGluc3RhbnRpYXRlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIGJpbmRpbmdzOiBNYXA8c3RyaW5nLCBhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBjcmVhdGVkIGNvbXBvbmVudCByZWZlcmVuY2UgdXNpbmcgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLiBXZSB1c2UgdGhpcyB0byBhY2Nlc3NcbiAgICAgKiB0aGUgYWN0dWFsIGNvbXBvbmVudCBpbnN0YW5jZSBhbmQgRWxlbWVudCBSZWZlcmVuY2VcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3VycmVudENvbXBvbmVudDogQ29tcG9uZW50UmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBJIHVzZSB0aGlzIGZsYWcgdG8gaWRlbnRpZnkgdGhhdCBjb21wb25lbnQgaXMgcmVuZGVyaW5nIGZvciBmaXJzdCB0aW1lIG9yIGl0cyB1cGRhdGVkIGR1cmluZ1xuICAgICAqIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0UmVuZGVySW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTm90IHN1cmUgaWYgd2UgbmVlZCB0aGlzLCBidXQgd2FudCB0byBrZWVwIGl0IGhlcmUgb3IgbWF5YmUgbW92ZSBpdCB0byBzb21lIHNlcnZpY2Ugc28gd2VcbiAgICAgKiBjYW4gY2FjaGUgY3JlYXRlZCBjb21wb25lbnRzIGFuZCBtYXliZSByZXVzZSB0aGVtLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNvbXBvbmVudFJlZmVyZW5jZXM6IE1hcDxzdHJpbmcsIENvbXBvbmVudFJlZmVyZW5jZT4gPVxuICAgICAgICBuZXcgTWFwPHN0cmluZywgQ29tcG9uZW50UmVmZXJlbmNlPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBOZWVkIHRvIGNhY2hlIHRoZSByZXNvbHZlZCBjb21wb25lbnQgcmVmZXJlbmNlIHNvIHdlIGRvbnQgY2FsbCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiBldmVyeXRoaW5nIHdlIHdhbnQgdG8gcmVmcmVzaCBhIHNjcmVlblxuICAgICAqL1xuICAgIHJlc29sdmVkQ29tcG9uZW50UmVmOiBDb21wb25lbnRSZWZlcmVuY2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBmYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgICAgICAgICBwdWJsaWMgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBjb21wUmVnaXN0cnk6IENvbXBvbmVudFJlZ2lzdHJ5KVxuICAgIHtcblxuICAgICAgICB0aGlzLmJpbmRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuXG4gICAgICAgIHRoaXMuaW5pdFJlbmRlckluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyB0b2RvOiBjaGVjayBpZiB0aGlzIHRoZSByaWdodCBsaWZlY3ljbGUgY2FsbGJhY2ssIHRoaXMgaXMgY2FsbGVkIG9ubHkgb25jZSBhbmQgeW91IHdhbnRcbiAgICAgICAgLy8gdG8gcHJvYmFibHkgbGlzdGVuIGZvciBjaGFuZ2VzLCBhbmQgY2hhbmdlIGRlY3Rpb24gZGVjaWRlIHRoZXJlIGlzIHNvbWUgY2hhbmdlIGFuZCB3ZVxuICAgICAgICAvLyBuZWVkIHRvIHJlLWRyYXcgdGhlIHZpZXdcbiAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZG9SZW5kZXJDb21wb25lbnQoKTtcbiAgICB9XG5cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KGNoYW5nZXNbJ25hbWUnXSkgJiZcbiAgICAgICAgICAgIChjaGFuZ2VzWyduYW1lJ10uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzWyduYW1lJ10ucHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5kb1JlbmRlckNvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVySW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBhbmQgcmVwb3NpdGlvbiBET00gZWxlbWVudCBib3RoIGZvciB3cmFwcGVyIGFuZFxuICAgICAgICAvLyBjb250ZW50XG4gICAgICAgIHRoaXMuY3JlYXRlV3JhcHBlckVsZW1lbnRJZkFueSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKTtcbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gcmVzb2x2ZSBhZGRpdGlvbmFsIGNvbXBvbmVudCBhbmQgd3JhcCB0aGUgY3VycmVudCBvbmUuXG4gICAgICogSnVzdCBsaWtlIHJlYXRlQ29udGVudEVsZW1lbnRJZkFueSgpIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGFsbFxuICAgICAqIGlzIGNyZWF0ZWQgYW5kIGluaXRpYWxpemVkIChpbnNpZGUgdGhlIG5nQWZ0ZXJWaWV3SW5pdCgpIClcbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBjcmVhdGVXcmFwcGVyRWxlbWVudElmQW55KCk6IHZvaWRcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGNvbXBvbmVudCBpbnRvIGFjdHVhbCBWaWV3IENvbnRhaW5lci4gVGhlIHByb2Nlc3MgZ29lcyBhcyB0aGlzLlxuICAgICAqICAxLiBXZSByZXRyaWV2ZSBjb21wb25lbnQgVHlwZSBiYXNlZCBvbiB0aGUgY29tcG9uZW50IG5hbWUsIHdoaWNoIGNyZWF0ZXMgY29tcG9uZW50UmVmXG4gICAgICogIDIuIFBsYWNlIHRoZSBjb21wb25lbnQgb250byB0aGUgc2NyZWVuXG4gICAgICogIDMuIFJlYWQgY29tcG9uZW50IG1ldGFkYXRhLCBtYWlubHkgSU5QVVRzIGFuZCBhcHBseSBiaW5kaW5ncyBmb3IgZWFjaCBvZiB0aGVtXG4gICAgICogIDQuIE1hbnVhbGx5IHNwaW4gY2hhbmdlIGRldGVjdGlvbiB0byB1cGRhdGUgdGhlIHNjcmVlbi4gTWFpbmx5IGZvciBjYXNlIHdoZXJlIEkgbmVlZCB0b1xuICAgICAqIHJlZHJhdyBhIHNjcmVlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkb1JlbmRlckNvbXBvbmVudCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBsYWNlVGhlQ29tcG9uZW50KCk7XG4gICAgICAgIC8vIHRoaXMuY3VycmVudENvbXBvbmVudC5jaGFuZ2VEZXRlY3RvclJlZi5kZXRhY2goKTtcblxuICAgICAgICB0aGlzLmFwcGx5QmluZGluZ3ModGhpcy5jb21wb25lbnRSZWZlcmVuY2UoKSwgdGhpcy5jdXJyZW50Q29tcG9uZW50LCB0aGlzLmJpbmRpbmdzKTtcbiAgICAgICAgLy8gdGhpcy5jdXJyZW50Q29tcG9uZW50LmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcblxuICAgICAgICAvLyBTdGlsbCBub3Qgc3VyZSBhYm91dCB0aGlzIHdoYXQgYWxsIEkgc2hvdWxkIHJlbGVhc2UgaGVyZS5cbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcG9uZW50Lm9uRGVzdHJveSgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzLmJpbmRpbmdzLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyB0aGlzLmJpbmRpbmdzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoaXMuY29tcG9uZW50UmVmZXJlbmNlcy5jbGVhcigpO1xuICAgICAgICAgICAgLy8gdGhpcy5jb21wb25lbnRSZWZlcmVuY2VzID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBQbGFjZSBhY3R1YWwgY29tcG9uZW50IG9udG8gdGhlIHNjcmVlbiB1c2luZyBWaWV3Q29udGFpbmVyUmVmXG4gICAgICpcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgcGxhY2VUaGVDb21wb25lbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHJlZmVyZW5jZSA9IHRoaXMuY29tcG9uZW50UmVmZXJlbmNlKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IHRoaXMudmlld0NvbnRhaW5lci5jcmVhdGVDb21wb25lbnQocmVmZXJlbmNlLnJlc29sdmVkQ29tcEZhY3RvcnkpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbnNlcnRpbmcgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gaGF2ZSBhIGNvbnRlbnQgbGlrZSBlLmcuIGh5cGVybGluayBvciBidXR0b25cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgPGJ1dHRvbj4gTVkgTkcgQ09OVEVOVCA8L2J1dHRvbj5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICB0aGlzIG1ldGhvZCBhcHBsaWVzIGFuZCBpbnNlcnQgYSBjaGlsZCBjb250ZW50IGludG8gdGhlIG1haW4gY29tcG9uZW50LiBUaGlzIG1ldGhvZCBpbnNlcnRcbiAgICAgKiBhIHNpbXBsZSBzdHJpbmcuIFdlIGFyZSBub3Qgd3JhcHBpbmcgZXhpc3RpbmcgY29tcG9uZW50IHdpdGggYW5vdGhlciBjb21wb25lbnQgaGVyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gbmVlZCB0byBydW4gZGV0ZWN0IGNoYW5nZXMgPyBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNyZWF0ZUNvbnRlbnRFbGVtZW50SWZBbnkoKTogYm9vbGVhblxuICAgIHtcblxuICAgICAgICBsZXQgZGV0ZWN0Q2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBsZXQgbmdDb250ZW50ID0gdGhpcy5uZ0NvbnRlbnQoKTtcbiAgICAgICAgbGV0IG5nQ29udGVudEVsZW1lbnQgPSB0aGlzLm5nQ29udGVudEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChuZ0NvbnRlbnQpKSB7XG4gICAgICAgICAgICBsZXQgYXdDb250ZW50Q29tcG9uZW50ID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoU3RyaW5nQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnQgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGF3Q29udGVudENvbXBvbmVudCwgMCk7XG5cbiAgICAgICAgICAgICg8U3RyaW5nQ29tcG9uZW50PmNvbXBvbmVudC5pbnN0YW5jZSkudmFsdWUgPSBuZ0NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgYXdDb250ZW50Q29udGFpbmVyID0gdGhpcy5jdXJyZW50Q29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGF3Q29udGVudENvbnRhaW5lci5hcHBlbmRDaGlsZChjb21wb25lbnQubG9jYXRpb24ubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIGRldGVjdENoYW5nZXMgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudChuZ0NvbnRlbnRFbGVtZW50KSkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbnRlbnQgRWxlbWVudDogJywgbmdDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGV0ZWN0Q2hhbmdlcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0cmlldmUgYSBORyBDb250ZW50IGZyb20gYmluZGluZyBsaXN0IGFuZCByZW1vdmUgaXQgc28gaXQgaXRzIG5vdCBwcmVwYWdhdGVkIGRvd24gd2hlblxuICAgICAqIGFwcGx5aW5nIG90aGVyIGJpbmRpbmdzLlxuICAgICAqXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG5nQ29udGVudCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCBjb250ZW50OiBhbnk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29udGVudCA9IHRoaXMuYmluZGluZ3MuZ2V0KEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MuZGVsZXRlKEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG5cblxuICAgIHByb3RlY3RlZCBuZ0NvbnRlbnRFbGVtZW50KCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IGNvbnRlbnQ6IGFueTtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjb250ZW50ID0gdGhpcy5iaW5kaW5ncy5nZXQoSW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZS5OZ0NvbnRlbnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3MuZGVsZXRlKEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUuTmdDb250ZW50RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBjb252ZXJ0IGEgY29tcG9uZW50IG5hbWUgdG8gYWN0dWFsIGEgdHlwZSBhbmQgdGhlbiB1c2UgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG4gICAgICogdG8gaW5zdGFudGlhdGUgYSBhIGNvbXBvbmVudCBhbmQgc2F2ZSBpdHMgaW5mb3JtYXRpb24gaW50byBvdXIgY29tcG9uZW50IHJlZmVyZW5jZXMuIFRoZVxuICAgICAqIHJlYXNvbiB3aHkgd2UgaGF2ZSB0aGlzIGNvbXBvbmVudCByZWZlcmVuY2UgaXMgd2UgbmVlZCB0byBzdG9yZSBBbmd1bGFyJ3MgY29tcG9uZW50IG1ldGFkYXRhXG4gICAgICogc28gd2UgY2FuIGl0ZXJhdGUgdGhydSBhbGwgdGhlIGlucHV0cyBhbmQgYmluZCB0aGVtIHRvIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogcmV0dXJucyB7Q29tcG9uZW50UmVmZXJlbmNlfSBhIHJlZmVyZW5jZSByZXByZXNlbnRpbmcgYSBjb21wb2VudCBjdXJyZW50bHkgYmVpbmcgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY29tcG9uZW50UmVmZXJlbmNlKCk6IENvbXBvbmVudFJlZmVyZW5jZVxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRDb21wb25lbnRSZWY7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJUeXBlID0gdGhpcy5yZXNvbHZlQ29tcG9uZW50VHlwZSgpO1xuICAgICAgICBsZXQgY29tcG9uZW50RmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+ID0gdGhpcy5mYWN0b3J5UmVzb2x2ZXJcbiAgICAgICAgICAgIC5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjdXJyVHlwZSk7XG5cbiAgICAgICAgbGV0IGNvbXBvbmVudE1ldGE6IENvbXBvbmVudCA9IHRoaXMucmVzb2x2ZURpcmVjdGl2ZShjb21wb25lbnRGYWN0b3J5KTtcbiAgICAgICAgbGV0IGNvbXBSZWZlcmVuY2U6IENvbXBvbmVudFJlZmVyZW5jZSA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjb21wb25lbnRNZXRhLFxuICAgICAgICAgICAgcmVzb2x2ZWRDb21wRmFjdG9yeTogY29tcG9uZW50RmFjdG9yeSxcbiAgICAgICAgICAgIGNvbXBvbmVudFR5cGU6IGN1cnJUeXBlLFxuICAgICAgICAgICAgY29tcG9uZW50TmFtZTogdGhpcy5uYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXNvbHZlZENvbXBvbmVudFJlZiA9IGNvbXBSZWZlcmVuY2U7XG4gICAgICAgIHJldHVybiBjb21wUmVmZXJlbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIHRocnUgQ29tcG9uZW50TWV0YWRhdGEgQElucHV0cygpIGFuZCBjaGVjayBpZiB3ZSBoYXZlIGF2YWlsYWJsZSBiaW5kaW5nIGluc2lkZSB0aGVcbiAgICAgKiAndGhpcy5iaW5kaW5ncydcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYXBwbHlCaW5kaW5ncyhjUmVmOiBDb21wb25lbnRSZWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBDb21wb25lbnRSZWY8YW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nczogTWFwPHN0cmluZywgYW55Pik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBpbnB1dHM6IHN0cmluZ1tdID0gY1JlZi5tZXRhZGF0YS5pbnB1dHM7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoaW5wdXRzKSB8fCBpbnB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2hvdWxkIHdlIGRvIGFueSB0eXBlIGNvbnZlcnNpb24/XG4gICAgICAgIE1hcFdyYXBwZXIuaXRlcmFibGUoYmluZGluZ3MpLmZvckVhY2goKHYsIGspID0+XG4gICAgICAgIHtcblxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjb21wb25lbnQuaW5zdGFuY2Vba10pKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIGNvbXBvbmVudCBUeXBlIGJhc2VkIG9uIHRoZSBzdHJpbmcgbGl0ZXJhbFxuICAgICAqXG4gICAgICogQHJldHVybnMgY29tcG9uZW50IHR5cGUgdXNlZCBieSBgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyYFxuICAgICAqXG4gICAgICogdG9kbzogcmVuYW1lIHRoZSBtZXRob2Qgc28gaXRzIGNsZWFyIHRoYXQgaXQgcmV0dXJucyBjb21wb25lbnQgdHlwZSBiYXNlZCBvbiBzdHJpbmcuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlc29sdmVDb21wb25lbnRUeXBlKCk6IGFueVxuICAgIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudFR5cGUgPSB0aGlzLmNvbXBSZWdpc3RyeS5uYW1lVG9UeXBlLmdldCh0aGlzLm5hbWUpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGNvbXBvbmVudFR5cGUpKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UsIHRoaXMubmFtZSArICcgY29tcG9uZW50IGRvZXMgbm90IGV4aXN0cy4gQ3JlYXRlIER1bW15IENvbXBvbmVudCBpbnN0ZWFkJyArXG4gICAgICAgICAgICAgICAgJyBvZiB0aHJvd2luZyB0aGlzIGVycm9yJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFR5cGU7XG4gICAgfVxuXG5cbiAgICBwcm90ZWN0ZWQgcmVzb2x2ZURpcmVjdGl2ZShjb21wRmFjdG9yeTogQ29tcG9uZW50RmFjdG9yeTxhbnk+KTogQ29tcG9uZW50XG4gICAge1xuICAgICAgICBsZXQgY29tcE1ldGE6IENvbXBvbmVudCA9IHtcbiAgICAgICAgICAgIGlucHV0czogW10sXG4gICAgICAgICAgICBvdXRwdXRzOiBbXVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY29tcEZhY3RvcnkuaW5wdXRzKSAmJiBjb21wRmFjdG9yeS5pbnB1dHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBjb21wRmFjdG9yeS5pbnB1dHMuZm9yRWFjaCgoaW5wdXQ6IHtwcm9wTmFtZTogc3RyaW5nLCB0ZW1wbGF0ZU5hbWU6IHN0cmluZ30pID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29tcE1ldGEuaW5wdXRzLnB1c2goaW5wdXQucHJvcE5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KGNvbXBGYWN0b3J5Lm91dHB1dHMpICYmIGNvbXBGYWN0b3J5Lm91dHB1dHMubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBjb21wRmFjdG9yeS5vdXRwdXRzLmZvckVhY2goKG91dHB1dDoge3Byb3BOYW1lOiBzdHJpbmcsIHRlbXBsYXRlTmFtZTogc3RyaW5nfSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb21wTWV0YS5vdXRwdXRzLnB1c2gob3V0cHV0LnByb3BOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wTWV0YTtcbiAgICB9XG5cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jdXJyZW50Q29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy52aWV3Q29udGFpbmVyKSkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHByaXZhdGUgZGVzdHJveSgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VycmVudENvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkQ29tcG9uZW50UmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7U3RyaW5nV3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogRXJyb3IgTWFuYWdlciBpcyBhIHNlcnZpY2UgdXNlZCBieSBGb3JtcyBjb21wb25lbnRzIHRvIG1hcCBlcnJvciBjb2RlcyBpbnRvIG1lYW5pbmdmdWwgbWVzc2FnZXMuXG4gKiBDdXJyZW50bHkgaXQgZG9lcyBub3QgaGF2ZSBtdWNoIGJ1dCBvbmNlIHdlIHBsdWcgaW4gbG9jYWxpemF0aW9uIGl0IHdpbGwgbWFrZSBtb3JlIHNlbnNlXG4gKlxuICpcbiAqIHRvZG86IE9uY2UgbmctdHJhbnNsYXRlIGlzIGltcGxlbWVudGVkIHJlcGxhY2UgdGhpcyB3aXRoIG5nLXRyYW5zbGF0ZSBmdW5jdGlvbmFsaXR5IHNvIHdlIGNhblxuICogZXh0ZXJuYWxpemUgdGhlc2UgbWVzc2FnZXMgaW50byBsb2NhbGUgZmlsZXMuXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRXJyb3JNYW5hZ2VyU2VydmljZVxue1xuICAgIG1lc3NhZ2VzOiB7W2tleTogc3RyaW5nXTogYW55fTtcblxuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSB7XG4gICAgICAgICAgICAncmVxdWlyZWQnOiAnUmVxdWlyZWQgZmllbGQnLFxuICAgICAgICAgICAgJ21pbmxlbmd0aCc6ICdGaWVsZCBkb2VzIG5vdCBtZWV0IG1pbmltdW0gbGVuZ3RoJyxcbiAgICAgICAgICAgICdtYXhsZW5ndGgnOiAnRmllbGQgZG9lcyBub3QgbWVldCBtYXhpbXVtIGxlbmd0aCcsXG4gICAgICAgICAgICAnY3VzdG9tTXNnJzogJyVzJyxcbiAgICAgICAgICAgICdtZXRhdmFsaWQnOiAnJXMnXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICBlcnJvck1lc3NhZ2UodmFsaWRhdG9yTmFtZTogc3RyaW5nLCB2YWxpZGF0b3JWYWx1ZT86IGFueSlcbiAgICB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1t2YWxpZGF0b3JOYW1lXTtcbiAgICAgICAgaWYgKFN0cmluZ1dyYXBwZXIuY29udGFpbnMobWVzc2FnZSwgJyVzJykpIHtcbiAgICAgICAgICAgIC8vIHRvZG86IHVzZSBuZy10cmFuc2xhdGUgd2l0aCBwcm9wZXIgbWVzc2FnZSBmb3JtYXR0aW5nXG5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmdXcmFwcGVyLnJlcGxhY2UobWVzc2FnZSwgJyVzJywgdmFsaWRhdG9yVmFsdWUubXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkluaXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuLi8uLi9jb3JlL2Vycm9yLW1hbmFnZXIuc2VydmljZSc7XG5cbi8qKlxuICogRXJyb3JNZXNzYWdlc0NvbXBvbmVudCBpcyB1c2VkIGJ5IGZvcm0ncyBjb21wb25lbnQgbGlrZSBGb3JtUm93IHRvIHByaW50IGl0cyB2YWxpZGF0aW9uIGVycm9ycy5cbiAqIEl0cyAgYmFzZWQgb24gTW9kZWxEcml2ZW4gKFJlYWN0aXZlIGZvcm1zKSBhbmQgaXQgcmVhZHMgZXJyb3JzIGZyb20gRm9ybUNvbnRyb2xcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhLWVycm9yLW1lc3NhZ2VzJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNtYWxsICpuZ0lmPVwiaGFzTWVzc2FnZSgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidWktZy0xMiB1aS1tZXNzYWdlIHVpLW1lc3NhZ2VzLWVycm9yIHVpLWNvcm5lci1hbGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGVycm9yTXNnIH19XG4gICAgICAgICAgICAgICAgICAgIDwvc21hbGw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIHN0eWxlczogW2BgXVxufSlcbmV4cG9ydCBjbGFzcyBFcnJvck1lc3NhZ2VzQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGZvcm0gRm9ybUNvbnRyb2xsIHRvIGNoZWNrIGZvciBFcnJvcnNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVyck1hbmFnZXI6IEVycm9yTWFuYWdlclNlcnZpY2UpXG4gICAge1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICB9XG5cblxuICAgIGhhc01lc3NhZ2UoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgbGV0IG1zZyA9IHRoaXMuZXJyb3JNc2c7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQobXNnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSBhIG1lc3NhZ2VzIGlmIGFueSByZWdpc3RlcmVkIGJ5IGFkZGVkIHZhbGlkYXRvcnNcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBlcnJvck1zZygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGZvciAobGV0IHByb3BlcnR5TmFtZSBpbiB0aGlzLmNvbnRyb2wuZXJyb3JzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sLmVycm9ycy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpICYmIHRoaXMuY29udHJvbC50b3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyTWFuYWdlci5lcnJvck1lc3NhZ2UocHJvcGVydHlOYW1lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wuZXJyb3JzW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTaG93IGVycm9ycz8gV2UgY3VycmVudGx5IHNob3dzIGVycm9ycyBpZiB0aGUgY29udHJvbCBpcyBub3QgdmFsaWQsIGl0IHdhcyB0b3VjaGVkIGJ5IHVzZXIuXG4gICAgICogTW9zdCBvZiB0aGUgdHlwZSBvbiBibHVyIGV2ZW50ICBhbmQgYXQgbGFzdCBpdHMgbm90IHByaXN0aW5lIGFueW1vcmUgKGl0cyBkaXJ0eSlcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dFcnJvcnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbnRyb2wudmFsaWQgJiYgIXRoaXMuY29udHJvbC5wcmlzdGluZSAmJiB0aGlzLmNvbnRyb2wudG91Y2hlZDtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnRGYWN0b3J5LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb21wb25lbnRSZWYsXG4gICAgSW5qZWN0YWJsZSxcbiAgICBUeXBlLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogTW9kYWwgc2VydmljZSBpcyB1c2VkIHRvIHRvIGNyZWF0ZSBtb2RhbCBkaWFsb2dzLiBJdCBjcmVhdGVzIG1vZGFsIGRpYWxvZ3MgZHluYW1pY2FsbHkuXG4gKiBUaGUgc2VydmljZSBhbHNvIGtlZXBzIHRyYWNrIG9mIHRoZSBjcmVhdGVkIG1vZGFsIGRpYWxvZyBhbmQgY2FuIGNsb3NlIGl0IGJ5IGNhbGxpbmcgdGhlXG4gKiBzZXJ2aWNlJ3MgY2xvc2UoKVxuICpcbiAqIE1vZGFsIHNlcnZpY2UgcmVxdWlyZXMgYSBWaWV3Q29udGFpbmVyIHRvIGluc2VydCBuZXdseSBjcmVhdGVkIG1vZGFscy4gVGhpcyBpcyB0YWtlbiBjYXJlXG4gKiBieSB0aGUgTW9kYWxDb21wb25lbnQuXG4gKlxuICogVXNhZ2U6XG4gKiAgICAgQWRkICAgPGF3LW1vZGFsPjwvYXctbW9kYWw+ICBpbnRvIHlvdXIgYXBwbGljYXRpb24gbWFpbiBodG1sLiBJdCBuZWVkcyB0byBiZSBvbiBldmVyeVxuICogICAgIHBhZ2Ugd2hlcmUgYSBtb2RhbCBkaWFsb2cgd2lsbCBhcHBlYXIuXG4gKlxuICogICAgMS4gIFBvcHVwIGEgZGlhbG9nIHdpdGhvdXQgY3JlYXRpbmcgeW91ciBvd24gY29tcG9uZW50LlxuICogICAgICAgIFVzZSB0aGUgZXhpc3RpbmcgRGlhbG9nQ29tcG9uZW50IGluIHdpZGdldHMuXG4gKlxuICogICAgICAgICAgICAgdGhpcy5tb2RhbFNlcnZpY2Uub3BlbjxEaWFsb2dDb21wb25lbnQ+KERpYWxvZ0NvbXBvbmVudCwge1xuICogICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ015IFBvcHVwIFRpdGxlJyxcbiAqICAgICAgICAgICAgICAgICAgICAgYm9keTogJ015IFBvcHVwIEJvZHknXG4gKiAgICAgICAgICAgICAgfSk7XG4gKlxuICpcbiAqICAgMi4gICBDcmVhdGluZyB5b3VyIG93biBEaWFsb2cgQ29tcG9uZW50IHRvIHBvcHVwLlxuICpcbiAqICAgICAgICAgbGV0IGNvbXBvbmVudFJlZiA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48TXlEaWFsb2dDb21wb25lbnQ+KE15RGlhbG9nQ29tcG9uZW50LFxuICoge2lucHV0c30pO1xuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1teWRpYWxvZycgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2cgKG9uQ2xvc2UpPVwiY2xvc2VQb3B1cCgpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI3RpdGxlVGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj48aSBjbGFzcz1cImZhIGZhLWVudmlyYVwiID48L2k+VGhpcyBpcyBteVxuICogICAgIFRpdGxlIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2JvZHlUZW1wbGF0ZT5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjxpIGNsYXNzPVwiZmEgZmEtZW52aXJhXCIgPjwvaT5UaGlzIGlzIG15XG4gKiAgICAgQm9keSA8L3NwYW4+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kaWFsb2c+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIH0pXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeURpYWxvZ0NvbXBvbmVudCBleHRlbmRzIERpYWxvZ0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNsb3NlUG9wdXAoKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5jbG9zZSgpO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICB9XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb2RhbFNlcnZpY2VcbntcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgc3RhdGljIGxpc3Qgb2Ygb3V0cHV0IHBhcmFtZXRlciBmcm9tIERpYWxvZywgQ29uZmlybWF0aW9uIGNvbXBvbmVudHNcbiAgICAgKiB0aGF0IG5lZWRzIHRvIGJlIGhhbmRsZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBPVVRQVVRfUEFSQU1FVEVSUzogc3RyaW5nW10gPSBbJ29uQ2xvc2UnLCAnb25Db25maXJtJywgJ29uQ2FuY2VsJ107XG5cblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBmb3IgdGhlIG5ld2x5IGNyZWF0ZWQgbW9kYWwuIFRoaXMgaXMgcGFzc2VkIGluIHRocm91Z2ggdGhlXG4gICAgICogcmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKCkuXG4gICAgICovXG4gICAgcHJpdmF0ZSB2Y1JlZjogVmlld0NvbnRhaW5lclJlZjtcblxuICAgIC8qKlxuICAgICAqIFN0b3JpbmcgdGhlIGNyZWF0ZWQgbW9kYWwgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbnN0YW5jZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogREkgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIHRvIGJlIHVzZWQgdG8gY3JlYXRlIG1vZGFsIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZnJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyKVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgUGxhY2VIb2xkZXIgZm9yIG1vZGFsIHRvIGJlIGluc2VydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZjUmVmXG4gICAgICovXG4gICAgcmVnaXN0ZXJWaWV3Q29udGFpbmVyUmVmKHZjUmVmOiBWaWV3Q29udGFpbmVyUmVmKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy52Y1JlZiA9IHZjUmVmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBtb2RhbCBkaWFsb2cgYnkgZHluYW1pY2FsbHkgY3JlYXRpbmcgdGhlIGNvbXBvbmVudCBhbmQgYWRkaW5nIGl0IHRvIHZjUmVmLlxuICAgICAqXG4gICAgICovXG4gICAgb3BlbjxUPihjb21wb25lbnQ6IFR5cGU8VD4sIHBhcmFtZXRlcnM/OiBhbnkpOiBDb21wb25lbnRSZWY8VD5cbiAgICB7XG4gICAgICAgIGNvbnN0IGNmOiBDb21wb25lbnRGYWN0b3J5PFQ+ID0gdGhpcy5jZnIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgbGV0IGNvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPFQ+ID0gdGhpcy52Y1JlZi5jcmVhdGVDb21wb25lbnQoY2YpO1xuXG4gICAgICAgIC8vIEF1dG8gc2V0IHZpc2libGl0eSB0byB0cnVlLiBTbyB0aGF0IHRoZSBEaWFsb2cgd2lsbCBkaXNwbGF5XG4gICAgICAgIHBhcmFtZXRlcnMgPSAocGFyYW1ldGVycykgPyBwYXJhbWV0ZXJzIDoge307XG4gICAgICAgIHBhcmFtZXRlcnNbJ3Zpc2libGUnXSA9IHRydWU7XG5cbiAgICAgICAgLy8gSGFuZGxlIG91dHB1dCBwYXJhbWV0ZXJzLlxuICAgICAgICBNb2RhbFNlcnZpY2UuT1VUUFVUX1BBUkFNRVRFUlMuZm9yRWFjaCgocGFyYW0pID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzW3BhcmFtXSkge1xuICAgICAgICAgICAgICAgICg8YW55PmNvbXBvbmVudFJlZi5pbnN0YW5jZSlbcGFyYW1dLnN1YnNjcmliZShwYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtZXRlcnNbcGFyYW1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBPYmplY3QuYXNzaWduKGNvbXBvbmVudFJlZi5pbnN0YW5jZSwgcGFyYW1ldGVycyk7XG5cbiAgICAgICAgLy8gaGFkIHRvIGNhc3QgaXQgaW4gb3JkZXIgdG8gYXZvaWQgYW55IGluZGV4IEVycm9yXG4gICAgICAgIC8vIEF0dGFjaCBhIGRlc3Ryb3kgbWV0aG9kIHRvIHRoZSBuZXdseSBjcmVhdGVkIGNvbXBvbmVudC5cbiAgICAgICAgKDxhbnk+Y29tcG9uZW50UmVmLmluc3RhbmNlKVsnZGVzdHJveSddID0gKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2F2ZSB0aGUgaW5zdGFuY2UsIHNvIGl0IGNhbiBiZSBkZXN0cm95ZWQgbGF0ZXIuXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBjb21wb25lbnRSZWY7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIGNsb3NlKCkgd2lsbCByZW1vdmUgdGhlIG1vZGFsIGZyb20gdmlldy5cbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIE9uSW5pdCwgVmlld0NoaWxkLCBWaWV3Q29udGFpbmVyUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kYWxTZXJ2aWNlfSBmcm9tICcuLi9tb2RhbC5zZXJ2aWNlJztcblxuXG4vKipcbiAqIFBsYWNlIGhvbGRlciBmb3IgYWxsIG1vZGFsIGRpYWxvZ3MuIFRoaXMgY29tcG9uZW50IHdvcmtzIHdpdGggdGhlIG1vZGFsU2VydmljZSBieSBwcm92aWRpbmdcbiAqIGEgcGxhY2UgaG9sZGVyIGZvciBpdCB0byBpbmplY3QgRGlhbG9nIGNvbXBvbmVudCBpbnRvLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW1vZGFsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgI21vZGFsPjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgYF1cbn0pXG5leHBvcnQgY2xhc3MgTW9kYWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXRcbntcblxuICAgIEBWaWV3Q2hpbGQoJ21vZGFsJywge3JlYWQ6IFZpZXdDb250YWluZXJSZWZ9KVxuICAgIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWY7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLm1vZGFsU2VydmljZS5yZWdpc3RlclZpZXdDb250YWluZXJSZWYodGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDdXJyZW5jeVBpcGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BpcGUsIFBpcGVUcmFuc2Zvcm19IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgY3VycmVuY3kgZm9ybWF0dGVyIHdpbGwgaWdub3JlIG51bGwgYW5kIGVtcHR5IHN0cmluZyBmb3IgdmFsdWUuXG4gKiBJc3N1ZSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzg2OTQgIERJIGZhaWxzIHdoZW4gZXh0ZW5kcyBvdGhlciBjbGFzc2VzXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAnY3VycmVuY3lGb3JtYXQnLFxuICAgIHB1cmU6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIEN1cnJlbmN5Rm9ybWF0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm1cbntcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY3VycmVuY3lQaXBlOiBDdXJyZW5jeVBpcGUpXG4gICAge1xuICAgIH1cblxuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSk6IGFueVxuICAgIHtcblxuICAgICAgICAvLyBEZWZhdWx0IHZhbHVlc1xuICAgICAgICBsZXQgY3VycmVuY3lDb2RlID0gJ1VTRCcsIHN5bWJvbERpc3BsYXkgPSB0cnVlLCBkaWdpdHMgPSAnMS4wLTInO1xuXG4gICAgICAgIGlmICghdmFsdWUgfHwgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYXJncyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxldCBjb2RlID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmIChjb2RlICYmIGNvZGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbmN5Q29kZSA9IGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW5jeVBpcGUudHJhbnNmb3JtKHZhbHVlLCBjdXJyZW5jeUNvZGUsIHN5bWJvbERpc3BsYXksIGRpZ2l0cyk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICovXG5pbXBvcnQge0RpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5cbi8qKlxuICogU2ltcGxlIHV0aWxpdHkgZGlyZWN0aXZlIHRoYXQgaXMgdXNlZCBieSBORyBGb3IgY3ljbGUgaW4gc2l0dWF0aW9uIHdoZXJlIHdlIG5lZWQgdG8gY2FsbCBhXG4gKiBvciBleGVjdXRlIHNvbWUgbG9naWMgYWZ0ZXIgZWFjaCBpdGVyYXRpb25cbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbmdGb3JTZXRdJ1xufSlcbmV4cG9ydCBjbGFzcyBOZ0ZvclNldERpcmVjdGl2ZVxue1xuXG4gICAgQE91dHB1dCgpXG4gICAgb25JdGVtOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLm9uSXRlbS5lbWl0KCctLScpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogU2ltcGxlIGNvbnZlbmllbnQgc2VydmljZSB0byB3b3JrIHdpdGggdGhlIGRvbS4gQWxsIHRoZSBmdXR1cmUgbG9naWMgcmVsYXRlZCB0byBET00gbWFuaXB1bGF0aW9uXG4gKiBvciB0cmF2ZXJzYWwgc2hvdWxkIGJlIHB1dCBpbnRvIHRoaXMgc2VydmljZVxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERvbVV0aWxzU2VydmljZVxue1xuXG4gICAgY29uc3RydWN0b3IgKClcbiAgICB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ29lcyBhbGwgdGhlIHdheSB1cCB0byB0aGUgYm9keSBhbmQgY2hlY2tzIGlmIHRoZXJlIGlzIGEgZWxlbWVudCBpZGVudGlmaWVkIGJ5IGEgJ3NlbGVjdG9yJ1xuICAgICAqXG4gICAgICovXG4gICAgaGFzUGFyZW50IChuYXRpdmVFbGVtZW50OiBhbnksIHNlbGVjdG9yOiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY2xvc2VzdChuYXRpdmVFbGVtZW50LCBzZWxlY3RvcikpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogIFRyYXZlbHMgYWxsIHRoZSB3YXkgdXAgdG8gdGhlIEJPRFkgYW5kIHJldHJpZXZlIGVsZW1lbnQgaWRlbnRpZmllZCBieSAnc2VsZWN0b3InIG9yIE5VTEwgaWZcbiAgICAgKiBub3QgZm91bmRcbiAgICAgKlxuICAgICAqL1xuICAgIGNsb3Nlc3QgKG5hdGl2ZUVsZW1lbnQ6IGFueSwgc2VsZWN0b3I6IHN0cmluZyk6IGFueVxuICAgIHtcbiAgICAgICAgbGV0IGZpcnN0Q2hhciA9IHNlbGVjdG9yLmNoYXJBdCgwKTtcblxuICAgICAgICBsZXQgcGFyZW50Tm9kZSA9IG5hdGl2ZUVsZW1lbnQ7XG5cblxuICAgICAgICB3aGlsZSAoaXNQcmVzZW50KChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlKSkpIHtcbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09ICcuJyAmJiBwYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucyhzZWxlY3Rvci5zdWJzdHIoMSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmaXJzdENoYXIgPT09ICcjJyAmJiBwYXJlbnROb2RlLmlkID09PSBzZWxlY3Rvci5zdWJzdHIoMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0b3IgaXMgYSB0YWdcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlLm5vZGVUeXBlID09PSAxICYmIHBhcmVudE5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gYW5ndWxhciBjb21wb25lbnQgaXMgcmVuZGVyZWQgYWxvbmcgd2l0aCBOR0NvbnRlbnQgaXQgaGFzIGl0cyBvd24gX25nQ29udGVudF9JTkRFWFxuICAgICAqIHdoaWNoIGFsd2F5cyBjb3JyZXNwb25kcyB3aXRoIF9uZ2hvc3RfSU5ERVgsIHRoaXMgd29ya3MgZmluZSBpZiB3ZSBoYXZlIGFjdHVhbCBjb21wb25lbnRcbiAgICAgKiB0aGF0IGlzIGFscmVhZHkgcmVuZGVyZWQuIElmIHdlIGFyZSBjcmVhdGluZyBjb21wb25lbnQgcHJvZ3JhbWF0aWNhbGx5IHRoZXJlIGlzIG5vIHdheSB0b1xuICAgICAqIGlkZW50aWZ5IHdoZXJlIHRoZSBhY3R1YWwgbmctY29udGVudCBpcyBwbGFjZWQgd2l0aGluIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIGUuZy4gQ29uc2lkZXIgZm9sbG93aW5nIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKlxuICAgICAqIEJ1dHRvbiBDb21wb25lbnQgVGVtcGxhdGU6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgPHNwYW4gY2xhc3M9bXlidXR0b25UaXRsZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9zcGFuPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlbiB5b3UgdXNlIGJ1dHRvbiBjb21wb25lbnQgYXMgPGF3LWJ1dHRvbj5DbGlja01lPC9hdy1idXR0b24+ICB0aGVuIGl0cyByZW5kZXJlZCBhc1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogPGF3LWJ1dHRvbiBfbmdob3N0XzEyMz5cbiAgICAgKiAgPHNwYW4gX25nY29udGVudF8xMjMgY2xhc3M9bXlidXR0b25UaXRsZT5DbGlja01lPC9zcGFuPlxuICAgICAqIDwvYXctYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQnV0IHdpdGggcHJvZ3JhbW1hdGljIEFQSSB5b3UgaW5zdGFudGlhdGUgQnV0dG9uIGFuZCBzaW5jZSBpdCBjcmVhdGVkIHdpdGhvdXQgYSBDb250ZW50IGl0XG4gICAgICogbG9va3MgbGlrZSB0aGlzO1xuICAgICAqXG4gICAgICogIGBgYFxuICAgICAqIDxhdy1idXR0b24gX25naG9zdF8xMjM+XG4gICAgICogIDxzcGFuIGNsYXNzPW15YnV0dG9uVGl0bGU+PC9zcGFuPlxuICAgICAqIDwvYXctYnV0dG9uPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlcmUgZG8geW91IHBsYWNlIHlvdSBjaGlsZCAoY29udGVudCBjb21wb25lbnQpPyBUaGVyZWZvcmUgdXRpbGl0eSBjc3MgY2xhc3Mgd2FzIGNyZWF0ZWRcbiAgICAgKiB0byB3cmFwIDxuZy1jb250ZW50PiB0byBnZXQgYXJvdW5kIHRoaXMgbGltaXRhdGlvbi5cbiAgICAgKlxuICAgICAqICBgYGBcbiAgICAgKiAgIDxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj5cbiAgICAgKiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgKiAgIDwvc3Bhbj5cbiAgICAgKiAgYGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgaW5zZXJ0SW50b1BhcmVudE5nQ29udGVudCAocGFyZW50TmF0aXZlRWw6IGFueSwgY2hpbGROYXRpdmVFbDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyB0byBpbnNlcnQgaXQgYXMgY2hpbGQgdG8gcGFyZW50TmF0aXZlRWxcbiAgICAgICAgbGV0IG5nQ29udGVudFBhcmVudCA9IHBhcmVudE5hdGl2ZUVsO1xuXG4gICAgICAgIGxldCBmb3VuZE5nQ29udGVudCA9IHBhcmVudE5hdGl2ZUVsLnF1ZXJ5U2VsZWN0b3IoJy51LW5nY29udGVudCcpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KGZvdW5kTmdDb250ZW50KSkge1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgY292ZXIgYSBjYXNlIHdoZXJlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG5nY29udGVudHNcbiAgICAgICAgICAgIG5nQ29udGVudFBhcmVudCA9IGZvdW5kTmdDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIG5nQ29udGVudFBhcmVudC5hcHBlbmRDaGlsZChjaGlsZE5hdGl2ZUVsKTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBSZXRyaWV2ZXMgY3VycmVudCBicm93c2VyIHdpbmRvdyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICpcbiAgICAgKi9cbiAgICBicm93c2VyRGltZW50aW9ucyAoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICAgICAgICAgICAgICB8fCBkb2N1bWVudC5ib2R5LmNsaWVudFdpZHRoKSxcbiAgICAgICAgICAgIGhlaWdodDogKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgICAgICAgfHwgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQpXG4gICAgICAgIH07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFJldHJpZXZlcyBlbGVtZW1lbnRzIGRpbWVuc2lvbnNcbiAgICAgKlxuICAgICAqL1xuICAgIGVsZW1lbnREaW1lbnNpb25zIChlbGVtZW50OiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMH07XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBVbmRlciBAb3JpZ2luYWwtbGljZW5zZVxuICpcbiAqIENvcHlyaWdodCAyMDE1LXByZXNlbnQgRHJpZnR5IENvLlxuICogaHR0cDovL2RyaWZ0eS5jb20vXG4gKlxuICogIE1JVCBMaWNlbnNlXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nXG4gKiBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OXG4gKiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT05cbiAqIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqXG4gKiBDcmVkaXQgdG8gZHJpZnR5IGZvciB0aGlzIGV4Y2VsbGVudCBjb21wb25lbnQuIFdlIGhhdmUgYSBzdHJvbmcgbmVlZHMgZm9yIGdvb2QgaW5maW5pdGVcbiAqIHNjcm9sbGluZyBjb21wb25lbnQgc28gdGhpcyBpcyBkZXJpdmVkIHdvcmsgYmFzZWQgb24gdGhpcyBkcmlmdHkgY29tcG9uZW50IGFzIHdlIGNhbiBub3QgcmVhbGx5XG4gKiBicmluZyBpbiB3aG9sZSBmcmFtZXdvcmsgYW5kIHRoZWlyIGNvbXBvbmVudC9BUEkuIEl0IHdvdWxkIGJlIHRvbyBoZWF2eVxuICpcbiAqIENvbXBvbmVudCBpcyB1cGRhdGVkIHdpdGggbmF0aXZlIERPTSBBUEkuIHBsdXMgc2ltcGxpZmllZCBieSByZW1vdmluZyB0aGluZ3NcbiAqIHRoYXQgYXJlIG5vdCBuZWNlc3NhcnkgZm9yIG91ciB1c2VjYXNlLiBVcGRhdGVkIGRpcmVjdGl2ZSBwcmVmaXggdG8gbWF0Y2ggb3VyIGd1aWRlbGluZXNcbiAqXG4gKlxuICpcbiAqL1xuXG5cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5wdXQsXG4gICAgTmdab25lLCBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbVV0aWxzU2VydmljZX0gZnJvbSAnLi4vLi4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5cbi8qKlxuICogVGhlIEluZmluaXRlIFNjcm9sbCBhbGxvd3MgeW91IHRvIHBlcmZvcm0gYW4gYWN0aW9uIHdoZW4gdGhlIHVzZXJcbiAqIHNjcm9sbHMgYSBzcGVjaWZpZWQgZGlzdGFuY2UgZnJvbSB0aGUgYm90dG9tIG9yIHRvcCBvZiB0aGUgcGFnZS5cbiAqXG4gKiBUaGUgZXhwcmVzc2lvbiBhc3NpZ25lZCB0byB0aGUgYGluZmluaXRlYCBldmVudCBpcyBjYWxsZWQgd2hlblxuICogdGhlIHVzZXIgc2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIGRpc3RhbmNlLiBXaGVuIHRoaXMgZXhwcmVzc2lvblxuICogaGFzIGZpbmlzaGVkIGl0cyB0YXNrcywgaXQgc2hvdWxkIGNhbGwgdGhlIGBjb21wbGV0ZSgpYCBtZXRob2RcbiAqIG9uIHRoZSBpbmZpbml0ZSBzY3JvbGwgaW5zdGFuY2UuXG4gKlxuICogIyMgVXNhZ2VcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxkaXYgICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCI+e3tpdGVtfX0gPC9kaXY+XG4gKiAgIDxhdy1pbmZpbml0ZS1zY3JvbGwgKG9uTG9hZCk9XCJkb0luZmluaXRlKCRldmVudClcIj5cbiAqICA8L2F3LWluZmluaXRlLXNjcm9sbD5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogWW91IGNhbiBhbHNvIHNldCBhIHRocmVzaG9sZCB0byBjaGFuZ2UgdGhlIGRpc3RhbmNlIHdoZW4gdGhlIGxhenkgbG9hZCBraWNrc1xuICogaW4uXG4gKiAjIyBVc2FnZVxuICpcbiAqIGBgYGh0bWxcbiAqXG4gKiAgPGRpdiAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj57e2l0ZW19fSA8L2Rpdj5cbiAqICAgPGF3LWluZmluaXRlLXNjcm9sbCAob25Mb2FkKT1cImRvSW5maW5pdGUoJGV2ZW50KVwiICBbZGlzdGFuY2VdPVwiJzE1JSdcIj5cbiAqICA8L2F3LWluZmluaXRlLXNjcm9sbD5cbiAqXG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1pbmZpbml0ZS1zY3JvbGwnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctaW5maW5pdGUtbG9hZGVyLXBhbmVsXCIgKm5nSWY9XCJpc0xvYWRpbmcoKVwiPlxuICAgIDxzcGFuIGNsYXNzPVwic2FwLWljb24gaWNvbi1zeW5jaHJvbml6ZSB1LXNwaW4taWNvblwiPjwvc3Bhbj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnctaW5maW5pdGUtbG9hZGVyLXBhbmVse2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwcHg7ei1pbmRleDozMDA7Ym90dG9tOjEwMHB4fS53LWluZmluaXRlLWxvYWRlci1wYW5lbCBzcGFue2NvbG9yOiM0YTRhNGE7Zm9udC1zaXplOjJlbX1gXSxcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXRcbntcbiAgICBfbGFzdENoZWNrOiBudW1iZXIgPSAwO1xuICAgIF9sYXN0U2Nyb2xsVG9wOiBudW1iZXIgPSAwO1xuICAgIF9zY0xzbjogYW55O1xuICAgIF90aHI6IHN0cmluZyA9ICcxMCUnO1xuICAgIF90aHJQeDogbnVtYmVyID0gMDtcbiAgICBfdGhyUGM6IG51bWJlciA9IDAuMTA7XG4gICAgX2luaXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIF9jb250ZW50OiBhbnk7XG4gICAgX2RvY0JvZHk6IGFueTtcblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRlOiBzdHJpbmcgPSBTVEFURV9FTkFCTEVEO1xuXG4gICAgLyoqXG4gICAgICogQGlucHV0IHtzdHJpbmd9IFRoZSB0aHJlc2hvbGQgZGlzdGFuY2UgZnJvbSB0aGUgYm90dG9tXG4gICAgICogb2YgdGhlIGNvbnRlbnQgdG8gY2FsbCB0aGUgYG9uTG9hZGAgb3V0cHV0IGV2ZW50IHdoZW4gc2Nyb2xsZWQuXG4gICAgICogVGhlIHRocmVzaG9sZCB2YWx1ZSBjYW4gYmUgZWl0aGVyIGEgcGVyY2VudCwgb3JcbiAgICAgKiBpbiBwaXhlbHMuIEZvciBleGFtcGxlLCB1c2UgdGhlIHZhbHVlIG9mIGAxMCVgIGZvciB0aGUgYGluZmluaXRlYFxuICAgICAqIG91dHB1dCBldmVudCB0byBnZXQgY2FsbGVkIHdoZW4gdGhlIHVzZXIgaGFzIHNjcm9sbGVkIDEwJVxuICAgICAqIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS4gVXNlIHRoZSB2YWx1ZSBgMTAwcHhgIHdoZW4gdGhlXG4gICAgICogc2Nyb2xsIGlzIHdpdGhpbiAxMDAgcGl4ZWxzIGZyb20gdGhlIGJvdHRvbSBvZiB0aGUgcGFnZS5cbiAgICAgKiBEZWZhdWx0IGlzIGAxNSVgLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGRpc3RhbmNlICgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aHI7XG4gICAgfVxuXG4gICAgc2V0IGRpc3RhbmNlICh2YWw6IHN0cmluZylcbiAgICB7XG4gICAgICAgIHRoaXMuX3RociA9IHZhbDtcbiAgICAgICAgaWYgKHZhbC5pbmRleE9mKCclJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyUHggPSAwO1xuICAgICAgICAgICAgdGhpcy5fdGhyUGMgPSAocGFyc2VGbG9hdCh2YWwpIC8gMTAwKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGhyUHggPSBwYXJzZUZsb2F0KHZhbCk7XG4gICAgICAgICAgICB0aGlzLl90aHJQYyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5wdXQge2Jvb2xlYW59IElmIHRydWUsIFdoZXRoZXIgb3Igbm90IHRoZSBpbmZpbml0ZSBzY3JvbGwgc2hvdWxkIGJlXG4gICAgICogZW5hYmxlZCBvciBub3QuIFNldHRpbmcgdG8gYGZhbHNlYCB3aWxsIHJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogYW5kIGhpZGUgdGhlIGRpc3BsYXkuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgZW5hYmxlZCAoc2hvdWxkRW5hYmxlOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgdGhpcy5lbmFibGUoc2hvdWxkRW5hYmxlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBvdXRwdXQge2V2ZW50fSBFbWl0dGVkIHdoZW4gdGhlIHNjcm9sbCByZWFjaGVzXG4gICAgICogdGhlIHRocmVzaG9sZCBkaXN0YW5jZS4gRnJvbSB3aXRoaW4geW91ciBpbmZpbml0ZSBoYW5kbGVyLFxuICAgICAqIHlvdSBtdXN0IGNhbGwgdGhlIGluZmluaXRlIHNjcm9sbCdzIGBjb21wbGV0ZSgpYCBtZXRob2Qgd2hlblxuICAgICAqIHlvdXIgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25Mb2FkOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cbiAgICBAVmlld0NoaWxkKCdsb2FkaW5QYW5lbCcpXG4gICAgbG9hZFBhbmVsOiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExhenkgbG9hZCBjdXJyZW50IG51bWJlcnMuIHRlbGwgdGhlIGFwcCBzdGFydGluZyBwb2ludCBhbmQgd2hhdCBpcyB0aGUgc2l6ZSBvZiBsb2FkZWRcbiAgICAgKiBsaXN0XG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZldGNoU2l6ZTogbnVtYmVyID0gMDtcblxuICAgIGxvYWRPZmZzZXQ6IG51bWJlciA9IDA7XG5cblxuICAgIGNvbnN0cnVjdG9yIChwcml2YXRlIF9yZW5kZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBfem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIGRvbVV0aWxzOiBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgX2NkOiBDaGFuZ2VEZXRlY3RvclJlZilcbiAgICB7XG5cblxuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX3JlbmRlci5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCAnaGFzLWluZmluaXRlLXNjcm9sbCcpO1xuXG4gICAgfVxuXG4gICAgX29uU2Nyb2xsIChldjogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX0xPQURJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG11c3QgdGhyb3R0bGUgdGhlIGNsYXNzIGJ5IDEwMG1zXG4gICAgICAgIGlmICh0aGlzLl9sYXN0Q2hlY2sgKyAxMDAgPiBldi50aW1lU3RhbXApIHtcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gY2hlY2sgbGVzcyB0aGFuIGV2ZXJ5IFhYbXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xhc3RDaGVjayA9IGV2LnRpbWVTdGFtcDtcbiAgICAgICAgbGV0IHNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgbGV0IHdpbkhlaWdodCA9IHRoaXMuZG9tVXRpbHMuYnJvd3NlckRpbWVudGlvbnMoKS5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KHRoaXMuX2RvY0JvZHkuc2Nyb2xsSGVpZ2h0LCB0aGlzLl9kb2NCb2R5Lm9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIHdpbkhlaWdodCwgdGhpcy5fY29udGVudC5zY3JvbGxIZWlnaHQsIHRoaXMuX2NvbnRlbnQub2Zmc2V0SGVpZ2h0KTtcblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gaGVpZ2h0IG9mIHRoaXMgZWxlbWVudCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLl90aHJQYyA/IChoZWlnaHQgKiB0aGlzLl90aHJQYykgOiB0aGlzLl90aHJQeDtcbiAgICAgICAgbGV0IGRpc3RhbmNlRnJvbUluZmluaXRlID0gdGhpcy5fY29udGVudC5zY3JvbGxIZWlnaHQgLSB3aW5IZWlnaHQgLSBzY3JvbGxUb3AgLSB0aHJlc2hvbGQ7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0RvY3VtZW50IGhlaWdodCAoJyArIGhlaWdodCArICcpICwgRGlzdGFuY2UgZnJvbSBib3R0b20gJ1xuICAgICAgICAvLyArIGRpc3RhbmNlRnJvbUluZmluaXRlICsgJywgID0+IHRocmVzaG9sZCA9ICcgK1xuICAgICAgICAvLyAgICAgdGhpcy5kaXN0YW5jZSArICcgKCcgKyB0aHJlc2hvbGQgKyAnKScpO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZUZyb21JbmZpbml0ZSA8IDAgJiYgdGhpcy5fbGFzdFNjcm9sbFRvcCA8IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgdGhpcy5maXJlT25MYXp5TG9hZCgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFNjcm9sbFRvcCA+IHNjcm9sbFRvcCAmJiBzY3JvbGxUb3AgPCB3aW5IZWlnaHRcbiAgICAgICAgICAgICYmIHRoaXMubG9hZE9mZnNldCAhPT0gdGhpcy5mZXRjaFNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZU9uTGF6eVVuTG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xhc3RTY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2RvOiByZWZhY3RvciB0byBvbmUgbWV0aG9kXG4gICAgICovXG4gICAgcHJpdmF0ZSBmaXJlT25MYXp5TG9hZCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX0xPQURJTkcgJiYgdGhpcy5zdGF0ZSAhPT0gU1RBVEVfRElTQUJMRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfTE9BRElORztcblxuICAgICAgICAgICAgICAgIHRoaXMub25Mb2FkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICBpc0xvYWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLmZldGNoU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLmxvYWRPZmZzZXRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBvbiB0aGUgbmV4dCByZWNvcmRcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRPZmZzZXQgKz0gdGhpcy5mZXRjaFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBmaXJlT25MYXp5VW5Mb2FkICgpXG4gICAge1xuICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU1RBVEVfTE9BRElORyAmJiB0aGlzLnN0YXRlICE9PSBTVEFURV9ESVNBQkxFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9MT0FESU5HO1xuXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgb24gdGhlIG5leHQgcmVjb3JkXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkT2Zmc2V0ID0gdGhpcy5mZXRjaFNpemU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNMb2FkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbGltaXQ6IHRoaXMuZmV0Y2hTaXplLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMubG9hZE9mZnNldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgc2Nyb2xsVG9wICgpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiAod2luZG93LnBhZ2VZT2Zmc2V0IHx8IHRoaXMuX2NvbnRlbnQuc2Nyb2xsVG9wKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBjb21wbGV0ZSgpYCB3aXRoaW4gdGhlIGBpbmZpbml0ZWAgb3V0cHV0IGV2ZW50IGhhbmRsZXIgd2hlblxuICAgICAqIHlvdXIgYXN5bmMgb3BlcmF0aW9uIGhhcyBjb21wbGV0ZWQuIEZvciBleGFtcGxlLCB0aGUgYGxvYWRpbmdgXG4gICAgICogc3RhdGUgaXMgd2hpbGUgdGhlIGFwcCBpcyBwZXJmb3JtaW5nIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24sXG4gICAgICogc3VjaCBhcyByZWNlaXZpbmcgbW9yZSBkYXRhIGZyb20gYW4gQUpBWCByZXF1ZXN0IHRvIGFkZCBtb3JlIGl0ZW1zXG4gICAgICogdG8gYSBkYXRhIGxpc3QuIE9uY2UgdGhlIGRhdGEgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIFVJIHVwZGF0ZWQsIHlvdVxuICAgICAqIHRoZW4gY2FsbCB0aGlzIG1ldGhvZCB0byBzaWduaWZ5IHRoYXQgdGhlIGxvYWRpbmcgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNoYW5nZSB0aGUgaW5maW5pdGUgc2Nyb2xsJ3Mgc3RhdGUgZnJvbSBgbG9hZGluZ2BcbiAgICAgKiB0byBgZW5hYmxlZGAuXG4gICAgICovXG4gICAgY29tcGxldGUgKClcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9MT0FESU5HKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9FTkFCTEVEO1xuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHRyaWdnZXIgZXh0cmEgZGV0ZWN0IGNoYW5nZXMgdG8gcmVyZW5kZXIgbG9hZGluZyBpY29uXG4gICAgICAgICAgICB0aGlzLl9jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBlbmFibGUoZmFsc2UpYCB0byBkaXNhYmxlIHRoZSBpbmZpbml0ZSBzY3JvbGwgZnJvbSBhY3RpdmVseVxuICAgICAqIHRyeWluZyB0byByZWNlaXZlIG5ldyBkYXRhIHdoaWxlIHNjcm9sbGluZy4gVGhpcyBtZXRob2QgaXMgdXNlZnVsXG4gICAgICogd2hlbiBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGlzIG5vIG1vcmUgZGF0YSB0aGF0IGNhbiBiZSBhZGRlZCwgYW5kXG4gICAgICogdGhlIGluZmluaXRlIHNjcm9sbCBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgICAqIEBwYXJhbSBzaG91bGRFbmFibGUgIElmIHRoZSBpbmZpbml0ZSBzY3JvbGwgc2hvdWxkIGJlXG4gICAgICogZW5hYmxlZCBvciBub3QuIFNldHRpbmcgdG8gYGZhbHNlYCB3aWxsIHJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXJzXG4gICAgICogYW5kIGhpZGUgdGhlIGRpc3BsYXkuXG4gICAgICovXG4gICAgZW5hYmxlIChzaG91bGRFbmFibGU6IGJvb2xlYW4pXG4gICAge1xuICAgICAgICB0aGlzLnN0YXRlID0gKHNob3VsZEVuYWJsZSA/IFNUQVRFX0VOQUJMRUQgOiBTVEFURV9ESVNBQkxFRCk7XG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhzaG91bGRFbmFibGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgdG8gbmF0aXZlIHdpbmRvd3Mgc2Nyb2xsIGV2ZW50XG4gICAgICovXG4gICAgX3NldExpc3RlbmVycyAoc2hvdWxkTGlzdGVuOiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXQpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRMaXN0ZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NjTHNuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NMc24gPSB0aGlzLl9vblNjcm9sbC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX3NjTHNuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5fc2NMc24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9zY0xzbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjTHNuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGlzTG9hZGluZyAoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNUQVRFX0xPQURJTkc7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0ICgpXG4gICAge1xuICAgICAgICB0aGlzLl9pbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZG9jQm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cbiAgICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKHRoaXMuc3RhdGUgIT09IFNUQVRFX0RJU0FCTEVEKTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkT2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmZpcmVPbkxhenlMb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3kgKClcbiAgICB7XG4gICAgICAgIHRoaXMuX3NldExpc3RlbmVycyhmYWxzZSk7XG4gICAgfVxuXG59XG5cblxuY29uc3QgU1RBVEVfRU5BQkxFRCA9ICdlbmFibGVkJztcbmNvbnN0IFNUQVRFX0RJU0FCTEVEID0gJ2Rpc2FibGVkJztcbmNvbnN0IFNUQVRFX0xPQURJTkcgPSAnbG9hZGluZyc7XG4iLCJpbXBvcnQge0luamVjdGFibGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQXdOYW1lU3RvcmUge1xuXG4gICAgcHJpdmF0ZSBzdG9yZTogTWFwPHN0cmluZywgYW55PjtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IE1hcCgpO1xuICAgIH1cblxuICAgIGFkZChuYW1lOiBzdHJpbmcsIGVsOiBhbnkpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sbGlkZXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZSBpcyBub3QgdW5pcXVlIScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLnNldChuYW1lLCBlbCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKG5hbWU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yZS5kZWxldGUobmFtZSk7XG4gICAgfVxuXG4gICAgY29sbGlkZXMobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JlLmhhcyhuYW1lKTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zdG9yZS5jbGVhcigpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHtcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIE9uSW5pdCxcbiAgICBEaXJlY3RpdmUsXG4gICAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgICBBcHBDb25maWdcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbmltcG9ydCB7XG4gICAgQXdOYW1lU3RvcmVcbn0gZnJvbSAnLi9hdy1uYW1lLnN0b3JlJztcblxuLyoqXG4gKiBUaGUgJ2F3TmFtZScgZGlyZWN0aXZlIGF0dGFjaGVzIGEgaWRlbnRpZmllciB0byBkZWNvcmF0ZWQgZWxlbWVudCB0byBhaWQgc2VsZWN0b3JzIGZvciB0ZXN0aW5nXG4gKiBwdXJwb3Nlcy4gVGhlICdhd05hbWUnIGRpcmVjdGl2ZSB0cmllcyB0byBnZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyIGJhc2VkIG9uIGNvbnRleHR1YWwgZGF0YVxuICogYW5kIGluaGVyYW50IGltbXV0YWJsZSBlbGVtZW50IGF0dHJpYnV0ZXMuXG4gKlxuICogKipHZW5lcmF0aW5nIHRoZSBCYXNlIE5hbWUqKlxuICpcbiAqIFRoZSAnYXdOYW1lJyBkaXJlY3RpdmUgZ2VuZXJhdGVzIGEgYmFzZSBuYW1lIGZyb20gZWxlbWVudCB0YWcgbmFtZSBhbmQgYXR0cmlidXRlcyB3aGljaCBhcmVcbiAqIHN0YXRpYyBieSBuYXR1cmUuXG4gKlxuICogICAgIEV4YW1wbGU6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgYXdOYW1lPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgYXduYW1lPVwiYnV0dG9uX29yZGVyXCI+XG4gKlxuICogSWYgdGhlIGVsZW1lbnQgaGFzIGFuICdpZCcsIHRoYXQgdmFsdWUgdGFrZXMgcHJlY2VkZW50IGFuZCBpcyB1c2VkIGluc3RlYWQgb2YgYSBnZW5lcmF0ZWRcbiAqIG5hbWUuXG4gKlxuICogICAgIEV4YW1wbGU6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgaWQ9XCJteU9yZGVyQnV0dG9uXCIgYXdOYW1lPlxuICpcbiAqICAgICBSZXN1bHQ6XG4gKiAgICAgICAgIDxidXR0b24gbmFtZT1cIm9yZGVyXCIgaWQ9XCJteU9yZGVyQnV0dG9uXCIgYXduYW1lPVwiYnV0dG9uX215T3JkZXJCdXR0b25cIj5cbiAqXG4gKlxuICogKipSZXBlYXRlZCBFbGVtZW50cyBhbmQgdGhlICdleHQnIFBhcmFtZXRlcioqXG4gKlxuICogVGhlcmUgYXJlIG1hbnkgY2FzZXMgd2hlcmUgZWxlbWVudHMgYXJlIGdlbmVyYXRlZCBkeW5hbWljYWxseSBpbiB0aGUgY29kZSBhcyBsaXN0cyBvciB0YWJsZXMuXG4gKiBJbiBzdWNoIGNhc2VzLCBpdCBtYXkgbm90IGJlIGVhc3kgdG8gZGlzdGluZ3Vpc2ggaW5kaXZpZHVhbCBlbGVtZW50cyBieSBzdGFuZGFyZCBIVE1MXG4gKiBhdHRyaWJ1dGVzLCBzbyB0aGUgJ2F3TmFtZScgZGlyZWN0aXZlIGFsbG93cyBjdXN0b20gZXh0ZW50aW9ucyB0byB0aGUgYmFzZSBuYW1lIHRvIGJlIHByb3ZpZGVkXG4gKiB1c2luZyB0aGUgJ2V4dCcgYXR0cmlidXRlLlxuICpcbiAqICAgIEV4YW1wbGU6XG4gKiAgICAgICAgZnJ1aXRzID0gWydhcHBsZScsICdiYW5hbmEnLCAnb3JhbmdlJ107XG4gKlxuICogICAgICAgIDx1bD5cbiAqICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBmcnVpdCBvZiBmcnVpdHNcIiBhd05hbWUgZXh0PVwie3tmcnVpdH19XCI+e3tmcnVpdH19PC9saT5cbiAqICAgICAgICA8L3VsPlxuICpcbiAqICAgUmVzdWx0OlxuICogICAgICAgPHVsPlxuICogICAgICAgICAgIDxsaSBhd25hbWU9XCJsaV9hcHBsZVwiPmFwcGxlPC9saT5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfYmFuYW5hXCI+YmFuYW5hPC9saT5cbiAqICAgICAgICAgICA8bGkgYXduYW1lPVwibGlfb3JhbmVcIj5vcmFuZ2U8L2xpPlxuICogICAgICAgPC91bD5cbiAqXG4gKiAqKkFkZGluZyBDb250ZXh0IFRocm91Z2ggQW5jZXN0b3IgSW5zcGVjdGlvbioqXG4gKlxuICogSW4gb3JkZXIgdG8gcHJvdmlkZSBjb250ZXh0IHRvIHRoZSBlbGVtZW50IG5hbWluZywgdGhlICdhd05hbWUnIGRpcmVjdGl2ZSBsb29wcyB0aHJvdWdoIHRoZVxuICogcGFyZW50IGFuY2VzdHJ5IGFuZCBzZWFyY2hlcyBmb3IgYW55IHVuaXF1ZSBlbGVtZW50ICdpZCcgdG8gcHJlcGVuZCB0byB0aGUgYmFzZSBuYW1lLlxuICpcbiAqICAgICBFeGFtcGxlOlxuICogICAgICAgICA8Zm9ybSBpZD1cImFwcGxpY2FudFwiPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiZmlyc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibGFzdE5hbWVcIiBhd05hbWU+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqICAgICAgICAgPGZvcm0gaWQ9XCJzcG91c2VcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3TmFtZT5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXdOYW1lPlxuICogICAgICAgICA8L2Zvcm0+XG4gKlxuICogICAgIFJlc3VsdDpcbiAqICAgICAgICAgPGZvcm0gaWQ9XCJhcHBsaWNhbnRcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3bmFtZT1cImFwcGxpY2FudF9pbnB1dF9maXJzdE5hbWVcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXduYW1lPVwiYXBwbGljYW50X2lucHV0X2xhc3ROYW1lXCI+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqICAgICAgICAgPGZvcm0gaWQ9XCJzcG91c2VcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImZpcnN0TmFtZVwiIGF3bmFtZT1cInNwb3VzZV9pbnB1dF9maXJzdE5hbWVcIj5cbiAqICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cImxhc3ROYW1lXCIgYXduYW1lPVwic3BvdXNlX2lucHV0X2xhc3RuYW1lXCI+XG4gKiAgICAgICAgIDwvZm9ybT5cbiAqXG4gKiAqKlVuaXF1ZW5lc3MgQ2hlY2sqKlxuICpcbiAqICdhd05hbWUnIGtlZXBzIHRyYWNrIG9mIHRoZSBuYW1lcyBpdCBjcmVhdGVzIGJ5IGFkZGluZyB0aGVtIHRvIGEgbWFwIHN0b3JlLiBXaGVuZXZlciBpdFxuICogY3JlYXRlcyBhIG5ldyBuYW1lIGR1cmluZyB0aGUgYG5nT25Jbml0YCBwaGFzZSBpdCBjaGVja3MgaXQgYWdhaW5zdCB0aGUgZXhpc3RpbmcgbWFwLFxuICogYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgaXQgZW5jb3VudGVycyBhIGR1cGxpY2F0ZS4gTW9yZW92ZXIgZHVyaW5nIHRoZSBlbGVtZW50IGRlc3RydWN0aW9uXG4gKiBwaGFzZSwgYG5nT25EZXN0cm95YCwgJ2F3TmFtZScgcmVtb3ZlcyB0aGUgZ2VuZXJhdGVkIG5hbWUgZnJvbSB0aGUgc3RvcmUuXG4gKlxuICpcbiAqICoqSW4gUHJvZHVjdGlvbioqXG4gKlxuICogVXNpbmcgJ2F3TmFtZScgYWRkcyBhIHNtYWxsIGJpdCBvZiByZW5kZXJpbmcgb3ZlcmhlYWQgZm9yIGVhY2ggZWxlbWVudCBpdCBpcyB1c2VkIG9uLiBJblxuICogYSBwcm9kdWN0aW9uIGVudmlyb25tZW50LCAnYXdOYW1lJyBzZXJ2ZXMgbm8gZnVuY3Rpb25hbGl0eSB0byB0aGUgZW5kIHVzZXIsIGJ1dCBtYXkgaGF2ZVxuICogYSBwZXJmb3JtYW5jZSBpbXBhY3Qgb24gdGhlIGFwcGxpY2F0aW9uLiBBcyBzdWNoLCAnYXdOYW1lJyB0YWtlcyBpbnRvIGFjY291bnQgdGhlXG4gKiBgQXBwQ29uZmlnYCBzZXR0aW5ncyBhbmQgZGlzYWJsZXMgbmFtZSBnZW5lcmF0aW9uIHdoZW4gYEFwcENvbmZpZy5pc1Byb2R1Y3Rpb25Nb2RlKClgXG4gKiBpcyBgdHJ1ZWAuXG4gKlxuICogSW4geW91ciBhcHBsaWNhdGlvbiwgeW91IGNhbiB0dXJuIG9uIHByb2R1Y3Rpb24gbW9kZSBieSBzZXR0aW5nIGBkZXZtb2RlLmVuYWJsZWRgIHRvXG4gKiBgZmFsc2VgIHdoZW4gY29uZmlndXJpbmcgYEFyaWJhQ29yZU1vZHVsZWA6XG4gKlxuICogICAgIEFyaWJhQ29yZU1vZHVsZS5mb3JSb290KHtcbiAqICAgICAgICAgJ2Rldm1vZGUuZW5hYmxlZCc6IGZhbHNlXG4gKiAgICAgfSlcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2F3TmFtZV0nLFxufSlcbmV4cG9ydCBjbGFzcyBBd05hbWVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBleHQ6IHN0cmluZztcblxuICAgIHByaXZhdGUgbmFtZTogc3RyaW5nO1xuXG4gICAgcHJpdmF0ZSBzZXBhcmF0b3I6IHN0cmluZyA9ICdfJztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIHN0b3JlOiBBd05hbWVTdG9yZSxcbiAgICAgICAgcHJpdmF0ZSBjb25maWc6IEFwcENvbmZpZ1xuICAgICkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuY29uZmlnLmlzUHJvZHVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jcmVhdGVOYW1lKHRoaXMuZWwpO1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50VG9TdG9yZSh0aGlzLm5hbWUsIHRoaXMuZWwpO1xuICAgICAgICAgICAgdGhpcy5lbC5uYXRpdmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXduYW1lJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3JlLnJlbW92ZSh0aGlzLm5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBlbGVtZW50IG5hbWUvaWQgYW5kIHJlZmVyZW5jZSB0byBtYXAgc3RvcmUuIElmIG5hbWUvaWQgYWxyZWFkeVxuICAgICAqIGV4aXN0cyBpbiBzdG9yZSB0aGVuIGl0IHRocm93cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkZEVsZW1lbnRUb1N0b3JlKG5hbWU6IHN0cmluZywgZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5hZGQobmFtZSwgZWxlbSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZS5tZXNzYWdlICsgYC4gXCIke25hbWV9XCIgaXMgYWxyZWFkeSBpbiB1c2UuYCwgZWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIG5hbWUvaWQgZm9yIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICogQHJldHVybiBTdHJpbmcgTmFtZS9JRFxuICAgICAqL1xuICAgIGNyZWF0ZU5hbWUoZWxlbTogRWxlbWVudFJlZikge1xuXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0aGlzLmdldFRhZ05hbWUoZWxlbSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhcnJheSBvZiBzdHJpbmcgcGFydHNcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcblxuICAgICAgICAvLyBGaW5kIGFuY2VzdG9yIHRhZyBpZCwgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIGNvbnN0IHBhcmVudElEID0gdGhpcy5nZXRBbmNlc3RvcklkKGVsZW0pO1xuICAgICAgICBpZiAocGFyZW50SUQpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2gocGFyZW50SUQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHRhZyB0eXBlXG4gICAgICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IHRoaXMuZ2V0UGFyZW50TmFtZShlbGVtKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChwYXJlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdldCB0YWduYW1lXG4gICAgICAgIHBhcnRzLnB1c2godGFnTmFtZSk7XG5cbiAgICAgICAgLy8gQ2hvb3NlIGlkIHByb3BlcnR5IGlmIGl0IGV4aXN0c1xuICAgICAgICBpZiAoZWxlbS5uYXRpdmVFbGVtZW50LmlkKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGVsZW0ubmF0aXZlRWxlbWVudC5pZCk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGJ1aWxkIGV4dGVuc2lvbiBmcm9tIHRhZyBwcm9wZXJ0aWVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgYSBuYW1lIGF0dHJpYnV0ZVxuICAgICAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ25hbWUnKSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goZWxlbS5uYXRpdmVFbGVtZW50Lm5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdmFsdWUgYXR0cmlidXRlIGlmICdvcHRpb24nIHRhZ1xuICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09ICdvcHRpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLnNwYWNlc1RvVW5kZXJzY29yZShlbGVtLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGN1c3RvbSBleHRlbnNpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgIGlmICh0aGlzLmV4dCkge1xuICAgICAgICAgICAgcGFydHMucHVzaCh0aGlzLnNwYWNlc1RvVW5kZXJzY29yZSh0aGlzLmV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4odGhpcy5zZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0YWcgbmFtZSBmcm9tIGVsZW1lbnQgcmVmZXJlbmNlLlxuICAgICAqIEBwYXJhbSBlbGVtIFJlZmVyZW5jZSB0byBlbGVtZW50XG4gICAgICovXG4gICAgZ2V0VGFnTmFtZShlbGVtOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHJldHVybiBlbGVtLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlIGVsZW1lbnQgYW5jZXN0cnkgYW5kIHJldHVybiBmaXJzdCBpZCBhdHRyaWJ1dGVcbiAgICAgKiBlbmNvdW50ZXJlZC5cbiAgICAgKiBAcGFyYW0gZWxlbSBSZWZlcmVuY2UgdG8gZWxlbWVudFxuICAgICAqL1xuICAgIGdldEFuY2VzdG9ySWQoZWxlbTogRWxlbWVudFJlZikge1xuICAgICAgICBsZXQgcGFyZW50ID0gZWxlbS5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIGxldCBpZCA9ICcnO1xuICAgICAgICB3aGlsZSAocGFyZW50ICYmICFpZCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC5pZCkge1xuICAgICAgICAgICAgICAgIGlkID0gcGFyZW50LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBuYW1lIGF0dHJpYnV0ZSBmcm9tIHBhcmVudCBpZiBuYW1lIGF0dHJpYnV0ZSBleGlzdHMuXG4gICAgICogQHBhcmFtIGVsZW0gUmVmZXJlbmNlIHRvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnZXRQYXJlbnROYW1lKGVsZW06IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbS5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiAocGFyZW50Lm5hbWUgJiYgIXBhcmVudC5pZCkgPyBwYXJlbnQubmFtZSA6IG51bGw7XG4gICAgfVxuXG4gICAgc3BhY2VzVG9VbmRlcnNjb3JlKHN0cjogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKy9nLCAnXycpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtFbWJlZGRlZEl0ZW1EaXJlY3RpdmV9IGZyb20gJy4vZW1iZWRkZWQtaXRlbSc7XG5pbXBvcnQge0dlbmVyaWNDb250YWluZXJDb21wb25lbnR9IGZyb20gJy4vZ2VuZXJpYy1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7SW5jbHVkZUNvbXBvbmVudERpcmVjdGl2ZX0gZnJvbSAnLi9pbmNsdWRlLWNvbXBvbmVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHtFcnJvck1lc3NhZ2VzQ29tcG9uZW50fSBmcm9tICcuL2Vycm9yLW1lc3NhZ2VzL2Vycm9yLW1lc3NhZ2VzLmNvbXBvbmVudCc7XG5pbXBvcnQge01vZGFsQ29tcG9uZW50fSBmcm9tICcuL21vZGFsLXNlcnZpY2UvbW9kYWwvbW9kYWwuY29tcG9uZW50JztcbmltcG9ydCB7Q3VycmVuY3lGb3JtYXRQaXBlfSBmcm9tICcuL3BpcGVzL2N1cnJlbmN5LWZvcm1hdC5waXBlJztcbmltcG9ydCB7TmdGb3JTZXREaXJlY3RpdmV9IGZyb20gJy4vb24tbmdmb3Itc2V0LmRpcmVjdGl2ZSc7XG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50fSBmcm9tICcuL2luZml0ZS1zY3JvbGwvaW5maXRlLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHtBd05hbWVEaXJlY3RpdmV9IGZyb20gJy4vYXctbmFtZS9hdy1uYW1lLmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBJbmNsdWRlQ29tcG9uZW50RGlyZWN0aXZlLFxuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBFcnJvck1lc3NhZ2VzQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ3VycmVuY3lGb3JtYXRQaXBlLFxuICAgICAgICBOZ0ZvclNldERpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxDb21wb25lbnQsXG4gICAgICAgIEF3TmFtZURpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBHZW5lcmljQ29udGFpbmVyQ29tcG9uZW50LFxuICAgICAgICBNb2RhbENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBFbWJlZGRlZEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIEluY2x1ZGVDb21wb25lbnREaXJlY3RpdmUsXG4gICAgICAgIEdlbmVyaWNDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgIEVycm9yTWVzc2FnZXNDb21wb25lbnQsXG4gICAgICAgIE1vZGFsQ29tcG9uZW50LFxuICAgICAgICBDdXJyZW5jeUZvcm1hdFBpcGUsXG4gICAgICAgIE5nRm9yU2V0RGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbENvbXBvbmVudCxcbiAgICAgICAgQXdOYW1lRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NvcmVDb21wb25lbnRNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7RW52aXJvbm1lbnQsIG5vb3B9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogUGFyZW50IGNsYXNzIGZvciBhbGwgbW9kYWwgZGlhbG9ncy4gUHJvdmlkZXMgZGVmYXVsdHMgZnVuY3Rpb25hbGl0eSBmb3IgYWxsIG1vZGFscy5cbiAqL1xuZXhwb3J0IGNsYXNzIE1vZGFsQ29udGFpbmVyIGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZGVzdHJveTogKCkgPT4gdm9pZCA9IG5vb3A7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIGZ1bmN0aW9uIHRoYXQgY2xvc2VzIHRoZSBkaWFsb2cgYnkgY2FsbGluZyBkZXN0cm95IG9uIHRoZSBjb21wb25lbnQgcmVmZXJlbmNlLlxuICAgICAqIE1ldGhvZCBpbmhlcml0ZWQgYnkgYWxsIGl0cyBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBjbG9zZU1vZGFsKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtJbmplY3RhYmxlLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNCbGFuaywgaXNQcmVzZW50LCBpc1N0cmluZ01hcCwgaXNUeXBlLCBvYmplY3RUb05hbWV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG5cbi8qKlxuICogRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5IGFnZ3JlZ2F0ZXMgZGlmZmVyZW50IERhdGFQcm92aWRlcnMgcGVyIHR5cGUuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnlcbntcblxuICAgIC8qKlxuICAgICAqIE1hcHMgY2xhc3MgbmFtZSB0byBEYXRhUHJvdmlkZXIgaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdHJ5QnlQcm92aWRlcjogTWFwPHN0cmluZywgRGF0YVByb3ZpZGVyPGFueT4+O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXBzIGEgY2xhc3MgTmFtZSAgdG8gYWN0dWFsIHR5cGVcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdHJ5TmFtZVRvQ2xhc3M6IE1hcDxzdHJpbmcsIGFueT47XG5cblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlciA9IG5ldyBNYXA8c3RyaW5nLCBEYXRhUHJvdmlkZXI8YW55Pj4oKTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzID0gbmV3IE1hcDxzdHJpbmcsIGFueT4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgZXZlcnkgc2luZ2xlIHJlZ2lzdGVyZWQgRGF0YVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIHdlIGFsc28gbmVlZCBzdG9yZSBpdHMgcHJvdG90eXBlXG4gICAgICogaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBzdXBwb3J0IHNvbWUga2luZCBvZiBpbmhlcml0YW5jZS4gWW91IGNhbiByZWdpc3RlciBhIHByb3ZpZGVyIGZvclxuICAgICAqIGEgcGFyZW50IGNsYXNzIGlmIG5lZWRlZFxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJQcm92aWRlcjxUPiAodGFyZ2V0OiBhbnksIHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0YXJnZXQpIHx8ICghaXNTdHJpbmdNYXAodGFyZ2V0KSAmJiAhaXNUeXBlKHRhcmdldCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyBDYW5ub3QgcmVnaXN0ZXIgbm9uLW9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG5hbWUgPSBpc1R5cGUodGFyZ2V0KSA/IHRhcmdldC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSA6IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlci5zZXQobmFtZSwgcHJvdmlkZXIpO1xuXG4gICAgICAgIGxldCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLnNldChuYW1lLCBwcm90b3R5cGUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBiZXN0IG1hdGNoaW5nIHByb3ZpZGVyLiBJZiBub3QgZm91bmQgdGhlbiB1c2Ugb2JqZWN0IHByb3RvdHlwZSB0byBnZXQgaG9sZCBvZiBpdHNcbiAgICAgKiBwYXJlbnQgYW5kIHNlZSBpZiB0aGVyZSBpcyBhIHByb3ZpZGVyIHJlZ2lzdGVyZWQgb24gdGhpcyBsZXZlbFxuICAgICAqXG4gICAgICovXG4gICAgYmVzdE1hdGNoRm9yQ2xhc3M8VD4gKGNsYXNzTmFtZTogc3RyaW5nKTogRGF0YVByb3ZpZGVyPFQ+XG4gICAge1xuICAgICAgICBsZXQgcmVnaXN0ZXJlZENsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgbGV0IGNsYXNzUHJvdG8gPSB0aGlzLnJlZ2lzdHJ5TmFtZVRvQ2xhc3MuZ2V0KGNsYXNzTmFtZSk7XG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChyZWdpc3RlcmVkQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgbGV0IHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8VD4gPSB0aGlzLnJlZ2lzdHJ5QnlQcm92aWRlci5nZXQocmVnaXN0ZXJlZENsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQocHJvdmlkZXIpKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIudHlwZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdvIHVwIHRvIHBhcmVudFxuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChjbGFzc1Byb3RvKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2xhc3NQcm90byk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudE5hbWUgPSBvYmplY3RUb05hbWUoY2xhc3NQcm90byk7XG4gICAgICAgICAgICAgICAgcmVnaXN0ZXJlZENsYXNzTmFtZSA9XG4gICAgICAgICAgICAgICAgICAgIChpc1ByZXNlbnQocGFyZW50TmFtZSkgJiYgcGFyZW50TmFtZSAhPT0gcmVnaXN0ZXJlZENsYXNzTmFtZSkgPyBwYXJlbnROYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMgYmVzdE1hdGNoRm9yQ2xhc3MoKSB3aXRoIHRoZSBkaWZmZXJlbmNlIHRvIHBhc3MgYSB0eXBlLiBJZiB5b3Ugd2FudCB0b1xuICAgICAqIHN1cHBvcnQgb2JqZWN0IGluaGVyaXRhbmNlIHlvdSBuZWVkIHRoaXMuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGJlc3RNYXRjaEZvclR5cGU8VD4gKHR5cGU6IFR5cGU8VD4pOiBEYXRhUHJvdmlkZXI8VD5cbiAgICB7XG4gICAgICAgIGxldCBuYW1lOiBzdHJpbmcgPSBvYmplY3RUb05hbWUodHlwZSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RyeU5hbWVUb0NsYXNzLnNldChuYW1lLCB0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVzdE1hdGNoRm9yQ2xhc3M8VD4obmFtZSk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogUHJvdmlkZXIgaXMgYSBkYXRhIGRyaXZlciB0aGF0IGNhbiBhY2Nlc3MgZGF0YSBhbmQgcmV0cmlldmUgdGhlbS4gSXQga25vd3MgaG93IHRvIGdldCAxXG4gKiBvciBtb3JlIHJlY29yZHMsIG1heWJlIGRvIHBhZ2luZyBhbmQgc29tZSBvdGhlciB0aGluZ3MuXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRGF0YVByb3ZpZGVyPFQ+XG57XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXJyZW50IHR5cGUgZm9yIHRoaXMgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgdHlwZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogTm90aWZpZXMgYWxsIHRoZSBsaXN0ZW5lcnMgaW4gY2FzZSBvZiBkYXRhIGFyZSBhdmFpbGFibGUgb3IgaWYgdGhleSBjaGFuZ2VkIGR1ZSB0byBzb21lIHVzZXJcbiAgICAgKiBpbnRlcmFjdGlvbiAgKHNlYXJjaCwgYWRkaW5nIG9yIHJlbW92aW5nKS5cbiAgICAgKlxuICAgICAqL1xuICAgIGRhdGFDaGFuZ2VzOiBCZWhhdmlvclN1YmplY3Q8VFtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VFtdPihbXSk7XG5cbiAgICAvKipcbiAgICAgKiAgUmV0dXJuIHNpemUgb2YgdGhlIHNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgZXhwZWN0ZWRDb3VudCAocGFyYW1zPzogTWFwPHN0cmluZywgYW55Pik6IG51bWJlclxuICAgIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRm9yIHVzZSBjYXNlcyB3aGVyZSB3ZSBuZWVkIHRvIHJldHJpZXZlIGRhdGEgYmFzZWQgb24gc29tZSBjcml0ZXJpYSBlLmcuXG4gICAgICpcbiAgICAgKiAgLSBtYXggbnVtYmVyIG9mIHJlY29yZHNcbiAgICAgKiAgLSBzdXBwb3J0IHBhZ2luZyB3aXRoIG9mZnNldCBhbmQgbGltaXRcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIGJ5IGZldGNoXG4gICAgICovXG4gICAgYWJzdHJhY3QgZGF0YUZvclBhcmFtcyAocGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+KTogQXJyYXk8VD47XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmV0Y2hlcyBkYXRhIGZyb20gdW5kZXJseWluZyBkYXRhUHJvdmlkZXIuXG4gICAgICpcbiAgICAgKiBSZXBsYWNlbWVudCBmb3IgZGF0YWZvclBhcmFtc1xuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3QgZmV0Y2ggKHBhcmFtczogTWFwPHN0cmluZywgYW55Pik6IE9ic2VydmFibGU8VFtdPjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyBub24tYXN5bmMgY3VycmVudCBzdGF0ZSBvZiBkYXRhXG4gICAgICovXG4gICAgZGF0YSAoKTogQXJyYXk8VD5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGlzIERhdGFQcm92aWRlciBzdXBwb3J0cyBJTlNFUlQsIFJFTU9WRVxuICAgICAqXG4gICAgICovXG4gICAgY2FuQ1JVRCAoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhpcyBEYXRhUHJvdmlkZXIgc3VwcG9ydHMgcXVlcnkgY2FwYWJpbGl0eVxuICAgICAqXG4gICAgICovXG4gICAgY2FuUXVlcnkgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnQgdG8gc3VwcG9ydCBpbnNlcnRpb24uIEFmdGVyIHJlY29yZCBpcyBpbnNlcnRlZCBlbWl0IGV2ZW50IGZvciBkYXRhQ2hhbmdlcyB0b1xuICAgICAqIGluZm9ybSBhbGwgc3Vic2NyaWJlcnNcbiAgICAgKlxuICAgICAqL1xuICAgIGluc2VydCAob2JqOiBhbnkpOiB2b2lkXG4gICAge1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHN1cHBvcnQgcmVjb3JkIHJlbW92YWwuIEFmdGVyIHJlY29yZCBpcyByZW1vdmVkIGVtaXQgZXZlbnQgZm9yIGRhdGFDaGFuZ2VzIHRvXG4gICAgICogaW5mb3JtIGFsbCBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqL1xuICAgIHJlbW92ZSAob2JqOiBhbnkpOiB2b2lkXG4gICAge1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50IHRvIHByb3ZpZGUgYWNjZXNzIHRvIGxvdyBsZXZlbCBzZWFyY2cgQVBJLlxuICAgICAqXG4gICAgICovXG4gICAgcXVlcnkgKHBhcmFtczogTWFwPHN0cmluZywgc3RyaW5nPik6IHZvaWRcbiAgICB7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7RmllbGRQYXRoLCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtvZiBhcyBvYnNlcnZhYmxlT2YsIE9ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuXG5cbi8qKlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmb3IgQXJyYXlzLlxuICovXG5leHBvcnQgY2xhc3MgQXJyYXlEYXRhUHJvdmlkZXI8VD4gZXh0ZW5kcyBEYXRhUHJvdmlkZXI8VD5cbntcblxuICAgIGNvbnN0cnVjdG9yIChwcm90ZWN0ZWQgIHZhbHVlczogQXJyYXk8VD4pXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnR5cGUgPSBBcnJheTtcblxuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VzLm5leHQodGhpcy52YWx1ZXMpO1xuICAgIH1cblxuICAgIGV4cGVjdGVkQ291bnQgKHBhcmFtcz86IE1hcDxzdHJpbmcsIGFueT4pOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgZGF0YUZvclBhcmFtcyAocGFyYW1zPzogTWFwPHN0cmluZywgYW55Pik6IEFycmF5PFQ+XG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhwYXJhbXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLnZhbHVlcztcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmFtcykgJiYgcGFyYW1zLmhhcygnb2Zmc2V0JykgJiYgcGFyYW1zLmhhcygnbGltaXQnKSkge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHBhcmFtcy5nZXQoJ29mZnNldCcpO1xuICAgICAgICAgICAgbGV0IGxpbWl0ID0gcGFyYW1zLmdldCgnbGltaXQnKTtcblxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gKG9mZnNldCArIGxpbWl0KSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS5zbGljZShvZmZzZXQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbXMuaGFzKCdvcmRlcmJ5JykgJiYgcGFyYW1zLmhhcygnc2VsZWN0b3InKSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0KGRhdGEsIHBhcmFtcy5nZXQoJ29yZGVyYnknKSwgcGFyYW1zLmdldCgnc2VsZWN0b3InKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG5cbiAgICBmZXRjaCAocGFyYW1zOiBNYXA8c3RyaW5nLCBhbnk+KTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHRoaXMuZGF0YUZvclBhcmFtcyhwYXJhbXMpKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHNvcnRpbmcgY3VycmVudCBkYXRhc2V0IGJ5IG9uZSBjb2x1bW4gLyBrZXlcbiAgICAgKlxuICAgICAqIGZvciBzb3J0T3JkZXJpbmcgcGxlYXNlIHNlZSBEYXRhdGFibGUgYW5kIGl0cyBzb3J0T3JkZXJpbmdGb3JOdW1iZXIoKVxuICAgICAqXG4gICAgICogICAgICAxICA9IGFzY2VuZGluZ1xuICAgICAqICAgICAgLTEgPSBkZXNjZW5kaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBzb3J0IChhcnJheVRvU29ydDogYW55W10sIGtleTogc3RyaW5nLCBzb3J0T3JkZXI6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIGFycmF5VG9Tb3J0LnNvcnQoKGRhdGExOiBhbnksIGRhdGEyOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZTEgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhMSwga2V5KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTIgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShkYXRhMiwga2V5KTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUxID09IG51bGwgJiYgdmFsdWUyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAtMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUxICE9IG51bGwgJiYgdmFsdWUyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZTEgPT0gbnVsbCAmJiB2YWx1ZTIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZTEgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZTIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWUxLmxvY2FsZUNvbXBhcmUodmFsdWUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gKHZhbHVlMSA8IHZhbHVlMikgPyAtMSA6ICh2YWx1ZTEgPiB2YWx1ZTIpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAoc29ydE9yZGVyICogcmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhUHJvdmlkZXIsIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2lzQXJyYXksIGlzU3RyaW5nfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QXJyYXlEYXRhUHJvdmlkZXJ9IGZyb20gJy4vYXJyYXktZGF0YS1wcm92aWRlcic7XG5cblxuLyoqXG4gKiBQcm92aWRlcyB0b3AgbGV2ZWwgYWNjZXNzb3IgY2xhc3MgaW4gb3JkZXIgdG8gbWFrZSB7QGxpbmsgRGF0YVByb3ZpZGVyfSByZXRyaWV2YWwgcHJvY2VzcyBlYXNpZXIuXG4gKiBVc2luZyB7QGxpbmsgRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5fSB3ZSBlaXRoZXIgcmV0cmlldmUgcmVnaXN0ZXJlZCBpbnN0YW5jZSBvZiBjb25jcmV0ZVxuICogcHJvdmlkZXIgb3IgaW5zdGFudGlhdGUgb3VyIGltcGxpY2l0IHByb3ZpZGVyIGZvciBuYXRpdmUgdHlwZXMgc3VjaCBhcyBBcnJheS5cbiAqXG4gKlxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRGF0YVByb3ZpZGVyc1xue1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlZ2lzdHJ5OiBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnkpXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBiZXN0IG1hdGNoaW5nICBEYXRhUHJvdmlkZXIgb3IgY3JlYXRlIG5ldyBvbmUgaW4gY2FzZSBvZiBBcnJheVxuICAgICAqIE1vcmUgcm9vbSB0byByZWdpc3RlciBhbmQgaW5zdGFudGlhdGUgc29tZSBvdGhlciBpbXBsaWNpdCBQcm92aWRlcnNcbiAgICAgKi9cbiAgICBmaW5kKHRhcmdldDogYW55KTogRGF0YVByb3ZpZGVyPGFueT5cbiAgICB7XG4gICAgICAgIGlmIChpc0FycmF5KHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlEYXRhUHJvdmlkZXIodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N0cmluZyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeS5iZXN0TWF0Y2hGb3JDbGFzcyh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkuYmVzdE1hdGNoRm9yVHlwZSh0YXJnZXQpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIG5ldyBwcm92aWRlciB3aXRoaW4gRGF0YVR5cGVQcm92aWRlclJlZ2lzdHJ5XG4gICAgICpcbiAgICAgKi9cbiAgICByZWdpc3RlcjxUPih0YXJnZXQ6IGFueSwgcHJvdmlkZXI6IERhdGFQcm92aWRlcjxUPik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih0YXJnZXQsIHByb3ZpZGVyKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyfSBmcm9tICcuL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtJbmplY3RhYmxlLCBUeXBlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgYXNzZXJ0LFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0JsYW5rLFxuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNKc09iamVjdCxcbiAgICBpc1ByZXNlbnQsXG4gICAgaXNTdHJpbmcsXG4gICAgdW5pbXBsZW1lbnRlZFxufSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7b2YgYXMgb2JzZXJ2YWJsZU9mLCBPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7QXJyYXlEYXRhUHJvdmlkZXJ9IGZyb20gJy4vYXJyYXktZGF0YS1wcm92aWRlcic7XG5cblxuLyoqXG4gKlxuICogUHJvdmlkZXMgYSByZWdpc3RyeSBvZiBkaWZmZXJlbnQgZGF0YSBGaW5kZXJzIHVzZWQgbW9zdGx5IGJ5IERhdGFTb3VyY2VzLiBBbGwgRmluZGVycyBhcmVcbiAqIHJlZ2lzdGVyZWQgYnkgdGhpcyBjbGFzcyBhcyB3ZSBkb24ndCBoYXZlIGFueSBuZWVkcyByaWdodCBub3cgdG8gZXhwb3NlIHRoaXMgdG8gZGV2ZWxvcGVyLlxuICpcbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGFGaW5kZXJzIHtcblxuICAgIHByaXZhdGUgZmluZGVyc0J5VHlwZTogTWFwPERhdGFGaW5kZXIsIFR5cGU8RGF0YUZpbmRlcj4+ID0gbmV3IE1hcCgpO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuaW5pdEZpbmRlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgYmVzdCBtYXRjaGluZyBEYXRhRmluZGVyIGJhc2VkIG9uIHRoZSBvYmplY3QgdHlwZSBhbmQgcXVlcnlUeXBlLlxuICAgICAqL1xuICAgIGZpbmQoZm9yUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+LCBmb3JUeXBlOiBRdWVyeVR5cGUpOiBEYXRhRmluZGVyIHtcblxuICAgICAgICBsZXQgZmluZGVyTWF0Y2g6IFR5cGU8RGF0YUZpbmRlcj47XG4gICAgICAgIHRoaXMuZmluZGVyc0J5VHlwZS5mb3JFYWNoKCh2OiBUeXBlPERhdGFGaW5kZXI+LCBrOiBEYXRhRmluZGVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoay5hY2NlcHRzKGZvclByb3ZpZGVyLCBmb3JUeXBlKSkge1xuICAgICAgICAgICAgICAgIGZpbmRlck1hdGNoID0gdjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChmaW5kZXJNYXRjaCkpIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gbmV3IGZpbmRlck1hdGNoKCk7XG4gICAgICAgICAgICBjb3B5LmZvckRhdGEoZm9yUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRGaW5kZXJzKCkge1xuICAgICAgICAvLyBjcmVhdGUgYSBwcm90b3R5cGUgZm9yIGVhY2hcbiAgICAgICAgdGhpcy5maW5kZXJzQnlUeXBlLnNldChuZXcgRnVsbFRleHRBcnJheURhdGFGaW5kZXIoKSwgRnVsbFRleHRBcnJheURhdGFGaW5kZXIpO1xuXG4gICAgfVxufVxuXG4vKipcbiAqIFdlIGhhdmUgZGlmZmVyZW50IG9wdGlvbnMgaG93IHRvIHF1ZXJ5IGRhdGEuIEZ1bGxUZXh0IHVzZXMgYSBzdHJpbmcgd2hlcmUgcHJlZGljYXRlIGlzXG4gKiB1c2luZyBrZXk6dmFsdWUgcGFpciB0byBidWlsdCBhIHF1ZXJ5XG4gKi9cbmV4cG9ydCBlbnVtIFF1ZXJ5VHlwZSB7XG4gICAgRnVsbFRleHQsXG4gICAgUHJlZGljYXRlLFxuICAgIEZ1bGxUZXh0QW5kUHJlZGljYXRlXG59XG5cblxuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIG1hdGNoaW5nIGNhcGFiaWxpdHkgZm9yIGdpdmVuIERhdGFQcm92aWRlci5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERhdGFGaW5kZXIge1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBmaW5kIGNvbmNyZXRlIERhdGFGaW5kZXIgd2UgbmVlZCB0byBrbm93IHRoZSB0YXJnZXQgdHlwZSBhbmQgdGhlIHF1ZXJ5IHR5cGVcbiAgICAgKlxuICAgICAqL1xuICAgIGFjY2VwdHMoZm9yRGF0YTogRGF0YVByb3ZpZGVyPGFueT4sIGZvclR5cGU6IFF1ZXJ5VHlwZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZXRzIGEgRGF0YVByb3ZpZGVyIGZvciBEYXRhRmluZGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBmb3JEYXRhKHByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55Pik6IERhdGFGaW5kZXI7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExvb2t1cCBrZXkgdG8gYXBwbHkgd2hlbiBydW5uaW5nIG1hdGNoLiBJZGVhbGx5IHlvdXIgRFMgc2hvdWxkIGJlIGFibGUgdG8gc2V0IGxvb2t1cEtleVxuICAgICAqIGVpdGhlciBnbG9iYWxseSBmb3IgZ2l2ZW4gZGF0YVByb3ZpZGVyIG9yIGxvY2FsbHkgZXZlcnkgdGltZSB5b3UgcnVuIHNlYXJjaC4gVGhpcyBpcyBpblxuICAgICAqIGNhc2UgeW91IGhhdmUgbWFueSBjaG9vc2VycyBmb3IgdGhlIHNhbWUgdHlwZSBhbmQgeW91IHdhbnQgdGhlbSB0byBoYXZlIGRpZmZlcmVudCBsb29rdXBcbiAgICAgKiBrZXkuXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgYWJzdHJhY3Qgc2V0IGxvb2t1cEtleShrZXk6IHN0cmluZyk7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogTWF0Y2hpbmcgbWV0aG9kcyB3aGljaCBhcmUgZWl0aGVyIGFzeW5jIG9yIHN5bmNcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGluc3RhbnRNYXRjaDxUPihxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IFRbXTtcblxuICAgIGFic3RyYWN0IGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnM6IGFueVtdLCBxdWVyeTogYW55LCBtYXg6IG51bWJlcik6IFRbXTtcblxuXG4gICAgbWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIgPSAtMSk6IE9ic2VydmFibGU8VFtdPiB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG4gICAgbWF0Y2hXaXRoU2VsZWN0aW9uczxUPihzZWxlY3Rpb25zOiBhbnlbXSwgcXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICAgICAgICByZXR1cm4gdW5pbXBsZW1lbnRlZCgpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFNpbXBsZSBGdWxsVGV4dCBpbXBsZW1lbnRhdGlvbiBiYXNlZCBvbiBpbmZpeCBzdHJpbmcgbWF0Y2hpbmcgd2hpY2ggd29ya3Mgb24gdG9wIG9mXG4gKiBBcnJheURhdGFQcm92aWRlci5cbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRnVsbFRleHRBcnJheURhdGFGaW5kZXIgZXh0ZW5kcyBEYXRhRmluZGVyIHtcbiAgICAvKipcbiAgICAgKiAgSWYgbGlzdCB2YWx1ZSBpcyBvYmplY3Qgc2V0IGtleVBhdGggdG8gZ2V0IHRoZSBvYmplY3QgdmFsdWVcbiAgICAgKi9cbiAgICBfa2V5UGF0aDogRmllbGRQYXRoO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBEYXRhUHJvdmlkZXIgdXNlZCB0byBhY2Nlc3MgZGF0YVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfcHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuXG5cbiAgICBhY2NlcHRzKGZvckRhdGE6IERhdGFQcm92aWRlcjxhbnk+LCBmb3JUeXBlOiBRdWVyeVR5cGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZvckRhdGEgaW5zdGFuY2VvZiBBcnJheURhdGFQcm92aWRlciAmJiBmb3JUeXBlID09PSBRdWVyeVR5cGUuRnVsbFRleHQ7XG4gICAgfVxuXG4gICAgZm9yRGF0YShwcm92aWRlcjogRGF0YVByb3ZpZGVyPGFueT4pOiBGdWxsVGV4dEFycmF5RGF0YUZpbmRlciB7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldCBsb29rdXBLZXkoa2V5OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fa2V5UGF0aCA9IGlzUHJlc2VudChrZXkpID8gbmV3IEZpZWxkUGF0aChrZXkpIDogbnVsbDtcbiAgICB9XG5cbiAgICBpbnN0YW50TWF0Y2g8VD4ocXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBUW10ge1xuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuX3Byb3ZpZGVyKSwgJ01pc3NpbmcgRGF0YVByb3ZpZGVyJyk7XG5cbiAgICAgICAgbGV0IGxpc3QgPSB0aGlzLl9wcm92aWRlci5kYXRhRm9yUGFyYW1zKG5ldyBNYXAoKS5zZXQoJ2xpbWl0JywgbWF4KSk7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KGxpc3QsIHF1ZXJ5LCBtYXgpO1xuICAgIH1cblxuICAgIGluc3RhbnRNYXRjaFdpdGhTZWxlY3Rpb25zPFQ+KHNlbGVjdGlvbnM6IGFueVtdLCBxdWVyeTogc3RyaW5nLCBtYXg6IG51bWJlcik6IEFycmF5PFQ+IHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLl9wcm92aWRlciksICdNaXNzaW5nIERhdGFQcm92aWRlcicpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHF1ZXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdDogYW55W10gPSBbXTtcbiAgICAgICAgbGV0IHRvTG93ZXJQYXR0ZXJuID0gcXVlcnkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gc2VsZWN0aW9uc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoZXMoaXRlbSwgdG9Mb3dlclBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPj0gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2FybmluZzogSWYgeW91IGRvbnQgc3VwcGx5IHNlYXJjaCBLZXkgYW5kIHlvdSB3YW50IGZ1bGx0ZXh0IHNlYXJjaCBhbmQgeW91IHVzZSB0aGlzXG4gICAgICogZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBiZSBhd2FyZSB0aGF0IGl0IGNhbiAgcGVyZm9ybSBwb29ybHkgYXMgaXQgaXMgbmFpdmUgaW1wbGVtZW50YWlvblxuICAgICAqIHRoYXQgZG9lcyBub3QgZG8gZGVlcCBjb21wYXJlLlxuICAgICAqXG4gICAgICovXG4gICAgbWF0Y2hlczxUPihpdGVtOiBhbnksIHBhdHRlcm46IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgdmFsID0gKGlzUHJlc2VudCh0aGlzLl9rZXlQYXRoKSkgPyB0aGlzLl9rZXlQYXRoLmdldEZpZWxkVmFsdWUoaXRlbSkgOiBpdGVtO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbih2YWwpKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuY2FsbChpdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0pzT2JqZWN0KGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoaXRlbSkuZmlsdGVyKChrZXk6IHN0cmluZykgPT5cbiAgICAgICAgICAgICAgICBpc1ByZXNlbnQoaXRlbVtrZXldKSAmJiBpc1N0cmluZyhpdGVtW2tleV0pICYmIGl0ZW1ba2V5XVxuICAgICAgICAgICAgICAgICAgICAudG9Mb3dlckNhc2UoKS5pbmRleE9mKHBhdHRlcm4pICE9PSAtMSlcbiAgICAgICAgICAgICAgICAubGVuZ3RoID4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JsYW5rKHBhdHRlcm4pIHx8XG4gICAgICAgICAgICAgICAgaXNQcmVzZW50KHZhbCkgJiYgdmFsLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5pbmRleE9mKHBhdHRlcm4pID4gLTE7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG1hdGNoPFQ+KHF1ZXJ5OiBhbnksIG1heDogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZih0aGlzLmluc3RhbnRNYXRjaChxdWVyeSwgbWF4KSk7XG4gICAgfVxuXG4gICAgbWF0Y2hXaXRoU2VsZWN0aW9uczxUPihzZWxlY3Rpb25zOiBhbnlbXSwgcXVlcnk6IGFueSwgbWF4OiBudW1iZXIpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZU9mKHRoaXMuaW5zdGFudE1hdGNoV2l0aFNlbGVjdGlvbnMoc2VsZWN0aW9ucywgcXVlcnksIG1heCkpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge09ic2VydmFibGV9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtJbmplY3Rpb25Ub2tlbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3VuaW1wbGVtZW50ZWR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEYXRhRmluZGVyLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcblxuXG5leHBvcnQgY29uc3QgREFUQV9TT1VSQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48RGF0YVNvdXJjZT4oJ0RBVEFfU09VUkNFJyk7XG5cbi8qKlxuICogRGF0YVNvdXJjZSBkZXNjcmliZXMgYmFzaWMgZnVuY3Rpb25hbGl0eSBmb3IgaGFuZGxpbmcgc3RyZWFtIG9mIGRhdGEgc3BlY2lmaWMgdG8gY29tcG9uZW50XG4gKlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCBEYXRhU291cmNlIHdpbGwgYmUgZGVmaW5lZCBhcyBjb21wb25lbnQgcHJvdmlkZXIgdXNpbmdcbiAqXG4gKiBAQ29tcG9uZW50cyAoe1xuICogICAgICAuLi5cbiAqICAgICAgcHJvdmlkZXJzOltcbiAqXG4gKiAgICAgICAgICBwcm92aWRlOiBEQVRBX1NPVVJDRSwgdXNlQ2xhc3M6IENob29zZXJEYXRhU291cmNlUGxhaW5BcnJheUV4YW1wbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdXG4gKiAgICAgIF1cbiAqXG4gKiB9KVxuICpcbiAqXG4gKiBzbyBhbGwgdGhlIGRlcGVuZGVuY2llcyAoRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnMpIGFyZSBwcm9wZXJseSBpbmplY3RlZC5cbiAqXG4gKiBEYXRhUHJvdmlkZXIgdXNlcyBvcGVuKCkgbWV0aG9kIHRvIGJyb2FkY2FzdCBjaGFuZ2VzIHRvIGFsbCB0aGUgc3Vic2NyaWJlcnMgaW4gcmVhY3RpdmUgd2F5LlxuICogT3IgeW91IGNhbiB1c2UgaW5zdGFudCgpIG1ldGhvZCB0byByZXRyaWV2ZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgRGF0YVNvdXJjZSAoc3luYylcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBEYXRhU291cmNlXG57XG4gICAgc3RhdGljIHJlYWRvbmx5IE1heExlbmd0aCA9IDEwO1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhSZWNlbnRTZWxlY3RlZCA9IDU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEVhY2ggRGF0YVNvdXJjZSBoYXZlIGluamVjdGVkIERhdGFQcm92aWRlcnMgYW5kIERhdGFGaW5kZXJzIHRvIHJldHJpZXZlIGNvbmNyZXRlXG4gICAgICogaW1wbGVtZW50YXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkYXRhUHJvdmlkZXJzPzogRGF0YVByb3ZpZGVycywgcHJvdGVjdGVkIGZpbmRlcnM/OiBEYXRhRmluZGVycylcbiAgICB7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gaW5pdGlhbGl6ZSBkYXRhIHNvdXJjZSBhbmQgcGFzcyBzb21lIGFkZGl0aW9uYWwgdmFsdWVzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGFic3RyYWN0IGluaXQoLi4uYXJnczogYW55W10pOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRGF0YVByb3ZpZGVycyB3b3JrcyB3aXRoIHN0cmVhbSBvZiBkYXRhIGFuZCB0aGlzIG9wZW5zIHVwIHRoZSBjaGFubmVsIGluIG9yZGVyIHRvXG4gICAgICogbGlzdGVuIGFuZCByZWFjdCBmb3IgYW55IGNoYW5nZXMgdGhhdCBjb3VsZCBoYXBwZW4gaW5zaWRlIERhdGFQcm92aWRlclxuICAgICAqL1xuICAgIGFic3RyYWN0IG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIHN1YnNjcmlwdGlvbiB0byBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCBjbG9zZSgpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgZGF0YSBpbnN0YW50bHkgZnJvbSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgRGF0YVByb3ZpZGVyXG4gICAgICovXG4gICAgaW5zdGFudDxUPigpOiBUW11cbiAgICB7XG5cbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERTSW5pdFBhcmFtc1xue1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdmFsdWVzIG9yIHRoZSBvYmplY3QgdHlwZSBuYW1lIHdlIHdhbnQgdG8gcmVuZGVyXG4gICAgICovXG4gICAgb2JqPzogYW55O1xuXG4gICAgLyoqXG4gICAgICogV2hpY2ggZmluZCB3ZSB3YW50IHRvIGxvYWQgRnVsbFRleHQgb3IgUHJlZGljYXRlXG4gICAgICovXG4gICAgcXVlcnlUeXBlOiBRdWVyeVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDYW4gc3BlY2lmeSBsb29rdXAgS2V5IHRvIG5hcnJvdyBkb3duIHRoZSBzZWFyY2ggdG8gc3BlY2lmaWMgZmllbGQuIElmIGxvb2t1cCBrZXkgaXNcbiAgICAgKiBudWxsLCBpdGVtcyBhcmUgYXNzdW1lZCB0byBiZSBzdHJpbmdzXG4gICAgICovXG4gICAgbG9va3VwS2V5Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIENob29zZXIgaXMgc2luZ2xlIG9yIG11bHRpIHNlbGVjdFxuICAgICAqL1xuICAgIG11bHRpc2VsZWN0OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9uIHRvIHBhc3MgY3VzdG9tIERhdGFQcm92aWRlciBpbnN0ZWFkIGxldHRpbmcgRGF0YVByb3ZpZGVycyB0byBmaW5kIG1hdGNoXG4gICAgICovXG4gICAgZGF0YVByb3ZpZGVyPzogRGF0YVByb3ZpZGVyPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb24gdG8gcGFzcyBjdXN0b20gRGF0YUZpbmRlciBpbnN0ZWFkIGxldHRpbmcgRGF0YUZpbmRlcnMgdG8gZmluZCBtYXRjaFxuICAgICAqL1xuICAgIGRhdGFGaW5kZXI/OiBEYXRhRmluZGVyO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSG9zdEJpbmRpbmd9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIFdlIGFyZSB1c2luZyB0aGVzZSBjb21wb25lbnRzIGFzIGEgYmV0dGVyIHdheSBzZWxlY3RvcnMuXG4gKlxuICovXG5cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXRvcCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBUb3Bab25lQ29tcG9uZW50XG57XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIGNsYXNzTGlzdDogc3RyaW5nID0gJ3VpLWctMTIgdWktZy1ub3BhZCAnO1xufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbGVmdCcsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBMZWZ0Wm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xufVxuXG4vKipcbiAqIENvbW1vbiBjbGFzcyB1c2VkIHVzZWQgZm9yIEZpdmUgWm9uZSBsYXlvdXQuIFVzZWQgZm9yIHRoZSBuZy1jb250ZW50IHNlbGVjdG9yXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctbWlkZGxlJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIE1pZGRsZVpvbmVDb21wb25lbnRcbntcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJykgY2xhc3NMaXN0OiBzdHJpbmcgPSAndWktZy0xMiB1aS1tZC02IHVpLWxnLTQgdWktZy1ub3BhZCc7XG59XG5cblxuLyoqXG4gKiBDb21tb24gY2xhc3MgdXNlZCB1c2VkIGZvciBGaXZlIFpvbmUgbGF5b3V0LiBVc2VkIGZvciB0aGUgbmctY29udGVudCBzZWxlY3RvclxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJpZ2h0JyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIFJpZ2h0Wm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xuXG59XG5cbi8qKlxuICogQ29tbW9uIGNsYXNzIHVzZWQgdXNlZCBmb3IgRml2ZSBab25lIGxheW91dC4gVXNlZCBmb3IgdGhlIG5nLWNvbnRlbnQgc2VsZWN0b3JcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1ib3R0b20nLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQm90dG9tWm9uZUNvbXBvbmVudFxue1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICd1aS1nLTEyIHVpLWctbm9wYWQnO1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0FzeW5jVmFsaWRhdG9yRm4sIFZhbGlkYXRvckZuLCBWYWxpZGF0b3JzfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnQsIExpc3RXcmFwcGVyLCBTdHJpbmdXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Rm9ybVRhYmxlQ29tcG9uZW50fSBmcm9tICcuLi9mb3JtLXRhYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50LCBXaWRnZXRTaXplQ29sdW1uc30gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuLyoqXG4gKiBVc2VkIGJ5IEZvcm1UYWJsZSB0byBsYXlvdXQgZmllbGRzIGludG8gUm93cy4gRWFjaCBGb3JtVGFibGUgcm93IGlzIHJlYXNvbmFibGUgZm9yIG5vdCBvbmx5IHRvXG4gKiBpbmNsdWRlIGFjdHVhbCBjb21wb25lbnQgc3VjaCBpcyBEcm9wRG93biBvciBJbnB1dEZpZWxkIGJ1dCBtYWlubHkgcHJvdmlkZXMgYSBlbm91Z2ggY29udGV4dCBmb3JcbiAqIHRoZSBjb21wb25lbnQgdG8gc3BlY2lmeSB0aGUgc2l6ZSwgaG93IGl0IHNob3VsZCBsYXlvdXQsIHdoZXRoZXIgd2UgbmVlZCB0byBzaG93IHJlcXVpcmVkIGZsYWcsXG4gKiB0byBzaG93L2hpZGUgbGFiZWxzIGluIGNhc2UgaWYgd2UgaGF2ZSBubyBsYWJlbCBsYXlvdXQgYW5kIG11Y2ggbW9yZS5cbiAqXG4gKiBGb3JtUm93IGNvbXBvbmVudCBhbHNvIHJlZ2lzdGVycyBhbmd1bGFyIHZhbGlkYXRvciBmb3IgdGhlIGN1cnJlbnQgcm93L2ZpZWxkLiBBcyBhbHJlYWR5XG4gKiBtZW50aW9uZWQgV2UgdHJlYXQgb3VyIHdpZGdldHMgd2l0aCBtaW5pbWFsIHJlc3BvbnNpYmlsaXR5IGFzIHBvc3NpYmxlIHRvIHByZXNlbnQgYW5kIHJldHJpdmVcbiAqIGluZm9ybWF0aW9uIHRvL2Zyb20gdXNlciBhbmQgbGV0IHNvbWVib2R5IGVsc2UgdG8gZmlndXJlIG91dCB3aGVyZSBpdCBhcHBlYXIgYW5kIGhvdy5cbiAqXG4gKiB0b2RvOiBNb3ZlIHVuZGVyIEZvcm1UYWJsZVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWZvcm0tcm93JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCIhaGlkZGVuXCJcbiAgICAgY2xhc3M9XCJ3LWZvcm0tcm93IHVpLWdcIlxuICAgICBbY2xhc3MuaGlnaGxpZ2h0LXJvd109XCJoaWdobGlnaHRSb3dcIlxuICAgICBbY2xhc3MucmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICBbY2xhc3MubGFiZWwtb24tdG9wXT1cImxhYmVsc09uVG9wXCJcbiAgICAgW2NsYXNzLmxhYmVsLW9uLXNpZGVdPVwiIWxhYmVsc09uVG9wXCJcbiAgICAgW2NsYXNzLmhhcy1kYW5nZXJdPVwiIWZvcm1Db250cm9sLnZhbGlkICYmICFmb3JtQ29udHJvbC5wcmlzdGluZSBcIlxuICAgICBbbmdDbGFzc109XCJzdHlsZUNsYXNzXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiY29udHJvbC1sYWJlbCB1aS1nLTEyIHVpLWctbm9wYWRcIlxuICAgICAgICAgKm5nSWY9XCIhbm9MYWJlbExheW91dFwiXG4gICAgICAgICBbY2xhc3MudWktbWQtM109XCIhbGFiZWxzT25Ub3BcIj5cbiAgICAgICAgPGxhYmVsIFtjbGFzcy5zci1vbmx5XT1cIm5vTGFiZWxMYXlvdXRcIj57e2xhYmVsfX08L2xhYmVsPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImNvbnRyb2wtdmFsdWUgdWktZy1ub3BhZFwiIFtuZ0NsYXNzXT1cInNpemVcIlxuICAgICAgICAgW2NsYXNzLnJlYWQtb25seV09XCIhZWRpdGFibGVcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8YS1lcnJvci1tZXNzYWdlcyBbY29udHJvbF09XCJmb3JtQ29udHJvbFwiPjwvYS1lcnJvci1tZXNzYWdlcz5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnJlcXVpcmVkIGxhYmVsOmFmdGVye2NvbnRlbnQ6XCIqXCI7Y29sb3I6cmVkfS9kZWVwLyAuaGlnaGxpZ2h0LXJvd3tiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y4ZmF9LnctZm9ybS1yb3cuaGlnaGxpZ2h0LXJvd3tiYWNrZ3JvdW5kLWNvbG9yOiNmN2Y4ZmF9LnctZm9ybS1yb3cubGFiZWwtb24tdG9we3BhZGRpbmctYm90dG9tOjEzcHh9LnctZm9ybS1yb3cubGFiZWwtb24tdG9wIC5jb250cm9sLWxhYmVsLC53LWZvcm0tcm93LmxhYmVsLW9uLXRvcCAuY29udHJvbC12YWx1ZXtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjB9LnctZm9ybS1yb3cubGFiZWwtb24tdG9wIC5jb250cm9sLWxhYmVse3BhZGRpbmctYm90dG9tOjEycHh9LnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC1sYWJlbCwudy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLXZhbHVle3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MH0udy1mb3JtLXJvdy5sYWJlbC1vbi1zaWRlIC5jb250cm9sLWxhYmVsIDo6bmctZGVlcCAudy1zdHJpbmctZmllbGQsLnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC12YWx1ZSA6Om5nLWRlZXAgLnctc3RyaW5nLWZpZWxke2xpbmUtaGVpZ2h0OjM2cHh9LnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC1sYWJlbCA6Om5nLWRlZXAgLnNhcC1pY29uLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgOjpuZy1kZWVwIC5zYXAtaWNvbntsaW5lLWhlaWdodDoyNnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwgbGFiZWwsLnctZm9ybS1yb3cubGFiZWwtb24tc2lkZSAuY29udHJvbC12YWx1ZSBsYWJlbHtsaW5lLWhlaWdodDozNnB4fS53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtbGFiZWwgLmZhLC53LWZvcm0tcm93LmxhYmVsLW9uLXNpZGUgLmNvbnRyb2wtdmFsdWUgLmZhe2xpbmUtaGVpZ2h0OjE4cHh9LmNvbnRyb2wtbGFiZWx7Y29sb3I6IzYzNjM2M30udS12YWxpZGF0aW9uLWVycm9ye2JvcmRlci1jb2xvcjpyZWR9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGb3JtUm93Q29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vTGFiZWxMYXlvdXQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgcm93IHdpdGggaGlnaGxpZ2h0ZWQgYmFja2dyb3VuZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBoaWdobGlnaHRSb3c6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIEZpZWxkIGxhYmVsIHRoYXQgc2hvdWxkIGFwcGVhciBhYm92ZSBvciBuZXh0IHRvIHRoZSBjb250cm9sXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxhYmVsOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciB2YWxpZGF0b3JzLCBtYXhpbWFsIGxlbmd0aCBvZiB0aGUgZmllbGRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1heExlbmd0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogIEZvciBpbnB1dHMgdHlwZSBmaWVsZHMgcHJvdmlkZXMgZGVmYXVsdCBhbmd1bGFyIHZhbGlkYXRvcnMsIG1pbmltYWwgbGVuZ3RoIG9mIHRoZSBmaWVsZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluTGVuZ3RoOiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqICBGb3IgaW5wdXRzIHR5cGUgZmllbGRzIHByb3ZpZGVzIGRlZmF1bHQgYW5ndWxhciBmb3JtYXR0ZXJzLiBIb3cgdGhlIGlucHV0IGZpZWxkcyBzaG91bGQgYmVcbiAgICAgKiBmb3JtYXR0ZWRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXN0b20gYXN5bmMgdmFsaWRhdG9ycyB3aGljaCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBDb250cm9sXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjdXN0b21Bc3luY1ZhbGlkYXRvcnM6IEFzeW5jVmFsaWRhdG9yRm5bXTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VzdG9tICB2YWxpZGF0b3JzIHdoaWNoIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIENvbnRyb2xcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1c3RvbVZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW107XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGlzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIGZpZWxkLiBDdXJyZW50IHdlIHN1cHBvcnQgNCBkaWZmZXJlbnQgc2l6ZXM6IHgtc21hbGwsIHNtYWxsLFxuICAgICAqIG1lZGl1bSwgbGFyZ2UsIHgtbGFyZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIF9zaXplOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZvciBzaW5nbGUgY29sdW1uIGxheW91dCB3aXRob3V0IHpvbmVzIHdlIG5lZWQgdG8gYXBwbHkgZ3JpZCBkaXJlY3RseSB0byB0aGUgRm9ybVJvdyB0YWdcbiAgICAgKiBzbyB3ZSBkb24ndCBuZWVkIHRvIGludHJvZHVjZSBleHRyYSBkaXYgbGV2ZWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKSBjbGFzc0xpc3Q6IHN0cmluZyA9ICcnO1xuXG5cbiAgICBwcml2YXRlIF9sYWJlbHNPblRvcDogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIC8vIEV2ZW50IHRoaXMgY3JlYXRlcyBDSSBkZXBlbmRzLiBOZWVkIHRvIGhhdmUgYSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICAgICAgICAgICAgLy8gSSBuZWVkIHRvIHJlZmFjdG9yIG1vcmUgcGFyZW50IHRvIG5vdCB1c2UgdGhpcyBjaGlsZCBhbmQgcmVmYWN0b3IgbGF5b3V0aW5nXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1UYWJsZUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogRm9ybVRhYmxlQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcblxuICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtJyArIFdpZGdldFNpemVDb2x1bW5zLm1lZGl1bTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJpZ2h0IG5vdyB3ZSBqdXN0IGluaXRpYWxpemUgdGhpcyBvbmNlIGFuZCB1c2UgdGhlIHZhbHVlcyB3ZSBkbyBub3QgZXhwZWN0IG5vdyB0byByZWFjdCB0b1xuICAgICAqIGNoYW5nZXNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbChudWxsKTtcblxuICAgICAgICB0aGlzLnJlZ2lzdGVyVmFsaWRhdG9ycygpO1xuXG4gICAgICAgIHRoaXMub21pdFBhZGRpbmcgPSB0aGlzLnBhcmVudENvbnRhaW5lci5vbWl0UGFkZGluZztcbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgKz0gaXNQcmVzZW50KHRoaXMucGFyZW50Q29udGFpbmVyKSA/ICcgdWktZy0xMiAnIDogJyc7XG4gICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5oaWdobGlnaHRSb3cgPyB0aGlzLmNsYXNzTGlzdCArICcgaGlnaGxpZ2h0LXJvdyAnIDogdGhpcy5jbGFzc0xpc3Q7XG5cbiAgICAgICAgdGhpcy5jbGFzc0xpc3QgPSB0aGlzLm9taXRQYWRkaW5nID8gdGhpcy5jbGFzc0xpc3QgKyAnIHVpLWctbm9wYWQgJyA6IHRoaXMuY2xhc3NMaXN0O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSnVzdCBhIHNpemUgZ2V0dGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQSBzaXplIHNldHRlciB3ZSB0cmFuc2xhdGUgY3VzdG9tIHNpemVzIGludG8gYWN0dWFsIGJvb3RzdHJhcCBncmlkIHN5c3RlbS4gV2UgdXNlIG1lZGl1bVxuICAgICAqIHJpZ2h0IG5vdy4gYnV0IHdlIHNob3VsZCBleHRlbmQgdGhpcyBmb3Igb3RoZXIgc2NyZWVuIHNpemVzXG4gICAgICpcbiAgICAgKiAgdG9kbzogcHJvdmlkZSBtYXBwaW5nIGFuZCBhZGQgb3RoZXIgZ3JpZCBjbGFzc2VzIGZvciBvdGhlciBzaXplcyB4cywgc20sIGxnLCB4bFxuICAgICAqXG4gICAgICogIEFsc28gY2hlY2sgaWYgdGhpcyBpcyBkeW5hbWljIHNpemUgdGhhdCBzaG91bGQgdmFyeSBiYXNlZCBvbiB0aGUgaG93IG1hbnkgbnVtYmVyIG9mIGNvbHVtbnNcbiAgICAgKiB3ZSBoYXZlLiBlLmcuIERhdGUgd2lkZ2V0cyBpcyBieSBkZWZhdWx0IHNtYWxsLCBidXQgaW4gMiwgMyBjb2x1bW5zIGxheW91dCB0aGlzIHNtYWxsIGlzIHRvb1xuICAgICAqIHNtYWxsLlxuICAgICAqL1xuXG5cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHNpemUodmFsdWU6IHN0cmluZykge1xuXG4gICAgICAgIGxldCBpc0R5blZhbCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChTdHJpbmdXcmFwcGVyLnN0YXJ0c1dpZHRoKHZhbHVlLCAnZC0nKSkge1xuICAgICAgICAgICAgaXNEeW5WYWwgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHIoMiwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbGV0IGRTaXplID0gdGhpcy5keW5TaXplKHZhbHVlLCBpc0R5blZhbCk7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gJ3VpLWctMTIgdWktbWQtJyArIGRTaXplO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ0RvQ2hlY2soKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nRG9DaGVjaygpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpICYmIHRoaXMuZWRpdGFibGUgIT09IHRoaXMucGFyZW50Q29udGFpbmVyLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRhYmxlID0gdGhpcy5wYXJlbnRDb250YWluZXIuZWRpdGFibGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQdXNoIG91dCBvZiBib3ggYW5ndWxhciB2YWxpZGF0b3IgYXMgd2VsbCBhcyBjdXN0b20gb25lIHRvIGN1cnJlbnQgRm9ybUNvbnRyb2xcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlZ2lzdGVyVmFsaWRhdG9ycygpIHtcbiAgICAgICAgbGV0IHZhbGlkYXRvcnM6IFZhbGlkYXRvckZuW10gPSBbXTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubWF4TGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWF4TGVuZ3RoKHRoaXMubWF4TGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubWluTGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMubWluTGVuZ3RoKHRoaXMubWluTGVuZ3RoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucmVxdWlyZWQpICYmIHRoaXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcnMucHVzaChWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFsaWRhdG9ycy5wdXNoKFZhbGlkYXRvcnMucGF0dGVybih0aGlzLnBhdHRlcm4pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY3VzdG9tVmFsaWRhdG9ycykpIHtcbiAgICAgICAgICAgIExpc3RXcmFwcGVyLmFkZEFsbCh2YWxpZGF0b3JzLCB0aGlzLmN1c3RvbVZhbGlkYXRvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbGlkYXRvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbGlkYXRvcnModmFsaWRhdG9yc1swXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsaWRhdG9ycy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbGlkYXRvcnMoVmFsaWRhdG9ycy5jb21wb3NlKHZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpICYmIHRoaXMuY3VzdG9tQXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnModGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnNbMF0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmN1c3RvbUFzeW5jVmFsaWRhdG9ycykgJiYgdGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMoXG4gICAgICAgICAgICAgICAgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmModGhpcy5jdXN0b21Bc3luY1ZhbGlkYXRvcnMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEbyB3ZSBoYXZlIGxhYmVscyBvbiBUT1AsIHRyeSB0byByZWFkIHRoaXMgZnJvbSBQYXJlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBsYWJlbHNPblRvcCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fbGFiZWxzT25Ub3ApICYmIGlzUHJlc2VudCh0aGlzLnBhcmVudENvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiAoPEZvcm1UYWJsZUNvbXBvbmVudD50aGlzLnBhcmVudENvbnRhaW5lcikuaXNMYWJlbHNPblRvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FuIHJlZmFjdG9yIGFsbCBpbnRvIDEgbGluZSBidXQgaXRzIGhhcmQgdG8gZGVidWcgc28gdGhpcyBpcyBqdXN0IGZvciByZWFkXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGR5blNpemUodmFsdWU6IHN0cmluZywgaXNEeW5WYWx1ZTogYm9vbGVhbik6IHN0cmluZyB7XG4gICAgICAgIGxldCBub3JtYWxpemVTaXplID0gdmFsdWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCctJywgJycpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5wYXJlbnRDb250YWluZXIpICYmXG4gICAgICAgICAgICAoPEZvcm1UYWJsZUNvbXBvbmVudD50aGlzLnBhcmVudENvbnRhaW5lcikuaGFzVHdvQ29sdW1uICYmIGlzRHluVmFsdWUpIHtcblxuICAgICAgICAgICAgbGV0IGVudW1WYWx1ZXM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXMoV2lkZ2V0U2l6ZUNvbHVtbnMpO1xuICAgICAgICAgICAgbm9ybWFsaXplU2l6ZSA9IGVudW1WYWx1ZXNbZW51bVZhbHVlcy5pbmRleE9mKG5vcm1hbGl6ZVNpemUpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICg8YW55PldpZGdldFNpemVDb2x1bW5zKVtub3JtYWxpemVTaXplXTtcblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgU2ltcGxlQ2hhbmdlc1xufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge1xuICAgIEJvdHRvbVpvbmVDb21wb25lbnQsXG4gICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgVG9wWm9uZUNvbXBvbmVudFxufSBmcm9tICcuLi9maXZlLXpvbmUtbGF5b3V0LmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4vZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBGb3JtVGFibGUgaXMgYSBzcGVjaWZpYyBsYXlvdXQgY29tcG9uZW50IGZvciByZW5kZXJpbmcgTGFiZWxzIGFuZCBpdHMgY29udHJvbHMgaW4gdHdvIGNvbHVtbnNcbiAqIGFuZCA1IGRpZmZlcmVudCB6b25lcy5cbiAqXG4gKiBXZSBzdXBwb3J0IExFRlQsIE1JRERMRSwgUklHSFQsIFRPUCwgQk9UVE9NIHpvbmUgd2hlcmUgd2UgY2FuIHBsYWNlIG91ciBjb21wb25lbnQgb3Igd2lkZ2V0cy5cbiAqIFRoaXNcbiAqIGNvbXBvbmVudCBpcyB1c2VkIGFzIHByaW1hcnkgbGF5b3V0IHRvIHdyYXAgYWxsIHRoZSBjb21tb24gdXNlIGNhc2VzLiBFLmcuIFdoZW4gd2UgbGF5IG91dFxuICogZmllbGRzIGluIHRoZSBmb3JtIEkgZG8gbm90IHdhbnQgY29udHJvbHMgdG8gYmUgYXdhcmUgb2YgZXJyb3IgdmFsaWRhdGlvbiwgc2l6ZSwgbGFiZWxzLCBhbmRcbiAqIHNvbWUgb3RoZXIgdGhpbmdzLiBDb250cm9sIHN1Y2ggSU5QVVQgaXMganVzdCByZXNwb25zaWJsZSBmb3IgcmV0cmlldmUgdXNlciB2YWx1ZSBidXQgbm90IGhvdyBpdFxuICogYXBwZWFyIG9uIHRoZSBwYWdlLlxuICpcbiAqIFRoaXMgd2F5IHdlIGNhbiBiZSBmbGV4aWJsZSBob3cgd2UgdHJlYXQgd2lkZ2V0cyBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIHNpdHVhdGlvbiBkZXBlbmRpbmdcbiAqIHdoZXJlIHRoZXkgYXBwZWFyXG5cbiAqIEZvcm1UYWJsZSBqdXN0IGxpa2UgdGhlIHJlc3Qgb2YgdGhlIGNvbXBvbmVudHMgYXJlIHVzaW5nIE1vZGVsIGRyaXZlbiBhcHByb2FjaCBob3cgdG8gd29yayB3aXRoXG4gKiBkYXRhLCBtZWFuIHdlIGFyZSB1c2luZyBGb3JtR3JvdXAsIEZvcm1Db250cm9sIGV0Yy4gRm9ybUdyb3VwIGNhbiBiZSBwYXNzZWQgaW50byB0aGUgRm9ybVRhYmxlLFxuICogb3RoZXJ3aXNlIGl0cyBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgd2hlbiB0aGUgRm9ybVRhYmxlIGlzIGluc3RhbnRpYXRlZC5cbiAqXG4gKiBGb3JtR3JvdXAgaXMgc2F2ZWQgaW5zb2RlIEVudmlyb25tZW50IHdoZXJlIHdlIGFyZSB1c2luZyB0aGlzIHRvIHBhc3MgdGhpcyBhcm91bmQgdGhlIHBhZ2VzIGFuZFxuICogY29tcG9uZW50cy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIFNpbXBsZSBMYXlvdXQgZmllbGRzIGFuZCBpdHMgY29udHJvbFxuICpcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnd3JhcHBlci1jb21wJyAsXG4gKiAgICAgIHRlbXBsYXRlOiBgXG4gKiAgXHRcdFx0PGF3LWZvcm0tdGFibGUgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIiAob25TdWJtaXQpPT5cbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ25hbWUnXCIgW25hbWVdPVwiJ25hbWUnXCI+XG4gKiAgXHRcdFx0XHRcdDxhdy1pbnB1dC1maWVsZCBbdHlwZV09XCInc3RyaW5nJ1wiPjwvYXctaW5wdXQtZmllbGQ+XG4gKiAgXHRcdFx0XHQ8L2F3LWZvcm0tcm93PlxuICpcbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1ByZWZlcnJlZCBDb2xvcnMnXCIgW25hbWVdPVwiJ215Q29sb3JzJ1wiPlxuICogIFx0XHRcdFx0XHQ8YXctY2hlY2tib3gtbGlzdCBbbGlzdF09XCJjaGVja0JveExpc3RWYWx1ZXNcIlxuICogIFx0XHRcdFx0XHQgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25zXT1cInNlbGVjdGVkVmFsdWVzXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICBbbGF5b3V0XT1cIidpbmxpbmUnXCJcbiAqICBcdFx0XHRcdFx0ICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25DQkNsaWNrKCRldmVudClcIj5cbiAqICBcdFx0XHRcdFx0PC9hdy1jaGVja2JveC1saXN0PlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0dlbmRlcidcIiBbbmFtZV09XCInZ2VuZGVyJ1wiPlxuICpcbiAqICBcdFx0XHRcdFx0PGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwicmJWYWx1ZXNcIiBbc2VsZWN0aW9uXT1cInJiU2VsZWN0aW9uXCI+XG4gKlxuICogIFx0XHRcdFx0XHQ8L2F3LXJhZGlvYnV0dG9uLWxpc3Q+XG4gKlxuICogIFx0XHRcdFx0PC9hdy1mb3JtLXJvdz5cbiAqICBcdFx0XHRcdDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ015IGJpcnRoZGF0ZSdcIiBbbmFtZV09XCInYmlydGhEYXRlJ1wiIFtzaXplXT1cIidzbWFsbCdcIj5cbiAqXG4gKiAgXHRcdFx0XHRcdDxhdy1kYXRlLXRpbWUgW3ZhbHVlXT1cImRhdGVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIiBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIj5cbiAqICBcdFx0XHRcdFx0PC9hdy1kYXRlLXRpbWU+XG4gKiAgXHRcdFx0XHQ8L2F3LWZvcm0tcm93PlxuICogIFx0XHRcdDwvYXctZm9ybS10YWJsZT5cbiAqICAgIGBcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBTaG93VXNlckluZm9Db21wb25lbnRcbiAqICB7XG4gKiAgICAgICBjaGVja0JveExpc3RWYWx1ZXM6IHN0cmluZ1tdID0gWydibHVlJyAsICdyZWQnICwgJ3llbGxvdycgLCAnb3JhbmdlJyAsICd3aGl0ZScgLCAnc2lsdmVyJ1xuICogICAgICwgJ2JsYWNrJyAsICdHcmVlbidcbiAqICAgICAsICdHcmF5JyAsICdOYXZ5JyAsXG4gKiAgICAgICAgICAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddO1xuICogICAgICBzZWxlY3RlZFZhbHVlczogc3RyaW5nW10gPSBbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqICAgICAgcmJWYWx1ZXM6IHN0cmluZ1tdID0gWydtYWxlJyAsICdmZW1hbGUnICwgJ290aGVyJ107XG4gKiAgICAgIHJiU2VsZWN0aW9uOiBzdHJpbmcgPSAnbWFsZSc7XG4gKiAgICAgIGVkaXRhYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAqICAgICAgc2hvd1RpbWU6IGJvb2xlYW4gPSB0cnVlO1xuICpcbiAqICAgICAgZm9ybUdyb3VwOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqXG4gKlxuICogICAgICBvbkNCQ2xpY2sgKGV2ZW50KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnb25DQkNsaWNrID0gJyArIGV2ZW50KTtcbiAqICAgICAgfVxuICpcbiAqICAgICAgb25TdWJtaXQgKG1vZGVsOiBhbnkpOiB2b2lkXG4gKiAgICAgIHtcbiAqICAgICAgICAgY29uc29sZS5sb2cobW9kZWwpXG4gKlxuICogICAgICAgICAvLyB3aWxsIHByaW50IHsgbmFtZTpudWxsLCBteUNvbG9yczpbJ2JsdWUnICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXSwgZ2VuZGVyOlxuICogICAgIG1hbGV9XG4gKiAgICAgIH1cbiAqXG4gKiAgfVxuICpcbiAqICBgYGBcbiAqXG4gKiAgT3IgeW91IGNhbiB1c2Ugem9uZSB0byBsYXlvdXQgdGhlc2UgZmllbGRzIGludG8gdHdvIGNvbHVtbnM6XG4gKlxuICogIEN1cnJlbnQgem9uZXMgYXJlIGltcGxlbWVudCB3aXRoIDxuZy1jb250ZW50IFNFTEVDVD4gd2hpY2ggaXMganVzdCBhIHNlbGVjdG9yIHRvIHNlYXJjaGVzIGZvclxuICogICAgIHNwZWNpZmljIHBhdHRlcm4uIEluIG91ciBjYXNlIGluc3RlYWQgb2YgY3JlYXRpbmcgZXh0cmEgd3JhcHBlciBjdXN0b20gY29tcG9uZW50IHVzZSBzaW1wbGVcbiAqICAgICBDU1MgY2xhc3NcbiAqXG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctZm9ybS10YWJsZSAjbWV0YUZvcm1UYWJsZSBbZWRpdGFibGVdPVwiZWRpdGluZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgW3VzZUZpdmVab25lXT1cImlzRml2ZVpvbmVMYXlvdXRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvblN1Ym1pdCk9XCJvblNhdmVBY3Rpb24oJGV2ZW50KVwiPlxuICpcbiAqICAgICAgICAgICAgICAgIDxhdy1sZWZ0ICAqbmdJZj1cImNhblNob3dab25lKCd6TGVmdCcpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YXctZm9ybS1yb3cgW2xhYmVsXT1cIiduYW1lJ1wiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWlucHV0LWZpZWxkIFt0eXBlXT1cIidzdHJpbmcnXCI+PC9hdy1pbnB1dC1maWVsZD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1mb3JtLXJvdz5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ1ByZWZlcnJlZCBDb2xvcnMnXCIgW25hbWVdPVwiJ215Q29sb3JzJ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWNoZWNrYm94LWxpc3QgW2xpc3RdPVwiY2hlY2tCb3hMaXN0VmFsdWVzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbnNdPVwic2VsZWN0ZWRWYWx1ZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbGF5b3V0XT1cIidpbmxpbmUnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uQ0JDbGljaygkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWNoZWNrYm94LWxpc3Q+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICA8L2F3LWxlZnQ+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgIDxhdy1yaWdodCAgKm5nSWY9XCJjYW5TaG93Wm9uZSgnelJpZ2h0JylcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInR2VuZGVyJ1wiIFtuYW1lXT1cIidnZW5kZXInXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwicmJWYWx1ZXNcIiBbc2VsZWN0aW9uXT1cInJiU2VsZWN0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInTXkgYmlydGhkYXRlJ1wiIFtuYW1lXT1cIidiaXJ0aERhdGUnXCJcbiAqICAgICBbc2l6ZV09XCInc21hbGwnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGF0ZS10aW1lIFt2YWx1ZV09XCJkYXRlXCIgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAqICAgICBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGF0ZS10aW1lPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tcm93PlxuICogICAgICAgICAgICAgICAgPC88YXctcmlnaHQ+XG4gKiAgICAgICAgICAgIDwvYXctZm9ybS10YWJsZT5cbiAqXG4gKiAgYGBgXG4gKlxuICogIHRvZG86IHJlbW92ZSBteSBjc3Mgc2VsZWN0b3JzIGZvciB6b25lcyBhbmQgcmVwbGFjZSBpdCB3aXRoIHJlYWwgY29tcG9uZW50IGV2ZW4ganVzdCBhIHRhZ1xuICogIHRvZG86IHdvdWxkIHdvcmsgZmlsZVxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1mb3JtLXRhYmxlJyxcbiAgICB0ZW1wbGF0ZTogYDxmb3JtIGNsYXNzPVwidy1mb3JtLXRhYmxlIHVpLWcgdWktZmx1aWRcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiXG4gICAgICBbbmdDbGFzc109XCJzdHlsZUNsYXNzXCJcbiAgICAgIChuZ1N1Ym1pdCk9XCJvblN1Ym1pdEZvcm0oZm9ybUdyb3VwLnZhbHVlKVwiIG5vdmFsaWRhdGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1nLW5vcGFkXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cbjwvZm9ybT5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2UtY29udGFpbmVyPmZvcm17bWFyZ2luLXRvcDoxZW19LnctZm9ybS10YWJsZSBidXR0b257ZmxvYXQ6cmlnaHR9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybVRhYmxlQ29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEZvcm1UYWJsZUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgdGhlIGZvcm0gbGF5b3V0IHRvIHNlZSBpZiB3ZSBuZWVkIHRvIHJlbmRlciBsYWJlbHMgc3RhY2tlZCAgb3Igc2lkZSBieSBzaWRlIG5leHQgdG9cbiAgICAgKiB0aGUgY29udHJvbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbHNPblRvcD86IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyB0aGlzIGEgNCB6b25lIGxheW91dFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB1c2VGaXZlWm9uZT86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZvciBjZXJ0YWluIHVzZWNhc2Ugd2UgZG9udCB3YW50IHRvIHNldCBhdXRvbWF0aWNhbGx5IHRoaXMgdG8gYWxsIGNoaWxkcmVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBlZGl0YWJpbGl0eUNoZWNrOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqICBUcmlnZ2VycyB3aGVuIHRoZSA8Zm9ybT4gaXMgc3VibWl0dGVkLiBvblN1Ym1pdCB3ZSBlbWl0IHRoZSB3aG9sZSBmb3JtQ29udHJvbGxlciBvYmplY3RzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU3VibWl0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlc2UgcHJvcGVydGllcyByZXByZXNlbnQgaW5kaXZpZHVhbCB6b25lcyBhbmQgd2UgdXNlIHRoZW0gdG8gYWRqdXN0IG91ciBjb2x1bW4gZ3JpZFxuICAgICAqIGxheW91dFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoTGVmdFpvbmVDb21wb25lbnQpIGxlZnRab25lOiBMZWZ0Wm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoTWlkZGxlWm9uZUNvbXBvbmVudCkgbWlkZGxlWm9uZTogTWlkZGxlWm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoUmlnaHRab25lQ29tcG9uZW50KSByaWdodFpvbmU6IFJpZ2h0Wm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoVG9wWm9uZUNvbXBvbmVudCkgdG9wWm9uZTogVG9wWm9uZUNvbXBvbmVudDtcblxuICAgIEBDb250ZW50Q2hpbGQoQm90dG9tWm9uZUNvbXBvbmVudCkgYm90dG9tWm9uZTogQm90dG9tWm9uZUNvbXBvbmVudDtcblxuXG4gICAgQENvbnRlbnRDaGlsZHJlbihCYXNlRm9ybUNvbXBvbmVudCwge2Rlc2NlbmRhbnRzOiB0cnVlfSlcbiAgICBmb3JtRmllbGRzOiBRdWVyeUxpc3Q8QmFzZUZvcm1Db21wb25lbnQ+O1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpLCB7ZGVzY2VuZGFudHM6IHRydWV9KVxuICAgIHJvd3M6IFF1ZXJ5TGlzdDxGb3JtUm93Q29tcG9uZW50PjtcblxuXG4gICAgLyoqXG4gICAgICogQ2FjaGUgY2FsY3VsYXRlZCBwcm9wZXJ0aWVzIHdoZW4gaW5pdCB0aGlzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgaGFzT25lQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGFzVHdvQ29sdW1uOiBib29sZWFuID0gZmFsc2U7XG4gICAgaGFzVGhyZWVDb2x1bW46IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIG51bGwpO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlc1snZWRpdGFibGUnXSkgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ2VkaXRhYmxlJ10ucHJldmlvdXNWYWx1ZSAhPT0gY2hhbmdlc1snZWRpdGFibGUnXS5jdXJyZW50VmFsdWUpIHtcblxuICAgICAgICAgICAgdGhpcy51cGRhdGVGb3JtRmllbGRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIG9uU3VibWl0Rm9ybShldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5vblN1Ym1pdC5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEFyZSBsYWJlbHMgb24gdG9wXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0xhYmVsc09uVG9wKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsc09uVG9wO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IGNoaWxkIGNvbXBvbmVudCB0byBpbmhlcml0IGVkaXRhYmlsaXR5XG4gICAgICpcbiAgICAgKi9cbiAgICBpc0Zvcm1FZGl0YWJsZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0YWJsZTtcbiAgICB9XG5cblxuICAgIGFwcGx5Q29sdW1ucygpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMudXNlRml2ZVpvbmUgJiYgdGhpcy5oYXNBbnlab25lcygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvbmVzIGRldGVjdGVkIGluIHRoZSBGb3JtVGFibGUgYnV0IHVzZUZpdmVab25lIG9wdGlvbiBpcyBmYWxzZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNPbmVDb2x1bW4gPSAhaXNQcmVzZW50KHRoaXMucmlnaHRab25lKSAmJiAhaXNQcmVzZW50KHRoaXMubWlkZGxlWm9uZSk7XG4gICAgICAgIHRoaXMuaGFzVHdvQ29sdW1uID0gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpICYmIGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiZcbiAgICAgICAgICAgICFpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKTtcblxuICAgICAgICB0aGlzLmhhc1RocmVlQ29sdW1uID0gaXNQcmVzZW50KHRoaXMubGVmdFpvbmUpICYmIGlzUHJlc2VudCh0aGlzLnJpZ2h0Wm9uZSkgJiZcbiAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLm1pZGRsZVpvbmUpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1R3b0NvbHVtbiAmJiAhdGhpcy5pc1R3b1pvbmVSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdCArPSAnIHVpLW1kLTYgdWktbGctNic7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTYnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzVGhyZWVDb2x1bW4gJiYgIXRoaXMuaXNUaHJlZVpvbmVSZWFkeSgpKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdCArPSAnIHVpLW1kLTYgdWktbGctNCc7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0Wm9uZS5jbGFzc0xpc3QgKz0gJyB1aS1tZC02IHVpLWxnLTQnO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGhhc0FueVpvbmVzKClcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5sZWZ0Wm9uZSkgfHwgaXNQcmVzZW50KHRoaXMucmlnaHRab25lKSB8fCBpc1ByZXNlbnQodGhpcy5taWRkbGVab25lKVxuICAgICAgICAgICAgfHwgaXNQcmVzZW50KHRoaXMudG9wWm9uZSkgfHwgaXNQcmVzZW50KHRoaXMuYm90dG9tWm9uZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBhbHJlYWR5IGluaXRpYWxpemVkIHRoZSBjbGFzc0xpc3QuXG4gICAgICogdGhlXG4gICAgICpcbiAgICAgKiBUT0RPOiBQcm9iYWJseSBzdHJpbmcgYXJyYXkgd291bGQgYmUgZWFzaWVyXG4gICAgICovXG4gICAgaXNUd29ab25lUmVhZHkoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0LmluZGV4T2YoJ3VpLWxnLTYnKSA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMubGVmdFpvbmUuY2xhc3NMaXN0LmluZGV4T2YoJ3VpLWxnLTYnKSA+IDA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRvIGNoZWNrIGlmIHdlIGFscmVhZHkgaW5pdGlhbGl6ZWQgdGhlIGNsYXNzTGlzdC5cbiAgICAgKiB0aGVcbiAgICAgKlxuICAgICAqIFRPRE86IFByb2JhYmx5IHN0cmluZyBhcnJheSB3b3VsZCBiZSBlYXNpZXJcbiAgICAgKi9cbiAgICBpc1RocmVlWm9uZVJlYWR5KCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy00JykgPiAwICYmXG4gICAgICAgICAgICB0aGlzLmxlZnRab25lLmNsYXNzTGlzdC5pbmRleE9mKCd1aS1sZy00JykgPiAwO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvLyBwcm9ibGVtIHNpbmNlIEFuZ3VsYXIgNC4yLCBuZ0FmdGVyQ29udGVudEluaXRcbiAgICAgICAgLy8gd2l0aG91dCB0aGlzIEkgZ2V0IGVycm9yIHRoYXQgdmFsdWUgd2FzIGNoYW5nZWQgYWZ0ZXIgdmlldyB3YXMgY2hlY2tlZFxuICAgICAgICAvLyB0b2RvOiByZWZhY3RvciAgLSBtYWlubHkgb3VyIHpvbmVzIGxlZnQsIHJpZ2h0IG1pZGRsZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlDb2x1bW5zKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1GaWVsZHMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0TGF5b3V0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSB1cGRhdGVGb3JtRmllbGRzKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmlsaXR5Q2hlY2sgJiYgaXNQcmVzZW50KHRoaXMuZm9ybUZpZWxkcykgJiYgdGhpcy5mb3JtRmllbGRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUZpZWxkcy5mb3JFYWNoKChpdGVtOiBCYXNlRm9ybUNvbXBvbmVudCkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpdGVtLmVkaXRhYmxlID0gdGhpcy5lZGl0YWJsZTtcbiAgICAgICAgICAgICAgICAvLyBpdGVtLmZvcm1Hcm91cCA9IHRoaXMuZm9ybUdyb3VwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEJhc2VkIG9uIGlmIHdlIGFyZSAyIG9yIDMgb3IgMSBjb2x1bW4gbGF5b3V0IHdlIG5lZWQgdG8gYWRqdXN0IHdpZGdldHMgd2lkdGggd2l0aGluIHRoZVxuICAgICAqIGZvcm0gcm93LlxuICAgICAqL1xuICAgIHByaXZhdGUgYWRqdXN0TGF5b3V0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5yb3dzKSAmJiB0aGlzLnJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVGhyZWVDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvd3MuZm9yRWFjaCgoaXRlbTogRm9ybVJvd0NvbXBvbmVudCkgPT4gaXRlbS5zaXplID0gJ2xhcmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW5wdXRUZXh0TW9kdWxlfSBmcm9tICdwcmltZW5nL2NvbXBvbmVudHMvaW5wdXR0ZXh0L2lucHV0dGV4dCc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybVRhYmxlQ29tcG9uZW50fSBmcm9tICcuL2Zvcm0tdGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtcbiAgICBCb3R0b21ab25lQ29tcG9uZW50LFxuICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgUmlnaHRab25lQ29tcG9uZW50LFxuICAgIFRvcFpvbmVDb21wb25lbnRcbn0gZnJvbSAnLi4vZml2ZS16b25lLWxheW91dC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEZvcm1UYWJsZUNvbXBvbmVudCxcbiAgICAgICAgRm9ybVJvd0NvbXBvbmVudCxcbiAgICAgICAgVG9wWm9uZUNvbXBvbmVudCxcbiAgICAgICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICAgICAgQm90dG9tWm9uZUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIEZvcm1UYWJsZUNvbXBvbmVudCxcbiAgICAgICAgRm9ybVJvd0NvbXBvbmVudCxcbiAgICAgICAgVG9wWm9uZUNvbXBvbmVudCxcbiAgICAgICAgTGVmdFpvbmVDb21wb25lbnQsXG4gICAgICAgIFJpZ2h0Wm9uZUNvbXBvbmVudCxcbiAgICAgICAgTWlkZGxlWm9uZUNvbXBvbmVudCxcbiAgICAgICAgQm90dG9tWm9uZUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBGb3JtVGFibGVDb21wb25lbnQsXG4gICAgICAgIEZvcm1Sb3dDb21wb25lbnQsXG4gICAgICAgIFRvcFpvbmVDb21wb25lbnQsXG4gICAgICAgIExlZnRab25lQ29tcG9uZW50LFxuICAgICAgICBSaWdodFpvbmVDb21wb25lbnQsXG4gICAgICAgIE1pZGRsZVpvbmVDb21wb25lbnQsXG4gICAgICAgIEJvdHRvbVpvbmVDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFXRm9ybVRhYmxlTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtkaXN0aW5jdFVudGlsQ2hhbmdlZH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTaW1wbGVDaGFuZ2VzLFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc1ByZXNlbnQsIFZhbHVlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHtTdWJzY3JpcHRpb259IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtEZWNpbWFsUGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJlcHJlc2VudCBhIElucHV0IGZpZWxkIGFuZCBpdCBjYW4gIGFjY2VwdCBkaWZmZXJlbnQgdHlwZXMgb2YgdmFsdWVzIHN1Y2ggYXNcbiAqIHRleHQsIG51bWJlci5cbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogIEBDb21wb25lbnQoe1xuICogICAgICBzZWxlY3RvcjogJ3dyYXBwZXItY29tcCcgLFxuICogICAgICB0ZW1wbGF0ZTogJzxhdy1pbnB1dC1maWVsZCBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFt0eXBlXT1cImlucHV0VHlwZVwiPjwvYXctaW5wdXQtZmllbGQ+J1xuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIFRlc3RJbnB1dENvbXBvbmVudFxuICogIHtcbiAqICAgICAgaW5wdXRWYWx1ZTogc3RyaW5nID0gJ1NvbWUgdGV4dCc7XG4gKlxuICogICAgICAvLyBieSBkZWZhdWx0IGlucHV0IHR5cGUgaXMgdGV4dCwgeW91IGNhbiBwYXNzIHN0cmluZywgU3RyaW5nLCBvciB0ZXh0XG4gKiAgICAgIGlucHV0VHlwZTogc3RyaW5nID0gJ3N0cmluZyc7XG4gKiAgfVxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogIyMjIEV4YW1wbGUgd2hlciBpbnB1dCBmaWVsZCBpcyBpbml0aWFsaXplZCB3aXRoIG5nTW9kZWxcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnd3JhcHBlci1jb21wJyAsXG4gKiAgICAgIHRlbXBsYXRlOiAnPGF3LWlucHV0LWZpZWxkIFt2YWx1ZV09XCJpbnB1dFZhbHVlXCIgWyhuZ01vZGVsKV09XCJpbnB1dFR5cGVcIj48L2F3LWlucHV0LWZpZWxkPidcbiAqICB9KVxuICogIGV4cG9ydCBjbGFzcyBUZXN0SW5wdXRDb21wb25lbnRcbiAqICB7XG4gKiAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHRleHQnO1xuICpcbiAqICAgICAgLy8gYnkgZGVmYXVsdCBpbnB1dCB0eXBlIGlzIHRleHQsIHlvdSBjYW4gcGFzcyBzdHJpbmcsIFN0cmluZywgb3IgdGV4dFxuICogICAgICBpbnB1dFR5cGU6IHN0cmluZyA9ICdzdHJpbmcnO1xuICogIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiAgTm90ZTogaWYgeW91IGFyZSB1c2luZyB0aGlzIG91dHNpZGUgb2YgRm9ybVRhYmxlIHBsZWFzZSBwcm92aWRlIHlvdXIgb3duIEZvcm1Hcm91cFxuICpcbiAqL1xuXG5cblxuZXhwb3J0IGNvbnN0IElOUFVUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBJbnB1dEZpZWxkQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWlucHV0LWZpZWxkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCJlZGl0YWJsZVwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCIgY2xhc3M9XCJ3LWlucHV0LXdyYXBwZXJcIj5cblxuICAgIDxpbnB1dCBwSW5wdXRUZXh0XG5cbiAgICAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgW2F0dHIudHlwZV09XCJ0eXBlXCJcbiAgICAgICAgICAgY2xhc3M9XCJ3LWlucHV0LWZpZWxkXCJcbiAgICAgICAgICAgW25nQ2xhc3NdPVwic3R5bGVDbGFzc1wiXG4gICAgICAgICAgIFtjbGFzcy5oYXMtaWNvbl09XCJpY29uXCJcbiAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJ7e3BsYWNlSG9sZGVyfX1cIlxuICAgICAgICAgICBbY2xhc3MudS12YWxpZGF0aW9uLWVycm9yXT1cIiEoZm9ybUNvbnRyb2wudmFsaWQgfHwgKGZvcm1Db250cm9sLnByaXN0aW5lKSlcIlxuICAgICAgICAgICBmb3JtQ29udHJvbE5hbWU9XCJ7e25hbWV9fVwiXG4gICAgICAgICAgIFt2YWx1ZV09XCJkaXNwbGF5VmFsdWVcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJpY29uXCIgY2xhc3M9XCJzYXAtaWNvblwiIFtuZ0NsYXNzXT1cImljb25cIj48L3NwYW4+XG48L2Rpdj5cblxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyBbdmFsdWVdPVwiZGlzcGxheVZhbHVlXCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgLnctaW5wdXQtd3JhcHBlcntwb3NpdGlvbjpyZWxhdGl2ZX0udy1pbnB1dC1maWVsZH5zcGFue3RvcDoxM3B4O3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjE1cHh9YF0sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSU5QVVRfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcblxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElucHV0RmllbGRDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRGaWVsZENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IHtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHNhdmUgYW5kIHJlYWQgIHdoZW4gcmVuZGVyaW5nIGFuZCB1cGRhdGluZyBhIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdXNlZCB0byBmb3JtYXQgdGhlIG51bWJlciBvYmplY3QuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHByZWNpc2lvbjogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQmlnRGVjaW1hbCBvYmplY3QgdGhhdCBlbmNhcHN1bGF0ZXMgdmFsdWUgYW5kIGxvY2FsZS5cbiAgICAgKiBJZiB0aGlzIG9iamVjdCBpcyBzZXQsIHZhbHVlcyB3aWxsIGJlIHRha2VuIGZyb20gdGhpcyBvYmplY3RcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJpZ0RlY2ltYWw6IEJpZ0RlY2ltYWw7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlIGN1c3RvbSBpY29uIHRoYXQgaXMgcGxhY2VkIGludG8gdGhlIGlucHV0IGZpZWxkLlxuICAgICAqXG4gICAgICogVG9kbzogYWRkIGV4dHJhIGJpbmRpbmcgdGhhdCB3aWxsIGFsbG93IGRldmVsb3BlciB0byB0ZWxsIHBvc2l0aW9uLCBsZWZ0IHJpZ2h0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpY29uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBmaWVsZCB0eXBlLiBDdXJyZW50bHkgd2Ugc3VwcG9ydCBlaXRoZXIgTnVtYmVyIG9yIHRleHRcbiAgICAgKi9cbiAgICBwcml2YXRlIF90eXBlOiBzdHJpbmcgPSAnc3RyaW5nJztcblxuXG4gICAgLyoqXG4gICAgICogSnVzdCB0byBjbGVhbiB1cCBzdWJzY3JpYmVyIHdoZW4gY29tcG9uZW50IGlzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHByaXZhdGUgdmNoU3Vic2NyaWJlcjogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlY2ltYWwgcGlwZSBpcyB1c2VkIHRvIGZvcm1hdCBvdXIgbnVtYmVyIG9iamVjdC5cbiAgICAgKi9cbiAgICBkZWNpbWFsUGlwZTogRGVjaW1hbFBpcGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0dGVkIGRlY2ltYWwgdmFsdWUuIFVzZXMgYW5ndWxhciBkZWNpbWFsUGlwZSB0byBmb3JtYXQgYmFzZWQgb24gbG9jYWxlLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2Rpc3BsYXlWYWx1ZTogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kZWNpbWFsUGlwZSA9IG5ldyBEZWNpbWFsUGlwZShlbnYubG9jYWxlKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLmJpZ0RlY2ltYWwpO1xuXG4gICAgICAgIHRoaXMudmNoU3Vic2NyaWJlciA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzXG4gICAgICAgICAgICAucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh2YWwgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52YWx1ZSA9IHZhbCk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBnZW5lcmF0ZWQgc2V0dGVyIHRvIGNoZWNrIGZvciB2YWx1ZSBhbmQgbm9ybWFsaXppbmcgaW50byBleHBlY3RlZCBlaXRoZXIgbnVtYmVyIG9yIHRleHRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IHR5cGUodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N0cmluZycgfHwgdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ3RleHQnO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLl90eXBlID0gJ251bWJlcic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG5cblxuICAgIGdldCBkaXNwbGF5VmFsdWUoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuYmlnRGVjaW1hbCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXROdW1iZXIodGhpcy5iaWdEZWNpbWFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXlWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlWYWx1ZTtcbiAgICB9XG5cbiAgICBjYW5TZXRUeXBlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHRoaXMuYmlnRGVjaW1hbCAmJiAhZXF1YWxzKHZhbHVlLCB0aGlzLmJpZ0RlY2ltYWwpKSB7XG4gICAgICAgICAgICB0aGlzLmJpZ0RlY2ltYWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5iaWdEZWNpbWFsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHtvbmx5U2VsZjogdHJ1ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0IHRoZSBudW1iZXIgb2JqZWN0IGFjY29yZGluZyB0byBpdHMgcHJlY2lzaW9uLlxuICAgICAqXG4gICAgICovXG4gICAgZm9ybWF0TnVtYmVyKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgcHJlY2lzaW9uIGlzIDIuIEZvciBleGFtcGxlLCAxMC4yMy5cbiAgICAgICAgbGV0IGRpZ2l0cyA9ICcxLjAtMic7XG5cbiAgICAgICAgLy8gSWYgcHJlY2lzaW9uIGlzIHByZXNlbnQsIHVzZSBpdCBmb3IgZm9ybWF0IHRoZSBiaWdEZWNpbWFsIHZhbHVlIGZvciBkaXNwbGF5LlxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucHJlY2lzaW9uKSAmJlxuICAgICAgICAgICAgdGhpcy5fdHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRpZ2l0cyA9ICcxLjAtJyArIHRoaXMucHJlY2lzaW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjaW1hbFBpcGUudHJhbnNmb3JtKHZhbHVlLCBkaWdpdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMudmNoU3Vic2NyaWJlcikpIHtcbiAgICAgICAgICAgIHRoaXMudmNoU3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEJpZ0RlY2ltYWwgb2JqZWN0IGlzIHJlcHJlc2VudGVkIGFzIGEgdmFsdWUsIGxvY2FsZSwgYW5kIGN1cnJlbmN5Q29kZVxuICovXG5leHBvcnQgY2xhc3MgQmlnRGVjaW1hbCBpbXBsZW1lbnRzIFZhbHVlIHtcbiAgICB1bmlxdWVOYW1lOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYW1vdW50OiBudW1iZXIgPSAwLFxuICAgICAgICAgICAgICAgIHB1YmxpYyByZWFkb25seSBsb2NhbGU6IHN0cmluZyA9ICdlbl9VUycpIHtcbiAgICB9XG5cblxuICAgIGdldFR5cGVzKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbW91bnQ6IE51bWJlcixcbiAgICAgICAgICAgIGxvY2FsZTogU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xhc3NOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnQmlnRGVjaW1hbCc7XG4gICAgfVxuXG4gICAgJHByb3RvKCk6IEJpZ0RlY2ltYWwge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoMSwgJ2VuX1VTJyk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW1vdW50ICsgJywgbG9jYWxlOiAnICsgdGhpcy5sb2NhbGU7XG4gICAgfVxuXG5cbiAgICBjbG9uZShkYXRhOiB7IGFtb3VudD86IG51bWJlciwgbG9jYWxlPzogc3RyaW5nIH0gPSB7fSk6IEJpZ0RlY2ltYWwge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ0RlY2ltYWwoXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5hbW91bnQpID8gZGF0YS5hbW91bnQgOiB0aGlzLmFtb3VudCxcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmxvY2FsZSkgPyBkYXRhLmxvY2FsZSA6IHRoaXMubG9jYWxlKTtcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtTdHJpbmdDb21wb25lbnR9IGZyb20gJy4vc3RyaW5nLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3RyaW5nQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFN0cmluZ0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1N0cmluZ0ZpZWxkTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SW5wdXRUZXh0TW9kdWxlfSBmcm9tICdwcmltZW5nL2NvbXBvbmVudHMvaW5wdXR0ZXh0L2lucHV0dGV4dCc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5wdXRGaWVsZENvbXBvbmVudH0gZnJvbSAnLi4vaW5wdXQtZmllbGQvaW5wdXQtZmllbGQuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBJbnB1dEZpZWxkQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIElucHV0RmllbGRDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSW5wdXRGaWVsZENvbXBvbmVudCxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdJbnB1dEZpZWxkTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge0FwcENvbmZpZywgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKlxuICogYmFzaWMgbmF2aWdhdGlvbiBiYXIgcHJvdmlkZSBhIG1haW4gYWN0aW9uIGJ1dHRvbnMgZm9yIGl0cyBjb250ZW50IChwYWdlIGxldmVsIGJ1dHRvbnMpLlxuICogVGhpcyBpcyBub3QgdGhlIFRvcCBsZXZlbCBhcHBsaWNhdGlvbiBuYXZpZ2F0aW9uLiBUaGlzIGNvbXBvbmVudCBwcm92aWRlcyBieSBkZWZhdWx0IGFjdGlvbiBPSyxcbiAqIENBTkNFTCBhbmQgeW91IGFyZSBmcmVlIHRvIG1vZGlmeSBob3cgdGhlIE9LIG9yIENBTkNFTCB3aWxsIGJlIGNhbGwgYXMgd2VsbCBhcyBzdWJzY3JpYmUgdG8gdGhlXG4gKiBldmVudC4gT3IgeW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGJ1dHRvbnMgdGVtcGxhdGUgd2hpY2ggd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhpcyBkZWZhdWx0XG4gKiBvbmUuXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIDE6XG4gKlxuICogSW4gb3JkZXIgdG8gdXNlIG5hdmlnYXRpb24gYmFyIGluIGl0cyBiYXNpYyB1c2FnZSB5b3UgY2FuIGRvIGZvbGxvd2luZzpcbiAqIHRoaXMgd2lsbCByZW5kZXIgYnV0dG9ucyBvbiB0aGUgdG9wIGFzIHdlbGwgYXMgb24gdGhlIGJvdHRvbSBhcm91bmQgdGhlIGNvbnRlbnQuXG4gKlxuICpcbiAqICBgYGBodG1sXG4gKlxuICogICAgICA8YXctYmFzaWMtbmF2aWdhdG9yIFticmFuZEltZ109XCInaW1nL2FyaWJhbG9nb2JhbC5wbmcnXCI+XG4gKlxuICogICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCI+XG4gKiAgICAgICAgICAgICAgICA8Zm9ybT5cbiAqICAgICAgICAgICAgICAgICAgICBVc2VyIG5hbWU6IDxpbnB1dCB0eXBlPXRleHQgdmFsdWU9XCJwZXRlci5wYW5cIj5cbiAqICAgICAgICAgICAgICAgIDwvPGZvcm0+PlxuICogICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgPC9hdy1iYXNpYy1uYXZpZ2F0b3I+XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqICBpZiB5b3UgZG8gbm90IHdhbnQgYnV0dG9uIG9uIHRoZSB0b3Agb3IgYm90dG9tIHlvdSBjYW4gc2F5IHRoaSB1c2luZyBiaW5kaW5nIHNob3dUb3Agb3JcbiAqIHNob3dCb3R0b20uXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlIDI6XG4gKiAgSW4gdGhpcyBleGFtcGxlIHdlIGFyZSBwcm92aWRpbmcgY3VzdG9tIGJ1dHRvbnMgYXMgd2VsbCBhcyBicmFuayBzZWN0aW9uXG4gKlxuICpcbiAqICBgYGBodG1sXG4gKlxuICpcbiAqICAgICAgPGF3LWJhc2ljLW5hdmlnYXRvciBbYnJhbmRJbWddPVwiJ2ltZy9hcmliYWxvZ29iYWwucG5nJ1wiPlxuICogICAgICAgICAgICA8bmctdGVtcGxhdGUgI2J1dHRvbnM+XG4gKiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJuYXYgbmF2YmFyLW5hdiBmbG9hdC1tZC1yaWdodCBjb2xsYXBzZSBuYXZiYXItdG9nZ2xlYWJsZS14c1wiPlxuICogICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzcz1cIm5hdi1pdGVtIFwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAqIChjbGljayk9XCJvblNhdmVBY3Rpb24oJGV2ZW10KVwiPkNhbmNlbDwvYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gKiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzPVwibmF2LWl0ZW0gYWN0aXZlXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLXByaW1hcnlcIiB0eXBlPVwiYnV0dG9uXCJcbiAqIChjbGljayk9XCJvbkNhbmNlbEFjdGlvbigkZXZlbnQpXCI+IFNhdmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAqICAgICAgICAgICAgICAgIDwvdWw+XG4gKiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogICAgICAgICAgICA8bmctdGVtcGxhdGUgI2JyYW5kPlxuICogICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJicmFuZC10aXRsZVwiPkFyaWJhPC9zcGFuPlxuICogICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqXG4gKiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXJcIj5cbiAqICAgICAgICAgICAgICAgIDxmb3JtPlxuICogICAgICAgICAgICAgICAgICAgIFVzZXIgbmFtZTogPGlucHV0IHR5cGU9dGV4dCB2YWx1ZT1cInBldGVyLnBhblwiPlxuICogICAgICAgICAgICAgICAgPC88Zm9ybT4+XG4gKiAgICAgICAgICAgIDwvZGl2PlxuICogICAgICA8L2F3LWJhc2ljLW5hdmlnYXRvcj5cbiAqXG4gKlxuICogYGBgXG5cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctYmFzaWMtbmF2aWdhdG9yJyxcbiAgICB0ZW1wbGF0ZTogYDxwLXRvb2xiYXIgKm5nSWY9XCJzaG93VG9wXCIgW2NsYXNzXT1cIid3LWJhc2ljLW5hdmlnYXRvcidcIj5cbiAgICA8ZGl2IGNsYXNzPVwidWktdG9vbGJhci1ncm91cC1sZWZ0XCI+XG5cbiAgICAgICAgPGEgY2xhc3M9XCJuYXYtYnJhbmRcIiBocmVmPVwiI1wiICpuZ0lmPVwic2hvd0JyYW5kXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0JyYW5kVGVtcGxhdGUoKVwiPlxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwie3thc3NldEZvbGRlcn19L3t7YnJhbmRJbWd9fVwiIGhlaWdodD1cIjMwXCIgYWx0PVwiXCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJuYXYtYnJhbmQtdGl0bGVcIj5BcmliYTwvc3Bhbj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbZW1iZWRkZWRJdGVtXT1cImJyYW5kVGVtcGxhdGVcIiBbaXRlbV09XCJjb250ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0JyYW5kVGVtcGxhdGUoKVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvYT5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLXRvb2xiYXItZ3JvdXAtcmlnaHRcIj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNCdXR0b25UZW1wbGF0ZSgpXCI+XG5cbiAgICAgICAgICAgIDxhdy1idXR0b24gKm5nSWY9XCJzaG93Q2FuY2VsQnV0dG9uXCIgW3N0eWxlXT1cIidzZWNvbmRhcnknXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNhbmNlbEFjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICB7e2NhbmNlbEFjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uIChhY3Rpb24pPVwib25PS0FjdGlvbi5lbWl0KCRldmVudClcIj5cbiAgICAgICAgICAgICAgICB7e29rQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG5cblxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJidXR0b25zVGVtcGxhdGVcIiBbaXRlbV09XCJjb250ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzQnV0dG9uVGVtcGxhdGUoKVwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG5cbjwvcC10b29sYmFyPlxuXG48bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cbjxwLXRvb2xiYXIgKm5nSWY9XCJzaG93Qm90dG9tXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidWktdG9vbGJhci1ncm91cC1yaWdodFwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0J1dHRvblRlbXBsYXRlKClcIj5cblxuICAgICAgICAgICAgPGF3LWJ1dHRvbiAqbmdJZj1cInNob3dDYW5jZWxCdXR0b25cIiBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAoYWN0aW9uKT1cIm9uQ2FuY2VsQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIHt7Y2FuY2VsQWN0aW9uTGFiZWx9fVxuICAgICAgICAgICAgPC9hdy1idXR0b24+XG5cbiAgICAgICAgICAgIDxhdy1idXR0b24gKGFjdGlvbik9XCJvbk9LQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgIHt7b2tBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiYnV0dG9uc1RlbXBsYXRlXCIgW2l0ZW1dPVwiY29udGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc0J1dHRvblRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuXG48L3AtdG9vbGJhcj5cblxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYGEubmF2LWJyYW5ke3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtsaW5lLWhlaWdodDppbmhlcml0O3RleHQtZGVjb3JhdGlvbjpub25lO2NvbG9yOiMyZDM1M2N9YS5uYXYtYnJhbmQ6Zm9jdXMsYS5uYXYtYnJhbmQ6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOm5vbmV9YS5uYXYtYnJhbmQgc3Bhbnt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9Lm5hdi1icmFuZCBpbWd7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO3BhZGRpbmc6M3B4fWBdXG59KVxuZXhwb3J0IGNsYXNzIEJhc2ljTmF2aWdhdG9yQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkIG9uIHRoZSB0b3BcbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgVFJVRVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93VG9wOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYnV0dG9ucyB3aWxsIGJlIHJlbmRlcmVkIG9uIHRoZSBib3R0b21cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgVFJVRVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Qm90dG9tOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IGJyYW5kIHNlY3Rpb24gdGhhdCBpcyBvbiB0aGUgbGVmdCBzaWRlIGFuZCBvbmx5IGluIHRoZSB0b3AgYmFyIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgVFJVRVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93QnJhbmQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXRpdmUgcGF0aCB0byBhIGltYWdlLiBJbWFnZXMgYXJlIHNhdmVkIGluc2lkZSBhc3NldHMgZm9sZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBicmFuZEltZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gT0sgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBva0FjdGlvbkxhYmVsOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBDYW5jZWwgYWN0aW9uXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlIGlzIE9LXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjYW5jZWxBY3Rpb25MYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBDb250ZXh0IGlzIGFuIG9iamVjdCB3aGljaCBpcyByZW5kZXJlZCBpbnNpZGUgbmF2LWJhciBjb250ZW50LiBTb21ldGltZXMgdGhlcmUgYXJlIHNpdHVhdGlvblxuICAgICAqIHRoYXQgeW91IHdhbnQgdG8gcmVuZGVyIHNvbWUgaW5mb3JtYXRpb24gZnJvbSB0aGUgb2JqZWN0IGluc2lkZSBuYXZpZ2F0aW9uIGJhci4gU28geW91IGFyZVxuICAgICAqIGZyZWUgdG8gcGFzcyBhIGNvbnRleHQgb2JqZWN0IGFuZCB0aGVuIGFjY2VzcyBpdCBpbnNpZGUgeW91ciB0ZW1wbGF0ZVxuICAgICAqXG4gICAgICogYGBgSFRNTFxuICAgICAqICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNicmFuZCBsZXQtaXRlbT5cbiAgICAgKiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJyYW5kLXRpdGxlXCI+e3tpdGVtLmZpcnN0TmFtZX19PC9zcGFuPlxuICAgICAqICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY29udGV4dDogYW55O1xuXG5cbiAgICBASW5wdXQoKVxuICAgIHNob3dDYW5jZWxCdXR0b246IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEV2ZW50RW1pdHRlciB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHlvdSBjbGljayBvbiBkZWZhdWx0IE9LIEFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PS0FjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRXZlbnRFbWl0dGVyIHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4geW91IGNsaWNrIG9uIGRlZmF1bHQgQ0FOQ0VMIEFjdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DYW5jZWxBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBidXR0b25zIHRlbXBsYXRlIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2J1dHRvbnMnKVxuICAgIGJ1dHRvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBicmFuZCB0ZW1wbGF0ZSBpZiBhbnlcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdicmFuZCcpXG4gICAgYnJhbmRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG5cbiAgICBjb25zdHJ1Y3RvcihlbnY6IEVudmlyb25tZW50LCBhcHBDb25maWc6IEFwcENvbmZpZylcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gdG9kbzogbG9hZCB0aGlzIGZyb20gcmVzb3VyY2UgZmlsZSB1c2luZyBuZ1RyYW5zbGF0ZSBzZXJ2aWNlXG4gICAgICAgIHRoaXMub2tBY3Rpb25MYWJlbCA9ICdPSyc7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uTGFiZWwgPSAnQ2FuY2VsJztcbiAgICAgICAgdGhpcy5icmFuZEltZyA9ICdpbWFnZXMvYXJpYmFsb2dvYmFsLnBuZyc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zaG93Q2FuY2VsQnV0dG9uKSkge1xuICAgICAgICAgICAgdGhpcy5zaG93Q2FuY2VsQnV0dG9uID0gdGhpcy5lZGl0YWJsZSB8fCAodGhpcy5vbkNhbmNlbEFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICYmIHRoaXMub25PS0FjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYnV0dG9uc1RlbXBsYXRlIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzQnV0dG9uVGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJ1dHRvbnNUZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiBicmFuZFRlbXBsYXRlIGlzIGF2YWlsYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzQnJhbmRUZW1wbGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuYnJhbmRUZW1wbGF0ZSk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQnV0dG9uIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvci4gQnV0dG9uIGNhbiBiZSByZW5kZXJlZCBlaXRoZXIgYXNcbiAqIGEgYnV0dG9uIG9yIGFzIGEgbGluay4gSXQgY291bGQgYmUgc3RhbmRhbG9uZSBvciBiZSBwYXJ0IG9mIGEgZm9ybS5cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgIDxhdy1mb3JtLXRhYmxlID5cbiAqICAgICAgIDxhdy1mb3JtLXJvdyBbbGFiZWxdPVwiJ0Ftb3VudCdcIiBbbmFtZV09XCInYW1vdW50J1wiIFtzaXplXT1cIidzbWFsbCdcIj5cbiAqXG4gKiAgICAgICAgICAgPGF3LWJ1dHRvbiBbdHlwZV09XCInc3VibWl0J1wiIFtuYW1lXT1cIididXR0b24nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJvbkNsaWNrZWQoJGV2ZW50KVwiIFt2YWx1ZV09XCJjb21tYW5kXCJcbiAqICAgICAgICAgICAgICAgICAgICAgW3N0eWxlXT1cIid3YXJuaW5nJ1wiID5CdXR0b248L2F3LWJ1dHRvbj5cbiAqICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgIDwvYXctZm9ybS10YWJsZT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgY29tbWFuZDpib29sZWFuO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgICAgIG9uQ2xpY2tlZCh2YWx1ZTpzdHJpbmcpIHtcbiAqICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAqICAgICAgICAgICAgICAvLyBzdWJtaXQgZm9ybS5cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWJ1dHRvbicsXG4gICAgdGVtcGxhdGU6IGA8YnV0dG9uXG4gICAgcEJ1dHRvblxuICAgIFthdHRyLnR5cGVdPVwidHlwZVwiXG4gICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICBbbmdDbGFzc109XCJidXR0b25DbGFzc1wiXG4gICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICBbYXR0ci52YWx1ZV09XCJ2YWx1ZVwiXG4gICAgKGNsaWNrKT1cImNsaWNrZWQoJGV2ZW50KVwiPlxuXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9idXR0b24+XG5gLFxuICAgIHN0eWxlczogW2AudWktYnV0dG9uLWxpbmt7Y29sb3I6IzMzN2FiNztmb250LXdlaWdodDo0MDA7Ym9yZGVyLXJhZGl1czowO2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LnVpLWJ1dHRvbi1saW5rLC51aS1idXR0b24tbGluay5hY3RpdmUsLnVpLWJ1dHRvbi1saW5rOmFjdGl2ZSwudWktYnV0dG9uLWxpbms6Zm9jdXMsLnVpLWJ1dHRvbi1saW5rOmhvdmVyLC51aS1idXR0b24tbGlua1tkaXNhYmxlZF17Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS51aS1idXR0b24tbGluazpmb2N1cywudWktYnV0dG9uLWxpbms6aG92ZXJ7Y29sb3I6IzMzN2FiNzstd2Via2l0LXRleHQtZGVjb3JhdGlvbjojMzM3YWI3O3RleHQtZGVjb3JhdGlvbjojMzM3YWI3O2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LnVpLWJ1dHRvbi1saW5rW2Rpc2FibGVkXTpmb2N1cywudWktYnV0dG9uLWxpbmtbZGlzYWJsZWRdOmhvdmVye2NvbG9yOiMyMzk5ZTU7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LnVpLWJ1dHRvbnttYXJnaW4tcmlnaHQ6NXB4fS5idG4tbWlke2hlaWdodDozNnB4O3BhZGRpbmc6NXB4IDEwcHh9LmJ0bi1sZ3toZWlnaHQ6NDJweDtmb250LXNpemU6MTZweDtwYWRkaW5nOjVweCAxMnB4fS5idG4tc217aGVpZ2h0OjMwcHg7Zm9udC1zaXplOjEycHg7cGFkZGluZzo1cHggMTBweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBCdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogQnV0dG9uIHR5cGVzICBbIGJ1dHRvbiB8IHN1Ym1pdCB8IHJlc2V0IF1cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogc3RyaW5nID0gJ2J1dHRvbic7XG5cbiAgICAvKipcbiAgICAgKiBOYW1lIGZvciB0aGlzIGJ1dHRvbi4gQ2FuIGJlIHVzZWQgdG8gbG9va3VwIGNvbXBvbmVudCBpbiBmb3JtLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbmFtZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBzdHlsaW5nIGZvciB0aGlzIGJ1dHRvbi4gU2VlIEJ1dHRvblN0eWxlIGZvciBhbGwgc3VwcG9ydGVkIHN0eWxlcy5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0eWxlOiBCdXR0b25TdHlsZSA9ICdwcmltYXJ5JztcblxuXG4gICAgLyoqXG4gICAgICogc2l6aW5nIGZvciB0aGlzIGJ1dHRvbi4gW2xhcmdlLCBub3JtYWwsIHNtYWxsXS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNpemU6IEJ1dHRvblNpemUgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHRhcmdldCBvZiB0aGUgYnV0dG9uLiBbX2JsYW5rIHwgX3NlbGYgfCBfcGFyZW50IHwgX3RvcCB8IGZyYW1lbmFtZSBdXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0YXJnZXQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIHRvIGJlIHNlbmQgdG8gc2VydmVyIHdoZW4gY2xpY2tlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cblxuICAgIC8qKlxuICAgICAqIFByaW1lTmcgYnV0dG9uIHNpbXBseSBkb2VzIG5vdCBzdXBwb3J0IGNvbnRlbnQgc28gd2UgbmVlZCB0byBnZXQgYXJvdW5kIGl0XG4gICAgICovXG4gICAgbGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIENTUyBjbGFzcyB0aGF0IHN0eWxlcyB0aGlzIGJ1dHRvbiBiYXNlZCBvbiBpbnB1dCAnc3R5bGUnIGFuZCAnc2l6ZSdcbiAgICAgKi9cbiAgICBidXR0b25DbGFzczogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICAvLyBEZWZhdWx0IGJ1dHRvbiBjbGFzcyBpcyBzZWNvbmRhcnkuXG4gICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgPSAndWktYnV0dG9uLXNlY29uZGFyeSc7XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkaXNhYmxlZFxuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgLy8gSG93IHRvIHN0eWxlIHRoaXMgYnV0dG9uLlxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHlsZSA9PT0gJ3ByaW1hcnknKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCAudWktYnV0dG9uIGFuZCAudWktYnV0dG9uLXByaW1hcnkgZ2V0IHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICAgICAgICAgIC8vIC51aS1idXR0b24tcHJpbWFyeSBpcyBuZWNlc3NhcnkgYmVjYXVzZSBidXR0b24gc3R5bGUgY2FuIGJlIG92ZXJyaWRkZW5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGluY2x1ZGVkIGluc2lkZSBvdGhlciB3aWRnZXRzLiBTbyBzcGVjaWZ5IHByaW1hcnlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzID0gJ3VpLWJ1dHRvbi1wcmltYXJ5JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyA9ICd1aS1idXR0b24tJyArIHRoaXMuc3R5bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGJ1dHRvbiBjbGFzcyBiYXNlZCBvbiBpbnB1dCBzaXplLlxuICAgICAgICBpZiAodGhpcy5zaXplKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFyZ2UnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25DbGFzcyArPSAnIGJ0bi1sZyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25vcm1hbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbkNsYXNzICs9ICcgYnRuLW1pZCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NtYWxsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uQ2xhc3MgKz0gJyBidG4tc20nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBsaXR0bGUgaGFja3kgaGFja2l0eSBoYWNrIGFzIGN1cnJlbnRseSBwcmltZW5nIGJ1dHRvbiBkaXJlY3RpdmUgZG9lcyBub3Qgd29yayB3aXRoXG4gICAgICogbmdjb250ZW50IHByb2plY3Rpb24gYnV0IGl0IGhhcyBhIGxhYmVsIGJpbmRpbmdzLCB3aGljaCBpcyBub3QgdGhlIHdheSBkZXZlbG9wZXJzIHdvcmsgd2l0aFxuICAgICAqIGJ1dHRvbi4geW91IHdhbnQgdG9cbiAgICAgKlxuICAgICAqIDxidXR0b24+IE1ZIENPTlRFTlQ8L2J1dHRvbiBpbnN0ZWFkIG9mIDxidXR0b24gbGFiZWw9J015Q29udGVudCc+PC9idXR0b24+XG4gICAgICpcbiAgICAgKlxuICAgICAqIEBUb2RvOiBDaGFuZ2UgdGhpcyB1bnRpbCB0aGUgdGltZSBrZWVwIGEgdGVzdCB0aGF0IGNoZWNrIHRoYXQgdGhleSBhcmUgc3RpbGwgdXNpbmcgdWktYnV0dG9uXG4gICAgICogICAgIHRoYXQgd2UgYXJlIGV4cGVjdGluZyBhbmQgcmVwbGFjaW5nXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5lbGVtZW50KSkge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbicpO1xuICAgICAgICAgICAgbGV0IGJ1dHRvblRpdGxlID0gYnV0dG9uLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgYnV0dG9uLmNoaWxkcmVuWzBdLnRleHRDb250ZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3VpLWJ1dHRvbicsICcnKS5yZXBsYWNlKCd1aS1idG4nLCAnJyk7XG5cbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCd1aS1idXR0b24tdGV4dC1lbXB0eScpO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICBidXR0b24uYXBwZW5kQ2hpbGQoYnV0dG9uVGl0bGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEFjdGlvbiBjbGlja2VkLiBDYWxsIHBhcmVudCBhY3Rpb24uXG4gICAgICovXG4gICAgY2xpY2tlZCgkZXZlbnQ6IGFueSlcbiAgICB7XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQoaXNCbGFuayh0aGlzLnZhbHVlKSA/ICRldmVudCA6IHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFN1cHBvcnRlZCBCdXR0b24gU3R5bGVcbiAqL1xuZXhwb3J0IHR5cGUgQnV0dG9uU3R5bGUgPSAnaW5mbycgfCAncHJpbWFyeScgfCAnc2Vjb25kYXJ5JyB8ICd3YXJuaW5nJyB8ICdzdWNjZXNzJyB8ICdkYW5nZXInIHxcbiAgICAnbGluayc7XG5cbi8qKlxuICogU3VwcG9ydGVkIEJ1dHRvbiBTaXplXG4gKi9cbmV4cG9ydCB0eXBlIEJ1dHRvblNpemUgPSAnbGFyZ2UnIHwgJ25vcm1hbCcgfCAnc21hbGwnO1xuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtCdXR0b25Db21wb25lbnR9IGZyb20gJy4vYnV0dG9uLmNvbXBvbmVudCc7XG5pbXBvcnQge0J1dHRvbk1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBCdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBCdXR0b25Nb2R1bGUsXG5cbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBCdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQnV0dG9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQnV0dG9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtCYXNpY05hdmlnYXRvckNvbXBvbmVudH0gZnJvbSAnLi9iYXNpYy1uYXZpZ2F0b3IuY29tcG9uZW50JztcbmltcG9ydCB7VG9vbGJhck1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7QVdCdXR0b25Nb2R1bGV9IGZyb20gJy4uL2J1dHRvbi9idXR0b24ubW9kdWxlJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBCYXNpY05hdmlnYXRvckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFRvb2xiYXJNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcblxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBCYXNpY05hdmlnYXRvckNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBhdy1jYXJkLXRvcGAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXp0b3AnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBDYXJkWm9uZVRvcENvbXBvbmVudFxue1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYGF3LWNhcmQtYm90dG9tYCxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd3LWNhcmQtemJvdHRvbSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIENhcmRab25lQm90dG9tQ29tcG9uZW50XG57XG59XG5cbi8qKlxuICpcbiAqIENhcmQgY29tcG9uZW50IGlzIGEgY29udGFpbmVyIHJlbmRlcmluZyBpdHMgY29udGVudCBpbnNpZGUgMyBkaWZmZXJlbnQgem9uZXMuXG4gKlxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICBUSVRMRSAgICAgICAgICAgICAgICAgICAgICAgfCBBQ1RJT04gfFxuICogIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICBUT1AgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICBCT1RUT00gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqXG4gKiAgVGhlcmUgYXJlIDMgem9uZXMgICsgMSBwbGFjZWhvbGRlciBmb3IgdGhlIGFjdGlvbkljb25cbiAqXG4gKiAgQ2FyZHMgY2FuIGJlIHNlbGVjdGFibGUgd2hpY2ggbWVhbnMgd2hlbiB5b3UgY2xpY2sgb24gaXQgdGhlcmUgd2lsbCBiZSByZW5kZXJlZCBhIGJvcmRlciB3aXRoXG4gKiAgYSBjaGVjayBtYXJrIGluc2lkZSBBY3Rpb24gem9uZSAodGhpcyBpcyBkZWZhdWx0IGJlaGF2aW9yKS5cbiAqICBZb3UgY2FuIHVzZSBbc2VsZWN0YWJsZV0gYmluZGluZyB0byBkaXNhYmxlIHRoaXMsIGluIHN1Y2ggY2FzZSBjYXJkIHdpbGwgaGF2ZSBqdXN0IGEgYm9yZGVyXG4gKiAgd2l0aG91dCBhbnkgY2hlY2sgbWFyay5cbiAqXG4gKiAgQ2FyZHMgY2FuIGFsc28gY29udGFpbiBjdXN0b20gQWN0aW9uIHdoaWNoIGlzIHJlbmRlcmVkIGluc2lkZSBBQ1RJT04gem9uZSBhbmQgb24gdGhlXG4gKiAgYXBwbGljYXRpb24gbGV2ZWwgeW91IGNhbiBsaXN0ZW4gZm9yIChjbGljaykgZXZlbnRzIGFzIHdlbGwgYXMgeW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGFjdGlvblxuICogIGljb25cbiAqXG4gKiAgQmVzaWRlcyBBQ1RJT04sIFRJVExFLCBUT1AgYW5kIEJPVFRPTSBjb250ZW50IHpvbmVzIGNhcmRzIHN1cHBvcnQgaG92ZXIgb3ZlcmxheSBlZmZlY3QgYW5kXG4gKiAgd2hlbiBpdHMgYWN0aXZhdGVkIHRoZXJlIGlzIGEgb3ZlcmxheSBkaXNwbGF5ZWQgb24gdG9wIG9mIHRoZSBjYXJkIHdpdGggSWNvbiBpbiB0aGUgbWlkZGxlLlxuICogIFBsZWFzZSBub3RlIHdoZW4gW2hhc0hvdmVyXSBpcyBUUlVFIGFsbCB0aGUgYWN0aW9ucyBhbmQgc2VsZWN0YWJpbGl0eSBhcmUgZGlzYWJsZWQgYXMgdGhlcmUgaXNcbiAqICBvbmx5IG9uZSBhY3Rpb24gd2hpY2ggY2xpY2sgb24gdGhlIGhvdmVyIG92ZXJsYXkuXG4gKlxuICpcbiAqICMjI2V4YW1wbGUgMTpcbiAqICBCYXNpYyBob3ZlciBjYXJkIHdoaWNoIGJ5IGRlZmF1bHQgc3VwcG9ydCBzZWxlY3RhYmxlIG1vZGVcbiAqXG4gKiBgYGBcbiAqICAgICAgICAgIDxhdy1jYXJkICNjYXJkMSBbaGFzQWN0aW9uXT1cImZhbHNlXCIgW3dpZHRoXT1cIicyMDJweCdcIiBbaGVpZ2h0XT1cIicxNTRweCdcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdGl0bGUgW2FsaWduXT1cIidib3R0b20tbGVmdCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhLXN1cHBsaWVyLXRhZ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdGl0bGU+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRvcD5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTmFtZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgSGFpZ2h0IFB1bXBzXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VwcGxpZXJMb2NhdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUGFsbyBBbHRvLCBDQSwgVVNBXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC10b3A+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLWJvdHRvbSBjbGFzcz1cInctY2FyZC16Ym90dG9tXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIHNvbWUgdGV4dCBhYm91dCB0aGUgc3VwcGxpZXIgYW5kIGhpcyBwYXJlbnRzPGJyLz5cbiAqICAgICAgICAgICAgICAgICAgICAgYW5kIHNvbWUgY29udGFjdHNcbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtYm90dG9tPlxuICpcbiAqICAgICAgICAgICAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIyMjZXhhbXBsZSAyOlxuICogICBIb3ZlciBjYXJkIHdpdGggY3VzdG9tIGFjdGlvbi4gd2hlbiB1bnNlbGVjdGVkIGFjdGlvbiB3aWxsIGFwcGVhciBhbmQgdXNlciBjYW4gY2xpY2sgb24gaXQuXG4gKlxuICogYGBgXG4gKiAgICAgICAgICA8YXctY2FyZCAjY2FyZDEgW3NlbGVjdGFibGVdPVwidHJ1ZVwiIFthY3Rpb25JY29uXT1cIidpY29uLXF1ZXN0aW9uLW1hcmsnXCJcbiAqICAgICAgICAgICAgICAgICAgICAgKG9uQWN0aW9uKT1cIm9uQWN0aW9uKDMsICRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdGl0bGUgW2FsaWduXT1cIidib3R0b20tbGVmdCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJhLXN1cHBsaWVyLXRhZ1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUHJlZmVycmVkXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtdGl0bGU+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLXRvcD5cbiAqICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInN1cHBsaWVyTmFtZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgSGFpZ2h0IFB1bXBzXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3VwcGxpZXJMb2NhdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgUGFsbyBBbHRvLCBDQSwgVVNBXG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgIDwvYXctY2FyZC10b3A+XG4gKlxuICogICAgICAgICAgICAgICAgIDxhdy1jYXJkLWJvdHRvbSBjbGFzcz1cInctY2FyZC16Ym90dG9tXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIHNvbWUgdGV4dCBhYm91dCB0aGUgc3VwcGxpZXIgYW5kIGhpcyBwYXJlbnRzPGJyLz5cbiAqICAgICAgICAgICAgICAgICAgICAgYW5kIHNvbWUgY29udGFjdHNcbiAqICAgICAgICAgICAgICAgICA8L2F3LWNhcmQtYm90dG9tPlxuICpcbiAqICAgICAgICAgICAgIDwvYXctY2FyZD5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jYXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ3LWNhcmRcIiBbc3R5bGUud2lkdGhdPVwid2lkdGhcIiBbc3R5bGUuaGVpZ2h0XT1cImhlaWdodFwiXG4gICAgIFtjbGFzcy51LWlzLWhvdmVyXT1cImhhc0hvdmVyXCJcbiAgICAgKG1vdXNlZW50ZXIpPVwib25Ib3Zlcih0cnVlKVwiXG4gICAgIChtb3VzZWxlYXZlKT1cIm9uSG92ZXIoZmFsc2UpXCJcbiAgICAgW2NsYXNzLnUtY2FyZC1zZWxlY3RlZF09XCJzZWxlY3RlZFwiXG4gICAgIFtjbGFzcy51LWNhcmQtdW5zZWxlY3RlZF09XCIhc2VsZWN0ZWRcIlxuICAgICBbbmdDbGFzc109XCJzdHlsZUNsYXNzXCJcbj5cblxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLWJvZHkgdWktZ1wiICAqbmdJZj1cIiFzaG93Qm9keVRlbXBsYXRlKClcIj5cbiAgICAgICAgPCEtLSBIb3ZlciBlbGVtZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJ5IG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUgZXZlbnRzLS0+XG4gICAgICAgIDxkaXYgI2hvdmVyRGl2ICpuZ0lmPVwiaGFzSG92ZXJcIiBjbGFzcz1cInUtY2FyZC1ob3ZlclwiIChjbGljayk9XCJvbkhvdmVyQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPHNwYW4gW3N0eWxlLndpZHRoXT1cIicxMDAlJ1wiIGNsYXNzPVwic2FwLWljb25cIiBbbmdDbGFzc109XCJob3Zlckljb25cIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8IS0tIEhFQURFUiBIQVZJTkcgVElUTEUgQU5EIElDT05TL0FDVElPTlMtLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktZy1ub3BhZCB3LWNhcmQtaGVhZGVyXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy1jYXJkLXp0aXRsZSB1aS1nLW5vcGFkXCIgKGNsaWNrKT1cInRvZ2dsZVNlbGVjdCgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1wb2ludGVyXT1cInNlbGVjdGFibGVcIlxuICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7J3VpLWctOSc6IGhhc0FjdGlvbiB8fCBzZWxlY3RhYmxlLCAndWktZy0xMSc6ICFoYXNBY3Rpb24gJiYgIXNlbGVjdGFibGV9XCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY2FyZC10aXRsZVwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiaGFzQWN0aW9uIHx8IHNlbGVjdGFibGVcIiBjbGFzcz1cInctY2FyZC16YWN0aW9uIHVpLWctbm9wYWQgdWktZy0zXCI+XG5cbiAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cInNlbGVjdGVkICYmIHNlbGVjdGFibGVcIiBjbGFzcz1cInNhcC1pY29uIHNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1wb2ludGVyXT1cInNlbGVjdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy51LWNhcmQtYWN0aW9uLWJnXT1cInNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlU2VsZWN0KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInNlbGVjdGVkSWNvblwiPjwvc3Bhbj5cblxuXG4gICAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJoYXNBY3Rpb24gJiYgKCFzZWxlY3RlZCB8fCAhc2VsZWN0YWJsZSkgXCJcbiAgICAgICAgICAgICAgICAgICAgICBjbGFzcz1cInNhcC1pY29uIGFjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1wb2ludGVyXT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJvbkFjdGlvbkNsaWNrKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cImFjdGlvbkljb25cIlxuICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPCEtLVRPUCBDQVJEIFNFQ1RJT04tLT5cbiAgICAgICAgPGRpdiBjbGFzcz1cInctY2FyZC16dG9wIHVpLWctbm9wYWQgdWktZy0xMiBcIlxuICAgICAgICAgICAgIChjbGljayk9XCJ0b2dnbGVTZWxlY3QoJGV2ZW50KVwiXG4gICAgICAgICAgICAgW2NsYXNzLnUtY2FyZC1wb2ludGVyXT1cInNlbGVjdGFibGVcIj5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWNhcmQtdG9wXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1nLW5vcGFkIHctY2FyZC1saW5lLWRpdmlkZXIgIFwiICpuZ0lmPVwic2hvd0JvdHRvbVNlY3Rpb24oKVwiPjwvZGl2PlxuICAgICAgICA8IS0tQk9UVE9NIENBUkQgU0VDVElPTi0tPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd0JvdHRvbVNlY3Rpb24oKVwiIGNsYXNzPVwidWktZy0xMiB1aS1nLW5vcGFkIHctY2FyZC16Ym90dG9tXCJcbiAgICAgICAgICAgICBbY2xhc3MudS1jYXJkLXBvaW50ZXJdPVwic2VsZWN0YWJsZVwiXG4gICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZVNlbGVjdCgkZXZlbnQpXCI+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jYXJkLWJvdHRvbVwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2ICpuZ0lmPVwic2hvd0JvZHlUZW1wbGF0ZSgpXCIgY2xhc3M9XCJ3LWNhcmQtdXNlci1jbnRcIiA+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5VGVtcGxhdGVcIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnctY2FyZHtib3JkZXI6MnB4IHNvbGlkICMwMDc2Y2I7ZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO2NvbG9yOiM2MzYzNjM7Ym94LXNpemluZzpib3JkZXItYm94fS53LWNhcmQtaGVhZGVye3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDozMHB4O3BhZGRpbmctbGVmdDoxZW19LnctY2FyZC16dGl0bGV7aGVpZ2h0OjEwMCU7cGFkZGluZy10b3A6M3B4fS53LWNhcmQtenRpdGxlIDo6bmctZGVlcCAudy1jYXJkLXRpdGxle2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7ZGlzcGxheTpmbGV4fS53LWNhcmQtenRpdGxlIDo6bmctZGVlcCAudy1jYXJkLXRpdGxlPip7ZmxleDowIDF9LnctY2FyZC16YWN0aW9ue2hlaWdodDoxMDAlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246cmlnaHR9LnctY2FyZC16YWN0aW9uIC5zYXAtaWNvbnt3aWR0aDoyOXB4O2hlaWdodDoyOXB4O3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtc2l6ZToxLjVlbTtsaW5lLWhlaWdodDoxLjRlbX0udy1jYXJkLXphY3Rpb24gLnNhcC1pY29uLnNlbGVjdGlvbntjb2xvcjojZmZmfS53LWNhcmQtemFjdGlvbiAuc2FwLWljb24uYWN0aW9ue2NvbG9yOiM5Njk2OTZ9LnctY2FyZC16Ym90dG9tLC53LWNhcmQtenRvcHtwYWRkaW5nOjFlbX0udy1jYXJkLWxpbmUtZGl2aWRlcntib3JkZXItdG9wOjFweCBzb2xpZCAjZDZkNmQ2O21hcmdpbjowIDE0cHh9LnctY2FyZC11c2VyLWNudHt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3Bvc2l0aW9uOnJlbGF0aXZlO2JhY2tncm91bmQtY29sb3I6I2VlZX0udS1jYXJkLWhvdmVye3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxMDAlO3dpZHRoOjEwMCU7b3BhY2l0eTowO3RyYW5zaXRpb246LjVzIGVhc2U7YmFja2dyb3VuZC1jb2xvcjojMDA3NmNiO3otaW5kZXg6MTAwfS51LWNhcmQtaG92ZXIgLnNhcC1pY29ue3RleHQtYWxpZ246Y2VudGVyO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2ZvbnQtc2l6ZTo0ZW07Y29sb3I6I2ZmZjtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9LnUtY2FyZC1hY3Rpb24tYmd7YmFja2dyb3VuZDojMDA3NmNifS51LWlzLWhvdmVye3Bvc2l0aW9uOnJlbGF0aXZlfS51LWNhcmQtc2VsZWN0ZWR7Ym9yZGVyLWNvbG9yOiMwMDc2Y2J9LnUtY2FyZC11bnNlbGVjdGVke2JvcmRlci1jb2xvcjojZDdkN2Q3fS51LWNhcmQtaG92ZXIsLnUtY2FyZC1wb2ludGVye2N1cnNvcjpwb2ludGVyfWBdXG59KVxuZXhwb3J0IGNsYXNzIENhcmRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgd2Ugc2hvdWxkIGV4cGxpY2l0bHkgaGlkZSB0aGUgYWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhhc0FjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJcyBzZWxlY3RhYmxlIG1vZGUgc3VwcG9ydGVkPyBTYXlpbmcgWWVzLCBjYXJkIHdpbGwgaGF2ZSBieSBkZWZhdWx0IGNoZWNrLW1hcmsgaW4gdGhlXG4gICAgICogQUNUSU9OIHpvbmUgd2hlbiBzZWxlY3RlZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RhYmxlOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbiB0byBwYXNzIGN1c3RvbSBcIkNhcmQgU2VsZWN0ZWRcIiBJY29uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGVkSWNvbjogc3RyaW5nID0gJ2ljb24tYWNjZXB0JztcblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGlzIG5vIGRlZmF1bHQgdmFsdWUgZm9yIGFjdGlvbiBpY29uLCB3aGVuIGFwcGxpY2F0aW9uIHdhbnQgdG8gYWRkIGFjdGlvbiB0byB0aGUgY2FyZFxuICAgICAqIGl0IG11c3QgYWxzbyBwcm92aWRlIGEgaWNvblxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhY3Rpb25JY29uOiBzdHJpbmc7XG5cbiAgICAvKlxuICAgICAqIEVuYWJsZSBhbmQgZGlzYWJsZXMgaG92ZXIgZWZmZWN0IG9uIHRvcCBvZiB0aGUgY2FyZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGFzSG92ZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGVmYXVsdCBpY29uIG5hbWUgZm9yIHRoZSBob3ZlciBvdmVybGF5LiBUaGlzIGljb25zIHNob3dzIHVwIGluIHRoZSBtaWRkbGUgb3ZlciB0aGUgY2FyZFxuICAgICAqIHZlcnRpY2FsbHkgYW5kIGhvcml6b250YWxseSBjZW50ZXJlZFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBob3Zlckljb246IHN0cmluZyA9ICdpY29uLWFkZCc7XG5cblxuICAgIC8qKlxuICAgICAqICBTZWxlY3Rpb24gc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0ZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjYXJkIGlzIHNlbGVjdGVkLlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Q6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhY3Rpb24gaWNvbiBpcyBjbGlja2VkLlxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25BY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIGhvdmVyIG92ZXJsYXkuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkhvdmVyQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhpcyBxdWVyeSBpcyB1c2VkIHRvIHNhdmUgdGhlIGNvbnRlbnQgcmVmZXJlbmNlIHRvIGJvdHRvbSBzZWN0aW9uIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoQ2FyZFpvbmVCb3R0b21Db21wb25lbnQpXG4gICAgYm90dG9tOiBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgY3VzdG9tIHRlbXBsYXRlIGZvciB0aGUgYm9keSB3aGljaCBpcyB1bmRlciBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgY29udHJvbC5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdib2R5JylcbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIEBWaWV3Q2hpbGQoJ2hvdmVyRGl2JylcbiAgICBob3ZlckRpdjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIFVzdWFsbHkgd2hlbiB0ZW1wbGF0ZSBpcyBwcm92aWRlZCB3ZSB3YW50IHRvIHVzZSBpdCBhbmQgcmVwbGFjZSBpbnRlcm5hbCBvbmUgYnV0IGluIHRoaXNcbiAgICAgKiBjYXNlIGl0IHdpbGwgYmUgYWx3YXlzIGNvbmRpdGlvbmFsIGFuZCBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgY2FuIHN3aXRjaCBiZXR3ZWVuIGRlZmF1bHRcbiAgICAgKiB0ZW1wbGF0ZSB3aXRoIHpvbmVzIGFuZCBjdXN0b20gb25lIHByb3ZpZGVkIGJ5IGRldmVsb3Blci5cbiAgICAgKlxuICAgICAqL1xuICAgIHVzZUJvZHlUZW1wbGF0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgLy8gc2V0cyBkZWZhdWx0IHZhbHVlXG4gICAgICAgIHRoaXMud2lkdGggPSAnMjAycHgnO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICcxNTRweCc7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICAvLyBJZiBhcHBsaWNhdGlvbiB3YW50cyB0byB1c2UgYWN0aW9uIGl0IG11c3QgcHJvdmlkZSBhY3Rpb25JY29uXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuYWN0aW9uSWNvbikgJiYgdGhpcy5oYXNBY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG5lZWQgdG8gcHJvdmlkZSBhY3Rpb24gaWNvbicpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2hvd0JvdHRvbVNlY3Rpb24oKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJvdHRvbSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBmaXJlcyBzZWxlY3QgYW5kIHVuc2VsZWN0IGV2ZW50LlxuICAgICAqL1xuICAgIHRvZ2dsZVNlbGVjdChldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGFibGUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9ICF0aGlzLnNlbGVjdGVkO1xuICAgICAgICAgICAgdGhpcy5vblNlbGVjdC5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBPbmx5IGZpcmVkIHdoZW4gYWN0aW9uIGlzIHJlbmRlcmVkIGFuZCB1c2VyIGNsaWNrcyBvbiBjdXN0b20gYWN0aW9uSWNvblxuICAgICAqXG4gICAgICovXG4gICAgb25BY3Rpb25DbGljayhldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWN0aW9uICYmICghdGhpcy5zZWxlY3RlZCB8fCAhdGhpcy5zZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy5vbkFjdGlvbi5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkICB3aGVuIGhvdmVyIGVmZmVjdCBpcyBvbiArIHVzZXIgY2xpY2sgb24gdGhlIGNhcmRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSG92ZXIoaXNFbnRlcjogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ob3ZlckRpdikpIHtcbiAgICAgICAgICAgIHRoaXMuaG92ZXJEaXYubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gaXNFbnRlciA/IDAuNSA6IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCByZW5kZXIgaW1wbGljaXQgY2FyZCB0ZW1wbGF0ZSB3aXRoIG91ciB6b25lcyBvclxuICAgICAqIHVzZXIgcHJvdmlkZWQgdGVtcGxhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dCb2R5VGVtcGxhdGUoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmJvZHlUZW1wbGF0ZSkgICYmIHRoaXMudXNlQm9keVRlbXBsYXRlO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuXG5cbi8qKlxuICogTWFwcyBvdXIgaW50ZXJuYWwgYWxpZ25tZW50IHZhbHVlIHRvIHJlYWwgY3NzIHZhbHVlc1xuICpcbiAqL1xuY29uc3QgVkFsaWduTWFwID0ge1xuICAgICd0b3AtbGVmdCc6ICdmbGV4LXN0YXJ0JyxcbiAgICAndG9wLWNlbnRlcic6ICdmbGV4LXN0YXJ0JyxcbiAgICAndG9wLXJpZ2h0JzogJ2ZsZXgtc3RhcnQnLFxuICAgICdjZW50ZXItbGVmdCc6ICdjZW50ZXInLFxuICAgICdjZW50ZXItY2VudGVyJzogJ2NlbnRlcicsXG4gICAgJ2NlbnRlci1yaWdodCc6ICdjZW50ZXInLFxuICAgICdib3R0b20tbGVmdCc6ICdmbGV4LWVuZCcsXG4gICAgJ2JvdHRvbS1jZW50ZXInOiAnZmxleC1lbmQnLFxuICAgICdib3R0b20tcmlnaHQnOiAnZmxleC1lbmQnXG59O1xuXG5cbmNvbnN0IEhBbGlnbk1hcCA9IHtcbiAgICAndG9wLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ3RvcC1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAndG9wLXJpZ2h0JzogJ2ZsZXgtZW5kJyxcbiAgICAnY2VudGVyLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ2NlbnRlci1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAnY2VudGVyLXJpZ2h0JzogJ2ZsZXgtZW5kJyxcbiAgICAnYm90dG9tLWxlZnQnOiAnZmxleC1zdGFydCcsXG4gICAgJ2JvdHRvbS1jZW50ZXInOiAnY2VudGVyJyxcbiAgICAnYm90dG9tLXJpZ2h0JzogJ2ZsZXgtZW5kJ1xufTtcblxuXG4vKipcbiAqIFRpdGxlIHpvbmUgcHJvdmlkZXMgYSBjb250ZW50IHBsYWNlaG9sZGVyIGZvciB0aGUgVGl0bGUgQXJlYS4gVGhpcyB6b25lIGlzIGFkZGluZyBhYmlsaXR5XG4gKiB0byBhbGlnbiBpdHMgY29udGVudCBpbnRvIDkgZGlmZmVyZW50IHBvc2l0aW9uLlxuICpcbiAqIFlvdSBjYW4gdXNlIHRoaXMgVGl0bGUgem9uZSB3aXRoaW4gPGF3LWNhcmQ+IGFzOlxuICpcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogIDxhdy1jYXJkICBbd2lkdGhdPVwiJzIwMnB4J1wiIFtoZWlnaHRdPVwiJzE1NHB4J1wiIFtoYXNIb3Zlcl09XCJ0cnVlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0YWJsZV09XCJmYWxzZVwiIFtoYXNBY3Rpb25dPVwiZmFsc2VcIlxuICogICAgICAgICAgICAgICAgICAob25Ib3ZlckFjdGlvbik9XCJvbkFjdGlvbig3LCAkZXZlbnQpXCIgPlxuICpcbiAqICAgICAgICAgICAgICAgICAgPGF3LWNhcmQtdGl0bGUgW2FsaWduXT1cIidib3R0b20tbGVmdCdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYS1zdXBwbGllci10YWdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBQcmVmZXJyZWRcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgPC9hdy1jYXJkLXRpdGxlPlxuICpcbiAqICAgPC9hdy1jYXJkPlxuICpcbiAqIGBgYFxuICogRGVmYXVsdCBhbGlnbm1lbnQgaXMgdG9wLWxlZnRcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgYXctY2FyZC10aXRsZWAsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndy1jYXJkLXRpdGxlJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFpvbmVUaXRsZUNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIHByb3BlcnR5IHdoaWNoIGlzIHVzZWQgdG8gYXBwbHkgZmxleCBwcm9wZXJ0aWVzIGZvciBhbGlnbmluZyBjb250ZW50IHZlcnRpY2FsbHlcbiAgICAgKiBhcyB3ZWxsIGFzIGhvcml6b250YWxseVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhbGlnbjogQ2FyZFRpdGxlQWxpZ25tZW50ID0gJ3RvcC1sZWZ0JztcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBlbGVtOiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5zdHlsZS5hbGlnbkl0ZW1zID0gVkFsaWduTWFwW3RoaXMuYWxpZ25dO1xuICAgICAgICB0aGlzLmVsZW0ubmF0aXZlRWxlbWVudC5zdHlsZS5qdXN0aWZ5Q29udGVudCA9IEhBbGlnbk1hcFt0aGlzLmFsaWduXTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBNYWtlIHN1cmUgd2UgZG9udCBhY2NlcHQgYW55IHVuc3VwcG9ydGVkIHZhbHVlcy4gVGhlc2UgdmFsdWVzIG1hcHMgdG8gdGhlIEhBbGlnbk1hcCBhbmRcbiAqIFZBbGlnbk1hcCBpbiBvcmRlciB0byBnZXQgcmVhbCBjc3MgdmFsdWUgZm9yIHRoZSBmbGV4IGFsaWdubWVudFxuICovXG5leHBvcnQgdHlwZSBDYXJkVGl0bGVBbGlnbm1lbnQgPSAndG9wLWxlZnQnIHwgJ3RvcC1jZW50ZXInIHwgJ3RvcC1yaWdodCcgfCAnY2VudGVyLWxlZnQnIHxcbiAgICAnY2VudGVyLWNlbnRlcicgIHwgJ2NlbnRlci1yaWdodCcgfCAnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1jZW50ZXInIHwgJ2JvdHRvbS1yaWdodCc7XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0NhcmRDb21wb25lbnQsIENhcmRab25lQm90dG9tQ29tcG9uZW50LCBDYXJkWm9uZVRvcENvbXBvbmVudH0gZnJvbSAnLi9jYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQge0NhcmRab25lVGl0bGVDb21wb25lbnR9IGZyb20gJy4vY2FyZC10aXRsZS9jYXJkLXRpdGxlLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIENhcmRDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVGl0bGVDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lVG9wQ29tcG9uZW50LFxuICAgICAgICBDYXJkWm9uZUJvdHRvbUNvbXBvbmVudFxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2FyZENvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVUaXRsZUNvbXBvbmVudCxcbiAgICAgICAgQ2FyZFpvbmVUb3BDb21wb25lbnQsXG4gICAgICAgIENhcmRab25lQm90dG9tQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2FyZE1vZHVsZVxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1Db250cm9sLCBOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCb29sZWFuLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcblxuXG4vKipcbiAqICBDaGVja2JveFR5cGUgZGVzY3JpYmVzIHdoYXQgdHlwZSBvZiBjaGVja2JveCBpcyB0aGlzOlxuICpcbiAqIC0gRm9ybSB0eXBlOiB0aGF0IGlzIHdyaXRpbmcgYW5kIHJlYWRpbmcgYSB2YWx1ZSBmcm9tL3RvIG1vZGVsIGJvdGggdXNpbmcgRm9ybUdyb3VwIGFzIHdlbGxcbiAqICAgICAgICAgICAgICBhcyBuZ01vZGVsXG4gKiAtIEFjdGlvbiB0eXBlOiAgb25seSBmaXJlcyBhY3Rpb24gYW5kIGRvZXMgbm90IHdyaXRlIHZhbHVlIHRvIG1vZGVsLlxuICpcbiAqXG4gKi9cbmV4cG9ydCB0eXBlIENoZWNrYm94VHlwZSA9ICdmb3JtJyB8ICdhY3Rpb24nO1xuXG4vKipcbiAqXG4gKiBJbXBsZW1lbnRzIHN0YW5kYXJkIEhUTUwgY2hlY2tib3ggb24gdG9wIG9mIFByaW1lTkcuIFRoZXJlIGFyZSAyIHR5cGVzIG9mXG4gKiB7QGxpbmsgQ2hlY2tib3hDb21wb25lbnR9OiBmb3JtIGFuZCBhY3Rpb24gY2hlY2tib3ggYXMgZGVzY3JpYmVkIGFib3ZlLlxuICpcbiAqXG4gKiBVc2FnZTogQmFzaWMgZXhhbXBsZSBoYXZpbmcgcmVkIGNoZWNrYm94IGNoZWNrZWRcbiAqXG4gKiBgYGBIVE1MXG4gKiAgICAgICAgPGF3LWNoZWNrYm94IFtuYW1lXT1cIidjb2xvcidcIiBbdmFsdWVdPVwiJ3JlZCdcIiBbbGFiZWxdPVwiJ1JlZCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtb2RlbFwiPlxuICogICAgICAgIDwvYXctY2hlY2tib3g+XG4gKiAgICAgICAgPGF3LWNoZWNrYm94IFtuYW1lXT1cIidjb2xvcidcIiBbdmFsdWVdPVwiJ2JsdWUnXCIgW2xhYmVsXT1cIidCbHVlJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICA8L2F3LWNoZWNrYm94PlxuICpcbiAqIGBgYFxuICpcbiAqIGBgYHRzXG4gKlxuICpcbiAqICAgY2xhc3MgQ0JCYXNpY1dpdGhOZ01vZGVsQ29tcG9uZW50XG4gKiAgIHtcbiAqXG4gKiAgICAgICBtb2RlbDogc3RyaW5nW10gPSBbJ3JlZCddO1xuICpcbiAqICAgICAgIGNvbnN0cnVjdG9yKClcbiAqICAgICAgIHtcbiAqICAgICAgIH1cbiAqICAgfVxuICpcbiAqIGBgYFxuICpcbiAqIEZvciBtb3JlIGV4YW1wbGVzIHBsZWFzZSBzZWUgYSBwbGF5Z3JvdW5kIG9yIHVuaXQgdGVzdC5cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBDQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctY2hlY2tib3gnLFxuICAgIHRlbXBsYXRlOiBgPHNwYW4gY2xhc3M9XCJ3LWNoZWNrYm94XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGUgJiYgaXNGb3JtVHlwZSgpXCI+XG4gICAgICAgIDxwLWNoZWNrYm94IFtuYW1lXT1cIm5hbWVcIiBbdmFsdWVdPVwidmFsdWVcIiBbbGFiZWxdPVwibGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgW2JpbmFyeV09XCJpc0JpbmFyeVwiXG4gICAgICAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgW2NsYXNzLnUtdmFsaWRhdGlvbi1lcnJvcl09XCIhKGZvcm1Db250cm9sLnZhbGlkIHx8IChmb3JtQ29udHJvbC5wcmlzdGluZSkpXCJcbiAgICAgICAgPlxuICAgICAgICA8L3AtY2hlY2tib3g+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFpc0Zvcm1UeXBlKClcIj5cbiAgICAgICAgPHAtY2hlY2tib3ggW2JpbmFyeV09XCJpc0JpbmFyeVwiXG4gICAgICAgICAgICAgICAgICAgIFtsYWJlbF09XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIlxuICAgICAgICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuICAgICAgICA8L3AtY2hlY2tib3g+XG5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9zcGFuPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC51aS1jaGtib3ggLnVpLWNoa2JveC1ib3h7d2lkdGg6MjJweDtoZWlnaHQ6MjJweH0vZGVlcC8gLnVpLWNoa2JveCAucGl7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2NvbG9yOiMxOTlkZTA7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuMDdlbTtsaW5lLWhlaWdodDoxLjQyZW19L2RlZXAvIC51aS1jaGtib3ggLnBpLnBpLWNoZWNrOmJlZm9yZXtjb250ZW50OidcXFxcZTA1Yid9YF0sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgQ0JfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja2JveENvbXBvbmVudCl9XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja2JveENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEEgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY2hlY2tib3hcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBUeXBlIG9mIGNoZWNrYm94LiBGb3JtIGJhc2VkIHVwZGF0ZXMgbW9kZWwgYW5kIEFjdGlvbiBiYXNlZCBvbmx5IGZpcmVzIGNsaWNrIGV2ZW50c1xuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBDaGVja2JveFR5cGUgPSAnZm9ybSc7XG5cblxuICAgIC8qKlxuICAgICAqIExhYmVsIHRvIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgYSBjaGVja2JveFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBjbGljayBldmVudC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBQcmltZU5HIGhhcyB0aGlzIHR5cGUgY2FsbGVkIGJpbmFyeSB3aGljaCB3b3JrcyBvbmx5IHdpdGggQm9vbGVhbiBtZWFuaW5nIGl0IGRvZXMgbm90IGFkZCBvclxuICAgICAqIHJlbW92ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBJbiBvdXIgY2FzZSBDaGVja3R5cGUgPSBBY3Rpb24gaXMgYWx3YXlzIGJpbmFyeSBvciB3aGVuIHRoaXMudmFsdWUgaXMgYm9vbGVhblxuICAgICAqXG4gICAgICovXG4gICAgaXNCaW5hcnk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsIGZvciBjaGVja2JveFxuICAgICAqL1xuICAgIG1vZGVsOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5tb2RlbCA9IHRoaXMudmFsdWU7XG4gICAgICAgIHRoaXMudHlwZSA9IHRoaXMuYWN0aW9uLm9ic2VydmVycy5sZW5ndGggPiAwID8gJ2FjdGlvbicgOiB0aGlzLnR5cGU7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNGb3JtVHlwZSgpKSB7XG4gICAgICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdldCBjb250cm9sIGZyb20gcGFyZW50XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHZhbHVlIGlzIGJvb2xlYW4gd2UgYXJlIGRlYWxpbmcgd2l0aCBQcmltZU5nIEJpbmFyeSBjaGVja2JveFxuICAgICAgICAvLyB3aGljaCBvbmx5IHNldHMgVFJVRS9GQUxTRSBhbmQgZG9lcyBub3QgYWRkIG9yIHJlbW92ZSB2YWx1ZXNcbiAgICAgICAgdGhpcy5pc0JpbmFyeSA9IGlzQm9vbGVhbih0aGlzLnZhbHVlKTtcblxuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlc1sndmFsdWUnXSkgJiZcbiAgICAgICAgICAgIChjaGFuZ2VzWyd2YWx1ZSddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1sndmFsdWUnXS5wcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGNoYW5nZXNbJ3ZhbHVlJ10uY3VycmVudFZhbHVlO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIENoZWNrYm94IGlzIGNsaWNrZWQgYW5kIGl0IGVpdGhlciBmaXJlIGFjdGlvbiBvciB1cGRhdGVzIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5pc0Zvcm1UeXBlKCkpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hY3Rpb24uZW1pdChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbCBpZiB3ZSBhcmUgdXNpbmcgRm9ybSBDaGVja2JveC4gVGhpcyBpcyB1c2VkIHJlbW92ZSBzb21lIG9mIHRoZSBiaW5kaW5ncyB0aGF0IGFyZSBub3RcbiAgICAgKiBhcHBsaWNhYmxlIGZvciBjZXJ0YWluIHR5cGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0Zvcm1UeXBlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdmb3JtJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1vZGVsICYmIHRoaXMuaXNGb3JtVHlwZSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtDaGVja2JveENvbXBvbmVudH0gZnJvbSAnLi9jaGVja2JveC5jb21wb25lbnQnO1xuaW1wb3J0IHtDaGVja2JveE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDaGVja2JveENvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZVxuICAgIF0sXG5cbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgQ2hlY2tib3hDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2hlY2tib3hDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ2hlY2tCb3hNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Zvcm1Sb3dDb21wb25lbnR9IGZyb20gJy4uLy4uL2xheW91dHMvZm9ybS10YWJsZS9mb3JtLXJvdy9mb3JtLXJvdy5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogIENoZWNrYm94IGxpc3QgaXMgYSB3cmFwcGVyIGNsYXNzIGFyb3VuZCAnQ2hlY2tib3gnIGNvbXBvbmVudCB0byBzaW1wbHkgYXNzZW1ibHkgb2YgbXVsdGkgY2hvaWNlXG4gKiBjb21wb25lbnRcbiAqXG4gKiBJbiBBZGRpdGlvbiBpdCBhZGRzIGFiaWxpdHkgdG8gd29yayB3aXRoIGNvbXBsZXggb2JqZWN0LiBQcmltZU5HIGNoZWNrYm94ZXMgd29yayBvbmx5IHdpdGhcbiAqIHByaW1pdGl2ZSB2YWx1ZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgY2hlY2stYm94L2NoZWNrLWJveC5jb21wb25lbnQudHN9XG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICpcbiAqICAgIEBDb21wb25lbnQoe1xuICogICAgICAgc2VsZWN0b3I6ICdzaG93Q2hlY2tCb3hMaXN0JyAsXG4gKiAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgIDxhdy1jaGVja2JveC1saXN0IFtsaXN0XT1cImNoZWNrQm94TGlzdFZhbHVlc1wiIFtzZWxlY3Rpb25zXT1cInNlbGVjdGVkVmFsdWVzXCJcbiAqXG4gKiAgICAgICAgICAgIFtuYW1lXT1cIidteUNvbG9ycydcIiBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiIChvblNlbGVjdGlvbik9XCJvbkNCQ2xpY2tcIj5cbiAqICAgICAgICAgICA8L2F3LWNoZWNrYm94LWxpc3Q+XG4gKiAgICAgICBgXG4gKlxuICogICAgICAgfSlcbiAqICAgICAgICBjbGFzcyBNeVNob3dDTENvbXBvbmVudFxuICogICAgICAgIHtcbiAqICAgICAgICAgICAgY2hlY2tCb3hMaXN0VmFsdWVzOiBzdHJpbmdbXSA9IFsnYmx1ZScgLCAncmVkJyAsICd5ZWxsb3cnICwgJ29yYW5nZScgLCAnd2hpdGUnICxcbiAqICAgICAnc2lsdmVyJyAsICdibGFjaycgLFxuICogICAgICAgICAgICAnR3JlZW4nICwgJ0dyYXknICwgJ05hdnknICwgJ09saXZlJyAsICdBcXVhJyAsICdQdXJwbGUnXTtcbiAqXG4gKiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzOiBzdHJpbmdbXSA9IFsnYmx1ZScgLCAnT2xpdmUnICwgJ0FxdWEnICwgJ1B1cnBsZSddO1xuICpcbiAqXG4gKiAgICAgICAgICAgIGZvcm1Hcm91cDogRm9ybUdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gKlxuICpcbiAqICAgICAgICAgICAgb25DQkNsaWNrIChldmVudCk6IHZvaWRcbiAqICAgICAgICAgICAge1xuICogICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ29uQ0JDbGljayA9ICcgKyBldmVudCk7XG4gKiAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgfVxuICoqXG4gKi9cblxuXG5cblxuZXhwb3J0IGNvbnN0IENCX0xJU1RfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrQm94TGlzdENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jaGVja2JveC1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nRm9yPVwibGV0IGl0ZW0gb2YgbGlzdDsgbGV0IGkgPSBpbmRleFwiIGNsYXNzPVwidWktZ1wiPlxuXG4gICAgPCEtLSBpbiB0aGUgZnV0dXJlIHdlIHNob3VsZCBiZSBhYmxlIHRvIHRvIHN1cHBvcnQgaW5saW5lIGFuZCBzdGFjay0tPlxuICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyXCI+XG4gICAgICAgIDxhdy1jaGVja2JveCBbKG5nTW9kZWwpXT1cIm1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwiaVwiXG4gICAgICAgICAgICAgICAgICAgICBbbGFiZWxdPVwibGFiZWxWYWx1ZShpdGVtKVwiPlxuXG4gICAgICAgIDwvYXctY2hlY2tib3g+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuXG5gLFxuICAgIHN0eWxlczogW2BgXSxcblxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tCb3hMaXN0Q29tcG9uZW50KX1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIENoZWNrQm94TGlzdENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgdmFsdWVzIHVzZWQgdG8gcmVuZGVyIGNoZWNrYm94ZXMuIEV2ZW4gd2UgaGF2ZSBoZXJlIHR5cGUgYXMgQU5ZIHdlIGludGVybmFsbHlcbiAgICAgKiBzdXBwb3J0IG9ubHkgc3RyaW5nIGF0IHRoZSBtb21lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU2VsZWN0aW9ucyBhcmUgZGVmYXVsdCBDSEVDS0VEIHZhbHVlcyBwYXNzZWQuIGUuZy4gV2hlbiByZW5kZXJpbmcgZmllbGQgZmF2b3JpdGUgY29sb3JzOlxuICAgICAqIGJsdWUsIHJlZCwgeWVsbG93IHlvdSB3aWxsIHBhc3MgaW4gaGVyZSBibHVlLCByZWQsIHRoZW4gY2hlY2tib3hlcyB3aXRoIHZhbHVlIGJsdWUsIHJlZCB3aWxcbiAgICAgKiBiZSByZW5kZXJlZCBhcyBjaGVjayBhbmQgeWVsbG93IHVuY2hlY2tlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2VsZWN0aW9uczogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBGaXJlcyBldmVudCB3aGVuIGNoZWNrYm94IGlzIHNlbGVjdGVkL2NsaWNrZWQuIEVtaXRzIGN1cnJlbnQgY2xpY2tlZCBjaGVja2JveGVkLiBub3QgdGhlXG4gICAgICogYWN0dWFsbCBpbnRlcm5hbCBtb2RlbCB2YWx1ZSBpbiB0aGlzIGNhc2UgYXJyYXkgb2YgY2hvaWNlc1xuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBzcGVjaWFsIGV4cHJlc3Npb24gdG8gZm9ybWF0IGxhYmVsXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbEZvcm1hdHRlcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWxcbiAgICAgKi9cbiAgICBtb2RlbDogYW55ID0gW107XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNkOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbnMpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWwodGhpcy5zZWxlY3Rpb25zKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnNlbGVjdGlvbnMpO1xuICAgIH1cblxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCB1cGRhdGVkTW9kZWw6IGFueVtdID0gW107XG5cbiAgICAgICAgdGhpcy5tb2RlbC5mb3JFYWNoKChpbmRleDogbnVtYmVyKSA9PiB1cGRhdGVkTW9kZWwucHVzaCh0aGlzLmxpc3RbaW5kZXhdKSk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodXBkYXRlZE1vZGVsLCB7XG4gICAgICAgICAgICBlbWl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgaXMgZXh0cmFjdGVkIGludG8gdGhpcyBtZXRob2Qgc28gaW4gdGhlIGZ1dHVyZSB3ZSBjYW4gcGxheSBtb3JlIGhvdyB3ZSB3YW50IHRvIGRpc3BsYXlcbiAgICAgKiB0aGUgdmFsdWUuIFNpbmNlIEkgd2FudCB0byBzdXBwb3J0IGZvcm1hdHRlcnMgZm9yIGVhY2ggY29tcG9uZW50cyB3ZSBtaWdodCBoYXZlIGEgY2hhbmNlIHRvXG4gICAgICogZGVjaWRlIGhvdyBsYWJlbCB3aWxsIGxvb2sgbGlrZS5cbiAgICAgKlxuICAgICAqL1xuICAgIGxhYmVsVmFsdWUoaXRlbTogYW55KTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGFiZWxGb3JtYXR0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYWJlbEZvcm1hdHRlcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbS50b1N0cmluZygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW4gdGhpcyB2ZXJzaW9uIG9mIGNoZWNrYm94ZXMgd2Ugc3RpbGwgZXhwZWN0IG9ubHkgcHJpbWl0aXZlIHR5cGVzLiBLZWVwIHRoaXMgZnVuY3Rpb25hbGl0eVxuICAgICAqIGluIGV4dHJhIG1ldGhvZCBzbyB3ZSBjYW4gd29yayB3aXRoIGl0IGV2ZW4gbm93IHdlIGp1c3QgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2tcbiAgICAgKi9cbiAgICB2YWx1ZShpdGVtOiBhbnkpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlbGVnYXRlIGV2ZW50IG91dHNpZGUgb2YgdGhpcyBjb21wb25lbnQgYW5kIGNvbnZlcnQgaW5kZXhlZCBtb2RlbCB0byBvcmlnaW5hbCBvYmplY3RzXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRNb2RlbDogYW55W10gPSBbXTtcblxuICAgICAgICB0aGlzLm1vZGVsLmZvckVhY2goKGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHVwZGF0ZWRNb2RlbC5wdXNoKHRoaXMubGlzdFtpbmRleF0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodXBkYXRlZE1vZGVsKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNpbmNlIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBjb21wbGV4IG9iamVjdCBzdG9yZSBvbmx5IElOREVYZXMgbnVtYmVyIGluIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZU1vZGVsKHNvdXJjZUxpc3Q6IGFueVtdKTogdm9pZFxuICAgIHtcbiAgICAgICAgc291cmNlTGlzdC5mb3JFYWNoKChpdGVtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMubGlzdC5maW5kSW5kZXgoKGVsZW06IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXF1YWxzKGl0ZW0sIGVsZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnB1c2goaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubW9kZWwpICYmIGlzUHJlc2VudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBuZXdNb2RlbCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNb2RlbChuZXdNb2RlbCk7XG5cbiAgICAgICAgICAgIC8vIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NoZWNrQm94TGlzdENvbXBvbmVudH0gZnJvbSAnLi4vY2hlY2stYm94LWxpc3QvY2hlY2stYm94LWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveE1vZHVsZX0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2hlY2tCb3hMaXN0Q29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hNb2R1bGVcbiAgICBdLFxuXG5cbiAgICBleHBvcnRzOiBbXG4gICAgICAgIENoZWNrQm94TGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0NoZWNrQm94TGlzdE1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogSHlwZXJsaW5rIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgY29uc2lzdGVudCBzdHlsaW5nLCBiZWhhdmlvci4gSHlwZXJsaW5rIHN1cHBvcnRzIGFsbCBvZiB0aGVcbiAqIG5hdGl2ZSBsaW5rIGZ1bmN0aW9uYWxpdHkuIEluIGFkZGl0aW9uLCBpdCBzdXBwb3J0cyBuYXZpZ2F0aW9uIHRvIGNvbXBvbmVudHMgdGhyb3VnaCB0aGUgYWN0aW9uXG4gKiBiaW5kaW5nLlxuICpcbiAqXG4gKiBmb3IgbW9yZSBpbmZvIHBsZWFzZSBzZWUgY2xhc3MgRG9jIG9mIHRoZTpcbiAqICBAc2VlIHtAbGluayBidXR0b24vYnV0dG9uLmNvbXBvbmVudC50c31cbiAqXG4gKiAgIyMjIEV4YW1wbGVcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JlZ2lzdHJhdGlvbicgLFxuICogICAgdGVtcGxhdGU6IGBcbiAqXG4gKiAgICAgICAgICAgPGF3LWh5cGVybGluayAgW3R5cGVdPVwiJ3RleHQvaHRtbCdcIiBbbmFtZV09XCInbGluaydcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAoYWN0aW9uKT1cIm9uQ2xpY2tlZCgkZXZlbnQpXCIgW3ZhbHVlXT1cImN1c3RvbWVySWRcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbc2l6ZV09XCInbGFyZ2UnXCIgPm15IGxpbms8L2F3LWh5cGVybGluaz5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgY29tbWFuZDpib29sZWFuO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgICAgIG9uQ2xpY2tlZChjdXN0b21lcklkOnN0cmluZykge1xuICogICAgICAgICAgIGlmIChjdXN0b21lcklkKSB7XG4gKiAgICAgICAgICAgICAgLy8gZGlzcGxheSBjdXN0b21lciBkZXRhaWxzIGNvbXBvbmVudC5cbiAqICAgICAgICAgICB9XG4gKiAgICAgICAgfVxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWh5cGVybGluaycsXG4gICAgdGVtcGxhdGU6IGA8YSBbYXR0ci50eXBlXT1cInR5cGVcIlxuICAgW2F0dHIuaHJlZl09XCJocmVmXCJcbiAgIFthdHRyLnJlbF09XCJyZWxcIlxuICAgW2F0dHIudGFyZ2V0XT1cInRhcmdldFwiXG4gICBbbmdDbGFzc109XCJsaW5rQ2xhc3NcIlxuICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgIChjbGljayk9XCJjbGlja2VkKCRldmVudClcIj5cblxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvYT5cbmAsXG4gICAgc3R5bGVzOiBbYC5saW5re2NvbG9yOiMwMjc1ZDg7Y3Vyc29yOnBvaW50ZXJ9LmxpbmsubGluay1iaHtjb2xvcjojMDI3NWQ4fS5saW5rLmxpbmstYmg6aG92ZXJ7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZTtjdXJzb3I6cG9pbnRlcn0ubGluay1zbXtmb250LXNpemU6Ljg3NWVtfS5saW5rLW1pZHtmb250LXNpemU6MWVtfS5saW5rLWxne2ZvbnQtc2l6ZToxLjI1ZW19LmxpbmsuZGlzYWJsZWR7cG9pbnRlci1ldmVudHM6bm9uZTtjdXJzb3I6ZGVmYXVsdDtjb2xvcjojZGRkfWBdXG59KVxuZXhwb3J0IGNsYXNzIEh5cGVybGlua0NvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqICAgIFNwZWNpZmllcyB0aGUgbWVkaWEgdHlwZSBvZiB0aGUgbGlua2VkIGRvY3VtZW50LiBNaW1lIHR5cGVcbiAgICAgKiAgICBleDogW3RleHQvaHRtbCB8IHRleHQvY3N2IHwgaW1hZ2UvcG5nIHwgYXVkaW8vM2dwcCB8IC4uLi5dXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiB1cmwgZm9yIHRoaXMgaHlwZXJsaW5rLiBDYW4gYmUgdXNlZCB0byBuYXZpZ2F0ZSB0byBhIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhyZWY6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIHJlbCBmb3IgdGhpcyBoeXBlcmxpbmsuIFNwZWNpZnkgdGhlIHJlbGF0aW9uc2hpcCBvZiB0aGUgY3VycmVudCBkb2N1bWVudCBhbmQgbGlua2VkIGRvY3VtZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc2l6aW5nIGZvciB0aGlzIGxpbmsuIFtsYXJnZSwgbm9ybWFsLCBzbWFsbF0uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaXplOiBMaW5rU2l6ZSA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogU3BlY2lmeSB0aGUgdGFyZ2V0IG9mIHRoZSBoeXBlcmxpbmsuIFtfYmxhbmsgfCBfc2VsZiB8IF9wYXJlbnQgfCBfdG9wIHwgZnJhbWVuYW1lIF1cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRhcmdldDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gYmUgc2VuZCB0byBzZXJ2ZXIgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgYWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIENTUyBjbGFzcyB0aGF0IHN0eWxlcyB0aGlzIGh5cGVybGluayBiYXNlZCBvbiBpbnB1dCAnc2l6ZSdcbiAgICAgKi9cbiAgICBsaW5rQ2xhc3M6IHN0cmluZyA9ICdsaW5rJztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBsaW5rIGNsYXNzIGJhc2VkIG9uIGlucHV0IHNpemUuXG4gICAgICAgIGlmICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zaXplKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbGFyZ2UnIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLWxnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbm9ybWFsJyA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlua0NsYXNzICs9ICcgbGluay1taWQnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzbWFsbCcgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpbmtDbGFzcyArPSAnIGxpbmstc20nO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIEkgaGF2ZSBhbiBhY3Rpb24gdGFnLCBhbmQgbm8gaHJlZi4gV2UgYWRkIGRlZmF1bHQgc3R5bGluZyBhbmQgYmVoYXZpb3IuXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbi5vYnNlcnZlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5rQ2xhc3MgKz0gJyBsaW5rLWJoJztcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEFjdGlvbiBjbGlja2VkLiBDYWxsIHBhcmVudCBhY3Rpb24uXG4gICAgICovXG4gICAgY2xpY2tlZChldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5hY3Rpb24uZW1pdCh7XG4gICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogU3VwcG9ydGVkIExpbmsgU2l6ZVxuICovXG5leHBvcnQgdHlwZSBMaW5rU2l6ZSA9ICdsYXJnZScgfCAnbm9ybWFsJyB8ICdzbWFsbCc7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0h5cGVybGlua0NvbXBvbmVudH0gZnJvbSAnLi9oeXBlcmxpbmsuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBIeXBlcmxpbmtDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgSHlwZXJsaW5rQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEh5cGVybGlua0NvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0h5cGVybGlua01vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHt1bmltcGxlbWVudGVkfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuXG4vKipcbiAqIFNlbGVjdGlvbiBTdGF0ZSBmb3IgdGhlIGNob29zZXIgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBjb211bmljYXRlIHdpdGggdGhlIHBhcmVudCBvYmplY3QgdXNpbmcgYVxuICogY2hvb3Nlci4gSWYgSSB3b3VsZCBoYXZlIHRvIG1hbmFnZSBvbmx5IHNpbmdsZSB2YWx1ZXMgd2l0aCBubyBhZGRpb25hbCBtZXRob2RzIGkgd291bGQgdXNlclxuICogZW1pdHRlcnMgdG8gZG8gdGhlIGpvYiwgYnV0IGluIHRoaXMgY2FzZSB3ZSBuZWVkIHRoaXMgaW50ZXJmYWNlIChhYnN0cmFjdCBjbGFzcykgYmV0d2VlbiBhXG4gKiBjaG9vc2VyIGFuZCBhY3R1YWwgb2JqZWN0LlxuICpcbiAqXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNldCBzZWxlY3Rpb24gc3RhdGUgaXMgdXN1YWxseSB0cmlnZ2VyZWQgYnkgc2VsZWN0aW5nIGFuZCB1bnNlbGVjdGluZyBhIGl0ZW0gKGluIGNhc2Ugb2ZcbiAgICAgKiBtdWx0aXNlbGVjdCkgYW5kIGl0IHNob3VsZCB1cGRhdGUgaXRzIGxpc3Qgb2Ygb2JqZWN0cyB3aXRoIGVpdGhlciBzZXR0aW5ncy9hZGRpbmcgaXRlbSBvclxuICAgICAqIHJlbW92aW5nIGl0LlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gLiBOdWxsIGlmIGxhc3QgYWN0aW9uIHdhcyBhIGRlc2VsZWN0aW9uLiBVc3VhbGx5IHVzZWQgYnkgQ2hvb3NlclxuICAgICAqIG9yIENob29zZXJTdGF0ZSB0byBnZXQgY3V1cmVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHVuaW1wbGVtZW50ZWQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBpdGVtIHNlbGVjdGlvbiBpdGVtcyBpcyBpbiB0aGUgc2VsZWN0ZWRPYmplY3RzXG4gICAgICovXG4gICAgaXNTZWxlY3RlZChzZWxlY3Rpb246IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB1bmltcGxlbWVudGVkKCk7XG4gICAgfVxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7aXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Nob29zZXJTZWxlY3Rpb25TdGF0ZX0gZnJvbSAnLi9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZSc7XG5pbXBvcnQge0RhdGFTb3VyY2V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5cbi8qKlxuICogQ2hvb3NlclN0YXRlIG1hbmFnZXMgY29tcGxldGUgbGlmZWN5Y2xlIGZvciB0aGUgQ2hvb3NlciBDb21wb25lbnQuIEl0IGtlZXBzIHRyYWNrIG9mIGN1cnJlbnRcbiAqIHNlbGVjdGlvbiBhcyB3ZWxsIGFzIGl0IGNhbiBicm9hZGNhc3QgYW55IHVwZGF0ZXMuXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENob29zZXJTdGF0ZVxue1xuXG4gICAgLyoqXG4gICAgICogIENhbGxiYWNrIHRvIHRoZSBwYXJlbnQgb2JqZWN0IHRvIHN0b3JlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICovXG4gICAgc2VsZWN0aW9uU3RhdGU6IENob29zZXJTZWxlY3Rpb25TdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIHRvZG86IFdlIGRvIG5vdCBuZWVkZWQgdGhpcyAhIVxuICAgICAqL1xuICAgIGN1cnJlbnRJdGVtOiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIHBhdHRlcm4uIFVzZXIgbGF0ZXN0IGlucHV0IHRvIHRoZSBjaG9vc2VyIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgcGF0dGVybjogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBMYXN0IHN1Y2Nlc3NmdWxsIHBhdHRlcm4gdGhhdCByZXRyaWV2ZWQgc29tZSBkYXRhXG4gICAgICovXG4gICAgbGFzdEZ1bGxNYXRjaFBhdHRlcm46IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBtYXRjaGVkIGl0ZW1zIHVzaW5nIENob29zZXJTZWxlY3Rpb25TdGF0ZVxuICAgICAqL1xuICAgIG1hdGNoZXM6IEFycmF5PGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbXVsdGlzZWxlY3QgY2hvb3NlclxuICAgICAqL1xuICAgIG11bHRpc2VsZWN0OiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEltcGxlbWVudGF0aW9uIGNhbiBzZXQgbG9va3VwIGtleSB0byBuYXJyb3cgdGhlIHNlYXJjaC4gSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBvYmplY3RcbiAgICAgKiB5b3Ugc2hvdWxkIHNldCB0aGlzLlxuICAgICAqXG4gICAgICovXG4gICAgbG9va3VwS2V5OiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIHByZXZpb3VzIGRpc3BsYXkgdmFsdWUgaXMgc2V0IHdoZW4gdGhlIGRpc3BsYXkgdmFsdWUgaXMgcmVuZGVyZWQgb24gdGhlIGNob29zZXIuIHdlIGNhY2hlXG4gICAgICogdGhlIFVJIHZhbHVlIHRvIGNvbXBhcmUgd2l0aCB0aGUgaW5ib3VuZCB2YWx1ZSBsYXRlciBpbnN0ZWFkIG9mIHRoZSB2YWx1ZSBmcm9tIHVuZGVybHlpbmdcbiAgICAgKiBvYmplY3QgYmVjYXVzZSBidXNpbmVzcyBsb2dpYyBsZXZlbCBjb2RlIGNvdWxkIGhhdmUgY2hhbmdlZCB0aGUgdW5kZXJseWluZyBvYmplY3QncyB2YWx1ZVxuICAgICAqXG4gICAgICogdG9kbzogZG8gSSBzdGlsbCBuZWVkIHRoaXM/XG4gICAgICovXG4gICAgcHJldkRpc3BsYXlWYWx1ZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlcmUgYXJlIGFueSB2YWxpZGF0aW9uIGxpa2UgZW50ZXJlZCB2YWx1ZSBkb2VzIG5vdCBtdWNoIHdpdGggdGhlIHNvdXJjZSBsaXN0LlxuICAgICAqXG4gICAgICovXG4gICAgaXNJbnZhbGlkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIGluZGljYXRlcyB0aGF0IHdlIHN0YXJ0ZWQgdG8gc29tZSBlZGl0aW5nIGUuZy4gc3RhcnRpbmcgdG8gdHlwZSBpbiBzb21ldGhpbmcgaW50byB0aGVcbiAgICAgKiBmaWx0ZXIsIG9yIHJlbW92aW5nIGFscmVhZHkgc2VsZWN0ZWQgaXRlbXNcbiAgICAgKi9cbiAgICBhZGRNb2RlOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIHJlY2VudFNlbGVjdGVkRGlzcGxheWVkOiBudW1iZXIgPSAwO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSB3ZSBkbyBub3Qgc2hvdyBhbGwgc2VsZWN0ZWQgaXRlbXMsIGJ1dCBtYXggbnVtYmVyIHRoYXQgaXNcbiAgICAgKiBkZWZpbmVkLiBVc2VyIGlzIGFibGUgdG8gdG9nZ2xlIHRvIGV4cGFuZCB0aGUgdmlldyB0byBzZWUgYWxsIHNlbGVjdGlvbnMgYW5kIGhpZGUgdGhlbSBhc1xuICAgICAqIHdlbGxcbiAgICAgKi9cbiAgICBzaG93QWxsUmVjZW50bHlTZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihjaG9vc2VyU2VsZWN0aW9uU3RhdGU/OiBDaG9vc2VyU2VsZWN0aW9uU3RhdGUsIGlzTXVsdGk6IGJvb2xlYW4gPSB0cnVlKVxuICAgIHtcblxuICAgICAgICB0aGlzLnNlbGVjdGlvblN0YXRlID0gY2hvb3NlclNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm11bHRpc2VsZWN0ID0gaXNNdWx0aTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvblN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZSA9IG5ldyBEZWZhdWx0U2VsZWN0aW9uU3RhdGUodGhpcy5tdWx0aXNlbGVjdCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXQgd2lsbCBzZWxlY3QgYW5kIHBlcnNpc3QgYW4gaXRlbSB1c2luZyBDaG9vc2VyU2VsZWN0aW9uU3RhdGUgcHJvdmlkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICB1cGRhdGVkU2VsZWN0ZWRPYmplY3RzKGl0ZW06IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5jdXJyZW50SXRlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZE9iamVjdCA9IHRoaXMuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgICAgIGxldCBzZWxlY3RlZE9iamVjdHMgPSB0aGlzLnNlbGVjdGVkT2JqZWN0cygpO1xuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmFkZE1vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0ludmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzZWxlY3RlZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0ZWRPYmplY3QsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhdGUoaXRlbSwgIUxpc3RXcmFwcGVyLmNvbnRhaW5zQ29tcGxleChzZWxlY3RlZE9iamVjdHMsIGl0ZW0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJlc2VudChzZWxlY3RlZE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3RlZE9iamVjdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvblN0YXRlKGl0ZW0sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzZXIgc2VsZWN0aW9uIGlzIGxhcmdlIHdlIHVzZSB0aGlzIG1ldGhvZCB0byBjaGVjayBpZiB3ZSBuZWVkIHRvIHNob3cgYWxsIHNlbGVjdGVkXG4gICAgICogaXRlbXMgb3Igb25seSBNYXhSZWNlbnRTZWxlY3RlZFxuICAgICAqL1xuICAgIHRvZ2dsZUFsbFNlbGVjdGVkKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQgPSAhdGhpcy5zaG93QWxsUmVjZW50bHlTZWxlY3RlZDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVuZGVycyB1c2VyJ3Mgc2VsZWN0aW9uIHVuZGVyIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IHJlY2VudFNlbGVjdGVkT2JqZWN0cygpOiBBcnJheSA8YW55PlxuICAgIHtcblxuICAgICAgICBpZiAoIXRoaXMubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZWNlbnRTZWxlY3RlZE9iamVjdHM6IGFueVtdID0gW107XG4gICAgICAgIHRoaXMucmVjZW50U2VsZWN0ZWREaXNwbGF5ZWQgPSAwO1xuICAgICAgICBsZXQgc2VsZWN0ZWRPYmplY3RzID0gdGhpcy5zZWxlY3RlZE9iamVjdHMoKTtcbiAgICAgICAgbGV0IHNpemUgPSBzZWxlY3RlZE9iamVjdHMubGVuZ3RoO1xuICAgICAgICBsZXQgbWF4Q291bnQgPSBEYXRhU291cmNlLk1heFJlY2VudFNlbGVjdGVkO1xuICAgICAgICBpZiAoc2l6ZSA+IERhdGFTb3VyY2UuTWF4UmVjZW50U2VsZWN0ZWQgJiYgIXRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG1heENvdW50IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvd0FsbFJlY2VudGx5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIG1heENvdW50ID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSBzaXplIC0gMTsgaSA+PSAwICYmICh0aGlzLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkIDwgbWF4Q291bnQpOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBzZWxlY3RlZE9iamVjdHNbaV07XG4gICAgICAgICAgICByZWNlbnRTZWxlY3RlZE9iamVjdHMucHVzaChzZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZWNlbnRTZWxlY3RlZERpc3BsYXllZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlY2VudFNlbGVjdGVkT2JqZWN0cztcbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblN0YXRlLnNlbGVjdGVkT2JqZWN0KCk7XG4gICAgfVxuXG5cbiAgICBzZWxlY3RlZE9iamVjdHMoKTogQXJyYXk8YW55PlxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU3RhdGUuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgfVxuXG4gICAgc2V0U2VsZWN0aW9uU3RhdGUoc2VsZWN0aW9uOiBhbnksIHNlbGVjdGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChzZWxlY3Rpb24pXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGF0ZS5zZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb24sIHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbi8qKlxuICogRHVtbXkgaW1wbGVtZW50YXRpb24gQ2hvb3NlclNlbGVjdGlvblN0YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U2VsZWN0aW9uU3RhdGUgZXh0ZW5kcyBDaG9vc2VyU2VsZWN0aW9uU3RhdGVcbntcbiAgICBwcml2YXRlIF9zZWxlY3RlZE9iamVjdDogYW55O1xuICAgIHByaXZhdGUgX3NlbGVjdGVkT2JqZWN0czogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG11bHRpU2VsZWN0OiBib29sZWFuKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBzZXRTZWxlY3Rpb25TdGF0ZShzZWxlY3Rpb246IGFueSwgc2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkT2JqZWN0ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlTZWxlY3QgJiYgIUxpc3RXcmFwcGVyLmNvbnRhaW5zQ29tcGxleCh0aGlzLnNlbGVjdGVkT2JqZWN0cygpLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE9iamVjdHMoKS5wdXNoKHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QodGhpcy5zZWxlY3RlZE9iamVjdHMoKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0KCk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkT2JqZWN0O1xuICAgIH1cblxuICAgIHNlbGVjdGVkT2JqZWN0cygpOiBBcnJheTxhbnk+XG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLl9zZWxlY3RlZE9iamVjdHMpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE9iamVjdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRPYmplY3RzO1xuICAgIH1cblxuICAgIGlzU2VsZWN0ZWQoc2VsZWN0aW9uOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gc3VwZXIuaXNTZWxlY3RlZChzZWxlY3Rpb24pO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuaW1wb3J0IHtEYXRhU291cmNlLCBEU0luaXRQYXJhbXN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFGaW5kZXIsIERhdGFGaW5kZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7RGF0YVByb3ZpZGVyc30gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcn0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtDaG9vc2VyU3RhdGV9IGZyb20gJy4vY2hvb3Nlci1zdGF0ZSc7XG5pbXBvcnQge2Fzc2VydCwgaXNBcnJheSwgaXNCbGFuaywgaXNQcmVzZW50LCBMaXN0V3JhcHBlcn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cbi8qKlxuICogQ29uY3JldGUgRGF0YVNvdXJjZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIENob29zZXIgY29tcG9uZW50LiBUaGVyZSBhcmUgdHdvIHdheXMgaG93IHRvIHVzZSBpdDpcbiAqXG4gKiAxKSBZb3UgY2FuIHVzZSBkZWZhdWx0IERhdGFTb3VyY2UgaW5qZWN0ZWQgaW5zaWRlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBhbmQganVzdCBjYWxsXG4gKiBpbml0aWFsaXplIHRvIGNvbmZpZ3VyZSBpdCB3aXRoIGNvcnJlY3QgRGF0YVByb3ZpZGVyIGFuZCBEYXRhRmluZGVyOlxuICpcbiAqXG4gKiBgYGBcbiAqICAgdGhpcy5kYXRhU291cmNlLmluaXQoe1xuICogICAgICAgICAgICAgICBvYmo6IHRoaXMubGlzdCxcbiAqICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gKiAgICAgICAgICAgICAgIHN0YXRlOiBudWxsLFxuICogICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICogICAgICAgICAgIH0pO1xuICpcbiAqIGBgYFxuICpcbiAqIGFuZCB0aGVuIHlvdSBjYW4gdXNlIGl0IHRvIHNpbXBseSByZXRyaWV2ZSBkYXRhIG9yIHJ1biBxdWVyaWVzLlxuICpcbiAqIDIpIFlvdSB3aWxsIGluc3RhbnRpYXRlIHlvdXIgb3duIERhdGFTb3VyY2UgYW5kIHBhc3MgaXQgaW50byB0aGUgY29tcG9uZW50IHVzaW5nIFtkYXRhU291cmNlXVxuICogYmluZGluZ1xuICpcbiAqIGBgYFxuICpcbiAqICAgdGhpcy5kcyA9IG5ldyBDaG9vc2VyRGF0YVNvdXJjZSh0aGlzLmRhdGEsIHRoaXMuZmluZGVycyk7XG4gKiAgIHRoaXMuZHMuaW5pdCh7XG4gKiAgICAgICAgICAgICAgIG9iajogdGhpcy5saXN0LFxuICogICAgICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAqICAgICAgICAgICAgICAgc3RhdGU6IG51bGwsXG4gKiAgICAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0aGlzLm11bHRpc2VsZWN0XG4gKiAgICAgICAgICAgfSk7XG4gKlxuICogYGBgXG4gKlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIENob29zZXJEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZVxue1xuXG4gICAgLyoqXG4gICAgICogTWF0Y2hpbmcgZGF0YVByb3ZpZGVycyBhbmQgZmluZGVyc1xuICAgICAqL1xuICAgIHByaXZhdGUgZGF0YVByb3ZpZGVyOiBEYXRhUHJvdmlkZXI8YW55PjtcbiAgICBwcml2YXRlIGRhdGFGaW5kZXI6IERhdGFGaW5kZXI7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpYWwgb2JqZWN0IHRvIGtlZXAgY3VycmVudCBzdGF0ZSBvZiB0aGlzIGNob29zZXJcbiAgICAgKi9cbiAgICBzdGF0ZTogQ2hvb3NlclN0YXRlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0YVByb3ZpZGVyczogRGF0YVByb3ZpZGVycywgcHVibGljIGZpbmRlcnM6IERhdGFGaW5kZXJzKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZGF0YVByb3ZpZGVycywgZmluZGVycyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUbyBpbml0aWFsaXplIHRoaXMgRGF0YVNvdXJjZSB3aXRoIGN1cnJlbnQgRGF0YUZpbmRlciBhbmQgUHJvdmlkZXIgYXMgd2VsbCBhcyBzdGF0ZSB3ZSB1c2VcbiAgICAgKiBhbiBpbnRlcmZhY2UgRFNDaG9vc2VySW5pdFBhcmFtcyB0byBoYXZlIGFsbCBpbml0IHZhbHVlcyB0eXBlZCBjaGVja2VkXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluaXQoLi4uYXJnczogYW55W10pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayhhcmdzKSB8fCBhcmdzLmxlbmd0aCAhPT0gMSAmJiAhaXNEU0Nob29zZXJJbml0UGFyYW1zKGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIGluaXRpYWxpemUgRFMgd2l0aCAoRFNDaG9vc2VySW5pdFBhcmFtcyknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5pdDogRFNDaG9vc2VySW5pdFBhcmFtcyA9IGFyZ3NbMF07XG5cbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhUHJvdmlkZXIpID8gaW5pdC5kYXRhUHJvdmlkZXJcbiAgICAgICAgICAgIDogdGhpcy5kYXRhUHJvdmlkZXJzLmZpbmQoaW5pdC5vYmopO1xuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlciA9IGlzUHJlc2VudChpbml0LmRhdGFGaW5kZXIpID8gaW5pdC5kYXRhRmluZGVyXG4gICAgICAgICAgICA6IHRoaXMuZmluZGVycy5maW5kKHRoaXMuZGF0YVByb3ZpZGVyLCBpbml0LnF1ZXJ5VHlwZSk7XG5cbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmRhdGFQcm92aWRlcikgJiYgaXNQcmVzZW50KHRoaXMuZGF0YUZpbmRlciksXG4gICAgICAgICAgICAnRGF0YVNvdXJjZSBpbmNvcnJlY3RseSBpbml0aWFsaXplZC4gKERhdGFQcm92aWRlciwgRGF0YUZpbmRlcikgbWlzc2luZy4gJyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChpbml0LnN0YXRlKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXQuc3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IENob29zZXJTdGF0ZShudWxsLCBpbml0Lm11bHRpc2VsZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSBpbml0Lmxvb2t1cEtleTtcbiAgICAgICAgdGhpcy5zdGF0ZS5sb29rdXBLZXkgPSBpbml0Lmxvb2t1cEtleTtcbiAgICB9XG5cblxuICAgIGZpbmQocGF0dGVybjogc3RyaW5nLCBtYXg6IG51bWJlcik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc3RhdGUucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMuc3RhdGUubGFzdEZ1bGxNYXRjaFBhdHRlcm4gPSBwYXR0ZXJuO1xuXG4gICAgICAgIGlmIChwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSAnKicpIHsgLy8gcXVlcnkgZXZlcnl0aGluZ1xuICAgICAgICAgICAgcGF0dGVybiA9ICcnO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBtYWtlIHN1cmUgd2UgZGF0YUZpbmRlciBoYXMgZXhwZWN0ZWQgbG9va3VwIGtleVxuICAgICAgICBsZXQgb3JpZ0tleSA9IHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXk7XG4gICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSB0aGlzLnN0YXRlLmxvb2t1cEtleTtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLmZvckRhdGEodGhpcy5kYXRhUHJvdmlkZXIpLm1hdGNoPGFueT4ocGF0dGVybiwgbWF4KVxuICAgICAgICAgICAgLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1hdGNoZXMgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QodGhpcy5zdGF0ZS5tYXRjaGVzLCBpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUZpbmRlci5sb29rdXBLZXkgPSBvcmlnS2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG11bHRpc2VsZWN0IHRoaXMgbWV0aG9kIGNoZWNrcyBpZiB3ZSBuZWVkIHRvIHNob3cgU0hPVyBNT1JFIGxhYmVsIHVuZGVyIHRoZSBzZWxlY3RlZFxuICAgICAqIGl0ZW1zLiBXZSBkbyBub3Qgd2FudCBzaG93IGUuZy4gNTAgc2VsZWN0aW9uIHVuZGVyIHRoZSBjaG9vc2VyIHRoYXQgd291bGQgdGFrZSB1cCB3aG9sZVxuICAgICAqIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBzaG93TW9yZVNlbGVjdGVkKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpLmxlbmd0aCA+PSBEYXRhU291cmNlLk1heFJlY2VudFNlbGVjdGVkO1xuICAgIH1cblxuICAgIG9wZW48VD4oKTogT2JzZXJ2YWJsZTxUW10+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGFGaW5kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpbnN0YW50PFQ+KCk6IFRbXVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbXM6IGFueVtdID0gdmFsdWU7XG4gICAgICAgICAgICBpdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB0aGlzLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVkU2VsZWN0ZWRPYmplY3RzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLmFkZE1vZGUgPSBmYWxzZTtcblxuICAgIH1cblxuXG4gICAgZ2V0IGxvb2t1cEtleSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5O1xuICAgIH1cbn1cblxuLyogaXMgXCJpbml0XCIgdHlwZSBvZiBEU0Nob29zZXJJbml0UGFyYW1zIGludGVyZmFjZSA/ICovXG5leHBvcnQgZnVuY3Rpb24gaXNEU0Nob29zZXJJbml0UGFyYW1zKGluaXQ6IERTQ2hvb3NlckluaXRQYXJhbXMpOiBpbml0IGlzIERTQ2hvb3NlckluaXRQYXJhbXNcbntcbiAgICByZXR1cm4gaXNQcmVzZW50KGluaXQub2JqKSB8fCBpc1ByZXNlbnQoaW5pdC5xdWVyeVR5cGUpO1xufVxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERTQ2hvb3NlckluaXRQYXJhbXMgZXh0ZW5kcyBEU0luaXRQYXJhbXNcbntcbiAgICAvKipcbiAgICAgKiBDaG9vc2VyIHN0YXRlIGtlZXBpbmcgaW5mb3JtYXRpb24gd2hhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQgLCByZXN1bHQgb2YgdGhlIGxhc3QgbWF0Y2hcbiAgICAgKi9cbiAgICBzdGF0ZT86IENob29zZXJTdGF0ZTtcbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7QXV0b0NvbXBsZXRlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0Nob29zZXJEYXRhU291cmNlfSBmcm9tICcuL2Nob29zZXItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1wcm92aWRlcnMnO1xuaW1wb3J0IHtEYXRhRmluZGVycywgUXVlcnlUeXBlfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1maW5kZXJzJztcbmltcG9ydCB7Q2hvb3NlclN0YXRlLCBEZWZhdWx0U2VsZWN0aW9uU3RhdGV9IGZyb20gJy4vY2hvb3Nlci1zdGF0ZSc7XG5cblxuLyoqXG4gKiBUeXBlYWhlYWQgY2hvb3NlciB0aGF0IHN1cHBvcnRzIGJvdGggc2luZ2xlIGFuZCBtdWx0aS1zZWxlY3QuIE5vdCBsaWtlIERyb3Bkb3duLCB0aGlzIGNob29zZXJcbiAqIHJlcXVpcmVzIGxpdHRsZSBiaXQgZGlmZmVyZW50IHNldHVwLiBJdCByZXF1aXJlcyBhdCBtaW5pbXVtIEBJbnB1dCBkYXRhU291cmNlIG9yXG4gKiBkZXN0aW5hdGlvbkNsYXNzXG4gKlxuICpcbiAqIEJ5IGRlZmF1bHQgY2hvb3NlciBpcyBtdWx0aS1zZWxlY3QuIElmIHlvdSB3YW50IHNpbmdsZSBzZWxlY3QgdGhlbiB5b3UgbXVzdCBwcm92aWRlIG11bHRpLXNlbGVjdFxuICogd2l0aCBASW5wdXQuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBJbiBzaW1wbGUgc2NlbmFyaW8geW91IGNhbiB1c2UgQ2hvb3NlciBsaWtlIHNvOlxuICpcbiAqXG4gKiBgYGBcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICdjaG9vc2VyLWFwcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYDxhdy1jaG9vc2VyICBbZm9ybUdyb3VwXT1cImZvcm1Hcm91cFwiIG5hbWU9XCJjb2xvclwiJ1xuICogICAgICAgICAgICAgICAgICAgICAgW2RhdGFTb3VyY2VdPVwiZHNcIj48L2F3LWNob29zZXI+YFxuICogIH0pXG4gKiAgZXhwb3J0IGNsYXNzIE15Q2hvb3NlckFwcFxuICogIHtcbiAqXG4gKiAgICAgIGRzOiBDaG9vc2VyRGF0YVNvdXJjZTtcbiAqXG4gKiAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBEYXRhUHJvdmlkZXJzLCBwcml2YXRlIGZpbmRlcnM6IERhdGFGaW5kZXJzKXtcbiAqICAgICAgICAgIHRoaXMuZHMgPSBuZXcgQ2hvb3NlckRhdGFTb3VyY2UodGhpcy5kYXRhLCB0aGlzLmZpbmRlcnMpO1xuICpcbiAqICAgICAgIHRoaXMuZHMuaW5pdCh7XG4gKiAgICAgICAgICAgb2JqOiBbJ2JsdWUnLCAncmVkJywgJ3llbGxvdyddLCBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCwgc3RhdGU6IG51bGwsXG4gKiAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0cnVlXG4gKiAgICAgICB9KTtcbiAqXG4gKiAgICAgfVxuICogIH1cbiAqXG4gKiBgYGBgXG4gKiAgQWJvdmUgZXhhbXBsZSB3aWxsIHVzZSBwcm92aWRlZCBkYXRhU291cmNlIGFuZCByZW5kZXIgbXVsdGktc2VsZWN0IGNob29zZXIuIFdpdGggZGVmYXVsdFxuICogIGltcGxlbWVudGF0aW9uICBzZWxlY3RlZCB2YWx1ZXMgd2lsbCBhcHBlYXIgYXMgYSB0YWdzIHVuZGVyIHRoZSBpbnB1dCBib3hcbiAqXG4gKlxuICpcbiAqICogIyMjIEV4YW1wbGVcbiAqXG4gKiAgSW4gdGhpcyBleGFtcGxlIHdlIHByb3ZpZGUgY3VzdG9tIHRlbXBsYXRlIHRvIGNoYW5nZSB0aGUgd2F5IGhvdyBjaG9vc2VyJ3MgTWVudUl0ZW0gYXJlXG4gKiAgICAgcmVuZGVyZWQgYXMgd2VsbCBhcyB0ZW1wbGF0ZSBmb3IgdGhlIHNlbGVjdGlvbiBpdGVtIGxvb2tzIGxpa2VcbiAqXG4gKiBgYGBcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgICAgc2VsZWN0b3I6ICdjaG9vc2VyLWFwcCcgLFxuICogICAgICB0ZW1wbGF0ZTogYDxhdy1jaG9vc2VyICBuYW1lPVwiY29tbW9kaXR5XCInIFtkYXRhU291cmNlXT1cImRzXCI+XG4gKlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlICNtZW51SXRlbSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgIFx0PHNwYW4+XG4gKiAgICAgICAgICAgICBcdFx0PGkgY2xhc3M9XCJmYSBmYS1lbnZpcmEgXCIgPjwvaT5cbiAqICAgICAgICAgICAgIFx0XHR7e2l0ZW19fVxuICogICAgICAgICAgICAgXHQ8L3NwYW4+XG4gKlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKiAgICAgICAgICA8bmctdGVtcGxhdGUgI3NlbGVjdGlvbkl0ZW0gbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICBcdDxzcGFuIGNsYXNzPVwidGFnIHRhZy1jaXJjbGVcIj5cbiAqICAgICAgICAgICAgIFx0XHRpdGVtOiB7e2l0ZW0gfX1cbiAqICAgICAgICAgICAgIFx0XHQ8aSBjbGFzcz1cImZhIGZhLWNsb3NlXCIgKGNsaWNrKT1cImNob29zZXIucmVtb3ZlVmFsdWUoaXRlbSlcIj48L2k+XG4gKiAgICAgICAgICAgICBcdDwvc3Bhbj5cbiAqXG4gKlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqXG4gKlxuICogICAgICAgICAgPC9hdy1jaG9vc2VyPlxuICogICAgICBgXG4gKiAgICAgIHN0eWxlOiBbYFxuICogICAgICAgICAgICAgIC50YWctY2lyY2xlIHtcbiAqICAgICAgICAgICAgICBcdGJvcmRlci1yYWRpdXM6IDZyZW07XG4gKiAgICAgICAgICAgICAgXHRoZWlnaHQ6IDdyZW07XG4gKiAgICAgICAgICAgICAgXHRjb2xvcjogI2U4ZWVmMTtcbiAqICAgICAgICAgICAgICBcdGJhY2tncm91bmQtY29sb3I6IHJnYmEoNTMsIDU2LCA1OCwgMC42Nyk7XG4gKiAgICAgICAgICAgICAgXHRsaW5lLWhlaWdodDogNnJlbTtcbiAqICAgICAgICAgICAgICB9XG4gKiAgICAgIGBdXG4gKiAgfSlcbiAqXG4gKiBgYGBgXG4gKlxuICogIEluIGFib3ZlIGV4YW1wbGUgd2UgY2hhbmdlIGhvdyB0aGUgY2hvb3NlcidzIG1lbnUgaXRlbSBsb29rIGxpa2UgYXMgd2VsbCBhcyB3ZSBkZWZpbmUgY3VzdG9tXG4gKiAgICAgdGVtcGxhdGUgZm9yIHNlbGVjdGlvbiBpdGVtIHRvIHR1cm4gYWxsIHNlbGVjdGlvbiB0byBjaXJjbGVzIHdpdGggdGV4dCBpbiB0aGUgbWlkZGxlLlxuICpcbiAqXG4gKlxuICovXG5cbmV4cG9ydCBjb25zdCBDSE9PU0VSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaG9vc2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNob29zZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInctY2hvb3NlciBcIj5cblxuICAgIDxwLWF1dG9Db21wbGV0ZSAjYXV0b0NvbXBwbGV0ZSBbKG5nTW9kZWwpXT1cImludGVybmFsQ2hvb3Nlck1vZGVsXCJcbiAgICAgICAgICAgICAgICAgICAgW3N1Z2dlc3Rpb25zXT1cImRhdGFTb3VyY2Uuc3RhdGUubWF0Y2hlc1wiXG4gICAgICAgICAgICAgICAgICAgIFttdWx0aXBsZV09XCJkYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgW2Ryb3Bkb3duXT1cIiFkYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgW21pbkxlbmd0aF09XCJtaW5MZW5Gb3JTZWFyY2hcIlxuICAgICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIlxuICAgICAgICAgICAgICAgICAgICBbZGVsYXldPVwiZGVsYXlcIlxuICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAob25Ecm9wZG93bkNsaWNrKT1cIm9uRHJvcGRvd25DbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKGNvbXBsZXRlTWV0aG9kKT1cIm1hdGNoKCRldmVudC5xdWVyeSlcIlxuICAgICAgICAgICAgICAgICAgICAob25TZWxlY3QpPVwic2VsZWN0SXRlbSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uVW5zZWxlY3QpPVwicmVtb3ZlVmFsdWUoJGV2ZW50KVwiPlxuXG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIGxldC1pbnRlcm5hbENob29zZXJNb2RlbCBwVGVtcGxhdGU9XCJpdGVtXCI+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc01lbnVUZW1wbGF0ZSgpXCI+XG4gICAgICAgICAgICAgICAge3sgZGlzcGxheUl0ZW0oaW50ZXJuYWxDaG9vc2VyTW9kZWwpIH19XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwibWVudVRlbXBsYXRlXCIgW2l0ZW1dPVwiaW50ZXJuYWxDaG9vc2VyTW9kZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzTWVudVRlbXBsYXRlKClcIj48L25nLXRlbXBsYXRlPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvcC1hdXRvQ29tcGxldGU+XG5cbiAgICA8IS0tXG4gICAgICAgIFdyYXAgd2hvbGUgc2VsZWN0aW9uIHdpdGggb25lIGV4dHJhIGVsZW1lbnQgc28gd2UgY2FuIG1vdmUgaXQgYXJvdW5kXG5cbiAgICAgICAgIHNlZTogc2VsZWN0aW9uQXBwZW5kVG9cbiAgICAtLT5cbiAgICA8c3BhbiAjc2VsZWN0aW9uVmlldz5cbiAgICAgICAgPGRpdiBjbGFzcz1cInctY2hvb3Nlci1zZWxlY3Rpb25zXCJcbiAgICAgICAgICAgICAqbmdJZj1cIm11bHRpc2VsZWN0ICYmIGRhdGFTb3VyY2Uuc3RhdGUucmVjZW50U2VsZWN0ZWRPYmplY3RzLmxlbmd0aCA+IDBcIj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc1NlbGVjdGlvblRlbXBsYXRlKClcIj5cblxuICAgICAgICAgICAgPCEtLSBubyBzZWxlY3Rpb24gdGVtcGxhdGUgcmVuZGVyIGl0IGFzIGl0IGlzIGZyb20gQ09SRS0tPlxuICAgICAgICAgICAgPHVsIGNsYXNzPVwidWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lciB1aS13aWRnZXQgdWktc3RhdGUtZGVmYXVsdCBcIlxuICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsndWktc3RhdGUtZGlzYWJsZWQnOmRpc2FibGVkLCd1aS1zdGF0ZS1mb2N1cyc6YXV0b0NvbXBsZXRlQ29tcG9uZW50LmZvY3VzfVwiPlxuXG4gICAgICAgICAgICAgICAgPGxpICN0b2tlbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBkYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkT2JqZWN0c1wiXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidWktYXV0b2NvbXBsZXRlLXRva2VuIHVpLXN0YXRlLWhpZ2hsaWdodCB1aS1jb3JuZXItYWxsXCIgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgKGtleXVwLmRlbGV0ZSk9XCJyZW1vdmVWYWx1ZShpdGVtKVwiXG4gICAgICAgICAgICAgICAgICAgIChrZXl1cC5iYWNrc3BhY2UpPVwicmVtb3ZlVmFsdWUoaXRlbSlcIj5cblx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cInVpLWF1dG9jb21wbGV0ZS10b2tlbi1pY29uIHNhcC1pY29uIGljb24tZGVjbGluZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjbGljayk9XCJyZW1vdmVWYWx1ZShpdGVtKVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ1aS1hdXRvY29tcGxldGUtdG9rZW4tbGFiZWxcIj57eyBkaXNwbGF5SXRlbShpdGVtKSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPC91bD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICAgICAgPCEtLVllcyB0aGVyZSBpcyBzZWxlY3Rpb24gdGVtcGxhdGUgbGV0J3MgaXRlcmF0ZSBhbmQgcHVzaCBlYWNoIGl0ZW0gdG8gYmUgcmVuZGVyZWQtLT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIFtuZ0Zvck9mXT1cImRhdGFTb3VyY2Uuc3RhdGUucmVjZW50U2VsZWN0ZWRPYmplY3RzXCIgbGV0LWl0ZW0+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJzZWxlY3Rpb25UZW1wbGF0ZVwiIFtpdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzU2VsZWN0aW9uVGVtcGxhdGUoKVwiPjwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImRhdGFTb3VyY2Uuc2hvd01vcmVTZWxlY3RlZCgpXCI+XG5cdFx0XHQ8c3BhbiBjbGFzcz1cIm1vcmUtc2VsZWN0ZWRcIj5cblx0XHRcdFx0PGF3LWh5cGVybGluayBbc2l6ZV09XCInc21hbGwnXCIgKGFjdGlvbik9XCJkYXRhU291cmNlLnN0YXRlLnRvZ2dsZUFsbFNlbGVjdGVkKClcIj5cblx0XHRcdFx0XHR7e21vcmVTZWxlY3RTdHJpbmcoKX19XG5cdFx0XHRcdDwvYXctaHlwZXJsaW5rPlxuXHRcdFx0PC9zcGFuPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuICAgIDwvc3Bhbj5cblxuXG48L2Rpdj5cblxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC51aS1mbHVpZCAudWktYXV0b2NvbXBsZXRlLnVpLWF1dG9jb21wbGV0ZS1kZCAudWktYXV0b2NvbXBsZXRlLWlucHV0LC9kZWVwLyAudWktZmx1aWQgLnVpLWF1dG9jb21wbGV0ZS51aS1hdXRvY29tcGxldGUtZGQgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXJ7d2lkdGg6MTAwJX0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxle2xpbmUtaGVpZ2h0Om5vcm1hbH0vZGVlcC8gLnctY2hvb3NlciAudWktYXV0b2NvbXBsZXRlLWlucHV0e3dpZHRoOjEwMCV9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1kcm9wZG93bi51aS1idXR0b257cmlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXI6MDt3aWR0aDozMHB4O2JhY2tncm91bmQ6MCAwfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd24udWktYnV0dG9uIC5waXtmb250LWZhbWlseTpcIlNBUCBpY29uIGZvbnRzXCI7Y29sb3I6Izc2NzY3NjtjdXJzb3I6cG9pbnRlcjtmb250LXNpemU6MS40ZW07bWFyZ2luLWxlZnQ6LS44NWVtfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd24udWktYnV0dG9uIC5waS1jYXJldC1kb3duOmJlZm9yZXtjb250ZW50OidcXFxcZTFlZid9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1kcm9wZG93bi51aS1idXR0b24gaW5wdXR7cGFkZGluZy1yaWdodDozMHB4fS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW57cGFkZGluZzowO21hcmdpbjowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lO3dpZHRoOmluaGVyaXR9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbiAuZmF7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2NvbG9yOiM3Njc2NzY7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuMmVtfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4gLmZhLXNlYXJjaDpiZWZvcmV7Y29udGVudDonXFxcXGUwMGQnfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtaW5wdXQtdG9rZW4gaW5wdXR7d2lkdGg6aW5oZXJpdDtwYWRkaW5nLXJpZ2h0OjI1cHh9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1pbnB1dC10b2tlbiBzcGFue3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjVweDt0b3A6MDtwYWRkaW5nLXRvcDouNmVtfS9kZWVwLyAudy1jaG9vc2VyIC51aS1hdXRvY29tcGxldGUtZHJvcGRvd257aGVpZ2h0OjM2cHh9L2RlZXAvIC53LWNob29zZXIgLnVpLWF1dG9jb21wbGV0ZS1wYW5lbCAudWktYXV0b2NvbXBsZXRlLWxpc3QtaXRlbXtwYWRkaW5nOi42NWVtIDJlbSAuNjVlbSAuNjRlbTttYXJnaW46MH0vZGVlcC8gYm9keSAudWktYXV0b2NvbXBsZXRlLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZSAudWktYXV0b2NvbXBsZXRlLW11bHRpcGxlLWNvbnRhaW5lcntwYWRkaW5nOi40ZW0gLjVlbSAuNGVtIDFlbX0udy1jaG9vc2VyLXNlbGVjdGlvbnN7bWFyZ2luLXRvcDoycHh9LnctY2hvb3Nlci1zZWxlY3Rpb25zIHVse21hcmdpbjowO3BhZGRpbmc6MH0udy1jaG9vc2VyLXNlbGVjdGlvbnMgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXJ7Ym9yZGVyOjB9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIC51aS1hdXRvY29tcGxldGUtdG9rZW57Zm9udC1zaXplOi44NWVtO2xldHRlci1zcGFjaW5nOi4xcHg7Zm9udC13ZWlnaHQ6NDAwO3BhZGRpbmc6MDtiYWNrZ3JvdW5kOiNlMGYyZmY7bWFyZ2luLXJpZ2h0OjVweDttYXJnaW4tYm90dG9tOjVweH0udy1jaG9vc2VyLXNlbGVjdGlvbnMgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXIgLnVpLWF1dG9jb21wbGV0ZS10b2tlbi1sYWJlbHtwYWRkaW5nOjRweCAyMXB4IDRweCA1cHh9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC51aS1hdXRvY29tcGxldGUtbXVsdGlwbGUtY29udGFpbmVyIC51aS1hdXRvY29tcGxldGUtdG9rZW4taWNvbntmb250LXNpemU6Ljc4ZW07cGFkZGluZy1yaWdodDouMjhlbX0udy1jaG9vc2VyLXNlbGVjdGlvbnMgLnVpLWF1dG9jb21wbGV0ZS1tdWx0aXBsZS1jb250YWluZXIgLnNhcC1pY29ue2xpbmUtaGVpZ2h0OmluaGVyaXR9LnctY2hvb3Nlci1zZWxlY3Rpb25zIC5tb3JlLXNlbGVjdGVke2Rpc3BsYXk6aW5saW5lLWJsb2NrfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBDSE9PU0VSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hvb3NlckNvbXBvbmVudCl9LFxuICAgICAgICB7cHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX1cbiAgICBdXG5cblxufSlcbmV4cG9ydCBjbGFzcyBDaG9vc2VyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQge1xuXG4gICAgLyoqXG4gICAgICogTWF4IG51bWJlciBvZiBpdGVtcyByZXR1cm4gYXQgc2luZ2xlIE1hdGNoIHNvIHdlIGRvIG5vdCByZXR1cm4gMTAwMCBpdGVtcyBhdCBzaW5nbGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWF4TGVuZ3RoOiBudW1iZXIgPSAxMDtcblxuXG4gICAgLyoqXG4gICAgICogTWF4IG51bWJlciBvZiBpdGVtcyByZXR1cm4gYXQgc2luZ2xlIE1hdGNoIHNvIHdlIGRvIG5vdCByZXR1cm4gMTAwMCBpdGVtcyBhdCBzaW5nbGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWluTGVuRm9yU2VhcmNoOiBudW1iZXIgPSAxO1xuXG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXR0ZXIgdXNlZCB0byBmb3JtYXQgZWFjaCBzZWxlY3Rpb24gYW5kIHNlbGVjdGVkIG9iamVjdCBmb3IgZGlzcGxheS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWVUcmFuc2Zvcm1lcjogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbXVsdGlzZWxlY3RcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbXVsdGlzZWxlY3Q6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0IENob29zZXJEYXRhU291cmNlIHdpbGwgYmUgY3JlYXRlZCBidXQgdGhlcmUgaXMgYSBvcHRpb24gdG8gc2V0XG4gICAgICogY3VzdG9tIG9uZSBvbiBhcHBsaWNhdGlvbiBsZXZlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGF0YVNvdXJjZTogQ2hvb3NlckRhdGFTb3VyY2U7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2Ugd2FudCB0byBjaGFuZ2UgdGhlIHBsYWNlIHdoZXJlIHNlbGVjdGlvbiBpcyByZW5kZXJlZCB1c2UgdGhpcyBhcHBlbmRUbyBwcm9wZXJ0eVxuICAgICAqIGFuZCBpdCB3aWxsIHVzZSBET00gb3BlcmF0aW9uIGFwcGVuZENoaWxkKCkgdG8gbW92ZSBzZWxlY3Rpb25WaWV3IHVuZGVyIGRpZmZlcmVudCBwYXJlbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbkFwcGVuZFRvOiBFbGVtZW50UmVmO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIGRlbGF5OiBudW1iZXIgPSAzMDA7XG5cblxuICAgIC8qKlxuICAgICAqIFRhcmdldCB0eXBlIHRvIHJlbmRlci4gRGF0YSB3aWxsIGJlIHJlYWQgZnJvbSB0aGUgcmVnaXN0ZXJlZCBEYXRhUHJvdmlkZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc3RpbmF0aW9uQ2xhc3M6IHN0cmluZztcblxuXG4gICAgQElucHV0KClcbiAgICBmaWVsZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHVzZXIgc2VsZWN0IGEgaXRlbVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgbW9kZWwgdG8gbGlzdGVuIGZvciBJbnB1dCB2YWx1ZSBjaGFuZ2VzXG4gICAgICovXG4gICAgaW50ZXJuYWxDaG9vc2VyTW9kZWw6IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogRW1iZWRkZWQgdGVtcGxhdGUgZGVmaW5lZCBieSB1c2VyLiBJZiB1c2VyIGRvZXMgbm90IHByb3ZpZGUgYW55IHRlbXBsYXRlIHRoZW4gd2hlbiByZW5kZXJpbmdcbiAgICAgKiBhbiBpdGVtIHdlIGFzc3VtZSB3ZSBhcmUgZGVhbGluZyB3aXRoIHByaW1pdGl2ZSB0eXBlcyBhbmQgY2FsbCBvbiBlYWNoIGl0ZW0gdG9TdHJpbmcoKSwgaWZcbiAgICAgKiB3ZSBhcmUgZGVhbGluZyB3aXRoIG9iamVjdCwgdGhlbiB3ZSBleHBlY3QgdXNlciB0byBwcm92aWRlIGEgdGVtcGxhdGUgYW5kIHRlbGwgdGhlIGNob29zZXJcbiAgICAgKiBob3cgaXRlbXMgc2hvdWxkcyBiZSBoYW5kbGVkIG9yIGF0IGxlYXN0IHZhbHVlVHJhbnNmb3JtZXIgc28gd2Uga25vdyBob3cgdG8gY29udmVydCB0aGlzXG4gICAgICogdmFsdWUuXG4gICAgICpcbiAgICAgKiBFYWNoIG9iamVjdCBjYW4gcHJvdmlkZSBpdHMgb3duIHRvU3RyaW5nIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnbWVudUl0ZW0nKVxuICAgIG1lbnVUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgQENvbnRlbnRDaGlsZCgnc2VsZWN0aW9uSXRlbScpXG4gICAgc2VsZWN0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAVmlld0NoaWxkKCdhdXRvQ29tcHBsZXRlJylcbiAgICBhdXRvQ29tcGxldGVDb21wb25lbnQ6IEF1dG9Db21wbGV0ZTtcblxuICAgIEBWaWV3Q2hpbGQoJ3NlbGVjdGlvblZpZXcnKVxuICAgIHNlbGVjdGlvblZpZXdFbGVtOiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSBzZWxlY3Rpb24gaXMgPiBtYXggc2VsZWN0aW9uLCB0aGVuIHNob3cgaGlkZSBsaW5rLlxuICAgICAqL1xuICAgIHByaXZhdGUgaGlkZUxpbms6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwcml2YXRlIGVsZW1lbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KERBVEFfU09VUkNFKSBwcml2YXRlIF9kZWZhdWx0RFM6IENob29zZXJEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMucGxhY2VIb2xkZXIpKSB7XG4gICAgICAgICAgICAvLyB0aGlzLnBsYWNlSG9sZGVyID0gaTE4bi5pbnN0YW50KCdXaWRnZXRzLmNob29zZXIucGxhY2VIb2xkZXInKTtcbiAgICAgICAgICAgIHRoaXMucGxhY2VIb2xkZXIgPSAnU2VhcmNoJztcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLmhpZGVMaW5rID0gaTE4bi5pbnN0YW50KCdXaWRnZXRzLmNob29zZXIuaGlkZVNlbGVjdGlvbicpO1xuICAgICAgICB0aGlzLmhpZGVMaW5rID0gJ0hpZGUnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuZGF0YVNvdXJjZSkpIHtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5fZGVmYXVsdERTO1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmZvcm1Db250cm9sKSAmJiBpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS51cGRhdGVWYWx1ZSh0aGlzLmZvcm1Db250cm9sLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdEludGVybmFsTW9kZWwoKTtcblxuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wgPSA8Rm9ybUNvbnRyb2w+IHRoaXMuZm9ybUdyb3VwLmNvbnRyb2xzW3RoaXMubmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgU2VhcmNoIGljb24gaW4gY2FzZSBvZiBtdWx0aXNlbGVjdC5cbiAgICAgKiB0b2RvOiBPbmNlIFByaW1lTkcgd2lsbCBwcm92aWRlIGEgdGVtcGxhdGUgdG8gb3ZlcnJpZGUgZGVmYXVsdCBiZWhhdmlvciByZW1vdmUgaXRcbiAgICAgKlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubXVsdGlzZWxlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IHRoaXMuZWxlbWVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICAgICcudWktYXV0b2NvbXBsZXRlLWlucHV0LXRva2VuJyk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChzZWFyY2hJbnB1dCkpIHtcbiAgICAgICAgICAgIGxldCBpY29uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGljb25FbGVtZW50LmNsYXNzTmFtZSA9ICdzZWFyY2gtaWNvbi1yaWdodCBmYSBmYS1mdyBmYS1zZWFyY2gnO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuYXBwZW5kQ2hpbGQoaWNvbkVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnNlbGVjdGlvbkFwcGVuZFRvKSAmJiBpc1ByZXNlbnQodGhpcy5zZWxlY3Rpb25WaWV3RWxlbSkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFbGVtID0gdGhpcy5zZWxlY3Rpb25BcHBlbmRUbyBpbnN0YW5jZW9mIEVsZW1lbnRSZWYgP1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uQXBwZW5kVG8ubmF0aXZlRWxlbWVudCA6IHRoaXMuc2VsZWN0aW9uQXBwZW5kVG87XG5cbiAgICAgICAgICAgIHBhcmVudEVsZW0uYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3Rpb25WaWV3RWxlbS5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5lZWQgdG8gY2hhbmdlIGN1cnJlbnQgYmVoYXZpb3Igc2luY2Ugd2Ugd2FudCB0byBzaG93IHNlbGVjdGlvbiB1bmRlciB0aGUgY2hvb3Nlci4gS1xuICAgICAqXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRva2VucyA9IHRoaXMuZWxlbWVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgICcudWktYXV0b2NvbXBsZXRlIC51aS1hdXRvY29tcGxldGUtdG9rZW4nKTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0b2tlbnMpICYmIHRva2Vucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0b2tlbnMuZm9yRWFjaCgoaXRlbTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIHZhbHVlIGlzIGVudGVyZWQgaW50byBzZWFyY2ggYm94LCB3ZSBhc2sgb3VyIERhdGFTb3VyY2UgdG8gbWF0Y2ggdGhpcyBwYXR0ZXJuXG4gICAgICogYWdhaW5zdCBkYXRhIHJlcG9zaXRvcnkuIEl0IHdpbGwgcmV0cmlldmUgYWxsIHBvc3NpYmxlIG1hdGNoZXMgbGltaXRlZCBieSBNYXhMZW4gYW5kIHRoaXNcbiAgICAgKiBpcyBhZ2FpbiBmaWx0ZXJlZCBzbyBpdCBkb2VzIG5vdCBpbmNsdWRlIGFscmVhZHkgc2VsZWN0ZWQgaXRlbXMuXG4gICAgICpcbiAgICAgKiAgdGhlIG1hdGNoZWQgcmVzdWx0ZWQgaXMgc2F2ZWQgaW4gdGhlOiB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUubWF0Y2hlc1xuICAgICAqL1xuICAgIG1hdGNoKHBhdHRlcm46IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsZXQgbWF4TGVuID0gdGhpcy5tYXhMZW5ndGggPyB0aGlzLm1heExlbmd0aCA6IENob29zZXJEYXRhU291cmNlLk1heExlbmd0aDtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLmZpbmQocGF0dGVybiwgbWF4TGVuKTtcblxuXG4gICAgICAgIC8vIGZpeDogZm9yIHRlc3RzOiBJbiB2ZXJzaW9uIDQgd2UgbmVlZCB0byBleHBsaWNpdGx5IGZvY3VzIGlucHV0IG90aGVyd2lzZSBhdXRvY29tcGxldGVcbiAgICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGFueSBwb3B1cCBwYW5lbFxuICAgICAgICBpZiAodGhpcy5lbnYuaW5UZXN0ICYmIGlzUHJlc2VudCh0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50LmZvY3VzSW5wdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbnZva2VkIGJ5IERyb3Bkb3duIGJ1dHRvbiBpbiBjYXNlIG9mIHNpbmdsZSBzZWxlY3QgYW5kIGhlcmUgd2Ugd2FudCB0byBpbnZva2UgbWF0Y2hcbiAgICAgKiB0byByZXRyaWV2ZSBhbGwgc3VnZ2VzdGlvbnMgd2l0aG91dCBhbnkgZmlsdGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRyb3Bkb3duQ2xpY2soZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm1hdGNoKCcqJyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXRjaCgnKicpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hvb3NlciBzdGF0ZSBpcyB1cGRhdGVkICB3aXRoIHVzZXIgc2VsZWN0aW9uLiBQbGVhc2Ugc2VlIHdyaXRlVmFsdWUuIFdoZW4gZG8gbm90IG5lZWRcbiAgICAgKiBjYWxsIGFueXRoaW5nIGFkZGl0aW9uYWwgYXMgaW50ZXJuYWxDaG9vc2VyTW9kZWwgYW5kIHRoaXMuY2hvb3NlclN0YXRlLnNlbGVjdGVkT2JqZWN0cygpXG4gICAgICogc2hhcmVzIHRoZSBzYW1lIHJlZmVyZW5jZXMgc28gaXRzIGltcG9ydGFudCB0aGF0IHdlIGZpcnN0IHNhdmUgcmVmZXJlbmNlIHRvXG4gICAgICogdGhpcy5jaG9vc2VyU3RhdGUuc2VsZWN0ZWRPYmplY3RzKCkgYW5kIHRoZW4gYmFjayB0byBpbnRlcm5hbENob29zZXJNb2RlbFxuICAgICAqXG4gICAgICovXG4gICAgc2VsZWN0SXRlbShpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwpO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuaW50ZXJuYWxDaG9vc2VyTW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcblxuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuYWRkTW9kZSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbSk7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGUgPSB0cnVlO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmF1dG9Db21wbGV0ZUNvbXBvbmVudC5pbnB1dEVMLm5hdGl2ZUVsZW1lbnQudmFsdWUgPVxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheUl0ZW0odGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVW5zZWxlY3QgaXRlbVxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlVmFsdWUoaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLnVwZGF0ZWRTZWxlY3RlZE9iamVjdHMoaXRlbSk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5hZGRNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKTtcblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCwge2VtaXRFdmVudDogdHJ1ZX0pO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLm1hcmtBc0RpcnR5KHtvbmx5U2VsZjogdHJ1ZX0pO1xuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG5cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuYXV0b0NvbXBsZXRlQ29tcG9uZW50KSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvQ29tcGxldGVDb21wb25lbnQuZm9jdXNJbnB1dCgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENvbnZlcnQgYSBvYmplY3QgaWYgYW55IGludG8gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqXG4gICAgICogdG9kbzogaW1wbGVtZW50IGJldHRlciB3YXkgaG93IHRvIHdvcmsgd2l0aCBvYmplY3RzXG4gICAgICpcbiAgICAgKi9cbiAgICBkaXNwbGF5SXRlbShpdGVtOiBhbnkpIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5jdXJyZW50SXRlbSA9IGl0ZW07XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnZhbHVlVHJhbnNmb3JtZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZVRyYW5zZm9ybWVyKGl0ZW0pO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZS5sb29rdXBLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbVt0aGlzLmRhdGFTb3VyY2UubG9va3VwS2V5XTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV0dXJucyBhIGxhYmVsIHRoYXQgaXMgc2hvd24gdW5kZXIgdGhlIHNlbGVjdGVkIGl0ZW0gd2hlbiB1c2VyIHNlbGVjdGlvbiBpcyA+XG4gICAgICogTWF4UmVjZW50U2VsZWN0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIG1vcmVTZWxlY3RTdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IG1vcmVTZWxlY3RlZCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdHMoKS5sZW5ndGggLVxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlLnJlY2VudFNlbGVjdGVkRGlzcGxheWVkO1xuICAgICAgICBpZiAobW9yZVNlbGVjdGVkIDwgMiAmJiAhdGhpcy5kYXRhU291cmNlLnN0YXRlLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlLnN0YXRlLnNob3dBbGxSZWNlbnRseVNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlTGluaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bW9yZVNlbGVjdGVkfSBtb3JlIHNlbGVjdGVkLi4uYDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugb2YgbXVsdGlzZWxlY3QgPSBmYWxzZSBjaGVjayBpZiB3ZSB3YW50IHRvIHNob3cgYSBzZWxlY3RlZCB2YWx1ZSBpbnNpZGUgdGhlIGlucHV0XG4gICAgICogZmllbGRcbiAgICAgKlxuICAgICAqL1xuICAgIHNpbmdsZVZhbHVlU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRhU291cmNlLnN0YXRlICYmIGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2Uuc3RhdGUuY3VycmVudEl0ZW0pXG4gICAgICAgICAgICAmJiAhdGhpcy5kYXRhU291cmNlLnN0YXRlLmFkZE1vZGU7XG4gICAgfVxuXG4gICAgaGFzTWVudVRlbXBsYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubWVudVRlbXBsYXRlKTtcbiAgICB9XG5cblxuICAgIGhhc1NlbGVjdGlvblRlbXBsYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uVGVtcGxhdGUpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKiBBcyB3ZSBhcmUgdXNpbmcgRGF0YVNvdXJjZSBpbnRlcm5hbGx5IGZvciBbKG5nTW9kZWwpXSBjYXNlIHdlIG5lZWQgdG8gZGVmZmVyIERhdGFTb3VyY2VcbiAgICAgKiBpbml0aWFsaXphdGlvbiBvbmNlIHdlIGhhdmUgYSB2YWx1ZSBhbmQgd2Ugb25seSBhY2NlcHQgW11cbiAgICAgKlxuICAgICAqXG4gICAgICogPyBTaG91bGQgd2UgZG8gc29tZSBkZWVwZXIgY29tcGFyaXNpb24/XG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmIChpc0JsYW5rKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmRhdGFTb3VyY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UudXBkYXRlVmFsdWUodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHNlbFN0YXRlOiBEZWZhdWx0U2VsZWN0aW9uU3RhdGUgPSBuZXcgRGVmYXVsdFNlbGVjdGlvblN0YXRlKHRoaXMubXVsdGlzZWxlY3QpO1xuICAgICAgICAgICAgbGV0IGNoU3RhdGU6IENob29zZXJTdGF0ZSA9IG5ldyBDaG9vc2VyU3RhdGUoc2VsU3RhdGUsIHRoaXMubXVsdGlzZWxlY3QpO1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZShjaFN0YXRlKTtcblxuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnVwZGF0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdEludGVybmFsTW9kZWwoKTtcbiAgICB9XG5cbiAgICBpbml0RGF0YXNvdXJjZShjaG9vc2VyU3RhdGU/OiBDaG9vc2VyU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgYXNzZXJ0KGlzUHJlc2VudCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpLFxuICAgICAgICAgICAgJ1lvdSBuZWVkIHRvIHByb3ZpZGUgZGVzdGluYXRpb25DbGFzcyBvciBjdXN0b20gRGF0YVNvdXJjZScpO1xuXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAgICAgICAgICAgIG9iajogdGhpcy5kZXN0aW5hdGlvbkNsYXNzLFxuICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gICAgICAgICAgICBsb29rdXBLZXk6IHRoaXMuZmllbGQsXG4gICAgICAgICAgICBzdGF0ZTogY2hvb3NlclN0YXRlLFxuICAgICAgICAgICAgbXVsdGlzZWxlY3Q6IHRoaXMubXVsdGlzZWxlY3RcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IG5nT25Jbml0IGFuZCBXcml0ZSB2YWx1ZSB0byByZWFkIHN0YXRlIGZyb20gQ2hvb3NlclN0YXRlIGFuZCBzZXQgaXQgdG8gaW50ZXJuYWxcbiAgICAgKiBuZ01vZGVsIHByb3BlcnR5XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRJbnRlcm5hbE1vZGVsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kYXRhU291cmNlLnN0YXRlLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsQ2hvb3Nlck1vZGVsID0gdGhpcy5kYXRhU291cmNlLnN0YXRlLnNlbGVjdGVkT2JqZWN0cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCA9IHRoaXMuZGF0YVNvdXJjZS5zdGF0ZS5zZWxlY3RlZE9iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5mb3JtQ29udHJvbCkpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5pbnRlcm5hbENob29zZXJNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Nob29zZXJDb21wb25lbnR9IGZyb20gJy4vY2hvb3Nlci5jb21wb25lbnQnO1xuaW1wb3J0IHtBdXRvQ29tcGxldGVNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuLi9oeXBlcmxpbmsvaHlwZXJsaW5rLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgICAgIEFXSHlwZXJsaW5rTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcblxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIENob29zZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQ2hvb3NlckNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdDaG9vc2VyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybUNvbnRyb2wsIE5HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1NlbGVjdEl0ZW19IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBlcXVhbHMsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogQSBwb3B1cCBsaWtlIGNvbXBvbmVudCByZW5kZXJpbmcgbGlzdCBvZiB2YWx1ZXMgYXMuIEJhc2VkIG9uIFByaW1lTkcgY29tcG9uZW50IGFuZCBvbmUgb2YgdGhlXG4gKiBtYWluIHJlYXNvbiB3aHkgd2UgbmVlZCB0byB3cmFwIHRoaXMgaXMgdG8gZXh0ZW5kIGl0cyBjYXBhYmlsaXRpZXMgdG8gYWNjZXB0IGFsbW9zdCBhbnlcbiAqIGRhdGEgdHlwZSB3aXRob3V0IHVzaW5nIFByaW1lbnMncyBzcGVjaWZpYyBTZWxlY3RJdGVtIHR5cGUuXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICAgIHNlbGVjdG9yOiAnc2hvd0Ryb3BEb3duJyAsXG4gKiAgICAgIHRlbXBsYXRlOiAnPGF3LWRyb3Bkb3duIFtsaXN0XT1cInRlc3RJdGVtU21hbGxcIlxuICogICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCI+PC9hdy1kcm9wZG93bj4nXG4gKiAgfSlcbiAqICBleHBvcnQgY2xhc3MgTXlEcm9wQ29tcG9uZW50XG4gKiAge1xuICogICAgICB0ZXN0SXRlbVNtYWxsOiBzdHJpbmdbXSA9IFsndmlldycgLCAnZWRpdCddO1xuICpcbiAqICAgICAgLy8gd2hlbiB5b3Ugc3dpdGNoIGxpc3QgYmluZGluZyB0byByZWZlcnQgdG8gbGFyZ2UgaXRlbSBmaWlsdGVyIGF1dG9tYXRpY2FsbHkgaXMgc2hvd24gYW5kXG4gKiAgICAgbWF4IDEwIGl0ZW1zIGFyZVxuICogICAgICAvLyB2aXNpYmxlXG4gKiAgICAgIHRlc3RJdGVtTGFyZ2U6IHN0cmluZ1tdID0gWyd2aWV3JyAsICdlZGl0JyAsICdmcmFuaycgLCAna29sYXInICwgJ1RoZSBTdW4nICwgJ0RvZycgLFxuICogICAgICdDb21wdXRlcicgLCAnQSBEZXNrJyAsXG4gKiAgICAgICdNeSBDYXInICwgJ1BlbmNpbCcgLCAnVGhpcyBQYWdlJyAsICdZZXN0ZXJkYXknICwgJ01vbmRheScgLCAnVHVlc2RheScgLCAnQk1XIFIxMjAwIEdTJyAsXG4gKiAgICAgJ0N6ZWNoIFJlcHVibGljJyAsXG4gKiAgICAgICdMYXN0IEl0ZW0nXTtcbiAqXG4gKlxuICogICAgICBpdGVtU2VsZWN0ZWQ6IHN0cmluZyA9ICd2aWV3JztcbiAqICAgICAgaXRlbVNlbGVjdGVkTGc6IHN0cmluZyA9ICdNb25kYXknO1xuICpcbiAqICAgICAgbm9zZWxTdHJpbmc6IHN0cmluZyA9ICcobm8gc2VsZWN0aW9uKSc7XG4gKlxuICpcbiAqICAgICAgb25TZWxlY3Rpb24gKGV2ZW50KTogdm9pZFxuICogICAgICB7XG4gKiAgICAgICAgICB0aGlzLml0ZW1TZWxlY3RlZCA9IGV2ZW50O1xuICpcbiAqICAgICAgfVxuICogIH1cbiAqXG4gKiAgYGBgXG4gKlxuICovXG5cblxuZXhwb3J0IGNvbnN0IEREX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEcm9wZG93bkNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kcm9wZG93bicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidy1kcm9wZG93blwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNTdGFuZGFsb25lXCI+XG4gICAgICAgIDxwLWRyb3Bkb3duIFtvcHRpb25zXT1cImludGVybmFsTGlzdFwiXG4gICAgICAgICAgICAgICAgICAgIFtmb3JtQ29udHJvbE5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJub1NlbGVjdGlvblN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIFthdXRvV2lkdGhdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICBbZmlsdGVyXT1cInNob3dGaWx0ZXIoKVwiXG4gICAgICAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkl0ZW1TZWxlY3Rpb24oJGV2ZW50KVwiPlxuXG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgbGV0LWl0ZW0gcFRlbXBsYXRlPVwiaXRlbVwiPlxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGFzRW1iZWRkZWRUZW1wbGF0ZSgpICYmIGl0ZW1FeGlzdChpdGVtKVwiPlxuICAgICAgICAgICAgICAgICAgICB7e2l0ZW0ubGFiZWwgfX1cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtlbWJlZGRlZEl0ZW1dPVwiaXRlbVRlbXBsYXRlXCIgW2l0ZW1dPVwiaXRlbVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiaGFzRW1iZWRkZWRUZW1wbGF0ZSgpICYmIGl0ZW1FeGlzdChpdGVtKVwiPlxuXG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgICAgICA8L3AtZHJvcGRvd24+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvZGl2PlxuXG5cbjwhLS0gbm8gZm9ybUNvbnRyb2wgTmFtZSBoZXJlLiBuZ01vZGVsIGNhbm5vdCBoYXZlIGZvcm1Hcm91cCBhcm91bmQgLS0+XG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzU3RhbmRhbG9uZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJ3LWRyb3Bkb3duXCI+XG4gICAgICAgIDxwLWRyb3Bkb3duIFtvcHRpb25zXT1cImludGVybmFsTGlzdFwiXG4gICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwic2VsZWN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cIm5vU2VsZWN0aW9uU3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgW2F1dG9XaWR0aF09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFtmaWx0ZXJdPVwic2hvd0ZpbHRlcigpXCJcbiAgICAgICAgICAgICAgICAgICAgKG9uQ2hhbmdlKT1cIm9uSXRlbVNlbGVjdGlvbigkZXZlbnQpXCI+XG5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSBsZXQtaXRlbSBwVGVtcGxhdGU9XCJpdGVtXCI+XG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWhhc0VtYmVkZGVkVGVtcGxhdGUoKSAmJiBpdGVtRXhpc3QoaXRlbSlcIj5cbiAgICAgICAgICAgICAgICAgICAge3tpdGVtLmxhYmVsIH19XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJpdGVtVGVtcGxhdGVcIiBbaXRlbV09XCJpdGVtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNFbWJlZGRlZFRlbXBsYXRlKCkgJiYgaXRlbUV4aXN0KGl0ZW0pXCI+XG4gICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDwvcC1kcm9wZG93bj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2AvZGVlcC8gLnVpLWRyb3Bkb3duLXBhbmVsIC51aS1kcm9wZG93bi1pdGVtcy13cmFwcGVye21heC1oZWlnaHQ6bm9uZSFpbXBvcnRhbnR9L2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24taXRlbXtwYWRkaW5nOi42NWVtIDJlbSAuNjVlbSAuNjRlbTttYXJnaW46MH0vZGVlcC8gLnVpLWRyb3Bkb3duLXBhbmVsIC51aS1kcm9wZG93bi1maWx0ZXItY29udGFpbmVye3dpZHRoOjEwMCV9L2RlZXAvIC51aS1kcm9wZG93bi1wYW5lbCAudWktZHJvcGRvd24tZmlsdGVyLWNvbnRhaW5lciAuZmF7dG9wOjEuMmVtfS9kZWVwLyAudWktZHJvcGRvd24tcGFuZWwgLnVpLWRyb3Bkb3duLWxpc3R7cGFkZGluZzoxZW0gMH0vZGVlcC8gLnctZHJvcGRvd246bm90KC5uZy1kaXJ0eSkgbGFiZWx7Y29sb3I6Izk2OTY5Nn0vZGVlcC8gLnctZHJvcGRvd24gLnVpLWRyb3Bkb3duLXRyaWdnZXIudWktY29ybmVyLXJpZ2h0e2JvcmRlci1sZWZ0Om5vbmU7Y29sb3I6Izk2OTY5Nn0vZGVlcC8gLnctZHJvcGRvd24gLnVpLWRyb3Bkb3duLXRyaWdnZXIgLnBpe2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtjb2xvcjojNzY3Njc2O2N1cnNvcjpwb2ludGVyO2ZvbnQtc2l6ZToxLjRlbTttYXJnaW4tbGVmdDotLjg1ZW19L2RlZXAvIC53LWRyb3Bkb3duIC51aS1kcm9wZG93bi10cmlnZ2VyIC5waS1jYXJldC1kb3duOmJlZm9yZXtjb250ZW50OidcXFxcZTFlZid9L2RlZXAvIC53LWRyb3Bkb3duIC51aS1kcm9wZG93bi1sYWJlbHtwYWRkaW5nLXJpZ2h0OjIuNGVtfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBERF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERyb3Bkb3duQ29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd25Db21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgc3RhdGljIHJlYWRvbmx5IE1heE51bVNob3duID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBPcmRlcmVkIGxpc3Qgb2YgaXRlbXMgcmVuZGVyZWQgYXMgYSBwb3B1cCBtZW51XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIEl0ZW1zIHdoaWNoIHdhcyBzZWxlY3RlZCBhcyBhIGRlZmF1bHQgdmFsdWUgb3IgYnkgdXNlZCBpbiB0aGUgcG9wdXAgbWVudS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU3RyaW5nIHJlbmRlcmVkIGFzIGZpcnN0IHZhbHVlIGluIHRoZSBwb3B1cCB3aGljaCBsZXQgdGhlIHVzZXIgdG8gbWFrZSAnbm8gc2VsZWN0aW9uJyBmcm9tXG4gICAgICogYXZhaWxhYmxlIGxpc3Qgb2YgdmFsdWVzLiBXaGVuIHRoaXMgb3B0aW9uIGlzIGFjdGl2ZSBhbmQgdXNlIG1ha2UgdGhpcyBzZWxlY3Rpb24gd2Ugc2F2ZSBhXG4gICAgICogTlVMTCB2YWx1ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm9TZWxlY3Rpb25TdHJpbmc6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdXNlciBzZWxlY3QgYSBpdGVtXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgaW50ZXJuYWwgbGlzdCB0aGF0IGhpZGVzIFByaW1lTkcgc3BlY2lmaWNzIHdoZXJlIHdlIG5lZWQgdG8gZGVhbCB3aXRoIHNwZWNpYWxcbiAgICAgKiB0eXBlOiBTZWxlY3RJdGVtLiBPdXIgZXhwZWN0YXRpb24gaXMgdGhhdCB5b3UgbmVlZCB0byBiZSBhYmxlIHRvIHBhc3MgcmVndWxhciBzdHJpbmcgdmFsdWVzXG4gICAgICogb3IgZnVsbCBvYmplY3QgYW5kIG5vdCB0cnlpbmcgdG8gd3JhcCBpdCBpbnRvIGV4dHJhIGxheWVyLlxuICAgICAqXG4gICAgICovXG4gICAgaW50ZXJuYWxMaXN0OiBTZWxlY3RJdGVtW107XG5cblxuICAgIC8qKlxuICAgICAqIEVtYmVkZGVkIHRlbXBsYXRlIGRlZmluZWQgYnkgdXNlci4gSWYgdXNlciBkb2VzIG5vdCBwcm92aWRlIGFueSB0ZW1wbGF0ZSBhbmQgd2hpbGUgcmVuZGVyaW5nXG4gICAgICogaXRlbSB3ZSBhc3N1bWUgd2UgYXJlIGRlYWxpbmcgd2l0aCBwcmltaXRpdmUgdHlwZXMgYW5kIGNhbGwgb24gZWFjaCBpdGVtIHRvU3RyaW5nKCksIGlmIHdlXG4gICAgICogYXJlIGRlYWxpbmcgd2l0aCBvYmplY3QsIHRoZW4gd2UgZXhwZWN0IHVzZXIgdG8gcHJvdmlkZSBhIHRlbXBsYXRlIGFuZCB0ZWxsIHRoZSBkcm9wZG93biBvZlxuICAgICAqIGVhY2ggaXRlbSBzaG91bGQgYmUgaGFuZGxlZFxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaXRlbVRlbXBsYXRlJylcbiAgICBpdGVtVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1vZGVsIHVzZWQgZm9yIGVtYmVkZGVkIHZlcnNpb24uXG4gICAgICovXG4gICAgbW9kZWw6IFNlbGVjdEl0ZW07XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9kbzogUHV0IGJhY2sgdGhlIHNjcm9sbGluZyBvcHRpb24gb25jZSB3ZSBkZWNpZGUgc28uIEN1cnJlbnRseSB0aGUgcmVxdWlyZW1lbnRzIGFyZVxuICAgICAqIHNob3cgb25seSAxMCBpdGVtcyBtYXgsIG5vIHNjcm9sbGluZy4gRnVuY3Rpb25hbGl0eSBjb21tZW50ZWQgb3V0IGNhbiBzaG93IHNjcm9sbGJhciB3aXRoXG4gICAgICogc2VhcmNoIGZpbHRlci5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuXG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sID0gPEZvcm1Db250cm9sPiB0aGlzLmZvcm1Hcm91cC5jb250cm9sc1t0aGlzLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gYSB2YWx1ZSB0byBQcmltZU5nIEZvcm1hdCwgd2UgYXJlIG5vdCByZWFsbHkgYmUgdXNpbmcgYSBsYWJlbCBmaWVsZCBvbmx5IGFcbiAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gW107XG4gICAgICAgIC8vIGlmIChpc1ByZXNlbnQodGhpcy5ub1NlbGVjdGlvblN0cmluZykpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuaW50ZXJuYWxMaXN0LnB1c2goe1xuICAgICAgICAvLyAgICAgICAgIGxhYmVsOiB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nLFxuICAgICAgICAvLyAgICAgICAgIHZhbHVlOiBudWxsXG4gICAgICAgIC8vICAgICB9KTtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdGhpcy5ub1NlbGVjdGlvblN0cmluZztcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiB0aGlzLmxpc3QubGVuZ3RoID49IERyb3Bkb3duQ29tcG9uZW50Lk1heE51bVNob3duKSB7XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxMaXN0ID0gdGhpcy5saXN0LnNsaWNlKDAsIERyb3Bkb3duQ29tcG9uZW50Lk1heE51bVNob3duKS5tYXAoKGl0ZW06IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2xhYmVsOiBpdGVtLnRvU3RyaW5nKCksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLmxpc3QpKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsTGlzdCA9IHRoaXMubGlzdC5zbGljZSgwKS5tYXAoKGl0ZW06IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge2xhYmVsOiBpdGVtLnRvU3RyaW5nKCksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBoYXNFbWJlZGRlZFRlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5pdGVtVGVtcGxhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHByZXZlbnQgRW1wdHkgaXRlbSB0byBiZSByZW5kZXJlZFxuICAgICAqXG4gICAgICogdG9kbzogUmVwb3J0IHRoaXMgb24gUHJpbWVOZ1xuICAgICAqXG4gICAgICovXG4gICAgaXRlbUV4aXN0KGl0ZW06IGFueSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoaXRlbSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRyb3Bkb3duIGxpc3QgaXMgbW9yZSB0aGVuIGRlZmluZWQgY29uc3RhbnQgTWF4TnVtU2hvd24gKDEwKSBhdXRvbWF0aWNhbGx5IHNob3cgZmlsdGVyXG4gICAgICogaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBzaG93RmlsdGVyKClcbiAgICB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gcmV0dXJuIGlzUHJlc2VudCh0aGlzLmxpc3QpICYmIHRoaXMubGlzdC5sZW5ndGggPiBEcm9wZG93bkNvbXBvbmVudC5NYXhOdW1TaG93bjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVwZGF0ZXMgaW50ZXJuYWwgbW9kZWxzIG9mIGN1cnJlbnQgc2VsZWN0aW9ucyBhbmQgdHJpZ2dlcnMgb25TZWxlY3Rpb24gZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIG9uSXRlbVNlbGVjdGlvbih2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgdGhpcy5vblNlbGVjdGlvbi5lbWl0KHZhbHVlLnZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5zZWxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5tYXJrQXNEaXJ0eSh7b25seVNlbGY6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodmFsdWUudmFsdWUpO1xuICAgIH1cblxuICAgIGRpc3BsYXlJdGVtKGl0ZW06IGFueSlcbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQoaXRlbSkgPyBpdGVtLmxhYmVsIDogJ05vIFNlbGVjdGlvbic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICghZXF1YWxzKHZhbHVlLCB0aGlzLnNlbGVjdGlvbikpIHtcblxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7RHJvcGRvd25Db21wb25lbnR9IGZyb20gJy4vZHJvcGRvd24uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RHJvcGRvd25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRHJvcGRvd25Db21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERyb3Bkb3duQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERyb3Bkb3duQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0Ryb3Bkb3duTW9kdWxlXG57XG59XG5cblxuIiwiaW1wb3J0IHtDb21wb25lbnQsIGZvcndhcmRSZWYsIEluamVjdCwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0N1cnJlbmN5UGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGVxdWFscywgaXNCbGFuaywgaXNQcmVzZW50LCBWYWx1ZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuLyoqXG4gKiBMaWdodHdlaWdodCBhbmQgY29uZmlndXJhYmxlIEN1cnJlbmN5IGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgbmcgYm9vdHN0cmFwIGRpcmVjdGl2ZS4gVGhpc1xuICogY29tcG9uZW50IGNvbWJpbmVzIGFuIGlucHV0IGFuZCBjdXJyZW5jeSBjb2RlIGRyb3Bkb3duLlxuICpcbiAqXG4gKiBmb3IgbW9yZSBpbmZvIHBsZWFzZSBzZWUgY2xhc3MgRG9jIG9mIHRoZTpcbiAqICBAc2VlIHtAbGluayBjdXJyZW5jeS9jdXJyZW5jeS5jb21wb25lbnQudHN9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdhbW91bnQnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICA8YXctY3VycmVuY3kgW21vbmV5XT1cInByaWNlXCIgW2N1cnJlbmNpZXNdPVwiY3VycmVuY2llc1wiIFtuYW1lXT1cIidjdXJyZW5jeSdcIj5cbiAqICAgICAgPC9hdy1jdXJyZW5jeT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50XG4gKiAgICB7XG4gKiAgICAgICAgYW1vdW50OiBudW1iZXIgPSAxMDAwO1xuICogICAgICAgIGN1cnJlbmNpZXM6IHN0cmluZ1tdID0gWydVU0QnLCAnQ05ZJywgJ0FVRCcsICdFVVInLCAnR0JQJ107XG4gKiAgICAgICAgY3VycmVuY3lDb2RlOiBzdHJpbmcgPSB0aGlzLmN1cnJlbmNpZXNbMF07XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuXG5leHBvcnQgY29uc3QgQ1VSUkVOQ1lfQ09OVFJPTF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEN1cnJlbmN5Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWN1cnJlbmN5JyxcbiAgICB0ZW1wbGF0ZTogYDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlZGl0YWJsZVwiPlxuICAgIDxkaXYgY2xhc3M9XCJ3LWN1cnJlbmN5LWZpZWxkIHVpLWZsdWlkXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWcgXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy04IHVpLWctbm9wYWQgXCI+XG4gICAgICAgICAgICAgICAgPGlucHV0ICNjdXJyZW5jeUlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgIHBJbnB1dFRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIiBjbGFzcz1cInctdGV4dC1maWVsZCBjdXJyZW5jeS1mb3JtYXRcIlxuICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5uYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiXG4gICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJkaXNwbGF5VmFsdWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAoZm9jdXMpPVwib25Gb2N1cyhjdXJyZW5jeUlucHV0KVwiXG4gICAgICAgICAgICAgICAgICAgICAgIChibHVyKT1cIm9uQmx1cihjdXJyZW5jeUlucHV0KVwiXG4gICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy00IHVpLWctbm9wYWQgdy1jYy1maWVsZFwiPlxuICAgICAgICAgICAgICAgIDxhdy1kcm9wZG93biAqbmdJZj1cIiFyZWFkb25seUN1cnJlbmN5Q29kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIiBbbGlzdF09XCJjdXJyZW5jaWVzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbl09XCJtb25leS5jdXJyZW5jeVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCI+XG5cbiAgICAgICAgICAgICAgICA8L2F3LWRyb3Bkb3duPlxuICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJyZWFkb25seUN1cnJlbmN5Q29kZVwiIGNsYXNzPVwidy1jYy1yZWFkb25seS1maWVsZFwiPnt7bW9uZXkuY3VycmVuY3l9fTwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLSBjdXJyZW5jeTonVVNEJzp0cnVlIC0tPlxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyB2YWx1ZT1cInt7ZGlzcGxheVZhbHVlfX0ge3sgZ2V0TW9uZXlDdXJyZW5jeSgpIH19XCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgLnctY3VycmVuY3ktZmllbGQgW3JlYWRvbmx5XSwudy1jdXJyZW5jeS10eXBlLWZpZWxkIFtyZWFkb25seV17YmFja2dyb3VuZC1jb2xvcjojZmZmfS53LWN1cnJlbmN5LWZpZWxkIGlucHV0LC53LWN1cnJlbmN5LXR5cGUtZmllbGQgaW5wdXR7bWluLXdpZHRoOjgwcHh9LnctY3VycmVuY3ktZmllbGQgaS5mYSwudy1jdXJyZW5jeS10eXBlLWZpZWxkIGkuZmF7Y3Vyc29yOnBvaW50ZXJ9LnctY3VycmVuY3ktZmllbGR7bWFyZ2luLXRvcDowfS53LWN1cnJlbmN5LWZpZWxkIC9kZWVwLyAudWktZHJvcGRvd257bWluLXdpZHRoOjgwcHh9LnctY2MtZmllbGR7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn0udy1jYy1yZWFkb25seS1maWVsZHtwYWRkaW5nLWxlZnQ6NXB4O2NvbG9yOiM5Njk2OTZ9Lm5vLWd1dHRlcj5bY2xhc3MqPXVpLWctXXtwYWRkaW5nLXJpZ2h0OjA7cGFkZGluZy1sZWZ0OjB9YF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIENVUlJFTkNZX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ3VycmVuY3lDb21wb25lbnQpfVxuICAgIF1cblxufSlcbmV4cG9ydCBjbGFzcyBDdXJyZW5jeUNvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogTW9uZXkgb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIHZhbHVlLCBsb2NhbGUsIGN1cnJlbmN5IGNvZGUuXG4gICAgICogSWYgdGhpcyBvYmplY3QgaXMgc2V0LCB2YWx1ZXMgd2lsbCBiZSB0YWtlbiBmcm9tIHRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtb25leTogTW9uZXk7XG5cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIHVzZXIgdG8gY2hhbmdlIE1vbmV5J3MgY3VycmVuY3kgY29kZSBhbmQgc3RpbGxcbiAgICAgKiBhbGxvdyB1c2VyIHRvIGVkaXQgTW9uZXkncyBhbW91bnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICByZWFkb25seUN1cnJlbmN5Q29kZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbmN5IHRoYXQncyBzZWxlY3RlZCBmb3IgdGhpcyBjdXJyZW5jeSBmaWVsZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1cnJlbmN5U2VsZWN0aW9uOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdXNlZCB0byBmb3JtYXQgdGhlIG1vbmV5IG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJlY2lzaW9uOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGN1cnJlbmNpZXMgdGhhdCB0aGlzIGN1cnJlbmN5IHdpZGdldCBzdXBwb3J0LiBUaGUgZm9ybWF0IGZvciBlYWNoIGVudHJ5IHNob3VsZCBiZVxuICAgICAqIFtjdXJyZW5jeS1jb2RlIC0gZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgX2N1cnJlbmNpZXM6IGFueVtdO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybWF0dGVkIGN1cnJlbmN5IHZhbHVlLiBVc2VzIGFuZ3VsYXIgY3VycmVuY3lQaXBlIHRvIGZvcm1hdCBiYXNlZCBvbiBjb3VudHJ5IGNvZGUuXG4gICAgICovXG4gICAgZGlzcGxheVZhbHVlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVuY3kgcGlwZSBpcyB1c2VkIHRvIGZvcm1hdCBvdXIgbW9uZXkgb2JqZWN0LlxuICAgICAqL1xuICAgIGN1cnJlbmN5UGlwZTogQ3VycmVuY3lQaXBlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgY3VycmVuY2llcy5cbiAgICAgICAgdGhpcy5pbml0Q3VycmVuY2llcygpO1xuXG4gICAgICAgIHRoaXMuY3VycmVuY3lQaXBlID0gbmV3IEN1cnJlbmN5UGlwZShlbnYubG9jYWxlKTtcblxuICAgICAgICBlbnYub25Mb2NhbGVDaGFuZ2Uuc3Vic2NyaWJlKChsb2NhbGU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVBpcGUgPSBuZXcgQ3VycmVuY3lQaXBlKGxvY2FsZSk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5tb25leSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3koXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9uZXkuYW1vdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMubW9uZXkpO1xuXG4gICAgICAgIHRoaXMuaW5pdEN1cnJlbmNpZXMoKTtcblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmN1cnJlbmN5U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IHRoaXMuX2N1cnJlbmNpZXNbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWFkeSB0aGUgbW9uZXkgZmllbGQgaWYgaXQgZXhpc3RzLiBhbmQgb3ZlcnJpZGUgdGhlIGV4aXN0aW5nIHZhbHVlcy5cbiAgICAgICAgaWYgKHRoaXMubW9uZXkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVuY3lTZWxlY3Rpb24gPSB0aGlzLm1vbmV5LmN1cnJlbmN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb25leSA9IG5ldyBNb25leShudWxsLCB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeSh0aGlzLm1vbmV5LmFtb3VudCk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGluaXRDdXJyZW5jaWVzKClcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5fY3VycmVuY2llcyB8fCB0aGlzLl9jdXJyZW5jaWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVuY2llcyA9IFsnVVNEJywgJ0NOWScsICdBVUQnLCAnRVVSJywgJ0dCUCddO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5IHRoZSByZWFsIHZhbHVlIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGluIHRoZSBjdXJyZW5jeSB3aWRnZXQuIFRoZW4gaGUgY2FuIG1vZGlmeSB0aGVcbiAgICAgKiB2YWx1ZSB3aXRob3V0IHNlZWluZyB0aGUgZm9ybWF0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbFxuICAgICAqL1xuICAgIG9uRm9jdXMoZWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5tb25leSkgJiYgaXNQcmVzZW50KHRoaXMubW9uZXkuYW1vdW50KSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5VmFsdWUgPSB0aGlzLm1vbmV5LmFtb3VudC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGlzcGxheSB0aGUgZm9ybWF0dGVkIGN1cnJlbmN5IHZhbHVlIHdoZW4gdGhlIHVzZXIgbmF2aWdhdGVzIGF3YXkuXG4gICAgICogQHBhcmFtIGVsXG4gICAgICovXG4gICAgb25CbHVyKGVsOiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm1vbmV5ID0gdGhpcy5tb25leS5jbG9uZSh7YW1vdW50OiBOdW1iZXIoZWwudmFsdWUpfSk7XG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeSh0aGlzLm1vbmV5LmFtb3VudCk7XG5cbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vbmV5KTtcbiAgICB9XG5cbiAgICBvblNlbGVjdGlvbihjdXJyZW5jeTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5jdXJyZW5jeVNlbGVjdGlvbiA9IGN1cnJlbmN5O1xuICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSA9IHRoaXMuZm9ybWF0Q3VycmVuY3kodGhpcy5tb25leS5hbW91bnQpO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB3aWxsIGNoZWNrIHRvIHNlZSBpZiBjdXJyZW5jeSBpcyBhIHZhbGlkIG51bWJlciBiZWZvcmUgZm9ybWF0dGluZy5cbiAgICAgKiBAcGFyYW0gdmFsXG4gICAgICovXG4gICAgcHJpdmF0ZSBmb3JtYXRDdXJyZW5jeSh2YWw6IGFueSk6IGFueVxuICAgIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvZGUgPSAnVVNEJztcbiAgICAgICAgaWYgKHRoaXMuY3VycmVuY3lTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvZGUgPSB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb25leSA9IHRoaXMubW9uZXkuY2xvbmUoe2N1cnJlbmN5OiB0aGlzLmN1cnJlbmN5U2VsZWN0aW9ufSk7XG5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIHByZWNpc2lvbiBpcyAyLiBGb3IgZXhhbXBsZSwgMTAuMjMgVVNELlxuICAgICAgICBsZXQgZGlnaXRzID0gJzEuMC0yJztcbiAgICAgICAgLy8gSWYgcHJlY2lzaW9uIGlzIHByZXNlbnQsIHVzZSBpdCBmb3IgZm9ybWF0IHRoZSBtb25leSB2YWx1ZSBmb3IgZGlzcGxheS5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnByZWNpc2lvbikpIHtcbiAgICAgICAgICAgIGRpZ2l0cyA9ICcxLjAtJyArIHRoaXMucHJlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbmN5UGlwZS50cmFuc2Zvcm0odmFsLCBjb2RlLCAnc3ltYm9sJywgZGlnaXRzKTtcbiAgICB9XG5cbiAgICBnZXRNb25leUN1cnJlbmN5KCk6IHN0cmluZyB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kaXNwbGF5VmFsdWUpICYmIHRoaXMuZGlzcGxheVZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBjdXJyZW5jaWVzKCk6IGFueVtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVuY2llcztcbiAgICB9XG5cbiAgICBzZXQgY3VycmVuY2llcyh2YWx1ZTogYW55W10pXG4gICAge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fY3VycmVuY2llcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICgodmFsdWUgaW5zdGFuY2VvZiBNb25leSkgJiYgIWVxdWFscyh2YWx1ZSwgdGhpcy5tb25leSkpIHtcbiAgICAgICAgICAgIHRoaXMubW9uZXkgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5tb25leS5jdXJyZW5jeSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbmN5U2VsZWN0aW9uID0gdGhpcy5tb25leS5jdXJyZW5jeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gdGhpcy5mb3JtYXRDdXJyZW5jeSh0aGlzLm1vbmV5LmFtb3VudCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9uZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIE1vbmV5IG9iamVjdCBpcyByZXByZXNlbnRlZCBhcyBhIHZhbHVlLCBsb2NhbGUsIGFuZCBjdXJyZW5jeUNvZGVcbiAqL1xuZXhwb3J0IGNsYXNzIE1vbmV5IGltcGxlbWVudHMgVmFsdWVcbntcbiAgICB1bmlxdWVOYW1lOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgYW1vdW50OiBudW1iZXIgPSAwLCBwdWJsaWMgcmVhZG9ubHkgY3VycmVuY3k6IHN0cmluZyA9ICdVU0QnLFxuICAgICAgICAgICAgICAgIHB1YmxpYyByZWFkb25seSBsb2NhbGU6IHN0cmluZyA9ICdlbl9VUycpXG4gICAge1xuICAgIH1cblxuXG4gICAgZ2V0VHlwZXMoKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIsXG4gICAgICAgICAgICBjdXJyZW5jeTogU3RyaW5nLFxuICAgICAgICAgICAgbG9jYWxlOiBTdHJpbmdcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjbGFzc05hbWUoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gJ01vbmV5JztcbiAgICB9XG5cbiAgICAkcHJvdG8oKTogTW9uZXlcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgTW9uZXkoMSwgJzIzJywgJzMzJyk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5hbW91bnQgKyAnLCBsb2NhbGU6ICcgKyB0aGlzLmxvY2FsZSArICcsIGNvZGU6ICAnICsgdGhpcy5jdXJyZW5jeTtcbiAgICB9XG5cblxuICAgIGNsb25lKGRhdGE6IHsgYW1vdW50PzogbnVtYmVyLCBjdXJyZW5jeT86IHN0cmluZywgbG9jYWxlPzogc3RyaW5nIH0gPSB7fSk6IE1vbmV5XG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IE1vbmV5KFxuICAgICAgICAgICAgaXNQcmVzZW50KGRhdGEuYW1vdW50KSA/IGRhdGEuYW1vdW50IDogdGhpcy5hbW91bnQsXG4gICAgICAgICAgICBpc1ByZXNlbnQoZGF0YS5jdXJyZW5jeSkgPyBkYXRhLmN1cnJlbmN5IDogdGhpcy5jdXJyZW5jeSxcbiAgICAgICAgICAgIGlzUHJlc2VudChkYXRhLmxvY2FsZSkgPyBkYXRhLmxvY2FsZSA6IHRoaXMubG9jYWxlXG4gICAgICAgICk7XG4gICAgfVxuXG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGUsIEN1cnJlbmN5UGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RHJvcGRvd25Nb2R1bGUsIElucHV0VGV4dE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7Q3VycmVuY3lDb21wb25lbnR9IGZyb20gJy4vY3VycmVuY3kuY29tcG9uZW50JztcbmltcG9ydCB7QVdTdHJpbmdGaWVsZE1vZHVsZX0gZnJvbSAnLi4vc3RyaW5nL3N0cmluZy5tb2R1bGUnO1xuaW1wb3J0IHtBV0Ryb3Bkb3duTW9kdWxlfSBmcm9tICcuLi9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDdXJyZW5jeUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV0Ryb3Bkb3duTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBDdXJyZW5jeUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDdXJyZW5jeUNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW0N1cnJlbmN5UGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgQVdDdXJyZW5jeU1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBTa2lwU2VsZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzQmxhbmssIGlzRGF0ZX0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcblxuXG4vKipcbiAqIExpZ2h0d2VpZ2h0IGFuZCBjb25maWd1cmFibGUgRGF0ZSBhbmQgVGltZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIHByaW1lbmcuIFRoaXNcbiAqIGNvbXBvbmVudCBjb21iaW5lcyBib3RoIGRhdGUgcGlja2VyIGFzIHdlbGwgYXMgdGltZSBwaWNrZXJcbiAqXG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdteVRpbWVyJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgPGF3LWRhdGUtdGltZSBbdmFsdWVdPVwiZGF0ZVwiIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiICBbbmFtZV09XCInZHVlRGF0ZSdcIj5cbiAqICAgIDwvYXctZGF0ZS10aW1lPlxuICpcbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlUaW1tZXJDb21wb25ldFxuICogICAge1xuICpcbiAqICAgICAgICBkYXRlOiBEYXRlID0gbmV3IERhdGUoKTtcbiAqXG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0RnVsbFllYXIoMjAxNiAsIDEwICwgMyk7XG4gKiAgICAgICAgICAgIHRoaXMuZGF0ZS5zZXRIb3VycygxMCAsIDEwICwgMTApO1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqXG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0IHlvdSB3aWxsIHNlZSBkYXRlIGZpZWxkIGFuZCB0aW1lIGZpZWxkIGlzIGhpZGRlbiB0byBzaG93IGJvdGggeW91IGp1c3QgZG8gZm9sbG93aW5nOlxuICpcbiAqICBgYGBcbiAqXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ215VGltZXInICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgPGF3LWRhdGUtdGltZSBbdmFsdWVdPVwiZGF0ZVwiICBbc2hvd1RpbWVdPVwic2hvd1RpbWVcIiBbZWRpdGFibGVdPVwiZWRpdGFibGVcIiAgW25hbWVdPVwiJ2JiZGQnXCI+XG4gKiAgICA8L2F3LWRhdGUtdGltZT5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15VGltbWVyQ29tcG9uZXRcbiAqICAgIHtcbiAqICAgICAgICBkYXRlOiBEYXRlID0gbmV3IERhdGUoKTtcbiAqICAgICAgICBzaG93VGltZSA9IHRydWU7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgICAgICB0aGlzLmRhdGUuc2V0RnVsbFllYXIoMjAxNiAsIDEwICwgMyk7XG4gKiAgICAgICAgICAgIHRoaXMuZGF0ZS5zZXRIb3VycygxMCAsIDEwICwgMTApO1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBEQVRFVElNRV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGF0ZUFuZFRpbWVDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRhdGUtdGltZScsXG4gICAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGVcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ3LWRhdGV0aW1lIFwiIFtjbGFzcy5oYXMtdGltZV09XCJzaG93VGltZVwiIFtmb3JtR3JvdXBdPVwiZm9ybUdyb3VwXCI+XG5cbiAgICAgICAgPHAtY2FsZW5kYXIgZm9ybUNvbnRyb2xOYW1lPVwie3tuYW1lfX1cIlxuICAgICAgICAgICAgICAgICAgICBbZGVmYXVsdERhdGVdPVwiZGVmYXVsdERhdGVcIlxuICAgICAgICAgICAgICAgICAgICBbc2hvd0ljb25dPVwic2hvd0ljb25cIlxuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0PVwie3tzaG93VGltZSA/IGZvcm1hdE5hbWVXaXRoVGltZSA6IGZvcm1hdFBhdHRlcm59fVwiXG4gICAgICAgICAgICAgICAgICAgIFt5ZWFyTmF2aWdhdG9yXT1cInNob3dOYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgW21vbnRoTmF2aWdhdG9yXT1cInNob3dOYXZpZ2F0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgW3llYXJSYW5nZV09XCJ5ZWFyUmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cInt7c2hvd1RpbWUgPyBmb3JtYXROYW1lV2l0aFRpbWUudG9VcHBlckNhc2UoKSA6IGZvcm1hdFBhdHRlcm4udG9VcHBlckNhc2UoKX19XCJcbiAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0KT1cIm9uRGF0ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpbWVPbmx5XT1cIiFzaG93RGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgIFtyZWFkb25seUlucHV0XT1cInRydWVcIlxuICAgICAgICAgICAgICAgICAgICBbbG9jYWxlXT1cImkxOG5cIj5cbiAgICAgICAgPC9wLWNhbGVuZGFyPlxuXG4gICAgICAgIDxwLWNhbGVuZGFyICpuZ0lmPVwic2hvd1RpbWVcIlxuICAgICAgICAgICAgICAgICAgICBpY29uPVwiaWNvbi1oaXN0b3J5XCJcbiAgICAgICAgICAgICAgICAgICAgZm9ybUNvbnRyb2xOYW1lPVwie3tuYW1lfX1cIlxuICAgICAgICAgICAgICAgICAgICBbaG91ckZvcm1hdF09XCJob3VyRm9ybWF0XCJcbiAgICAgICAgICAgICAgICAgICAgW2RlZmF1bHREYXRlXT1cImRlZmF1bHREYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dJY29uXT1cInNob3dJY29uXCJcbiAgICAgICAgICAgICAgICAgICAgW3RpbWVPbmx5XT1cInNob3dUaW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW3Nob3dUaW1lXT1cInNob3dUaW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInRpbWVQbGFjZUhvbGRlclwiXG4gICAgICAgICAgICAgICAgICAgIChvblNlbGVjdCk9XCJvbkRhdGVDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgIFtsb2NhbGVdPVwiaTE4blwiPlxuICAgICAgICA8L3AtY2FsZW5kYXI+XG5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhZWRpdGFibGVcIj5cbiAgICA8YXctc3RyaW5nIHZhbHVlPVwie3t2YWx1ZSB8IGRhdGU6IGZvcm1hdFBhdHRlcm5OR319XCI+PC9hdy1zdHJpbmc+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgL2RlZXAvIC53LWRhdGV0aW1lIC51aS1jYWxlbmRhciBidXR0b257Ym9yZGVyOjA7d2lkdGg6MH0vZGVlcC8gLnctZGF0ZXRpbWUgLnVpLWNhbGVuZGFyLnVpLWNhbGVuZGFyLXctYnRuIC51aS1pbnB1dHRleHR7d2lkdGg6MTAwJX0vZGVlcC8gLnVpLWNhbGVuZGFyIC51aS1jYWxlbmRhci1idXR0b24gLnVpLWJ1dHRvbi1pY29uLWxlZnR7Zm9udC1mYW1pbHk6XCJTQVAgaWNvbiBmb250c1wiO2NvbG9yOiMxOTlkZTA7Y3Vyc29yOnBvaW50ZXI7Zm9udC1zaXplOjEuNGVtfS9kZWVwLyAudWktY2FsZW5kYXIgLnVpLWNhbGVuZGFyLWJ1dHRvbiAudWktYnV0dG9uLWljb24tbGVmdC5waS1jYWxlbmRhcjpiZWZvcmV7Y29udGVudDonXFxcXGUwZTAnfS9kZWVwLyAudWktY2FsZW5kYXIgLnVpLWNhbGVuZGFyLWJ1dHRvbiAudWktYnV0dG9uLWljb24tbGVmdC5pY29uLWhpc3Rvcnk6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMDJkJ30vZGVlcC8gLnVpLWRhdGVwaWNrZXJ7d2lkdGg6MjQuMjhlbTtsaW5lLWhlaWdodDoyNXB4O3BhZGRpbmc6MDtib3JkZXItY29sb3I6Izk3OTc5Nztib3gtc2hhZG93Om5vbmV9L2RlZXAvIC51aS1kYXRlcGlja2VyIC51aS1kYXRlcGlja2VyLWhlYWRlcntwYWRkaW5nOi45MmVtIDA7Zm9udC13ZWlnaHQ6NDAwO2NvbG9yOiMwMDA7Zm9udC1zaXplOjFlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItbmV4dCwvZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItcHJldnt0b3A6MWVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciAudWktZGF0ZXBpY2tlci1wcmV2e2xlZnQ6LjJlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItbmV4dHtyaWdodDouMmVtfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0YWJsZXtmb250LXNpemU6MWVtO21hcmdpbjowIDAgMS41ZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIHRoe2ZvbnQtd2VpZ2h0OjQwMDtiYWNrZ3JvdW5kLWNvbG9yOiNlY2VjZWM7Y29sb3I6IzM2MzYzNjtwYWRkaW5nOi43ODZlbSAxLjA3ZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIHRke3BhZGRpbmc6LjFlbX0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgdGQgYXt0ZXh0LWFsaWduOmNlbnRlcjt3aWR0aDoyLjdlbTtoZWlnaHQ6Mi43ZW07bGluZS1oZWlnaHQ6Mi43ZW07cGFkZGluZzowO2JvcmRlci1yYWRpdXM6NTAlfS9kZWVwLyAudWktZGF0ZXBpY2tlciB0ZCBhLnVpLXN0YXRlLWRlZmF1bHR7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50fS9kZWVwLyAudWktZGF0ZXBpY2tlciB0ZCBhLnVpLXN0YXRlLWFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiMxOTlkZTA7Y29sb3I6I2ZmZn0vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnBpe2ZvbnQtc2l6ZToxZW19L2RlZXAvIC51aS1kYXRlcGlja2VyIC5waS5waS1jaGV2cm9uLWxlZnQ6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWVlJ30vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnBpLnBpLWNoZXZyb24tcmlnaHQ6YmVmb3Jle2NvbnRlbnQ6J1xcXFxlMWVkJ30vZGVlcC8gLnVpLWRhdGVwaWNrZXIgLnVpLWRhdGVwaWNrZXItY2FsZW5kYXIgdGQ6bm90KC51aS1zdGF0ZS1kaXNhYmxlZCkgYTpob3Zlcntib3JkZXItY29sb3I6dHJhbnNwYXJlbnQ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDI1LDE1NywyMjQsLjcpO29wYWNpdHk6Ljc1O2NvbG9yOiMzNjM2MzZ9L2RlZXAvIC51aS1kYXRlcGlja2VyLXRpbWVvbmx5e3dpZHRoOjEwMCV9L2RlZXAvIC51aS10aW1lcGlja2Vye2ZvbnQtc2l6ZToxLjE0ZW07Y29sb3I6Izc2NzY3Njtmb250LXdlaWdodDo0MDB9L2RlZXAvIC51aS10aW1lcGlja2VyIC5waXtmb250LXNpemU6MWVtfS9kZWVwLyAudWktdGltZXBpY2tlciAucGkucGktY2hldnJvbi11cDpiZWZvcmV7Y29udGVudDonXFxcXGUxZjAnfS9kZWVwLyAudWktdGltZXBpY2tlciAucGkucGktY2hldnJvbi1kb3duOmJlZm9yZXtjb250ZW50OidcXFxcZTFlZid9L2RlZXAvIC51aS10aW1lcGlja2VyPmRpdnttYXJnaW4tbGVmdDowfS9kZWVwLyAudWktdGltZXBpY2tlciAudWktc2VwYXJhdG9ye3dpZHRoOi4xZW07bWluLXdpZHRoOi4xZW19L2RlZXAvIC51aS10aW1lcGlja2VyIC51aS1zZXBhcmF0b3IgLnBpe2ZvbnQtc2l6ZTowfS9kZWVwLyAudWktZGF0ZXBpY2tlci10cmlnZ2Vye2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9L2RlZXAvIC51aS1kYXRlcGlja2VyLXRyaWdnZXIudWktYnV0dG9uOmVuYWJsZWQ6aG92ZXIsL2RlZXAvIC51aS1kYXRlcGlja2VyLXRyaWdnZXIudWktYnV0dG9uOmZvY3Vze2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9L2RlZXAvIC5oYXMtdGltZXtkaXNwbGF5OmZsZXg7ZmxleC13cmFwOm5vd3JhcH0vZGVlcC8gLmhhcy10aW1lIHAtY2FsZW5kYXI6Zmlyc3QtY2hpbGR7d2lkdGg6NTUlO21hcmdpbi1yaWdodDoxNHB4fS9kZWVwLyAuaGFzLXRpbWUgcC1jYWxlbmRhcjpsYXN0LWNoaWxke3dpZHRoOjQ1JX0vZGVlcC8gLmhhcy10aW1lIHAtY2FsZW5kYXI6bGFzdC1jaGlsZCAudWktZGF0ZXBpY2tlcntwYWRkaW5nOjB9L2RlZXAvIC5oYXMtdGltZSAudWktYnV0dG9uLWljb24tbGVmdHtsaW5lLWhlaWdodDoxOHB4fWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBEQVRFVElNRV9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERhdGVBbmRUaW1lQ29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZUFuZFRpbWVDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudCB7XG5cbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdUaW1lMTI6IHN0cmluZyA9ICdoaDptbSBhJztcbiAgICBzdGF0aWMgcmVhZG9ubHkgTmdUaW1lMjQ6IHN0cmluZyA9ICdISC5tbSBhJztcblxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCB2YWx1ZSB1c2VkIHRvIHNldCB0aGUgZGF0ZSBhbmQgdGltZSBwaWNrZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBEYXRlO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBkYXRlIGZvcm1hdCBwYXR0ZXJuIHVzZWQgaWYgbm9uZSBpcyBwYXNzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9ybWF0UGF0dGVybjogc3RyaW5nID0gJ21tL2RkL3l5JztcblxuXG4gICAgLyoqXG4gICAgICogU3BlY2lhbCB3b3JrYXJvdW5kIGFzIGZvcm1hdHRlcnMgaW4gdGhlIHByaW1lTkcgYW5kIGFuZ3VsYXIgYXJlIGRpZmZlcmVudCBzbyB1bnRpbCBpdHNcbiAgICAgKiBmaXhlZCB3ZSBuZWVkIHRvIGtlZXAgdGhpcyBleHRyYSBwYXR0ZXJuLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZm9ybWF0UGF0dGVybk5HOiBzdHJpbmcgPSAnTU0vZGQveXknO1xuXG5cbiAgICAvKipcbiAgICAgKiBTaG93cyBhbmQgaGlkZXMgbmF2aWdhdGlvbiBiYXIgd2l0aCB5ZWFyIGFuZCBtb250aHMgc2VsZWN0aW9uc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd05hdmlnYXRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogWWVhciByYW5nZSBkaXNwbGF5ZWQgZm9yIHRoZSBkcm9wIGRvd24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB5ZWFyUmFuZ2U6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNob3dzIGFuZCBoaWRlcyBuYXZpZ2F0aW9uIGJhciB3aXRoIHllYXIgYW5kIG1vbnRocyBzZWxlY3Rpb25zXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93SWNvbjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgdGltZXBpY2tlclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1RpbWU6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IERhdGVQaWNrZXIuIEV2ZW4gd2UgY2FuIGhpZGUgaXQuIGl0IHNob3VsZCBiZSBmb3IgbW9zdCBvZiB0aGUgY2FzZSBhbHdheXNcbiAgICAgKiB0cnVlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93RGF0ZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgdGhlIGRhdGUgcGlja2VyIHdoYXQgZm9ybWF0IGl0IHNob3VsZCB1c2Ugd2hlbiBwcmVzZW50aW5nIHRpbWUuIFdoZW4gaG91ckZvcm1hdCBpcyAxMixcbiAgICAgKiBpdCBzaG93cyB0aGUgQU0sIFBNXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhvdXJGb3JtYXQ6IHN0cmluZyA9ICcyNCc7XG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBldmVudCB3aGVuIHNwZWNpZmljIGRhdGUgaXMgY2xpY2tlZCBpbnNpZGUgRGF0ZVBpY2tlclxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oKTtcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZGF0ZSB0byBoaWdobGlnaHQgb24gZmlyc3Qgb3BlbmluZyBpZiB0aGUgZmllbGQgaXMgYmxhbmsuXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWZhdWx0RGF0ZTogRGF0ZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIG9mIERhdGV0aW1lIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBEYXRlQW5kVGltZSBmb3JtYXROYW1lIGlzIG5vdCBwcm9wYWdhdGVkXG4gICAgICogdG8gRGF0ZSBmaWVsZC5cbiAgICAgKi9cbiAgICBmb3JtYXROYW1lV2l0aFRpbWU6IHN0cmluZztcblxuXG4gICAgaTE4bjogYW55O1xuICAgIHRpbWVQbGFjZUhvbGRlcjogc3RyaW5nID0gJ2hoOnNzJztcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KSB7XG4gICAgICAgIHN1cGVyKGVudiwgcGFyZW50Q29udGFpbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcblxuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgdG8gZGF0ZVRpbWUgcGF0dGVybiB3aGljaCBpcyBkZWZpbmVkIGluIHJlc291cmNlIGZpbGVzXG4gICAgICAgIGlmICh0aGlzLmhvdXJGb3JtYXQgIT09ICcxMicgJiYgdGhpcy5ob3VyRm9ybWF0ICE9PSAnMjQnKSB7XG4gICAgICAgICAgICB0aGlzLmhvdXJGb3JtYXQgPSAnMjQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aW1lUGxhY2VIb2xkZXIgPSAodGhpcy5ob3VyRm9ybWF0ID09PSAnMTInKSA/XG4gICAgICAgICAgICBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMTJ9YCA6IGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUyNH1gO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKCh2YWw6IERhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHRoaXMudmFsdWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmluaXRUcmFuc2xhdGlvbnMoKTtcblxuICAgICAgICB0aGlzLmVudi5vbkxvY2FsZUNoYW5nZS5zdWJzY3JpYmUoKGxvY2FsZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRUcmFuc2xhdGlvbnMoKTtcblxuICAgICAgICB9KTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogTmVlZCB0byByZWZhY3RvciB0aGlzIGFzIHRoaXMgcmVhbGx5IGdldCBjb21wbGljYXRlZCB0cnlpbmcgdG8gY292ZXIgdXNlY2FzZSB3aXRoIHRpbWVcbiAgICAgKiBhbmQgZGF0ZSBhbmQgZXZlcnkgZm9ybWF0IHdlIGhhdmUuIFdlIHNob3VsZCBwcm9iYWJseSBoYXZlIHNlcGFyYXRlIHBhdHRlcm5zIGZvclxuICAgICAqIGRhdGVzIG9ubHkgYW5kIGRhdGUgKyB0aW1lXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0VHJhbnNsYXRpb25zKCkge1xuXG4gICAgICAgIHRoaXMuZm9ybWF0TmFtZVdpdGhUaW1lID0gdGhpcy5mb3JtYXRQYXR0ZXJuO1xuICAgICAgICBpZiAoIXRoaXMuc2hvd0RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0UGF0dGVybk5HID0gdGhpcy5mb3JtYXRQYXR0ZXJuICs9ICh0aGlzLmhvdXJGb3JtYXQgPT09ICcxMicpID9cbiAgICAgICAgICAgICAgICBgICR7RGF0ZUFuZFRpbWVDb21wb25lbnQuTmdUaW1lMTJ9YCA6IGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUyNH1gO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zaG93VGltZSkge1xuICAgICAgICAgICAgbGV0IHRpbWVTdGFydHMgPSB0aGlzLmZvcm1hdFBhdHRlcm4uaW5kZXhPZignaCcpO1xuICAgICAgICAgICAgaWYgKHRpbWVTdGFydHMgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtYXROYW1lV2l0aFRpbWUgPSB0aGlzLmZvcm1hdFBhdHRlcm4uc3Vic3RyaW5nKDAsIHRpbWVTdGFydHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JtYXRQYXR0ZXJuTkcgKz0gKHRoaXMuaG91ckZvcm1hdCA9PT0gJzEyJykgP1xuICAgICAgICAgICAgICAgIGAgJHtEYXRlQW5kVGltZUNvbXBvbmVudC5OZ1RpbWUxMn1gIDogYCAke0RhdGVBbmRUaW1lQ29tcG9uZW50Lk5nVGltZTI0fWA7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHRoaXMuaTE4biA9IHtcbiAgICAgICAgICAgIGZpcnN0RGF5T2ZXZWVrOiAwLFxuICAgICAgICAgICAgZGF5TmFtZXM6IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLFxuICAgICAgICAgICAgICAgICdTYXR1cmRheSddLFxuICAgICAgICAgICAgZGF5TmFtZXNTaG9ydDogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgICAgICAgICAgIGRheU5hbWVzTWluOiBbJ1MnLCAnTScsICdUJywgJ1cnLCAnVCcsICdGJywgJ1MnXSxcbiAgICAgICAgICAgIG1vbnRoTmFtZXM6IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsXG4gICAgICAgICAgICAgICAgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10sXG4gICAgICAgICAgICBtb250aE5hbWVzU2hvcnQ6IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JyxcbiAgICAgICAgICAgICAgICAnTm92JywgJ0RlYyddXG4gICAgICAgIH07XG5cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gZGF0ZXMgY2hhbmdlcy4gSGVyZSB3ZSB1cGRhdGUgIHRoaXMudmFsdWUgLSA+IGRhdGUgYW5kIGFsc28gdXBkYXRlIHZhbHVlIGluc2lkZVxuICAgICAqIGZvcm1Db250cm9sbGVyXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkRhdGVDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIGlmIChpc0JsYW5rKGV2ZW50KSkge1xuICAgICAgICAgICAgLy8gdGhyb3cgc29tZSBlcnJvciA/XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbHVlID0gaXNEYXRlKGV2ZW50KSA/IGV2ZW50IDogbmV3IERhdGUoZXZlbnQpO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy52YWx1ZSwge29ubHlTZWxmOiBmYWxzZSwgZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UuZW1pdCh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsImltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NhbGVuZGFyTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEYXRlQW5kVGltZUNvbXBvbmVudH0gZnJvbSAnLi9kYXRlLWFuZC10aW1lLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgRGF0ZUFuZFRpbWVDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQ2FsZW5kYXJNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBEYXRlQW5kVGltZUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBEYXRlQW5kVGltZUNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFXRGF0ZUFuZFRpbWVNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBkaWFsb2cgaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBEaWFsb2dDb21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRpYWxvZy1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgRGlhbG9nSGVhZGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKipcbiAqIEFuIGRpYWxvZyBoZWFkZXIgYXJlYS5cbiAqXG4gKiBTZWUge0BsaW5rIERpYWxvZ0NvbXBvbmVudH0gZm9yIG1vcmUgZXhwbGFuYXRpb24uXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGlhbG9nLWZvb3RlcicsXG4gICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xufSlcbmV4cG9ydCBjbGFzcyBEaWFsb2dGb290ZXJDb21wb25lbnRcbntcbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgQ29udGVudENoaWxkLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7TW9kYWxDb250YWluZXJ9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXInO1xuaW1wb3J0IHtEaWFsb2dIZWFkZXJDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEaWFsb2dGb290ZXJDb21wb25lbnR9IGZyb20gJy4vZGlhbG9nLWZvb3Rlci5jb21wb25lbnQnO1xuXG4vKipcbiAqIERpYWxvZyBDb21wb25lbnQgdGhhdCBwcm92aWRlcyB0aGUgbG9vayBhbmQgZmVlbCBmb3IgYSBtb2RhbCBkaWFsb2cuIFRoaXMgY29tcG9uZW50IGhhcyB0aHJlZVxuICogc2VjdGlvbnM6IGhlYWRlciwgYm9keSwgYW5kIGZvb3Rlci4gSXQgY2FuIGJlIHVzZWQgYnkgaXRzZWxmIG9yIGV4dGVuZGVkLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBwb3B1cC5cbiAqICAgMS4gIGEgcmVndWxhciBkaWFsb2cgYm94IHRoYXQgaGFzIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyLiBJdCdzIHRoZSBtb3N0IGN1c3RvbWl6YWJsZS5cbiAqICAgMi4gIGEgY29uZmlybWF0aW9uIGJveCBpcyBzaW1pbGFyIHRvIGEgZGlhbG9nIGJveCBidXQgaGFzIGFjY2VwdCBhbmQgcmVqZWN0IGFjdGlvbiBidXR0b25zLlxuICogICAzLiAgYSBvdmVybGF5LCB3aGljaCBpcyBhIHZlcnkgYmFzaWMgcG9wdXAgd2l0aCB3aGF0IHlvdSBwdXQgaW5zaWRlLlxuICogICAgICAgSXQgZG9lc24ndCBoYXZlIGhlYWRlciBhbmQgZm9vdGVyLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgYW55IHBvcHVwIGNvbXBvbmVudC5cbiAqICAgMS4gIEVpdGhlciBkaXJlY3RseSBieSB1c2luZyBjb21wb25lbnQsIGF3LWRpYWxvZywgYXctY29uZmlybWF0aW9uIG9yIGF3LW92ZXJsYXlcbiAqICAgMi4gIG9yIHRoZSBNb2RhbFNlcnZpY2UgIHNlcnZpY2Uub3Blbig8RGlhbG9nQ29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIERpYWxvZyBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoaXMgdXNhZ2UgaXMgYSBxdWljayB3YXkgdG8gc2hvdyBhXG4gKiBtZXNzYWdlIHRvIHRoZSB1c2VyLlxuICpcbiAqICAgICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48RGlhbG9nQ29tcG9uZW50PiggRGlhbG9nQ29tcG9uZW50LCB7XG4gKiAgICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnTXkgUG9wdXAgVGl0bGUnLFxuICogICAgICAgICAgICAgICAgICAgICBib2R5OiAnTXkgUG9wdXAgQm9keSdcbiAqICAgICAgICAgICAgICB9KTtcbiAqXG4gKlxuICogICAyLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLlxuICpcbiAqICAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1kaWFsb2cgWyh2aXNpYmxlKV09XCJkaXNwbGF5XCIgW21vZGFsXT1cInRydWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uT3Blbik9XCJvcGVuQWN0aW9uKClcIiAob25DbG9zZSk9XCJjbG9zZUFjdGlvbigpXCI+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGlhbG9nLWhlYWRlcj5EaWFsb2cgSGVhZGVyPC9hdy1kaWFsb2ctaGVhZGVyPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERpYWxvZyBCb2R5OiBDcmVhdGluZyBhIGRpYWxvZyB1c2luZyB0aGUgZGlhbG9nIGNvbXBvbmVudFxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWRpYWxvZy1mb290ZXI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgW3N0eWxlXT1cIidwcmltYXJ5J1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY2xvc2UoKVwiPk9LPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctZGlhbG9nLWZvb3Rlcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1kaWFsb2c+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIChjbGljayk9XCJvcGVuKClcIj5PcGVuIERpYWxvZzwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogYm9vbGVhbiA9IGZhbHNlO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgZGlhbG9nQWN0aW9uOiBzdHJpbmc7XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG1vZGFsU2VydmljZTogTW9kYWxTZXJ2aWNlKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwZXIoKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICB9XG4gKiAgICAgICAgICAgICAgICAgICAgIG5nT25Jbml0KCkgeyB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBvcGVuKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXkgPSB0cnVlO1xuICogICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICBvcGVuQWN0aW9uKCkgIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaWFsb2dBY3Rpb24gPSBcIm9wZW5cIjtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgIH1cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWRpYWxvZycsXG4gICAgdGVtcGxhdGU6IGA8cC1kaWFsb2cgW2hlYWRlcl09XCJ0aXRsZVwiIFsodmlzaWJsZSldPVwidmlzaWJsZVwiXG4gICAgICAgICAgW21vZGFsXT1cIm1vZGFsXCIgW2Nsb3NhYmxlXT1cImNsb3NhYmxlXCIgW3dpZHRoXT1cIndpZHRoXCIgW2hlaWdodF09XCJoZWlnaHRcIlxuICAgICAgICAgIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbYXBwZW5kVG9dPVwiYXBwZW5kVG9cIiAob25TaG93KT1cIm9wZW4oKVwiIChvbkhpZGUpPVwiY2xvc2UoKVwiPlxuXG4gICAgPHAtaGVhZGVyICpuZ0lmPVwiaGFzSGVhZGVyKClcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctZGlhbG9nLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICA8L3AtaGVhZGVyPlxuXG4gICAge3tib2R5fX1cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cbiAgICA8cC1mb290ZXIgKm5nSWY9XCJoYXNGb290ZXIoKVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGlhbG9nLWZvb3Rlci1zZXBhcmF0b3JcIj48L2Rpdj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctZGlhbG9nLWZvb3RlclwiPjwvbmctY29udGVudD5cbiAgICA8L3AtZm9vdGVyPlxuPC9wLWRpYWxvZz5cbmAsXG4gICAgc3R5bGVzOiBbYDo6bmctZGVlcCAudWktZGlhbG9nIC51aS1kaWFsb2ctdGl0bGViYXJ7YmFja2dyb3VuZC1jb2xvcjojZjJmMmYyO3BhZGRpbmc6MTVweCAyMHB4fTo6bmctZGVlcCAudWktZGlhbG9nIC51aS1kaWFsb2ctdGl0bGViYXIgLnVpLWRpYWxvZy10aXRsZWJhci1pY29uOmhvdmVye2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudH06Om5nLWRlZXAgLnVpLXdpZGdldC1oZWFkZXJ7Zm9udC13ZWlnaHQ6NDAwO2ZvbnQtc2l6ZToxNnB4fTo6bmctZGVlcCAudWktZGlhbG9nIC51aS1kaWFsb2ctY29udGVudHtwYWRkaW5nOjE1cHggMjBweDtsaW5lLWhlaWdodDoxLjNlbX06Om5nLWRlZXAgLnVpLWRpYWxvZyAudWktd2lkZ2V0LWNvbnRlbnR7Ym9yZGVyOm5vbmV9OjpuZy1kZWVwIC51aS1kaWFsb2cudWktd2lkZ2V0LWNvbnRlbnR7Ym9yZGVyOm5vbmU7Ym94LXNoYWRvdzowIDJweCAxMHB4IDAgcmdiYSgwLDAsMCwuMyl9OjpuZy1kZWVwIC51aS1kaWFsb2cgLmRpYWxvZy1mb290ZXItc2VwYXJhdG9ye2JvcmRlci10b3A6MXB4IHNvbGlkICNkN2Q3ZDc7aGVpZ2h0OjE0cHh9OjpuZy1kZWVwIC51aS1kaWFsb2cgLnVpLWRpYWxvZy1mb290ZXJ7cGFkZGluZzowIDIwcHggMTVweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBEaWFsb2dDb21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lclxue1xuICAgIC8qKlxuICAgICAqIFRpdGxlIGZvciB0aGUgRGlhbG9nLiAgaWYgdGl0bGUgYW5kICdUaXRsZVRlbXBsYXRlJyBhcmUgYm90aCBzZXQsIHRpdGxlVGVtcGxhdGUgdGFrZXNcbiAgICAgKiBwcmVjZWRlbmNlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEJvZHkgc2VjdGlvbiBmb3IgRGlhbG9nLiBDYWxsZXIgc2hvdWxkIHVzZSBlaXRoZXIgdGhlIGJvZHkgc3RyaW5nLCBvciBjb250ZW50IHByb2plY3Rpb25cbiAgICAgKiB0byBhZGQgdmFsdWVzIHRvIHRoZSBkaWFsb2cuIElmIGJvdGggYXJlIHVzZWQsIHRoZXkgd2lsbCBib3RoIHNob3cgdXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogc3VwcG9ydCB0d28gd2F5IGRhdGEgYmluZGluZyBvbiB2aXNpYmxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogd2hldGhlciB0aGlzIGRpYWxvZyBibG9ja3MgdGhlIHJlc3Qgb2YgdGhlIHBhZ2Ugb3Igbm90IHdoZW4gZGlzcGxheWVkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbW9kYWw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSdzIGFuIHggYXQgdGhlIHRvcCByaWdodCB0aGF0IG1ha2VzIHRoZSBkaWFsb2cgY2xvc2FibGUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjbG9zYWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBUYXJnZXQgZWxlbWVudCB0byBhdHRhY2ggdGhlIGRpYWxvZy4gXCJib2R5XCIgb3IgbG9jYWwgbmctdGVtcGxhdGUgdmFyaWFibGUgYXJlIHZhbGlkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kVG86IGFueTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gZGlhbG9nIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIGRpYWxvZyBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25PcGVuOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEhlYWRlciBjb21wb25lbnQuIFVzdWFsbHkgY29udGFpbnMgdGhlIHRpdGxlLlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoRGlhbG9nSGVhZGVyQ29tcG9uZW50KSBoZWFkZXI6IERpYWxvZ0hlYWRlckNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIERpYWxvZyBmb290ZXIuIFVzdWFsbHkgY29udGFpbnMgYnV0dG9uc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoRGlhbG9nRm9vdGVyQ29tcG9uZW50KSBmb290ZXI6IERpYWxvZ0Zvb3RlckNvbXBvbmVudDtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIHRoaXMud2lkdGggPSAzMDA7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhpcyBkaWFsb2cuXG4gICAgICovXG4gICAgb3BlbigpXG4gICAge1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KCk7XG5cbiAgICAgICAgLy8gdmlzaWJsZSBpcyBhIDItd2F5IGJpbmRpbmcgdmFyaWFibGUuXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNsb3NlIHRoZSBkaWFsb2dcbiAgICAgKi9cbiAgICBjbG9zZSgpXG4gICAge1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoKTtcblxuICAgICAgICAvLyBJbXBvcnRhbnQgdG8gbWFrZSBzdXJlIGNoYW5nZSBpcyBzZXQgb24gcGFyZW50IGJpbmRpbmcuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgdGhlIHZhcmlhYmxlIGFuZCBkaWFsb2cgb3Blbi9jbG9zZSBzdGF0ZSBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIHN5bmMgYW5kIHdlIHdvdWxkbid0IHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbi5cbiAgICAgICAgdGhpcy52aXNpYmxlQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvZXMgdGhpcyBkaWFsb2cgaGF2ZSBoZWFkZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNIZWFkZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmhlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGlzIGRpYWxvZyBoYXZlIGZvb3Rlci5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0Zvb3RlcigpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZm9vdGVyKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0RpYWxvZ0NvbXBvbmVudH0gZnJvbSAnLi9kaWFsb2cuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7RGlhbG9nRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2RpYWxvZy1mb290ZXIuY29tcG9uZW50JztcbmltcG9ydCB7TW9kYWxDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC9tb2RhbC5jb21wb25lbnQnO1xuaW1wb3J0IHtEaWFsb2dNb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dGb290ZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIE1vZGFsQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dDb21wb25lbnQsXG4gICAgICAgIERpYWxvZ0hlYWRlckNvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERpYWxvZ0NvbXBvbmVudCxcbiAgICAgICAgRGlhbG9nSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBEaWFsb2dGb290ZXJDb21wb25lbnQsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0RpYWxvZ01vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgU2tpcFNlbGYsXG4gICAgVmlld0NvbnRhaW5lclJlZlxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gICAgRW52aXJvbm1lbnQsXG4gICAgZXF1YWxzLFxuICAgIEZpZWxkUGF0aCxcbiAgICBpc0FycmF5LFxuICAgIGlzQmxhbmssXG4gICAgaXNGdW5jdGlvbixcbiAgICBpc1ByZXNlbnQsXG4gICAgTGlzdFdyYXBwZXJcbn0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Nob29zZXJTZWxlY3Rpb25TdGF0ZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLXNlbGVjdGlvbi1zdGF0ZSc7XG5pbXBvcnQge0Nob29zZXJTdGF0ZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLXN0YXRlJztcbmltcG9ydCB7QmFzZUZvcm1Db21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS1mb3JtLmNvbXBvbmVudCc7XG5pbXBvcnQge0Nob29zZXJEYXRhU291cmNlfSBmcm9tICcuLi9jaG9vc2VyL2Nob29zZXItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEQVRBX1NPVVJDRX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtc291cmNlJztcbmltcG9ydCB7RGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5cblxuLyoqXG4gKiBDb252ZW5pZW50IHdyYXBwZXIgY2xhc3MgYXJvdW5kIGNvbnRyb2xzIHN1Y2ggYXMgcmFkaW9idXR0b25zLCBkcm9wZG93biwgY2hlY2tib3hlcyxcbiAqIENob29zZXIuIFRoZSB0eXBlIG9mIHRoZSBjaG9vc2VyIG1heSBiZSBkZXRlcm1pbmVkIGR5bmFtaWNhbGx5IGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgaXRlbXMgaW5cbiAqIHRoZSBkYXRhIHNvdXJjZSBsaXN0LCBvciBjYW4gYmUgc3BlY2lmaWVkIGV4cGxpY2l0bHkgdmlhIHRoZSBcInR5cGVcIiBiaW5kaW5nLlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWdlbmVyaWMtY2hvb3NlcicsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJ0eXBlXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nU3dpdGNoQ2FzZV09XCInQ2hlY2tib3gnXCI+XG4gICAgICAgIDxhdy1jaGVja2JveC1saXN0IFtsaXN0XT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZWRpdGFibGVdPVwiZWRpdGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uc109XCJzZWxlY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbbmFtZV09XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2xhYmVsRm9ybWF0dGVyXT1cImRpc3BsYXlWYWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChvblNlbGVjdGlvbik9XCJvblNlbGVjdGlvbigkZXZlbnQpXCI+XG4gICAgICAgIDwvYXctY2hlY2tib3gtbGlzdD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG5cbiAgICA8bmctdGVtcGxhdGUgW25nU3dpdGNoQ2FzZV09XCInUmFkaW8nXCI+XG4gICAgICAgIDxhdy1yYWRpb2J1dHRvbi1saXN0IFtsaXN0XT1cImxpc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtlZGl0YWJsZV09XCJlZGl0YWJsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbGFiZWxGb3JtYXR0ZXJdPVwiZGlzcGxheVZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2VsZWN0aW9uKT1cIm9uU2VsZWN0aW9uKCRldmVudClcIj5cbiAgICAgICAgPC9hdy1yYWRpb2J1dHRvbi1saXN0PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmctdGVtcGxhdGUgW25nU3dpdGNoQ2FzZV09XCInRHJvcGRvd24nXCI+XG4gICAgICAgIDxhdy1kcm9wZG93biBbbGlzdF09XCJsaXN0XCJcbiAgICAgICAgICAgICAgICAgICAgIFtpc1N0YW5kYWxvbmVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgIFtub1NlbGVjdGlvblN0cmluZ109XCJub1NlbGVjdGlvblN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAob25TZWxlY3Rpb24pPVwib25TZWxlY3Rpb24oJGV2ZW50KVwiPlxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNpdGVtVGVtcGxhdGUgbGV0LWl0ZW0+XG5cbiAgICAgICAgICAgICAgICA8IS0tIHRvZG86IGFsbG93IHRvIHBhc3MgYSBQSVBFIHRvIGRvIHNvbWUgYWRkaXRpb25hbCBmb3JtYXR0aW5nIC0tPlxuICAgICAgICAgICAgICAgIHt7IGRpc3BsYXlWYWx1ZShpdGVtLnZhbHVlKSB9fVxuICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPC9hdy1kcm9wZG93bj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG5cbiAgICA8bmctdGVtcGxhdGUgW25nU3dpdGNoQ2FzZV09XCInQ2hvb3NlcidcIj5cbiAgICAgICAgPGF3LWNob29zZXIgI2Nob29zZXJcbiAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cImVkaXRhYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgICAgICAgICBbbXVsdGlzZWxlY3RdPVwibXVsdGlzZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICBbZGF0YVNvdXJjZV09XCJkYXRhU291cmNlXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZhbHVlVHJhbnNmb3JtZXJdPVwiZGlzcGxheVZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCI+XG5cbiAgICAgICAgPC9hdy1jaG9vc2VyPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuPC9uZy1jb250YWluZXI+XG5gLFxuICAgIHN0eWxlczogW2BgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IEJhc2VGb3JtQ29tcG9uZW50LCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBHZW5lcmljQ2hvb3NlckNvbXBvbmVudCl9LFxuICAgICAgICB7cHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBDaG9vc2VyRGF0YVNvdXJjZSwgZGVwczogW0RhdGFQcm92aWRlcnMsIERhdGFGaW5kZXJzXX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgR2VuZXJpY0Nob29zZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogT3JkZXJlZCBsaXN0IG9mIGl0ZW1zIGFzc2lnbmFibGUgdG8gdGhlIGtleSBvZiB0aGUgb2JqZWN0XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0OiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBvYmplY3QgdGhpcyBjb250cm9sIGlzIGJlaW5nIGFzc2lnbmVkIHRvLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0OiBhbnk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBrZXkgZmllbGQgcGF0aCB0aGlzIGNvbnRyb2wgaXMgYmVpbmcgYXNzaWduZWQgdG8uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBrZXk6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgaW4gcGxhY2Ugb2YgTElTVCBiaW5kaW5nIHRvIHJldHJpZXZlIGEgbGlzdCBiYXNlZCBvbiB0aGUgQ2hvaWNlU291cmNlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRlc3RpbmF0aW9uQ2xhc3M6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogVXNlZCB3aGVuIHJldHJpZXZpbmcgY2hvaWNlU291cmNlIGJ5IGRlc3RpbmF0aW9uIGNsYXNzIGFuZCB0aGlzIGFyZSBleHRyYSBwYXJhbXMgdGhhdCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIG5hcnJvdyB0aGUgbWF0Y2hpbmcgb3IgdG8gcGFzcyBwYXJhbWV0ZXJzIGludG8gQ2hvaWNlU291cmNlIHByb3ZpZGVyXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjaG9pY2VQcm92aWRlclBhcmFtczogTWFwPHN0cmluZywgYW55PjtcblxuXG4gICAgLyoqXG4gICAgICogIElzIHRoaXMgYSBMaXN0IHByb3BlcnR5LCBvciBhIHRvLW9uZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG11bHRpc2VsZWN0OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIHN0eWxlIG9mIGNob29zZXIgdG8gdXNlIChSYWRpbywgQ2hlY2tib3gsIERyb3Bkb3duLCBDaG9vc2VyKVxuICAgICAqICBEZWZhdWx0cyBiYXNlZCBvbiBjYXJkaW5hbGl0eSBvZiB0aGUgbGlzdCBhbmQgd2hldGhlciBpdCdzIG11bHRpU2VsZWN0LlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBjdXN0b20ga2V5LiBpbiBvcmRlciB0byBtYWtlIHRoaXMgd29yayB3ZSBuZWVkIHRvIGludHJvZHVjZSBjdXN0b20gPHRlbXBsYXRlcz4gZm9yXG4gICAgICogYWxsIHRoaXMgY2hvb3NlciB0eXBlc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheUtleTogc3RyaW5nO1xuXG4gICAgLy8gLyoqXG4gICAgLy8gICogIFNob3VsZCB3ZSBhdHRlbXB0IGEgbWF0Y2ggYXMgdGhleSB0eXBlIChhZ2FpbnN0IHRoZSBmdWxsIGxpc3QpXG4gICAgLy8gICovXG4gICAgLy8gQElucHV0KClcbiAgICAvLyBhbGxvd0Z1bGxNYXRjaE9uSW5wdXQ6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBTdHJpbmcgcmVuZGVyZWQgYXMgZmlyc3QgdmFsdWUgaW4gdGhlIGRyb3Bkb3duIHdoaWNoIGxldCB0aGUgdXNlciB0byBtYWtlICdubyBzZWxlY3Rpb24nXG4gICAgICogZnJvbSBhdmFpbGFibGUgbGlzdCBvZiB2YWx1ZXMuIFdoZW4gdGhpcyBvcHRpb24gaXMgYWN0aXZlIGFuZCB1c2UgbWFrZSB0aGlzIHNlbGVjdGlvbiB3ZVxuICAgICAqIHNhdmUgYSBOVUxMIHZhbHVlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBub1NlbGVjdGlvblN0cmluZzogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmljIENob29zZXIgd29ya3MgZGlyZWN0bHkgd2l0aCBvYmplY3QgYW5kIGl0cyByZWZlcmVuY2VzIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGlzXG4gICAgICoga2V5cGF0aCB0byBiZSBhYmxlIHRvIHNldC9nZXQgdmFsdWUgZnJvbSB0YXJnZXQgb3IgcGFyZW50IG9iamVjdFxuICAgICAqL1xuICAgIGtleVBhdGg6IEZpZWxkUGF0aDtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHVibGljIGRhdGFTb3VyY2U6IENob29zZXJEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBCYXNlRm9ybUNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMub2JqZWN0KSkge1xuICAgICAgICAgICAgdGhpcy5vYmplY3QgPSAoPGFueT50aGlzLl92aWV3Q29udGFpbmVyLmluamVjdG9yKS52aWV3LmNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlQYXRoID0gbmV3IEZpZWxkUGF0aCh0aGlzLmtleSk7XG4gICAgICAgIGxldCBkZWZhdWx0RGF0YVByb3ZpZGVyID0gbnVsbDtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIGRlZmF1bHREYXRhUHJvdmlkZXIgPSB0aGlzLmRhdGFTb3VyY2UuZGF0YVByb3ZpZGVycy5maW5kKHRoaXMubGlzdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0RGF0YVByb3ZpZGVyID0gdGhpcy5kYXRhU291cmNlLmRhdGFQcm92aWRlcnMuZmluZCh0aGlzLmRlc3RpbmF0aW9uQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHByb2plY3RlZFNpemUgPSBkZWZhdWx0RGF0YVByb3ZpZGVyLmV4cGVjdGVkQ291bnQodGhpcy5jaG9pY2VQcm92aWRlclBhcmFtcyk7XG4gICAgICAgIHRoaXMuaW5pdFR5cGUocHJvamVjdGVkU2l6ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ0Nob29zZXInKSB7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5pbml0KHtcbiAgICAgICAgICAgICAgICBkYXRhUHJvdmlkZXI6IGRlZmF1bHREYXRhUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgcXVlcnlUeXBlOiBRdWVyeVR5cGUuRnVsbFRleHQsXG4gICAgICAgICAgICAgICAgbG9va3VwS2V5OiB0aGlzLmRpc3BsYXlLZXksXG4gICAgICAgICAgICAgICAgc3RhdGU6IG5ldyBDaG9vc2VyU3RhdGUobmV3IEdDQ2hvb3NlclN0YXRlKHRoaXMpLCB0aGlzLm11bHRpc2VsZWN0KSxcbiAgICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogdGhpcy5tdWx0aXNlbGVjdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGRvIHdlIG5lZWQgdG8gcmVhZCB0aGlzIHZhbHVlIGluIGFzeW5jP1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gZGVmYXVsdERhdGFQcm92aWRlci5kYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMudmFsaWRhdGVSZXF1aXJlZCgpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgLy8gdGhpcy5ub1NlbGVjdGlvblN0cmluZyA9IHRoaXMuaTE4bi5pbnN0YW50KCdXaWRnZXRzLmdjaG9vc2VyLm5vU2VsU3RyaW5nJyk7XG4gICAgICAgICAgICB0aGlzLm5vU2VsZWN0aW9uU3RyaW5nID0gJ1NlbGVjdCBhIEl0ZW0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIEBJbnB1dCB0eXBlIGlzIG5vdCBwYXNzZWQgd2UgdHJ5IHRvIGd1ZXNzIGFuZCBzZWxlY3QgdGhlIGJlc3QgdHlwZSBmb3IgY3VycmVudCBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRUeXBlKHByb2plY3RlZFNpemU6IG51bWJlcilcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gKHByb2plY3RlZFNpemUgPD0gMCB8fCBwcm9qZWN0ZWRTaXplID4gOCkgPyAnQ2hvb3NlcicgOiAnQ2hlY2tib3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAocHJvamVjdGVkU2l6ZSA8PSAwIHx8IHByb2plY3RlZFNpemUgPiAyMCkgPyAnQ2hvb3NlcidcbiAgICAgICAgICAgICAgICAgICAgOiAocHJvamVjdGVkU2l6ZSA8IDYpID8gJ1JhZGlvJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAnRHJvcGRvd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlcmUgYXJlIGNlcnRhaW4gcHJvcGVydGllcyB3aGljaCBhcmUgcmVxdWlyZWQgYnkgdGhpcyBjb21wb25lbnQuIEFzIGFscmVhZHkgbWVudGlvbmVkXG4gICAgICogYWJvdmUgR2VuZXJpY0Nob29zZXIgd29ya3Mgd2l0aCByZWZlcmVuY2VzIGFuZCB0aGVmb3JlIHR3byBrZXkgcHJvcGVydGllcyBhcmUgb2JqZWN0IGFuZCBrZXlcbiAgICAgKiBzbyB3ZSBjYW4gYWNjZXNzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHZhbGlkYXRlUmVxdWlyZWQoKVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5vYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2Fubm90IGNvbnRpbnVlIHdpdGhvdXQgYSBvYmplY3QnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMua2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGEga2V5IGJpbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmxpc3QpICYmIGlzQmxhbmsodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0Nhbm5vdCBjb250aW51ZSB3aXRob3V0IGhhdmluZyBlaXRoZXIgbGlzdCBvZiB2YWx1ZXMgb3IgZGVzdGluYXRpb25DbGFzcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudChcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUpICYmXG4gICAgICAgICAgICAodGhpcy50eXBlICE9PSAnUmFkaW8nICYmIHRoaXMudHlwZSAhPT0gJ0NoZWNrYm94JyAmJiB0aGlzLnR5cGUgIT09ICdEcm9wZG93bicgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgIT09ICdDaG9vc2VyJykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgaW5zdGFudGlhdGUgR2VuZXJpY0Nob29zZXIgIC0gaW52YWxpZCB0eXBlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmRpc3BsYXlLZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlLZXkgPSAndG9TdHJpbmcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBVc2VkIHdoZW4gZGlzcGxheWluZyB2YWx1ZSBib3RoIGZyb20gcHJpbWl0aXZlIHR5cGUgYXMgd2VsbCBjb21wbGV4IG9iamVjdC4gSWYgeW91IHdhbnQgdG9cbiAgICAgKiBjb250cm9sIGhvdyBpdGVtIGlzIGRpc3BsYXllZCB5b3UgY2FuIHByb3ZpZGUgZGlzcGxheSBrZXksIHdoaWNoIGlzIGNhbiBiZSBhICBtZXRob2Qgb3JcbiAgICAgKiBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0IHlvdSBhcmUgZGlzcGxheWluZy5cbiAgICAgKlxuICAgICAqIFRvZG86IHRoaW5rIGFib3V0IGZvcm1hdHRlcnMgYXMgd2VsbFxuICAgICAqXG4gICAgICovXG4gICAgZGlzcGxheVZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kaXNwbGF5S2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZpZWxkVmFsdWUgPSBGaWVsZFBhdGguZ2V0RmllbGRWYWx1ZShpdGVtLCB0aGlzLmRpc3BsYXlLZXkpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihmaWVsZFZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkVmFsdWUuY2FsbChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmllbGRWYWx1ZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBSZXRyaWV2ZSBhIGN1cnJlbnQgdmFsdWUgZnJvbSB0aGUgcGFyZW50L3RhcmdldCBvYmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGdldCBzZWxlY3Rpb24oKTogYW55XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlQYXRoLmdldEZpZWxkVmFsdWUodGhpcy5vYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBzZXQgdmFsdWUgYmFjayB0byB0aGUgb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBzZXQgc2VsZWN0aW9uKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLmtleVBhdGguc2V0RmllbGRWYWx1ZSh0aGlzLm9iamVjdCwgdmFsdWUpO1xuICAgIH1cblxuXG4gICAgb25TZWxlY3Rpb24odmFsdWU6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wubWFya0FzRGlydHkoKTtcblxuICAgIH1cbn1cblxuLyoqXG4gKiBHZW5lcmljQ2hvb3NlciBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgQ2hvb3NlclNlbGVjdGlvblN0YXRlIHdoaWNoIGlzIHVzZWQgd2hlbiBUeXBlID0gQ2hvb3Nlci5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBHQ0Nob29zZXJTdGF0ZSBleHRlbmRzIENob29zZXJTZWxlY3Rpb25TdGF0ZVxue1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBnQ2hvb3NlcjogR2VuZXJpY0Nob29zZXJDb21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHNldFNlbGVjdGlvblN0YXRlKHNlbGVjdGlvbjogYW55LCBzZWxlY3RlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChzZWxlY3RlZCA9PT0gdGhpcy5pc1NlbGVjdGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0KSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBpbXBsZW1lbnQgc21hcnRlciBhbmQgbW9yZSBnZW5lcmljIHdheSBob3cgd2UgdXNlIGl0IGluIGphdmFcbiAgICAgICAgICAgIC8vIFJlbGF0aW9uc2hpcEZpZWxkLmFkZFRvKF9vYmplY3QsIF9rZXlQYXRoLCBzZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICBsZXQgbXVsdGlSZWw6IEFycmF5PGFueT4gPSB0aGlzLmdDaG9vc2VyLmtleVBhdGguZ2V0RmllbGRWYWx1ZSh0aGlzLmdDaG9vc2VyLm9iamVjdCk7XG4gICAgICAgICAgICBpZiAoaXNCbGFuayhtdWx0aVJlbCkpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVJlbCA9IFtdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudChtdWx0aVJlbCkgJiYgIWlzQXJyYXkobXVsdGlSZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJIGNhbiBub3Qgc3RvcmUgbXVsdGlzZWxlY3QgdmFsdWUgaW50byBub24tYXJyYXkgb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG11bHRpUmVsLnB1c2goc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbiA9IG11bHRpUmVsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIExpc3RXcmFwcGVyLnJlbW92ZUlmRXhpc3QobXVsdGlSZWwsIHNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ0Nob29zZXIuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RlZE9iamVjdCgpOiBhbnlcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmdDaG9vc2VyLm11bHRpc2VsZWN0KSB7XG4gICAgICAgICAgICBsZXQgb2JqZWN0cyA9IHRoaXMuc2VsZWN0ZWRPYmplY3RzKCk7XG4gICAgICAgICAgICByZXR1cm4gKGlzQmxhbmsob2JqZWN0cykgfHwgTGlzdFdyYXBwZXIuaXNFbXB0eShvYmplY3RzKSkgPyBudWxsIDogTGlzdFdyYXBwZXIubGFzdChcbiAgICAgICAgICAgICAgICBvYmplY3RzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nQ2hvb3Nlci5zZWxlY3Rpb247XG4gICAgfVxuXG4gICAgc2VsZWN0ZWRPYmplY3RzKCk6IEFycmF5PGFueT5cbiAgICB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLmdDaG9vc2VyLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QgJiYgaXNCbGFuayhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuZ0Nob29zZXIubXVsdGlzZWxlY3QgJiYgaXNBcnJheShzZWxlY3Rpb24pKSA/IHNlbGVjdGlvbiA6IFtzZWxlY3Rpb25dO1xuICAgIH1cblxuICAgIGlzU2VsZWN0ZWQoc2VsZWN0aW9uOiBhbnkpOiBib29sZWFuXG4gICAge1xuICAgICAgICBpZiAodGhpcy5nQ2hvb3Nlci5tdWx0aXNlbGVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmNvbnRhaW5zQ29tcGxleCh0aGlzLnNlbGVjdGVkT2JqZWN0cygpLCBzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdXJWYWx1ZSA9IHRoaXMuc2VsZWN0ZWRPYmplY3QoKTtcbiAgICAgICAgcmV0dXJuIGVxdWFscyhjdXJWYWx1ZSwgc2VsZWN0aW9uKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge05HX1ZBTFVFX0FDQ0VTU09SfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGNsYXNzIGZvciBSYWRpb0J1dHRvbiBjb21wb25lbnQgcHJvdmlkaW5nIGNvbnZlbmllbnQgd2F5IHRvIHRvIHJlbmRlciBSYWRpb0J1dHRvbiBHcm91cHNcbiAqXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKlxuICogYGBgXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdnZW5kZXItc2VsZWN0b3InICxcbiAqICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uLWxpc3QgW2xpc3RdPVwicmJMaXN0VmFsdWVzXCIgW2xheW91dF09XCJsYXlvdXRcIlxuICogICAgIFtzZWxlY3Rpb25dPVwic2VsZWN0ZWRWYWx1ZVwiIFtuYW1lXT1cIiduYW1lJ1wiPlxuICogICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uLWxpc3Q+XG4gKiAgICAgIGBcbiAqICAgICAgfSlcbiAqICAgICAgZXhwb3J0IGNsYXNzIEdlbmRlclNlbGVjdG9yQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIHJiTGlzdFZhbHVlczogc3RyaW5nW10gPSBbJ21hbGUnICwgJ2ZlbWFsZScgLCAnb3RoZXInXTtcbiAqICAgICAgICAgIHNlbGVjdGVkVmFsdWU6IHN0cmluZyA9ICdvdGhlcic7XG4gKiAgICAgICAgICBsYXlvdXQ6IHN0cmluZyA9ICdzdGFja2VkJztcbiAqXG4gKlxuICogICAgICAgICAgZm9ybUdyb3VwOiBGb3JtR3JvdXAgPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqXG4gKlxuICogICAgICAgICAgb25DQkNsaWNrIChldmVudCk6IHZvaWRcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICBjb25zb2xlLmxvZygnb25DQkNsaWNrID0gJyArIGV2ZW50KTtcbiAqICAgICAgICAgIH1cbiAqXG4gKiAgICAgIH1cbiAqXG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCBjb25zdCBSQl9MSVNUX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcmFkaW9idXR0b24tbGlzdCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0Zvcj1cImxldCBpdGVtIG9mIGxpc3Q7ICBsZXQgaSA9IGluZGV4XCIgY2xhc3M9XCJ1aS1nXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMlwiPlxuICAgICAgICA8YXctcmFkaW9idXR0b25cbiAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIlxuICAgICAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbaXNTdGFuZGFsb25lXT1cImZhbHNlXCJcbiAgICAgICAgICAgIFtuYW1lXT1cIm5hbWVcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cImlcIlxuICAgICAgICAgICAgW2xhYmVsXT1cImxhYmVsVmFsdWUoaXRlbSlcIj5cbiAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2BgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUkJfTElTVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudCl9XG4gICAgXVxuXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdFxue1xuXG4gICAgLyoqXG4gICAgICogTElzdCBvZiB2YWx1ZXMgdXNlZCB0byByZW5kZXIgdGhlIHJhZGlvIGJ1dHRvbiBncm91cFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGlzdDogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgd2hpY2ggcmFkaW8gYnV0dG9ucyBpcyBzZWxlY3RlZCB3aGVuIHJlbmRlcmVkXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb246IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogc3BlY2lhbCBleHByZXNzaW9uIHRvIGZvcm1hdCBsYWJlbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWxGb3JtYXR0ZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZXMgYW4gZXZlbnQgd2hlbiByYWRpbyBidXR0b24gaXMgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBpbnRlcm5hbCBtb2RlbCB0byBsaXN0ZW4gZm9yIHJhZGlvIHZhbHVlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqL1xuICAgIG1vZGVsOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsKHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnNlbGVjdGlvbik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBMYWJlbCBpcyBleHRyYWN0ZWQgaW50byBhIG1ldGhvZCBzbyBpbiB0aGUgZnV0dXJlIHdlIGNhbiBwbGF5IGhvdyB3ZSB3YW50IHRvIGRpc3BsYXkgdGhlXG4gICAgICogdmFsdWUuIFNpbmNlIEkgd2FudCB0byBzdXBwb3J0IGZvcm1hdHRlcnMgZm9yIGVhY2ggY29tcG9uZW50cyB3ZSBtaWdodCBoYXZlIGEgY2hhbmNlIHRvXG4gICAgICogZGVjaWRlIGhvdyB0aGUgbGFiZWwgd2lsbCBsb29rIGxpa2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBsYWJlbFZhbHVlKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxhYmVsRm9ybWF0dGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3JtYXR0ZXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEluIHRoaXMgdmVyc2lvbiBvZiBjaGVja2JveGVzIHdlIHN0aWxsIGV4cGVjdCBvbmx5IHByaW1pdGl2ZSB0eXBlcy4gS2VlcCB0aGlzIGZ1bmN0aW9uYWxpdHlcbiAgICAgKiBpbiBleHRyYSBtZXRob2Qgc28gd2UgY2FuIHdvcmsgd2l0aCBpdCBldmVuIG5vdyB3ZSBqdXN0IHJldHVybiB0aGUgc2FtZSB2YWx1ZSBiYWNrXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHZhbHVlKGl0ZW06IGFueSk6IGFueVxuICAgIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIE9uIE5HTW9kZWwgY2hhbmdlIHJldHJpZXZlIGFjdHVhbCByZWNvcmQgYmFzZWQgb24gdGhlIElOREVYIGFuZCBwcm9wYWdhdGUgaXQgdG8gYm90aFxuICAgICAqIG5nTW9kZWwgYXMgd2VsbCBhcyBGb3JtR3JvdXAuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkNoYW5nZShldmVudDogYW55KVxuICAgIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRNb2RlbDogYW55ID0gdGhpcy5saXN0W3RoaXMubW9kZWxdO1xuXG4gICAgICAgIHRoaXMub25TZWxlY3Rpb24uZW1pdCh1cGRhdGVkTW9kZWwpO1xuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKHVwZGF0ZWRNb2RlbCk7XG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUodXBkYXRlZE1vZGVsLCB7XG4gICAgICAgICAgICBlbWl0RXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2luY2Ugd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGNvbXBsZXggb2JqZWN0IHN0b3JlIG9ubHkgSU5ERVggbnVtYmVyIGluIHRoZSBtb2RlbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZU1vZGVsKHNvdWNlSXRlbTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5saXN0LmZpbmRJbmRleCgoZWxlbTogYW55KSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gc291Y2VJdGVtID09PSBlbGVtO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbCA9IGluZGV4ID09PSAtMSA/IDAgOiBpbmRleDtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHVwZGF0ZWRNb2RlbDogYW55ID0gdGhpcy5saXN0W3RoaXMubW9kZWxdO1xuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHVwZGF0ZWRNb2RlbCwge1xuICAgICAgICAgICAgZW1pdEV2ZW50OiB0cnVlLFxuICAgICAgICAgICAgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbC4gUGxlYXNlIHNlZSBDb250cm9sVmFsdWVBY2Nlc3NvclxuICAgICAqXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICBsZXQgbmV3TW9kZWwgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTW9kZWwobmV3TW9kZWwpO1xuICAgICAgICB9XG5cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3JtQ29udHJvbCwgTkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICogSW1wbGVtZW50cyBzdGFuZGFyZCBIVE1MIHJhZGlvIGJ1dHRvbiBvbiB0b3Agb2YgUHJpbWVORyB3aXRoIGFyaWJhIHN0eWxpbmdcbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIDEuIEJhc2ljIHVzYWdlIHVzaW5nIG5nTW9kZWwgcHJlLXNlbGVjdGVkIGZpcnN0IHJhZGlvXG4gKlxuICogIGBgYHRzXG4gKlxuICogICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgIHNlbGVjdG9yOiAnZGVtby1jb21wJyxcbiAqICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcidcIiBbdmFsdWVdPVwiJ3JlZCdcIiBbbGFiZWxdPVwiJ1JlZCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIj5cbiAqICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKiAgICAgICAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidjb2xvcidcIiBbdmFsdWVdPVwiJ2JsdWUnXCIgW2xhYmVsXT1cIidCbHVlJ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICBbKG5nTW9kZWwpXT1cIm1vZGVsXCI+XG4gKiAgICAgICAgICAgICAgPC9hdy1yYWRpb2J1dHRvbj5cbiAqICAgICAgYFxuICogICAgICB9KSpcbiAqICAgICAgY2xhc3MgQmFzaWNXaXRoTmdNb2RlbENvbXBvbmVudFxuICogICAgICB7XG4gKiAgICAgICAgICBtb2RlbDogc3RyaW5nW10gPSBbJ3JlZCddO1xuICpcbiAqICAgICAgICAgIGNvbnN0cnVjdG9yKClcbiAqICAgICAgICAgIHtcbiAqICAgICAgICAgIH1cbiAqICAgICAgfVxuICpcbiAqICBgYGBcbiAqXG4gKlxuICogMi4gQmFzaWMgdXNhZ2Ugd2l0aCBmb3JtR3JvdXBcbiAqXG4gKlxuICogYGBgdHNcbiAqICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgIHNlbGVjdG9yOiAnZGVtby1jb21wJyxcbiAqICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgPGRpdiBbZm9ybUdyb3VwXT1cImVudi5jdXJyZW50Rm9ybVwiPlxuICogICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ2NvbG9yMidcIiBbdmFsdWVdPVwiJ3JlZCdcIiBbbGFiZWxdPVwiJ1JlZCdcIlxuICogICAgICAgICAgICAgICAob25DaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiPlxuICogICAgICAgICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICogICAgICAgICAgICAgICA8YXctcmFkaW9idXR0b24gW25hbWVdPVwiJ2NvbG9yMidcIiBbdmFsdWVdPVwiJ2JsdWUnXCIgW2xhYmVsXT1cIidCbHVlJ1wiXG4gKiAgICAgICAgICAgICAgIChvbkNoYW5nZSk9XCJvbkNoYW5nZSgkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgIDwvYXctcmFkaW9idXR0b24+XG4gKlxuICogICAgICAgPC9kaXY+XG4gKiAgICAgICBgXG4gKiAgICAgICB9KVxuICogICAgICAgY2xhc3MgQmFzaWNXaXRoRm9ybUdyb3VwQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG4gKiAgICAgICB7XG4gKiAgICAgICAgICAgbW9kZWw6IHN0cmluZyA9ICdibHVlJztcbiAqXG4gKiAgICAgICAgICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgbmdPbkluaXQoKTogdm9pZFxuICogICAgICAgICAgIHtcbiAqICAgICAgICAgICAgICAgdGhpcy5lbnYuY3VycmVudEZvcm0gPSBuZXcgRm9ybUdyb3VwKHt9KTtcbiAqICAgICAgICAgICAgICAgdGhpcy5lbnYuY3VycmVudEZvcm0ucmVnaXN0ZXJDb250cm9sKCdjb2xvcjInLCBuZXcgRm9ybUNvbnRyb2wodGhpcy5tb2RlbCkpO1xuICogICAgICAgICAgIH1cbiAqXG4gKlxuICogICAgICAgICAgIG9uQ2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkXG4gKiAgICAgICAgICAge1xuICogICAgICAgICAgICAgICB0aGlzLm1vZGVsU2V0ID0gZXZlbnQ7XG4gKiAgICAgICAgICAgfVxuICpcbiAqICAgICAgIH1cbiAqICBgYGBgXG4gKlxuICpcbiAqXG4gKlxuICovXG5leHBvcnQgY29uc3QgUkFCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBSYWRpb0J1dHRvbkNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1yYWRpb2J1dHRvbicsXG4gICAgdGVtcGxhdGU6IGA8c3BhbiBjbGFzcz1cInctcmFkaW9idXR0b25cIj5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlZGl0YWJsZSBcIj5cbiAgICAgICAgPHAtcmFkaW9CdXR0b24gW25hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgIFtsYWJlbF09XCJsYWJlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgIFsobmdNb2RlbCldPVwibW9kZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJvbk1vZGVsQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MudS12YWxpZGF0aW9uLWVycm9yXT1cIiEoZm9ybUNvbnRyb2wudmFsaWQgfHwgKGZvcm1Db250cm9sLnByaXN0aW5lKSlcIj5cbiAgICAgICAgPC9wLXJhZGlvQnV0dG9uPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L3NwYW4+XG5gLFxuICAgIHN0eWxlczogW2AvZGVlcC8gLnctcmFkaW9idXR0b24gLnVpLXJhZGlvYnV0dG9uLWJveHt3aWR0aDoyM3B4O2hlaWdodDoyM3B4O2xpbmUtaGVpZ2h0OjIzcHh9L2RlZXAvIC53LXJhZGlvYnV0dG9uIC51aS1yYWRpb2J1dHRvbi1pY29ue2ZvbnQtc2l6ZToxLjVlbTtsaW5lLWhlaWdodDoxZW19YF0sXG5cbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUkFCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25Db21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJhZGlvXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnkgPSAnJztcblxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgdG8gYmUgdXNlZCB3aGVuIHJlbmRlcmluZyBhIHJhZGlvXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsYWJlbDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGNsaWNrIGV2ZW50IHdpdGggY3VycnJlbnQgc2VsZWN0ZWQgdmFsdWVcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbW9kZWwgdG8gY29tdW5pY2F0ZSB3aXRoIHByaW1lTmcgUmFkaW9cbiAgICAgKi9cbiAgICBtb2RlbDogYW55O1xuXG5cbiAgICBjb25zdHJ1Y3RvciAocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgIEBTa2lwU2VsZigpIEBPcHRpb25hbCgpIEBJbmplY3QoZm9yd2FyZFJlZigoKSA9PiBGb3JtUm93Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYsIHBhcmVudENvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQgKClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubW9kZWwgPSB0aGlzLmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbCA9IDxGb3JtQ29udHJvbD4gdGhpcy5mb3JtR3JvdXAuY29udHJvbHNbdGhpcy5uYW1lXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHJhZGlvIGlzIGNsaWNrZWQuIE5vdCB1c2luZyBQcmltZU5HIGNsaWNrIGV2ZW50IGFzIGl0IGlzIGZpcmVkIGJlZm9yZVxuICAgICAqIHRoZSBtb2RlbCBpcyBjaGFuZ2VkLiBUaGVyZWZvcmUgbmVlZCB0byBsaXN0ZW4gb24gKG5nTW9kZWxDaGFuZ2UpXG4gICAgICpcbiAgICAgKi9cbiAgICBvbk1vZGVsQ2hhbmdlIChuZXdWYWw6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmlzU3RhbmRhbG9uZSkge1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh0aGlzLm1vZGVsLCB7ZW1pdEV2ZW50OiB0cnVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkNoYW5nZS5lbWl0KHRoaXMubW9kZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlICh2YWx1ZTogYW55KVxuICAgIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMubW9kZWwsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLm1vZGVsKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtSYWRpb0J1dHRvbkNvbXBvbmVudH0gZnJvbSAnLi9yYWRpby1idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7UmFkaW9CdXR0b25Nb2R1bGV9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmFkaW9CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBSYWRpb0J1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSYWRpb0J1dHRvbkNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdSYWRpb0J1dHRvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7UmFkaW9CdXR0b25MaXN0Q29tcG9uZW50fSBmcm9tICcuL3JhZGlvLWJ1dHRvbi1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25Nb2R1bGV9IGZyb20gJy4uL3JhZGlvLWJ1dHRvbi9yYWRpby1idXR0b24ubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFJhZGlvQnV0dG9uTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSYWRpb0J1dHRvbkxpc3RDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUmFkaW9CdXR0b25MaXN0TW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtHZW5lcmljQ2hvb3NlckNvbXBvbmVudH0gZnJvbSAnLi9nZW5lcmljLWNob29zZXIuY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveExpc3RNb2R1bGV9IGZyb20gJy4uL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hvb3Nlck1vZHVsZX0gZnJvbSAnLi4vY2hvb3Nlci9jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXUmFkaW9CdXR0b25MaXN0TW9kdWxlfSBmcm9tICcuLi9yYWRpby1idXR0b24tbGlzdC9yYWRpby1idXR0b24tbGlzdC5tb2R1bGUnO1xuaW1wb3J0IHtBV0Ryb3Bkb3duTW9kdWxlfSBmcm9tICcuLi9kcm9wZG93bi9kcm9wZG93bi5tb2R1bGUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEdlbmVyaWNDaG9vc2VyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveExpc3RNb2R1bGUsXG4gICAgICAgIEFXQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBHZW5lcmljQ2hvb3NlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgR2VuZXJpY0Nob29zZXJDb21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEFXR2VuZXJpY0Nob29zZXJNb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0VudGl0eSwgaXNCbGFuaywgaXNFbnRpdHksIExpc3RXcmFwcGVyfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge091dGxpbmVGb3JDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcblxuLyoqXG4gKiBPdXRsaW5lU3RhdGUgaXMgdGhlIGtleSBnbHVpbmcgcGFydCBmb3IgdGhlIE91dGxpbmVGb3IgYW5kIE91dGxpbmVDb250cm9sbGVyIGNvbXBvbmVudHMuIEl0XG4gKiBob2xkcyBhbGwgaW1wb3J0YW50IGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudCBvdXRsaW5lIHRyZWUgYW5kIG1hbmFnZXMgZXhwYW5zaW9uIHN0YXRlcyBpbiBmb3JtXG4gKiBvZiBzbyBjYWxsZWQgZXhwYW5zaW9uUGF0aCBhbmQgZXhwYW5zaW9uU3RhdGVzXG4gKlxuICogV2UgbmVlZCB0byBoYXZlIGEgd2F5IGhvdyB0byB3b3JrIHdpdGggZ2VuZXJpYyBkYXRhIHN0cnVjdHVyZSBpbiBvcmRlciBub3QgdG8gaG9sZCBVSSBzcGVjaWZpY1xuICogaW5mb3JtYXRpb24gb24gdGhlIGRvbWFpbiBvYmplY3QgbW9kZWwganVzdCBsaWtlIHdlIGhhZCBpdCBiZWZvcmUsIHdoZXJlIHdlIGhhZCBhbiBpbnRlcmZhY2VcbiAqIGNhbGxlZCBPdXRsaW5lTm9kZSwgd2l0aCBmaWVsZHMgKGV4cGFuZGVkLCBzZWxlY3RlZCwgZXRjLi4gKVxuICpcbiAqXG4gKiBgZXhwYW5zaW9uUGF0aGA6IEhvbGRzIGFuIGFycmF5IG9mIGN1cnJlbnRseSBzZWxlY3RlZCBhbmQgZXhwYW5kZWQgbm9kZXMuIFRoaXMgaXMgZmlsbGVkIGJ5XG4gKiBPdXRsaW5lQ29udHJvbGxlci5cbiAqXG4gKlxuICogSWYgd2UgYXJlIGRlYWxpbmcgd2l0aCBFbnRpdHkgb3IgYW55dGhpbmcgdGhhdCBoYXMgaWRlbnRpdHkgdGhlbiB3ZSBoYXZlIGVhc2llciBzaXR1YXRpb24gYXMgd2VcbiAqIGNhbiBhc2sgZm9yIElEIGFuZCBpdCBpcyBtb3JlIGVmZmljaWVudCBmb3Igc2VyaWFsaXphdGlvblxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgT3V0bGluZVN0YXRlXG57XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGFuZCBleHBhbmRlZCBub2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZXhwYW5zaW9uUGF0aDogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGBhbGxvd1NlbGVjdGlvbmAgaXMgZW5hYmxlZCBvbiBPdXRsaW5lQ29udHJvbCBpdCBzYXZlZCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSB0byBiZVxuICAgICAqIGFibGUgbGF0ZXIgb24gYXBwbHkgc29tZSBzdHlsaW5nIGFuZCBicm9hZGNhc3QgdGhpcyBzZWxlY3Rpb24gb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHNlbGVjdGVkSXRlbTogYW55O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBNYXBzIG9iamVjdCByZWZlcmVuY2UgdG8gYm9vbGVhbiB2YWx1ZXMsIHdoZXJlIFRSVUUgbWVhbnMgRVhQQU5ERUQsIEZBTFNFIGNvbGxhcHNlZFxuICAgICAqXG4gICAgICovXG4gICAgZXhwYW5zaW9uU3RhdGVzOiBNYXA8YW55LCBib29sZWFuPjtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIG91dGxpbmUgaXMgcmVuZGVyZWQgZm9yIGZpcnN0IHRpbWUgb3IgcmUtcmVuZGVyZWQgYW5kIHdlIHNldCBkZWZhdWx0IHZhbHVlIGZvciB0aGVcbiAgICAgKiBleHBhbnNpb25TdGF0ZXMuIFRoaXMgd2F5IHdlIGNhbiBwcmV0dHkgZWFzaWx5IGV4ZWN1dGUgQ29sbGFwc2VBbGwsIEV4cGFuZEFsbFxuICAgICAqXG4gICAgICovXG4gICAgZ2xvYmFsU3RhdGU6IGJvb2xlYW4gPSBmYWxzZTsgLy8gY29sbGFwc2VkXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhvbGRzIGN1cnJlbnQgbGV2ZWwgZHVyaW5nIHRyZWUgbm9kZSByZW5kZXJpbmcgc28gd2UgY2FuIGFwcGx5IGNvcnJlY3QgaW5kZW50YXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGN1cnJlbnRMZXZlbDogbnVtYmVyID0gLTE7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGR1cmluZyBhIHRvZ2dsZSBhY3Rpb24gdG8gcmVjb3JkIGN1cnJlbnQgc2VsZWN0aW9uIHBhdGguXG4gICAgICpcbiAgICAgKi9cbiAgICBjdXJyZW50UGF0aDogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIEdsb2JhbGx5IHNoYXJlZCBwcm9wZXJ0eVxuICAgICAqL1xuICAgIG91dGxpbmVGb3I6IE91dGxpbmVGb3JDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yICgpXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIGNvbGxhcHNlQWxsIGFuZCBleHBhbmRBbGwgd2UgYXJlIHVzaW5nIHNpbXBsZSBtZWNoYW5pc20gd2hlcmUgd2UgY2xlYW4gdXAgYWxsXG4gICAgICogc2VsZWN0aW9uIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGV4cGFuZCBzdGF0ZSwgdGhpcyB3aGV5IGlzRXhwYW5kIG1ldGhvZCByZXR1cm5zIHRoZSBzYW1lXG4gICAgICogc3RhdGUgZm9yIGFsbCBpdGVtc1xuICAgICAqL1xuICAgIGNvbGxhcHNlQWxsICgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0YXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZXhwYW5kQWxsICgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5jbGVhcigpO1xuICAgICAgICB0aGlzLmdsb2JhbFN0YXRlID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIGdldCBleHBhbnNpb25QYXRoICgpOiBhbnlbXVxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fZXhwYW5zaW9uUGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4cGFuc2lvblBhdGggPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5zaW9uUGF0aDtcbiAgICB9XG5cblxuICAgIHNldCBleHBhbnNpb25QYXRoICh2YWx1ZTogYW55W10pXG4gICAge1xuICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5fZXhwYW5zaW9uUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9leHBhbnNpb25QYXRoLmZvckVhY2goKGl0ZW06IGFueSkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShpdGVtLCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICB0b2dnbGVFeHBhbnNpb24gKGN1cnJlbnRQYXRoOiBhbnlbXSwgY2hpZHJlbj86IGFueVtdKTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoaXNCbGFuayhjdXJyZW50UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXRlbSA9IExpc3RXcmFwcGVyLmxhc3QoY3VycmVudFBhdGgpO1xuICAgICAgICBsZXQgaXRlbUNoaWxkcmVuID0gY2hpZHJlbiB8fCBbXTtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gIXRoaXMuaXNFeHBhbmRlZChpdGVtKTtcbiAgICAgICAgdGhpcy5zZXRFeHBhbnNpb25TdGF0ZShpdGVtLCBuZXdTdGF0ZSk7XG5cbiAgICAgICAgaWYgKCFuZXdTdGF0ZSkge1xuICAgICAgICAgICAgTGlzdFdyYXBwZXIucmVtb3ZlTGFzdChjdXJyZW50UGF0aCk7XG4gICAgICAgICAgICBpdGVtQ2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQ6IGFueSkgPT5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEV4cGFuc2lvblN0YXRlKGNoaWxkLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uUGF0aChjdXJyZW50UGF0aCk7XG4gICAgfVxuXG4gICAgc2V0RXhwYW5zaW9uU3RhdGUgKGl0ZW06IGFueSwgaXNFeHBhbmRlZDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgaWYgKGlzRXhwYW5kZWQgPT09IHRoaXMuZ2xvYmFsU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmRlbGV0ZShrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuc2V0KGtleSwgKGlzRXhwYW5kZWQpID8gdHJ1ZSA6IGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIGltcHJvdmUgc3RhdGUgcGVyc2lzdGluZyBsZXRzIGNoZWNrIGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggYW4gT2JqZWN0IHRoYXQgaGFzIElkZW50aXR5XG4gICAgICogc28gd2UgY2FuIGV4dHJhY3QgYW4gSUQgb3RoZXJ3aXNlIHVzZSBvYmplY3QgdG8gY29tcGFyZSBieSByZWZlcmVuY2VcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpdGVtVG9LZXkgKGl0ZW06IGFueSk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzRW50aXR5KGl0ZW0pID8gKDxFbnRpdHk+aXRlbSkuaWRlbnRpdHkoKSA6IGl0ZW07XG4gICAgfVxuXG5cbiAgICBzZXRFeHBhbnNpb25QYXRoIChpdGVtOiBhbnlbXSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uUGF0aCA9IGl0ZW07XG5cbiAgICAgICAgaXRlbS5mb3JFYWNoKChub2RlOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhwYW5zaW9uU3RhdGUobm9kZSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlzRXhwYW5kZWQgKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgaWYgKCF0aGlzLmV4cGFuc2lvblN0YXRlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsU3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmdldChrZXkpO1xuICAgIH1cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIE9uSW5pdCxcbiAgICBPdXRwdXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdDb250YWluZXJSZWZcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2FuaW1hdGUsIEFuaW1hdGlvbkJ1aWxkZXIsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlcn0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzQmxhbmssIGlzUHJlc2VudCwgTGlzdFdyYXBwZXJ9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuL291dGxpbmUtc3RhdGUnO1xuXG5cbi8qKlxuICpcbiAqIE91dGxpbmVGb3JDb21wb25lbnQgaXMgbGlrZSBuZ0ZvciwgYnV0IGZvciBoaWVyYXJjaGljYWwgKG91dGxpbmUvdHJlZSkgc3RydWN0dXJlcyAtLSBpLmUuIGluXG4gKiB0aG9zZSBjYXNlcyB3aGVyZSBhbiBpdGVtIG1heSBoYXZlIGNoaWxkcmVuLlxuICpcbiAqXG4gKiBJdCB1c2VzIG91dGxpbmUgYDxhdy1vdXRsaW5lLWNvbnRyb2w+YCB0byBwcm92aWRlIGV4cGFuZGluZyBmdW5jdGlvbmFsaXR5LCBpbmRlbnRhdGlvblxuICogYW5kIG90aGVyIHRoaW5ncy5cbiAqXG4gKlxuICogVGhpcyBjb21wb25lbnQgaGFzIG1pbmltYWwgc3R5bGluZyB0byBtYWtlIHN1cmUgaXQgY2FuIGJlIGNoYW5nZWQgZWFzaWx5LlxuICpcbiAqICMjIyBFeGFtcGxlIHJlbmRlcmluZyB0cmVlIHNlY3Rpb24sIHdoZXJlIGJhc2VkIG9uIHRoZSB0eXBlIHdlIGZvcm1hdCB0aGUgb3V0IHBsdXNcbiAqIGZvciB0aGUgbWFpbiByb290IHNlY3Rpb24gd2UgYWx3YXlzIHJlbmRlciBsaXR0bGUgcG9wdXAgbWVudS5cbiAqXG4gKiBgYGBcbiAqXG4gKiAgIDxhdy1vdXRsaW5lLWZvciBbbGlzdF09XCJsaXN0XCIgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCI+XG4gKlxuICogICAgICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1pdGVtPlxuICpcbiAqICAgICAgICAgICA8ZGl2IGNsYXNzPVwibXktc2VjdGlvblwiPlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3V0bGluZVwiPlxuICogICAgICAgICAgICAgICAgICAgPGF3LW91dGxpbmUtY29udHJvbD5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJpdGVtLnR5cGVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1N3aXRjaENhc2VdPVwiJ3RleHQnXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXMtcGFyYWdyYWZcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e2l0ZW0/LmNvbnRlbnR9fVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIG5nU3dpdGNoRGVmYXVsdD5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAqXG4gKlxuICogICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZpbHRlcnNcIiAqbmdJZj1cIml0ZW0udHlwZSA9PT0gJ3NlY3Rpb24nXCIgPlxuICpcbiAqICAgICAgICAgICAgICAgICAgIDxhdy1ob3Zlci1jYXJkIFtsaW5rVGl0bGVdPVwiJ0ZpbHRlciBJdGVtcydcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICA8YXctbGlzdCBbbGlzdF09XCJmaWx0ZXJJdGVtc1wiIFtib3JkZXJsZXNzXT1cInRydWVcIj48L2F3LWxpc3Q+XG4gKiAgICAgICAgICAgICAgICAgICA8L2F3LWhvdmVyLWNhcmQ+XG4gKlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICA8L2Rpdj5cbiAqICAgICA8L25nLXRlbXBsYXRlPmBcbiAqICAgPC9hdy1vdXRsaW5lLWZvcj5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogV2UgY2FuIHVzZSBpdCBhbHNvIGluIGVtYmVkZGVkIG1vZGUgd2hlcmUgd2UgdXNlIHRoZSBgYXdPdXRsaW5lRm9yYCBkaXJlY3RpdmVcbiAqXG4gKiAjIyBFeGFtcGxlXG4gKlxuICpcbiAqIGBgYGBcbiAqICA8dGFibGUgIGNsYXNzPVwidHJlZS10YWJsZVwiID5cbiAqICAgICAgPHRoZWFkPlxuICogICAgICAgICAgPHRyPlxuICogICAgICAgICAgICAgIDx0aD5OYW1lPC90aD5cbiAqICAgICAgICAgICAgICA8dGg+VHlwZTwvdGg+XG4gKiAgICAgICAgICA8L3RyPlxuICogICAgICA8L3RoZWFkPlxuICogICAgICA8dGJvZHkgI29vbzIgYXdPdXRsaW5lRm9yIFtsaXN0XT1cImxpc3RcIlxuICogICAgICAgICAgICAgW2hhc0NoaWxkcmVuXT1cImhhc0NoaWxkcmVuXCJcbiAqICAgICAgICAgICAgIGNsYXNzPVwib3V0bGluZS10YWJsZVwiXG4gKiAgICAgID5cbiAqICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjb3V0bGluZSBsZXQtaXRlbT5cbiAqICAgICAgICAgICAgICA8dHI+XG4gKiAgICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz1cIml0ZW0tbmFtZSBvdXRsaW5lLWFuaW1hdGlvblwiPlxuICogICAgICAgICAgICAgICAgICAgICAgPGRpdj48YXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHt7aXRlbT8uY29udGVudH19XG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LW91dGxpbmUtY29udHJvbD48L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgPC90ZD5cbiAqICAgICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiaXRlbS10eXBlIG91dGxpbmUtYW5pbWF0aW9uXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICA8ZGl2Pnt7aXRlbS50eXBlfX08L2Rpdj5cbiAqICAgICAgICAgICAgICAgICAgPC90ZD5cbiAqICAgICAgICAgICAgICA8L3RyPlxuICogICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgPC90Ym9keT5cbiAqICA8L3RhYmxlPlxuICpcbiAqIGBgYFxuICpcbiAqIEkgd2FzIHRoaW5raW5nIG1heWJlIGZvciBmaXJzdCB0aW1lIHdlIGRvbid0IG5lZWQgdGhlIHNhbWUgYW5pbWF0aW9uIGxpa2UgZXhwYW5kaW5nIGFuZFxuICogY29sbGFwc2luZy4gTWF5YmUgd2UgbmVlZCBmYWRlLWluLiBJbiBzdWNoIGNhc2UgSSB3b3VsZCBwcm9iYWJseSBhcHBseSBAc2VjdGlvbiBhbmltIG9ubHlcbiAqIG9uIGl0ZW1zIHdoZXJlIGxldmVsID4gMCAoaW4gdGhlIHRlbXBsYXRlIEkga2VlcCBsZXZlbHMpIGFuZCBpZiBsZXZlbCA9PSAwIHRoZW4gSSB3b3VsZFxuICogZXhlY3V0ZSB0aGUgc2FtZSByZW5kZXJpbmcganVzdCB3aXRob3V0IFtAc2VjdGlvbl1cbiAqXG4gKlxuICogVG9kbzogVGhpbmsgYWJvdXQgaG93IHRvIGRvIGFuaW1hdGlvbiBmb3IgdGhlIHRhYmxlIGNhc2UuIE11c3QgYWxzbyB3cml0ZSB1bml0ZXN0IC0gZHVlIHRvXG4gKiBBcmliYUxpdmUgYWdncmVzc2l2ZSBzY2hlZHVsZSB3ZSBhcmUgc2tpcHBpbmcgdGhlbSBmb3Igbm93XG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW91dGxpbmUtZm9yLCBbYXdPdXRsaW5lRm9yXScsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgU3RhcnRzIHdpdGggdGhlIGxpc3QsIHdoZXJlIG5lc3RpbmdMZXZlbCBpcyAtMS5cbiAgICBjYWxsIHRlbXBsYXRlIG91dGxpbmVJdGVtcyB0byBpdGVyYXRlIGFuZCByZW5kZXIgZWFjaCBpdGVtXG4tLT5cbjxuZy1jb250YWluZXIgW25nSWZdPVwibGlzdFwiICpuZ1RlbXBsYXRlT3V0bGV0PVwib3V0bGluZUl0ZW1zO1xuICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogbGlzdCwgbmVzdGluZ0xldmVsOiAwLCBwYXJlbnRJdGVtOiBudWxsLCBleHBhbmRlZDogdHJ1ZX1cIj5cbjwvbmctY29udGFpbmVyPlxuXG48IS0tXG4gICAgTWFpbiBFbnRyeSBwb2ludCBmb3IgdGhlIHJlY3Vyc2lvbi4gdGhpcyBpcyBjYWxsZWQgYnkgdGhlIGJsb2NrIGFib3ZlIGFzIHdlbGwgYXMgYnl0IHRoZSBpbm5lclxuICAgIHBpZWNlIHRoYXQgY2FsbHMgdGhpcyB0ZW1wbGF0ZSByZWN1cnNpdmVseSBhZ2FpbiB3aGVuIGFuIGl0ZW0gaGFzIGNoaWxkcmVuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjb3V0bGluZUl0ZW1zIGxldC1jaGlsZHJlbiBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCJcbiAgICAgICAgICAgICBsZXQtcGFyZW50PVwicGFyZW50SXRlbVwiIGxldC1leHBhbmRlZD1cImV4cGFuZGVkXCI+XG5cbiAgICA8bmctdGVtcGxhdGUgbmdGb3IgbGV0LWl0ZW0gW25nRm9yT2ZdPVwiY2hpbGRyZW5cIiAgbGV0LXJvd0luZGV4PVwiaW5kZXhcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwib3V0bGluZUl0ZW07XG4gICAgICAgICAgICBjb250ZXh0OnsgJGltcGxpY2l0OiBpdGVtLCBuZXN0aW5nTGV2ZWw6IG5lc3RpbmdMZXZlbCwgcGFyZW50SXRlbTogcGFyZW50LFxuICAgICAgICAgICAgZXhwYW5kZWQ6IGV4cGFuZGVkLCByb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPCEtLVxuXG4gICAgICAgICAgICBSZWN1cnNpb24gcGllY2U6XG5cbiAgICAgICAgICAgIEZvciBub24gZW1iZWRkZWQgY2FzZSB3aGVuIGV2ZW4gaWYgaXRzIG5vdCBleHBhbmRlZCB3ZSBuZWVkIHRvIGl0ZXJhdGUgY2hpbGRyZW5cbiAgICAgICAgICAgIGFzIHdlIHdhbnQgdG8gYXBwbHkgYW5pbWF0aW9uIHRoYXQgc2hvdWxkIGdvIHdpdGggbmdJZiB3aGljaCBpbnNpZGUgdGhlIG91dGluZUl0ZW1cbiAgICAgICAgICAgIHRlbXBsYXRlXG5cbiAgICAgICAgICAgIERvbnQgcmVjdXJzZS8gcmVuZGVyIGl0ZW1zIHRoYXQgYXJlIG5vdCB2aXNpYmxlLlxuICAgICAgICAtLT5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzQ2hpbGRyZW4oaXRlbSkgJiYgKGlzRXhwYW5kZWQoaXRlbSwgbmVzdGluZ0xldmVsKSB8fCAhZW1iZWRkZWQpICYmIGlzVmlzaWJsZShpdGVtKVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm91dGxpbmVJdGVtcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyAkaW1wbGljaXQ6IGNoaWxkcmVuRm9ySXRlbShpdGVtKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwrMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQ6IGlzRXhwYW5kZWQoaXRlbSwgbmVzdGluZ0xldmVsKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SXRlbTppdGVtIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG5cbjwhLS1cbiAgICBSZW5kZXJzIGFjdHVhbCBvdXRsaW5lIG5vZGUgYW5kIGFwcGxpZXMgYW5pbWF0aW9uIHdoaWxlIGV4cGFuZGluZyBhbmQgY29sbGFwc2luZ1xuXG4gICAgW0BzZWN0aW9uXT1cImV4cGFuZGVkIHx8IGlzRXhwYW5kZWQoaXRlbSkgPyAndmlzaWJsZScgOiAnaGlkZGVuJ1wiXG4tLT5cbjxuZy10ZW1wbGF0ZSAjb3V0bGluZUl0ZW0gbGV0LWl0ZW0gbGV0LW5lc3RpbmdMZXZlbD1cIm5lc3RpbmdMZXZlbFwiIGxldC1wYXJlbnQ9XCJwYXJlbnRJdGVtXCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiXG4gICAgICAgICAgICAgbGV0LWV4cGFuZGVkPVwiZXhwYW5kZWRcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ3LW91dGxpbmUtaXRlbVwiXG4gICAgICAgICAqbmdJZj1cIiFlbWJlZGRlZCAmJiBleHBhbmRlZFwiXG4gICAgICAgICBbc3R5bGUucGFkZGluZy1sZWZ0LnB4XT1cImluZGVudGF0aW9uKG5lc3RpbmdMZXZlbClcIlxuICAgICAgICAgaW5pdE5lc3RpbmcgW3NldExldmVsXT1cIm5lc3RpbmdMZXZlbFwiIFtzZXRQYXJlbnRJdGVtXT1cInBhcmVudFwiXG4gICAgICAgICBbc2V0Q3VycnJlbnRJdGVtXT1cIml0ZW1cIlxuICAgICAgICAgW0BzZWN0aW9uXVxuICAgICAgICAgKEBzZWN0aW9uLmRvbmUpPVwib25BbmltYXRpb25Eb25lKCRldmVudClcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29udHJvbFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogaXRlbSwgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsIHJvd0luZGV4OnJvd0luZGV4IH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tXG4gICAgICAgIFdoZW4gb3V0bGluZSBjb250cm9sIGlzIHVzZWQgYXMgZW1iZWRkZWQgbWVhbmluZyBpdHMgaW5zaWRlIGUuLmcgZGF0YXRhYmxlIHdlXG4gICAgICAgIGNhbm5vdCBoYXZlIGFueSB0YWdzIGFyb3VuZCBpdC5cblxuICAgICAgICBUb2RvOiBSZWZhY3RvciB0aGlzIGluIHRoZSB3YXkgc28gd2UgY2FuIGRvIGFuaW1hdGlvbiB3aGVuIHRhYmxlIGxpbmVzIGFyZVxuICAgICAgICBleHBhbmRlZC4gU2luY2UgaXRzIGVtYmVkZGVkIHdlIGNhbiBub3QgaGF2ZSBhbnkgd3JhcHBpbmcgZWxlbWVudCBhcm91bmQsIHRoZSB0ZW1wbGF0ZVxuICAgICAgICBpcyBmdWxseSByZXNwb25zaWJsZVxuICAgIC0tPlxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJlbWJlZGRlZCAmJiBleHBhbmRlZFwiXG4gICAgICAgICAgICAgICAgIGluaXROZXN0aW5nIFtzZXRMZXZlbF09XCJuZXN0aW5nTGV2ZWxcIiBbc2V0UGFyZW50SXRlbV09XCJwYXJlbnRcIlxuICAgICAgICAgICAgICAgICBbc2V0Q3VycnJlbnRJdGVtXT1cIml0ZW1cIlxuICAgID5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAjcmVuZGVyZWRJdGVtICpuZ1RlbXBsYXRlT3V0bGV0PVwiY29udHJvbFRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7ICRpbXBsaWNpdDogaXRlbSwgbmVzdGluZ0xldmVsOiBuZXN0aW5nTGV2ZWwsIHJvd0luZGV4OnJvd0luZGV4ICB9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbjwvbmctdGVtcGxhdGU+XG5cblxuYCxcbiAgICBzdHlsZXM6IFtgLmlzLW91dGxpbmUtYW5pbWF0aW9uPmRpdiw6Om5nLWRlZXAgLnctb3V0bGluZS1pdGVte292ZXJmbG93OmhpZGRlbn1gXSxcblxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignc2VjdGlvbicsIFtcbiAgICAgICAgICAgIHN0YXRlKCcqJywgc3R5bGUoe1xuICAgICAgICAgICAgICAgICdvdmVyZmxvdy15JzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcqJyxcbiAgICAgICAgICAgICAgICAnb3BhY2l0eSc6ICcxJ1xuXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBzdGF0ZSgndm9pZCcsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogJzAnLFxuICAgICAgICAgICAgICAgICdvcGFjaXR5JzogJzAnLFxuICAgICAgICAgICAgICAgICdvdmVyZmxvdy15JzogJ2hpZGRlbidcblxuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignKiA9PiB2b2lkJywgYW5pbWF0ZSgnMjAwbXMgZWFzZS1vdXQnKSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBhbmltYXRlKCcyMDBtcyBlYXNlLWluJykpXG4gICAgICAgIF0pLFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgT3V0bGluZUZvckNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgaXRlbXMgdGhhdCBuZWVkcyB0byBiZSByZW5kZXJlZC4gSXQgZG9lcyBub3QgaGF2ZSB0byBpbiBoaWVyYXJjaGljYWwgb3JkZXIgb3Igd2VcbiAgICAgKiBsZWF2ZSBpdCB1cCB0byB0aGUgYXBwbGljYXRpb24gdG8gZGVjaWRlIGFib3V0IHRoZSBzdHJ1Y3R1cmUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsaXN0PzogYW55W107XG5cblxuICAgIC8qKlxuICAgICAqIFRlbGxzIHRoZSBjb21wb25lbnQgbm90IHRvIHJlbmRlciBleHBhbnNpb24gY29udHJvbCwgaW4gc3VjaCBjYXNlIHdlIGV4cGFuZEFsbCBhcyBhXG4gICAgICogZGVmYXVsdCBiZWhhdmlvclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93RXhwYW5zaW9uQ29udHJvbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gbWV0aG9kIHByb3ZpZGVkIGJ5IGFwcGxpY2F0aW9uIHRvIHJldHJpZXZlIGxpc3Qgb2YgY2hpbGRyZW4gZm9yIGN1cnJlbnQgaXRlbS4gSWZcbiAgICAgKiBjaGlsZHJlbiBpcyB1bmRlZmluZWQgdGhlbiwgZGVmYXVsdCAnY2hpbGRyZW4nIGZpZWxkIGlzIHVzZWQgPGN1cnJlbnRJdGVtPi5jaGlsZHJlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hpbGRyZW46ICh2YWx1ZTogYW55KSA9PiBhbnlbXTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogT3B0aW9uIHRvIGNvbmRpdGlvbmFsbHkgcmVuZGVyIG9ubHkgaXRlbXMgdGhhdCBhcmUgc2F0aXNmeWluZyBmaWx0ZXIgY29uZGl0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpbHRlck91dDogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIGFsbCB0cmVlIG5vZGVzLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHBhbmRBbGw6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogIE1hbmFnZXMgdGhlIHN0YXRlIGZvciB0aGUgT3V0bGluZSBjb21wb25lbnQuIExhdGVyIG9uIHdlIGNhbiBwcm92aWRlIGVhc2llciB3ZSBob3cgdG9cbiAgICAgKiAgaW5pdGlhbGl6ZSBhbmQgc2V0IHNlbGVjdGlvblBhdGhzIGFuZCBzZWxlY3Rpb25TdGF0ZXMgZnJvbSB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RhdGU6IE91dGxpbmVTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2V0IGluZGVudGF0aW9uIHNpemUgdG8gYmUgdXNlZCBmb3IgZWFjaCBsZXZlbFxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbmRlbnRhdGlvblBlckxldmVsOiBudW1iZXIgPSAyNTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB0ZW1wbGF0ZSBpcyBvdXRzaWRlIG9mIHRoZSBvdXRsaW5lRm9yXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBleHRlcm5hbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gY3VycmVudCBvYmplY3QgdXNpbmcgdGhpcyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCB3aGVuIGluIHNlbGVjdGlvbiBtb2RlIHRvIHB1c2ggY3VycmVudCBzZWxlY3RlZCBJdGVtIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25JdGVtU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IE91dGxpbmVDb250cm9sIHdoZW4gbm9kZSBpcyBleHBhbmRlZCBvciBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uRXhwYW5kQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEEgdGVtcGxhdGUgdG8gdXNlIG9uIGFwcGxpY2F0aW9uIGxldmVsIHRvIHJlbmRlciBpbmRpdmlkdWFsIGl0ZW1zXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnb3V0bGluZScpXG4gICAgY29udHJvbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICBAVmlld0NoaWxkKCdyZW5kZXJlZEl0ZW0nKVxuICAgIG91dGxpbmVJdGVtOiBFbGVtZW50UmVmO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbHNcbiAgICAgKlxuICAgICAqIGN1cnJlbnRJdGVtIGFuZCBwYXJlbnRJdGVtIGFyZSB1c2VkIHRvIGNhcHR1cmUgY3VycmVudCBwcm9jZXNzZWQgaXRlbSBvZiBuZ0Zvci4gVGhpcyBpc1xuICAgICAqIHNldCBieSBkaXJlY3RpdmUgYEluaXROZXN0aW5nRGlyZWN0aXZlYFxuICAgICAqXG4gICAgICogYW5pbWF0aW9uSW5Qcm9ncmVzczogdXNlZCBieSBhbmltYXRpb24gZW5naW5lIHRvIG1ha2Ugc3VyZSB3ZSBkb250IGRvIGFueSBhY3Rpb25zIHdoaWxlXG4gICAgICogYW5pbWF0aW9uIGlzIGluIHRoZSBwcm9ncmVzc1xuICAgICAqXG4gICAgICogZW1iZWRkZWQ6IEluZGljYXRlcyB0aGF0IHdlIGFyZSB1c2luZyBkaXJlY3RpdmUgc28gaXQgd2lsbCBub3QgaGF2ZSBkZWZhdWx0IGNvbXBvbmVudFxuICAgICAqIHdyYXBwZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGN1cnJlbnRJdGVtOiBhbnk7XG4gICAgcGFyZW50SXRlbTogYW55O1xuICAgIGFuaW1hdGlvbkluUHJvZ3Jlc3M6IGJvb2xlYW47XG4gICAgZW1iZWRkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZsYWcgdGhhdCB0ZWxscyB1cyB0aGF0IGNvbXBvbmVudCBpcyBmdWxseSByZW5kZXJlZFxuICAgICAqXG4gICAgICovXG4gICAgdmlld0luaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yIChwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBidWlsZGVyOiBBbmltYXRpb25CdWlsZGVyLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgfVxuXG4gICAgbmdPbkluaXQgKClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgT3V0bGluZVN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5zdGF0ZS5vdXRsaW5lRm9yKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vdXRsaW5lRm9yID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZEFsbCkge1xuICAgICAgICAgICAgdGhpcy5zaG93RXhwYW5zaW9uQ29udHJvbCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZS5nbG9iYWxTdGF0ZSA9IHRoaXMuZXhwYW5kQWxsO1xuXG4gICAgICAgIC8vIGluIGNhc2Ugd2Ugd2FudCB0byByZW5kZXIgY29udGVudCBvZiB0cmVlIG91dHNpZGUgb2Ygb3V0bGluZUZvclxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZXh0ZXJuYWxUZW1wbGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbFRlbXBsYXRlID0gdGhpcy5leHRlcm5hbFRlbXBsYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWJlZGRlZCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXdvdXRsaW5lZm9yJyk7XG5cbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5jb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC8vIHdoZW4gcm9vdCBzZWN0aW9uIG5lZWRzIHRvIGJlIG9uIG5ldyBsaW5lLCB0aGVuIGF1dG9tYXRpY2FsbHkgZXhwYW5kIHNlY29uZCBsZXZlbFxuICAgICAgICAvLyBpZiAodGhpcy5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpIHtcbiAgICAgICAgLy8gICAgIHRoaXMubGlzdC5mb3JFYWNoKChpdGVtOiBhbnkpID0+IHtcbiAgICAgICAgLy8gICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KHRoaXMuc3RhdGUuY3VycmVudFBhdGgpO1xuICAgICAgICAvLyAgICAgICAgIHRoaXMuc3RhdGUudG9nZ2xlRXhwYW5zaW9uKGl0ZW0pO1xuICAgICAgICAvLyAgICAgfSlcbiAgICAgICAgLy8gfVxuICAgIH1cblxuXG4gICAgbmdEb0NoZWNrICgpOiB2b2lkXG4gICAge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IHRlbXBsYXRlIGFuZCBPdXRsaW5lQ29udHJvbCB0byBpZGVudGlmeSB3aGljaCBpdGVtIGlzIGV4cGFuZGVkIGFuZCBjb2xsYXBzZWRcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRXhwYW5kZWQgKGl0ZW06IGFueSwgY3VycmVudExldmVsOiBudW1iZXIgPSAtMSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiAoY3VycmVudExldmVsID09PSAwICYmIHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lKVxuICAgICAgICAgICAgPyB0cnVlIDogdGhpcy5zdGF0ZS5pc0V4cGFuZGVkKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2luY2Ugd2UgaGF2ZSBjdXJyZW50bHkgdHdvIHdheXMgaG93IHRvIHBhc3MgY2hpbGRyZW4gaXRlbXMgd2UgbmVlZCBoYXZlIHRoaXMgbWV0aG9kIHRvXG4gICAgICogdW5pZnkgdGhlIHdheSBob3cgd2UgYWNjZXNzIGl0LiBJZiB3ZSBwYXNzIGBjaGlsZHJlbmAgYmluZGluZyB3ZSB1c2UgdGhpcyBpbnN0ZWFkLCBvdGhlcndpc2VcbiAgICAgKiB3ZSBleHBlY3QgY3VycmVudCBvYmplY3QgdG8gaGF2ZSBgY2hpbGRyZW5gIGZpZWxkXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGlsZHJlbkZvckl0ZW0gKGl0ZW06IGFueSk6IGFueVtdXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDaGlsZHJlbihpdGVtKSA/IHRoaXMuZG9HZXRDaGlsZHJlbihpdGVtKSA6IFtdO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiB0aGUgY3VycmVudCBpdGVtIGhhcyBhIGNoaWxkcmVuIGFuZCBuZWVkcyB0byBiZSByZW5kZXJlZFxuICAgICAqXG4gICAgICovXG4gICAgaGFzQ2hpbGRyZW4gKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuY2hpbGRyZW4pICYmIGlzQmxhbmsoaXRlbS5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGFzc2VydChmYWxzZSwgJ01pc3NpbmcgW2NoaWxkcmVuXSBtZXRob2QgYmluZGluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZG9HZXRDaGlsZHJlbihpdGVtKS5sZW5ndGggPiAwO1xuXG4gICAgfVxuXG4gICAgZG9HZXRDaGlsZHJlbiAoaXRlbTogYW55KTogYW55W11cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuLmFwcGx5KHRoaXMuY29udGV4dCwgW2l0ZW1dKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBVc2VzIHRoZSBgT3V0bGluZVN0YXRlYCB0byB0b2dnbGUgc3RhdGUgb2YgY3VycmVudCBzZWxlY3Rpb25QYXRoLiBUaGUgYHNlbGVjdGlvblBhdGhgIGlzXG4gICAgICogIHB1dCB0b2dldGhlciBpbnNpZGUgYE91dGxpbmVDb250cm9sYCB3aGVyZSB3ZSBpdGVyYXRlIGFsbCB0aGUgd2F5IHRvIHRoZSByb290IGFuZCBhZGRcbiAgICAgKiAgZWFjaCBpdGVtIHRvIHRoZSBgY3VycmVudFBhdGhgIGFycmF5LiBUaGlzIHdheSB3ZSBjb2xsZWN0IGxpc3Qgb2YgaXRlbSByZXByZXNlbnRpbmcgY3VycmVudFxuICAgICAqICBjdXJyZW50IGV4cGFuc2lvblBhdGguXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvbiAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgLy8gYmFja3VwIHByb2NlZHVyZSBpbiBjYXNlIG9uQW5pbWF0aW9uRG9uZSBmYWlsc1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkluUHJvZ3Jlc3MpIHsgLy8gY2hhbmdlIG9ubHkgaWYgaXRzIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY3VycmVudEl0ZW0gPSBMaXN0V3JhcHBlci5sYXN0KHRoaXMuc3RhdGUuY3VycmVudFBhdGgpO1xuICAgICAgICB0aGlzLnN0YXRlLnRvZ2dsZUV4cGFuc2lvbih0aGlzLnN0YXRlLmN1cnJlbnRQYXRoLCB0aGlzLmNoaWxkcmVuRm9ySXRlbShjdXJyZW50SXRlbSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmVtYmVkZGVkKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmFuaW1hdGVFbWJlZGRlZEl0ZW0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQW5ndWxhciBhbmltLiBjYWxsYmFjayB0aGF0IHNldHMgYmFjayB0aGUgZmxhZyB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhbmltYXRpb25zXG4gICAgICogd2hlbiBvbmUgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkFuaW1hdGlvbkRvbmUgKGV2ZW50OiBFdmVudClcbiAgICB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZWQgaW5kZW50YXRpb24gdXNlZCB0byBzaGlmdCB0aGUgbmVzdGVkIHNlY3Rpb24gdG8gdGhlIHJpZ2h0IG9yIGxhdGVyIG9uIHRvIHRoZVxuICAgICAqIGxlZnQgd2hlbiBSVEwgaXMgc3VwcG9ydGVkXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGluZGVudGF0aW9uIChjdXJyZW50TGV2ZWw6IG51bWJlcik6IG51bWJlclxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMucHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lICYmIGN1cnJlbnRMZXZlbCA+IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChjdXJyZW50TGV2ZWwgPT09IDAgJiYgdGhpcy5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUpXG4gICAgICAgICAgICA/IDAgOiAodGhpcy5pbmRlbnRhdGlvblBlckxldmVsICogY3VycmVudExldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3QgYWxsIHJvd3MgYXJlIHZpc2libGUgYnkgZGVmYXVsdCwgdGhlcmUgY2FuIGJlIGEgY2FzZSB3aGVyZSB5b3UgZG9udCB3YW50IHRvIHJlbmRlciBpdGVtc1xuICAgICAqIHVzaW5nIG91dGxpbmUuIGUuZy4gRGF0YXRhYmxlIHdpdGggZGV0YWlsIHJvdy5cbiAgICAgKi9cbiAgICBpc1Zpc2libGUgKGl0ZW06IGFueSk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5maWx0ZXJPdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuZmlsdGVyT3V0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogU2luY2Ugd2UgY2FuIG5vdCBkaXJlY3RseSBzZXQgYCpuZ1RlbXBsYXRlT3V0bGV0YCBjb250ZXh0IHZhcmlhYmxlcyB0byB0aGUgdHlwZXNjcmlwdCBjbGFzcyB3ZVxuICogdXNlIHRoaXMgZGlyZWN0aXZlIHRvIGRvIHRoZSBKb2JcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2luaXROZXN0aW5nXSdcbn0pXG5leHBvcnQgY2xhc3MgSW5pdE5lc3RpbmdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXRcbntcblxuICAgIEBJbnB1dCgpXG4gICAgc2V0TGV2ZWw6IG51bWJlcjtcblxuXG4gICAgQElucHV0KClcbiAgICBzZXRDdXJycmVudEl0ZW06IGFueTtcblxuXG4gICAgQElucHV0KClcbiAgICBzZXRQYXJlbnRJdGVtOiBhbnk7XG5cblxuICAgIGNvbnN0cnVjdG9yIChwcml2YXRlIG91dGxpbmU6IE91dGxpbmVGb3JDb21wb25lbnQpXG4gICAge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zZXRMZXZlbCkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5zdGF0ZS5jdXJyZW50TGV2ZWwgPSB0aGlzLnNldExldmVsO1xuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2V0Q3VycnJlbnRJdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsaW5lLmN1cnJlbnRJdGVtID0gdGhpcy5zZXRDdXJycmVudEl0ZW07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc2V0UGFyZW50SXRlbSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZS5jdXJyZW50SXRlbVsnJCRwYXJlbnRJdGVtJ10gPSB0aGlzLnNldFBhcmVudEl0ZW07XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbmplY3QsXG4gICAgSW5wdXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNraXBTZWxmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHthc3NlcnQsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7T3V0bGluZUZvckNvbXBvbmVudH0gZnJvbSAnLi4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuLi9vdXRsaW5lLXN0YXRlJztcblxuXG4vKipcbiAqIE91dGxpbmVDb250cm9sQ29tcG9uZW50IHJlbmRlcnMgdGhlIGluZGVudGF0aW9uLCBhcnJvdywgYW5kIHRleHQgZm9yIGEgbm9kZSBpbiBhbiBvdXRsaW5lLlxuICogSXQgc2hvdWxkIGJlIHVzZWQgZWl0aGVyIGluIHRoZSBib2R5IG9mIGFuIE91dGxpbmVGb3IgY29tcG9uZW50LCBvciBpbnNpZGUgZGF0YXRhYmxlXG4gKlxuICpcbiAqICMjVXNhZ2UgaW5zaWRlIGJvZHk6XG4gKlxuICogIEhlcmUgeW91IGNhbiBzZWUgdGhhdCB3ZSBuZWVkIHRvIHdyYXAgb3V0IGNvbnRlbnQgaW5zaWRlIG5nLXRlbXBsYXRlIHdoaWNoIHdpbGwgcHVzaCB1c1xuICogIGdpdmUgdXMgY3VycmVudCBpdGVtIGl0ZW0gYW5kIHRoZW4gd2UgY2FuIHBsYWNlIE91dGxpbmVDb250cm9sQ29tcG9uZW50IHRvIGNvbnRyb2xcbiAqICB0aGUgdHJlZS5cbiAqXG4gKiBgYGBcbiAqICA8YXctb3V0bGluZS1mb3IyICNvb28gW2xpc3RdPVwibGlzdFwiIFtoYXNDaGlsZHJlbl09XCJoYXNDaGlsZHJlblwiPlxuICpcbiAqICAgICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1pdGVtPlxuICogICAgICAgICAgPGRpdiBjbGFzcz1cIm15LXNlY3Rpb25cIj5cbiAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3V0bGluZVwiPlxuICogICAgICAgICAgICAgICAgICA8YXctb3V0bGluZS1jb250cm9sPlxuICogICAgICAgICAgICAgICAgICAgICAge3tpdGVtPy5jb250ZW50fX1cbiAqICAgICAgICAgICAgICAgICAgPC9hdy1vdXRsaW5lLWNvbnRyb2w+XG4gKiAgICAgICAgICAgICAgPC9kaXY+KlxuICogICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgPC9hdy1vdXRsaW5lLWZvcjI+XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIFdlIGNhblxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb3V0bGluZS1jb250cm9sJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBDb250cm9sIGlzIGp1c3QgdGhlIHR3byBmbGV4IGJveCBpdGVtcyBmb3IgZGlzcGxheWluZyBleHBhbmQvY29sbGFwc2UgaWNvbiBhbmQgY29udGVudFxuXG4gICAgU2luY2Ugd2UgYW5pbWF0ZSBvbmx5IHN0YW5kYWxvbmUvbm9uLWVtYmVkZGVkIGNhc2Ugbm93IHRoZW4gd2UgbmVlZCB0byBhbHNvIGFuaW1hdGUgdGhlIGljb25cbiAgICBzbyB3ZSB1c2Ugb25seSBpY29uLXNsaW0tYXJyb3ctcmlnaHQgYW5kIGRvIHRyYW5mb3JtYXRpb24gb24gdG9wIG9mIHRoaXMgdG8gbWFrZSBpdCByb3RhdGUuXG5cbiAgICBJZiBlbWJlZGRlZCBjYXNlIHdlIHVzZSBib3RoIGljb25zIGljb24tc2xpbS1hcnJvdy1yaWdodCAvIGljb24tc2xpbS1hcnJvdy1kb3duXG4tLT5cbjxkaXYgY2xhc3M9XCJ3LW91dGxpbmUtY29udHJvbFwiXG4gICAgIFtuZ0NsYXNzXT1cInsnb3V0bGluZS11LXVuc2VsZWN0YWJsZS10ZXh0Jzogb3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgJiYgIWl0ZW0uJCRwYXJlbnRJdGVtfVwiPlxuICAgIDxkaXYgY2xhc3M9XCJvdXRsaW5lLWljb24gc2FwLWljb25cIlxuICAgICAgICAgKm5nSWY9XCIhb3V0bGluZUZvci5wdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmUgfHwgIWlzUm9vdEl0ZW1cIlxuICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZUV4cGFuc2lvbigkZXZlbnQpXCJcbiAgICAgICAgIFtzdHlsZS5tYXJnaW4tbGVmdC5weF09XCJpbmRlbnRhdGlvblwiXG4gICAgICAgICBbbmdDbGFzc109XCJjYWxjdWxhdGVTdHlsZUNsYXNzKClcIj5cbiAgICA8L2Rpdj5cblxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJhbGxvd1NlbGVjdGlvbjsgdGhlbiB3aXRoU2VsZWN0aW9uIGVsc2Ugd2l0aG91dFNlbGVjdGlvblwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG5cbjwhLS1cbiBXZSBzdXBwb3J0IHR3byBjYXNlIGZvciB0aGUgY29udGVudFxuXG4gU2VsZWN0aW9uOiBXaGVuIHlvdSBjbGljayBvbiB0aGUgY29udGVudCBpdCB3aWxsIGFkZCBleHRyYSBjbGFzcyBzbyB5b3UgY2FuIHN0eWxlIGN1cnJlbnRseVxuIHNlbGVjdGVkIGl0ZW0gYXMgd2VsbCBhcyBicm9hZGNhc3QgZXZlbnQgb3V0c2lkZSBzbyBkZXZlbG9wZXIgY2FuIGhvb2sgaW4gc29tZSBjdXN0b20gbG9naWNcblxuIElmIHdlIGRvbnQgc3VwcG9ydCBzZWxlY3Rpb246IFRoZW4gY2xpY2tpbmcgb24gdGhlIGNvbnRlbnQgaXMganVzdCBsaWtlIGNsaWNraW5nIG9uIGV4cGFuZGFibGVcbiBpY29uLCBpdCB0b2dnbGVzIHRoZSBzdGF0ZVxuLS0+XG5cbjxuZy10ZW1wbGF0ZSAjd2l0aFNlbGVjdGlvbj5cbiAgICAgPHNwYW4gY2xhc3M9XCJvdXRsaW5lLWNvbnRlbnQgb3V0bGluZS1jb250ZW50LXNlbGVjdGVkXCIgKm5nSWY9XCJpc1NlbGVjdGVkKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cIm5nQ29udGVudFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cIm91dGxpbmUtY29udGVudFwiICpuZ0lmPVwiIWlzU2VsZWN0ZWQoKVwiIChjbGljayk9XCJzZWxlY3QoKVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibmdDb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9zcGFuPlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjd2l0aG91dFNlbGVjdGlvbj5cbiAgICA8c3BhbiBjbGFzcz1cIm91dGxpbmUtY29udGVudFwiIChjbGljayk9XCJ0b2dnbGVFeHBhbnNpb24oJGV2ZW50KVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibmdDb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI25nQ29udGVudD5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L25nLXRlbXBsYXRlPlxuXG5gLFxuICAgIHN0eWxlczogW2Audy1vdXRsaW5lLWNvbnRyb2x7b3ZlcmZsb3c6aGlkZGVuO2Rpc3BsYXk6ZmxleDtmbGV4LXdyYXA6bm93cmFwO2N1cnNvcjpwb2ludGVyfS53LW91dGxpbmUtY29udHJvbCAub3V0bGluZS1pY29ue2ZsZXg6MCAwIDE1cHg7Y29sb3I6I2FiYWJhYjtmb250LXNpemU6MTRweDtmb250LXdlaWdodDo3MDA7bWluLXdpZHRoOjExcHg7YWxpZ24tc2VsZjpjZW50ZXI7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSA1MG1zIGVhc2UtaW47dHJhbnNpdGlvbjp0cmFuc2Zvcm0gNTBtcyBlYXNlLWluO3RyYW5zaXRpb246dHJhbnNmb3JtIDUwbXMgZWFzZS1pbiwtd2Via2l0LXRyYW5zZm9ybSA1MG1zIGVhc2UtaW47LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjI1JSA2NSU7dHJhbnNmb3JtLW9yaWdpbjoyNSUgNjUlOy13ZWJraXQtdHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkO3RyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZH0udy1vdXRsaW5lLWNvbnRyb2wgLm91dGxpbmUtaWNvbi5vdXRsaW5lLWljb24tZXhwYW5kZWR7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDkwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0udy1vdXRsaW5lLWNvbnRyb2wgLm91dGxpbmUtY29udGVudHtmbGV4OjEgMSBhdXRvO2ZsZXgtd3JhcDp3cmFwO3BhZGRpbmc6MCA0cHh9Lnctb3V0bGluZS1jb250cm9sIC5vdXRsaW5lLWNvbnRlbnQub3V0bGluZS1jb250ZW50LXNlbGVjdGVke2N1cnNvcjpkZWZhdWx0O2ZvbnQtd2VpZ2h0OjcwMH0ub3V0bGluZS11LXVuc2VsZWN0YWJsZS10ZXh0ey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW8tdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lO2N1cnNvcjphdXRvfWBdLFxufSlcbmV4cG9ydCBjbGFzcyBPdXRsaW5lQ29udHJvbENvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgaXRlbXMgdGhhdCBuZWVkcyB0byBiZSByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogIElmIFRSVUUgaXQgY2hhbmdlcyB0aGUgYmVoYXZpb3Igb2YgdGhlIG91dGxpbmUgbm9kZSB0ZXh0IHdoaWNoIGNsaWNrIGlzIHRyaWdnZXJlZFxuICAgICAqICBpdCBzZWxlY3RzIHRoZSBpdGVtIGFuZCBicm9hZGNhc3QgdGhlIGBvbkl0ZW1TZWxlY3RlZGAgZXZlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxsb3dTZWxlY3Rpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgYWN0aW9uIHdoZW4gb3V0bGluZSBpdGVtIGlzIGV4cGFuZGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBpdGVtIHVzZWQgZm9yIHRoaXMgYE91dGxpbmVDb250cm9sYFxuICAgICAqXG4gICAgICovXG4gICAgaXRlbTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBpbmRlbnRhdGlvbiB1c2VkIHRvIHNoaWZ0IHRoZSBuZXN0ZWQgc2VjdGlvbiB0byB0aGUgbGVmdC4gVGhpcyBpcyB1c2VkIGZvclxuICAgICAqIGVtYmVkZGVkIG1vZGUgZS5nLiB0cmVlIHRhYmxlIHdoZXJlIHdlIGNhbm5vdCBpbmRlbnQgcGFyZW50XG4gICAgICovXG4gICAgaW5kZW50YXRpb246IG51bWJlcjtcblxuXG4gICAgaXNSb290SXRlbTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IgKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gT3V0bGluZVN0YXRlKSlcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBvdXRsaW5lU3RhdGU6IE91dGxpbmVTdGF0ZSxcbiAgICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE91dGxpbmVDb250cm9sQ29tcG9uZW50KSlcbiAgICAgICAgICAgICAgICAgcHJpdmF0ZSBwYXJlbnRDb250cm9sOiBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IE91dGxpbmVGb3JDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgICBwdWJsaWMgb3V0bGluZUZvcjogT3V0bGluZUZvckNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICB9XG5cbiAgICBuZ09uSW5pdCAoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLnByZXBhcmVDb250cm9sKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdlIGRvbnQgc2hvdyBleHBhbnNpb24gaWNvbnMgd2hlbiB0aGVyZSBubyBjaGlsZHJlblxuICAgICAqXG4gICAgICovXG4gICAgaGFzRXhwYW5zaW9uQ29udHJvbCAoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5oYXNDaGlsZHJlbih0aGlzLml0ZW0pICYmIHRoaXMub3V0bGluZUZvci5zaG93RXhwYW5zaW9uQ29udHJvbDtcbiAgICB9XG5cblxuICAgIGlzU2VsZWN0ZWQgKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuc2VsZWN0ZWRJdGVtID09PSB0aGlzLml0ZW07XG4gICAgfVxuXG4gICAgY2FsY3VsYXRlU3R5bGVDbGFzcyAoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBpZiAoIXRoaXMuaGFzRXhwYW5zaW9uQ29udHJvbCgpIHx8XG4gICAgICAgICAgICAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBpc0JsYW5rKHRoaXMuaXRlbS4kJHBhcmVudEl0ZW0pKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3V0bGluZUZvci5lbWJlZGRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZUZvci5pc0V4cGFuZGVkKHRoaXMuaXRlbSkgPyAnaWNvbi1zbGltLWFycm93LWRvd24nXG4gICAgICAgICAgICAgICAgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxpbmVGb3IuaXNFeHBhbmRlZCh0aGlzLml0ZW0pXG4gICAgICAgICAgICAgICAgPyAnaWNvbi1zbGltLWFycm93LXJpZ2h0IG91dGxpbmUtaWNvbi1leHBhbmRlZCcgOiAnaWNvbi1zbGltLWFycm93LXJpZ2h0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyBhbmQgZXhwYW5kcyBjdXJyZW50IG5vZGVcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUV4cGFuc2lvbiAoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50UGF0aCA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudFBhdGggPSB0aGlzLml0ZW07XG5cbiAgICAgICAgd2hpbGUgKGlzUHJlc2VudChjdXJyZW50UGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50UGF0aC51bnNoaWZ0KGN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIGN1cnJlbnRQYXRoID0gY3VycmVudFBhdGguJCRwYXJlbnRJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnRvZ2dsZUV4cGFuc2lvbigpO1xuICAgICAgICBsZXQgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGl0ZW06IHRoaXMuaXRlbSxcbiAgICAgICAgICAgIGV4cGFuZGVkOiB0aGlzLm91dGxpbmVGb3Iuc3RhdGUuaXNFeHBhbmRlZCh0aGlzLml0ZW0pXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aW9uLmVtaXQocGF5bG9hZCk7XG4gICAgICAgIHRoaXMub3V0bGluZUZvci5vbkV4cGFuZENoYW5nZS5lbWl0KHBheWxvYWQpO1xuXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIHNlbGVjdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLnN0YXRlLnNlbGVjdGVkSXRlbSA9IHRoaXMuaXRlbTtcbiAgICAgICAgdGhpcy5vdXRsaW5lRm9yLm9uSXRlbVNlbGVjdGVkLmVtaXQodGhpcy5pdGVtKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXBhcmVDb250cm9sICgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLm91dGxpbmVGb3IpICYmIGlzUHJlc2VudCh0aGlzLm91dGxpbmVTdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZUZvciA9IHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3I7XG4gICAgICAgIH1cblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMub3V0bGluZUZvciksICdNaXNzaW5nIG91dGxpbmVGb3IgY29tcG9uZW50Jyk7XG4gICAgICAgIGlmICh0aGlzLm91dGxpbmVGb3IuZW1iZWRkZWQpIHtcbiAgICAgICAgICAgIGxldCBsZXZlbCA9IHRoaXMub3V0bGluZUZvci5zdGF0ZS5jdXJyZW50TGV2ZWw7XG4gICAgICAgICAgICBpZiAodGhpcy5vdXRsaW5lRm9yLnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSAmJiBsZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXZlbCAtPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmluZGVudGF0aW9uID0gKHRoaXMub3V0bGluZUZvci5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbSA9IHRoaXMub3V0bGluZUZvci5jdXJyZW50SXRlbTtcbiAgICAgICAgdGhpcy5pc1Jvb3RJdGVtID0gaXNCbGFuayh0aGlzLml0ZW0uJCRwYXJlbnRJdGVtKTtcbiAgICB9XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5pdE5lc3RpbmdEaXJlY3RpdmUsIE91dGxpbmVGb3JDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1mb3IuY29tcG9uZW50JztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7T3V0bGluZUNvbnRyb2xDb21wb25lbnR9IGZyb20gJy4vb3V0bGluZS1jb250cm9sL291dGxpbmUtY29udHJvbC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBPdXRsaW5lRm9yQ29tcG9uZW50LFxuICAgICAgICBPdXRsaW5lQ29udHJvbENvbXBvbmVudCxcbiAgICAgICAgSW5pdE5lc3RpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE91dGxpbmVGb3JDb21wb25lbnQsXG4gICAgICAgIE91dGxpbmVDb250cm9sQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV091dGxpbmVGb3JNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBPcHRpb25hbCwgU2tpcFNlbGZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VGb3JtQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UtZm9ybS5jb21wb25lbnQnO1xuaW1wb3J0IHtGb3JtUm93Q29tcG9uZW50fSBmcm9tICcuLi8uLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS1yb3cvZm9ybS1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7ZGlzdGluY3RVbnRpbENoYW5nZWR9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuXG4vKipcbiAqIFJlbmRlcnMgaHRtbCB0ZXh0IGFyZWEgY29tcG9uZW50XG5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqXG4gKiAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgc2VsZWN0b3I6ICdteU5vdGUnICxcbiAqICAgICAgICAgIHRlbXBsYXRlOiAnPGF3LXRleHQtYXJlYSBbdmFsdWVdPVwiaW5wdXRWYWx1ZVwiIFthdXRvUmVzaXplXT1cImF1dG9SZXNpemVcIiA+XG4gKiAgICAgICAgICAgICAgPC9hdy10ZXh0LWFyZWE+J1xuICogICAgICB9KVxuICogICAgICBleHBvcnQgY2xhc3MgTXlOb3RlQ29tcG9uZW50XG4gKiAgICAgIHtcbiAqICAgICAgICAgIGlucHV0VmFsdWU6IHN0cmluZyA9ICdTb21lIHJlYWxseSBsb25nIHRleHQnO1xuICogICAgICAgICAgYXV0b1Jlc2l6ZTogZmFsc2U7XG4gKiAgICAgIH1cbiAqXG4gKiBgYGBcbiAqICBOb3RlOiBpZiB5b3UgYXJlIHVzaW5nIHRoaXMgb3V0c2lkZSBvZiBGb3JtVGFibGUgcGxlYXNlIHByb3ZpZGUgeW91ciBvd24gRm9ybUdyb3VwXG4gKi9cblxuZXhwb3J0IGNvbnN0IFRFWFRBUkVBX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUZXh0QXJlYUNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy10ZXh0LWFyZWEnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAqbmdJZj1cImVkaXRhYmxlXCIgW2Zvcm1Hcm91cF09XCJmb3JtR3JvdXBcIj5cblxuXHQ8dGV4dGFyZWFcbiAgICAgICAgcElucHV0VGV4dGFyZWFcbiAgICAgICAgW2F0dHIubmFtZV09XCJuYW1lXCJcbiAgICAgICAgY2xhc3M9XCJ3LXRleHQtYXJlYVwiXG4gICAgICAgIFtjbGFzcy51LXZhbGlkYXRpb24tZXJyb3JdPVwiIShmb3JtQ29udHJvbC52YWxpZCB8fCAoZm9ybUNvbnRyb2wucHJpc3RpbmUpKVwiXG4gICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIGZvcm1Db250cm9sTmFtZT1cInt7bmFtZX19XCJcbiAgICAgICAgW3Jvd3NdPVwicm93c1wiXG4gICAgICAgIFtjb2xzXT1cImNvbHVtbnNcIlxuICAgICAgICBbYXV0b1Jlc2l6ZV09XCJhdXRvUmVzaXplXCJcbiAgICAgICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIlxuXG4gICAgPjwvdGV4dGFyZWE+XG5cbjwvZGl2PlxuXG5cbjxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhZWRpdGFibGVcIj5cbiAgICA8YXctc3RyaW5nIFt2YWx1ZV09XCJ2YWx1ZVwiPjwvYXctc3RyaW5nPlxuPC9uZy10ZW1wbGF0ZT5cbmAsXG4gICAgc3R5bGVzOiBbYGBdLFxuXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFRFWFRBUkVBX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGV4dEFyZWFDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgVGV4dEFyZWFDb21wb25lbnQgZXh0ZW5kcyBCYXNlRm9ybUNvbXBvbmVudFxue1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHN0b3JlIGFuZCByZWFkIHVzZXIgaW5wdXRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueSA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVmaWZpZXMgdmlzaWJsZSBudW1iZXIgb2YgbGluZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd3M6IG51bWJlciA9IDI7XG5cblxuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB2aXNpYmxlIHdpZHRoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2x1bW5zOiBudW1iZXIgPSAyMDtcblxuXG4gICAgLyoqXG4gICAgICogd2hlbiB0aGlzIG9wdGlvbiBpcyBUUlVFIGFuZCB1c2VyIHN0YXJ0cyB0eXBpbmcgaXQgd2lsbCBtYXhpbWl6ZSB0ZXh0YXJlYSdzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGF1dG9SZXNpemU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgQFNraXBTZWxmKCkgQE9wdGlvbmFsKCkgQEluamVjdChmb3J3YXJkUmVmKCgpID0+IEZvcm1Sb3dDb21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgc3VwZXIucmVnaXN0ZXJGb3JtQ29udHJvbCh0aGlzLnZhbHVlKTtcblxuICAgICAgICB0aGlzLmZvcm1Db250cm9sLnZhbHVlQ2hhbmdlcy5waXBlKFxuICAgICAgICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICAgICApLnN1YnNjcmliZSh2YWwgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMub25Nb2RlbENoYW5nZWQodGhpcy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSlcbiAgICB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSwge29ubHlTZWxmOiB0cnVlfSk7XG4gICAgICAgIH1cblxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7SW5wdXRUZXh0YXJlYU1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7VGV4dEFyZWFDb21wb25lbnR9IGZyb20gJy4vdGV4dC1hcmVhLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0YXJlYU1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZVxuICAgIF0sXG5cbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgVGV4dEFyZWFDb21wb25lbnQsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXVGV4dEFyZWFNb2R1bGVcbntcbn1cblxuXG4iLCJpbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFRlbXBsYXRlUmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBQYWdlLU5vdGlmaWNhdGlvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGEgbm90aWZpY2F0aW9uIHN5c3RlbSBmb3IgdGhlIHVzZXIgcmVnYXJkaW5nXG4gKiB0aGUgY3VycmVudCBvYmplY3QgaGUncyB3b3JraW5nIG9uLiBUeXBpY2FsIG5vdGlmaWNhdGlvbiBhcmU6XG4gKiAgICAgIFN1Y2Nlc3MgLSBzYXZlZC5cbiAqICAgICAgV2FybmluZyAtIFNvdXJjaW5nIHJlcXVlc3QgcmVxdWlyZXMgMyBzdXBwbGllcnMuXG4gKiAgICAgIEVycm9yICAgLSBjYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXIsIGNoZWNrIGludGVybmV0IGNvbm5lY3Rpb24uXG4gKlxuICpcbiAqXG4gKiBVc2FnZSAxOiAgQXMgcGFydCBvZiBwYWdlIHdyYXBwZXIuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdNeVBhZ2UnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8YXctb2JqZWN0LXBhZ2Utd3JhcHBlclxuICogICAgICAgICAgICAgICAgICAgICAgICBbdGl0bGVdPVwiTXlQYWdlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW29iamVjdFR5cGVdPVwiTXlUeXBlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJwYWdlTm90aWZpY2F0aW9uXCI+XG4gKiAgICAgICAgICAgICBwYWdlIGNvbnRlbnRcbiAqICAgICAgICAgIGBcbiAqICAgICAgIDwvYXctb2JqZWN0LXBhZ2VyLXdyYXBwZXI+XG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICpcbiAqICAgICAgICBwYWdlTm90aWZpY2F0aW9uOiBQYWdlTm90aWZpY2F0aW9uID0gbmV3IFBhZ2VOb3RpZmljYXRpb24oXCJ3YXJuXCIsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiUG9saWN5IFdhcm5pbmdcIiwgXCJUaGlzIHJlcXVlc3QgcmVxdWlyZXMgMyBiaWRzLlwiKTtcbiAqXG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICogICAgfVxuICpcbiAqIFVzYWdlIDI6IGRpcmVjdGx5IGludG8gdGhlIHBhZ2UuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgIDxcbiAqICAgICAgYXctaGVhZGVyPjwvYXctaGVhZGVyPlxuICogICAgICAgIFBhZ2UgSGVhZGVyXG4gKlxuICogICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJoYXNOb3RpZmljYXRpb25zKClcIj5cbiAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHUtbm9wYWRkaW5nXCI+XG4gKiAgICAgICAgICAgIDxhdy1wYWdlLW5vdGlmaWNhdGlvbiBbbm90aWZpY2F0aW9uXT1cIm5vdGlmaWNhdGlvblwiPjwvYXctcGFnZS1ub3RpZmljYXRpb24+XG4gKiAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICA8L25nLXRlbXBsYXRlPlxuICpcbiAqICAgICAgPGF3LWZvb3Rlcj48L2F3LWZvb3Rlcj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKlxuICogICAgICAgIG5vdGlmaWNhdGlvbjogUGFnZU5vdGlmaWNhdGlvbiA9IG5ldyBQYWdlTm90aWZpY2F0aW9uKFwid2FybmluZ1wiLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBvbGljeSBXYXJuaW5nXCIsIFwiVGhpcyByZXF1ZXN0IHJlcXVpcmVzIDMgYmlkcy5cIik7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1ub3RpZmljYXRpb24nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBhZ2Utbm90aWZpY2F0aW9uXCI+XG4gICAgPGRpdiBbY2xhc3NdPVwibm90aWZpY2F0aW9uQ2xhc3MoKVwiPlxuICAgICAgICA8aSBbY2xhc3NdPVwibm90aWZpY2F0aW9uSWNvbigpXCI+PC9pPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJ0aXRsZVwiPnt7bm90aWZpY2F0aW9uLnRpdGxlfX08L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZGVzY3JpcHRpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwibm90aWZpY2F0aW9uLmhhc1RlbXBsYXRlKCk7IGVsc2UgZGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRdPVwibm90aWZpY2F0aW9uLmNvbnRlbnRUbXBsXCI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjZGVzY3JpcHRpb24+e3tub3RpZmljYXRpb24uZGVzY3JpcHRpb259fTwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2Utbm90aWZpY2F0aW9ue21hcmdpbjowIDAgNXB4fS5ub3RpZmljYXRpb24tZXJyb3IsLm5vdGlmaWNhdGlvbi1pbmZvLC5ub3RpZmljYXRpb24tc3VjY2Vzcywubm90aWZpY2F0aW9uLXdhcm5pbmd7cGFkZGluZzo5cHggOHB4fS5ub3RpZmljYXRpb24tZXJyb3IgaSwubm90aWZpY2F0aW9uLWluZm8gaSwubm90aWZpY2F0aW9uLXN1Y2Nlc3MgaSwubm90aWZpY2F0aW9uLXdhcm5pbmcgaXtmb250LXNpemU6MjRweDttYXJnaW46MTBweH0ubm90aWZpY2F0aW9uLXN1Y2Nlc3MgaXtjb2xvcjojNThiOTU3fS5ub3RpZmljYXRpb24taW5mbyBpe2NvbG9yOiMxOTlkZTB9Lm5vdGlmaWNhdGlvbi13YXJuaW5nIGl7Y29sb3I6I2Y5MH0ubm90aWZpY2F0aW9uLWVycm9yIGl7Y29sb3I6I2MwMH0ubm90aWZpY2F0aW9uLXN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojZjFmOWYxO2JvcmRlcjoxcHggc29saWQgcmdiYSg4OCwxODUsODcsLjUpfS5ub3RpZmljYXRpb24taW5mb3tiYWNrZ3JvdW5kLWNvbG9yOiNlZGY4ZmQ7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDI1LDE1NywyMjQsLjUpfS5ub3RpZmljYXRpb24td2FybmluZ3tiYWNrZ3JvdW5kLWNvbG9yOiNmZmY4ZGQ7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDI1NSwxNTMsMCwuNSl9Lm5vdGlmaWNhdGlvbi1lcnJvcntiYWNrZ3JvdW5kLWNvbG9yOiNmZmViZWI7Ym9yZGVyOjFweCBzb2xpZCByZ2JhKDIwNCwwLDAsLjUpfS5pY29uLWVycm9yOmJlZm9yZXtjb250ZW50OlwiXFxcXEVBOURcIn0uaWNvbi13YXJuaW5nOmJlZm9yZXtjb250ZW50OlwiXFxcXEVBOUNcIn0uY29udGVudHt2ZXJ0aWNhbC1hbGlnbjpzdXBlcn0udGl0bGV7Zm9udC13ZWlnaHQ6NzAwO21hcmdpbi1yaWdodDoxMHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VOb3RpZmljYXRpb25Db21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBBbnkgaW5mbywgRXJyb3IsIG9yIFdhcm4gZm9yIHRoaXMgcGFnZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vdGlmaWNhdGlvbjogUGFnZU5vdGlmaWNhdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgbm90aWZpY2F0aW9uQ2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYG5vdGlmaWNhdGlvbi0ke3RoaXMubm90aWZpY2F0aW9uLnR5cGV9YDtcbiAgICB9XG5cbiAgICBub3RpZmljYXRpb25JY29uKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBhcmliYS1pY29uIGljb24tJHt0aGlzLm5vdGlmaWNhdGlvbi50eXBlfWA7XG4gICAgfVxuXG59XG5cbi8qKlxuICogUGFnZSBOb3RpZmljYXRpb24gYXJlIG1lc3NhZ2VzIGZvciB0aGlzIHBhZ2Ugb25seS4gSXQgZGlzcGxheXMgaW4gdGhlIGNlbnRlciBvZiB0aGUgcGFnZVxuICogcmlnaHQgdW5kZXIgcGFnZSB0aXRsZS4gVHlwaWNhbCBwYWdlIG5vdGlmaWNhdGlvbnMgYXJlICdzYXZlIGNvbmZpcm1hdGlvbicsXG4gKiAnZXJyb3IgZHVyaW5nIHN1Ym1pdCcsIHdhcm5pbmdzIG9mIGZpZWxkIHJlcXVpcmVtZW50cywgZXRjLlxuICovXG5leHBvcnQgY2xhc3MgUGFnZU5vdGlmaWNhdGlvblxue1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0eXBlOiBQYWdlTm90aWZpY2F0aW9uVHlwZSwgcHVibGljIHRpdGxlOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHVibGljIGRlc2NyaXB0aW9uOiBzdHJpbmcsIHB1YmxpYyBjb250ZW50VG1wbD86IFRlbXBsYXRlUmVmPGFueT4pXG4gICAge1xuICAgIH1cblxuICAgIGhhc1RlbXBsYXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5jb250ZW50VG1wbCk7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlICsgJywgdGl0bGU6ICcgKyB0aGlzLnRpdGxlICsgJywgZGVzY3JpcHRpb246ICAnICsgdGhpcy5kZXNjcmlwdGlvbjtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VOb3RpZmljYXRpb25UeXBlID0gJ3N1Y2Nlc3MnIHwgJ2luZm8nIHwgJ3dhcm5pbmcnIHwgJ2Vycm9yJztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7UGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9wYWdlLW5vdGlmaWNhdGlvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50XG5cbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUGFnZU5vdGlmaWNhdGlvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBQYWdlTm90aWZpY2F0aW9uQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGV2ZW50IHRyaWdnZXJlZCB3aGVuIGEgcGFnZSBoYXMgYmVlbiBpbml0aWFsaXplZC5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWdlSW5pdGlhbGl6ZWRcbntcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGl0bGU6IHN0cmluZylcbiAgICB7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYFBhZ2VJbml0aWFsaXppZWQodGl0bGU6ICR7dGhpcy50aXRsZX0pYDtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBldmVudCB0cmlnZ2VyZWQgd2hlbiBhIHBhZ2UgaGFzIGJlZW4gZGVzdHJveWVkLlxuICpcbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VEZXN0cm95ZWRcbntcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGl0bGU6IHN0cmluZylcbiAgICB7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYFBhZ2VEZXN0cm95ZWQodGl0bGU6ICR7dGhpcy50aXRsZX0pYDtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VFdmVudCA9IFBhZ2VJbml0aWFsaXplZCB8IFBhZ2VEZXN0cm95ZWQ7XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N1YmplY3R9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtQYWdlRGVzdHJveWVkLCBQYWdlRXZlbnQsIFBhZ2VJbml0aWFsaXplZH0gZnJvbSAnLi9wYWdlLWV2ZW50cyc7XG5cbi8qKlxuICogUGFnZSBMaWZlQ3ljbGUgU2VydmljZSBtb25pdG9ycyBhbGwgcGFnZSBpbml0aWFsaXphdGlvbiBhbmQgZGVzdHJ1Y3Rpb25zLlxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBzZXJ2aWNlIGlzIHRvIGhlbHAgdGhlIGFwcGxpY2F0aW9uIG1vbml0b3IgcGFnZSBsaWZlY3ljbGUsIHN1YnNjcmliZVxuICogdG8gbGlmZWN5Y2xlIGV2ZW50cyBhbmQgZXhlY3V0ZSBhY3Rpb25zIHN1Y2ggYXMgdXNlciBhbmFseXRpY3MuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogICAgMS4gIEluamVjdCBQYWdlTGlmZUN5Y2xlU2VydmljZSBpbnRvIHlvdXIgY29uc3RydWN0b3JcbiAqXG4gKiAgICBjb25zdHJ1Y3RvcihwYWdlTGlmZWN5Y2xlOlBhZ2VMaWZlQ3ljbGVTZXJ2aWNlKSB7XG4gKiAgICAgICAgcGFnZUxpZmVjeWNsZS5wYWdlRXZlbnRzLnN1YnNjcmliZShldmVudDpFdmVudCA9PiB7XG4gKiAgICAgICAgICAgIGlmKGV2ZW50IGluc3RhbmNlb2YgUGFnZUluaXRpYWxpemVkKSB7XG4gKiAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgLy8gUGFnZURlc3Ryb3llZFxuICpcbiAqICAgICAgICB9KTtcbiAqICAgICB9XG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQYWdlTGlmZUN5Y2xlU2VydmljZVxue1xuXG4gICAgLyoqXG4gICAgICogUGFnZSBldmVudCBxdWV1ZSB3aGVuIGFsbCBwYWdlIGxpZmVjeWNsZSBldmVudHM6IGluaXQsIGRlc3Ryb3kgYXJlIGVtaXR0ZWQuXG4gICAgICogTGlzdGVuZXJzIGNhbiBzdWJzY3JpYmUgdG8gdGhlc2UgZXZlbnRzLlxuICAgICAqL1xuICAgIHB1YmxpYyBwYWdlRXZlbnRzOiBTdWJqZWN0PFBhZ2VFdmVudD4gPSBuZXcgU3ViamVjdDxQYWdlRXZlbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKClcbiAgICB7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBwYWdlIGlzIGluaXRpYWxpemVkLlxuICAgICAqIEBwYXJhbSBwYWdlVGl0bGVcbiAgICAgKi9cbiAgICBwdWJsaWMgb25QYWdlSW5pdChwYWdlVGl0bGU6IHN0cmluZyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMucGFnZUV2ZW50cy5uZXh0KG5ldyBQYWdlSW5pdGlhbGl6ZWQocGFnZVRpdGxlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCB3aGVuIHBhZ2UgaGFzIGJlZW4gZGVzdHJveWVkXG4gICAgICogQHBhcmFtIHRpdGxlXG4gICAgICovXG4gICAgcHVibGljIG9uUGFnZURlc3Ryb3kocGFnZVRpdGxlOiBzdHJpbmcpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBhZ2VFdmVudHMubmV4dChuZXcgUGFnZURlc3Ryb3llZChwYWdlVGl0bGUpKTtcbiAgICB9XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0NvbXBvbmVudFJlZ2lzdHJ5fSBmcm9tICcuLi8uLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7UGFnZUxpZmVDeWNsZVNlcnZpY2V9IGZyb20gJy4vcGFnZS1saWZlY3ljbGUuc2VydmljZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCBwYWdlIHR5cGVzIGluIGFuIGFwcGxpY2F0aW9uLlxuICovXG5leHBvcnQgZW51bSBQYWdlVHlwZSB7XG4gICAgSW5pdCwgICAgICAgICAvLyBJbml0IFBhZ2UgdHlwZVxuICAgIExvZ2luLCAgICAgICAgLy8gTG9naW4gUGFnZVxuICAgIE9iamVjdCwgICAgICAgLy8gT2JqZWN0IGRldGFpbCBwYWdlXG4gICAgTGlzdCwgICAgICAgICAvLyBMaXN0IFBhZ2VcbiAgICBNYXN0ZXJEZXRhaWwsIC8vIE1hc3RlckRldGFpbFxuICAgIERhc2hib2FyZCwgICAgLy8gRGFzaGJvYXJkIHBhZ2VcbiAgICBNb2RhbCAgICAgICAgIC8vIE1vZGFsIHBhZ2UsIGl0IGNhbiBiZSBjb25maWd1cmVkIHRvIGJlIGEgcG9wdXAsIG9yIHN0YW5kYWxvbmUgcGFnZS5cbn1cblxuLyoqIFBsYWNlaG9sZGVyIG5vdy4gVGhlIEVycm9yIE1hbmFnZXIgaGFuZGxlcyBhbGwgdGhlIGVycm9ycyBvbiB0aGUgcGFnZS5cbiAqICBJdCBpcyBpbml0aWFsaXplZCBmb3IgZXZlcnkgcGFnZS4gUGFnZSBlcnJvcnMsIHdhcm5pbmcsIGluZm8gZ29lcyB0aHJvdWdoXG4gKiAgdGhlIGVycm9yIE1hbmFnZXIgYW5kIHRoZSByZXN1bHQgbWVzc2FnZSBpcyBkaXNwbGF5ZWQgb24gdGhlIHBhZ2Ugbm90aWZpY2F0aW9uIGFyZWEuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvck1hbmFnZXJcbntcblxufVxuXG4vKipcbiAqICBQYWdlIHdyYXBwZXIgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGFsbCBwYWdlcy4gVGhlIGlkZWEgaXMgdGhhdCB0aGVyZSBhcmUgZGlmZmVyZW50IHBhZ2UgdHlwZXNcbiAqICBpbiBhbiBBcHBsaWNhdGlvbi4gQSBMaXN0IFBhZ2UgcmVuZGVycyBhIGxpc3Qgb2Ygb2JqZWN0cywgZXg6IGN1c3RvbWVycywgcmVxdWVzdHMsIFBPLiAgQW5kXG4gKiAgYSBvYmplY3QgcGFnZSB3aWxsIHJlbmRlciBvbmUgb2JqZWN0IGluIGRldGFpbC5cbiAqXG4gKiAgVGhleSBzaGFyZSBjb21tb24gYXR0cmlidXRlcyBzdWNoIGFzIHBhZ2UgdHlwZSBhbmQgcGFnZSBpZC5cbiAqXG4gKiAgQXJpYmEgUGFnZSBoYXZlIGEgbGlmZSBjeWNsZS4gV2hlbiBwYWdlIHN0YXJ0cyB1cCwgaXQncyBpbml0aWFsaXplZC4gQW5kIHdoZW4gdGhlIHBhZ2UgaXNcbiAqICBkZXN0cm95ZWQsIGl0J2xsIGJlIGNvbXBsZXRlLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUGFnZVdyYXBwZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogV2hhdCB0eXBlIG9mIHBhZ2UgdGhpcyBpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwYWdlVHlwZTogUGFnZVR5cGUgPSBQYWdlVHlwZS5Jbml0O1xuXG4gICAgLyoqXG4gICAgICogUGFnZSBJZC4gVXNlZCB3aGVuIHBhZ2VzIGFyZSBzdG9yZWQgaW4gbWFwLlxuICAgICAqL1xuICAgIGlkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGluZyBhbGwgdGhlIGVycm9yIG9uIGEgcGFnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgZXJyb3JNYW5hZ2VyOiBFcnJvck1hbmFnZXI7XG5cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB0aGF0IHRoaXMgcGFnZSB3cmFwcGVyIGhhcyBiZWVuIHdyYXBwZWQgYnkgYW5vdGhlciBwYWdlIHdyYXBwZXIuXG4gICAgICogSW4gdGhpcyBjYXNlLCB3ZSB3b3VsZG4ndCBkaXNwbGF5IGhlYWRlciBhbmQgZm9vdGVyIGFuZCBvdGhlciBwYWdlIHdyYXBwZXIgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGFscmVhZHlJblBhZ2VXcmFwcGVyOiBib29sZWFuO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcGFnZVR5cGU6IFBhZ2VUeXBlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBjb21wb25lbnRSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnksXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhZ2VMaWZlY3ljbGVTZXJ2aWNlOiBQYWdlTGlmZUN5Y2xlU2VydmljZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgICAgIHRoaXMucGFnZVR5cGUgPSBwYWdlVHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGwgc3ViY2xhc3MgbmVlZHMgdG8gZ2VuZXJhdGVkIGEgcGFnZSBpZGVudGlmaWVyLlxuICAgICAqIEl0IGZvbGxvd3MgdGhlIGZvbGxvd2luZyBwYXR0ZXJuOlxuICAgICAqICAgIHR5cGVfdGl0bGVfaWRcbiAgICAgKlxuICAgICAqICAgIFJGUV9Tb3VyY2luZ1JlcXVlc3RfMTIzXG4gICAgICovXG4gICAgYWJzdHJhY3QgZ2VuZXJhdGVQYWdlSWQoKTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB1bmlxdWUgSWQgZm9yIHRoaXMgcGFnZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRJZCgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmdlbmVyYXRlUGFnZUlkKCk7XG4gICAgfVxuXG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFZpZXdDaGlsZH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnQsIFJvdXRpbmdTZXJ2aWNlfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7U2lkZW5hdkNvbXBvbmVudH0gZnJvbSAnLi4vc2lkZW5hdi9zaWRlbmF2LmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqXG4gKiBIZWFkZXIgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBjb25zaXN0ZW50IHN0eWxpbmcsIGJlaGF2aW9yIGZvciBhbiBBcmliYSBwYWdlLlxuICogSGVhZGVyIGluY2x1ZGVzIGEgbWVudSwgdXNlciBwcm9maWxlLCBhbmQgYWxlcnRzLlxuICpcbiAqICBAQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAncmVnaXN0cmF0aW9uJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgPGF3LXBhZ2UtaGVhZGVyIFtzaG93QmFja0FjdGlvbl09XCJ0cnVlXCIgdXNlck5hbWU9XCJDaGFkIE5vbGxcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbWVudUl0ZW1zXT1cIm1lbnVJdGVtc1wiIFtub3RpZmljYXRpb25zXT1cInVzZXJOb3RpZmljYXRpb25zXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1jZW50ZXJcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3M9XCJuYXZiYXItYnJhbmRcIiB0YWJpbmRleD1cIjBcIiBocmVmPVwiL1wiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBjbGFzcz1cIm5hdmJhci1sb2dvXCIgc3JjPVwiLi9pbWFnZXMvU0FQX0FyaWJhX0RCLnBuZ1wiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiR28gdG8gaG9tZXBhZ2VcIiBkYXRhLXBpbi1ub3Bpbj1cInRydWVcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICA8L2E+XG4gKiAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICogICAgICAgICAgICAgICAgPC9hdy1wYWdlLWhlYWRlcj5cbiAqXG4gKiAgICBgXG4gKiAgICB9KVxuICogICAgZXhwb3J0IGNsYXNzIE15UGFnZVxuICogICAge1xuICogICAgICBtZW51SXRlbXM6IFBhZ2VNZW51SXRlbVtdID0gW25ldyBQYWdlTWVudUl0ZW0oJ2ljb24taG9tZScsICdIb21lJywgJy9wbGF5LycpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1leHBlbnNlLXJlcG9ydCcsICdSZXBvcnRzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvcGFnZWhlYWRlcicpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1zYWxlcy1vcmRlcicsICdQdXJjaGFzZSBPcmRlcicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvcGFnZWhlYWRlcicpLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFBhZ2VNZW51SXRlbSgnaWNvbi1hY2NvdW50JywgJ0FjY291bnRzJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvcGFnZWhlYWRlcicpXTtcbiAqXG4gKiAgICAgdXNlck5vdGlmaWNhdGlvbnM6IFVzZXJOb3RpZmljYXRpb25bXSA9IFtcbiAqICAgICAgIG5ldyBVc2VyTm90aWZpY2F0aW9uKCdpY29uLWV4cGVuc2UtcmVwb3J0JywgJ0V4cGVuc2UgcmVwb3J0IEVYUDQ1MyBoYXMgYmVlbiBhcHByb3ZlZC4nLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICcvcGxheS8nKSxcbiAqICAgICAgICAgbmV3IFVzZXJOb3RpZmljYXRpb24oJ2ljb24tc2FsZXMtb3JkZXInLCAnU2FsZXMgT3JkZXIgU08xMjM0IGhhcyBiZWVuIGNyZWF0ZWQuJyxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvJyksXG4gKiAgICAgICAgICAgbmV3IFVzZXJOb3RpZmljYXRpb24oJ2ljb24tYWNjb3VudCcsICdTdXBwbGllciBhY2NvdW50IFNBMTIzNCBoYXMgYmVlbiB1cGRhdGVkLicsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnL3BsYXkvJylcbiAqICAgICAgICBdO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXBhZ2UtaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxuYXYgY2xhc3M9XCJuYXZiYXIgcGFnZS1oZWFkZXJcIiByb2xlPVwibmF2aWdhdGlvblwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtNCBuYXZiYXItbGVmdFwiPlxuXG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzTWVudUl0ZW1zKClcIj5cbiAgICAgICAgICAgIDxhIChjbGljayk9XCJzaG93SGlkZU1lbnUoKVwiPlxuICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwic2FwLWljb24gaWNvbi1wYWdpbmdcIj48L2k+XG4gICAgICAgICAgICA8L2E+XG5cbiAgICAgICAgICAgIDwhLS0gU2lkZSBtZW51IC0tPlxuICAgICAgICAgICAgPGF3LXNpZGVuYXYgI3NpZGVtZW51IFtpdGVtc109XCJtZW51SXRlbXNcIj48L2F3LXNpZGVuYXY+XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwhLS0gRW5kIEhhbWJ1cmdlciBtZW51LiAtLT5cblxuICAgICAgICAgICAgPCEtLSAgYmFjayBhY3Rpb24gLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImJhY2stYWN0aW9uXCI+XG4gICAgICAgICAgICA8YSAoY2xpY2spPVwiYmFja0FjdGlvbigpXCI+XG4gICAgICAgICAgICAgICAgPGkgKm5nSWY9XCJzaG93QmFja0FjdGlvblwiIGNsYXNzPVwic2FwLWljb24gaWNvbi1hcnJvdy1sZWZ0XCIgcm9sZT1cImJ1dHRvblwiPjwvaT5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHVpLW1kLTQgbmF2YmFyLWNlbnRlclwiPlxuXG4gICAgICAgICAgICA8IS0tIGNlbnRyYWwgc2VjdGlvbi4gIEFwcGxpY2F0aW9uIGNhbiBhZGQgQXJpYmEtbG9nbywgc2VhcmNoIGJveCwgZXRjIC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2UtaGVhZGVyLWNlbnRlclwiPjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdWktbWQtNCBuYXZiYXItcmlnaHRcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJ1c2VyTmFtZVwiPlxuICAgICAgICAgICAgPGltZyBpZD1cInVzZXJQcm9maWxlUGljdHVyZVwiIGNsYXNzPVwicHJvZmlsZS1sb2dvXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCJcbiAgICAgICAgICAgICAgICAgW3RpdGxlXT1cInVzZXJOYW1lXCIgc3JjPVwie3thc3NldEZvbGRlcn19L2ltYWdlcy9kZWZhdWx0X2ltYWdlX3NtYWxsLnBuZ1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwcm9maWxlLXVzZXJcIiB0aXRsZT1cInt7dXNlck5hbWV9fVwiPnt7dXNlck5hbWV9fTwvc3Bhbj5cbiAgICAgICAgPC9zcGFuPlxuXG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFoaWRlTm90aWZpY2F0aW9uXCIgY2xhc3M9XCJub3RpZmljYXRpb24tY29udGFpbmVyXCI+XG5cbiAgICAgICAgICAgIDxpICNub3RpZmljYXRpb25JY29uIGNsYXNzPVwiYXJpYmEtaWNvbiBpY29uLW5vdGlmaWNhdGlvblwiXG4gICAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlTm90aWZpY2F0aW9uUGFuZWwoKVwiPjwvaT5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiaGFzTm90aWZpY2F0aW9ucygpXCIgY2xhc3M9XCJub3RpZmljYXRpb24tYmFkZ2VcIiBhcmlhLWhpZGRlbj1cInRydWVcIj57e25vdGlmaWNhdGlvbnMubGVuZ3RofX08L3NwYW4+XG5cbiAgICAgICAgICAgICAgICA8IS0tIE9yaWdpbmFsbHkgSSB3YXMgdXNpbmcgcC1vdmVybGF5LXBhbmVsLCBob3dldmVyLCBpdCBkb2Vzbid0IHBvc2l0aW9uIGNvcnJlY3RseSB1bmRlciB0aGUgbm90aWZpY2F0aW9uIGljb24uXG4gICAgICAgICAgICAgICAgICAgICBUaGUgcG9zaXRpb25pbmcgbG9naWMgaW4gcHJpbWUgbmcgbmVlZHMgc29tZSBtb3JlIGludmVzdGlnYXRpb24uIFNvIGZvciBub3csIHVzZSBhIGRpdiBpbnN0ZWFkLS0+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd05vdGlmaWNhdGlvblBhbmVsXCIgY2xhc3M9XCJub3RpZmljYXRpb24tcGFuZWxcIj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJub3RpZmljYXRpb24taGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICBOb3RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJub3RpZmljYXRpb24tY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICA8bGkgKm5nRm9yPVwibGV0IG5vdGkgb2Ygbm90aWZpY2F0aW9uc1wiIGNsYXNzPVwibm90aWZpY2F0aW9uLWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhIFtyb3V0ZXJMaW5rXT1cIm5vdGkubGlua1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibm90aWZpY2F0aW9uLWl0ZW0taWNvblwiPjxpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ0NsYXNzXT1cIidzYXAtaWNvbiAnICsgbm90aS5pY29uXCI+PC9pPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7e25vdGkubGFiZWx9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cblxuXG4gICAgPC9kaXY+XG48L25hdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5wYWdlLWhlYWRlciBpe2ZvbnQtc2l6ZTozMnB4fS5wYWdlLWhlYWRlciAuaWNvbi1wYWdpbmd7Zm9udC1zaXplOjMwcHg7cG9zaXRpb246cmVsYXRpdmU7dG9wOjJweH0uYmFjay1hY3Rpb257ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6MTVweH0uYmFjay1hY3Rpb24gaXtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6M3B4fS5uYXZiYXJ7YmFja2dyb3VuZDojMDAwO2NvbG9yOiNmZmZ9Lm5hdmJhci1sZWZ0e3BhZGRpbmctbGVmdDoxNXB4O2hlaWdodDo1MHB4fS5uYXZiYXItY2VudGVye3RleHQtYWxpZ246Y2VudGVyO2hlaWdodDo1MHB4fS5uYXZiYXItcmlnaHR7dGV4dC1hbGlnbjpyaWdodDtoZWlnaHQ6NTBweH0ucHJvZmlsZS1sb2dve3dpZHRoOjMwcHg7aGVpZ2h0OjMwcHg7cG9zaXRpb246cmVsYXRpdmU7dG9wOjJweH0ucHJvZmlsZS11c2Vye3ZlcnRpY2FsLWFsaWduOnN1cGVyO21hcmdpbi1yaWdodDozMHB4fS5pY29uLW5vdGlmaWNhdGlvbjpiZWZvcmV7Y29udGVudDpcIlxcXFxlQTE0XCJ9Lm5hdmJhciAjc2lkZWJhci1tZW51LWljb257cG9zaXRpb246cmVsYXRpdmU7dG9wOi41ZW19Lm5vdGlmaWNhdGlvbi1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLXJpZ2h0OjIwcHg7ZGlzcGxheTppbmxpbmUtYmxvY2t9Lm5vdGlmaWNhdGlvbi1iYWRnZXtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOjJweCA1cHg7Zm9udC1zaXplOjEycHg7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojYzAwO2JvcmRlci1yYWRpdXM6MTBweDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjE2cHh9Lm5vdGlmaWNhdGlvbi1wYW5lbHtwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDotMjdweDt0b3A6NDVweDt3aWR0aDozNTBweDtjb2xvcjojNzY3Njc2O2JveC1zaGFkb3c6MCAycHggMTBweCAwIHJnYmEoMCwwLDAsLjEzKTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7b3ZlcmZsb3c6aGlkZGVuO3RyYW5zaXRpb246YWxsIC4zcyBlYXNlLWluLW91dH0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taGVhZGVye2JhY2tncm91bmQtY29sb3I6I2YzZjNmMztmb250LXNpemU6MTZweDtoZWlnaHQ6NTBweDtsaW5lLWhlaWdodDo1MHB4O3RleHQtYWxpZ246Y2VudGVyfS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1jb250ZW50e3BhZGRpbmc6MDttYXJnaW46MH0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taXRlbXtoZWlnaHQ6NTBweDtib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3O3BhZGRpbmc6MTVweCAxMHB4O3doaXRlLXNwYWNlOm5vd3JhcDt0ZXh0LW92ZXJmbG93OmVsbGlwc2lzfS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1pdGVtIGF7Y29sb3I6Izc2NzY3Njt0ZXh0LWRlY29yYXRpb246bm9uZTtsaW5lLWhlaWdodDozNXB4fS5ub3RpZmljYXRpb24tcGFuZWwgLm5vdGlmaWNhdGlvbi1pdGVtOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2Y3ZjhmYX0ubm90aWZpY2F0aW9uLXBhbmVsIC5ub3RpZmljYXRpb24taXRlbS1pY29ue21hcmdpbi1yaWdodDoxNXB4O2NvbG9yOiM3Njc2NzY7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLXRvcDoxMHB4O3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgLyoqXG4gICAgICogbGlzdCBvZiBtZW51IGVudHJpZXMuIFRoZSBwYWdlIG1lbnUgaWNvbiB3aWxsIG9ubHkgZGlzcGxheSB3aGVuIHRoaXMgbGlzdCBpcyBub3QgZW1wdHkuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBtZW51SXRlbXM6IFBhZ2VNZW51SXRlbVtdO1xuXG4gICAgLyoqXG4gICAgICogbGlzdCBvZiB1c2VyIG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbm90aWZpY2F0aW9uczogVXNlck5vdGlmaWNhdGlvbltdO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSB1c2VyIG5vdGlmaWNhdGlvbiBpY29uIGJlIGhpZGRlbi4gRGVmYXVsdCBpdCB0byBzaG93IHRoZSBpY29uIGV2ZW5cbiAgICAgKiBpZiB0aGVyZSdzIG5vIG5vdGlmaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGVOb3RpZmljYXRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBiYWNrIGxpbmsgdGhhdCBuYXZpZ2F0ZXMgdXNlciB0byB0aGUgcHJldmlvdXMgcGFnZSB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93QmFja0FjdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsb2dnZWQgaW4gdXNlciBuYW1lLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdXNlck5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWRlbWVudVxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3NpZGVtZW51JylcbiAgICBzaWRlbmF2OiBTaWRlbmF2Q29tcG9uZW50O1xuXG4gICAgc2hvd05vdGlmaWNhdGlvblBhbmVsOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHJvdXRpbmc6IFJvdXRpbmdTZXJ2aWNlKVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgIH1cblxuICAgIGJhY2tBY3Rpb24oKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5yb3V0aW5nLmdvQmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERvIGkgaGF2ZSBhbnkgbWVudSBpdGVtcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc01lbnVJdGVtcygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMubWVudUl0ZW1zICYmIHRoaXMubWVudUl0ZW1zLmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgc2lkZSBuYXZpZ2F0aW9uIG1lbnUuXG4gICAgICovXG4gICAgc2hvd0hpZGVNZW51KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuc2lkZW5hdi50b2dnbGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBJIGhhdmUgYW55IG5vdGlmaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNOb3RpZmljYXRpb25zKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5ub3RpZmljYXRpb25zKSAmJiB0aGlzLm5vdGlmaWNhdGlvbnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGluZyB3aGVhdGhlciBub3RpZmljYXRpb24gcGFuZWwgaXMgZGlzcGxheWVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICB0b2dnbGVOb3RpZmljYXRpb25QYW5lbCgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb25QYW5lbCA9ICF0aGlzLnNob3dOb3RpZmljYXRpb25QYW5lbDtcbiAgICB9XG59XG5cbi8qKlxuICogUGFnZU1lbnVJdGVtIHJlcHJlc2VudHMgYW4gaXRlbSBpbiB0aGUgcGFnZSBtZW51IHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VNZW51SXRlbVxue1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpY29uICAgIC0gSWNvbiBvZiB0aGlzIG1lbnUgaXRlbS5cbiAgICAgKiBAcGFyYW0gbGFiZWwgICAtIGxhYmVsIG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAcGFyYW0gbGluayAgICAtIGxpbmsgdG8gdGhlIGRlc3RpbmF0aW9uIHdoZW4gdXNlciBjbGlja3Mgb24gaXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHVibGljIGljb246IHN0cmluZywgcHVibGljIGxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgcHVibGljIGxpbms6IHN0cmluZylcbiAgICB7XG4gICAgfVxuXG4gICAgdG9TdHJpbmcoKTogc3RyaW5nXG4gICAge1xuICAgICAgICByZXR1cm4gYFBhZ2VNZW51SXRlbTogKGxhYmVsLCAke3RoaXMubGFiZWx9KWA7XG4gICAgfVxufVxuXG4vKipcbiAqIG5vdGlmaWNhdGlvbiBmb3IgdGhlIGN1cnJlbnQgbG9nZ2VkIGluIHVzZXIuXG4gKiBFeDogIFBSMjA0OSBoYXMgYmVlbiBhcHByb3ZlZC5cbiAqICAgICAgT3JkZXIgUE81MTggcmVjZWl2ZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBVc2VyTm90aWZpY2F0aW9uXG57XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWNvbiAgIC0gYWxlcnQgbm90aWZpY2F0aW9uIGljb25cbiAgICAgKiBAcGFyYW0gbGFiZWwgIC0gYWxlcnQgbm90aWZpY2F0aW9uIGxhYmVsXG4gICAgICogQHBhcmFtIGxpbmsgICAtIGxpbmtcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgaWNvbjogc3RyaW5nLCBwdWJsaWMgbGFiZWw6IHN0cmluZyxcbiAgICAgICAgICAgICAgICBwdWJsaWMgbGluazogc3RyaW5nKVxuICAgIHtcblxuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIGBQYWdlVXNlck5vdGlmaWNhdGlvbjogKGxhYmVsLCAke3RoaXMubGFiZWx9KWA7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIEZvb3RlciBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGNvbnNpc3RlbnQgc3R5bGluZywgYmVoYXZpb3IuXG4gKiBUaGlzIGZvb3RlciBjb21wb25lbnQgc2VsZiBjb250YWluZWQuXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZWdpc3RyYXRpb24nICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgICAgPGF3LXBhZ2UtZm9vdGVyPlxuICogICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1mb290ZXItbG9nb1wiPlxuICogICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCJpbWFnZXMvYXJpYmFfbG9nb193aGl0ZV9ia2dkLnBuZ1wiPlxuICogICAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtZm9vdGVyLXVzZXItaW5mb1wiPlxuICogICAgICAgICAgICAgICAgICAgQ2hhZCBOb2xsIChjbm9sbCkgbGFzdCB2aXNpdCB7e2xhc3RfdmlzaXRlZCB8IGRhdGU6J01NL2RkL3l5eXkgaDptbWEnIH19XG4gICogICAgICAgICAgICAgICAgICAgfCBCdXllciBPcmdhbml6YXRpb25cbiAqICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicGFnZS1mb290ZXItY29weXJpZ2h0XCIgI2NvcHlyaWdodD5cbiAqICAgICAgICAgICAgICAgICAgIDxwPsOCwqkgMjAyMMOiwoDCkzIwMjggVGhlIEZ1dHVyZSwgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkPC9wPlxuICogICAgICAgICAgICAgICA8L3NwYW4+XG4gKiAgICAgICAgICAgPC9hdy1wYWdlLWZvb3Rlcj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKiAgICAgICAgY29uc3RydWN0b3IgKClcbiAqICAgICAgICB7XG4gKiAgICAgICAgfVxuICpcbiAqICAgIH1cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWZvb3RlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicGFnZS1mb290ZXJcIj5cbiAgICA8ZGl2IGNsYXNzPVwidWktZ1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC04XCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLWZvb3Rlci1sb2dvXCI+PC9uZy1jb250ZW50PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXNlci1pbmZvXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiLnBhZ2UtZm9vdGVyLXVzZXItaW5mb1wiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8dWwgY2xhc3M9XCJmb290ZXItbGlua3NcIj5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYV90b3UuY2ZtXCI+VGVybXMgb2ZcbiAgICAgICAgICAgICAgICAgICAgVXNlPC9hPjwvbGk+XG4gICAgICAgICAgICAgICAgPGxpIHJvbGU9XCJwcmVzZW50YXRpb25cIj48YVxuICAgICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cDovL3d3dy5hcmliYS5jb20vbGVnYWwvYXJpYmFfc2VjdXJpdHlfcG9saWN5LmNmbVwiPlNlY3VyaXR5XG4gICAgICAgICAgICAgICAgICAgIERpc2Nsb3N1cmU8L2E+PC9saT5cbiAgICAgICAgICAgICAgICA8bGkgcm9sZT1cInByZXNlbnRhdGlvblwiPjxhXG4gICAgICAgICAgICAgICAgICAgIGhyZWY9XCJodHRwOi8vd3d3LmFyaWJhLmNvbS9sZWdhbC9hcmliYV9wcml2YWN5X3N0YXRlbWVudC5jZm1cIj5Qcml2YWN5XG4gICAgICAgICAgICAgICAgICAgIFN0YXRlbWVudDwvYT48L2xpPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhLXByaXZhY3ktc3RhdGVtZW50XCI+Q29va2llIFN0YXRlbWVudDwvYT5cbiAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgIDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCI+PGFcbiAgICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHA6Ly93d3cuYXJpYmEuY29tL2xlZ2FsL2FyaWJhLXByaXZhY3ktc3RhdGVtZW50XCI+UGFydGljaXBhbnRcbiAgICAgICAgICAgICAgICAgICAgU3RhdGVtZW50PC9hPjwvbGk+XG4gICAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiB1aS1tZC00XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidS1ib3R0b20tYWxpZ25cIj48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1LWhyaWdodCBjb3B5cmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1mb290ZXItY29weXJpZ2h0XCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gRGVmYXVsdCBDb3B5cmlnaHQgLS0+XG4gICAgICAgICAgICA8ZGl2ICpuZ0lmPVwic2hvd0RlZmF1bHRDb3B5cmlnaHRcIiBjbGFzcz1cInUtaHJpZ2h0IGNvcHlyaWdodFwiPlxuICAgICAgICAgICAgICAgIDxwPsOCwqkgMTk5NsOiwoDCkzIwMTcgQXJpYmEsIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZDwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS1mb290ZXJ7YmFja2dyb3VuZDojZmZmO3BhZGRpbmc6MTVweCAwIDA7Zm9udC1zaXplOjExcHg7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkN30ucGFnZS1mb290ZXIgLnVzZXItaW5mb3tjb2xvcjojY2NjfS5wYWdlLWZvb3RlciAudWktZ3ttYXJnaW46MCBhdXRvfS5wYWdlLWZvb3RlciAuY29weXJpZ2h0e2NvbG9yOiNjY2N9LmZvb3Rlci1saW5rc3tsaXN0LXN0eWxlOm5vbmU7bWFyZ2luOjAgLTE1cHg7cGFkZGluZzowO2ZvbnQtc2l6ZToxMHB4fS5mb290ZXItbGlua3MgbGl7ZmxvYXQ6bGVmdH0uZm9vdGVyLWxpbmtzOmFmdGVyLC5mb290ZXItbGlua3M6YmVmb3Jle2NvbnRlbnQ6XCIgXCI7ZGlzcGxheTp0YWJsZX0uZm9vdGVyLWxpbmtzOmFmdGVye2NsZWFyOmJvdGh9LmZvb3Rlci1saW5rcz5saSwuZm9vdGVyLWxpbmtzPmxpPmF7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9ja30uZm9vdGVyLWxpbmtzPmxpPmF7cGFkZGluZzoxMHB4IDE1cHg7Y29sb3I6IzE5OWRlMH1gXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlRm9vdGVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXRcbntcblxuICAgIC8qKlxuICAgICAqIGNvcHlyaWdodCBjb250ZW50XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnY29weXJpZ2h0JykgY29weXJpZ2h0OiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBzaG93IGRlZmF1bHQgY29weXJpZ2h0LiBJZiBjb3B5cmlnaHQgaXMgcGFzc2VkIGluLCB0aGVuIHNob3cgdGhlIHBhc3NlZCBpbiBvbmUuXG4gICAgICovXG4gICAgc2hvd0RlZmF1bHRDb3B5cmlnaHQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuc2hvd0RlZmF1bHRDb3B5cmlnaHQgPSAhaXNQcmVzZW50KHRoaXMuY29weXJpZ2h0KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7Q29tcG9uZW50UmVnaXN0cnl9IGZyb20gJy4uLy4uLy4uL2NvcmUvY29tcG9uZW50LXJlZ2lzdHJ5LnNlcnZpY2UnO1xuaW1wb3J0IHtQYWdlVHlwZSwgUGFnZVdyYXBwZXJ9IGZyb20gJy4uL3BhZ2Utd3JhcHBlcic7XG5pbXBvcnQge1BhZ2VOb3RpZmljYXRpb259IGZyb20gJy4uLy4uL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuLi9wYWdlLWxpZmVjeWNsZS5zZXJ2aWNlJztcbmltcG9ydCB7UGFnZUhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUZvb3RlckNvbXBvbmVudH0gZnJvbSAnLi4vcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKlxuICogT2JqZWN0IFBhZ2UgV3JhcHBlciBDb21wb25lbnQgcmVuZGVycyBhbnkgb2JqZWN0IGluc3RhbmNlIGluIGRldGFpbC4gSXQgaGFzIGEgdW5pZm9ybSBsYXlvdXQsXG4gKiBIZWFkZXIsIFBhZ2UgdGl0bGUsIFBhZ2Ugbm90aWZpY2F0aW9uLCBhY3Rpb25zLCBjb250ZW50LCBhbmQgRm9vdGVyLlxuICpcbiAqXG4gKiAgVXNhZ2U6XG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdSRlhQYWdlJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgPGF3LW9iamVjdC1wYWdlLXdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3RpdGxlXT1cInJmeEVudGl0eS5oZWFkZXJJbmZvLnRpdGxlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW29iamVjdFR5cGVdPVwicmZ4RW50aXR5LmhlYWRlckluZm8uZXZlbnRUeXBlU3RyaW5nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW25vdGlmaWNhdGlvbl09XCJwYWdlTm90aWZpY2F0aW9uXCI+XG4gKlxuICpcbiAqICAgICAgICAgICA8YXctcGFnZS1hY3Rpb25zPlxuICogICAgICAgICAgICAgICA8YXctYnV0dG9uIFt0eXBlXT1cIidzdWJtaXQnXCIgW25hbWVdPVwiJ2VkaXQnXCIgW3ZhbHVlXT1cImVkaXRcIiBbc3R5bGVdPVwiJ3ByaW1hcnknXCI+XG4gKiAgICAgICAgICAgICAgICAgICBFZGl0XG4gKiAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbdHlwZV09XCInYnV0dG9uJ1wiIFtuYW1lXT1cIidjYW5jZWwnXCIgW3ZhbHVlXT1cImNhbmNlbFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiPlxuICogICAgICAgICAgICAgICAgICBDYW5jZWxcbiAqICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gKiAgICAgICAgICAgPC9hdy1wYWdlLWFjdGlvbnM+XG4gKlxuICogICAgICAgICAgIDxhdy1wYWdlLWNvbnRlbnQ+XG4gKiAgICAgICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlNvdXJjaW5nIHJlcXVlc3QgaW5mb1wiIChvblN0YXRlQ2hhbmdlZCk9XCJvblN0YXRlQ2hhbmdlKCRldmVudClcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICA8bS1jb250ZXh0IFtvYmplY3RdPVwicmZ4RW50aXR5LmhlYWRlckluZm9cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbb3BlcmF0aW9uXT1cInRoaXMuZWRpdGFiaWxpdHlTdGF0ZS5oZWFkZXJJbmZvT3BcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ9XCJJbnNwZWN0XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlHcm91cD1cIkhlYWRlckdlbmVyYWxcIlxuICogICAgICAgICAgICAgICAgICAgPlxuICogICAgICAgICAgICAgICAgICAgICAgIDxtLWluY2x1ZGUtY29tcG9uZW50PjwvbS1pbmNsdWRlLWNvbXBvbmVudD5cbiAqICAgICAgICAgICAgICAgICAgIDwvbS1jb250ZXh0PlxuICpcbiAqICAgICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqICAgICAgICAgICA8L2F3LXBhZ2UtY29udGVudD5cbiAqICAgICAgIDwvYXctb2JqZWN0LXBhZ2Utd3JhcHBlcj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgUkZYUGFnZVxuICogICAge1xuICogICAgICAgLy8gVG8ga2VlcCB0cmFjayB3aGF0IHNlY3Rpb24gaXMgZWRpdGFibGUgYW5kIHdoaWNoIHJlYWQgb25seVxuICogICAgICAgZWRpdGFiaWxpdHlTdGF0ZTogRWRpdGFiaWxpdHlTdGF0ZTtcbiAqXG4gKiAgICAgICAvLyBDdXJyZW50IFJGWCBldmVudFxuICogICAgICAgcmZ4RW50aXR5OiBSZnhFdmVudEVudGl0eTtcbiAqXG4gKiAgICAgICAvLyBOb3RpZmljYXRpb25zXG4gKiAgICAgICBub3RpZmljYXRpb246IFBhZ2VOb3RpZmljYXRpb24gPSBuZXcgUGFnZU5vdGlmaWNhdGlvbihcIndhcm5cIixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJQb2xpY3kgV2FybmluZ1wiLCBcIlRoaXMgcmVxdWVzdCByZXF1aXJlcyAzIGJpZHMuXCIpO1xuICpcbiAqICAgICAgICBjb25zdHJ1Y3RvciAoKVxuICogICAgICAgIHtcbiAqICAgICAgICB9XG4gKlxuICogICAgfVxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LW9iamVjdC1wYWdlLXdyYXBwZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBhZ2Utd3JhcHBlclwiPlxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaGlkZUhlYWRlclwiPlxuICAgICAgICA8YXctaW5jbHVkZS1jb21wb25lbnQgW25hbWVdPSdoZWFkZXIubmFtZSc+PC9hdy1pbmNsdWRlLWNvbXBvbmVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPGRpdiBjbGFzcz1cImFyYy1vYmplY3QtZGV0YWlsXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInVpLWdcIj5cblxuICAgICAgICAgICAgPCEtLSBwYWdlIGhlYWRlciAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2UtdGl0bGVcIj5cblxuICAgICAgICAgICAgICAgIDwhLS0gcGFnZSB0aXRsZSAtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy04IHVpLW1kLTggcGFnZS10aXRsZS10ZXh0XCI+e3t0aXRsZX19PC9kaXY+XG5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy00IHVpLW1kLTQgcGFnZS1zdGF0dXNcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvYmplY3Qtc3RhdHVzLWxhYmVsXCI+e3tvYmplY3RTdGF0dXNMYWJlbH19ICZuYnNwOzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJvYmplY3Qtc3RhdHVzXCI+e3tvYmplY3RTdGF0dXN9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIHBhZ2UgYWN0aW9ucyAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2UtYWN0aW9uc1wiICpuZ0lmPVwiaGFzVG9wUGFnZUFjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJhY3Rpb25zVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqbmdJZj1cImhhc1RvcFBhZ2VBY3Rpb25zXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8IS0tIG9iamVjdCBzdGF0ZXMgIGRpc3BsYXlzIG9ubHkgaWYgc3RhdGUgZXhpc3RzLiAtLT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTEyIHBhZ2Utc3RhdGVcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidWktZy0zIHBhZ2Utc3RhdGUtbGVmdFwiIFtjbGFzcy5jb250ZW50XT1cImhhc09iamVjdFN0YXRlcygpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIi5wYWdlLXN0YXRlLWxlZnRcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctNiBwYWdlLXN0YXRlLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaGFzT2JqZWN0U3RhdGVzKClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1zdGVwcGVyIFtzdGVwc109XCJvYmplY3RTdGF0ZXNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRTdGVwXT1cIm9iamVjdFN0YXRlSW5kZXhcIj48L2F3LXN0ZXBwZXI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1aS1nLTMgcGFnZS1zdGF0ZS1yaWdodFwiPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCIucGFnZS1zdGF0ZS1yaWdodFwiPjwvbmctY29udGVudD5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG5cbiAgICAgICAgICAgIDwhLS0gUGFnZSBOb3RpZmljYXRpb24gLS0+XG4gICAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaGFzTm90aWZpY2F0aW9ucygpXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInVpLWctMTIgdS1ub3BhZGRpbmdcIj5cblxuICAgICAgICAgICAgICAgICAgICA8YXctcGFnZS1ub3RpZmljYXRpb24gKm5nRm9yPVwibGV0IG5vdGlmaWNhdGlvbiBvZiBub3RpZmljYXRpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtub3RpZmljYXRpb25dPVwibm90aWZpY2F0aW9uXCI+PC9hdy1wYWdlLW5vdGlmaWNhdGlvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwhLS0gYWRkaXRpb25hbCBjb250ZW50IC0tPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctcGFnZS1jb250ZW50XCI+PC9uZy1jb250ZW50PlxuXG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIHBhZ2UgYWN0aW9ucyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidWktZy0xMiBwYWdlLWFjdGlvbnMtYm90dG9tXCIgKm5nSWY9XCJoYXNCb3R0b21QYWdlQWN0aW9uc1wiPlxuICAgICAgICA8bmctdGVtcGxhdGUgW2VtYmVkZGVkSXRlbV09XCJhY3Rpb25zVGVtcGxhdGVcIlxuICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJoYXNCb3R0b21QYWdlQWN0aW9uc1wiPjwvbmctdGVtcGxhdGU+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJwYWdlLXB1c2hcIj48L2Rpdj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWhpZGVGb290ZXJcIj5cbiAgICA8YXctaW5jbHVkZS1jb21wb25lbnQgW25hbWVdPSdmb290ZXIubmFtZSc+PC9hdy1pbmNsdWRlLWNvbXBvbmVudD5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2AucGFnZS13cmFwcGVye2JhY2tncm91bmQtY29sb3I6I2YyZjJmMjttaW4taGVpZ2h0OjEwMCU7bWFyZ2luLWJvdHRvbTotMTAwcHh9LmFyYy1vYmplY3QtZGV0YWlse3BhZGRpbmc6MjBweH0ucGFnZS10aXRsZS10ZXh0e2ZvbnQtc2l6ZToyMnB4O2NvbG9yOiMwMDA7cGFkZGluZzoxNHB4IDB9LnBhZ2UtdGl0bGV7cGFkZGluZzo1cHggMDtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZDdkN2Q3fS5wYWdlLWFjdGlvbnN7cGFkZGluZzoxNXB4IDAgNXB4fS5wYWdlLWFjdGlvbnMtYm90dG9te3BhZGRpbmc6MCAyMHB4fS5wYWdlLXN0YXRlLC5wYWdlLXN0YXRlLWNlbnRlciwucGFnZS1zdGF0ZS1sZWZ0LC5wYWdlLXN0YXRlLXJpZ2h0e3BhZGRpbmc6MH0uY29udGVudDo6YWZ0ZXJ7Y29udGVudDonXFxcXDAwYTAnO2ZvbnQtc2l6ZTowfS5wYWdlLXRpdGxlIC9kZWVwLyAudWktYnV0dG9ue21pbi13aWR0aDoxMDBweH0ucGFnZS1zdGF0dXN7dGV4dC1hbGlnbjpyaWdodDtwYWRkaW5nOjE4cHggMH0ucGFnZS1zdGF0dXMgLm9iamVjdC1zdGF0dXMtbGFiZWx7Y29sb3I6Izc2NzY3Nn0ucGFnZS1zdGF0dXMgLm9iamVjdC1zdGF0dXN7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiMwMzg3MTl9LnBhZ2UtcHVzaHtoZWlnaHQ6MTAwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgT2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnQgZXh0ZW5kcyBQYWdlV3JhcHBlciBpbXBsZW1lbnRzIE9uRGVzdHJveVxue1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoaXMgcGFnZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QgYmVpbmcgcmVuZGVyZWQgLSBFdmVudCwgV29ya3NwYWNlLCBjb250cmFjdCwgZXRjLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0VHlwZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogbGFiZWwgZm9yIHRoZSBvYmplY3Qgc3RhdHVzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0U3RhdHVzTGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoaXMgb2JqZWN0J3Mgc3RhdHVzLiBGb3IgZXhhbXBsZSwgZHJhZnQsIHBlbmRpbmcgc2VsZWN0aW9uLFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgb2JqZWN0U3RhdHVzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbC4gU29tZSBvYmplY3QgaGFzIHN0YXRlcy4gRm9yIGV4YW1wbGU6IFJGeE9iamVjdCBoYXMgUmVzb2x2ZSwgUmV2aWV3LCBHZXQgUXVvdGUuXG4gICAgICogT2JqZWN0IHN0YXRlcyB3aWxsIGFwcGVhciBvbiB0aGUgcGFnZSB3aGVuIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvYmplY3RTdGF0ZXM6IHN0cmluZ1tdO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIFN0ZXBwZXIgaXMgdXNlZCB0aGlzIGlkZW50aWZpZXMgY3VycmVudCBzZXQgc3RhdGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGN1cnJlbnRTdGF0ZTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgaXMgYSBjb21wb25lbnQgdHlwZSB0byBiZSByZW5kZXJlZCBhcyBhIHBhZ2UgSGVhZGVyLlxuICAgICAqXG4gICAgICogVGhlICdkZWZhdWx0JyB2YWx1ZSBpcyB0aGUgY29tcG9uZW50L3dpZGdldC9IZWFkZXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhlYWRlcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRydWUgaWYgcGFnZSBzaG91bGQgbm90IGluY2x1ZGUgYW55IGhlYWRlci4gTmVlZCB0byBzZXQgdG8gdHJ1ZSBldmVuIG5vIGhlYWRlclxuICAgICAqIG9iamVjdCBpcyBwYXNzZWQgaW4uIE90aGVyd2lzZSwgYSBkZWZhdWx0IEhlYWRlciBjb21wb25lbnQgd2lsbCBiZSBhZGRlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGVIZWFkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEZvb3RlciBDb21wb25lbnQgaXMgdGhlIHBhZ2UgZm9vdGVyLlxuICAgICAqIGNhbiBiZSBvdmVycmlkZW4gYnV0IHRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbXBvZW5lbnQvd2lkZ2V0L0Zvb3RlckNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZvb3RlcjogYW55O1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRydWUgaWYgcGFnZSBzaG91bGQgbm90IGluY2x1ZGUgYW55IGZvb3Rlci4gTmVlZCB0byBzZXQgdG8gdHJ1ZSBldmVuIG5vIGZvb3RlclxuICAgICAqIG9iamVjdCBpcyBwYXNzZWQgaW4uIE90aGVyd2lzZSwgYSBkZWZhdWx0IEZvb3RlciBjb21wb25lbnQgd2lsbCBiZSBhZGRlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGhpZGVGb290ZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbmluZyBvZiB0aGUgcGFnZSBhY3Rpb25zIChwYWdlIGJ1dHRvbnMpXG4gICAgICogICAndG9wJyA6ICAgIHBhZ2UgYnV0dG9ucyBhcmUgcGxhY2VkIGF0IHRoZSB0b3Agb2YgdGhlIHBhZ2UsIGJlbG93IHRoZSB0aXRsZSwgdG8gdGhlIHJpZ2h0LlxuICAgICAqICAgJ2JvdHRvbScgOiBwYWdlIGJ1dHRvbnMgYXJlIHBsYWNlZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBwYWdlLCBhYm92ZSB0aGUgZm9vdGVyLlxuICAgICAqICAgJ2JvdGgnICAgOiBwYWdlIGJ1dHRvbnMgYXJlIHBsYWNlZCBhdCBib3RoIHRvcCBhbmQgYm90dG9tLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwYWdlQWN0aW9uUG9zaXRpb246IHN0cmluZyA9ICd0b3AnO1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZsYWcgaXMgZHJpdmVuIGJ5IHBhZ2VBY3Rpb25Qb3NpdGlvbi4gVGhlIGRlZmF1bHQgcG9zaXRpb24gaXMgdG9wLlxuICAgICAqIFZhbHVlIGlzIHRydWUgZm9yIGJvdGggJ3RvcCcgYW5kICdib3RoJyBvZiBwYWdlQWN0aW9uUG9zaXRpb24uXG4gICAgICovXG4gICAgaGFzVG9wUGFnZUFjdGlvbnM6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBmbGFnIGlzIGRyaXZlbiBieSBwYWdlQWN0aW9uIHBvc2l0aW9uLlxuICAgICAqIFZhbHVlIGlzIHRydWUgZm9yIGJvdGggJ2JvdHRvbScgYW5kICdib3RoJyBvZiBwYWdlQWN0aW9uUG9zaXRpb24uXG4gICAgICovXG4gICAgaGFzQm90dG9tUGFnZUFjdGlvbnM6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFF1ZXJpZXMgYSBwIHRlbXBsYXRlIGlmIGFueVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ3BhZ2VBY3Rpb25zJylcbiAgICBhY3Rpb25zVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBBbnkgU3VjY2VzcywgSW5mbywgRXJyb3IsIG9yIFdhcm4gZm9yIHRoaXMgcGFnZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG5vdGlmaWNhdGlvbnM6IFBhZ2VOb3RpZmljYXRpb25bXTtcblxuXG4gICAgb2JqZWN0U3RhdGVJbmRleDogbnVtYmVyID0gMDtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBlbGVtZW50OiBFbGVtZW50UmVmLCBwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnksIHBhZ2VMaWZlY3ljbGVTZXJ2aWNlOiBQYWdlTGlmZUN5Y2xlU2VydmljZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudiwgUGFnZVR5cGUuT2JqZWN0LCBjb21wb25lbnRSZWdpc3RyeSwgcGFnZUxpZmVjeWNsZVNlcnZpY2UpO1xuXG4gICAgICAgIC8vIFNldHRpbmcgRGVmYXVsdCBoZWFkZXIgY29tcG9uZW50XG4gICAgICAgIHRoaXMuaGVhZGVyID0gUGFnZUhlYWRlckNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5mb290ZXIgPSBQYWdlRm9vdGVyQ29tcG9uZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdW5pcXVlIElkIGZvciB0aGlzIG9iamVjdC5cbiAgICAgKlxuICAgICAqL1xuICAgIGdlbmVyYXRlUGFnZUlkKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0VHlwZSArICdfJyArIHRoaXMudGl0bGUgKyAodGhpcy5pZCkgPyAoJ18nICsgdGhpcy5pZCkgOiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIG15IHBhZ2UgaGF2ZSBwYWdlIG5vdGlmaWNhdGlvbj9cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc05vdGlmaWNhdGlvbnMoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm5vdGlmaWNhdGlvbnMgJiYgdGhpcy5ub3RpZmljYXRpb25zLmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIGhhc09iamVjdFN0YXRlcygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMub2JqZWN0U3RhdGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIG15IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIC8vIE5ldyBDb21wb25lbnQgdHlwZXMgdGhhdCBhcmUgdXNlZCBpbiBjLWluY2x1ZGUtY29tcG9uZW50XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRSZWdpc3RyeS5yZWdpc3RlclR5cGUodGhpcy5oZWFkZXIubmFtZSwgdGhpcy5oZWFkZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmV3IENvbXBvbmVudCB0eXBlcyB0aGF0IGFyZSB1c2VkIGluIGMtaW5jbHVkZS1jb21wb25lbnRcbiAgICAgICAgaWYgKHRoaXMuZm9vdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyVHlwZSh0aGlzLmZvb3Rlci5uYW1lLCB0aGlzLmZvb3Rlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogbm90aWZ5IHN1YnNjcmliZXJzIG9mIHRoZSBwYWdlIGxpZmVjeWNsZSBzZXJ2aWNlICAqL1xuICAgICAgICB0aGlzLnBhZ2VMaWZlY3ljbGVTZXJ2aWNlLm9uUGFnZUluaXQodGhpcy50aXRsZSk7XG5cbiAgICAgICAgLy8gU2V0dGluZyB0aGUgcGFnZSBhY3Rpb24gcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLnBhZ2VBY3Rpb25Qb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzVG9wUGFnZUFjdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm90dG9tUGFnZUFjdGlvbnMgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYWdlQWN0aW9uUG9zaXRpb24gPT09ICdib3RoJykge1xuXG4gICAgICAgICAgICB0aGlzLmhhc1RvcFBhZ2VBY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGFzQm90dG9tUGFnZUFjdGlvbnMgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm9iamVjdFN0YXRlcykgJiYgdGhpcy5vYmplY3RTdGF0ZXMubGVuZ3RoID4gMVxuICAgICAgICAgICAgJiYgaXNQcmVzZW50KHRoaXMuY3VycmVudFN0YXRlKSkge1xuXG4gICAgICAgICAgICB0aGlzLm9iamVjdFN0YXRlSW5kZXggPSB0aGlzLm9iamVjdFN0YXRlcy5pbmRleE9mKHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQoY2hhbmdlc1snY3VycmVudFN0YXRlJ10pICYmXG4gICAgICAgICAgICBjaGFuZ2VzWydjdXJyZW50U3RhdGUnXS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXNbJ2N1cnJlbnRTdGF0ZSddLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbnQgbmVlZCB0byBjaGVjayBpZiBvYmplY3RTdGF0ZXMgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLm9iamVjdFN0YXRlSW5kZXggPSB0aGlzLm9iamVjdFN0YXRlcy5pbmRleE9mKHRoaXMuY3VycmVudFN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKVxuICAgIHtcbiAgICAgICAgdGhpcy5wYWdlTGlmZWN5Y2xlU2VydmljZS5vblBhZ2VEZXN0cm95KHRoaXMudGl0bGUpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWZ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqIFBhZ2UgYWN0aW9ucyBpcyBhIHdyYXBwZXIgZm9yIGFsbCBwYWdlIGFjdGlvbnMsIGJ1dHRvbnMsIGxpbmtzLCBtZW51cyB0aGF0IGludGVyYWN0cyBpdCB3aXRoIHRoZVxuICogcGFnZS4gVGhlIHdyYXBwZXIgdXNlIHRoZSBhYmlsaXR5IHRvIHBvc2l0aW9uIGl0IGFzIG5lZWRlZC5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1wYWdlLWFjdGlvbnMnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInBhZ2UtYWN0aW9uc1wiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnBhZ2UtYWN0aW9uc3t0ZXh0LWFsaWduOnJpZ2h0O3BhZGRpbmctdG9wOjA7cGFkZGluZy1yaWdodDowfWBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VBY3Rpb25zQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFbGVtZW50UmVmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuLyoqXG4gKiBQYWdlIGNvbnRlbnQgaXMgYSB3cmFwcGVyIGZvciBwYWdlIGNvbnRlbnQuXG4gKiBDdXJyZW50bHksIGl0J3MgcHJldHR5IGJhcmUsIGJ1dCBhcyB3ZSBhZGQgbW9yZSBpbnRlcmFjdGlvbnMgb24gdGhlIHBhZ2UsIGxpa2UgYSBzaWRlIGJhcixcbiAqIHRoZSBwYWdlIGNvbnRlbnQgYXJlYSB3aWxsIGxpa2VseSBnZXQgYWZmZWN0ZWQuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctcGFnZS1jb250ZW50JyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nLFxuICAgIHN0eWxlczogWyc6aG9zdCB7d2lkdGg6IDEwMCU7IHBhZGRpbmc6IDAgLjVlbTt9J11cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUNvbnRlbnRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG5cbmNvbnN0IFNURVBQRVJfQ09NUExFVEVEX1NURVBfQ09MT1IgPSAnIzU4Yjk1Nyc7XG5jb25zdCBTVEVQUEVSX0NVUlJFTlRfU1RFUF9DT0xPUiA9ICcjMDA3NkNCJztcbmNvbnN0IFNURVBQRVJfUkVNQUlOSU5HX1NURVBfQ09MT1IgPSAnI0Q3RDdENyc7XG5cbi8qKlxuICogU3RlcHBlciBjb21wb25lbnQgZGlzcGxheXMgYSBsaXN0IG9mIHN0ZXBzIGZvciB1c2VyIHRvIGZvbGxvdy4gSXQgY2FuIGJlIHVzZWQgYXMgYSBjaGVja2xpc3RcbiAqIHRvIGluZGljYXRlIGNvbXBsZXRlZCwgY3VycmVudCBhbmQgcmVtYWluaW5nIGl0ZW1zLiBJdCBjb3VsZCBiZSBhbHNvIGJlIHVzZWQgdG8gaW5kaWNhdGVcbiAqIHRoZSBzdGF0ZSBvZiBhbiBkb2N1bWVudCwgY3JlYXRlZCwgc3VibWl0dGVkLCBhcHByb3ZlZCwgZXRjLi4uXG4gKlxuICpcbiAqIFVzYWdlOlxuICogICAxLiAgIFVzZSB0aGUgY29tcG9uZW50IGluc2lkZSB5b3VyIHRlbXBsYXRlLiBwcm92aWRlIGEgbGlzdCBvZiBzdGVwcyBhbmQgdGhlIGN1cnJlbnQgc3RlcC5cbiAqXG4gKiAgICAgICAgICBAQ29tcG9uZW50KHtcbiAqICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnYXctcGFnZScgLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICAgICAgICAgPGF3LXN0ZXBwZXIgW3N0ZXBzXT1cInN0ZXBzXCIgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCI+PC9hdy1zdGVwcGVyPlxuICpcbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiBzdHJpbmdbXSA9IFsnTW9uaXRvcicsICdBZGQgU3VwcGxpZXInLCAnR2V0IFF1b3RlJ107XG4gKiAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBudW1iZXIgPSAxO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICogICAgICAgfVxuICpcbiAqICAgMi4gIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGNvbG9ycy5cbiAqXG4gKiAgICAgICAgIEBDb21wb25lbnQoe1xuICogICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdhdy1wYWdlJyAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctc3RlcHBlciBbc3RlcHNdPVwic3RlcHNcIiBbc3RlcENvbG9yQ3VycmVudF09XCInI2ZmOTkwMCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBDb2xvclJlbWFpbmluZ109XCInI0NDMDAwMCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0ZXBDb2xvckNvbXBsZXRlZF09XCInIzk3YTgyMidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRTdGVwXT1cImN1cnJlbnRTdGVwXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LXN0ZXBwZXI+XG4gKiAgICAgICAgICAgICAgICAgIGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdGVwcGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJzdGVwcGVyLWNvbnRhaW5lclwiPlxuICAgIDxkaXYgY2xhc3M9XCJzdGVwc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcC1zcGFjaW5nXCI+PC9kaXY+XG5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGk9aW5kZXg7IGxldCBsYXN0PWxhc3Q7XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcFwiPlxuICAgICAgICAgICAgICAgIDxhdy1zdGVwIFt0aXRsZV09XCJzdGVwXCIgW2NvbG9yXT1cImdldFN0ZXBDb2xvcihpKVwiPjwvYXctc3RlcD5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiAqbmdJZj1cIiFsYXN0XCIgY2xhc3M9XCJzdGVwLWNvbm5lY3RvclwiIFtzdHlsZS53aWR0aF09XCJjb25uZWN0b3JXaWR0aFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb25uZWN0b3JcIiBbc3R5bGUuYm9yZGVyQm90dG9tQ29sb3JdPVwiZ2V0Q29ubmVjdG9yQ29sb3IoaSlcIj48L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwic3RlcC1zcGFjaW5nXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwic3RlcC1sYWJlbHNcIj48L2Rpdj5cbjwvZGl2PlxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYC5zdGVwcGVyLWNvbnRhaW5lcntkaXNwbGF5OnRhYmxlO3RhYmxlLWxheW91dDpmaXhlZDt3aWR0aDoxMDAlfS5zdGVwc3tkaXNwbGF5OnRhYmxlLXJvd30uc3RlcC1zcGFjaW5ne2Rpc3BsYXk6dGFibGUtY2VsbDt3aWR0aDoxMCV9LnN0ZXB7ZGlzcGxheTp0YWJsZS1jZWxsO3dpZHRoOjMycHh9LnN0ZXAtY29ubmVjdG9ye2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmNvbm5lY3RvcntoZWlnaHQ6MXB4O2JvcmRlci1ib3R0b206M3B4IHNvbGlkICM1OGI5NTd9LnN0ZXAtbGFiZWxze2Rpc3BsYXk6dGFibGUtcm93O2hlaWdodDo1MHB4fWBdXG59KVxuZXhwb3J0IGNsYXNzIFN0ZXBwZXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50XG57XG4gICAgLyoqXG4gICAgICogUmVxdWlyZWRcbiAgICAgKiBBcnJheSBvZiBzdGVwcy4gT3JkZXIgb2YgdGhlIHN0ZXBzIHNob3VsZCBiZSBpbiBhcnJheSBvcmRlci5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBzOiBzdHJpbmdbXTtcblxuXG4gICAgLyoqXG4gICAgICogc3BlY2lmeSB0aGUgY29sb3JzIGFzc29jaWF0ZWQgd2l0aCBzdGVwcyBhYm92ZS4gVGhlIG51bWJlciBvZiBjb2xvcnNcbiAgICAgKiBhbmQgbnVtYmVyIG9mIHN0ZXBzIG11c3QgbWF0Y2guXG4gICAgICogT3B0aW9uYWw6LCBpZiBlbXB0eSwgZGVmYXVsdCBjb2xvcnMgb3IgY29sb3JzIGZyb20gc3RlcENvbG9yIGlucHV0cyB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjb2xvcnM6IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgdmFyaWFibGUgdG8gaW5kaWNhdGUgd2hldGhlciB0byB1c2UgdGhlIGNvbG9ycyBhcnJheSBvciBub3QuXG4gICAgICovXG4gICAgYlVzZUNvbG9yQXJyYXk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIElucHV0IGZvciBjYWxsZXIgdG8gb3ZlcnJpZGUgdGhlIGNvbG9yIG9mIGNvbXBsZXRlZCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc3RlcENvbG9yQ29tcGxldGVkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiBjdXJyZW50IHN0ZXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzdGVwQ29sb3JDdXJyZW50OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBPcHRpb25hbCBJbnB1dCBmb3IgY2FsbGVyIHRvIG92ZXJyaWRlIHRoZSBjb2xvciBvZiByZW1haW5pbmcgc3RlcC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHN0ZXBDb2xvclJlbWFpbmluZzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc3RlcCB0aGF0J3Mgb24uIElmIG5vdCBwcm92aWRlZCBkZWZhdWx0IHRvIHRoZSBmaXJzdCBzdGVwLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY3VycmVudFN0ZXA6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVkIHRoZSB3aWR0aCBvZiBjb25uZWN0b3JzIGJldHdlZW4gc3RlcHMuIFRoZSBjYWxjdWxhdGlvbnMgaXMgc29cbiAgICAgKiB0aGF0IHRoZSBzdGVwcyBhcmUgc3ByZWFkIG91dCBldmVubHkuXG4gICAgICovXG4gICAgY29ubmVjdG9yV2lkdGg6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICAgICAgLy8gSW5pdGlhbCBjb2xvciBmb3IgdGhlIGRpZmZlcmVudCBzdGFnZXMgb2Ygc3RlcHMuXG4gICAgICAgIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkID0gU1RFUFBFUl9DT01QTEVURURfU1RFUF9DT0xPUjtcbiAgICAgICAgdGhpcy5zdGVwQ29sb3JDdXJyZW50ID0gU1RFUFBFUl9DVVJSRU5UX1NURVBfQ09MT1I7XG4gICAgICAgIHRoaXMuc3RlcENvbG9yUmVtYWluaW5nID0gU1RFUFBFUl9SRU1BSU5JTkdfU1RFUF9DT0xPUjtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGNvbm5lY3RvciB3aWR0aCBiYXNlZCBvbiBob3cgbWFueSBzdGVwc1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RlcHMpICYmIHRoaXMuc3RlcHMubGVuZ3RoID4gMSkge1xuXG4gICAgICAgICAgICAvLyAoMTAwJSAtIDIwJSAoc2lkZSBtYXJnaW5zKSkgLyAoTnVtT2ZTdGVwcyAtMSlcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdG9yV2lkdGggPSBNYXRoLmNlaWwoODAgLyAodGhpcy5zdGVwcy5sZW5ndGggLSAxKSkgKyAnJSc7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIHRoZSBjb2xvciBhcnJheSBpZiBpdCdzIGRlZmluZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuY29sb3JzKSkge1xuXG4gICAgICAgICAgICB0aGlzLmJVc2VDb2xvckFycmF5ID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JzLmxlbmd0aCAhPT0gdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzaXplIG9mIHRoZSBzdGVwcyBhbmQgY29sb3JzIGRvbid0IG1hdGNoOlxuICAgICAgICAgICAgICAgICAgKHN0ZXBzLmxlbmd0aCA9ICR7dGhpcy5zdGVwcy5sZW5ndGh9KSwgKGNvbG9ycy5sZW5ndGggPSAke3RoaXMuY29sb3JzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHRpbmcgdGhlIGNvbG9yIG9mIHRoZSBzdGVwIGZvciB0aGUgY3VycmVudCBpbmRleFxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RlcENvbG9yKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICAvLyBDb2xvciBBcnJheSBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICBpZiAodGhpcy5iVXNlQ29sb3JBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ3VycmVudDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29sb3JSZW1haW5pbmc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdG9yIGNvbG9ycyBhcmUgZHJpdmVuIGJ5IHRoZSBzdGVwIGNvbG9ycy5cbiAgICAgKlxuICAgICAqL1xuICAgIGdldENvbm5lY3RvckNvbG9yKGluZGV4OiBudW1iZXIpXG4gICAge1xuICAgICAgICAvLyBDb2xvciBBcnJheSBvdmVycmlkZXMgZXZlcnl0aGluZyBlbHNlLlxuICAgICAgICBpZiAodGhpcy5iVXNlQ29sb3JBcnJheSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IHRoaXMuY3VycmVudFN0ZXApIHtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RlcENvbG9yQ29tcGxldGVkO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0ZXBDb2xvclJlbWFpbmluZztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5leHQgc3RlcC5cbiAgICAgKi9cbiAgICBuZXh0U3RlcCgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcHJldmlvdXMgc3RlcC5cbiAgICAgKi9cbiAgICBwcmV2U3RlcCgpXG4gICAge1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwLS07XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgSW5wdXQsIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc0JsYW5rfSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBSZW5kZXJzIGh0bWwgc3RlcCBjb21wb25lbnRcbiAqXG4gKiAgKiBVc2FnZTpcbiAqICAgICAgIFN0cmFpZ2h0IGZvcndhcmQgdG8gdXNlLiBCdXQgbW9zdGx5IGl0IHdvdWxkIGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgc3RlcHBlciBjb21wb25lbnQuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LXN0ZXAgW3RpdGxlXT1cInN0ZXBcIiBbY29sb3JdPVwiY29sb3JcIj48L2F3LXN0ZXA+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGBcbiAqL1xuXG4gICAgLy8gRGVmYXVsdCBjb2xvciBmb3IgdGhpcyBzdGVwLlxuY29uc3QgREVGQVVMVF9DT0xPUiA9ICcjNThiOTU3JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdGVwJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJzdGVwLWNvbnRhaW5lclwiPlxuICAgIDxkaXYgY2xhc3M9XCJvdXRlci1jaXJjbGVcIiBbc3R5bGUuYm9yZGVyQ29sb3JdPVwiY29sb3JcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlubmVyLWNpcmNsZVwiIFtzdHlsZS5ib3JkZXJDb2xvcl09XCJjb2xvclwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiY29sb3JcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzdGVwLXRpdGxlXCI+e3t0aXRsZX19PC9kaXY+XG48L2Rpdj5cblxuYCxcbiAgICBzdHlsZXM6IFtgLnN0ZXAtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjMycHh9Lm91dGVyLWNpcmNsZXt3aWR0aDoyNnB4O2hlaWdodDoyNnB4O2JvcmRlci1yYWRpdXM6NTAlO2JhY2tncm91bmQtY29sb3I6I2ZmZjtib3JkZXI6M3B4IHNvbGlkICM1OGI5NTc7cG9zaXRpb246cmVsYXRpdmV9LmlubmVyLWNpcmNsZXt3aWR0aDo4cHg7aGVpZ2h0OjhweDtib3JkZXItcmFkaXVzOjUwJTtib3JkZXI6MnB4IHNvbGlkICM1OGI5NTc7YmFja2dyb3VuZC1jb2xvcjojNThiOTU3O21hcmdpbjowIGF1dG87cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSl9LnN0ZXAtdGl0bGV7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MTUwcHg7dG9wOjQwcHg7bGVmdDotNjBweDt0ZXh0LWFsaWduOmNlbnRlcn1gXVxufSlcbmV4cG9ydCBjbGFzcyBTdGVwQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0XG57XG4gICAgLyoqXG4gICAgICogVGhlIGNvbG9yIG9mIHN0ZXAgaWNvbi5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbG9yOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiB0aXRsZSBhcHBlYXJzIHVuZGVyIHRoZSBzdGVwIGdyYXBoaWNzLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpXG4gICAge1xuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmNvbG9yKSkge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IERFRkFVTFRfQ09MT1I7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1N0ZXBwZXJDb21wb25lbnR9IGZyb20gJy4vc3RlcHBlci5jb21wb25lbnQnO1xuaW1wb3J0IHtTdGVwQ29tcG9uZW50fSBmcm9tICcuL3N0ZXAvc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG5cbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU3RlcENvbXBvbmVudCxcbiAgICAgICAgU3RlcHBlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTdGVwQ29tcG9uZW50LFxuICAgICAgICBTdGVwcGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU3RlcHBlck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIElucHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtQYWdlTWVudUl0ZW19IGZyb20gJy4uL3BhZ2UtaGVhZGVyL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Jhc2VDb21wb25lbnR9IGZyb20gJy4uLy4uLy4uL2NvcmUvYmFzZS5jb21wb25lbnQnO1xuXG4vKipcbiAqICBUaGlzIGlzIGEgdGVtcG9yYXJ5IGltcGxlbWVudGF0aW9uIGZvciB0aGUgcGFnZSBoZWFkZXIgY29tcG9uZW50LlxuICogIFdoZW4gdGhlIHJlYWwgaW1wbGVtZW50YXRpb24gb2Ygc2lkZSBtZW51IGlzIGRvbmUsIFBhZ2VIZWFkZXJDb21wb25lbnQgd2lsbFxuICogIGJlIHN3YXBlZCB0byB1c2UgaXQuXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNpZGVuYXYnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBbbmdDbGFzc109XCJnZXRTaWRlbmF2Q2xhc3MoKVwiPlxuICAgIDxkaXYgY2xhc3M9XCJzaWRlbmF2LWNvbnRlbnRcIj5cbiAgICAgICAgPGEgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIiBbcm91dGVyTGlua109XCJpdGVtLmxpbmtcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2lkZW5hdi1pY29uXCI+PGkgW25nQ2xhc3NdPVwiJ3NhcC1pY29uICcgKyBpdGVtLmljb25cIj48L2k+PC9zcGFuPlxuICAgICAgICAgICAge3tpdGVtLmxhYmVsfX1cbiAgICAgICAgPC9hPlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2Auc2lkZW5hdntoZWlnaHQ6MTAwJTt3aWR0aDowO3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MTt0b3A6NTBweDtsZWZ0OjA7YmFja2dyb3VuZC1jb2xvcjojMzYzNjM2O292ZXJmbG93LXg6aGlkZGVuO3BhZGRpbmctdG9wOjIwcHg7dHJhbnNpdGlvbjouNXN9LnNpZGVuYXYtYWN0aXZle3dpZHRoOjI1MHB4fS5zaWRlbmF2IGF7cGFkZGluZzo4cHggOHB4IDhweCAzMnB4O3RleHQtZGVjb3JhdGlvbjpub25lO2ZvbnQtc2l6ZToxNnB4O2NvbG9yOiNmZmY7ZGlzcGxheTpibG9jazt0cmFuc2l0aW9uOi4zc30uc2lkZW5hdiBhOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzExMX0uc2lkZW5hdi1pY29ue2ZvbnQtc2l6ZTozMHB4O2NvbG9yOiNjY2M7bWFyZ2luLXJpZ2h0OjEwcHh9YF1cbn0pXG5leHBvcnQgY2xhc3MgU2lkZW5hdkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIG1lbnUgaXRlbXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGl0ZW1zOiBQYWdlTWVudUl0ZW1bXTtcblxuICAgIC8qKlxuICAgICAqIGRpc3BsYXlzIHRoZSBiYWNrIGxpbmsgdGhhdCBuYXZpZ2F0ZXMgdXNlciB0byB0aGUgcHJldmlvdXMgcGFnZSB3aGVuIGNsaWNrZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93OiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJvdGVjdGVkIGVsZW1lbnQ6IEVsZW1lbnRSZWYsIHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBnZXRTaWRlbmF2Q2xhc3MoKTogc3RyaW5nXG4gICAge1xuICAgICAgICAvLyBPbmx5IHNob3cgaWYgSSBoYXZlIGl0ZW1zXG4gICAgICAgIHJldHVybiAodGhpcy5zaG93ICYmIHRoaXMuaXRlbXMpID8gJ3NpZGVuYXYgc2lkZW5hdi1hY3RpdmUnIDogJ3NpZGVuYXYnO1xuICAgIH1cblxuICAgIG9wZW4oKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5zaG93ID0gIXRoaXMuc2hvdztcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlfSBmcm9tICcuL3BhZ2UtbGlmZWN5Y2xlLnNlcnZpY2UnO1xuaW1wb3J0IHtPYmplY3RQYWdlV3JhcHBlckNvbXBvbmVudH0gZnJvbSAnLi9vYmplY3QtcGFnZS13cmFwcGVyL29iamVjdC1wYWdlLXdyYXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUFjdGlvbnNDb21wb25lbnR9IGZyb20gJy4vcGFnZS1hY3Rpb25zL3BhZ2UtYWN0aW9ucy5jb21wb25lbnQnO1xuaW1wb3J0IHtQYWdlQ29udGVudENvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWNvbnRlbnQvcGFnZS1jb250ZW50LmNvbXBvbmVudCc7XG5pbXBvcnQge1BhZ2VGb290ZXJDb21wb25lbnR9IGZyb20gJy4vcGFnZS1mb290ZXIvcGFnZS1mb290ZXIuY29tcG9uZW50JztcbmltcG9ydCB7UGFnZUhlYWRlckNvbXBvbmVudH0gZnJvbSAnLi9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtBV1N0ZXBwZXJNb2R1bGV9IGZyb20gJy4uL3N0ZXBwZXIvc3RlcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtTaWRlbmF2Q29tcG9uZW50fSBmcm9tICcuL3NpZGVuYXYvc2lkZW5hdi5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGV9IGZyb20gJy4uL3BhZ2Utbm90aWZpY2F0aW9uL3BhZ2Utbm90aWZpY2F0aW9uLm1vZHVsZSc7XG5pbXBvcnQge1JvdXRlck1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgT2JqZWN0UGFnZVdyYXBwZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VBY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBQYWdlQ29udGVudENvbXBvbmVudCxcbiAgICAgICAgUGFnZUZvb3RlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgU2lkZW5hdkNvbXBvbmVudFxuXG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUm91dGVyTW9kdWxlLFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGUsXG4gICAgICAgIEFXU3RlcHBlck1vZHVsZSxcbiAgICAgICAgQVdQYWdlTm90aWZpY2F0aW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUGFnZUZvb3RlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUFjdGlvbnNDb21wb25lbnQsXG4gICAgICAgIFBhZ2VDb250ZW50Q29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIE9iamVjdFBhZ2VXcmFwcGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlQWN0aW9uc0NvbXBvbmVudCxcbiAgICAgICAgUGFnZUNvbnRlbnRDb21wb25lbnQsXG4gICAgICAgIFBhZ2VGb290ZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIFNpZGVuYXZDb21wb25lbnRcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW1BhZ2VMaWZlQ3ljbGVTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBBV1BhZ2VXcmFwcGVyTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIFNraXBTZWxmfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TkdfVkFMVUVfQUNDRVNTT1J9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7Rm9ybVJvd0NvbXBvbmVudH0gZnJvbSAnLi4vLi4vbGF5b3V0cy9mb3JtLXRhYmxlL2Zvcm0tcm93L2Zvcm0tcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge2Rpc3RpbmN0VW50aWxDaGFuZ2VkfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8qKlxuICogUmljaFRleHRBcmVhIGNvbXBvbmVudCByZXByZXNlbnRzIGEgdGV4dCBlZGl0b3Igd2hpY2ggYWxsb3dzIHVzZXJzIHRvIGZvcm1hdCB0ZXh0IGlucHV0LlxuICogVGhlIGVkaXRvcidzIHRvb2xiYXIgaXMgcHJlLWNvbmZpZ3VyZWQgdG8gY29udGFpbiBmdW5jdGlvbmFsaXRpZXMgdGhhdCBhcmUgaW4gb3VyIGRlc2lnbi5cbiAqIEBzZWUge0BsaW5rIGVkaXRvci9lZGl0b3IuY29tcG9uZW50Lmh0bWx9XG4gKlxuICogICMjIyBFeGFtcGxlXG4gKiAgYGBgXG4gKlxuICogIEBDb21wb25lbnQoe1xuICogICAgc2VsZWN0b3I6ICdyZngtZXZlbnQnICxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKlxuICogICAgICAgIDwhLS0gQmFzaWMgVXNhZ2UuIC0tPlxuICogICAgICAgIDxhdy1yaWNodGV4dGFyZWEgW25hbWVdPVwiJ2Rlc2NyaXB0aW9uJ1wiIFt2YWx1ZV09XCJkZXNjcmlwdGlvblwiIHBsYWNlSG9sZGVyPVwicHV0XG4gKiAgICAgICAgZGVzY3JpcHRpb25cIj5cbiAqICAgICAgICA8L2F3LXJpY2h0ZXh0YXJlYT5cbiAqXG4gKiAgICAgICAgPCEtLSBFZGl0b3Igd2l0aCBGdWxsIGZ1bmN0aW9uYWxpdHkgLS0+XG4gKiAgICAgIDxhdy1yaWNodGV4dGFyZWEgW25hbWVdPVwiJ2NvbW1lbnQnXCIgW3R5cGVdPVwiZWRpdG9yVHlwZVwiIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gKiAgICAgIHBsYWNlSG9sZGVyPVwiaG9sZCB0aGlzXCI+XG4gKiAgICAgIDwvYXctcmljaHRleHRhcmVhPlxuICogICAgfSlcbiAqICAgIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudFxuICogICAge1xuICogICAgICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gKlxuICogICAgICAgIGVkaXRvclR5cGU6RWRpdG9yVHlwZSA9IEVkaXRvclR5cGUuRnVsbDtcbiAqICAgICAgICB2YWx1ZTpTdHJpbmc7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqICAgIH1cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiB0ZXh0IGVkaXRvci4gVGhleSBhcmUgcHJlY29uZmlndXJlZCB3aXRoXG4gKiBmdW5jdGlvbmFsaXR5IGJhc2VkIG9uIHR5cGUuIFVzZSBjdXN0b20gdG8gYWRkIHlvdXIgb3duIHRvb2xiYXIgbWVudS5cbiAqL1xuZXhwb3J0IGVudW0gRWRpdG9yVHlwZSB7XG4gICAgRGVmYXVsdCwgICAgLy8gRGVmYXVsdCBFZGl0b3Igc3VwcG9ydHMgTWluaW1hbCBzZXQgb2YgZnVuY3Rpb25hbGl0eVxuICAgIC8vIFsgYm9sZCB8IGl0YWxpYyB8IHVuZGVybGluZSB8IG9yZGVyZWQgfCBidWxsZXQgfCBhbGlnbm1lbnRdXG4gICAgRnVsbCwgICAgICAgLy8gVGhlIGZ1bGwgbGlzdCBvZiBmdW5jdGlvbmFsaXR5LFxuICAgIFRleHRGb3JtYXQsIC8vIEZ1bmN0aW9uYWxpdGllcyB0aGF0IGFmZmVjdHMgdGV4dCBmb3JtYXR0aW5nLlxuICAgIEN1c3RvbSAgICAgLy8gQ3VzdG9tIHRvb2xiYXIuXG59XG5cblxuZXhwb3J0IGNvbnN0IEVESVRPUl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmljaFRleHRBcmVhQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXJpY2h0ZXh0YXJlYScsXG4gICAgdGVtcGxhdGU6IGA8bmctdGVtcGxhdGUgW25nSWZdPVwiZWRpdGFibGVcIj5cblxuICAgIDwhLS0gQmFzaWMgZWRpdG9yLCBhbHNvIHRoZSBkZWZhdWx0LCB3aGljaCB0aGUgbW9zdCB1c2VkIGZlYXR1cmVzIGVuYWJsZWQuIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJ0eXBlID09PSBFZGl0b3JUeXBlLkRlZmF1bHRcIj5cbiAgICAgICAgPHAtZWRpdG9yIFsobmdNb2RlbCldPVwidmFsdWVcIiBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW3N0eWxlXT1cInsnaGVpZ2h0JzonMTgwcHgnfVwiXG4gICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIj5cbiAgICAgICAgICAgIDxwLWhlYWRlcj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXRzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtYm9sZFwiIGFyaWEtbGFiZWw9XCJCb2xkXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwicWwtaXRhbGljXCIgYXJpYS1sYWJlbD1cIkl0YWxpY1wiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLXVuZGVybGluZVwiIGFyaWEtbGFiZWw9XCJVbmRlcmxpbmVcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWxpc3RcIiB2YWx1ZT1cIm9yZGVyZWRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1saXN0XCIgdmFsdWU9XCJidWxsZXRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJsZWZ0XCIgc2VsZWN0ZWQ+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB2YWx1ZT1cImNlbnRlclwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJyaWdodFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJqdXN0aWZ5XCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvcC1oZWFkZXI+XG4gICAgICAgIDwvcC1lZGl0b3I+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIEVkaXRvciB3aXRoIGFsbCB0aGUgZmVhdHVyZXMgZW5hYmxlZCAtLT5cbiAgICA8ZGl2ICpuZ0lmPVwidHlwZSA9PT0gRWRpdG9yVHlwZS5GdWxsXCI+XG4gICAgICAgIDxwLWVkaXRvciBbKG5nTW9kZWwpXT1cInZhbHVlXCIgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFtzdHlsZV09XCJ7J2hlaWdodCc6JzE4MHB4J31cIlxuICAgICAgICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlSG9sZGVyXCI+PC9wLWVkaXRvcj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRWRpdG9yIHdpdGggYWxsIFRleHQgZm9ybWF0dGluZyAgLS0+XG4gICAgPGRpdiAqbmdJZj1cInR5cGUgPT09IEVkaXRvclR5cGUuVGV4dEZvcm1hdFwiPlxuICAgICAgICA8cC1lZGl0b3IgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiIFtzdHlsZUNsYXNzXT1cInN0eWxlQ2xhc3NcIiBbc3R5bGVdPVwieydoZWlnaHQnOicxODBweCd9XCJcbiAgICAgICAgICAgICAgICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZUhvbGRlclwiPlxuICAgICAgICAgICAgPHAtaGVhZGVyPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXQtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgPHNlbGVjdCB0aXRsZT1cIkZvbnRcIiBjbGFzcz1cInFsLWZvbnRcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwic2Fucy1zZXJpZlwiIHNlbGVjdGVkPVwiXCI+U2FucyBTZXJpZjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJzZXJpZlwiPlNlcmlmPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIm1vbm9zcGFjZVwiPk1vbm9zcGFjZTwvb3B0aW9uPlxuICAgICAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgICAgICAgPHNlbGVjdCB0aXRsZT1cIlNpemVcIiBjbGFzcz1cInFsLXNpemVcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMTBweFwiPlNtYWxsPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIjEzcHhcIiBzZWxlY3RlZD1cIlwiPk5vcm1hbDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCIxOHB4XCI+TGFyZ2U8L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwiMzJweFwiPkh1Z2U8L29wdGlvbj5cbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXRzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1ib2xkXCIgYXJpYS1sYWJlbD1cIkJvbGRcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWl0YWxpY1wiIGFyaWEtbGFiZWw9XCJJdGFsaWNcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLXVuZGVybGluZVwiIGFyaWEtbGFiZWw9XCJVbmRlcmxpbmVcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJxbC1mb3JtYXQtZ3JvdXBcIj5cbiAgICAgICAgICAgICAgPHNlbGVjdCB0aXRsZT1cIlRleHQgQ29sb3JcIiBjbGFzcz1cInFsLWNvbG9yXCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAwLCAwKVwiIGxhYmVsPVwicmdiKDAsIDAsIDApXCIgc2VsZWN0ZWQ9XCJcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIzMCwgMCwgMClcIiBsYWJlbD1cInJnYigyMzAsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDE1MywgMClcIiBsYWJlbD1cInJnYigyNTUsIDE1MywgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAwKVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgMTM4LCAwKVwiIGxhYmVsPVwicmdiKDAsIDEzOCwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDEwMiwgMjA0KVwiIGxhYmVsPVwicmdiKDAsIDEwMiwgMjA0KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMTUzLCA1MSwgMjU1KVwiIGxhYmVsPVwicmdiKDE1MywgNTEsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAyNTUpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1MCwgMjA0LCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjUwLCAyMDQsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjM1LCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyMzUsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIwNCwgMjMyLCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjA0LCAyMzIsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIwNCwgMjI0LCAyNDUpXCIgbGFiZWw9XCJyZ2IoMjA0LCAyMjQsIDI0NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIzNSwgMjE0LCAyNTUpXCIgbGFiZWw9XCJyZ2IoMjM1LCAyMTQsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE4NywgMTg3LCAxODcpXCIgbGFiZWw9XCJyZ2IoMTg3LCAxODcsIDE4NylcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI0MCwgMTAyLCAxMDIpXCIgbGFiZWw9XCJyZ2IoMjQwLCAxMDIsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMTk0LCAxMDIpXCIgbGFiZWw9XCJyZ2IoMjU1LCAxOTQsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAxMDIpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgMTg1LCAxMDIpXCIgbGFiZWw9XCJyZ2IoMTAyLCAxODUsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgMTYzLCAyMjQpXCIgbGFiZWw9XCJyZ2IoMTAyLCAxNjMsIDIyNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE5NCwgMTMzLCAyNTUpXCIgbGFiZWw9XCJyZ2IoMTk0LCAxMzMsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEzNiwgMTM2LCAxMzYpXCIgbGFiZWw9XCJyZ2IoMTM2LCAxMzYsIDEzNilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE2MSwgMCwgMClcIiBsYWJlbD1cInJnYigxNjEsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNzgsIDEwNywgMClcIiBsYWJlbD1cInJnYigxNzgsIDEwNywgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE3OCwgMTc4LCAwKVwiIGxhYmVsPVwicmdiKDE3OCwgMTc4LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgOTcsIDApXCIgbGFiZWw9XCJyZ2IoMCwgOTcsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA3MSwgMTc4KVwiIGxhYmVsPVwicmdiKDAsIDcxLCAxNzgpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDcsIDM2LCAxNzgpXCIgbGFiZWw9XCJyZ2IoMTA3LCAzNiwgMTc4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoNjgsIDY4LCA2OClcIiBsYWJlbD1cInJnYig2OCwgNjgsIDY4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoOTIsIDAsIDApXCIgbGFiZWw9XCJyZ2IoOTIsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDYxLCAwKVwiIGxhYmVsPVwicmdiKDEwMiwgNjEsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDEwMiwgMClcIiBsYWJlbD1cInJnYigxMDIsIDEwMiwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDU1LCAwKVwiIGxhYmVsPVwicmdiKDAsIDU1LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNDEsIDEwMilcIiBsYWJlbD1cInJnYigwLCA0MSwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoNjEsIDIwLCAxMDIpXCIgbGFiZWw9XCJyZ2IoNjEsIDIwLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInFsLWZvcm1hdC1zZXBhcmF0b3JcIj48L3NwYW4+XG4gICAgICAgICAgICAgIDxzZWxlY3QgdGl0bGU9XCJCYWNrZ3JvdW5kIENvbG9yXCIgY2xhc3M9XCJxbC1iYWNrZ3JvdW5kXCI+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAwLCAwKVwiIGxhYmVsPVwicmdiKDAsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyMzAsIDAsIDApXCIgbGFiZWw9XCJyZ2IoMjMwLCAwLCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMjU1LCAxNTMsIDApXCIgbGFiZWw9XCJyZ2IoMjU1LCAxNTMsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMClcIiBsYWJlbD1cInJnYigyNTUsIDI1NSwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDEzOCwgMClcIiBsYWJlbD1cInJnYigwLCAxMzgsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCAxMDIsIDIwNClcIiBsYWJlbD1cInJnYigwLCAxMDIsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE1MywgNTEsIDI1NSlcIiBsYWJlbD1cInJnYigxNTMsIDUxLCAyNTUpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigyNTUsIDI1NSwgMjU1KVwiIGxhYmVsPVwicmdiKDI1NSwgMjU1LCAyNTUpXCIgc2VsZWN0ZWQ9XCJcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1MCwgMjA0LCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjUwLCAyMDQsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjM1LCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyMzUsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIwNCwgMjMyLCAyMDQpXCIgbGFiZWw9XCJyZ2IoMjA0LCAyMzIsIDIwNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIwNCwgMjI0LCAyNDUpXCIgbGFiZWw9XCJyZ2IoMjA0LCAyMjQsIDI0NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDIzNSwgMjE0LCAyNTUpXCIgbGFiZWw9XCJyZ2IoMjM1LCAyMTQsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE4NywgMTg3LCAxODcpXCIgbGFiZWw9XCJyZ2IoMTg3LCAxODcsIDE4NylcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI0MCwgMTAyLCAxMDIpXCIgbGFiZWw9XCJyZ2IoMjQwLCAxMDIsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMTk0LCAxMDIpXCIgbGFiZWw9XCJyZ2IoMjU1LCAxOTQsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDI1NSwgMjU1LCAxMDIpXCIgbGFiZWw9XCJyZ2IoMjU1LCAyNTUsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgMTg1LCAxMDIpXCIgbGFiZWw9XCJyZ2IoMTAyLCAxODUsIDEwMilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEwMiwgMTYzLCAyMjQpXCIgbGFiZWw9XCJyZ2IoMTAyLCAxNjMsIDIyNClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE5NCwgMTMzLCAyNTUpXCIgbGFiZWw9XCJyZ2IoMTk0LCAxMzMsIDI1NSlcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDEzNiwgMTM2LCAxMzYpXCIgbGFiZWw9XCJyZ2IoMTM2LCAxMzYsIDEzNilcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE2MSwgMCwgMClcIiBsYWJlbD1cInJnYigxNjEsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxNzgsIDEwNywgMClcIiBsYWJlbD1cInJnYigxNzgsIDEwNywgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDE3OCwgMTc4LCAwKVwiIGxhYmVsPVwicmdiKDE3OCwgMTc4LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgOTcsIDApXCIgbGFiZWw9XCJyZ2IoMCwgOTcsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigwLCA3MSwgMTc4KVwiIGxhYmVsPVwicmdiKDAsIDcxLCAxNzgpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDcsIDM2LCAxNzgpXCIgbGFiZWw9XCJyZ2IoMTA3LCAzNiwgMTc4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoNjgsIDY4LCA2OClcIiBsYWJlbD1cInJnYig2OCwgNjgsIDY4KVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoOTIsIDAsIDApXCIgbGFiZWw9XCJyZ2IoOTIsIDAsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDYxLCAwKVwiIGxhYmVsPVwicmdiKDEwMiwgNjEsIDApXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInJnYigxMDIsIDEwMiwgMClcIiBsYWJlbD1cInJnYigxMDIsIDEwMiwgMClcIj48L29wdGlvbj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uIHZhbHVlPVwicmdiKDAsIDU1LCAwKVwiIGxhYmVsPVwicmdiKDAsIDU1LCAwKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoMCwgNDEsIDEwMilcIiBsYWJlbD1cInJnYigwLCA0MSwgMTAyKVwiPjwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJyZ2IoNjEsIDIwLCAxMDIpXCIgbGFiZWw9XCJyZ2IoNjEsIDIwLCAxMDIpXCI+PC9vcHRpb24+XG4gICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJxbC1saXN0XCIgdmFsdWU9XCJvcmRlcmVkXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cInFsLWxpc3RcIiB2YWx1ZT1cImJ1bGxldFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicWwtZm9ybWF0c1wiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwibGVmdFwiIHNlbGVjdGVkPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwiY2VudGVyXCI+PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdmFsdWU9XCJyaWdodFwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHZhbHVlPVwianVzdGlmeVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9wLWhlYWRlcj5cbiAgICAgICAgPC9wLWVkaXRvcj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gQ3VzdG9tIGhlYWRlciBUZXh0IEVkaXRvciAtLT5cbiAgICA8ZGl2ICpuZ0lmPVwidHlwZSA9PT0gRWRpdG9yVHlwZS5DdXN0b21cIj5cbiAgICAgICAgPHAtZWRpdG9yIFsobmdNb2RlbCldPVwidmFsdWVcIiBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCIgW3N0eWxlXT1cInsnaGVpZ2h0JzonMTgwcHgnfVwiXG4gICAgICAgICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2VIb2xkZXJcIj5cbiAgICAgICAgICAgIDxwLWhlYWRlcj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJjdXN0b20taGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9wLWhlYWRlcj5cbiAgICAgICAgPC9wLWVkaXRvcj5cbiAgICA8L2Rpdj5cblxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgW25nSWZdPVwiIWVkaXRhYmxlXCI+XG4gICAgPGF3LXN0cmluZyBbdmFsdWVdPVwidmFsdWVcIj48L2F3LXN0cmluZz5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICAgIHN0eWxlczogW2AvZGVlcC8gLnVpLWVkaXRvci10b29sYmFye2JhY2tncm91bmQtY29sb3I6I2Y1ZjVmNTtib3JkZXI6MXB4IHNvbGlkICNkN2Q3ZDd9L2RlZXAvIHAtZWRpdG9yOmFjdGl2ZSAvZGVlcC8gLnVpLWVkaXRvci10b29sYmFyLnFsLXRvb2xiYXIucWwtc25vdywvZGVlcC8gcC1lZGl0b3I6Zm9jdXMgL2RlZXAvIC51aS1lZGl0b3ItdG9vbGJhci5xbC10b29sYmFyLnFsLXNub3csL2RlZXAvIHAtZWRpdG9yOmhvdmVyIC9kZWVwLyAudWktZWRpdG9yLXRvb2xiYXIucWwtdG9vbGJhci5xbC1zbm93e2JvcmRlci1jb2xvcjojMTk5ZGUwfS9kZWVwLyBwLWVkaXRvcjphY3RpdmUgL2RlZXAvIC51aS1lZGl0b3ItY29udGVudC5xbC1jb250YWluZXIucWwtc25vdywvZGVlcC8gcC1lZGl0b3I6Zm9jdXMgL2RlZXAvIC51aS1lZGl0b3ItY29udGVudC5xbC1jb250YWluZXIucWwtc25vdywvZGVlcC8gcC1lZGl0b3I6aG92ZXIgL2RlZXAvIC51aS1lZGl0b3ItY29udGVudC5xbC1jb250YWluZXIucWwtc25vd3tib3JkZXItY29sb3I6IzE5OWRlMH1gXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgRURJVE9SX0NPTlRST0xfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHtwcm92aWRlOiBCYXNlRm9ybUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmljaFRleHRBcmVhQ29tcG9uZW50KX1cbiAgICBdXG5cbn0pXG5leHBvcnQgY2xhc3MgUmljaFRleHRBcmVhQ29tcG9uZW50IGV4dGVuZHMgQmFzZUZvcm1Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFRoZSB0eXBlIG9mIHRoZSBlZGl0b3IuICBTZWUgRWRpdG9yVHlwZSBmb3IgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB0eXBlOiBFZGl0b3JUeXBlO1xuXG4gICAgLyoqXG4gICAgICogQSB2YWx1ZSB1c2VkIHRvIHNhdmUgYW5kIHJlYWQgd2hlbiByZW5kZXJpbmcgYW5kIHVwZGF0aW5nIHRoaXMgY29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZTogYW55ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgZWRpdG9yVHlwZSBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGluIHRoaXMgY29tcG9uZW50cyB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBFZGl0b3JUeXBlOiBhbnkgPSBFZGl0b3JUeXBlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRm9ybVJvd0NvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJvdGVjdGVkIHBhcmVudENvbnRhaW5lcjogQmFzZUZvcm1Db21wb25lbnQpIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuXG4gICAgICAgIHRoaXMudHlwZSA9IEVkaXRvclR5cGUuRGVmYXVsdDtcbiAgICAgICAgdGhpcy5zdHlsZUNsYXNzID0gJ2RlZmF1bHQtZWRpdG9yJztcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICBzdXBlci5yZWdpc3RlckZvcm1Db250cm9sKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIHRoaXMuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gICAgICAgICkuc3Vic2NyaWJlKHZhbCA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgdGhpcy5vbk1vZGVsQ2hhbmdlZCh0aGlzLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwuIFBsZWFzZSBzZWUgQ29udHJvbFZhbHVlQWNjZXNzb3JcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmZvcm1Db250cm9sLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7Rm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7RWRpdG9yTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge1JpY2hUZXh0QXJlYUNvbXBvbmVudH0gZnJvbSAnLi4vcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSaWNoVGV4dEFyZWFDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRWRpdG9yTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgUmljaFRleHRBcmVhQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJpY2hUZXh0QXJlYUNvbXBvbmVudCxcbiAgICAgICAgUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdSaWNoVGV4dEFyZWFNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QWNjb3JkaW9uVGFifSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcblxuXG4vKipcbiAqIEFsbG93IGRldmVsb3BlciB0byBvdmVycmlkZSBkZWZhdWx0IGFjdGlvbnMuIE11c3QgaGF2ZSB0aGlzIGRlY2xhcmVkIGJlZm9yZSBjbGFzcyB3aGVuIHdlXG4gKiB3YW50IHRvIGhhdmUgdGhpcyBkZWNsYXJhdGlvbiBpbnNpZGUgdGhlIHNhbWUgZmlsZS5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zZWN0aW9uLWFjdGlvbnMnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PiBgLFxufSlcbmV4cG9ydCBjbGFzcyBTZWN0aW9uQWN0aW9uc0NvbXBvbmVudFxue1xuXG59XG5cblxuLyoqXG4gKlxuICogU2VjdGlvbiBjb21wb25lbnQgdGhhdCBpbXBsZW1lbnRzIGEgc2VjdGlvbiBvZiB0aGUgcGFnZS4gSXQncyBhbiBvdXRsaW5lIGJveCB0aGF0XG4gKiBoYXMgdGhlIGFiaWxpdHkgdG8gZXhwYW5kIGFuZCBoaWRlIGl0cyBjb250ZW50LlxuICpcbiAqIGBgYHRzXG4gKiAgQENvbXBvbmVudCh7XG4gKiAgICBzZWxlY3RvcjogJ3JmeC1kZXRhaWxzJyAsXG4gKiAgICB0ZW1wbGF0ZTogYFxuICogICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlNvdXJjaW5nIHJlcXVlc3QgaW5mb1wiIChvbkVkaXQpPVwib25TdGF0ZUNoYW5nZSgkZXZlbnQpXCJcbiAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICA8bS1jb250ZXh0IFtvYmplY3RdPVwicmZ4RW50aXR5LmhlYWRlckluZm9cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFtvcGVyYXRpb25dPVwidGhpcy5lZGl0YWJpbGl0eVN0YXRlLmhlYWRlckluZm9PcFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0PVwiSW5zcGVjdFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgdWlHcm91cD1cIkhlYWRlckdlbmVyYWxcIj5cbiAqICAgICAgICAgICAgICAgICAgIDxtLWluY2x1ZGUtY29tcG9uZW50PjwvbS1pbmNsdWRlLWNvbXBvbmVudD5cbiAqICAgICAgICAgICAgICAgPC9tLWNvbnRleHQ+XG4gKiAgICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqXG4gKiAgICAgICAgICAgPGF3LXNlY3Rpb24gI3N1cHBsaWVyU2VjdGlvbiB0aXRsZT1cIlNlbGVjdGVkIHN1cHBsaWVyc1wiIChvbk9wZW4pPVwib25PcGVuKClcIlxuICAgKiAgICAgICAgICAgICAgICBbb3BlbmVkXT1cImZhbHNlXCI+XG4gKiAgICAgICAgICAgICAgIDxzdXBwbGllci1wcm9maWxlLWNhcmQ+PC9zdXBwbGllci1wcm9maWxlLWNhcmQ+XG4gKiAgICAgICAgICAgPC9hdy1zZWN0aW9uPlxuICpcbiAqICAgICAgICAgICA8YXctc2VjdGlvbiB0aXRsZT1cIlJGUSBEZXRhaWxzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbj1cIlJldmlldyBhbmQgdXBkYXRlIGluZm9ybWF0aW9uIGZvciBzdXBwbGllcnMgdG8gcmVzcG9uZC5cIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlQ2xvc2VdPVwidHJ1ZVwiPlxuICpcbiAqICAgICAgICAgICAgICAgPGF3LXN1YnNlY3Rpb24gdGl0bGU9XCJFdmVudCB0aW1lbGluZVwiPlxuICogICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tdGFibGUgW3VzZUZpdmVab25lXT1cImZhbHNlXCIgW2VkaXRhYmxlXT1cInRydWVcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgPGF3LWZvcm0tcm93IFtsYWJlbF09XCInU3RhcnQgRGF0ZSdcIiBbbmFtZV09XCInc3RhcnREYXRlJ1wiIFtzaXplXT1cIidzbWFsbCdcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtoaWdobGlnaHRSb3ddPVwidHJ1ZVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctZGF0ZS10aW1lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXROYW1lPVwiZGF0ZVRpbWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZT1cInN0YXJ0RGF0ZVwiIFt2YWx1ZV09XCJyZnhFbnRpdHkuY3JlYXRlZFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2hvd1RpbWVdPVwidHJ1ZVwiPjwvYXctZGF0ZS10aW1lPlxuICogICAgICAgICAgICAgICAgICAgICAgIDwvYXctZm9ybS1yb3c+XG4gKiAgICAgICAgICAgICAgICAgICA8L2F3LWZvcm0tdGFibGU+XG4gKiAgICAgICAgICAgICAgIDwvYXctc3Vic2VjdGlvbj5cbiAqICAgICAgICAgIDwvYXctc2VjdGlvbj5cbiAqICAgIGBcbiAqICAgIH0pXG4gKiAgICBleHBvcnQgY2xhc3MgTXlQYWdlXG4gKiAgICB7XG4gKlxuICogICAgICAgIGNvbnN0cnVjdG9yICgpXG4gKiAgICAgICAge1xuICogICAgICAgIH1cbiAqXG4gKiAgICB9XG4gKlxuICogYGBgXG4gKlxuICogU2VjdGlvbiBjb21wb25lbnQgYWxzbyBzdXBwb3J0cyBlZGl0YWJpbGl0eSBtb2RlcyBhbmQgaWYgZW5hYmxlZCBpdCB3aWxsIHJlbmRlciBhY3Rpb24gYnV0dG9uc1xuICogaW4gdGhlIGZvb3Rlci4gRGV2ZWxvcGVyIGNhbiBhbHNvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IgYW5kIHByb3ZpZGUgY3VzdG9tIGFjdGlvbnMuXG4gKlxuICpcbiAqIGUuZzpcbiAqXG4gKiBgYGBcbiAqICAgICAgPGF3LXNlY3Rpb24gW3RpdGxlXT1cInRpdGxlXCIgW2VkaXRhYmxlXT1cInRydWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNhbmNlbEFjdGlvbik9XCJzb21lSGFuZGxlcjEoJGV2ZW50KVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKG9uU2F2ZUFjdGlvbik9XCJzb21lSGFuZGxlcjIoJGV2ZW50KVwiID5cbiAqICAgICAgICAgICAgICBzZWN0aW9uIGNvbnRlbnRcbiAqXG4gKlxuICogICA8L2F3LXNlY3Rpb24+XG4gKlxuICogYGBgXG4gKlxuICogb3IgY3VzdG9tIGFjdGlvbiBidXR0b25zOlxuICpcbiAqXG4gKiBgYGBodG1sXG4gKlxuICogICAgICAgPGF3LXNlY3Rpb24tYWN0aW9ucz5cbiAqICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgQnV0dG9uVGVzdDFcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJ1dHRvblRlc3QyXG4gKiAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICA8L2F3LXNlY3Rpb24tYWN0aW9ucz5cbiAqXG4gKiBgYGBcbiAqXG4gKlxuICogVGhlcmUgYXJlIHR3byBlZGl0IG1vZGVzXG4gKiAgIyBEZWZhdWx0XG4gKiAgICAgIFJlbmRlcnMgYWN0aW9uIGJ1dHRvbnMgaW4gdGhlIGZvb3RlcnMgYW5kIGVtaXQgYWN0aW9ucyB0byB0aGUgYXBwbGljYXRpb25cbiAqXG4gKiAgIyBFeHRlcm5hbFxuICogICAgIE5vIGFjdGlvbiBidXR0b25zIGFyZSBzaG93biBpbiB0aGUgZm9vdGVyIGFuZCBiZWhhdmlvciBpcyBoYW5kbGVkIGJ5IGFwcGxpY2F0aW9uLiBPbmx5IGV2ZW50XG4gKiAgICAgaXMgZW1pdGVkLlxuICpcbiAqXG4gKiAgZS5nOlxuICpcbiAqICBgYGB0c1xuICpcbiAqICAgICAgPGF3LXNlY3Rpb24gdGl0bGU9XCJVc2VyIEluZm9ybWF0aW9uXCIgKG9uRWRpdCk9XCJvbkFkZFNvbWV0aGluZygkZXZlbnQpXCJcbiAqICAgICAgICAgICAgICAgICAgW2VkaXRhYmxlXT1cInRydWVcIiBbZWRpdE1vZGVdPVwiJ2V4dGVybmFsJ1wiID5cbiAqICAgICAgICAgICAgICAgICAgPGRpdj5cbiAqICAgICAgICAgICAgICAgICAgICAgIENvbnRlbnRcbiAqICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgIDwvYXctc2VjdGlvbj5cbiAqXG4gKiAgYGBgXG4gKlxuICogTm90ZTogV2hlbiB1c2luZyBlZGl0aW5nIG1vZGUgeW91IGhhdmUgdG8gY2FsbCBhdCB0aGUgZW5kIG9mIHRoZSBlZGl0aW5nIGN5Y2xlIG1ldGhvZFxuICogYGNvbXBsZXRlRWRpdGluZygpYCB0byBjb21taXQgZWRpdGluZyB3aGljaCBjaGFuZ2VzIGludGVybmFsIHN0YXRlIG9mIHRoZSBTZWN0aW9uLlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LXNlY3Rpb24nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInVpLWctMTIgc2VjdGlvbi1jb250YWluZXJcIlxuICAgICBbY2xhc3MuZWRpdGluZ109XCJlZGl0YWJsZSAmJiBlZGl0U3RhdGUgJiYgZWRpdE1vZGUgPT09ICdkZWZhdWx0J1wiPlxuXG4gICAgPHAtYWNjb3JkaW9uIChvbk9wZW4pPVwib25TZWN0aW9uT3BlbigkZXZlbnQpXCIgKG9uQ2xvc2UpPVwib25TZWN0aW9uQ2xvc2UoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgIFtzdHlsZUNsYXNzXT1cImFDbGFzcygpXCI+XG4gICAgICAgIDxwLWFjY29yZGlvblRhYiAjYWNjb3JkaW9uVGFiIFtzZWxlY3RlZF09XCJvcGVuZWRcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZUNsb3NlXCI+XG4gICAgICAgICAgICA8cC1oZWFkZXI+XG4gICAgICAgICAgICAgICAgPCEtLSB0aXRsZSBhbmQgZGVzY3JpcHRpb24gLS0+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInNlY3Rpb24taGVhZGVyLWNvbnRhaW5lclwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VjdGlvbi10aXRsZVwiPnt7dGl0bGV9fTwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiaGFzRGVzY3JpcHRpb24oKVwiIGNsYXNzPVwic2VjdGlvbi1kZXNjcmlwdGlvblwiPnt7ZGVzY3JpcHRpb259fTwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gYWN0aW9uczogSGlkZSB3aGVuIGluIGVkaXRpbmcgYW5kIGVkaXRNb2RlIGlzIGRlZmF1bHQgLS0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCIoZWRpdGFibGUgJiYgIWVkaXRTdGF0ZSAmJiBlZGl0TW9kZSA9PT0gJ2RlZmF1bHQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGVkaXRhYmxlICYmIGVkaXRNb2RlID09PSAnZXh0ZXJuYWwnKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJzZWN0aW9uLWFjdGlvbnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1oeXBlcmxpbmsgKGFjdGlvbik9XCJvbkVkaXRBY3Rpb24oJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwic2FwLWljb24gc2VjdGlvbi1lZGl0LWFjdGlvblwiIFtuZ0NsYXNzXT1cImFjdGlvbkljb25cIj48L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWh5cGVybGluaz5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3AtaGVhZGVyPlxuXG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvcC1hY2NvcmRpb25UYWI+XG4gICAgPC9wLWFjY29yZGlvbj5cbiAgICA8IS0tXG4gICAgICAgIG5lZWQgdG8gcHV0IGl0IG91dHNpZGUgb2YgcC1hY2NvcmRpb24gb3RoZXJ3aXNlIGJ1dHRvbiB3aWxsIGluaGVyaXQgZGlmZmVyZW50XG4gICAgICAgIGNvbG9yIHNjaGVtZVxuICAgIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJzZWN0aW9uLWZvb3Rlci1jb250YWluZXJcIiAqbmdJZj1cImVkaXRhYmxlICYmIGVkaXRTdGF0ZSAmJlxuICAgICAgICAgICAgZWRpdE1vZGUgPT09ICdkZWZhdWx0J1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZm9vdGVyLWFjdGlvbnNcIj5cblxuICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFoYXNDdXN0b21BY3Rpb25zKClcIj5cbiAgICAgICAgICAgICAgICA8YXctYnV0dG9uIFtzdHlsZV09XCInc2Vjb25kYXJ5J1wiIHNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoYWN0aW9uKT1cIm9uQ2FuY2VsQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICBDYW5jZWxcbiAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAgICAgICAgICAgICAgICA8YXctYnV0dG9uIHNpemU9XCJzbWFsbFwiIChhY3Rpb24pPVwib25TYXZlQWN0aW9uLmVtaXQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICBTYXZlXG4gICAgICAgICAgICAgICAgPC9hdy1idXR0b24+XG4gICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1zZWN0aW9uLWFjdGlvbnNcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5gLFxuICAgIHN0eWxlczogW2Auc2VjdGlvbi1oZWFkZXItY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlfS5zZWN0aW9uLWNvbnRhaW5lcnttYXJnaW46MTBweCAwO2JhY2tncm91bmQtY29sb3I6I2ZmZjtwYWRkaW5nOi4yZW0gLjVlbTtib3JkZXI6MnB4IGRhc2hlZCB0cmFuc3BhcmVudH0uc2VjdGlvbi1jb250YWluZXIuZWRpdGluZ3tib3JkZXItY29sb3I6IzE5OWRlMH0uc2VjdGlvbi1jb250YWluZXIgOjpuZy1kZWVwIC51aS1hY2NvcmRpb24taGVhZGVyPmF7ZGlzcGxheTpmbGV4fS5zZWN0aW9uLWNvbnRhaW5lciA6Om5nLWRlZXAgLnVpLWFjY29yZGlvbi1oZWFkZXI+YSAudWktYWNjb3JkaW9uLXRvZ2dsZS1pY29ue2ZsZXg6MCAwIDMwcHg7cGFkZGluZy10b3A6MnB4fS5zZWN0aW9uLWNvbnRhaW5lciA6Om5nLWRlZXAgLnVpLWFjY29yZGlvbi1oZWFkZXI+YSBwLWhlYWRlcntmbGV4OjEgMH0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyLnVpLXN0YXRlLWRpc2FibGVke29wYWNpdHk6MX0uc2VjdGlvbi10aXRsZXtmb250LXNpemU6MS4xZW19LnNlY3Rpb24tZGVzY3JpcHRpb257Zm9udC1zaXplOi45ZW07cGFkZGluZzouNmVtIDAgLjJlbX0uc2VjdGlvbi1mb290ZXItY29udGFpbmVye21hcmdpbjoxZW0gMmVtIDA7cGFkZGluZzouOGVtIDAgMS41ZW0gLjhlbTtib3JkZXItdG9wOjFweCBzb2xpZCAjZDdkN2Q3fS5zZWN0aW9uLWZvb3Rlci1jb250YWluZXIgLmZvb3Rlci1hY3Rpb25ze2Rpc3BsYXk6aW5saW5lLWJsb2NrO3RleHQtYWxpZ246cmlnaHQ7d2lkdGg6MTAwJX0uc2VjdGlvbi1hY3Rpb25ze3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7ei1pbmRleDoxfS5zZWN0aW9uLWFjdGlvbnMgL2RlZXAvIGEubGluaywuc2VjdGlvbi1hY3Rpb25zIC9kZWVwLyBhLmxpbms6aG92ZXJ7cGFkZGluZzowO3RleHQtZGVjb3JhdGlvbjpub25lfS5zZWN0aW9uLWVkaXQtYWN0aW9ue2ZvbnQtc2l6ZToxLjVlbTtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOi4xZW0gMCAuMWVtIC41ZW07Y3Vyc29yOnBvaW50ZXJ9LnNlY3Rpb24tZWRpdC1hY3Rpb24uaWNvbi1lZGl0e2ZvbnQtc2l6ZToxLjRlbX0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVye2NvbG9yOiMzNjM2MzY7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDojZmZmIWltcG9ydGFudDtwYWRkaW5nOjAgMWVtfS5zZWN0aW9uLWNvbnRhaW5lciAvZGVlcC8gLnVpLWFjY29yZGlvbi1jb250ZW50e2JvcmRlcjpub25lO3BhZGRpbmc6MWVtIDJlbX0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyBhW3JvbGU9dGFiXXtwYWRkaW5nOi43NWVtIDA7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlci51aS1zdGF0ZS1hY3RpdmUgL2RlZXAvIGFbcm9sZT10YWJde2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNkN2Q3ZDc7Y29sb3I6IzM2MzYzNn0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC5zZWN0aW9uLW5vLWhlYWRlciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXJ7aGVpZ2h0OjFweH0uc2VjdGlvbi1jb250YWluZXIgL2RlZXAvIC5zZWN0aW9uLW5vLWhlYWRlciAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIudWktc3RhdGUtYWN0aXZlIC9kZWVwLyBhW3JvbGU9dGFiXXtib3JkZXItYm90dG9tOm5vbmV9LnNlY3Rpb24tY29udGFpbmVyIC9kZWVwLyAuc2VjdGlvbi1uby1oZWFkZXIgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC5zZWN0aW9uLWVkaXQtYWN0aW9ue2N1cnNvcjpwb2ludGVyIWltcG9ydGFudH06aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgL2RlZXAvIC5waS5waS1jYXJldC1kb3duLDpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlciAvZGVlcC8gLnBpLnBpLWNhcmV0LXJpZ2h0e2ZvbnQtZmFtaWx5OlwiU0FQIGljb24gZm9udHNcIjtmb250LXNpemU6MS4xZW07dG9wOi44ZW07bGVmdDouMWVtO2NvbG9yOiM3Njc2NzY7bWFyZ2luLXRvcDowfTpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlci51aS1zdGF0ZS1kaXNhYmxlZCAvZGVlcC8gLmZhLDpob3N0IC9kZWVwLyAudWktYWNjb3JkaW9uLWhlYWRlci51aS1zdGF0ZS1kaXNhYmxlZCAvZGVlcC8gLnBpe2Rpc3BsYXk6bm9uZX06aG9zdCAvZGVlcC8gLnVpLWFjY29yZGlvbi1oZWFkZXIgL2RlZXAvIC5waS5waS1jYXJldC1yaWdodDpiZWZvcmV7Y29udGVudDpcIlxcXFxlMWVkXCJ9Omhvc3QgL2RlZXAvIC51aS1hY2NvcmRpb24taGVhZGVyIC9kZWVwLyAucGkucGktY2FyZXQtZG93bjpiZWZvcmV7Y29udGVudDpcIlxcXFxlMWVmXCJ9YF1cbn0pXG5leHBvcnQgY2xhc3MgU2VjdGlvbkNvbXBvbmVudCBleHRlbmRzIEJhc2VDb21wb25lbnRcbntcblxuICAgIC8qKlxuICAgICAqIFRoZSB0aXRsZSBvZiB0aGlzIHNlY3Rpb25cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHRpdGxlOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhpcyBzZWN0aW9uLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNob3VsZCB0aGlzIHNlY3Rpb24gYmUgb3BlbmVkIGF0IHRoZSBzdGFydC4gRGVmYXVsdCBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBvcGVuZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIHNlY3Rpb24gY2FuIGJlIGNsb3NlZCBvciBub3QuXG4gICAgICoqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzYWJsZUNsb3NlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgc2VjdGlvbiBpcyBpbiBFZGl0U3RhdGUgb3Igbm90LlxuICAgICAqXG4gICAgICogV2hlbiBpbiBlZGl0aW5nIHN0YXRlIGFuZCB3ZSBzaG93IFwiQ2FuY2VsIC8gU2F2ZVwiIGJ1dHRvbiBkZXZlbG9wZXIgbmVlZHMgdXNlIHRoaXMgYmluZGluZ1xuICAgICAqIHRvIGNvbnRyb2wgdGhlIHN0YXRlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdFN0YXRlOiBib29sZWFuID0gZmFsc2U7XG5cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgRWRpdGluZyBtb2RlLiBUZWxscyB0aGUgY29tcG9uZW50cyBpZiBpdHMgaXRzIGRlZmF1bHQgYmVoYXZpb3Igb3IgZHJpdmVuIGJ5XG4gICAgICogYXBwbGljYXRpb24gdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiB7QHNlZSBFZGl0TW9kZX1cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZWRpdE1vZGU6IEVkaXRNb2RlID0gJ2RlZmF1bHQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXZlbG9wZXIgY2FuIHByb3ZpZGUgY3VzdG9tIEVkaXQgYWN0aW9uIGljb24gdGhhdCB3aWxsIGFwcGVhciBpbiB0aGUgcmlnaHQgdG9wIGNvcm5lclxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWN0aW9uSWNvbjogc3RyaW5nID0gJ2ljb24tZWRpdCc7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgZnVsbHkgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlY3Rpb24gaXMgZnVsbHkgY2xvc2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uQ2xvc2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRWRpdCBzdGF0ZSB0byBicm9hZGNhc3Qgc3RhdGUgb2YgY3VycmVudCBzZWN0aW9uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25FZGl0OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbiBlZGl0aW5nIHN0YXRlIGFuZCBkZWZhdWx0IGJ1dHRvbnMgYXJlIHJlbmRlcmVkIG9uIGNsaWNrIGJyb2FkY2FzdCBDYW5jZWwgYWN0aW9uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DYW5jZWxBY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGluIGVkaXRpbmcgc3RhdGUgYW5kIGRlZmF1bHQgYnV0dG9ucyBhcmUgcmVuZGVyZWQgb24gY2xpY2sgYnJvYWRjYXN0IFNhdmUgYWN0aW9uXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25TYXZlQWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgQE91dHB1dCgpXG4gICAgb25FZGl0aW5nQ29tcGxldGU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogTG9jYWwgdmFyaWFibGUgb24gd2hldGhlciB0aGlzIHNlY3Rpb24gaXMgZXhwYW5kZWQgb3Igbm90LlxuICAgICAqIERpZmZlcnMgZnJvbSAnb3BlbmVkJy4gb3BlbmVkIGlzIGFuIGlucHV0IHBhcmFtZXRlciBhbmQgaXQgZG9lc24ndCB0cmFja1xuICAgICAqIGN1cnJlbnQgc2VjdGlvbiBleHBhbmRlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICBleHBhbmRlZDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIGludGVybmFsIGFjY29yZGlvblRhYlxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2FjY29yZGlvblRhYicpXG4gICAgcHJpdmF0ZSBhY2NvcmRpb25UYWI6IEFjY29yZGlvblRhYjtcblxuXG4gICAgLyoqXG4gICAgICogU2F2ZSByZWZlcmVuY2UgdG8gZGV2ZWxvcGVyJ3MgZGVmaW5lZCBhY3Rpb25zIHNvIGlmIHdlIGNhbiBoaWRlIGRlZmF1bHQgb25lc1xuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoU2VjdGlvbkFjdGlvbnNDb21wb25lbnQpXG4gICAgY3VzdG9tQWN0aW9uczogU2VjdGlvbkFjdGlvbnNDb21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbWVudDogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgLy8gSWYgSSBoYXZlIG5vdCBoZWFkZXIsIHRoZW4gSSBjYW4ndCBjbG9zZSB0aGUgc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLmlzSGVhZGVyRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZUNsb3NlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIEkgY2FuJ3QgY2xvc2UgdGhlIHNlY3Rpb24sIHRoZW4gaXQgc2hvdWxkIGRlZmF1bHQgb3Blbi5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGV4cGFuZGVkIHN0YXRlLlxuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdGhpcy5vcGVuZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9uJ3QgZGlzcGxheSBoZWFkZXIgYXJlYSBpZiBJIGRvbid0IGhhdmUgdGl0bGUgYW5kIGRlc2NyaXB0aW9uLlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0hlYWRlckRpc3BsYXllZCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGlzUHJlc2VudCh0aGlzLnRpdGxlKSB8fCBpc1ByZXNlbnQodGhpcy5kZXNjcmlwdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENzcyBDbGFzcyB0aGF0IGNvbnRyb2wgdGhlIGxvb2sgYW5kIGZlZWwgZm9yIHNlY3Rpb24gY29tcG9uZW50LlxuICAgICAqL1xuICAgIGFDbGFzcygpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5pc0hlYWRlckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3NlY3Rpb24tbm8taGVhZGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaW5jZSB3ZSBpbnRyb2R1Y2VkIGJ1dHRvbnMgYW5kIGVkaXRTdGF0ZSB0aGUgZGVjaXNpb24gb24gd2hlbiB0byBleGl0IGVkaXRpbmcgbW9kZVxuICAgICAqIHNob3VsZCBiZSBvbiB0aGUgZGV2ZWxvcGVyIHVzaW5nIHRoaXMgY29tcG9uZW50IHRoZXJlZm9yZSBvbmx5IHN0YXJ0RWRpdGluZ1xuICAgICAqXG4gICAgICovXG4gICAgb25FZGl0QWN0aW9uKCRldmVudDogYW55KTogdm9pZFxuICAgIHtcblxuICAgICAgICAvLyB3aGVuIGluIGVkaXRpbmcgbWFrZSBzdXJlIHdlIGRvbnQgc3dpdGNoIHN0YXRlIGFzIHRoZXJlIGNhbiBiZSBzb21lIEZvcm0gZXJyb3JzXG4gICAgICAgIC8vIHdoaWNoIG5lZWRzIHRvIGJlIGhhbmRsZWQgYnkgZGV2ZWxvcGVyIGFuZCBvbmx5IHRoZW4gY2hhbmdlIHRoZSBlZGl0U3RhdGVcbiAgICAgICAgaWYgKCF0aGlzLmVkaXRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lZGl0U3RhdGUgPSAhdGhpcy5lZGl0U3RhdGU7XG4gICAgICAgICAgICBsZXQgc3RhdGU6IHN0cmluZyA9ICh0aGlzLmVkaXRTdGF0ZSkgPyAnaW5FZGl0JyA6ICdub3RJbkVkaXQnO1xuXG4gICAgICAgICAgICB0aGlzLm9uRWRpdC5lbWl0KHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgb3JpZ2luYWwgZXZlbnQgZnJvbSBidWJibGluZyB1cC4gQmVjYXVzZSB0aGUgZWRpdCBpY29uIGlzIGluc2lkZVxuICAgICAgICAvLyB0aGUgaGVhZGVyLiBJZiB0aGUgY2xpY2sgZXZlbiBpcyBidWJibGVkIHVwLCB0aGlzIGV2ZW50IHdpbGwgY2F1c2UgdGhlIHNlY3Rpb24gdG9cbiAgICAgICAgLy8gZXhwYW5kIG9yIGNvbGxhcHNlLlxuICAgICAgICBpZiAoaXNQcmVzZW50KCRldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgICRldmVudC5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICRldmVudC5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzRGVzY3JpcHRpb24oKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmRlc2NyaXB0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoaXMgc2VjdGlvbiwgaWYgaXQncyBhbHJlYWR5IG9wZW4sIHdpbGwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBvcGVuKGV2ZW50PzogYW55KTogdm9pZFxuICAgIHtcblxuICAgICAgICBpZiAoIXRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjb3JkaW9uVGFiLnRvZ2dsZShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGlzIHNlY3Rpb24sIGlmIGl0J3MgYWxyZWFkeSBjbG9zZSwgd2lsbCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIGNsb3NlKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5hY2NvcmRpb25UYWIudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhY2NvcmRpb24gaXMgb3BlbmVkXG4gICAgICpcbiAgICAgKi9cbiAgICBvblNlY3Rpb25PcGVuKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCgnb3BlbicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhY2NvcmRpb24gaXMgY2xvc2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBvblNlY3Rpb25DbG9zZShldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UuZW1pdCgnY2xvc2UnKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgdXMgaWYgd2UgbmVlZCB0byByZW5kZXIgYXBwbGljYXRpb24gZGVmaW5lZCBjdXN0b20gYWN0aW9uc1xuICAgICAqXG4gICAgICovXG4gICAgaGFzQ3VzdG9tQWN0aW9ucygpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuY3VzdG9tQWN0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW1pdCB0aGUgZWRpdGluZyBzdGF0ZSBiYWNrIHRvIG5vbi1lZGl0YWJsZVxuICAgICAqL1xuICAgIGNvbXBsZXRlRWRpdGluZygpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmVkaXRTdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uRWRpdGluZ0NvbXBsZXRlLmVtaXQodGhpcy5lZGl0U3RhdGUpO1xuICAgIH1cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1zdWJzZWN0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJzdWJzZWN0aW9uLXRpdGxlXCI+e3t0aXRsZX19PC9oND5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgICAgICBgLFxuICAgIHN0eWxlczogWycuc3Vic2VjdGlvbi10aXRsZSB7Y29sb3I6ICMzNjM2MzY7IH0nXVxufSlcbmV4cG9ydCBjbGFzcyBTdWJTZWN0aW9uQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBzdWIgc2VjdGlvblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcbn1cblxuXG4vKipcbiAqIERlZmluZXMgZWRpdGluZyBtb2RlcyBmb3IgdGhlIFNlY3Rpb25zLiBEZWZhdWx0IG1lYW5zIHdlIHNob3cgY2FuY2VsIC8gc2F2ZSBidXR0b25zIGFuZCBoaWRlXG4gKiBlZGl0IGljb25zIHdoZW4gaW4gZWRpdGluZy4gZXh0ZXJuYWwgaXMgZHJpdmVuIGJ5IGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydCB0eXBlIEVkaXRNb2RlID0gJ2RlZmF1bHQnIHwgJ2V4dGVybmFsJztcblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBcmliYUNvcmVNb2R1bGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtBV1N0cmluZ0ZpZWxkTW9kdWxlfSBmcm9tICcuLi9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FjY29yZGlvbk1vZHVsZSwgU2hhcmVkTW9kdWxlfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtTZWN0aW9uQWN0aW9uc0NvbXBvbmVudCwgU2VjdGlvbkNvbXBvbmVudCwgU3ViU2VjdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9zZWN0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuLi9oeXBlcmxpbmsvaHlwZXJsaW5rLm1vZHVsZSc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuLi9idXR0b24vYnV0dG9uLm1vZHVsZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU3ViU2VjdGlvbkNvbXBvbmVudCxcbiAgICAgICAgU2VjdGlvbkFjdGlvbnNDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBY2NvcmRpb25Nb2R1bGUsXG4gICAgICAgIEFyaWJhQ29yZU1vZHVsZSxcbiAgICAgICAgQVdTdHJpbmdGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXQnV0dG9uTW9kdWxlLFxuICAgICAgICBTaGFyZWRNb2R1bGVcbiAgICBdLFxuXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIFNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFN1YlNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFNlY3Rpb25Db21wb25lbnQsXG4gICAgICAgIFNlY3Rpb25BY3Rpb25zQ29tcG9uZW50LFxuICAgICAgICBTdWJTZWN0aW9uQ29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV1NlY3Rpb25Nb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIElucHV0LFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7QVdEYXRhVGFibGV9IGZyb20gJy4uL2F3LWRhdGF0YWJsZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7Qm9vbGVhbldyYXBwZXIsIEVudmlyb25tZW50LCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtCYXNlQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2Jhc2UuY29tcG9uZW50JztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuXG5leHBvcnQgdHlwZSBEVEhBbGlnbm1lbnQgPSAnbGVmdCcgfCAnY2VudGVyJyB8ICdyaWdodCc7XG5cblxuLyoqXG4gKiBEVENvbHVtbiByZXByZXNlbnQgc2luZ2xlIGNvbHVtbiBpbmNsdWRpbmcgaGVhZGVyIGFuZCBpdHMgYm9keS4gRWFjaCBjb2x1bW4gaGFzIGl0cyBvd25cbiAqIHJlbmRlcmVyVGVtcGxhdGUgd2hpY2ggYSBlbnRyeSB0byB0aGlzIGNvbXBvbmVudC5cbiAqXG4gKiBLZWVwaW5nIHRoaXMgc2VwYXJhdGUgZnJvbSB0aGUgZGF0YXRhYmxlIHdoZXJlIERUIGlzIG5vdCByZWFsbHkgYXdhcmUgd2hhdCBpdCBpcyByZW5kZXJpbmcsXG4gKiBpdCBhbGxvd3MgdXMgbW9yZSBmbGV4aWJpbGl0eSBpbiB0ZXJtcyBvZiBkaWZmZXJlbnQgdHlwZSBvZiBjb2x1bW4gaW5oZXJpdGluZyBmcm9tIHRoaXNcbiAqIG9uZS4uIFN1Y2ggYXM6XG4gKiAgRFRSb3dEZXRhaWwgIGNvbHVtblxuICogIERUU2luZ2xlU2VsZWN0aW9uIGNvbHVtblxuICogIERUTXVsdGlTZWxlY3Rpb24gY29sdW1uXG4gKlxuICogVGhpcyB3YXkgd2UgZG9uJ3QgZG8gSUYvVEhFTi9FTFNFIGluc2lkZSB0aGUgZGF0YXRhYmxlIGFuZCB0cnlpbmcgdG8gY3JlYXRlIGRpZmZlcmVudCBjYXNlcy5cbiAqXG4gKiAgVGhlbiBsYXRlciBvbiB0aGlzIHdpbGwgbGV0IHVzIGNyZWF0ZSBhZGRpdGlvbmFsIGxvZ2ljIGZvciB0aGUgcGl2b3RhbCBsYXlvdXQuIEJlY2F1c2UgRFRcbiAqICBkb2VzIGtub3cgYW55dGhpbmcgYWJvdXQgdGhlIHR5cGUgb2YgdGhlIGNvbHVtbiBzbyB3aGF0ZXZlciBpcyBhZGRlZCB0byB0aGUgRFQuY29sdW1ucyBpdFxuICogIHdpbGwgYmUgcmVuZGVyZWQuXG4gKlxuICpcbiAqICBDb2x1bW5zIGNhbiBiZSBhbHNvIGZyb3plbiBtZWFuaW5nIGlmIHRoZSBjb250ZW50IG92ZXJmbG93cyB0aGV5IGRvbnQgc2Nyb2xsLiBUbyBtYWtlIHRoZVxuICogIGNvbHVtbiBmcm96ZW4gd2UgbmVlZCB0byB1c2UgW2Zyb3plbl0gYmluZGluZyBhbmQgc2UgaXQgdG8gVFJVRSBwbHVzIGl0IHJlcXVpcmVzIGEgW3dpZHRoXVxuICogIGJpbmRpbmcgdG8gYmUgc2V0IChpbiBweCkuXG4gKiAgV2UgbmVlZCB0aGlzIHRvIGJlIGFibGUgdG8gcHJvcGVybHkgcG9zaXRpb24gdGhlIHNlY29uZCB0YWJsZSB3aGljaCBpcyBjaGFuZ2VkIHRvIGFic29sdXRlXG4gKiAgcG9zaXRpb25pbmcuXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtY29sdW1uMicsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgVG8gbWFrZSBpdCBtb3JlIHJlYWRhYmxlIEVhY2ggQ29sdW1uIHR5cGUgaGFzIGl0cyBvd24gcmVuZGVyaW5nIHRlbXBsYXRlIGluc3RlYWQgb2YgcHV0dGluZ1xuICAgIGFsbCB0aGlzIGludG8gZGF0YXRhYmxlIGFzIHRoaXMgaXMgbW9yZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY29sdW1uLiBBbmQgdGhlIG1haW4gZ29hbFxuICAgIHdhcyB0cnkgdG8gYmUgbW9kdWxhciBhcyBwb3NzaWJsZS4gV2hlbiBUaGVyZSB3aWxsIGJlIGRpZmZlcmVudCB0eXBlcyBvZiBjb2x1bW5zXG5cbiAgICAtIFJlZ3VsYXIgRFRDb2x1bW4gKGN1cnJlbnQgaW1wbGVtZW50YXRpb24pLFxuICAgIC0gU2VsZWN0aW9uQ29sdW1uIChTaW5nbGUvTXVsdGkgc2VsZWN0KSAtIHRvZG8sXG4gICAgLSBEZXRhaWxSb3cgY29sdW1uLCB0aGVuIHBpdm90YWwgY29sbHVtbiB0byByZW5kZXIgcm93L2NvbHVtbi9kZXRhaWwgYXR0cmlidXRlcyAtIHRvZG8uXG5cbiAgICBXaGVuIGltcGxlbWVudGluZyBuZXcgY29sdW1uIHR5cGUgeW91IGp1c3QgaW5oZXJpdCB0aGlzIERUQ29sdW1uQ29tcG9uZW50IGFuZCBwcm92aWRlIHlvdXJcbiAgICBvd24gcmVuZGVyaW5nIHRlbXBsYXRlIGFuZCBEVCB0YWtlIGNhcmUgb2YgdGhlIHJlc3QuXG5cbiAgICB0b2RvOiBXZSBoYXZlIFNpbmdsZVNlbGVjdCwgTXVsdGlzZWxlY3QgcmVuZGVyaW5nIHRlbXBsYXRlIHRoYXQgaXMgQWRkZWQgcHJvZ3JhbWF0aWNhbGx5XG4gICAgdG9kbzogV2UgaGF2ZSBwaXZvdGFsIHJlbmRlcmluZyB0ZW1wbGF0ZVxuXG5cbi0tPlxuPG5nLXRlbXBsYXRlICNyZW5kZXJpbmdUZW1wbGF0ZSBsZXQtaXNIZWFkZXIgbGV0LWlzU3ViSGVhZGVyPVwiaXNTdWJIZWFkZXJcIiBsZXQtY29sdW1uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICBsZXQtZGF0YVRvUmVuZGVyPVwiZGF0YVwiXG4gICAgICAgICAgICAgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIlxuICAgICAgICAgICAgIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEhlYWRlclwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBpc1N1YkhlYWRlciwgY29sdW1uSW5kZXg6Y29sdW1uSW5kZXgsIGRhdGE6IGRhdGFUb1JlbmRlcixcbiAgICAgICAgICAgICAgICAgcm93SW5kZXg6cm93SW5kZXh9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIiFpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEJvZHlcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogY29sdW1uLCBkYXRhOmRhdGFUb1JlbmRlcixyb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48IS0tXG4gICAgVGVtcGxhdGVzIGZvciBoZWFkZXIgY29sdW1ucy4gSGVyZSB3ZSBhcmUgcmVuZGVyaW5nIHR3byB0eXBlcy4gSGVhZGVyIGFuZCBTdWJoZWFkZXIgdGhhdCB3ZVxuICAgIHVzdWFsbHkgdXNlIGhlcmUgYXMgc29tZSBraW5kIG9mIHN1bW1hcnkgY29sdW1ucy4gTm90IHJlYWxseSBoYXZpbmcgc3VtbWFyeSBhdCB0aGUgYm90dG9tIGxpa2Ugb3RoZXJcbiAgICBEVC5cblxuICAgIFRIIGNvbHVtbiBhbmQgdGhlaXIgdGV4dCBhcmUgdXN1YWxseSB1bnNlbGVjdGFibGUgYW5kIG1vc3Qgb2YgdGhlc2Ugd2VyZSBpbmhlcml0ZWQgZnJvbVxuICAgIG9yaWdpbmFsIFByaW1lTmcgRFQgZXZlbiBub3QgbWFueSB0aGluZ3MgZ290IGxlZnQgYWZ0ZXIgd2UgcmVmYWN0b3IgdGhpcyBidXQgdGhlIGlkZWEgaXMgdGhlXG4gICAgc2FtZS5cblxuICAgIEVhY2ggY2VsbCBoYXMgaXRzIGR0LWNlbGwtZGVmIGNsYXNzIHRoYXQgc2V0cyBkZWZhdWx0IHN0eWxpbmcgbGlrZSBmb250LCBiYWNrZ3JvdW5kLCBhbGlnbm1lbnRcbiAgICBwYWRkaW5nLCBldGNzLi5cblxuXG4tLT5cbjxuZy10ZW1wbGF0ZSAjY29sSGVhZGVyIGxldC1pc1N1YkhlYWRlciBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8dGggI2hlYWRlckNlbGwxIFtjbGFzc109XCJoZWFkZXJTdHlsZUNsYXNzfHxzdHlsZUNsYXNzXCIgKm5nSWY9XCIhaXNTdWJIZWFkZXJcIlxuICAgICAgICAoY2xpY2spPVwiaGFuZGxlSGVhZGVyQ2xpY2soJGV2ZW50LCBoZWFkZXJDZWxsMSlcIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtdS11bnNlbGVjdGFibGUtdGV4dCcgOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1jZWxsLWRlZic6IGR0LnNlbGVjdGlvbk1vZGUgIT09ICdjZWxsJyB8fCAoIWR0LmlzT3V0bGluZSgpIHx8ICFkdC5waXZvdGFsTGF5b3V0KSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LXUtc29ydGFibGUnOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWlzLWFjdGl2ZSc6IGlzU29ydGVkKCksXG4gICAgICAgICAgICAgICAgICAgICdkdC1pcy1oaWRkZW4nOiAhaXNWaXNpYmxlfVwiXG4gICAgICAgIFthdHRyLndpZHRoXT1cIndpZHRoXCJcbiAgICAgICAgW2F0dHIuYWxpZ25dPVwiYWxpZ25cIlxuICAgICAgICBbYXR0ci50YWJpbmRleF09XCJzb3J0YWJsZSA/IDEgOiBudWxsXCJcbiAgICAgICAgW21heFdpZHRoXT1cIm1heFdpZHRoUHhcIlxuICAgID5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiZHQuaGVhZGVyRmlsdGVyVGVtcGxhdGUgJiYgY29sdW1uSW5kZXggPT09IDAgXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHQuaGVhZGVyRmlsdGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8IS0tXG4gICAgICAgICAgICB3aGVuIGNlbGwgYXJlIHNlbGVjdGFibGUgd2UgbmVlZCB0d28gdmVyc2lvbiB3aGVyZSBvbmUgd3JhcCB0aGUgY2VsbCBjb250ZW50IGluIGRpdlxuICAgICAgICAtLT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzSGVhZGVyU2VsZWN0YWJsZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic2VsZWN0YWJsZUhlYWRlckNlbGw7IGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXN9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNIZWFkZXJTZWxlY3RhYmxlKClcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub25TZWxlY3RhYmxlSGVhZGVyQ2VsbDsgY29udGV4dDogeyRpbXBsaWNpdDogdGhpc31cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdGg+XG5cbiAgICA8dGggI2hlYWRlckNlbGwyIFtjbGFzc109XCJoZWFkZXJTdHlsZUNsYXNzfHxzdHlsZUNsYXNzXCIgKm5nSWY9XCJpc1N1YkhlYWRlclwiXG4gICAgICAgIFthdHRyLndpZHRoXT1cIndpZHRoXCJcbiAgICAgICAgW2F0dHIuYWxpZ25dPVwiYWxpZ25cIlxuICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWlzLWRlZmF1bHQgZHQtY2VsbC1kZWYgZHQtc3ViLWhlYWRlciBkdC11LXVuc2VsZWN0YWJsZS10ZXh0Jzp0cnVlfVwiXG4gICAgICAgIFttYXhXaWR0aF09XCJtYXhXaWR0aFB4XCI+XG5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtdGl0bGVcIiAqbmdJZj1cImR0LnNob3dTdWJIZWFkZXIgJiYgc3ViSGVhZGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJzdWJIZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvc3Bhbj5cbiAgICA8L3RoPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48IS0tXG4gICAgVGVtcGxhdGUgZm9yIHRoZSBib2R5ID0gdGhlIFRELiBGb3IgdGhlIGJvZHkgYW5kIHdlIG1pZ2h0IHdhbnQgdG8gZG8gdGhlIHNhbWUgZm9yIGhlYWRlciB3ZVxuICAgIGFsbG93IHRvIGhhdmUgY2FsY3VsYXRlZCBib2R5IGNsYXNzIHRoYXQgY29tZXMgZnJvbSB0aGUgYXBwbGljYXRpb24uIFNvIGJhc2VkIG9uIHRoZSBkYXRhIHR5cGVzXG4gICAgeW91IG1pZ2h0IHdhbnQgdG8gYXBwbHkgZGlmZmVyZW50IGNsYXNzIGluIG9yZGVyIHRvIGFwcGx5IGN1c3RvbSBzdHlsaW5nLlxuLS0+XG48bmctdGVtcGxhdGUgI2NvbEJvZHkgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDx0ZCAjY2VsbCBbY2xhc3NdPVwiZHluYW1pY0JvZHlDbGFzcyhkYXRhKVwiXG4gICAgICAgIChjbGljayk9XCJkdC5vbkNlbGxTZWxlY3Rpb25DaGFuZ2UoY2VsbCwgdGhpcywgZGF0YSlcIlxuICAgICAgICBbYXR0ci53aWR0aF09XCJ3aWR0aFwiXG4gICAgICAgIFthdHRyLmFsaWduXT1cImFsaWduXCJcbiAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCc6IHRydWUsXG4gICAgICAgICdkdC1jZWxsLWRlZic6ICFpc0NlbGxTZWxlY3RhYmxlKGRhdGEpLFxuICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWlzVmlzaWJsZX1cIlxuICAgICAgICBbbWF4V2lkdGhdPVwibWF4V2lkdGhQeFwiPlxuXG4gICAgICAgIDwhLS1cbiAgICAgICAgICAgIFNpbmNlIHdlIG5lZWQgdG8gc3VwcG9ydCBjZWxsIHNlbGVjdGlvbiB3aGVuIHdlIG5lZWQgdG8gZHJhdyBib3JkZXIgYXJvdW5kIGl0XG4gICAgICAgICAgICBXZSBhcmUgd3JhcHBpbmcgc3VjaCBzZWxscyB3aXRoIGRpdiB3aGljaCBnaXZlcyB1cyBiZXR0ZXIgZmxleGliaWxpdHlcbiAgICAgICAgLS0+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJpc0NlbGxTZWxlY3RhYmxlKGRhdGEpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwic2VsZWN0YWJsZUJvZHlDZWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4IH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWlzQ2VsbFNlbGVjdGFibGUoZGF0YSlcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub25TZWxlY3RhYmxlQm9keUNlbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvdGQ+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tXG4gICAgVG9kbzogY3JlYXRlIGJldHRlciBzb2x1dGlvbiBpbnN0ZWFkIG9mIHVzaW5nIGRpZmZlcmVudCB0ZW1wbGF0ZSBjcmVhdGUgZGlyZWN0aXZlIHRoYXQgd3JhcHNcbiAgICBpdCB3aXRoIHRoZSBkaXYgY29uZGl0aW9uYWxseVxuLS0+XG48bmctdGVtcGxhdGUgI3NlbGVjdGFibGVIZWFkZXJDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtY2VsbC1kZWYtc2VsZWN0YWJsZVwiXG4gICAgICAgICBbbmdDbGFzc109XCJ7J2R0LWNlbGwtc2VsZWN0ZWQnOiBkdC5pc0hlYWRlclNlbGVjdGVkKHRoaXMpfVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaGVhZGVyQ2VsbENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7JGltcGxpY2l0OiB0aGlzLCBkYXRhOiBkYXRhLCByb3dJbmRleDogcm93SW5kZXh9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI25vblNlbGVjdGFibGVIZWFkZXJDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlckNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2hlYWRlckNlbGxDb250ZW50IGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPHNwYW4gY2xhc3M9XCJkdC1jb2wtdGl0bGVcIiAqbmdJZj1cInNob3dDb2x1bW5MYWJlbCAmJiAhaGVhZGVyVGVtcGxhdGVcIj5cbiAgICAgICAgICAgICAgICB7e2xhYmVsfX1cbiAgICA8L3NwYW4+XG5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC10aXRsZVwiICpuZ0lmPVwic2hvd0NvbHVtbkxhYmVsICYmIGhlYWRlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHskaW1wbGljaXQ6IHRoaXMsIHJvd0RhdGE6IGRhdGEsIHJvd0luZGV4OiByb3dJbmRleCB9XCI+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvc3Bhbj5cblxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLXNvcnRhYmxlLWljb24gc2FwLWljb24gaWNvbi1zb3J0XCIgKm5nSWY9XCJzb3J0YWJsZVwiXG4gICAgICAgICAgW25nQ2xhc3NdPVwieydpY29uLXNvcnQtZGVzY2VuZGluZyc6IChnZXRTb3J0T3JkZXIoKSA9PSAtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnaWNvbi1zb3J0LWFzY2VuZGluZyc6IChnZXRTb3J0T3JkZXIoKSA9PSAxKX1cIj5cbiAgICA8L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjc2VsZWN0YWJsZUJvZHlDZWxsIGxldC1kYXRhPVwiZGF0YVwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCI+XG4gICAgPGRpdiBjbGFzcz1cImR0LWNlbGwtZGVmLXNlbGVjdGFibGVcIlxuICAgICAgICAgW25nQ2xhc3NdPVwieydkdC1jZWxsLXNlbGVjdGVkJzogZHQuaXNCb2R5Q2VsbFNlbGVjdGVkKHRoaXMsIGRhdGEpfVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keUNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNub25TZWxlY3RhYmxlQm9keUNlbGwgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keUNlbGxDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgZGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2JvZHlDZWxsQ29udGVudCBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgIDwhLS1cbiAgICAgICAgICAgd2hlbiBubyB0ZW1wbGF0ZSBpcyB1c2VkIHVzZSBvdXIgRmllbGRQYXRoIHRvIGFjY2VzcyB0aGUgb2JqZWN0IHZhbHVlIGJhc2VkIG9uIHRoZVxuICAgICAgICAgICBrZXkgYmluZGluZ1xuICAgICAgICAtLT5cbiAgICA8c3BhbiBjbGFzcz1cImR0LWNvbC1jZWxsLWRhdGFcIiAqbmdJZj1cIiFib2R5VGVtcGxhdGVcIj5cbiAgICAgICAgICAgIHt7ZHQuZ2V0VmFsdWUoZGF0YSwga2V5KX19XG4gICAgICAgIDwvc3Bhbj5cblxuXG4gICAgPCEtLVxuICAgICAgICBJbiBjYXNlIGFwcGxpY2F0aW9uIHdhbnRzIHRvIHByb3ZpZGUgdGhlaXIgb3duIGNlbGwgY29tcG9uZW50IHRoZXkgdXNlXG4gICAgICAgICNib2R5IG5nLXRlbXBsYXRlIHRvIGRvIHNvLlxuICAgIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiZHQtY29sLWNlbGwtZGF0YVwiICpuZ0lmPVwiYm9keVRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiYm9keVRlbXBsYXRlO1xuICAgICAgICAgICAgY29udGV4dDogeyRpbXBsaWNpdDogdGhpcywgcm93RGF0YTogZGF0YSwgcm93SW5kZXg6IHJvd0luZGV4fVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgLmR0LXNvcnRhYmxlLWNvbHtjdXJzb3I6cG9pbnRlcn0uZHQtY29sLXNvcnRhYmxlLWljb257ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6LjEyNWVtfXRoLmR0LWNlbGwtZGVme2ZvbnQtd2VpZ2h0OjQwMDtjb2xvcjojNGE0YTRhfXRoLmR0LWlzLWRlZmF1bHR7YmFja2dyb3VuZC1jb2xvcjojZjJmMmYyO3doaXRlLXNwYWNlOm5vd3JhcH10aC5kdC1pcy1kZWZhdWx0LmR0LWNlbGwtZGVmOm5vdCguZHQtc3ViLWhlYWRlcil7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZjJmMmYyfXRoLmR0LXN1Yi1oZWFkZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZmfXRoIC5kdC1jZWxsLXNlbGVjdGVke2JvcmRlci1jb2xvcjojNThiOTU3fXRkIC5kdC1jZWxsLXNlbGVjdGVke2JvcmRlci1sZWZ0LWNvbG9yOiM0ZjlmY2Z9LmR0LXJvb3Qtc2VjdGlvbiAuZHQtc2VsZWN0aW9uLWNvbHVtbiwuZHQtc2VsZWN0aW9uLWNvbHVtbnt3aWR0aDo0NnB4O3BhZGRpbmc6MCAxMnB4fS5kdC1waXZvdC1sYXlvdXQgdGQuZHQtc2VsZWN0aW9uLWNvbHVtbix0aC5kdC1zZWxlY3Rpb24tY29sdW1ue2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH10aGVhZCB0cjpmaXJzdC1jaGlsZCB0aHtib3JkZXItdG9wLWNvbG9yOnRyYW5zcGFyZW50fXRib2R5IHRyOmxhc3QtY2hpbGQ6bm90KC5kdC1kcmFnLXJvdy1ib3R0b20pIHRke2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnR9dGQ6Zmlyc3QtY2hpbGQsdGg6Zmlyc3QtY2hpbGR7Ym9yZGVyLWxlZnQtY29sb3I6dHJhbnNwYXJlbnR9dGQ6bGFzdC1jaGlsZCx0aDpsYXN0LWNoaWxke2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH10Ym9keSAuZHQtZHJhZy1yb3ctdG9wPnRke2JhY2tncm91bmQ6bGluZWFyLWdyYWRpZW50KDBkZWcsI2ZmZiAwLCNmZmYgOTclLCMwMjcxZDIgMTAwJSl9dGJvZHkgLmR0LWRyYWctcm93LWJvdHRvbT50ZHtiYWNrZ3JvdW5kOmxpbmVhci1ncmFkaWVudCgxODBkZWcsI2ZmZiAwLCNmZmYgOTclLCMwMjcxZDIgMTAwJSl9dGJvZHkgLmR0LWRyYWctcm93LWJvdGg+dGR7YmFja2dyb3VuZDpsaW5lYXItZ3JhZGllbnQoMGRlZywjMDI3MWQyIDAsI2ZmZiAzJSwjZmZmIDk3JSwjMDI3MWQyIDEwMCUpfXRib2R5IC5kdC1yb3ctZHJhZ2dpbmc+dGR7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjO2NvbG9yOiNiOWI5Yjl9dGJvZHkgLmR0LXJvdy1kcmFnZ2luZyAudWktc3RhdGUtYWN0aXZle29wYWNpdHk6LjU7Y3Vyc29yOm5vdC1hbGxvd2VkfWBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbRG9tSGFuZGxlcl1cblxufSlcbmV4cG9ydCBjbGFzcyBEVENvbHVtbjJDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG4gICAgLyoqXG4gICAgICogQ29sdW1uIGhlYWRlciBsYWJlbC5cbiAgICAgKlxuICAgICAqIE9yIHlvdSBjYW4gdXNlIGhlYWRlclRlbXBsYXRlIHRvIGRlZmluZSB5b3VyIG93biB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbGFiZWw6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFdoYXQgZmllbGQgbmFtZSB0byByZWFkIGZyb20gdGhlIGdpdmVuIG9iamVjdFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAga2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENlbGwgYWxpZ25tZW50LiBJdCBpbnNlcnRzIHJlZ3VsYXIgYWxpZ24gYXR0cmlidXRlIHRvIHRoZSB0YWJsZSBjZWxsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFsaWduOiBEVEhBbGlnbm1lbnQgPSAnbGVmdCc7XG5cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkeW5hbWljIGNsYXNzIGJhc2VkIG9uIGRhdGEgYW5kIHRoZW4gaXRzIGFkZGVkIHRvIHRoZSB0YWJsZSBjZWxsIFREXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSWYgZmFsc2UgYXBwbGllcyBkdC1pcy1oaWRkZW4gc3R5bGUgdGhhdCBoaWRlcyB0aGUgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGlzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyBjb2x1bW4gYXMgc29ydGFibGUgd2hpY2ggbWVhbnMgc29ydGluZyBpY29uIGlzIGFkZGVkIHRvIHRoZSBoZWFkZXIgd2l0aCBzcGVjaWFsXG4gICAgICogc29ydGluZyBoYW5kbGluZ1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc29ydGFibGU6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNvcnRpbmcgZGlyZWN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNvcnRPcmRlcmluZzogc3RyaW5nID0gJ2Rlc2NlbmRpbmcnO1xuXG4gICAgLyoqXG4gICAgICogVGVsbHMgdGhlIHRlbXBsYXRlIGlmIHdoZXRoZXIgdG8gcmVuZGVyIGEgbGFiZWxcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd0NvbHVtbkxhYmVsOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdGF0aWMgY2xhc3MgdGhhdCBpcyBhZGRlZCB0byB0aGUgVEggaW50byB0aGUgaGVhZGVyLiBJdCBkb2VzIG5vdCByZWx5IG9uIGRhdGFcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaGVhZGVyU3R5bGVDbGFzczogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBzdGF0aWMgY2xhc3MgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGQgaW50byB0aGUgYm9keS4gSXQgZG9lcyBub3QgcmVseSBvbiBkYXRhXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvZHlTdHlsZUNsYXNzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZWQgdG9nZXRoZXIgd2l0aCBjZWxsIHNlbGVjdGlvbk1vZGUgdG8gdGVsbCB3aGljaCBjb2x1bW4gaXMgc2VsZWN0YWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3RhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2xvYmFsbHkgZGVmaW5lZCBIRUFERVIgdGVtcGxhdGUgZm9yIGN1cnJlbnQgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUdsb2JhbEhlYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2xvYmFsbHkgZGVmaW5lZCBTdWJIZWFkZXIgdGVtcGxhdGUgZm9yIGN1cnJlbnQgY29sdW1uXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUdsb2JhbFN1YkhlYWRlcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgZ2xvYmFsbHkgZGVmaW5lZCBib2R5IHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHVzZUdsb2JhbEJvZHk6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGUgY29sdW1uIGlzIGRhdGEgY29sdW1uICAtIGlmIGl0IGlzIHJlbmRlcmluZyBkYXRhIG9yIGp1c3QgYSBsYWJlbCBvciBzb21lXG4gICAgICogY29udHJvbFxuICAgICAqXG4gICAgICogVGhpcyBpcyBpbXBvcnRhbnQgd2hlbiBjYWxjdWxhdGluZyBhIGNvbHVtbiBzcGFuIGFuZCB3ZSBuZWVkIHRvIGtub3cgd2hpY2ggY29sdW1ucyBhcmUgb3JcbiAgICAgKiB3aWxsIGJlIGp1c3QgZm9yIHNlbGVjdGlvbiBjb250cm9scyBhbmQgd2hpY2ggaG9sZHMgZGF0YVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNEYXRhQ29sdW1uOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgY29sdW1uIHRoYXQgd2lsbCBub3Qgc2Nyb2xsIGhvcml6b250YWxseSB3aXRoIG90aGVyIGNvbHVtbnMuIENvbHVtbiBpc1xuICAgICAqIGZyb3plbi5cbiAgICAgKlxuICAgICAqIEZvciBzdWNoIGNvbHVtbnMgdGhhdCBhcmUgbWFya2VkIGFzIGZyb3plbiBiaW5kaW5nIFt3aWR0aF0gaXMgcmVxdWlyZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGZyb3plbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgTWF4IFdpZHRoIGZvciB0aGUgVEQuIEV2ZW4gVEQgZG9lcyBub3Qgc3VwcG9ydCB3ZSBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgd2lkdGhcbiAgICAgKiBmb3IgZWFjaCBjZWxsIGFuZCB0aGVuIGRlY2lkZSBpZiB3ZSBuZWVkIHRvIGVubGFyZ2UgdGhlIGNvbHVtbi5cbiAgICAgKlxuICAgICAqIEBFeHBlcmltYW50YWwgYmluZGluZyB0aGF0IGlzIGN1cnJlbnRseSB3b3JraW5nIGlmIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIGlzIGlubGluZVxuICAgICAqIGVsZW1lbnQgd2hlcmUgd2UgY2FuIGNvbnRyb2wgd2hpdGVzcGFjZSB3cmFwcGluZyBpbiBvcmRlciB0byBmaW5kIG91dCB0aGUgcmVhbCB3aWR0aFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgbWF4V2lkdGg6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWluV2lkdGggb24gdGhlIGNlbGwuIEFnYWluIGp1c3QgbGlrZSBtYXhXaWR0aCBjc3MgcHJvcGVybHkgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgICAqIHRoZSB0YWJsZSBzbyB0aGVyZSBpcyBhIHdvcmthcm91bmQgd2hlcmUgd2UgY3JlYXRlIGFkZGl0aW9uYWwgcm93IHRoYXQgc2V0cyBwYWRkaW5nIHJpZ2h0XG4gICAgICogYW5kIHRoaXMgd2lsbCBwcmV2ZW50IHRoZSBjb2x1bW4gdG8gY29sbGFwc2UgdW5kZXIgc3BlY2lmaWVkIHdpZHRoXG4gICAgICpcbiAgICAgKiB0b2RvOiBzdGlsbCBUQkRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIG1pbldpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBNYWluIHJlbmRlcmluZyB0ZW1wbGF0ZSB1c2VkIGJ5IGRhdGF0YWJsZSB0byByZW5kZXIgZWFjaCBjb2x1bW4uXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncmVuZGVyaW5nVGVtcGxhdGUnKVxuICAgIHJlbmRlcmVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gaGVhZGVyIHRlbXBsYXRlLiBJdCB3aWxsIG92ZXJyaWRlIHByb3ZpZGVkIGxhYmVsXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyJylcbiAgICBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBzdWJIZWFkZXIgdGVtcGxhdGUuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnc3ViSGVhZGVyJylcbiAgICBzdWJIZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEN1c3RvbSBib2R5IHRlbXBsYXRlIHRoYXQgd2lsbCBvdmVycmlkZSByZWFkIHZhbHVlIGZyb20gdGhlIFtrZXldIGJpbmRpbmdcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdib2R5JylcbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLi4uXG4gICAgICovXG4gICAgc29ydE9yZGVyOiBudW1iZXI7XG4gICAgbWF4V2lkdGhQeDogbnVtYmVyID0gMDtcbiAgICBtaW5XaWR0aFB4OiBudW1iZXIgPSAwO1xuICAgIHdpZHRoUHg6IG51bWJlciA9IDA7XG4gICAgd2lkZXN0Q2VsbDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBEYXRhdGFibGUgSW1wbGVtZW50YXRpb25zXG4gICAgICovXG4gICAgZHQ6IEFXRGF0YVRhYmxlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcikge1xuICAgICAgICBzdXBlcihlbnYpO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHRoaXMuc29ydE9yZGVyID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5zb3J0T3JkZXJpbmcpO1xuXG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuYm9keVRlbXBsYXRlKSAmJiB0aGlzLnVzZUdsb2JhbEJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keVRlbXBsYXRlID0gdGhpcy5kdC5ib2R5VGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmhlYWRlclRlbXBsYXRlKSAmJiB0aGlzLnVzZUdsb2JhbEhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJUZW1wbGF0ZSA9IHRoaXMuZHQuaGVhZGVyVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnN1YkhlYWRlclRlbXBsYXRlKSAmJiB0aGlzLnVzZUdsb2JhbFN1YkhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zdWJIZWFkZXJUZW1wbGF0ZSA9IHRoaXMuZHQuc3ViSGVhZGVyVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmJvZHlDbGFzc0ZuKSkge1xuICAgICAgICAgICAgdGhpcy5ib2R5Q2xhc3NGbiA9IHRoaXMuZHQuYm9keUNsYXNzRm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmtleSkgJiYgaXNCbGFuayh0aGlzLmxhYmVsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGJpbmRpbmc6ICcgK1xuICAgICAgICAgICAgICAgICdba2V5XSBvciBbbGFiZWxdIGJpbmRpbmdzIG11c3QgYmUgdXNlZCBhdCBtaW5pbXVtJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBiZSBhYmxlIHRvIHBvc2l0aW9uIHNlY29uZCBEVCB3ZSByZXF1aXJlIFt3aWR0aF0gdG8gYmUgc2V0IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMuZnJvemVuICYmIGlzQmxhbmsodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBiaW5kaW5nIFt3aWR0aF06ICcgK1xuICAgICAgICAgICAgICAgICd3aGVuIFtmcm96ZW5dPXRydWUgdGhlbiBbd2lkdGhdIGJpbmRpbmcgbmVlZHMgdG8gYmUgc3BlY2lmaWVkLicpO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcblxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gbmVlZCB0byBkZWZmZXIgdGhpcyBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uIG90aGVyd2lzZSBJIGdldFxuICAgICAgICAvLyB2YWx1ZSB3YXMgY2hhbmdlZCBhZnRlciBpdCB3YXMgY2hlY2tlZCBlcnJvclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF4V2lkdGhQeCA9IHRoaXMud2lkdGhUb1B4KHRoaXMubWF4V2lkdGgpO1xuICAgICAgICAgICAgdGhpcy5taW5XaWR0aFB4ID0gdGhpcy53aWR0aFRvUHgodGhpcy5taW5XaWR0aCk7XG4gICAgICAgICAgICB0aGlzLndpZHRoUHggPSB0aGlzLndpZHRoVG9QeCh0aGlzLndpZHRoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNlbGwgc2VsZWN0aW9uTW9kZSBpcyBlbmFibGVkIHRoaXMgbWV0aG9kIGlzIHRyaWdnZXJlZCB3aGVuIHdlIGNsaWNrIG9uIGhlYWRlci5cbiAgICAgKiBJdCBkZWxlZ2F0ZXMgdGhlIGNhbGwgdG8gdGhlIERUIHdoZXJlIGl0IHRvZ2dsZXMgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVIZWFkZXJDbGljayhldmVudDogYW55LCBlbGVtZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNIZWFkZXJTZWxlY3RhYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHQub25IZWFkZXJTZWxlY3Rpb25DaGFuZ2UoZWxlbWVudCwgdGhpcyk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNvcnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUb2RvOiBJbXBsZW1lbnQgb3VyIG93biBzb3J0aW5nIG1lY2hhbmlzbSBvbmNlIHdlIGV4dHJhY3QgdGhlIHNvcnRpbmcgbG9naWMgdG8gaXRzIGNvbXBvbmVudFxuICAgICAqXG4gICAgICovXG4gICAgc29ydChldmVudDogYW55KSB7XG4gICAgICAgIGlmICghdGhpcy5zb3J0YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAodGhpcy5kb21IYW5kbGVyLmhhc0NsYXNzKHRhcmdldE5vZGUsICdkdC11LXNvcnRhYmxlJykgfHxcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyh0YXJnZXROb2RlLCAnZHQtY29sLXRpdGxlJykgfHxcbiAgICAgICAgICAgIHRoaXMuZG9tSGFuZGxlci5oYXNDbGFzcyh0YXJnZXROb2RlLCAnZHQtY29sLXNvcnRhYmxlLWljb24nKSkge1xuXG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuc29ydENvbHVtbikgJiYgdGhpcy5kdC5zb3J0Q29sdW1uLmtleSA9PT0gdGhpcy5rZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNvcnRPcmRlciA9IHRoaXMuc29ydE9yZGVyICogLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0T3JkZXJpbmcgPSB0aGlzLmR0LnNvcnRPcmRlcmluZ0Zvck51bWJlcih0aGlzLnNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5zb3J0Q29sdW1uID0gdGhpcztcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLnN0YXRlLnNvcnRLZXkgPSB0aGlzLmtleTtcbiAgICAgICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5zb3J0T3JkZXIgPSB0aGlzLmR0LnNvcnRPcmRlcmluZ0ZvclN0cmluZyh0aGlzLnNvcnRPcmRlcmluZyk7XG5cbiAgICAgICAgICAgIHRoaXMuZHQuc29ydFNpbmdsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZHQudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlZCBzdHlsZSBjbGFzcyBiYXNlZCBvbiBkYXRhXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGR5bmFtaWNCb2R5Q2xhc3MoaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBkeW5DbGFzcyA9IGlzUHJlc2VudCh0aGlzLmJvZHlDbGFzc0ZuKVxuICAgICAgICAgICAgPyB0aGlzLmJvZHlDbGFzc0ZuLmFwcGx5KHRoaXMuZHQuY29udGV4dCwgW3RoaXMsIGl0ZW1dKSA6ICcnO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5ib2R5U3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIGR5bkNsYXNzICs9ICcgJyArIHRoaXMuYm9keVN0eWxlQ2xhc3M7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpc1ByZXNlbnQodGhpcy5zdHlsZUNsYXNzKSkge1xuICAgICAgICAgICAgZHluQ2xhc3MgKz0gJyAnICsgdGhpcy5zdHlsZUNsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGR5bkNsYXNzO1xuICAgIH1cblxuXG4gICAgaXNSb3dTZWxlY3RhYmxlKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuaXNSb3dTZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHQuaXNSb3dTZWxlY3RhYmxlKGl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlzQ2VsbFNlbGVjdGFibGUoaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LnNlbGVjdGlvbk1vZGUgPT09ICdjZWxsJyAmJiB0aGlzLmlzUm93U2VsZWN0YWJsZShpdGVtKSAmJiB0aGlzLnNlbGVjdGFibGU7XG5cbiAgICB9XG5cblxuICAgIGlzSGVhZGVyU2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHQuc2VsZWN0aW9uTW9kZSA9PT0gJ2NlbGwnICYmIHRoaXMuc2VsZWN0YWJsZTtcblxuICAgIH1cblxuXG4gICAgZ2V0U29ydE9yZGVyKCkge1xuICAgICAgICBsZXQgb3JkZXIgPSAwO1xuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5kdC5zb3J0Q29sdW1uKSAmJiB0aGlzLmtleSA9PT0gdGhpcy5kdC5zb3J0Q29sdW1uLmtleSkge1xuICAgICAgICAgICAgb3JkZXIgPSB0aGlzLmR0LnNvcnRDb2x1bW4uc29ydE9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICB9XG5cbiAgICBpc1NvcnRlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvcnRhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmR0LnNvcnRDb2x1bW4pICYmIHRoaXMua2V5ID09PSB0aGlzLmR0LnNvcnRDb2x1bW4ua2V5O1xuICAgIH1cblxuICAgIGluaXRpYWxpemUodGFibGU6IEFXRGF0YVRhYmxlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHQgPSB0YWJsZTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZHQuaW5pdGlhbFNvcnRLZXkpICYmIHRoaXMuZHQuaW5pdGlhbFNvcnRLZXkgPT09IHRoaXMua2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc29ydE9yZGVyID0gdGhpcy5kdC5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5kdC5pbml0aWFsU29ydE9yZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZHQuc29ydENvbHVtbiA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgdmlldyBpbml0IGN5Y2xlIGZyb20gdGhlIGR0Lm5nQWZ0ZXJWaWV3Q2hlY2tlZC5cbiAgICAgKlxuICAgICAqIEluIGNhc2Ugd2UgdXNlIE1heFdpZHRoIGRpcmVjdGl2ZSB3ZSBzZXQgbmV3IHdpZHRoIG9uY2UgZm9yIGFsbCBjb2x1bXNuXG4gICAgICovXG4gICAgcG9zdEluaXRpYWxpemUobXlJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbEluZGV4ID0gbXlJbmRleCArIDE7XG4gICAgICAgIGxldCB0YWJsZTtcblxuICAgICAgICBpZiAodGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIHRhYmxlID0gKDxEYXRhdGFibGUyQ29tcG9uZW50PnRoaXMuZHQpLmVsXG4gICAgICAgICAgICAgICAgLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWJvZHktZnJvemVuIHRhYmxlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YWJsZSA9ICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICh0aGlzLndpZGVzdENlbGwgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYWxsID0gdGFibGUucXVlcnlTZWxlY3RvckFsbCgndHIgdGg6bnRoLWNoaWxkKCcgKyBjb2xJbmRleCArICcpLCAnICtcbiAgICAgICAgICAgICAgICAndHIgdGQ6bnRoLWNoaWxkKCcgKyBjb2xJbmRleCArICcpJykuZm9yRWFjaCgobm9kZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHRoaXMud2lkZXN0Q2VsbCArICdweCc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogWW91IGVpdGhlciB1c2UgdGhpcyBiaW5kaW5nIGRpcmVjdGx5IGFuZCBzYXkgaXRzIGRhdGFjb2x1bW4gb3Igd2hlbiB0aGVyZSBpcyBhIFtrZXldXG4gICAgICogYmlkaW5nIHdlIGtub3cgaXQgcmVmZXJzIHRvIHNvbWUgZmllbGQuXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1ZhbHVlQ29sdW1uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKGlzUHJlc2VudCh0aGlzLmlzRGF0YUNvbHVtbikgJiYgQm9vbGVhbldyYXBwZXIuaXNUcnVlKHRoaXMuaXNEYXRhQ29sdW1uKSkgfHxcbiAgICAgICAgICAgIGlzUHJlc2VudCh0aGlzLmtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBhcmUgaW4gb3V0bGluZSBtb2RlICB3ZSBuZWVkIHRvIGFsc28gaW5kZW5kIGVhY2ggc2VsZWN0aW9uIGNvbnRyb2wgYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKiBpbmRlbnQgLSAxID4gb25seSBvZmZzZXQgd2l0aFxuICAgICAqIGluZGVudFxuICAgICAqL1xuICAgIGluZGVudEZvckNvbnRyb2woY2VsbDogYW55LCBsZXZlbDogbnVtYmVyKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuZHQuaXNPdXRsaW5lKCkgJiYgbGV2ZWwgPiAwICYmIGNlbGwub2Zmc2V0V2lkdGggPiAwXG4gICAgICAgICAgICAmJiBpc1ByZXNlbnQoY2VsbC5uZXh0RWxlbWVudFNpYmxpbmcpKSB7XG5cbiAgICAgICAgICAgIGxldCBvdXRsaW5lTm9kZVBhZGRpbmcgPVxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUoY2VsbC5uZXh0RWxlbWVudFNpYmxpbmcpLnBhZGRpbmdMZWZ0KSB8fCAwO1xuXG4gICAgICAgICAgICAvLyAxc3QgbGV2ZWwgaXMgcHVzaGVkIGFzIHJvb3RcbiAgICAgICAgICAgIGlmICh0aGlzLmR0LnB1c2hSb290U2VjdGlvbk9uTmV3TGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobGV2ZWwgPT09IDEpID8gbnVsbCA6ICh0aGlzLmR0LmluZGVudGF0aW9uUGVyTGV2ZWwgKiBsZXZlbClcbiAgICAgICAgICAgICAgICAgICAgLSBvdXRsaW5lTm9kZVBhZGRpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5kdC5pbmRlbnRhdGlvblBlckxldmVsICogbGV2ZWwpICsgb3V0bGluZU5vZGVQYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBJbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgd2lkdGhUb1B4KHdpZHRoOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBsZXQgcHg7XG4gICAgICAgIGlmIChpc1ByZXNlbnQod2lkdGgpKSB7XG4gICAgICAgICAgICBpZiAod2lkdGguaW5kZXhPZignJScpID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vblBjID0gcGFyc2VGbG9hdCh3aWR0aCkgLyAxMDA7XG4gICAgICAgICAgICAgICAgcHggPSBub25QYyAqICg8RGF0YXRhYmxlMkNvbXBvbmVudD50aGlzLmR0KS5lbC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBweCA9IHBhcnNlRmxvYXQod2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHB4O1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gZGF0YXRhYmxlIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgRGF0YVRhYmxlQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1kdC1oZWFkZXIyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIERUSGVhZGVyQ29tcG9uZW50Mlxue1xufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgZm9yd2FyZFJlZiwgSW5qZWN0LCBJbnB1dCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50LCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIEN1c3RvbSBjb2x1bW4gaW1wbGVtZW50YXRpb24gdG8gcmVuZGVyIGRldGFpbCByb3cgc3BhbmluZyBpdHMgY29sdW1uIGFjcm9zcyB3aG9sZSB0YWJsZSB3aWR0aC5cbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWRldGFpbC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIFJlbmRlcnMgYXBwbGljYXRpb24gZGVmaW5lZCBkZXRhaWwgY29sdW1uLiBUaGlzIHRlbXBsYXRlIGp1c3QgcmVuZGVycyBhIGRldGFpbCByb3cgYW5kXG4gICAgbm90IGV4cGFuc2lvbiBjb250cm9sLiBUaGlzIGlzIGltcGxlbWVudGVkIGJ5IGRpZmZlcmVudCBEdENvbHVtbiBpbXBsZW1lbnRhdGlvbiBhbmQgaXRzIGFkZGVkXG4gICAgKHdpbGwgYmUpIGFkZGVkIHByb2dyYW1tYXRpY2FsbHkgZHVyaW5nIGNvbHVtbiBpbml0aWFsaXphdGlvblxuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1jb2x1bW49XCJjb2x1bW5cIiBsZXQtcm93RGF0YT1cImRhdGFcIj5cblxuICAgIDx0ciAjZGV0YWlsUm93RWxlbWVudCBjbGFzcz1cImR0LWJvZHktcm93IGR0LWRldGFpbC1yb3dcIj5cblxuICAgICAgICA8dGQgKm5nSWY9XCJkdC5oYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKVwiIHdpZHRoPVwiMXB4XCI+PC90ZD5cbiAgICAgICAgPHRkICpuZ0lmPVwidmlzaWJsZUxlYWRpbmdDb2xzKCkgPiAwXCIgY29sc3Bhbj1cInZpc2libGVMZWFkaW5nQ29scygpXCIgd2lkdGg9XCIxcHhcIj5cbiAgICAgICAgICAgICZuYnNwOyZuYnNwO1xuICAgICAgICA8L3RkPlxuICAgICAgICA8dGQgW2F0dHIuY29sc3Bhbl09XCJkdC5zdGFydE9mRmlyc3REYXRhQ29sdW1uXCIgW2NsYXNzXT1cImR5bmFtaWNCb2R5Q2xhc3Mocm93RGF0YSlcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwieyAnZHQtaXMtZGVmYXVsdCBkdC1jZWxsLWRlZic6IHRydWV9XCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlUZW1wbGF0ZTsgY29udGV4dDp7JGltcGxpY2l0OiB0aGlzLCByb3dEYXRhOnJvd0RhdGF9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC90ZD5cbiAgICA8L3RyPlxuPC9uZy10ZW1wbGF0ZT5cblxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERURGV0YWlsUm93Q29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50IHtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgY3VycmVudCB2aXNpYmlsaXR5IGZvciBjdXJyZW50IGRhdGEgcm93IHVzaW5nIG1ldGhvZCByZWZlcmVuY2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNWaXNpYmxlRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIHRlbGxzIGlmIHdlIG5lZWQgdG8gcmVuZGVyIGEgbGluZSBiZXR3ZWVuIGl0ZW0gcm93IGFuZCBpdHMgZGV0YWlsXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dSb3dMaW5lOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKSB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8ganVzdCB0byBnZXQgYXJvdW5kIHRoZSBjaGVjayBpbiBwYXJlbnQgY2xhc3NcbiAgICAgICAgdGhpcy5rZXkgPSAnJztcblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9ICF0aGlzLmR0LmlzT3V0bGluZSgpIHx8ICF0aGlzLmR0LnBpdm90YWxMYXlvdXQ7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB3ZSBuZWVkIHRvIGtlZXAgc29tZSBsZWFkaW5nIFREc1xuICAgICAqXG4gICAgICovXG4gICAgdmlzaWJsZUxlYWRpbmdDb2xzKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0Lm51bWJlck9mQ29sc0JlZm9yZURhdGEgLSAodGhpcy5kdC5oYXNJbnZpc2libGVTZWxlY3Rpb25Db2x1bW4oKSA/IDEgOiAwKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2hlY2sgaWYgd2UgY2FuIHNob3cgZGV0YWlsIHJvdy9jb2x1bW4gdXNpbmcgZWl0aGVyIFtpc1Zpc2libGVdIG9yIFtpc1Zpc2libGVGbl0gYmluZGluZ3MuXG4gICAgICogSGVyZSBjYW4gaG9vayBvbiBhcHBsaWNhdGlvbiBsZXZlbCBjdXN0b20gbWV0aG9kIHRvIGRlY2lkZSBpZiBjdXJyZW50IGl0ZW0gaGFzIGRldGFpbCByb3dcbiAgICAgKiBvciBub3RcbiAgICAgKlxuICAgICAqIE9yIHdlIGNhbiB1c2UgaXNWaXNpYmxlPXRydWUgdG8gdGVsbCBhbGwgcm93IGhhdmUgZGV0YWlsIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd0RldGFpbFJvdyhpdGVtOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGlzVmlzaWJsZSA9IHRoaXMuaXNWaXNpYmxlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuaXNWaXNpYmxlRm4pKSB7XG4gICAgICAgICAgICBpc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZUZuLmFwcGx5KHRoaXMuZHQuY29udGV4dCwgW3RoaXMsIGl0ZW1dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH1cblxufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBmb3J3YXJkUmVmLCBJbmplY3QsIFZpZXdFbmNhcHN1bGF0aW9ufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi4vLi4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtFbnZpcm9ubWVudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RvbUhhbmRsZXJ9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5cblxuLyoqXG4gKlxuICpcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LWRldGFpbC1jb2x1bW4tZXhwYW5kJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgIFNwZWNpYWwgY29sdW1uIHRoYXQgcmVuZGVycyBleHBhbmQvY29sbGFwc2UgY29udHJvbCBmb3IgZGV0YWlsIHJvdyB3aGVuIGRldGFpbCByb3cgaXMgZW5hYmxlZC5cblxuICAgSnVzdCBsaWtlIGZvciB0aGUgb3RoZXIgY29sdW1uIGl0IHJlbmRlcnMgaGVhZGVyIHNlY3Rpb24gYXMgd2VsbCBhcyBib2R5IHNlY3Rpb24gd2l0aFxuICAgZXhwYW5kIGNvbnRyb2wgdG8gdG9nZ2xlIHRoZSBleHBhbnNpb25cblxuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1pc0hlYWRlciBsZXQtaXNTdWJIZWFkZXI9XCJpc1N1YkhlYWRlclwiIGxldC1jb2x1bW49XCJjb2x1bW5cIlxuICAgICAgICAgICAgIGxldC1kYXRhVG9SZW5kZXI9XCJkYXRhXCIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG5cbiAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiaXNIZWFkZXIgJiYgIWlzU3ViSGVhZGVyXCI+XG4gICAgICAgIDx0aCAjaGVhZGVyQ2VsbDEgW2NsYXNzXT1cImhlYWRlclN0eWxlQ2xhc3N8fHN0eWxlQ2xhc3NcIlxuICAgICAgICAgICAgY2xhc3M9XCJkdC1yb3ctY2VsbC1leHBhbmRvXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtaXMtZGVmYXVsdCBkdC11LXVuc2VsZWN0YWJsZS10ZXh0IGR0LWNlbGwtZGVmJyA6dHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdkdC1kZXQtcm93LWV4cGFuZGVkJzogZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuaXNFeHBhbmRlZChkYXRhVG9SZW5kZXIpfVwiPlxuICAgICAgICA8L3RoPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNIZWFkZXIgJiYgIWlzU3ViSGVhZGVyXCI+XG4gICAgICAgIDx0ZCAjY2VsbFxuICAgICAgICAgICAgY2xhc3M9XCJkdC1yb3ctY2VsbC1leHBhbmRvXCJcbiAgICAgICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtY2VsbC1kZWYnOiAhaXNDZWxsU2VsZWN0YWJsZShkYXRhVG9SZW5kZXIpLFxuICAgICAgICAgICAgICAgICAgICAnZHQtZGV0LXJvdy1leHBhbmRlZCc6IGR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoZGF0YVRvUmVuZGVyKSxcbiAgICAgICAgICAgICAgICAgICAgJ2R0LWRldC1yb3ctd2l0aC1sbicgOiBkdC5yb3dEZXRhaWxDb2x1bW4uc2hvd1Jvd0xpbmV9XCI+XG5cbiAgICAgICAgICAgIDxzcGFuIChjbGljayk9XCJ0b2dnbGVFeHBhbnNpb24oJGV2ZW50LCBkYXRhVG9SZW5kZXIpXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzPVwiZHQtZGV0LXJvdy1leHBhbmQgc2FwLWljb25cIlxuICAgICAgICAgICAgICAgICAgW25nQ2xhc3NdPVwiY2FsY3VsYXRlU3R5bGVDbGFzcyhkYXRhVG9SZW5kZXIpXCI+XG5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICA8L3RkPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuXG48L25nLXRlbXBsYXRlPlxuXG5gLFxuICAgIHN0eWxlczogW2AuZHQtcm93LWNlbGwtZXhwYW5kb3t3aWR0aDoxNHB4O3RleHQtYWxpZ246cmlnaHQ7cGFkZGluZzoxN3B4IDVweCAxN3B4IDE3cHg7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kdC1yb3ctY2VsbC1leHBhbmRvIC5kdC1kZXQtcm93LWV4cGFuZHtjdXJzb3I6cG9pbnRlcjtsaW5lLWhlaWdodDoyMXB4fXRkLmR0LWRldC1yb3ctZXhwYW5kZWQ6bm90KC5kdC1kZXQtcm93LXdpdGgtbG4pLHRkLmR0LWRldC1yb3ctZXhwYW5kZWQ6bm90KC5kdC1kZXQtcm93LXdpdGgtbG4pfnRke2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnR9YF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQgZXh0ZW5kcyBEVENvbHVtbjJDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKSB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG5cbiAgICAgICAgLy8gd2UgZG9udCB3YW50IHRvIHNob3cgdGhlIHJvdy9jb2x1bW4gdW5sZXNzIGFwcGxpY2F0aW9uIHNheXMgc29cbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBkZWZhdWx0IHdpZHRoIG9mIHRoZSBzZWxlY3Rpb24gY29udHJvbFxuICAgICAgICB0aGlzLndpZHRoID0gJzQ1cHgnO1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIGp1c3QgdG8gZ2V0IGFyb3VuZCB0aGUgY2hlY2sgaW4gcGFyZW50IGNsYXNzXG4gICAgICAgIHRoaXMua2V5ID0gJyc7XG5cbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVFeHBhbnNpb24oZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZHQuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUudG9nZ2xlKGl0ZW0pO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICBjYWxjdWxhdGVTdHlsZUNsYXNzKGl0ZW06IGFueSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmR0LmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoaXRlbSkgP1xuICAgICAgICAgICAgJ2ljb24tc2xpbS1hcnJvdy1kb3duJyA6ICdpY29uLXNsaW0tYXJyb3ctcmlnaHQnO1xuICAgIH1cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5cblxuaW1wb3J0IHtUZW1wbGF0ZVJlZn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1NlbGVjdGlvbk1vZGV9IGZyb20gJy4vZGF0YXRhYmxlMi5jb21wb25lbnQnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4vY29sdW1uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5pbXBvcnQge0RldGFpbFJvd0V4cGFuc2lvblN0YXRlLCBEVDJEYXRhU291cmNlfSBmcm9tICcuL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtPdXRsaW5lU3RhdGV9IGZyb20gJy4uL291dGxpbmUnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IGNvbnN0IERyYWdFdmVudHM6IHN0cmluZ1tdID0gWydtb3VzZWRvd24nLCAnZHJhZ3N0YXJ0JywgJ2RyYWdvdmVyJywgJ2RyYWdlbnRlcicsICdkcmFnbGVhdmUnLFxuICAgICdkcm9wJywgJ2RyYWdlbmQnXTtcblxuZXhwb3J0IGVudW0gRHJhZ0RpcmVjdGlvblxue1xuICAgIE5vbmUgPSAnbm9uZScsXG4gICAgVXAgPSAnZHQtZHJhZy1yb3ctdG9wJyxcbiAgICBEb3duID0gJ2R0LWRyYWctcm93LWJvdHRvbScsXG4gICAgTWlkZGxlID0gJ2R0LWRyYWctcm93LWJvdGgnXG59XG5cblxuZXhwb3J0IGVudW0gRHJvcFBvc2l0aW9uXG57XG4gICAgQmVmb3JlID0gJ2JlZm9yZScsXG4gICAgQWZ0ZXIgPSAnYWZ0ZXInLFxuICAgIEludG8gPSAnaW50bydcbn1cblxuXG4vKipcbiAqIEFic3RyYWN0IHR5cGUgdGhhdCBpcyBzaGFyYWJsZSBhbW9uZyBkZXBlbmRhbnQgRFQgb2JqZWN0IHN1Y2ggYXMgQ29sdW1ucywgRGF0YVNvdXJjZXMsXG4gKiBEaXJlY3RpdmVzIHRvIGJlIGFibGUgdG8gY29tbXVuaWNhdGUgYmFjayB0byB0aGUgZGF0YXRhYmxlIG1haW5seSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQVdEYXRhVGFibGUge1xuXG4gICAgLyoqXG4gICAgICogQWxsb3dzIHlvdSB0byBwYXNzIHlvdXIgb3duIGRhdGFzb3VyY2UgdG8gb3ZlcnJpZGUgZGVmYXVsdCBvbmUuIEFsc28gd2hlbiBkYXRhU291cmNlIGlzXG4gICAgICogdXNlZCB0aGUgZGVzdGluYXRpb25DbGFzcyBvciBsaXN0IGFyZSBpZ25vcmVkXG4gICAgICovXG4gICAgZGF0YVNvdXJjZTogRFQyRGF0YVNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIE1hbmFnZXMgb3V0bGluZSBzdGF0ZXMgZm9yIERhdGF0YWJsZXMgdXNpbmcgb3V0bGluZSBjb250cm9sXG4gICAgICovXG4gICAgb3V0bGluZVN0YXRlOiBPdXRsaW5lU3RhdGU7XG5cblxuICAgIC8qKlxuICAgICAqIEluIGNhc2Ugd2UgaGF2ZSBkZXRhaWwgcm93IHJlbWVtYmVyIGl0cyBleHBhbnNpb24gc3RhdGVcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTogRGV0YWlsUm93RXhwYW5zaW9uU3RhdGU7XG5cbiAgICAvKipcbiAgICAgKiBXaGF0IGNvbHVtbiBpcyB1c2VkIGFzIGZpcnN0IGZvciBzb3J0aW5nXG4gICAgICovXG4gICAgaW5pdGlhbFNvcnRLZXk6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEFsbG93IHRvIGNoYW5nZSBzb3J0aW5nIGRpcmVjdGlvblxuICAgICAqL1xuICAgIGluaXRpYWxTb3J0T3JkZXI6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGVsbHMgRFQgaWYgd2Ugc3VwcG9ydCBjZWxsIHNlbGVjdGlvbiBvciByb3cgYmFzZWQgc2VsZWN0aW9uIHdoaWNoIGlzIHJlZ3VsYXIgRFQuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlO1xuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSBvZiBzaW5nbGUgb3IgbXVsdGlzZWxlY3Rpb24gc2hvdyBjb250cm9sc1xuICAgICAqXG4gICAgICovXG4gICAgc2hvd1NlbGVjdGlvbkNvbHVtbjogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIHdhbnQgdG8gcmVuZGVyIG9uZSBzZWxlY3Rpb24gY29udHJvbCBpbiB0aGUgaGVhZGVyIHRvIHNlbGVjdCBhbGwgdGhlXG4gICAgICogcm93cy4gQXBwbGljYWJsZSBmb3IgbXVsdGlzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTZWxlY3RBbGw6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeSBpZiByb3cgb3IgY2VsbCBpcyBzZWxlY3RhYmxlIGJhc2VkIG9uIGRhdGFcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGFibGU6IChpdGVtOiBhbnkpID0+IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIEVhY2ggRFRDb2x1bW4gaGF2ZSBoYXZlIGl0cyBvd24gdGVtcGxhdGUgdG8gcHJvdmlkZSBjb250ZW50IGZvciBoZWFkZXIsIHN1YmhlYWRlciBhbmRcbiAgICAgKiBib2R5IGJ1dCBpZiB0aG9zZSB0ZW1wbGF0ZSBhcmUgaWRlbnRpY2FsIHRoZXJlIHdvdWxkIGJlIHRvbyBtdWNoIGR1cGxpY2F0ZSBjb2RlIHRvIHJlcGxpY2F0ZVxuICAgICAqIGZvciBlYWNoIGNvbHVtbiB0aGUgc2FtZS4gVGhlcmVmb3JlIHdlIGhhdmUgdGhlc2UgZ2xvYmFsIHRlbXBsYXRlcyB0aGF0IHlvdSBjYW4gZGVjbGFyZVxuICAgICAqIG9uIERUIGxldmVsIChub3QgdW5kZXIgY29sdW1ucykgYW5kIGNvbnRlbnQgb2YgdGhlc2UgdGVtcGxhdGUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIGNvbHVtblxuICAgICAqXG4gICAgICogWW91IGNhbiBtaXggdGhlbSBhcyB3ZWxsLiBZb3UgY2FuIGhhdmUgZ2xvYmFsIHRlbXBsYXRlcyBhcyB3ZWxsIGFzIHRlbXBsYXRlIG9uIHRoZSBDb2x1bW5cbiAgICAgKiBsZXZlbCB3aGljaCB3b3VsZCBvdmVycmlkZSB0aGUgZ2xvYmFsIG9uZVxuICAgICAqXG4gICAgICovXG4gICAgaGVhZGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIHN1YkhlYWRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBib2R5VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgLyoqXG4gICAgICogU2VlIGhlYWRlclRlbXBsYXRlIGZvciBtb3JlIGRldGFpbHNcbiAgICAgKi9cbiAgICBoZWFkZXJGaWx0ZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUmVuZGVyIGEgc3ViSGVhZGVyIHRlbXBsYXRlIGlmIHByZXNlbnRcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dTdWJIZWFkZXI6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGdsb2JhbCBzdHlsZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBib3VuZCB0byB0YWJsZSBhbmQgcmVhZCBieSBlYWNoIGNvbHVtbi5cbiAgICAgKiBUaGUgc2FtZSB5b3UgY2FuIHNlZSBvbiB0aGUgRFRDb2x1bW5cbiAgICAgKi9cbiAgICBib2R5Q2xhc3NGbjogKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpID0+IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogQ29udGV4dCBpcyBpbXBvcnRhbnQgd2hlbiB3ZSBleGVjdXRlIGFueSBmdW5jdGlvbiB0aGF0IGlzIHBhc3NlZCBpbiBhcyBpbnB1dC4gV2UgbmVlZCB0b1xuICAgICAqIGdpdmUgb3B0aW9uIHRvIGJlIGV4ZWN1dGVkIHdpdGhpbiB0aGUgY29udGV4dCAodGhpcykgb2YgdGhlIGNvZGUgdXNpbmcgdGhpcyBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKi9cbiAgICBjb250ZXh0OiBhbnk7XG5cbiAgICAvLyBPdXRsaW5lIG5lZWRlZCBwcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBQdXNoZXMgb3V0bGluZUZvciBzZWN0aW9uIG9uIHRoZSBuZXcgbGluZSBhbmQgMm5kIGxldmVsIGNoaWxkIG1ha2UgaXQgcm9vdCBmb3IgdGhpc1xuICAgICAqIHNlY3Rpb25cbiAgICAgKi9cbiAgICBwdXNoUm9vdFNlY3Rpb25Pbk5ld0xpbmU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBZb3UgY2FuIGNoYW5nZSBkZWZhdWx0IGluZGVudGF0aW9uIGZvciB0aGUgb3V0bGluZSBub2Rlc1xuICAgICAqXG4gICAgICovXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBhY3RpdmUgYXBwbGllcyBzcGVjaWFsIHN0eWxlcyB0byB0aGUgRFQuIExhdGVyIG9uIG9uY2UgcGl2b3QgaXMgaW1wbGVtZW50ZWQgdGhpcyB3aWxsXG4gICAgICogYWxzbyBhZGQgYWRkaXRpb25hbCBiZWhhdmlvciB0byB0aGUgRFRcbiAgICAgKlxuICAgICAqL1xuICAgIHBpdm90YWxMYXlvdXQ6IGJvb2xlYW47XG5cblxuICAgIC8qKlxuICAgICAqIFdoZW4gc29ydGluZyBpcyBlbmFibGVkIHRoaXMgaXMgY3VycmVudCBhY3RpdmUgY29sdW1uIGJlaW5nIHNvcnRlZC5cbiAgICAgKlxuICAgICAqICAtIHdlIGRvbnQgc3VwcG9ydCBtdWx0aXBsZSBjb2x1bW4gc29ydGluZ1xuICAgICAqL1xuICAgIHNvcnRDb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBhdy1kdC1kZXRhaWwtY29sdW1uIGlmIHByZXNlbnQgZGV0YWlsIHJvdyBpcyByZW5kZXJlZCBmb3Igc3BlY2lmaWVkXG4gICAgICogaXRlbXNcbiAgICAgKi9cbiAgICByb3dEZXRhaWxDb2x1bW46IERURGV0YWlsUm93Q29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBmb3Igc3BhbmluZyBjYWxjdWxhdGlvbiBvciBmb3IgdGhlIGRldGFpbCByb3cgdG8gaWRlbnRpZnkgY29ycmVjdCBudW1iZXIgb2YgY29sdW1uc1xuICAgICAqIHRvIHNwYW4sIHdoZW4gdGhleSBhcmUgc29tZSBub24tZGF0YSBjb2x1bW4gKGV4cGFuc2lvbiBjb250cm9sLCBzaW5nbGUvbXVsdGkgc2VsZWN0aW9uKVxuICAgICAqL1xuICAgIG51bWJlck9mQ29sc0JlZm9yZURhdGE6IG51bWJlcjtcblxuXG4gICAgLyoqXG4gICAgICogIHdoYXQgaXMgdGhlIGluZGV4IG9mIGZpcnN0IGRhdGEgY29sdW1uc1xuICAgICAqL1xuICAgIHN0YXJ0T2ZGaXJzdERhdGFDb2x1bW46IG51bWJlcjtcblxuXG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gaW4gY2VsbCBzZWxlY3Rpb24gbW9kZVxuICAgICAqXG4gICAgICovXG4gICAgb25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCBieSBjb2x1bW4gd2hlIGhlYWRlciBpcyBzZWxlY3RlZC4gQ3VycmVudCB3ZSBhc3N1bWUgdGhlIG9ubHkgb25lIGhlYWRlciBjYW4gYmVcbiAgICAgKiBzZWxlY3RlZCBhdCB0aGUgdGltZS5cbiAgICAgKlxuICAgICAqL1xuICAgIG9uSGVhZGVyU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQpOiB2b2lkO1xuXG5cbiAgICBvbkhhbmRsZVJvd0NsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSGFuZGxlcyByb3cgc2VsZWN0aW9uIGxvZ2ljIHdoZXJlIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluc2lkZSB0aGUgc2VsZWN0ZWQgaXRlbXMsIHRoZW5cbiAgICAgKiBpdHMgcmVtb3ZlZCBvdGhlcndpc2UgaXRzIGFkZGVkLlxuICAgICAqXG4gICAgICogVG9kbzogU3luYyAmIHJlZmFjdG9yIHRoaXMgd2l0aCBkdC5vbkNlbGxTZWxlY3Rpb25DaGFuZ2UgLSBwcmV0dHkgc2ltaWxhciBjb2RlXG4gICAgICpcbiAgICAgKiBXZSB3YW50IHRvIGhhdmUgcm93VG9nZ2xlIGFzIHdlbGwgYXMgd2Ugd2lsbCBoYXZlIHJvd1NlbGVjdCBvciBzb21ldGhpZ24gc2ltaWxhciB0b1xuICAgICAqIGlkZW50aWZ5IHdlIGFyZSBkZWFsaW5nIHdpdGggbXVsdGlzZWxlY3QgYW5kIHNpbmdsZSBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBvblJvd1RvZ2dsZShldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEhhbmRsZXMgcm93IHNpbmdsZSBzZWxlY3Rpb25cbiAgICAgKlxuICAgICAqL1xuICAgIG9uUm93U2VsZWN0KGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRlYWxpbmcgd2l0aCBvdXRsaW5lICh0cmVlKSB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB3aGVuIHdlIHNlbGVjdCBzb21lIHJvb3QgaXRlbSBpdFxuICAgICAqIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIHNlbGVjdCBhbGwgaXRzIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEp1c3QgbGlrZSBmb3Igb25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbiB0aGUgc2FtZSBiZWhhdmlvciBuZWVkcyB0byBiZSBhcHBsaWVkIGZvclxuICAgICAqIHRvd2FyZHMgdXAuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIG9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FsbGVkIGJ5IEQmRCByb3cgZGlyZWN0aXZlIHRvIHVwZGF0ZSB0aGlzIFREIHRoYXQgcm93IHJlb3JkZXJpbmcgbmVlZHMgdG8gaGFwcGVuLiBXZVxuICAgICAqIHJlY2VpdmUgYW4gSU5ERVggb2Ygcm93IHdlIGFyZSBkcmFnZ2luZyBhbmQgbmV3IGRyb3AgcG9zaXRpb24sIHBsdXMgaW5mb3JtYXRpb24gaWYgaXRcbiAgICAgKiBuZWVkcyB0byBiZSBkcm9wcGVkIGJlZm9yZSBuZXcgcm93IHBvc2l0aW9uIG9yIGFmdGVyLlxuICAgICAqXG4gICAgICovXG4gICAgb25EbkRSb3dEcm9wKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBkZXRhaWwgcm93IGlzIGNvbWJpbmVkIHdpdGggb3V0bGluZSBjb250cm9sIHdlIG5lZWQgbWFrZSBzdXJlIHRoYXQgd2UgbWFpbnRhaW4gdGhlXG4gICAgICogY29ycmVjdCBzdGF0ZSBmb3IgaXRlbXMgdGhhdCBhcmUgZWxpZ2libGUgZm9yIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqIEluIHRoaXMgc3BlY2lmaWMgY2FzZSB0aGUgZGV0YWlsIHJvdyBkb2VzIG5vdCBoYXZlIGl0cyBvd24gZXhwYW5kZXIgYnV0IHV0aWxpemluZyB0aGVcbiAgICAgKiBvdXRsaW5lQ29udHJvbFxuICAgICAqL1xuICAgIG9uT3V0bGluZUV4cGFuZENoYW5nZShldmVudDogYW55KTogdm9pZDtcblxuXG4gICAgLyoqXG4gICAgICogU3VwcG9ydCBmb3Igc2luZ2xlIGNvbHVtbiBzb3J0aW5nXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRTaW5nbGUoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gZGF0YSBjaGFuZ2VzLCBlaXRoZXIgdGhleSBhcmUgbGF6aWx5IGZldGNoZWQgb3IgQElucHV0IExJU1QgaXMgdXBkYXRlZCB3ZSBuZWVkXG4gICAgICogcmVzb3J0IG91dCBkYXRhIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGUgYW5kIHVwZGF0ZSBpbnRlcm5hbCBsaXN0IGRhdGFUb1JlbmRlciBzbyBuZXdcbiAgICAgKiBkYXRhIGNhbiByZS1yZW5kZXJlZCArIHRyaWdnZXJzIGV2ZW50IHZhbHVlQ2hhbmdlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYW5kbGVEYXRhQ2hhbmdlKCk6IHZvaWQ7XG5cbiAgICB1cGRhdGVEYXRhVG9SZW5kZXIoZGF0YXNvdXJjZT86IGFueSk6IHZvaWQ7XG5cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBvciB1bnNlbGVjdCBhbGwgcm93cy4gVXNlZCBieSBoZWFkZXIgY2hlY2tib3hcbiAgICAgKlxuICAgICAqL1xuICAgIHRvZ2dsZUFsbENvbHVtbnMoZXZlbnQ6IGFueSk6IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBNb3JlIGxpa2UgdXRpbGl0eSBtZXRob2RzIHRvIHRyYW5zbGF0ZSBzdHJpbmc8LS0+bnVtYmVyIHZhbHVlIGZvciBzb3J0aW5nXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgdXNlZCBvbmx5IGJ5IERUQ29sdW1uLiBXZSBtaWdodCB3YW50IHRvIG1vdmUgdGhpcyBpdHMgb3duIGNvbXBvbmVudCBmb3JcbiAgICAgKiBoZWFkZXJTb3J0IGFuZCBvcmRlcmluZ1xuICAgICAqXG4gICAgICovXG4gICAgc29ydE9yZGVyaW5nRm9yU3RyaW5nKGRpcmVjdGlvbjogc3RyaW5nKTogbnVtYmVyO1xuXG4gICAgc29ydE9yZGVyaW5nRm9yTnVtYmVyKGRpcmVjdGlvbjogbnVtYmVyKTogc3RyaW5nO1xuXG4gICAgdmlzaWJsZUNvbHVtbnMoKTogRFRDb2x1bW4yQ29tcG9uZW50W107XG5cbiAgICBoYXNGcm96ZW5Db2x1bW5zKCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBQbGFjZWhvbGRlciBmdW5jdGlvbmFsaXR5IGZvciB0aGUgc2luZ2xlL211bHRpc2VsZWN0IGZ1bmN0aW9uYWxpdHkgd2hlcmUgd2UgbmVlZCB0byB0cmFjayBpZlxuICAgICAqIHdlIHN1cHBvcnQgc2VsZWN0aW9uIHBsdXMgaG93IG1hbnkgY29sdW1uIGl0IG9jY3VwaWVzIGFuZCBpZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xzIGFyZVxuICAgICAqIHZpc2libGUgb3IgaGlkZGVuLlxuICAgICAqL1xuICAgIGhhc0ludmlzaWJsZVNlbGVjdGlvbkNvbHVtbigpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBsYWNlaG9sZGVyIHRvIGlkZW50aWZ5IGlmIHRoZXkgYXJlIG5vbi12YWx1ZSBjb2x1bW5cbiAgICAgKlxuICAgICAqL1xuICAgIGhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKTogYm9vbGVhbjtcblxuXG4gICAgLyoqXG4gICAgICogVG8gY29tcGFyZSB0aGUgZGF0YSBpZiB3ZSB1c2UgZGVlcCBvYmplY3QgZXF1YWxpdHkgYW5kIHRoaXMgaXMgdXNlZCB3aXRoaW4gdGhpcyBjbGFzcyBhc1xuICAgICAqIHdlbGwgYXMgZnJvbSB0aGUgRFRDb2x1bW4gdG8gY29uZGl0aW9uYWxseSBhZGQgY2xhc3Mgd2hpY2ggc2VsZWN0IHRoZSBjZWxsXG4gICAgICpcbiAgICAgKiBXZSBtaWdodCB3YW50IHRvIGNoYW5nZSB0byBjaGVjayBvbmx5IGEga2V5IG9mIHRoZSBvYmplY3Qgc29tZSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICBpc0hlYWRlclNlbGVjdGVkKGl0ZW06IERUQ29sdW1uMkNvbXBvbmVudCk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENoZWNrIGlmIHRoZSBzcGVjaWZpYyBjZWxsIGlzIHNlbGVjdGVkLiBXZSBuZWVkIHR3byBwb2ludHMgdG8gaWRlbnRpZnkgaWYgY2VsbCBpcyBzZWxlY3RlZFxuICAgICAqIHRoZSBhY3R1YWwgSXRlbSB0aGF0IGNvdWxkIHJlcHJlc2VudCB3aG9sZSByb3cgYW5kIENvbHVtblxuICAgICAqXG4gICAgICovXG4gICAgaXNCb2R5Q2VsbFNlbGVjdGVkKGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50LCBpdGVtOiBhbnkpOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogIENoZWNrIGlmIHRoZSBnaXZlbiBpdGVtIGlzIGFtb25nIHRoZSBzZWxlY3RlZCBvbmVzXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkKGl0ZW06IGFueSk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gW2NoaWxkcmVuXSBiaW5kaW5nIGlzIHByZXNlbnQgdGhlbiBpdCBtZWFucyB3ZSBuZWVkIHRvIHJlbmRlciBpdCBhcyBhIHRyZWVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzT3V0bGluZSgpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIERlZmF1bHRzIHRoZSBjaGVja2JveCB0byBlaXRoZXIgc2VsZWN0ZWQgYW5kIG5vdCBzZWxlY3RlZCBkZXBlbmRlZCBvbiBpbnRlcm5hbCBzdGF0ZVxuICAgICAqXG4gICAgICovXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5TZWxlY3RlZCgpOiBib29sZWFuO1xuXG4gICAgaXNUb2dnbGVBbGxDb2x1bW5EaXNhYmxlZCgpOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFVzZXMgYXJlIGZpZWxkIHBhdGggdXRpbGl0eSBjbGFzcyB0byByZXRyaWV2ZSBkYXRhIGZyb20gb2JqZWN0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWYWx1ZShkYXRhOiBhbnksIGZpZWxkOiBzdHJpbmcpOiBhbnk7XG5cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBhc3NlcnQsXG4gICAgRW50aXR5LFxuICAgIGVxdWFscyxcbiAgICBpc0JsYW5rLFxuICAgIGlzRW50aXR5LFxuICAgIGlzUHJlc2VudCxcbiAgICBpc1N0cmluZyxcbiAgICBNYXBXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtPYnNlcnZhYmxlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7RGF0YVNvdXJjZSwgRFNJbml0UGFyYW1zfSBmcm9tICcuLi8uLi9jb3JlL2RhdGEvZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJ9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhdHlwZS1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCB7RGF0YUZpbmRlciwgRGF0YUZpbmRlcnMsIFF1ZXJ5VHlwZX0gZnJvbSAnLi4vLi4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXRGF0YVRhYmxlLCBEcm9wUG9zaXRpb259IGZyb20gJy4vYXctZGF0YXRhYmxlJztcblxuXG4vKipcbiAqIENvbmNyZXRlIERhdGFTb3VyY2UgaW1wbGVtZW50YXRpb24gZm9yIERhdGF0YWJsZSB3aGljaCBkZWZpbmVzIHN0YXRlIGFuZCBjb2x1bW4gZGVmaW5pdGlvbiB0aGF0XG4gKiBjYW4gcHJvZ3JhbW1hdGljYWxseSBtb2RpZnkgcmVuZGVyZWQgY29sdW1ucyAoaWYgcHJvdmlkZWQpIGFuZCBtZXRob2QgZm9yIGluc2VydGluZyBhbmRcbiAqIGFuZCBkZWxldGluZyByZWNvcmRzO1xuICpcbiAqIEFsbCBvcGVyYXRpb25zIGRlYWxpbmcgd2l0aCBkYXRhIHVzZSBPYnNlcnZhYmxlPFQ+IGFuZCBpbnN0YW50KCkgbWV0aG9kIHRvIHJldHJpZXZlIGN1cnJlbnRcbiAqIHN0YXRlIGlzIG5vdCBpbXBsZW1lbnRlZC5cbiAqXG4gKlxuICovXG5leHBvcnQgY2xhc3MgRFQyRGF0YVNvdXJjZSBleHRlbmRzIERhdGFTb3VyY2Uge1xuICAgIHN0YXRpYyByZWFkb25seSBNYXhMaW1pdCA9IDEwMDtcblxuICAgIC8qKlxuICAgICAqIE1hdGNoaW5nIGRhdGFQcm92aWRlcnMgYW5kIGZpbmRlcnNcbiAgICAgKi9cbiAgICBkYXRhUHJvdmlkZXI6IERhdGFQcm92aWRlcjxhbnk+O1xuICAgIGRhdGFGaW5kZXI6IERhdGFGaW5kZXI7XG5cbiAgICAvKipcbiAgICAgKiBLZWVwIHRyYWNrIG9mIGN1cnJlbnQgZGF0YXRhYmxlIHN0YXRlXG4gICAgICovXG4gICAgc3RhdGU6IERhdGF0YWJsZTJTdGF0ZTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgb2JqZWN0IGJlaW5nIHJlbmRlcmVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbnRpdHk6IEVudGl0eURlZjI7XG5cblxuICAgIGluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBkZWJ1Z1RpbWU6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRhUHJvdmlkZXJzPzogRGF0YVByb3ZpZGVycywgcHVibGljIGZpbmRlcnM/OiBEYXRhRmluZGVycykge1xuICAgICAgICBzdXBlcihkYXRhUHJvdmlkZXJzLCBmaW5kZXJzKTtcblxuICAgICAgICB0aGlzLnN0YXRlID0gRGF0YXRhYmxlMlN0YXRlLmNyZWF0ZSgpO1xuXG4gICAgICAgIHRoaXMuZGVidWdUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG5cbiAgICBpbml0KC4uLmFyZ3M6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIGlmIChpc0JsYW5rKGFyZ3MpIHx8IGFyZ3MubGVuZ3RoICE9PSAxICYmICFpc0RUSW5pdFBhcmFtcyhhcmdzWzBdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byBpbml0aWFsaXplIERTIHdpdGggKERTQ2hvb3NlckluaXRQYXJhbXMpJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluaXQ6IERURFNJbml0UGFyYW1zID0gYXJnc1swXTtcblxuICAgICAgICAvLyB1c2UgZXhpc3Rpbmcgb3IgZmluZCBiZXN0IG1hdGNoIGZvciBkYXRhUHJvdmlkZXJcbiAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIgPSBpc1ByZXNlbnQoaW5pdC5kYXRhUHJvdmlkZXIpID8gaW5pdC5kYXRhUHJvdmlkZXJcbiAgICAgICAgICAgIDogdGhpcy5kYXRhUHJvdmlkZXJzLmZpbmQoaW5pdC5vYmopO1xuXG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBvciBmaW5kIGJlc3QgbWF0Y2ggZm9yIGRhdGFGaW5kZXJcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gaXNQcmVzZW50KGluaXQuZGF0YUZpbmRlcikgPyBpbml0LmRhdGFGaW5kZXJcbiAgICAgICAgICAgIDogdGhpcy5maW5kZXJzLmZpbmQodGhpcy5kYXRhUHJvdmlkZXIsIGluaXQucXVlcnlUeXBlKTtcblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuZGF0YVByb3ZpZGVyKSAmJiBpc1ByZXNlbnQodGhpcy5kYXRhRmluZGVyKSxcbiAgICAgICAgICAgICdEYXRhU291cmNlIGluY29ycmVjdGx5IGluaXRpYWxpemVkLiAoRGF0YVByb3ZpZGVyLCBEYXRhRmluZGVyKSBtaXNzaW5nLiAnKTtcblxuICAgICAgICB0aGlzLmRhdGFGaW5kZXIubG9va3VwS2V5ID0gaW5pdC5sb29rdXBLZXk7XG4gICAgICAgIGlmIChpc0JsYW5rKGluaXQuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbmV3IERhdGF0YWJsZTJTdGF0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGluaXQuc3RhdGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFzeW5jIGZldGNoIGRhdGEgcmVxdWVzdCBhbmQgcmVzdWx0IGlzIGdpdmVuIGJhY2sgdXNpbmcgZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBmZXRjaCh3aXRoUGFyYW1zPzogRGF0YXRhYmxlMlN0YXRlKTogdm9pZCB7XG4gICAgICAgIGxldCBwYXJhbXMgPSBudWxsO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHdpdGhQYXJhbXMpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBuZXcgTWFwKCkuc2V0KCdvZmZzZXQnLCB3aXRoUGFyYW1zLm9mZnNldClcbiAgICAgICAgICAgICAgICAuc2V0KCdsaW1pdCcsIHdpdGhQYXJhbXMubGltaXQpXG4gICAgICAgICAgICAgICAgLnNldCgnb3JkZXJieScsIHdpdGhQYXJhbXMuc29ydEtleSlcbiAgICAgICAgICAgICAgICAuc2V0KCdzZWxlY3RvcicsIHdpdGhQYXJhbXMuc29ydE9yZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmZldGNoKHBhcmFtcykuc3Vic2NyaWJlKChyZXN1bHQ6IGFueVtdKSA9PiB7XG4gICAgICAgICAgICBpZiAod2l0aFBhcmFtcy5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGluY3JEYXRhID0gWy4uLnRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLmdldFZhbHVlKCksIC4uLnJlc3VsdF07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChpbmNyRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgdXNlcyB0aGlzIG1ldGhvZCB0byBvcGVuIHVwIGNvbnRpbnVvdXMgc3RyZWFtIHRvIGxpc3RlbiBmb3IgYW55IGNoYW5nZXMgd2hpY2hcbiAgICAgKiBuZWVkIHRvIGJlIHJlZmxlY3RlZCBvbiB0aGUgVUkuXG4gICAgICpcbiAgICAgKiBEb250IGZvcmdldCB0byB1bnN1YnNjcmliZSB3aGVuIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgb3BlbjxUPigpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhRmluZGVyID0gbnVsbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIElmIENSVUQgaXMgZW5hYmxlZCB3ZSBkZWxlZ2F0ZSBjYWxscyB0byBEYXRhUHJvdmlkZXIgdGhhdCBpcyByZXNwb25zaWJsZSB0byB0ZWxsIHRoZVxuICAgICAqIGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcyB0aGF0IGFyZSBuZXcgZGF0YS4gSWYgbm90IGVuYWJsZWQgd2UgaGF2ZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICogd2hpY2ggd29ya3Mgd2l0aCBsb2NhbCBhcnJheVxuICAgICAqXG4gICAgICovXG4gICAgaW5zZXJ0KG9iamVjdDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFQcm92aWRlci5jYW5DUlVEKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmluc2VydChvYmplY3QpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29weSA9IHRoaXMuZGF0YVByb3ZpZGVyLmRhdGEoKS5zbGljZSgpO1xuICAgICAgICAgICAgY29weS5wdXNoKG9iamVjdCk7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoY29weSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFBsZWFzZSBzZWUge0BsaW5rIGluc2VydH0gbWV0aG9kXG4gICAgICpcbiAgICAgKi9cbiAgICByZW1vdmUob2JqZWN0OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb3ZpZGVyLmNhbkNSVUQoKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIucmVtb3ZlKG9iamVjdCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb3B5ID0gdGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpLnNsaWNlKCk7XG4gICAgICAgICAgICBsZXQgYWZ0ZXJEZWxldGUgPSBjb3B5LmZpbHRlcigoZWxlbTogYW55KSA9PiAhZXF1YWxzKGVsZW0sIG9iamVjdCkpO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5uZXh0KGFmdGVyRGVsZXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJvdmlkZXMgYWNjZXNzIHRvIERhdGFGaW5kZXIgd2hpY2ggY2FuIGFjY2VwdCBlaXRoZXIgcGxhaW4gc3RyaW5nIG9yIE1hcC5cbiAgICAgKlxuICAgICAqIFRvIGJlIGFibGUgdG8gcHJvdmlkZSBjb3JyZWN0IGlucHV0IHdlIG5lZWQgdG8gYXNrIERhdGFGaW5kZXIgaWYgaXQgc3VwcG9ydHMgRnVsbFRleHQgbGlrZVxuICAgICAqIHR5cGUgcXVlcnkgb3IgUHJlZGljYXRlLiBJbiBjYXNlIG9mIFByZWRpY2F0ZSB3ZSBidWlsZCB0aGUgTWFwIHdpdGggZGlmZmVyZW50IGtleS92YWx1ZVxuICAgICAqIHBhaXJzXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGZpbmQocGF0dGVybj86IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoaXNCbGFuayhwYXR0ZXJuKSB8fCBwYXR0ZXJuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaWYgd2UgcmVjZWl2ZWQgZW1wdHkgc3RyaW5nIHJldHVybiBvcmdpbmFsIGxpc3RcbiAgICAgICAgICAgIHRoaXMuZmV0Y2godGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc2VhcmNoUGFyYW06IGFueSA9IHBhdHRlcm47XG4gICAgICAgIGlmICh0aGlzLmRhdGFGaW5kZXIuYWNjZXB0cyh0aGlzLmRhdGFQcm92aWRlciwgUXVlcnlUeXBlLlByZWRpY2F0ZSkpIHtcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtID0gbmV3IE1hcCgpLnNldCgncXVlcnknLCBwYXR0ZXJuKS5zZXQoJ2xpbWl0JywgRFQyRGF0YVNvdXJjZS5NYXhMaW1pdCk7XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtLnNldCgnb3JkZXJieScsIHRoaXMuc3RhdGUuc29ydEtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5zb3J0S2V5KSkge1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhcmFtLnNldCgnc2VsZWN0b3InLCB0aGlzLnN0YXRlLnNvcnRPcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnQoaXNTdHJpbmcocGF0dGVybiksICdDYW5ub3QgcGFzcyBub24tc3RyaW5nIHZhbHVlIHRvIEZ1bGxUZXh0IEZpbmRlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kYXRhRmluZGVyLm1hdGNoPGFueT4oc2VhcmNoUGFyYW0pLnN1YnNjcmliZSgocmVzdWx0OiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dChyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGF0YSBzb3VyY2UgZGVsZWdhdGVzIHRoZSByZXNwb25zaWJpbGl0eSB0byB0aGUgZ2l2ZW4gZGF0YSBwcm92aWRlciB3aGljaCBuZWVkcyB0byBpbXBsZW1lbnRcbiAgICAgKiBzcGVjaWZpYyBzb3J0aW5nIG1lY2hhbmlzbVxuICAgICAqXG4gICAgICogVG9kbzogRXh0ZW5kIHRvIHNvcnQgYnkgbXVsdGlwbGUgY29sdW1uc1xuICAgICAqXG4gICAgICovXG4gICAgc29ydChrZXk6IHN0cmluZywgc29ydE9yZGVyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy5kYXRhUHJvdmlkZXIuZGF0YSgpKSB8fCB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0S2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnN0YXRlLnNvcnRPcmRlciA9IHNvcnRPcmRlcjtcbiAgICAgICAgdGhpcy5mZXRjaCh0aGlzLnN0YXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFBlcnNpc3QgZGIgc3RhdGVcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZVN0YXRlKG9mZnNldDogbnVtYmVyLCBzb3J0RmllbGQ6IHN0cmluZywgc09yZGVyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuc3RhdGUuc29ydEtleSA9IHNvcnRGaWVsZDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zb3J0T3JkZXIgPSBzT3JkZXI7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIHJlc2h1ZmZsZXMgY3VycmVudCBhcnJheSBiYXNlZCBvbiBuZXcgcm93IEQmRCByZXN1bHQuXG4gICAgICpcbiAgICAgKiBTaW5jZSB0aGVyZSBpcyBhIGRpZmZlcmVuY2UgaWYgd2UgbW92ZSBpdGVtIGZyb20gYm90dG9tIG9yIGZyb20gdGhlIHRvcCBhbmQgdGhlbiBhY2NvcmRpbmdseVxuICAgICAqIGhpZ2hsaWdodGluZyBhIHNwYWNlIGJldHdlZW4gcm93cy4gV2UgbmVlZCB0byByZWZsZWN0IHRoaXMgaW4gaGVyZSBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogVXNlQ2FzZSAxOlxuICAgICAqXG4gICAgICogMS4gWW91IGNhbiBncmFiIGl0ZW0gd2l0aCBpbmRleCAwIGFuZCBtb3ZlIGl0IGRvd24gc28gdGhhdCB5b3UgY2FuIHNlZSBhIGRyb3BwaW5nIGxpbmVcbiAgICAgKiBiZXR3ZWVuIHJvdyB3aXRoIGluZGV4IDIgLSAzXG4gICAgICpcbiAgICAgKiAyLiBJbiB0aGlzIGNhc2Ugc3BsaWNlKCkgc3RhcnRzIGZyb20gcG9zaXRpb24gMiBhbmQgaW5zZXJ0IGFsbCBlbGVtZW50cyBhZnRlciAyXG4gICAgICogICAgICBzcGxpY2Uoc3RhcnQ6IG51bWJlciwgZGVsZXRlQ291bnQ6IG51bWJlciwgLi4uaXRlbXM6IFRbXSk6IFRbXTtcbiAgICAgKlxuICAgICAqIDMuIG5vIG5lZWQgdG8gdXBkYXRlIG5ld1Bvc1xuICAgICAqXG4gICAgICogVXNlQ2FzZSAyOlxuICAgICAqXG4gICAgICogMS4gWW91IGNhbiBncmFiIGl0ZW0gd2l0aCBpbmRleCAwIGFuZCBtb3ZlIGFsbCB0aGUgd2F5IGRvd24gb2YgdGhlIERUIGFuZCBub3cgbW92ZSB0aGVcbiAgICAgKiByb3cgdG93YXJkIFRPUCBhbmQgc3BhY2UgYmV0d2VlbiByb3dzIHdpdGggaW5kZXggMiAtIDMgaXMgaGlnaGxpZ2h0ZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiAyLiBIZXJlIGlzIHRoZSBkaWZmZXJlbmNlLCBiZWZvcmUgd2UgaGlnaGxpZ2h0ZWQgcm93ICMyIHdpdGggbGluZSBhdCB0aGUgYm90dG9tLCBub3dcbiAgICAgKiBpdCBzZWVtcyB0aGUgc2FtZSBidXQgaXRzIGhpZ2hsaWdodGVkIHJvdyAjMyB3aXRoIGxpbmUgYXQgdGhlIFRPUC5cbiAgICAgKlxuICAgICAqICogVGhpcyBpcyB0aGUgcmVhc29uIHdoZXkgd2UgbmVlZCB0byBkbyBuZXdQb3MgLT0gMSBvciBuZXdQb3MgKz0gMTsgZGVwZW5kaW5nIG91ciBkaXJlY3Rpb25cbiAgICAgKiB3aGVyZSB3aGVyZSB0aGUgbGluZSBiZXR3ZWVuIHJvd3MgaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqXG4gICAgICogV2UgZG9uJ3QgbmVlZCBhbnkgY29tcGxpY2F0ZWQgY2FsY3VsYXRpb24gdHJ5aW5nIHRvIGZpbmQgb3V0IGlmIHdlIGFyZSBvbiBvbmUgaGFsZiBvZiB0aGUgcm93XG4gICAgICogb3Igc2Vjb25kIGhhbGYgYW5kIGJhc2VkIG9uIHRoaXMgdHJ5IHRvIGFwcGx5IGNlcnRhaW4gc3R5bGUuIFRoaXMgd291bGQgbm90IGdpdmUgc28gbXVjaFxuICAgICAqIHNwYWNlIGlmIHdlIHdhbnQgZHJvcCByb3cgaW50byB0aGUgcm93LiBBbmQgdGhlIGNhbGN1bGF0aW9uIHdpdGggY29vcmRpbmF0ZXMgd291ZGwgYmUgdG9vXG4gICAgICogY29tcGxpY2F0ZWQuXG4gICAgICpcbiAgICAgKiBXZSBzaW1wbHkgcmVtZW1iZXIgdGhlIGRpcmVjdGlvbiB3ZSBhcmUgbW92aW5nIGFuZCBiYXNlZCBvbiB0aGlzIHdlIGFwcGx5IHN0eWxlIHRvXG4gICAgICogdG8gY3JlYXRlIGEgbGluZSBhdCB0aGUgVE9QIGlmIHdlIGFyZSBnb2luZyB1cHdhcmRzIG9yIGJvdHRvbSBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHJlb3JkZXJSb3dzKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWQge1xuICAgICAgICBsZXQgYXJyYXkgPSB0aGlzLmRhdGFQcm92aWRlci5kYXRhKCkuc2xpY2UoKTtcblxuICAgICAgICAvLyB0YWtlIHNvbWV0aGluZyBmcm9tIHRvcCBhbmQgZHJhZyZkcm9wIHVuZGVyXG4gICAgICAgIGlmIChuZXdQb3MgPiBvcmlnUG9zICYmIGRyb3BQb3MgPT09IERyb3BQb3NpdGlvbi5CZWZvcmUgJiYgbmV3UG9zIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXdQb3MgLT0gMTtcblxuICAgICAgICAgICAgLy8gdGFrZSBzb21ldGhpbmcgZnJvbSBib3R0b20gYW5kIGRyYWcmZHJvcCBhYm92ZVxuICAgICAgICB9IGVsc2UgaWYgKG5ld1BvcyA8IG9yaWdQb3MgJiYgZHJvcFBvcyA9PT0gRHJvcFBvc2l0aW9uLkFmdGVyICYmIG5ld1BvcyA+PSAwKSB7XG4gICAgICAgICAgICBuZXdQb3MgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5LnNwbGljZShuZXdQb3MsIDAsIC4uLmFycmF5LnNwbGljZShvcmlnUG9zLCAxKVswXSk7XG4gICAgICAgIHRoaXMuZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoYXJyYXkpO1xuICAgIH1cblxufVxuXG4vKipcbiAqIEVudGl0eSBkZWZpbml0aW9uIHRvIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSBwcm9ncmFtbWF0aWNhbGx5IGNvbHVtbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFbnRpdHlEZWYyIHtcbiAgICBwcm9wZXJ0eUtleXM6IHN0cmluZ1tdO1xuXG4gICAgZGVmYXVsdEZvcm1hdHRlcjogKGtleTogYW55KSA9PiBzdHJpbmc7XG5cbiAgICBkaXNwbGF5U3RyaW5nRm9yS2V5OiAoa2V5OiBzdHJpbmcpID0+IHN0cmluZztcblxuICAgIGRlZmF1bHRBbGlnbm1lbnRGb3JLZXk6IChrZXk6IHN0cmluZykgPT4gc3RyaW5nO1xufVxuXG4vKipcbiAqIEtlZXBzIGN1cnJlbnQgZGF0YXRhYmxlIHN0YXRlIHRoZSBzdGF0ZSB3aGljaCBkcml2ZXJzIHRoZSB3YXkgd2hpbGUgZmV0Y2hpbmcgdGhlIGRhdGEgYXMgd2VsbFxuICogZW5jYXBzdWxhdGUgc2V0IG9mIHByb3BlcnRpZXMgdGhhdCBuZWVkcyB0byBiZSBwZXJzaXN0ZXQgaW4gb3JkZXIgdG8gcmVjb3ZlciBhIHN0YXRlIGFmdGVyIGUuZy5cbiAqIGJyb3dzZXIgcmVmcmVzaFxuICpcbiAqXG4gKiB0b2RvOiBDcmVhdGUgbWV0aG9kcyB0byBjb252ZXJ0IHRoaXMgc3RhdGUgZnJvbSBhbmQgdG8gSlNPTiBmb3IgZWFzaWVyIHNlcmlhbGl6YXRpb25cbiAqL1xuZXhwb3J0IGNsYXNzIERhdGF0YWJsZTJTdGF0ZSB7XG4gICAgcHVibGljIHN0YXRpYyByZWFkb25seSBBc2NlbmRpbmcgPSAxO1xuICAgIHB1YmxpYyBzdGF0aWMgcmVhZG9ubHkgRGVzY2VuZGluZyA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBmb3IgcGFnaW5nIGFuZCBmZXRjaGluZ1xuICAgICAqL1xuICAgIG9mZnNldDogbnVtYmVyID0gMDtcbiAgICBsaW1pdDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgZGVmYXVsdCB2YWx1ZSB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIE4gbnVtYmVyIG9mIHJvd3MgaW4gbm9uLWZ1bGxzY3JlZW5cbiAgICAgKiBtb2RlXG4gICAgICpcbiAgICAgKi9cbiAgICBkaXNwbGF5TGltaXQ6IG51bWJlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHNvcnRpbmcgZmllbGRcbiAgICAgKi9cbiAgICBzb3J0S2V5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTb3J0aW5nIG9yZGVyIG9mIHRoZSBzb3J0IGZpZWxkLiBEYXRhVGFibGUgc3VwcG9ydCBzb3J0aW5nIGZvciBtdWx0aXBsZSBjb2x1bW4gYnV0IHdlXG4gICAgICogZG9udCBwZXJzaXN0IGl0IG5vdy4gTWF5YmUgaW4gdGhlIGZ1dHVyZVxuICAgICAqL1xuICAgIHNvcnRPcmRlcjogbnVtYmVyID0gRGF0YXRhYmxlMlN0YXRlLkFzY2VuZGluZztcblxuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSB1c2luZyBnbG9iYWwgZmlsdGVyIGZvciBjdXJyZW50IGRhdGF0YWJsZSB0aGVuIHNhdmUgaXQgaGVyZVxuICAgICAqL1xuICAgIGN1cnJlbnRTZWFyY2hRdWVyeTogc3RyaW5nID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGlmIGFueSBwcmVzZWxlY3RlZCBmaWx0ZXJcbiAgICAgKi9cbiAgICBjdXJyZW50RmlsdGVyOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnQgY3VycmVudCBzZWxlY3Rpb24gZGVwZW5kaW5nIG9uIHNlbGVjdGlvbiBtb2RlLlxuICAgICAqXG4gICAgICogQ3VycmVudCBzZWxlY3Rpb24gdXNlZCBib3RoIGZvciByb3cgc2VsZWN0aW9uIGFuZCBjZWxsIHNlbGVjdGlvbi4gUm93IHNlbGVjdGlvbiBpcyB1c2VkIHdoZW5cbiAgICAgKiBTaW5nbGVTZWxlY3QgYW5kIE11bHRpU2VsZWN0IG9uY2Ugd2UgaW1wbGVtZW50IHRoaXMuXG4gICAgICpcbiAgICAgKi9cbiAgICBzZWxlY3Rpb246IGFueTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBoZWFkZXIgc2VsZWN0aW9uIGlzIGVuYWJsZWQgaXQgY2FwdHVyZXMgY3VycmVudGx5IHNlbGVjdGVkIGNvbHVtblxuICAgICAqL1xuICAgIGhlYWRlclNlbGVjdGlvbjogRFRDb2x1bW4yQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBIb2xkcyBjdXJyZW50IHN0YXRlIG9mIHRoZSBvdXRsaW5lIHRyZWUgaWYgdXNlZFxuICAgICAqXG4gICAgICovXG4gICAgb3V0bGluZVN0YXRlPzogTWFwPGFueSwgYm9vbGVhbj47XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBIb2xkcyBjdXJyZW50IHN0YXRlIG9mIHRoZSBkZXRhaWwgcm93cyBpZiB1c2VkXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbmRTdGF0ZT86IE1hcDxhbnksIGJvb2xlYW4+O1xuXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vdXRsaW5lU3RhdGUgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICAgICAgdGhpcy5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgIH1cblxuICAgIHN0YXRpYyBjcmVhdGUob2Zmc2V0OiBudW1iZXIgPSAwLCBsaW1pdDogbnVtYmVyID0gMTUsIGRpc3BsYXlMaW1pdDogbnVtYmVyID0gNSxcbiAgICAgICAgICAgICAgICAgIHNvcnRGaWVsZDogc3RyaW5nID0gJycsIHNPcmRlcjogbnVtYmVyID0gMCwgc2VhcmNoUXVlcnk/OiBzdHJpbmcsIGZpbHRlcj86IGFueSxcbiAgICAgICAgICAgICAgICAgIG91dGxpbmVTdGF0ZTogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKSxcbiAgICAgICAgICAgICAgICAgIGRldGFpbFJvd1N0YXRlOiBNYXA8YW55LCBib29sZWFuPiA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpKTogRGF0YXRhYmxlMlN0YXRlIHtcbiAgICAgICAgbGV0IHMgPSBuZXcgRGF0YXRhYmxlMlN0YXRlKCk7XG4gICAgICAgIHMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBzLmxpbWl0ID0gbGltaXQ7XG4gICAgICAgIHMuZGlzcGxheUxpbWl0ID0gZGlzcGxheUxpbWl0O1xuICAgICAgICBzLnNvcnRLZXkgPSBzb3J0RmllbGQ7XG4gICAgICAgIHMuc29ydE9yZGVyID0gc09yZGVyO1xuICAgICAgICBzLmN1cnJlbnRTZWFyY2hRdWVyeSA9IHNlYXJjaFF1ZXJ5O1xuICAgICAgICBzLmN1cnJlbnRGaWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHMub3V0bGluZVN0YXRlID0gb3V0bGluZVN0YXRlO1xuICAgICAgICBzLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gZGV0YWlsUm93U3RhdGU7XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgc3RhdGljIGZyb21KU09OKGRhdGE6IHN0cmluZyk6IERhdGF0YWJsZTJTdGF0ZSB7XG4gICAgICAgIGxldCBzdGF0ZTogRFRTdGF0ZVNlcmlhbGl6YWJsZUhlbHBlciA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIGxldCBkcyA9IG5ldyBEYXRhdGFibGUyU3RhdGUoKTtcbiAgICAgICAgZHMub2Zmc2V0ID0gc3RhdGUub2Zmc2V0O1xuICAgICAgICBkcy5saW1pdCA9IHN0YXRlLmxpbWl0O1xuICAgICAgICBkcy5kaXNwbGF5TGltaXQgPSBzdGF0ZS5kaXNwbGF5TGltaXQ7XG4gICAgICAgIGRzLnNvcnRLZXkgPSBzdGF0ZS5zb3J0S2V5O1xuICAgICAgICBkcy5zb3J0T3JkZXIgPSBzdGF0ZS5zb3J0T3JkZXI7XG4gICAgICAgIGRzLmN1cnJlbnRTZWFyY2hRdWVyeSA9IHN0YXRlLmN1cnJlbnRTZWFyY2hRdWVyeTtcbiAgICAgICAgZHMub3V0bGluZVN0YXRlID0gTWFwV3JhcHBlci5jcmVhdGVGcm9tQW55TWFwPGJvb2xlYW4+KHN0YXRlLm91dGxpbmVTdGF0ZSk7XG4gICAgICAgIGRzLmRldGFpbFJvd0V4cGFuZFN0YXRlID0gTWFwV3JhcHBlci5jcmVhdGVGcm9tQW55TWFwPGJvb2xlYW4+KHN0YXRlLmRldGFpbFJvd0V4cGFuZFN0YXRlKTtcblxuICAgICAgICByZXR1cm4gZHM7XG4gICAgfVxuXG5cbiAgICBzdGF0aWMgdG9KU09OKGRhdGE6IERhdGF0YWJsZTJTdGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIGxldCB0b0NvbnZlcnQ6IERUU3RhdGVTZXJpYWxpemFibGVIZWxwZXIgPSB7XG4gICAgICAgICAgICBvZmZzZXQ6IGRhdGEub2Zmc2V0LFxuICAgICAgICAgICAgbGltaXQ6IGRhdGEubGltaXQsXG4gICAgICAgICAgICBkaXNwbGF5TGltaXQ6IGRhdGEuZGlzcGxheUxpbWl0LFxuICAgICAgICAgICAgc29ydEtleTogZGF0YS5zb3J0S2V5LFxuICAgICAgICAgICAgc29ydE9yZGVyOiBkYXRhLnNvcnRPcmRlcixcbiAgICAgICAgICAgIGN1cnJlbnRTZWFyY2hRdWVyeTogZGF0YS5jdXJyZW50U2VhcmNoUXVlcnksXG4gICAgICAgICAgICBvdXRsaW5lU3RhdGU6IE1hcFdyYXBwZXIudG9BbnlNYXAoZGF0YS5vdXRsaW5lU3RhdGUpLFxuICAgICAgICAgICAgZGV0YWlsUm93RXhwYW5kU3RhdGU6IE1hcFdyYXBwZXIudG9BbnlNYXAoZGF0YS5kZXRhaWxSb3dFeHBhbmRTdGF0ZSlcblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodG9Db252ZXJ0KTtcbiAgICB9XG5cbn1cblxuXG4vKipcbiAqIFRoaXMgbmVlZHMgdG8gZ28gdG8gRFREYXRhU291cmNlIHRvIGtlZXAgYW5kIG1hbmFnZSB0aGUgc3RhdGUgb2YgdGhlIGRldGFpbCByb3cuIFRoZSBpZGVhIGlzXG4gKiBzaW1wbGUgd2UgaGF2ZSBhIG1hcCBob2xkaW5nIGl0ZW0gcmVmZXJlbmNlIGFzIGEga2V5IGFuZCBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgaWYgdGhlXG4gKiBkZXRhaWwgcm93IGlzIHZpc2libGVcbiAqXG4gKiBUb2RvOiBtb3ZlIHRoaXMgb3V0IHRvIERTXG4gKi9cbmV4cG9ydCBjbGFzcyBEZXRhaWxSb3dFeHBhbnNpb25TdGF0ZSB7XG5cbiAgICBleHBhbnNpb25TdGF0ZXM6IE1hcDxhbnksIGJvb2xlYW4+O1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGR0OiBBV0RhdGFUYWJsZSkge1xuICAgIH1cblxuICAgIHByaXZhdGUgaXRlbVRvS2V5KGl0ZW06IGFueSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBpc0VudGl0eShpdGVtKSA/ICg8RW50aXR5Pml0ZW0pLmlkZW50aXR5KCkgOiBpdGVtO1xuICAgIH1cblxuICAgIGdldCBkZXRhaWxFeHBhbnNpb25FbmFibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZXhwYW5zaW9uU3RhdGVzKTtcbiAgICB9XG5cbiAgICBzZXQgZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCh2YWx1ZTogYm9vbGVhbikge1xuXG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZShpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuaXRlbVRvS2V5KGl0ZW0pO1xuICAgICAgICBpZiAoIXRoaXMuaXNFeHBhbmRlZChpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuc2lvblN0YXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZS5kZXRhaWxSb3dFeHBhbmRTdGF0ZSA9IHRoaXMuZXhwYW5zaW9uU3RhdGVzO1xuICAgIH1cblxuICAgIGlzRXhwYW5kZWQoaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBrZXkgPSB0aGlzLml0ZW1Ub0tleShpdGVtKTtcbiAgICAgICAgLy8gaGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb2xsYXBzZSBwYXJlbnQgb2YgcGFyZW50IHdoaWxlIGRldGFpbCByb3cgaXMgZXhwYW5kZWRcbiAgICAgICAgaWYgKHRoaXMuZHQuaXNPdXRsaW5lKCkgJiYgIXRoaXMuZHQub3V0bGluZVN0YXRlLmlzRXhwYW5kZWQoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXNPdXRsaW5lRXhwYW5kZWQgPSB0aGlzLmR0LmlzT3V0bGluZSgpID8gdGhpcy5kdC5vdXRsaW5lU3RhdGUuaXNFeHBhbmRlZChrZXkpIDogdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChrZXkpICYmIHRoaXMuZXhwYW5zaW9uU3RhdGVzLmhhcyhrZXkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEVFN0YXRlU2VyaWFsaXphYmxlSGVscGVyIHtcbiAgICBvZmZzZXQ6IG51bWJlcjtcbiAgICBsaW1pdDogbnVtYmVyO1xuICAgIGRpc3BsYXlMaW1pdDogbnVtYmVyO1xuICAgIHNvcnRLZXk6IHN0cmluZztcbiAgICBzb3J0T3JkZXI6IG51bWJlcjtcbiAgICBjdXJyZW50U2VhcmNoUXVlcnk6IHN0cmluZztcbiAgICBjdXJyZW50RmlsdGVyPzogYW55O1xuICAgIG91dGxpbmVTdGF0ZTogYW55O1xuICAgIGRldGFpbFJvd0V4cGFuZFN0YXRlOiBhbnk7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRFRJbml0UGFyYW1zKGluaXQ6IERURFNJbml0UGFyYW1zKTogaW5pdCBpcyBEVERTSW5pdFBhcmFtcyB7XG4gICAgcmV0dXJuIGlzUHJlc2VudChpbml0Lm9iaikgfHwgaXNQcmVzZW50KGluaXQucXVlcnlUeXBlKSB8fCBpc1ByZXNlbnQoaW5pdC5lbnRpdHkpO1xufVxuXG4vKipcbiAqIFRvIG1ha2UgaW5pdGlhbGl6YXRpb24gZWFzaWVyIHdlIGhhdmUgdGhpcyBjb21tb24gZm9ybWF0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIERURFNJbml0UGFyYW1zIGV4dGVuZHMgRFNJbml0UGFyYW1zIHtcblxuICAgIC8qKlxuICAgICAqIE9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgZGF0YVxuICAgICAqL1xuICAgIGVudGl0eT86IEVudGl0eURlZjI7XG5cbiAgICBzdGF0ZT86IERhdGF0YWJsZTJTdGF0ZTtcbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIEluamVjdCwgVmlld0VuY2Fwc3VsYXRpb259IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEYXRhdGFibGUyQ29tcG9uZW50fSBmcm9tICcuLi8uLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RG9tSGFuZGxlcn0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuLi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqXG4gKiBDb2x1bW4gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBNdWx0aXNlbGVjdGlvbiB3aGVyZSB3ZSBzaG93IGNoZWNrYm94IGNvbnRyb2xcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LW11bHRpLXNlbGVjdC1jb2x1bW4nLFxuICAgIHRlbXBsYXRlOiBgPCEtLVxuICAgIE1hbmFnZXMgbXVsdGkgc2VsZWN0aW9uIGFuZCByZW5kZXJzIGNoZWNrYm94ZXMgYm90aCBmb3IgaGVhZGVyIGluIGNhc2UgW3Nob3dTZWxlY3RBbGxdIGlzXG4gICAgZW5hYmxlZCBhcyB3ZWxsIGFzIGVhY2ggY2hlY2tib3ggcGVyIHJvd1xuLS0+XG48bmctdGVtcGxhdGUgI3JlbmRlcmluZ1RlbXBsYXRlIGxldC1pc0hlYWRlciBsZXQtaXNTdWJIZWFkZXI9XCJpc1N1YkhlYWRlclwiIGxldC1jb2x1bW49XCJjb2x1bW5cIlxuICAgICAgICAgICAgIGxldC1kYXRhVG9SZW5kZXI9XCJkYXRhXCJcbiAgICAgICAgICAgICBsZXQtbGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIlxuICAgICAgICAgICAgIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCJcbiAgICAgICAgICAgICBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNIZWFkZXJcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJjb2xIZWFkZXJcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXNTdWJIZWFkZXIsIGNvbHVtbkluZGV4OmNvbHVtbkluZGV4LFxuICAgICAgICAgICAgICAgICBsZXZlbDpsZXZlbH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiIWlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sQm9keVwiXG4gICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBjb2x1bW4sIGxldmVsOmxldmVsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOmRhdGFUb1JlbmRlcixyb3dJbmRleDpyb3dJbmRleH1cIj5cbiAgICA8L25nLXRlbXBsYXRlPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2NvbEhlYWRlciBsZXQtaXNTdWJIZWFkZXIgbGV0LWNvbHVtbkluZGV4PVwiY29sdW1uSW5kZXhcIj5cbiAgICA8dGggW25nQ2xhc3NdPVwieydkdC1pcy1kZWZhdWx0IGR0LXUtdW5zZWxlY3RhYmxlLXRleHQgZHQtc2VsZWN0aW9uLWNvbHVtbicgOnRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1jZWxsLWRlZic6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdkdC1zdWItaGVhZGVyJzogaXNTdWJIZWFkZXIsXG4gICAgICAgICAgICAgICAgICAgICdkdC1pcy1oaWRkZW4nOiAhZHQuc2hvd1NlbGVjdGlvbkNvbHVtbn1cIiBhbGlnbj1cImNlbnRlclwiPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJkdC5zaG93U2VsZWN0QWxsXCI+XG4gICAgICAgICAgICA8YXctY2hlY2tib3ggW3R5cGVdPVwiJ2FjdGlvbidcIiAoYWN0aW9uKT1cImR0LnRvZ2dsZUFsbENvbHVtbnMoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImR0LmlzVG9nZ2xlQWxsQ29sdW1uU2VsZWN0ZWQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImR0LmlzVG9nZ2xlQWxsQ29sdW1uRGlzYWJsZWQoKVwiPlxuICAgICAgICAgICAgPC9hdy1jaGVja2JveD5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWR0LnNob3dTZWxlY3RBbGxcIj4mbmJzcDtcbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3RoPlxuXG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjY29sQm9keSBsZXQtZGF0YT1cImRhdGFcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiICwgbGV0LWxldmVsPVwibGV2ZWxcIj5cblxuICAgIDx0ZCAjY2VsbCBbY2xhc3NdPVwiZHluYW1pY0JvZHlDbGFzcyhkYXRhKVwiXG4gICAgICAgIFtzdHlsZS5wYWRkaW5nLWxlZnQucHhdPVwiaW5kZW50Rm9yQ29udHJvbChjZWxsLCBsZXZlbClcIlxuICAgICAgICBhbGlnbj1cImNlbnRlclwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsgJ2R0LWlzLWRlZmF1bHQgZHQtc2VsZWN0aW9uLWNvbHVtbic6IHRydWUsXG4gICAgICAgICdkdC1jZWxsLWRlZic6IHRydWUsXG4gICAgICAgICdkdC1pcy1oaWRkZW4nOiAhZHQuc2hvd1NlbGVjdGlvbkNvbHVtbn1cIj5cblxuICAgICAgICA8YXctY2hlY2tib3ggW3R5cGVdPVwiJ2FjdGlvbidcIiBbdmFsdWVdPVwiZHQuaXNSb3dTZWxlY3RlZChkYXRhKVwiID5cbiAgICAgICAgPC9hdy1jaGVja2JveD5cblxuICAgIDwvdGQ+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQgZXh0ZW5kcyBEVENvbHVtbjJDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGVudjogRW52aXJvbm1lbnQsIHB1YmxpYyBkb21IYW5kbGVyOiBEb21IYW5kbGVyKSB7XG4gICAgICAgIHN1cGVyKGVudiwgZG9tSGFuZGxlcik7XG5cbiAgICAgICAgLy8gZGVmYXVsdCB3aWR0aCBvZiB0aGUgc2VsZWN0aW9uIGNvbnRyb2xcbiAgICAgICAgdGhpcy53aWR0aCA9ICc0NXB4JztcbiAgICB9XG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgZm9yd2FyZFJlZiwgSW5qZWN0LCBWaWV3RW5jYXBzdWxhdGlvbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uLy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RW52aXJvbm1lbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtEb21IYW5kbGVyfSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2R0LWNvbHVtbi5jb21wb25lbnQnO1xuXG5cbi8qKlxuICpcbiAqIENvbHVtbiBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIFNpbmdsZVNlbGVjdCB3aGVyZSB3ZSBzaG93IGNoZWNrYm94IGNvbnRyb2xcbiAqXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWR0LXNpbmdsZS1zZWxlY3QtY29sdW1uJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS1cbiAgICBNYW5hZ2VzIG11bHRpIHNlbGVjdGlvbiBhbmQgcmVuZGVycyBjaGVja2JveGVzIGJvdGggZm9yIGhlYWRlciBpbiBjYXNlIFtzaG93U2VsZWN0QWxsXSBpc1xuICAgIGVuYWJsZWQgYXMgd2VsbCBhcyBlYWNoIGNoZWNrYm94IHBlciByb3dcbi0tPlxuPG5nLXRlbXBsYXRlICNyZW5kZXJpbmdUZW1wbGF0ZSBsZXQtaXNIZWFkZXIgbGV0LWlzU3ViSGVhZGVyPVwiaXNTdWJIZWFkZXJcIiBsZXQtY29sdW1uPVwiY29sdW1uXCJcbiAgICAgICAgICAgICBsZXQtZGF0YVRvUmVuZGVyPVwiZGF0YVwiXG4gICAgICAgICAgICAgbGV0LWxldmVsPVwibmVzdGluZ0xldmVsXCJcbiAgICAgICAgICAgICBsZXQtY29sdW1uSW5kZXg9XCJjb2x1bW5JbmRleFwiXG4gICAgICAgICAgICAgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIj5cblxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzSGVhZGVyXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiY29sSGVhZGVyXCJcbiAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInskaW1wbGljaXQ6IGlzU3ViSGVhZGVyLCBjb2x1bW5JbmRleDpjb2x1bW5JbmRleCxcbiAgICAgICAgICAgICAgICAgbGV2ZWw6bGV2ZWx9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cIiFpc0hlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbEJvZHlcIlxuICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogY29sdW1uLCBsZXZlbDpsZXZlbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTpkYXRhVG9SZW5kZXIscm93SW5kZXg6cm93SW5kZXh9XCI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNjb2xIZWFkZXIgbGV0LWlzU3ViSGVhZGVyIGxldC1jb2x1bW5JbmRleD1cImNvbHVtbkluZGV4XCI+XG4gICAgPHRoIFtuZ0NsYXNzXT1cInsnZHQtaXMtZGVmYXVsdCBkdC11LXVuc2VsZWN0YWJsZS10ZXh0IGR0LXNlbGVjdGlvbi1jb2x1bW4nIDp0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtY2VsbC1kZWYnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAnZHQtc3ViLWhlYWRlcic6IGlzU3ViSGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWR0LnNob3dTZWxlY3Rpb25Db2x1bW59XCIgYWxpZ249XCJjZW50ZXJcIj5cbiAgICAgICAgJm5ic3A7XG4gICAgPC90aD5cblxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2NvbEJvZHkgbGV0LWRhdGE9XCJkYXRhXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIiAsIGxldC1sZXZlbD1cImxldmVsXCI+XG5cbiAgICA8dGQgI2NlbGwgW2NsYXNzXT1cImR5bmFtaWNCb2R5Q2xhc3MoZGF0YSlcIlxuICAgICAgICBbc3R5bGUucGFkZGluZy1sZWZ0LnB4XT1cImluZGVudEZvckNvbnRyb2woY2VsbCwgbGV2ZWwpXCJcbiAgICAgICAgYWxpZ249XCJjZW50ZXJcIlxuICAgICAgICBbbmdDbGFzc109XCJ7ICdkdC1pcy1kZWZhdWx0IGR0LXNlbGVjdGlvbi1jb2x1bW4nOiB0cnVlLFxuICAgICAgICAnZHQtY2VsbC1kZWYnOiB0cnVlLFxuICAgICAgICAnZHQtaXMtaGlkZGVuJzogIWR0LnNob3dTZWxlY3Rpb25Db2x1bW59XCI+XG5cbiAgICAgICAgPGF3LXJhZGlvYnV0dG9uIFtuYW1lXT1cIidEVFJhZGlvJ1wiIFt2YWx1ZV09XCJkYXRhXCIgWyhuZ01vZGVsKV09XCJkdC5kYXRhU291cmNlLnN0YXRlLnNlbGVjdGlvblwiPlxuICAgICAgICA8L2F3LXJhZGlvYnV0dG9uPlxuICAgIDwvdGQ+XG48L25nLXRlbXBsYXRlPlxuYCxcbiAgICBzdHlsZXM6IFtgYF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBwcm92aWRlcnM6IFtEb21IYW5kbGVyXVxuXG59KVxuZXhwb3J0IGNsYXNzIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50IGV4dGVuZHMgRFRDb2x1bW4yQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZG9tSGFuZGxlcjogRG9tSGFuZGxlcikge1xuICAgICAgICBzdXBlcihlbnYsIGRvbUhhbmRsZXIpO1xuXG4gICAgICAgIC8vIGRlZmF1bHQgd2lkdGggb2YgdGhlIHNlbGVjdGlvbiBjb250cm9sXG4gICAgICAgIHRoaXMud2lkdGggPSAnNDVweCc7XG4gICAgfVxuXG5cbn1cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICogIEBvcmlnaW5hbC1saWNlbnNlXG4gKiAgVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2LTIwMTcgUHJpbWVUZWtcbiAqXG4gKiAgQ3JlZGl0OiBEZXJpdmVkIGFuZCBleHRlbmRlZCBmcm9tIFByaW1lLW5nIGRhdGFibGUgd2hlcmUgd2UgbmVlZGVkIG1vcmUgbW9kdWxhciBzb2x1dGlvbi5cbiAqICBXZSByZXVzZWQgdGhlIGNvcmUgc3RydWN0dXJlIGFuZCBsYXlvdXQgYnV0IGhhZCB0byByZWZhY3RvciBib3RoIGNvZGUgYW5kIHRlbXBsYXRlIHRvIG1hdGNoIG91clxuICogIG5lZWRzLiBNb3JlIGluIHRoZSBkZXNjcmlwdGlvblxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEluamVjdCxcbiAgICBJbmplY3RvcixcbiAgICBJbnB1dCxcbiAgICBOZ1pvbmUsXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtPYmplY3RVdGlsc30gZnJvbSAncHJpbWVuZy9jb21wb25lbnRzL3V0aWxzL29iamVjdHV0aWxzJztcbmltcG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICdyeGpzJztcbmltcG9ydCB7T3V0bGluZVN0YXRlfSBmcm9tICcuLi9vdXRsaW5lL2luZGV4JztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIGFzc2VydCxcbiAgICBCb29sZWFuV3JhcHBlcixcbiAgICBFbnZpcm9ubWVudCxcbiAgICBlcXVhbHMsXG4gICAgRmllbGRQYXRoLFxuICAgIGlzQmxhbmssXG4gICAgaXNQcmVzZW50LFxuICAgIExpc3RXcmFwcGVyXG59IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtBV0RhdGFUYWJsZSwgRHJvcFBvc2l0aW9ufSBmcm9tICcuL2F3LWRhdGF0YWJsZSc7XG5pbXBvcnQge0RUQ29sdW1uMkNvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZHQtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUSGVhZGVyQ29tcG9uZW50Mn0gZnJvbSAnLi9oZWFkZXIvaGVhZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RURGV0YWlsUm93Q29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93L2R0LWRldGFpbC1yb3cuY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudFxufSBmcm9tICcuL2NvbHVtbi9kZXRhaWwtcm93LWV4cGFuZGVyL2R0LWRldGFpbC1yb3ctZXhwYW5kZXIuY29tcG9uZW50JztcbmltcG9ydCB7REFUQV9TT1VSQ0V9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXNvdXJjZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzLCBRdWVyeVR5cGV9IGZyb20gJy4uLy4uL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtEYXRhdGFibGUyU3RhdGUsIERldGFpbFJvd0V4cGFuc2lvblN0YXRlLCBEVDJEYXRhU291cmNlfSBmcm9tICcuL2RhdGF0YWJsZTItZGF0YS1zb3VyY2UnO1xuaW1wb3J0IHtcbiAgICBEVE11bHRpU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL211bHRpLXNlbGVjdC9kdC1tdWx0aS1zZWxlY3QtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL3NpbmdsZS1zZWxlY3QvZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ211bHRpJyB8ICdzaW5nbGUnIHwgJ2NlbGwnIHwgJ25vbmUnO1xuXG4vKipcbiAqIERUIGNvbXBvbmVudCB0aGF0IGltcGxlbWVudHMgdGhlIGRhdGEgZ3JpZCB0aGF0IHNob3dzIHRhYnVsYXIgZGF0YS4gRXZlbiB0aGUgYmFzaWNcbiAqIHN0cnVjdHVyZSBpcyBiYXNlZCBvbiBQcmltZU5HIGRhdGF0YWJsZSBpdHMgY29tcGxldGVseSByZWZhY3RvcmVkIGludG8gc21hbGxlciBwaWVjZXMgdGhhdFxuICogYWxsb3dzIG1vcmUgZXh0ZW5zaWJpbGl0eSBhbmQgdHJ5aW5nIHRvIHN0YXkgYXMgY2xvc2UgYXMgcG9zc2libGUgdG8gZXhpc3RpbmcgQVdMIGltcGxlbWVudGF0aW9uXG4gKlxuICogVGhlcmUgYXJlIDMgbWFpbiBwaWVjZXM6XG4gKlxuICogIFRhYmxlIFdyYXBwZXIgLSBmb2N1c2VzIG9uIHRoZSBvdXRlciBzdHJ1Y3R1cmUuIENvbnRhaW5lciB3aXRoIGJhc2ljIGRhdGFibGUgbGF5b3V0IHBsdXNcbiAqICBjb250YWlucyBhbnkgYWRkaXRpb25hbCBwYW5lbHMgdGhhdCBkYXRhdGFibGUgbmVlZHMgc3VjaCBhcyBvdXIgbmV3IGNvbmNlcHQgaG93IGVkaXRpbmcgd2lsbFxuICogIHdvcmsgLSBzbGlkaW5nIHBhbmVsIGZyb20gdGhlIGJvdHRvbVxuICpcbiAqICBEYXRhdGFibGUgQ29sdW1uIC0gSW5zdGVhZCBvZiByZW5kZXJpbmcgZXZlcnl0aGluZyBpbnNpZGUgRFQgSSBzcGxpdCB0aGUgcGFydCB0aGF0IHJlbmRlcnNcbiAqICBjb2x1bW4gaW50byBzZXBhcmF0ZSBjb21wb25lbnQuIFRoaXMgd2F5IGNvbXBvbmVudCBjb2x1bW4gaGFzIGl0cyBvd24gcmVuZGVyZXIgdGVtcGxhdGUgd2hpY2hcbiAqICBjYW4gcmVuZGVyIGJvdGggaGVhZGVyIGFuZCBkYXRhIGNlbGxzLlxuICogIExhdGVyIG9uIERUQ29sdW1uIGlzIHRoZW4gZXh0ZW5kZWQgdG8gc3VwcG9ydCBvdGhlciBhZGRpdGlvbmFsIGNvbHVtbiB0eXBlc1xuICogIFNpbmdsZVNlbGVjdGlvbkNvbHVtbiwgTXVsdGlTZWxlY3Rpb25Db2x1bW4sIGJvdGggcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyBzZWxlY3Rpb24gY29udHJvbHMuXG4gKlxuICogVG8gc3VwcG9ydCBwaXZvdGFsIGxheW91dCB0aGlzIGNhbiBiZSBleHRlbmRlZCBmb3Igb3RoZXIgYWRkaXRpb25hbCBjb2x1bW5zIHRoYXQgaW1wbGVtZW50cyB0aGVpclxuICogb3duIHJlbmRlcmluZyB0ZW1wbGF0ZXNcbiAqXG4gKiBEYXRhdGFibGUgLSBUaGUgbWFpbiBjb21wb25lbnQgdGhhdCBpcyBvbmx5IGZvY3VzIG9uIGhlYWRlciBhbmQgYm9keSByZW5kZXJpbmcgYW5kIGJhc2FlZCBvbiB0aGVcbiAqIGNvbHVtbiB0eXBlIGl0IHdpbGwgcmVuZGVyIHRoZSBjb3JyZWN0IHRlbXBsYXRlXG4gKiBjb2x1bW4gdHlwZSBpdCB3aWxsIHJlbmRlciB0aGUgY29ycmVjdCB0ZW1wbGF0ZVxuICpcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZGF0YXRhYmxlMicsXG4gICAgdGVtcGxhdGU6IGA8IS0tXG4gICAgVGhpcyB0ZW1wbGF0ZSBmb2N1cyBvbmx5IG9uIGhlYWRlciBhbmQgYm9keSByZW5kZXJpbmcuXG5cbiAgICBUaGlzIGRhdGF0YWJsZSBhbHNvIHN1cHBvcnRzIGZyb3plbiBjb2x1bW4gYW5kIGZvciB0aGlzIHJlbmRlcmluZyBpdCBpcyBwcmV0dHkgbXVjaCB0cmFuc3BhcmVudFxuICAgIGFzIGl0IHJlY2VpdmVkIHNldHMgb2YgY29sdW1uIHRoYXQgaXQgbmVlZHMgdG8gcmVuZGVyIGZyb20gdGhlIFRhYmxlV3JhcHBlci5cblxuICAgIFRhYmxlV3JhcHBlciBpbiBjYXNlIG9mIGZyb3plbiBjb2x1bW5zIGNhbGxzICNoZWFkZXJSb3dzIGFuZCAjYm9keVJvd3MgdGVtcGxhdGVzIHR3aWNlIHRvXG4gICAgcmVuZGVyIHRvIHNlcGFyYXRlIHRhYmxlcyB3aGVyZSBvbmUgaGFzIGZyb3plbiBjb2x1bW5zIGFuZCBhbm90aGVyIG9uZSBoYXMgdGhlIHJlc3QgYW5kIGl0c1xuICAgIHNjcm9sbGFibGVcbi0tPlxuXG48YXctZHQtd3JhcHBlciAjZHRXcmFwcGVyPlxuICAgIDxuZy10ZW1wbGF0ZSAjaGVhZGluZ0FyZWE+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cImF3LWR0LWhlYWRlcjJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSAjaGVhZGVyUm93cyBsZXQtY29sc1RvUmVuZGVyIGxldC1mcm96ZW5WaWV3PVwiZnJvemVuQ29sdW1uc1wiPlxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlcjsgY29udGV4dDp7JGltcGxpY2l0OiBjb2xzVG9SZW5kZXIsIGZyb3plbjpmcm96ZW5WaWV3IH1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDxuZy10ZW1wbGF0ZSAjYm9keVJvd3MgbGV0LWNvbHNUb1JlbmRlcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cImlzT3V0bGluZSgpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5T3V0bGluZTsgY29udGV4dDp7JGltcGxpY2l0OiBjb2xzVG9SZW5kZXJ9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCIhaXNPdXRsaW5lKClcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImJvZHlQbGFpbjsgY29udGV4dDp7JGltcGxpY2l0OiBjb2xzVG9SZW5kZXJ9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvYXctZHQtd3JhcHBlcj5cblxuXG48IS0tXG4gICAgRWFjaCByZW5kZXJpbmcgY29sdW1uIGhhcyBpdHMgb3duIHJlbmRlclRlbXBsYXRlIHdoaWNoIGRlZmluZSBob3cgdGhpbmdzIHNob3VsZCBiZSByZW5kZXIuXG4gICAgQmFzZWQgb24gZGlmZmVyZW50IGNvbHVtbiB0eXBlcyB0aGlzIGNvZGUgc2hvdWxkIGJlIHRyYW5zcGFyZW50IGFzIHdlIGRvbnQgY2FyZSBvbiB0aGlzXG4gICAgbGV2ZWwgd2hhdCBraW5kIG9mIGNvbHVtbiB3ZSBhcmUgcmVuZGVyaW5nLlxuXG4gICAgTGF0ZXIgb24gd2hlbiB3ZSB3aWxsIHN1cHBvcnQgc2luZ2xlL211bHRpIHNlbGVjdGlvbiwgdGhpcyB3aWxsIGJlIGp1c3QgYW5vdGhlciBjb2x1bW4gZXh0ZW5kaW5nXG4gICAgRFRDb2x1bW4gYW5kIHByb3ZpZGluZyBpdHMgb3duIHRlbXBsYXRlXG5cbiAgICBXZSBwYXNzIGludG8gdGhpcyB0ZW1wbGF0ZSBpZiB3ZSBhcmUgcmVuZGVyaW5nIGhlYWRlciwgc3ViSGVhZGVyLCBvciBkYXRhXG4tLT5cbjxuZy10ZW1wbGF0ZSAjaGVhZGVyIGxldC1jb2xzVG9SZW5kZXIgbGV0LWZyb3plbj1cImZyb3plblwiPlxuICAgIDx0cj5cbiAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jb2wgW25nRm9yT2ZdPVwiY29sc1RvUmVuZGVyXCIgbGV0LWxhc3RDb2w9XCJsYXN0XCJcbiAgICAgICAgICAgICAgICAgICAgIGxldC1jb2x1bW5JbmRleD1cImluZGV4XCI+XG5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2wucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICBjb250ZXh0OnskaW1wbGljaXQ6IHRydWUsIGlzU3ViSGVhZGVyOmZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbHVtbkluZGV4Oihmcm96ZW4gPyBjb2x1bW5JbmRleDogKGNvbHVtbnMubGVuZ3RoICsgY29sdW1uSW5kZXgpKX1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdHI+XG5cbiAgICA8dHIgKm5nSWY9XCJzaG93U3ViSGVhZGVyXCI+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtY29sIFtuZ0Zvck9mXT1cImNvbHNUb1JlbmRlclwiIGxldC1sYXN0Q29sPVwibGFzdFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImNvbC5yZW5kZXJlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogdHJ1ZSwgaXNTdWJIZWFkZXI6dHJ1ZX1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdHI+XG48L25nLXRlbXBsYXRlPlxuXG5cbjxuZy10ZW1wbGF0ZSAjYm9keVBsYWluIGxldC1jb2xzVG9SZW5kZXI+XG5cbiAgICA8dGJvZHkgW25nQ2xhc3NdPVwieydkdC1jb250ZW50IGR0LWRhdGEtY2VsbHMgJzogdHJ1ZSwgJ2R0LWlzLWhvdmVyYWJsZS1yb3cnOiByb3dIb3Zlcn1cIj5cblxuICAgIDxuZy10ZW1wbGF0ZSBuZ0ZvciBsZXQtcm93RGF0YSBbbmdGb3JPZl09XCJkYXRhVG9SZW5kZXJcIiBsZXQtZXZlbj1cImV2ZW5cIiBsZXQtb2RkPVwib2RkXCJcbiAgICAgICAgICAgICAgICAgbGV0LXJvd0luZGV4PVwiaW5kZXhcIiBbbmdGb3JUcmFja0J5XT1cInJvd1RyYWNrQnlcIj5cblxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93VGVtcGxhdGU7IGNvbnRleHQ6eyRpbXBsaWNpdDogcm93RGF0YSwgZXZlbjpldmVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2RkOm9kZCwgcm93SW5kZXg6cm93SW5kZXgsIGNvbHNUb1JlbmRlcjpjb2xzVG9SZW5kZXJ9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJzaG93RGV0YWlsQ29sdW1uKHJvd0RhdGEpXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93RGV0YWlsQ29sdW1uLnJlbmRlcmVyVGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogZmFsc2UsIGRhdGE6cm93RGF0YSwgcm93SW5kZXg6KHJvd0luZGV4KX1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibm9EYXRhXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC90Ym9keT5cbjwvbmctdGVtcGxhdGU+XG5cblxuPG5nLXRlbXBsYXRlICNib2R5T3V0bGluZSBsZXQtY29sc1RvUmVuZGVyPlxuICAgIDx0Ym9keSAjb3V0bGluZUZvciBhd091dGxpbmVGb3IgW2xpc3RdPVwiZGF0YVRvUmVuZGVyXCJcbiAgICAgICAgICAgW2NvbnRleHRdPVwiY29udGV4dFwiXG4gICAgICAgICAgIFtpbmRlbnRhdGlvblBlckxldmVsXT1cImluZGVudGF0aW9uUGVyTGV2ZWxcIlxuICAgICAgICAgICBbcHVzaFJvb3RTZWN0aW9uT25OZXdMaW5lXT1cInB1c2hSb290U2VjdGlvbk9uTmV3TGluZVwiXG4gICAgICAgICAgIFtjaGlsZHJlbl09XCJjaGlsZHJlblwiIFtleHBhbmRBbGxdPVwiZXhwYW5kQWxsXCJcbiAgICAgICAgICAgW3N0YXRlXT1cIm91dGxpbmVTdGF0ZVwiXG4gICAgICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtY29udGVudCBkdC1kYXRhLWNlbGxzICc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAnZHQtaXMtaG92ZXJhYmxlLXJvdyc6IHJvd0hvdmVyfVwiXG4gICAgICAgICAgIChvbkV4cGFuZENoYW5nZSk9XCJvbk91dGxpbmVFeHBhbmRDaGFuZ2UoJGV2ZW50KVwiPlxuXG4gICAgPG5nLXRlbXBsYXRlICNvdXRsaW5lIGxldC1yb3dEYXRhIGxldC1uZXN0aW5nTGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIiBsZXQtcm93SW5kZXg9XCJyb3dJbmRleFwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwicm93VGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6eyRpbXBsaWNpdDogcm93RGF0YSwgbmVzdGluZ0xldmVsOm5lc3RpbmdMZXZlbCwgY29sc1RvUmVuZGVyOmNvbHNUb1JlbmRlcn1cIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cInNob3dEZXRhaWxDb2x1bW4ocm93RGF0YSlcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJyb3dEZXRhaWxDb2x1bW4ucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiBmYWxzZSwgZGF0YTpyb3dEYXRhLCByb3dJbmRleDoocm93SW5kZXgpfVwiPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub0RhdGFcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8L3Rib2R5PlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLVxuICAgIERlZmF1bHQgdGVtcGxhdGUgdGhhdCBpcyBkaXNwbGF5IHdoZW4gdGhlcmUgYXJlIG5vIGRhdGFcbi0tPlxuPG5nLXRlbXBsYXRlICNub0RhdGE+XG4gICAgPHRyICpuZ0lmPVwiaXNFbXB0eSgpXCIgY2xhc3M9XCIgZHQtZW1wdHltZXNzYWdlLXJvd1wiXG4gICAgICAgIFtzdHlsZS52aXNpYmlsaXR5XT1cImxvYWRpbmcgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJ1wiPlxuXG4gICAgICAgIDx0ZCBbYXR0ci5jb2xzcGFuXT1cInZpc2libGVDb2x1bW5zKCkubGVuZ3RoXCIgY2xhc3M9XCJkdC1lbXB0eW1lc3NhZ2VcIj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIWVtcHR5TWVzc2FnZVRlbXBsYXRlXCI+e3tlbXB0eU1lc3NhZ2V9fTwvc3Bhbj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJlbXB0eU1lc3NhZ2VUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3RkPlxuICAgIDwvdHI+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tXG4gICAgVGVtcGxhdGUgdGhhdCByZW5kZXJzIGFjdHVhbCByb3cuIFJlbmRlcnMgYm90aCBoZWFkZXIgYW5kIGJvZHkgY29sdW1uLiBFYWNoIHJlbmRlcmVkXG4gICAgY29sdW1uIGhhcyBpdHMgb3duIHRlbXBsYXRlIGNhbGxlZCByZW5kZXJlclRlbXBsYXRlIHRoYXQgaGFzIGFsbCB0aGluZ3MgdGhhdCBuZWVkcyB0byBiZVxuICAgIHJlbmRlcmVkIGFuZCB3ZSBqdXN0IHRlbGwgdGhlIHRlbXBsYXRlIGlmIHdlIGFyZSByZW5kZXJpbmcgaGVhZGVyLCBzdWJoZWFkZXIgb3IgYm9keVxuLS0+XG48bmctdGVtcGxhdGUgI3Jvd1RlbXBsYXRlIGxldC1yb3dEYXRhIGxldC1ldmVuPVwiZXZlbnRcIiBsZXQtb2RkPVwib2RkXCIgbGV0LXJvd0luZGV4PVwicm93SW5kZXhcIlxuICAgICAgICAgICAgIGxldC1uZXN0aW5nTGV2ZWw9XCJuZXN0aW5nTGV2ZWxcIiBsZXQtY29sc1RvUmVuZGVyPVwiY29sc1RvUmVuZGVyXCI+XG5cblxuICAgIDx0ciAjcm93RWxlbWVudCBkdERyYWdnYWJsZVJvdyBbZG5kUm93SW5kZXhdPVwicm93SW5kZXhcIlxuICAgICAgICBjbGFzcz1cImR0LWJvZHktcm93XCJcbiAgICAgICAgKGNsaWNrKT1cIm9uSGFuZGxlUm93Q2xpY2tlZCgkZXZlbnQsIHJvd0RhdGEpXCJcbiAgICAgICAgW2F0dHIubmVzdGluZ0xldmVsXT1cIm5lc3RpbmdMZXZlbFwiXG4gICAgICAgIFtuZ0NsYXNzXT1cInsnZHQtZXZlbi1yb3cnOiBldmVuLCAnZHQtb2RkLXJvdyc6IG9kZCxcbiAgICAgICAgICAgICdkdC1yb3ctc2VsZWN0ZWQnOiBpc1Jvd1NlbGVjdGVkKHJvd0RhdGEpLFxuICAgICAgICAgICAgJ2R0LXJvdy1kcmFnZ2FibGUnOiBkbmRSb3dFbmFibGVkLFxuICAgICAgICAgICAgJ2R0LXJvb3Qtc2VjdGlvbic6IG5lc3RpbmdMZXZlbCA9PT0gMCB9XCI+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlIG5nRm9yIGxldC1jb2wgW25nRm9yT2ZdPVwiY29sc1RvUmVuZGVyXCIgbGV0LWNvbEluZGV4PVwiaW5kZXhcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJjb2wucmVuZGVyZXJUZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDp7JGltcGxpY2l0OiBmYWxzZSwgZGF0YTpyb3dEYXRhLCByb3dJbmRleDpyb3dJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgbmVzdGluZ0xldmVsOm5lc3RpbmdMZXZlbH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvdHI+XG48L25nLXRlbXBsYXRlPlxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWRhdGF0YWJsZXtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveH0udy1kYXRhdGFibGUgdGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO3dpZHRoOjEwMCU7dGFibGUtbGF5b3V0OmZpeGVkfS53LWRhdGF0YWJsZSB0Ym9keSwudy1kYXRhdGFibGUgdGQsLnctZGF0YXRhYmxlIHRoe291dGxpbmU6MH0uZHQtY2VsbC1kZWYsLmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7Ym9yZGVyOjFweCBzb2xpZCB0cmFuc3BhcmVudDtwYWRkaW5nOjE3cHggMTZweDtib3gtc2l6aW5nOmJvcmRlci1ib3h9LmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7Y3Vyc29yOnBvaW50ZXI7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX10aCAuZHQtY2VsbC1kZWYtc2VsZWN0YWJsZXtib3JkZXItd2lkdGg6NHB4IDFweCAxcHg7cGFkZGluZzoxNHB4IDE2cHggMTdweH10ZCAuZHQtY2VsbC1kZWYtc2VsZWN0YWJsZXtib3JkZXItd2lkdGg6MCAxcHggMCA1cHg7cGFkZGluZzoxN3B4IDE2cHggMTdweCAxM3B4fS5kdC1kYXRhLWNlbGxzIHRyLmR0LWlzLWhpZ2hsaWdodCwuZHQtZGF0YS1jZWxscyB0ci5kdC1pcy1ob3Zlcntib3JkZXItY29sb3I6aW5oZXJpdDtmb250LXdlaWdodDppbmhlcml0O2N1cnNvcjpwb2ludGVyfS53LWRhdGF0YWJsZS1ydGx7ZGlyZWN0aW9uOnJ0bH0udy1kYXRhdGFibGUtcnRsLnctZGF0YXRhYmxlLXJ0bC53LWRhdGF0YWJsZSB0aGVhZCB0aHt0ZXh0LWFsaWduOnJpZ2h0fS5kdC1yb290LXNlY3Rpb24gLmR0LWNlbGwtZGVmLC5kdC1yb290LXNlY3Rpb24gLmR0LWNlbGwtZGVmLXNlbGVjdGFibGV7YmFja2dyb3VuZC1jb2xvcjojZjNmNmY4O3BhZGRpbmc6MTBweCAxNnB4O2JvcmRlci1ib3R0b20tY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LWNvbG9yOnRyYW5zcGFyZW50fS5kdC1wbGFpbi1sYXlvdXQgLmR0LWlzLWFjdGl2ZSwuZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1kZWZhdWx0LC5kdC1wbGFpbi1sYXlvdXQgLmR0LWlzLWhpZ2hsaWdodCwuZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1ob3ZlciwuZHQtcGxhaW4tbGF5b3V0IC5kdC1pcy1ob3ZlcmFibGUtcm93e2JvcmRlci1yaWdodC1jb2xvcjp0cmFuc3BhcmVudH0uZHQtaXMtYWN0aXZlLC5kdC1pcy1kZWZhdWx0LC5kdC1pcy1oaWdobGlnaHQsLmR0LWlzLWhvdmVyLC5kdC1pcy1ob3ZlcmFibGUtcm93e2JvcmRlcjoxcHggc29saWQgI2Q3ZDdkNztiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Y29sb3I6IzM2MzYzNn0uZHQtcm93LXNlbGVjdGVkIHRke2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzgsMjU1LDIzOCwuNzEpfS5kdC1pcy1hY3RpdmV7Ym9yZGVyLWNvbG9yOiMwNjVkOWM7Y29sb3I6IzE5OWRlMH0uZHQtaXMtaGlnaGxpZ2h0e2JhY2tncm91bmQtY29sb3I6cmdiYSg2NSwxMTcsNSwuMTgpfS5kdC1pcy1oaWRkZW57ZGlzcGxheTpub25lfS5kdC11LXVuc2VsZWN0YWJsZS10ZXh0ey13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW8tdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5kdC11LXNvcnRhYmxle2N1cnNvcjpwb2ludGVyfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBPYmplY3RVdGlscyxcbiAgICAgICAgT3V0bGluZVN0YXRlLFxuICAgICAgICB7cHJvdmlkZTogREFUQV9TT1VSQ0UsIHVzZUNsYXNzOiBEVDJEYXRhU291cmNlLCBkZXBzOiBbRGF0YVByb3ZpZGVycywgRGF0YUZpbmRlcnNdfSxcbiAgICBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcblxufSlcbmV4cG9ydCBjbGFzcyBEYXRhdGFibGUyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFXRGF0YVRhYmxlLCBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQge1xuXG4gICAgLyoqXG4gICAgICogIExpc3Qgb2YgaXRlbXMgdG8gc2hvdyBpbiB0aGUgZGF0YXRhYmxlLlxuICAgICAqXG4gICAgICogIHRvZG86IGltcGxlbWVudCB0aGUgc2FtZSBEYXRhc291cmNlIGFuZCBsYXp5IGxvYWRpbmcganVzdCBsaWtlIEkgZGlkIGl0IGZvciBkYXRhdGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogTmFtZSBvZiB0aGUgZW50aXR5IGZvciB3aGljaCBEYXRhUHJvdmlkZXIgd2lsbCBiZSBsb2FkZWQuIFlvdSBjYW4gZWl0aGVyIHBhc3MgbGlzdCBvZiBpdGVtc1xuICAgICAqIG9yIHVzZSB0aGlzIGRlc3RpbmF0aW9uQ2xhc3MuIE5vdCBib3RoXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkZXN0aW5hdGlvbkNsYXNzOiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgVGFibGVXcmFwcGVyIHRvIGFkZCB1c2VyIGRlZmluZWQgY2xhcyBpbnRvIHRoZSB0YWJsZSB0YWdcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFibGVTdHlsZUNsYXNzOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgaGVhZGVyVGVtcGxhdGUgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYm9keUNsYXNzRm46IChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KSA9PiBzdHJpbmc7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaXNSb3dTZWxlY3RhYmxlOiAoaXRlbTogYW55KSA9PiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiAgSGlkZXMgb3Igc2hvd3MgdGFibGUgaGVhZGluZyB3aGVyZSB3ZSBoYXZlIGZpbHRlcnMgYW5kIHRvb2xzIG1lbnVzXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93VGFibGVIZWFkZXI6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGl2b3RhbExheW91dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbnRleHQ6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5pdGlhbFNvcnRPcmRlcjogc3RyaW5nID0gJ2Rlc2NlbmRpbmcnO1xuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBpbml0aWFsU29ydEtleTogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIERUIGlzIGxvYWRlZCBpbiB0aGUgcGFnZSBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZnVsbCBzY3JlZW4gKGZ1bGwgcGFnZSBtb2RlKSwgdGhpc1xuICAgICAqIGlzIGh0ZSBudW1iZXIgb2YgbGluZXMgdGhhdCBEVCB3aWxsIHNob3dcbiAgICAgKlxuICAgICAqIHRvZG86IGNvbWUgdXAgd2l0aCBiZXR0ZXIgbmFtZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzcGxheVJvd1NpemU6IG51bWJlciA9IDEwO1xuXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBwYWdpbmcgb24gbGF6eSBsb2FkaW5nIHVzaW5nIGluZmluaXRlIHNjcm9sbGVyIHRvIHNldCBpbml0aWFsIGZldGNoIGxpbWl0IHNpemVcbiAgICAgKlxuICAgICAqIHRvZG86IGNvbWUgdXAgd2l0aCBiZXR0ZXIgbmFtZSAhISFcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcGFnZVNpemU6IG51bWJlciA9IDE1O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRhdGFTb3VyY2U6IERUMkRhdGFTb3VyY2U7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1lc3NhZ2Ugd2hlbiB0aGVyZSBhcmUgbm8gZGF0YSAuXG4gICAgICpcbiAgICAgKiB0b2RvOiBVc2UgaTE4biB2YWx1ZSBhbmQgY3JlYXRlIHJlc291cmNlIGZpbGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGVtcHR5TWVzc2FnZTogc3RyaW5nID0gJ05vIHJlY29yZHMgZm91bmQnO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXZlbG9wZXIgY2FuIHByb3ZpZGUgY3VzdG9tIHRyYWNrQnkgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gaXRlcmF0ZSBvdmVyIHRoZVxuICAgICAqIHJlY29yZHNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd1RyYWNrQnk6IChpbmRleDogbnVtYmVyLCBpdGVtOiBhbnkpID0+IGFueTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gdHJ1ZSBhZGRzIGN1c3RvbSBob3ZlcmluZyBjbGFzcyB0byB0aGUgdGJvZHlcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHJvd0hvdmVyOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogRG8gd2Ugc2hvdyBsb2FkaW5nIGluZGljYXRvclxuICAgICAqXG4gICAgICogVG9kbzogcmVuYW1lIHRvIHNob3dMb2FkaW5nXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsb2FkaW5nOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZWxlY3Rpb25Nb2RlOiBTZWxlY3Rpb25Nb2RlID0gJ25vbmUnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDYW4gcHJvdmlkZSBjdXN0b20gaWNvbi4gVGhlc2UgaWNvbnMgYXJlIG5vdCBhbmltYXRlZCBkaXZzLCB3ZSB1c2VkIGNzc1xuICAgICAqIHRyYW5zZm9ybWF0aW9uIHRvIHJvdGF0ZSB0aGVtLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsb2FkaW5nSWNvbjogc3RyaW5nID0gJ2ljb24tc3luY2hyb25pemUnO1xuXG5cbiAgICAvKipcbiAgICAgKiBBZGRpdGlvbmFsIGluZGVudCBjYW4gYmUgYWRkZWQgd2hlbiByZW5kZXJpbmcgZGV0YWlsIHJvd1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5kZW50RGV0YWlsUm93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgaW5kZW50YXRpb25QZXJMZXZlbDogbnVtYmVyID0gMjU7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqICBTdWJIZWFkZXIgaXMgdXNlZCB0byBzaG93IHN1bW1hcnkgY29sdW1ucywgd2hpY2ggaW4gb3VyIFVYIGlzIHNob3duIGF0IHRoZSB0b3AganVzdCB1bmRlclxuICAgICAqICB0aGUgcmVndWxhciB0YWJsZSBoZWFkZXJcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2hvd1N1YkhlYWRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2VlIE91dGxpbmVGb3IgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2hpbGRyZW46ICh2YWx1ZTogYW55KSA9PiBhbnlbXTtcblxuXG4gICAgLyoqXG4gICAgICogV2UgbWlnaHQgaGF2ZSB0aGlzIGNvbmRpdGlvbmFsIGFzIHRoaXMgY2FuIGJlIGR5bmFtaWMgYmFzZWQgb24gdmFsdWUsIHNvIHRoZSBzYW1lXG4gICAgICogYXMgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIFNlZSBPdXRsaW5lRm9yIC0gb25seSB1c2VkIGluIHRoZSB0cmVlIG1vZGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dFeHBhbnNpb25Db250cm9sOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogU2VlIE91dGxpbmVGb3IgLSBvbmx5IHVzZWQgaW4gdGhlIHRyZWUgbW9kZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQWxsOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1c2hSb290U2VjdGlvbk9uTmV3TGluZTogYm9vbGVhbiA9IHRydWU7XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlciBvciBoaWRlIGV4cGFuc2lvbiBjb250cm9sIGZvciByb3cgZGV0YWlsIGNvbHVtbnMuIEV4cGFuc2lvbiBjb250cm9sIG1ha2VzIHNlbnNlIGZvclxuICAgICAqIHNpbXBsZSB0YWJsZSwgd2hlbiB1c2luZyB0aGlzIGluc2lkZSBvdXRsaW5lICh0cmVlIHRhYmxlKSwgaXRzIGRyaXZlbiBieSBvdXRsaW5lIGNvbnRyb2xcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dSb3dEZXRhaWxFeHBhbnNpb25Db250cm9sOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93U2VsZWN0aW9uQ29sdW1uOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dTZWxlY3RBbGw6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBTaG93IG9yIGhpZGUgZ2xvYmFsIHNlYXJjaCB0ZXJtIGlucHV0IGZpZWxkIGluIHRoZSBoZWFkZXJcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dHbG9iYWxTZWFyY2g6IGJvb2xlYW4gPSB0cnVlO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBjYXNlIGZyb3plbiBjb2x1bW4gYXJlIHVzaW5nIHdlIGNhbiBzcGVjaWZ5IG9uIGdsb2JhbCBsZXZlbCB0b3RhbCB3aWR0aCBvZiB0aGUgdGFibGUgdGhlXG4gICAgICogb3ZlcmZsb3dpbmcgY29udGVudCBvciB3aWR0aCBmb3IgZWFjaCBjb2x1bW4uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzY3JvbGxXaWR0aDogYW55O1xuXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIHJvdyByZW9yZGVyaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGRuZFJvd0VuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRmlyZXMgZXZlbnQgdGhhdCBzb3J0aW5nIGlzIGVuYWJsZWQgZm9yIGNvbHVtbiBhbmQgd2UgdHJpZ2dlciBzb3J0aW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblNvcnQ6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBCYXNlZCBvbiBzZWxlY3Rpb24gbW9kZSBpdCB0cmlnZ2VycyBldmVuXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvblJvd0NsaWNrOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBtdWx0aSBvciBzaW5nbGUgc2VsZWN0aW9uIG1vZGUgaXMgZW5hYmxlZCBpdCB3aWxsIHRyaWdnZXIgZXZlbnQgd2hlbiBjaGVja2JveCBvclxuICAgICAqIHJhZGlvIGJ1dHRvbnMgaXMgc2VsZWN0ZWRcbiAgICAgKlxuICAgICAqIHRvZG86IGltcGxlbWVudCBTaW5nbGVTZWxlY3Rpb25EVENvbHVtbiwgTXVsdGlTZWxlY3Rpb25EVENvbHVtbiB3aXRoIHRoZWlyIHJlbmRlcmVyc1xuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uUm93U2VsZWN0aW9uQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBjZWxsIGJvZHkgc2VsZWN0aW9uIGNoYW5nZXMgd2UgZmlyZSBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DZWxsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gY2VsbCBoZWFkZXIgc2VsZWN0aW9uIGNoYW5nZXMgd2UgZmlyZSBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25IZWFkZXJTZWxlY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cbiAgICBAQ29udGVudENoaWxkKERUSGVhZGVyQ29tcG9uZW50MilcbiAgICBoZWFkZXI6IERUSGVhZGVyQ29tcG9uZW50MjtcblxuXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBjdXN0b20gdGVtcGxhdGUgdGhhdCBjYW4gYmUgaW1wbGVtZW50ZWQgYnkgYXBwbGljYXRpb24gdG8gc2hvdyB3aGVuIHRoZXJlIGFyZVxuICAgICAqIG5vIGRhdGEgaW4gdGhlIGRhdGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdub0RhdGFUZW1wbCcpXG4gICAgZW1wdHlNZXNzYWdlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2R0SGVhZGVyJylcbiAgICBoZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2R0U3ViSGVhZGVyJylcbiAgICBzdWJIZWFkZXJUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2R0Qm9keScpXG4gICAgYm9keVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKCdoZWFkZXJGaWx0ZXInKVxuICAgIGhlYWRlckZpbHRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0cyB1c2VkIERUQ29sdW1uIGluc2lkZSBkYXRhdGFibGUgYW5kIHRoZW4gdGhleSBhcmUgdXNlZCBpbnNpZGUgdGhlIHRlbXBsYXRlIHRvXG4gICAgICogaXRlcmF0ZSBvdmVyIGFuZCB1c2UgaXRzIHJlbmRlcmVyVGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBXaGVuIHdlIHdpbGwgYmUgZGVmaW5pbmcgbmV3IGNvbHVtbnMgaXRzIGltcG9ydGFudCB0aGF0IGl0IGNhbiBhbHNvIG1hdGNoIGFsbCB0aGVcbiAgICAgKiBpbmhlcml0ZWQgb25lcy4gc28gd2UgbmVlZCB0byBtYWtlIHN1cmUgd2UgZGVmaW5lIGEgcHJvdmlkZXIgdGhvc2UgdGhvc2UgY29sdW1ucyB0byBwb2ludFxuICAgICAqIHRvIHRoZSBEVENvbHVtbkNvbXBvbmVudFxuICAgICAqXG4gICAgICogZS5nLjpcbiAgICAgKlxuICAgICAqIHtwcm92aWRlOiBEVENvbHVtbkNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGV0YWlsUm93Q29sdW1uKX1cbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oRFRDb2x1bW4yQ29tcG9uZW50KVxuICAgIGNvbHNRdWVyeTogUXVlcnlMaXN0PERUQ29sdW1uMkNvbXBvbmVudD47XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoRFREZXRhaWxSb3dDb21wb25lbnQpXG4gICAgcm93RGV0YWlsQ29sdW1uOiBEVERldGFpbFJvd0NvbXBvbmVudDtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VycyB3aGVuIGl0ZW1zIGluIHRoZSBsaXN0IGFyZSB1cGRhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGNsYXNzTGlzdDogc3RyaW5nID0gJ3ctZGF0YXRhYmxlICc7XG5cblxuICAgIC8qKlxuICAgICAqIEZvciBpbnRlcm5hbCB1c2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGF0YXNldCB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLiBTZXQgZnJvbSB0aGUgW2xpc3RdIGJpbmRpbmcgb3IgYnkgbGF6eSBsb2FkIGZyb21cbiAgICAgKiBkYXRhc291cmNlXG4gICAgICovXG4gICAgcHVibGljIGRhdGFUb1JlbmRlcjogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBXZSBjb252ZXJ0IFF1ZXJ5TGlzdDxEVENvbHVtbjJDb21wb25lbnQ+IHRvIHRoaXMgYXJyYXkgZm9yIGVhc2llciBtYW5pcHVsYXRpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uczogRFRDb2x1bW4yQ29tcG9uZW50W107XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2Vjb25kYXJ5IGxpc3Qgb2YgY29sdW1ucyB3aGljaCBpcyB1c2VkIGluIGNhc2Ugd2UgaGF2ZSBoYXZlIGVuYWJsZWRcbiAgICAgKiBmcm96ZW4gY29sdW1ucy4gQ29sdW1ucyB0aGF0IGFyZSBtYXJrZWQgYXMgZnJvemVuIG5lZWRzIHRvIGJlIHBsYWNlZCBpbnRvIHNlcGFyYXRlIGFycmF5XG4gICAgICogdG8gYmUgcmVuZGVyZWQgd2F5IHRoYW4gcmVndWxhciBjb2x1bW5zIHdoaWNoIGFyZSBzdG9yZWQgaW4gdGhlIGNvbHVtbnMgYXJyYXkuXG4gICAgICovXG4gICAgcHVibGljIGZyb3plbkNvbHVtbnM6IERUQ29sdW1uMkNvbXBvbmVudFtdO1xuXG5cbiAgICAvKipcbiAgICAgKiAgSW5kaWNhdGVzIHRoYXQgY29sdW1ucyB3ZXJlIGluaXRpYWxlZCBBbHNvIHVzZWQgd2hlbiB3ZSBoaWRlIGFuZCBzaG93IGNvbHVtbiB0byB0cmlnZ2VyXG4gICAgICogIGNoYW5nZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHB1YmxpYyBjb2x1bW5zQ2hhbmdlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBwdWJsaWMgc29ydENvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gY29sc1F1ZXJ5IGFuZCBpdHMgY2hhbmdlcyBzbyB3ZSBjYW4gbGF0ZXIgb24gcmVsZWFzZSB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICovXG4gICAgY29sdW1uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIGluaXRpYWxpemVkOiBib29sZWFuO1xuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKi9cbiAgICBkZXRhaWxSb3dFeHBhbnNpb25TdGF0ZTogRGV0YWlsUm93RXhwYW5zaW9uU3RhdGU7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIG51bWJlck9mQ29sc0JlZm9yZURhdGE6IG51bWJlciA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIHN0YXJ0T2ZGaXJzdERhdGFDb2x1bW46IG51bWJlciA9IDA7XG5cblxuICAgIC8qKlxuICAgICAqIFNlY3Rpb24gZm9yIHByb2dyYW1tYXRpY2FsbHkgaW5zdGFudGlhdGVkIGNvbHVtbnMgdGhhdCBhcmUgYWRkZWQgdG8gdGhlIGxpc3QgaWYgYWRkaXRpb25hbFxuICAgICAqIHNwYW4gb3IgbG9naWMgaXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogVG8gcHJvZ3JhbW1hdGljYWxseSBpbnNlcnQgYSBuZXcgY29sdW1uIGludG8gY29sdW1ucyBhcnJheSBsaWtlIGV4cGFuZG8gY29sdW1uIGZvciBkZXRhaWxcbiAgICAgKiByb3csIG9yIFNpbmdsZVNlbGVjdCwgTXVsdGlTZWxlY3QgY29sdW1uIHdoZW4gc2VsZWN0aW9uIGlzIGVuYWJsZWQgd2UgbmVlZCB0byB1c2VcbiAgICAgKiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gaW5zdGFudGlhdGUgYSBuZXcgY29tcG9uZW50LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSByb3dEZXRhaWxFeHBhbmRDb2x1bW46IERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQ7XG4gICAgcHJpdmF0ZSBtdWx0aVNlbGVjdENvbHVtbjogRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudDtcbiAgICBwcml2YXRlIHNpbmdsZVNlbGVjdENvbHVtbjogRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW4gY2FzZSBvZiBvdXRsaW5lIHRhYmxlIHdlIGFyZSBpbmplY3QgT3V0bGluZVN0YXRlIHdoaWNoIGlzIHByb3ZpZGVkIGluIHRoZSBEVCBjb21wb25lbnRcbiAgICAgKiBkZWZpbml0aW9uLiBUaGlzIGlzIHVzZWQgYnkgbmVzdGVkIG91dGxpbmVGb3IgY29tcG9uZW50IGl0IHNldCBpdHNlbGYgYXMgcmVmZXJlbmNlIGFuZFxuICAgICAqIGluaXRpYWxpemUgdGhlIHN0YXRlIHNvIGl0IGNhbiBiZSB1c2VkIGxhdGVyIG9uIGluc2lkZSBPdXRsaW5lQ29udHJvbFxuICAgICAqXG4gICAgICpcbiAgICAgKiBFYWNoIERhdGF0YWJsZSBpcyBwcmUtZGVmYXVsdGVkIHdpdGggaXRzIG93biB2ZXJzaW9uIG9mIERhdGFTb3VyY2Ugc28gYWxsIHRoZSBvYnNlcnZlcnNcbiAgICAgKiBpbnNpZGUgYXJlIHVuaXF1ZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LCBwdWJsaWMgZWw6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgQEluamVjdChEQVRBX1NPVVJDRSkgcHJpdmF0ZSBfZGVmYXVsdERTOiBEVDJEYXRhU291cmNlLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBjaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgcHVibGljIGZhY3RvcnlSZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBvdXRsaW5lU3RhdGU6IE91dGxpbmVTdGF0ZSxcbiAgICAgICAgICAgICAgICBwdWJsaWMgem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKGVudik7XG5cbiAgICAgICAgdGhpcy5kYXRhU291cmNlID0gdGhpcy5fZGVmYXVsdERTO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiBpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHVzZSBib3RoIGJpbmRpbmdzIFtsaXN0XSBhbmQgW2Rlc3RpbmF0aW9uQ2xhc3NdIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUgPSBuZXcgRGV0YWlsUm93RXhwYW5zaW9uU3RhdGUodGhpcyk7XG5cbiAgICAgICAgLy8gaW5pdCBkZWZhdWx0IGNvbHVtbnNcbiAgICAgICAgdGhpcy5yb3dEZXRhaWxFeHBhbmRDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuXG4gICAgICAgIHRoaXMubXVsdGlTZWxlY3RDb2x1bW4gPSB0aGlzLmZhY3RvcnlSZXNvbHZlclxuICAgICAgICAgICAgLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdENvbHVtbiA9IHRoaXMuZmFjdG9yeVJlc29sdmVyXG4gICAgICAgICAgICAucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQpLmNyZWF0ZSh0aGlzLmluamVjdG9yKS5pbnN0YW5jZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGRhdGEgYXJlIG5vdCBkZWZlcnJlZCBhbmQgd2UgZ2V0IGxpc3QgZGlyZWN0bHkgdGhlbiBpdCBjcmVhdGVzIERTLiBJZlxuICAgICAgICAgKiBuZ09uQ2hhbmdlcyBpcyBjYWxsZWQgZmlyc3Qgd2UgcHJvcGVybHkgaW5pdCBEUyBhbmQgY2xlYW4gdGhpcy5saXN0XG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGVzdGluYXRpb25DbGFzcykgfHwgaXNQcmVzZW50KHRoaXMubGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdERhdGFzb3VyY2UoKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RGF0YXNvdXJjZShmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaW5jZSB3ZSB3b3JrIHdpdGggcmVmZXJlbmNlcyBsZXQncyBwYXNzIGNyZWF0ZWQgbWFwIGluc2lkZSBvdXIgc3RhdGVcbiAgICAgICAgdGhpcy5vdXRsaW5lU3RhdGUuZXhwYW5zaW9uU3RhdGVzID0gdGhpcy5zdGF0ZS5vdXRsaW5lU3RhdGU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRhdGEgYXJyaXZlcyBsYXRlciBtYXliZSBkdWUgdG8gUkVTVCBBUEkgbGF0ZW5jeSwgaW5pdGlhbGl6ZSBEUyBvbmx5IHdoZW4gd2UgaGF2ZSBhXG4gICAgICogZGF0YSwgb3RoZXJ3aXNlIGlmIGRhdGEgY2hhbmdlZCB0aHJ1IHRoZSBiaW5kaW5ncyBqdXN0IHRyaWdnZXIgZGF0YUNoYW5nZSBldmVudFxuICAgICAqXG4gICAgICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcyhjaGFuZ2VzKTtcblxuICAgICAgICBpZiAoY2hhbmdlc1snbGlzdCddICYmIGlzUHJlc2VudChjaGFuZ2VzWydsaXN0J10uY3VycmVudFZhbHVlKVxuICAgICAgICAgICAgJiYgIXRoaXMuZGF0YVNvdXJjZS5pbml0aWFsaXplZCkge1xuXG4gICAgICAgICAgICB0aGlzLmluaXREYXRhc291cmNlKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFTb3VyY2UuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXIuZGF0YUNoYW5nZXMubmV4dCh0aGlzLmxpc3QpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGluaXQgYSBzdGF0ZSB3aGVuIGRldGFpbCBjb2x1bW4gaXMgcHJlc2VudFxuICAgICAgICAvLyB0b2RvOiBtb3ZlIHRoaXMgaW5pdGlhbGl6YXRpb24gdG8gZGF0YXNvdXJjZVxuICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgPSBpc1ByZXNlbnQodGhpcy5yb3dEZXRhaWxDb2x1bW4pO1xuXG4gICAgICAgIHRoaXMuaW5pdENvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uID0gdGhpcy5jb2xzUXVlcnkuY2hhbmdlcy5zdWJzY3JpYmUoXyA9PiB7XG4gICAgICAgICAgICB0aGlzLmluaXRDb2x1bW5zKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIC8vIGFzc2lnbiBpdCBwcm9ncmFtYXRpY2FsbHkgYXMgd2Ugd2FudCB0byBoYXZlIGEgY29udGV4dCBmb3IgdGhlIGZpbHRlclxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMucm93RGV0YWlsQ29sdW1uKSAmJiBpc1ByZXNlbnQodGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvcikpIHtcbiAgICAgICAgICAgIHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IuZmlsdGVyT3V0ID0gdGhpcy5za2lwT3V0bGluZUl0ZW0uYmluZCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5vdXRsaW5lU3RhdGUub3V0bGluZUZvcikpIHtcbiAgICAgICAgICAgIC8vIHRoaXMub3V0bGluZVN0YXRlLm91dGxpbmVGb3IuY2hhbmdlRGV0ZWN0b3IuZGV0YWNoKCk7XG4gICAgICAgICAgICAvLyB0aGlzLm91dGxpbmVTdGF0ZS5vdXRsaW5lRm9yLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3Q2hlY2tlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uc0NoYW5nZWQgJiYgdGhpcy5lbC5uYXRpdmVFbGVtZW50Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJvemVuQ29sdW1ucygpKSB7XG4gICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAgY29sLnBvc3RJbml0aWFsaXplKGluZGV4KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgICAgICAgICAgY29sLnBvc3RJbml0aWFsaXplKGluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXkgZW50cnkgbWV0aG9kIHRoYXQgaW5pdGlhbGl6ZWQgb3VyIGNvbHVtbnMuIExhdGVyIG9uIHdoZW4gd2Ugd2lsbCBzdXBwb3J0IHNlbGVjdGlvbiBhbmRcbiAgICAgKiBtdWx0aXNlbGVjdGlvbiB3ZSB3aWxsIHByb2dyYW1tYXRpY2FsbHkgaW5zdGFudGlhdGUgU2luZ2xlU2VsZWN0aW9uLCBNdWx0aVNlbGVjdGlvbiBjb2x1bW5cbiAgICAgKiBjb21wb25lbnRzIGFuZCBhZGQgdGhlbSB0byB0aGUgbGlzdCBzbyB0aGV5IGNhbiBiZSByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIHNvIHRoZSBpZGVhIGhlcmUgaXM6XG4gICAgICpcbiAgICAgKiBXaGVuIERUIGNvbXBvbmVudCBpbml0aWFsaXplIGFuZCB3ZSBhcmUgaW4gZWRpdGluZyBtb2RlIGFuZCB3ZSBzdXBwb3J0IFNpbmdsZS9NdWx0aSBzZWxlY3Rpb25cbiAgICAgKiB3ZSB3aWxsIHVzZSBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgdG8gY3JlYXRlIGNvbXBvbmVudCBhbmQgYWRkIGl0IGFzIGZpcnN0IGl0ZW0gdG8gdGhlIGxpc3RcbiAgICAgKiBhbmQgdGhlbiBpdCB3aWxsIGJlIHJlbmRlcmVkIGp1c3QgbGlrZSBhbnl0aGlnbiBlbHNlLlxuICAgICAqXG4gICAgICovXG4gICAgaW5pdENvbHVtbnMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29sdW1ucyA9IFtdO1xuICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMgPSBbXTtcblxuICAgICAgICBpZiAodGhpcy5kZXRhaWxSb3dFeHBhbnNpb25TdGF0ZS5kZXRhaWxFeHBhbnNpb25FbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluaXREZXRhaWxDb2x1bW5FeHBhbnNpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLm11bHRpU2VsZWN0Q29sdW1uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc0xlYWRpbmdTZWxlY3RDb2x1bW4oKSAmJiB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0aGlzLnNpbmdsZVNlbGVjdENvbHVtbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGV4cGFuc2lvbiBjb2x1bW4gd2hlbiBkZXRhaWwgcm93IGlzIGVuYWJsZWRcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmRldGFpbEV4cGFuc2lvbkVuYWJsZWQgJiYgIXRoaXMuaXNPdXRsaW5lKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKHRoaXMucm93RGV0YWlsRXhwYW5kQ29sdW1uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29sc1F1ZXJ5XG4gICAgICAgICAgICAuZmlsdGVyKChjb2wxOiBEVENvbHVtbjJDb21wb25lbnQpID0+ICFjb2wxLmZyb3plbilcbiAgICAgICAgICAgIC5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbC5pbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGNvbCk7XG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIHRoaXMuaW5pdEZyb3plbkNvbHVtbnMoKTtcbiAgICAgICAgdGhpcy5pbml0Q29sdW1uSW5mbygpO1xuICAgICAgICB0aGlzLmNvbHVtbnNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIHN1cmUgdGhhdCB3ZSBhbHNvIGluY2x1ZGUgcHJvZ3JhbW1hdGljIGNvbHVtbiBpZiBwcmVzZW50LiBNb3ZlIHRoZW0gdG8gdGhlIGNvcnJlY3RcbiAgICAgKiBhcnJheVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0RnJvemVuQ29sdW1ucygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb2xzUXVlcnlcbiAgICAgICAgICAgIC5maWx0ZXIoKGNvbDE6IERUQ29sdW1uMkNvbXBvbmVudCkgPT4gY29sMS5mcm96ZW4pXG4gICAgICAgICAgICAuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb2wuaW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZyb3plbkNvbHVtbnMucHVzaChjb2wpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5mcm96ZW5Db2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIGZpbmQgbGFzdCBpbmRleCBvZiBjb2x1bW4gdGhhdCBpcyBpbnRlcm5hbCAvIHByb2dyYW1tYXRpY1xuXG4gICAgICAgICAgICBsZXQgbGFzdElueCA9IHRoaXMuY29sdW1ucy5zbGljZSgpXG4gICAgICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgICAgIC5maW5kSW5kZXgoKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KSA9PiB0aGlzLmlzSW50ZXJuYWxDb2x1bW4oY29sKSk7XG5cbiAgICAgICAgICAgIGlmIChsYXN0SW54ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBpZHggPSB0aGlzLmNvbHVtbnMubGVuZ3RoIC0gMSAtIGxhc3RJbng7XG4gICAgICAgICAgICAgICAgbGV0IGludGVybmFsQ29scyA9IHRoaXMuY29sdW1ucy5zcGxpY2UoMCwgaWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm96ZW5Db2x1bW5zID0gWy4uLmludGVybmFsQ29scywgLi4udGhpcy5mcm96ZW5Db2x1bW5zXTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaGFzVmFsaWRDb2xzID0gdGhpcy5jb2x1bW5zXG4gICAgICAgICAgICAgICAgLmZpbmRJbmRleCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IGlzQmxhbmsoY29sLndpZHRoKSkgPT09IC0xO1xuXG4gICAgICAgICAgICBhc3NlcnQoaGFzVmFsaWRDb2xzIHx8IGlzUHJlc2VudCh0aGlzLnNjcm9sbFdpZHRoKSxcbiAgICAgICAgICAgICAgICAnV2hlbiB1c2luZyBbZnJvemVuXSBiaW5kaW5nIHlvdSBuZWVkIHNwZWNpZnkgW3dpZHRoXSBmb3IgZWFjaCAnICtcbiAgICAgICAgICAgICAgICAnY29sdW1uIG9yIFtzY3JvbGxXaWR0aF0gb24gZGF0YXRhYmxlIScpO1xuXG5cbiAgICAgICAgICAgIGFzc2VydChpc0JsYW5rKHRoaXMucm93RGV0YWlsQ29sdW1uKSxcbiAgICAgICAgICAgICAgICAnWW91IGNhbm5vdCBjb21iaW5lIGF3LWR0LWRldGFpbC1jb2x1bW4gd2l0aCBmcm96ZW4gY29sdW1ucyEnKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY3VycmVudCBjb2x1bW4gaXMgcHJvZ3JhbW1hdGljYWxseSBjcmVhdGVkXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0ludGVybmFsQ29sdW1uKGNvbDogRFRDb2x1bW4yQ29tcG9uZW50KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBjb2wgaW5zdGFuY2VvZiBEVFNpbmdsZVNlbGVjdENvbHVtbkNvbXBvbmVudCB8fFxuICAgICAgICAgICAgY29sIGluc3RhbmNlb2YgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCB8fFxuICAgICAgICAgICAgY29sIGluc3RhbmNlb2YgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudDtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBuZXcgRGF0YXNvdXJjZSBiYXNlZCBvbiBwYXNzZWQgdmFsdWVzLiBJdCB0cmllcyB0byBpbml0aWFsaXplIERTIGZvciBmaXJzdCB0aW1lXG4gICAgICogaW5zaWRlIHRoZSBuZ0luaXQgYnV0IGluIGNhc2UgRGF0YSBhcnJpdmVzIGxhdGVyIG1heWJlIGR1ZSB0byBzb21lIFJFU1QgQVBJIGNhbGxzIHRoaXNcbiAgICAgKiBjYW4gYmUgdHJpZ2dlcmVkIGFsc28gZnJvbSBuZ09uQ2hhbmdlcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXREYXRhc291cmNlKGluaXRpYWxpemU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gRGF0YXRhYmxlMlN0YXRlLmNyZWF0ZSgwLCB0aGlzLnBhZ2VTaXplLCB0aGlzLmRpc3BsYXlSb3dTaXplLFxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbFNvcnRLZXksIHRoaXMuc29ydE9yZGVyaW5nRm9yU3RyaW5nKHRoaXMuaW5pdGlhbFNvcnRPcmRlcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5saW1pdCA9IHRoaXMuc3RhdGUuZGlzcGxheUxpbWl0ID0gdGhpcy5kaXNwbGF5Um93U2l6ZTtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5pbml0aWFsU29ydEtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNvcnRLZXkgPSB0aGlzLmluaXRpYWxTb3J0S2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc29ydE9yZGVyID0gdGhpcy5zb3J0T3JkZXJpbmdGb3JTdHJpbmcodGhpcy5pbml0aWFsU29ydE9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbml0aWFsaXplKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuaW5pdCh7XG4gICAgICAgICAgICAgICAgb2JqOiBpc1ByZXNlbnQodGhpcy5kZXN0aW5hdGlvbkNsYXNzKSA/IHRoaXMuZGVzdGluYXRpb25DbGFzcyA6IHRoaXMubGlzdCxcbiAgICAgICAgICAgICAgICBxdWVyeVR5cGU6IFF1ZXJ5VHlwZS5GdWxsVGV4dCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgICAgICAgICBtdWx0aXNlbGVjdDogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLnN0YXRlKTtcblxuICAgICAgICAvLyByZXNldCBsaXN0IHRvIG1ha2Ugc3VyZSBpdCBjb21lcyBmcm9tIERhdGFQcm92aWRlciwgd2UgdXNlIGxpc3QgIHRvIGluaXRpYWxpemVcbiAgICAgICAgdGhpcy5saXN0ID0gbnVsbDtcblxuICAgICAgICAvLyBUaGlzIGlzIHRoZSBFTlRSWSBwb2ludCBmb3IgdGhlIERBVEEgQ0hBTkdFUy4gQWxsIGFkZGl0aW9uLCBlZGl0cywgZGVsZXRpb24gZW5kcyB1cFxuICAgICAgICAvLyBoZXJlLiBXZSBkb250IHdvcmsgZGlyZWN0bHkgd2l0aCBMSVNULiBBbnkgY2hhbmdlIGlzIHJlYWN0aXZlIGFuZCBoZXJlIGlzIGxpc3RlbmVyXG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5vcGVuKCkuc3Vic2NyaWJlKChkYXRhOiBhbnlbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMaXN0KGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRldGFpbFJvdyBjb2x1bW4gaXMgcHJlc2VudCB3ZSBpbml0aWFsaXplIGEgc3RhdGUgaG9sZGluZyBpbmZvcm1hdGlvbiB3aGljaCBpdGVtIGlzXG4gICAgICogZXhwYW5kZWQuXG4gICAgICpcbiAgICAgKiB0b2RvOiBUaGlzIGlzIHRlbXBvcmFyeSBoZXJlIGFuZCBvbmNlIHdlIHN1cG9ydCBsYXp5IGxvYWRpbmcgbW92ZSB0aGlzIHRvIGRhdGFzb3VyY2UuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSBmb3Igb3V0bGluZSB0cmVlIHRhYmxlIHdlIG5lZWQgdG8gY29ubmVjdCBhIHN0YXRlIGZyb20gb3V0bGluZSB3aXRoIGEgc3RhdGUgaW5cbiAgICAgKiBoZXJlIGFzIHdlIGFyZSB1c2luZyBvdXRsaW5lIGNvbnRyb2wgdG8gZXhwYW5kIGFuZCBjb2xsYXBzZSBpdGVtc1xuICAgICAqL1xuICAgIGluaXREZXRhaWxDb2x1bW5FeHBhbnNpb24oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGV0YWlsUm93RXhwYW5zaW9uU3RhdGUuZGV0YWlsRXhwYW5zaW9uRW5hYmxlZCA9IGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiZcbiAgICAgICAgICAgIEJvb2xlYW5XcmFwcGVyLmlzVHJ1ZSh0aGlzLnNob3dSb3dEZXRhaWxFeHBhbnNpb25Db250cm9sKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGV4ZWN1dGVkIGFmdGVyIHdlIGluaXRpYWxpemUgYWxsIHRoZSBjb2x1bW5zIGluIG9yZGVyIHRvIGNhbGN1bGF0ZSBjb3JyZWN0XG4gICAgICogbnVtYmVycyB1c2VkIGZvciBpbmRlbnRhdGlvbiB3aGlsZSByZW5kZXJpbmcgc2VsZWN0aW9uIGNvbHVtbnMgYXMgd2VsbCBhcyBkZXRhaWwgcm93IGNvbHVtbnMuXG4gICAgICpcbiAgICAgKiBIZXJlIHdlIG5lZWQgdG8gYmUgYXdhcmUgaG93IG1hbnkgY29sdW1ucyB0byBzcGFuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbml0Q29sdW1uSW5mbygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5udW1iZXJPZkNvbHNCZWZvcmVEYXRhID0gMDtcblxuICAgICAgICB0aGlzLmNvbHVtbnMuZm9yRWFjaCgoY29sOiBEVENvbHVtbjJDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghY29sLmlzVmFsdWVDb2x1bW4oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pbmRlbnREZXRhaWxSb3cpIHtcbiAgICAgICAgICAgIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGFydE9mRmlyc3REYXRhQ29sdW1uID0gdGhpcy5jb2x1bW5zLmxlbmd0aCAtIHRoaXMubnVtYmVyT2ZDb2xzQmVmb3JlRGF0YTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIHN0YXRlIG91dCB0byBhcHBsaWNhdGlvbi4gQ2FuIGJlIHVzZSBhcyB0d28gd2F5IGJpbmRpbmdzXG4gICAgICpcbiAgICAgKiBbKHN0YXRlKV09ZHRTdGF0ZShzKVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RhdGUoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zdGF0ZTtcbiAgICB9XG5cbiAgICBzZXQgc3RhdGUodmFsOiBhbnkpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnN0YXRlID0gdmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25DZWxsU2VsZWN0aW9uQ2hhbmdlKGNlbGw6IGFueSwgY29sdW1uOiBEVENvbHVtbjJDb21wb25lbnQsIGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlICE9PSAnY2VsbCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbG9va3VwS2V5ID0ge1xuICAgICAgICAgICAgY29sOiBjb2x1bW4ua2V5IHx8IGNvbHVtbi5sYWJlbCxcbiAgICAgICAgICAgIGl0ZW06IGl0ZW1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnN0YXRlLnNlbGVjdGlvbikgJiYgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGxvb2t1cEtleSk7XG4gICAgICAgICAgICBsZXQgaXNTZWxlY3RlZCA9IGZvdW5kSW5kZXggIT09IC0xO1xuXG4gICAgICAgICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodmFsOiBhbnksIGluZGV4OiBudW1iZXIpID0+IGluZGV4ICE9PSBmb3VuZEluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGxvb2t1cEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFtsb29rdXBLZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25DZWxsQ2hhbmdlLmVtaXQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhlYWRlclNlbGVjdGlvbkNoYW5nZShjZWxsOiBhbnksIGNvbHVtbjogRFRDb2x1bW4yQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0hlYWRlclNlbGVjdGVkKGNvbHVtbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uID0gY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oZWFkZXJTZWxlY3Rpb24gPSBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkhlYWRlclNlbGVjdGlvbi5lbWl0KHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICBvbkhhbmRsZVJvd0NsaWNrZWQoZXZlbnQ6IGFueSwgaXRlbTogYW55KTogdm9pZCB7XG4gICAgICAgIC8vIHNwZWNpYWwgYWx0IGtleSBtb2RpZmllci4gV2hlbiB1c2VkIHdpdGggcm93cyBpdCBpbmRpY2F0ZXMgdGhlcmUgaXMgYSBEJkQgZW5hYmxlZFxuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICB0aGlzLm9uUm93VG9nZ2xlKGV2ZW50LCBpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uTW9kZSA9PT0gJ3NpbmdsZScpIHtcbiAgICAgICAgICAgIHRoaXMub25Sb3dTZWxlY3QoZXZlbnQsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uUm93VG9nZ2xlKGV2ZW50OiBhbnksIGl0ZW06IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgcm93U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJiB0aGlzLnN0YXRlLnNlbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgZm91bmRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pO1xuICAgICAgICAgICAgbGV0IGlzU2VsZWN0ZWQgPSBmb3VuZEluZGV4ICE9PSAtMTtcblxuICAgICAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gZm91bmRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICByb3dTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi50aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvciB0aGUgb3V0bGluZSBnbyB1cCBhbmQgZG93biB0aGUgc3luYyB3aXRoIHRyZWVpdGVtc1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNPdXRsaW5lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvQ2hpbGRyZW4oaXRlbSwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vSGFuZGxlT3V0bGluZVJvd1RvZ2dsZVRvUGFyZW50KGl0ZW0sIGlzU2VsZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbaXRlbV07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3V0bGluZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGl0ZW0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoaXRlbSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblJvd1NlbGVjdGlvbkNoYW5nZS5lbWl0KHtcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IHJvd1NlbGVjdGVkLFxuICAgICAgICAgICAgaXRlbTogdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvblJvd1NlbGVjdChldmVudDogYW55LCBpdGVtOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBpdGVtO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICB0aGlzLm9uUm93U2VsZWN0aW9uQ2hhbmdlLmVtaXQoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkhhbmRsZU91dGxpbmVSb3dUb2dnbGVUb0NoaWxkcmVuKGN1cnJlbnRJdGVtOiBhbnksIGlzU2VsZWN0ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuRm9yTm9kZSA9IHRoaXMuY2hpbGRyZW4uYXBwbHkodGhpcy5jb250ZXh0LCBbY3VycmVudEl0ZW1dKSB8fCBbXTtcblxuICAgICAgICBpZiAoY2hpbGRyZW5Gb3JOb2RlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElmIGlzIHNlbGVjdGVkIGN1cnJlbnRseSB0aGVuIHRvZ2dsZSB0byBvdGhlciBzdGF0ZVxuICAgICAgICAgICAgaWYgKCFpc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBjaGVja2luZyBhbGwgZnJvbSByb290LCBkZXNlbGVjdCBjaGlsZHJlbiBhbmQgYWRkIGFsbFxuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjdXJyZW50SXRlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbLi4udGhpcy5zdGF0ZS5zZWxlY3Rpb24sIC4uLmNoaWxkcmVuRm9yTm9kZV07XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGVhY2ggY2hpbGRcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBjaGlsZHJlbkZvck5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kSW5kZXggPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHZhbDogYW55LCBpbmRleDogbnVtYmVyKSA9PiBpbmRleCAhPT0gZm91bmRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhcHBseSB0aGUgc2FtZSBmb3IgY2hpbGRyZW4gb2YgY2hpbGRyZW5cbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGNoaWxkcmVuRm9yTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9DaGlsZHJlbihjaGlsZCwgaXNTZWxlY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW06IGFueSwgaXNTZWxlY3RlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBsZXQgcGFyZW50ID0gY3VycmVudEl0ZW0uJCRwYXJlbnRJdGVtO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbkZvck5vZGUgPSB0aGlzLmNoaWxkcmVuLmFwcGx5KHRoaXMuY29udGV4dCwgW3BhcmVudF0pIHx8IFtdO1xuXG4gICAgICAgICAgICBsZXQgYWxsU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgY2hpbGRyZW5Gb3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgYWxsU2VsZWN0ZWQgPSBMaXN0V3JhcHBlci5maW5kSW5kZXhDb21wbGV4KHRoaXMuc3RhdGUuc2VsZWN0aW9uLCBjaGlsZCkgIT09IC0xXG4gICAgICAgICAgICAgICAgICAgICYmIGFsbFNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxsU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24ucHVzaChwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnRJbmRleCA9IExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWw6IGFueSwgaW5kZXg6IG51bWJlcikgPT4gaW5kZXggIT09IHBhcmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9IYW5kbGVPdXRsaW5lUm93VG9nZ2xlVG9QYXJlbnQoY3VycmVudEl0ZW0uJCRwYXJlbnRJdGVtLCBpc1NlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgb25EbkRSb3dEcm9wKG9yaWdQb3M6IG51bWJlciwgbmV3UG9zOiBudW1iZXIsIGRyb3BQb3M6IERyb3BQb3NpdGlvbik6IHZvaWQge1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZGF0YVNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdEcm9wcGluZyByb3cgIzogJywgb3JpZ1BvcyArICcgJyArIGRyb3BQb3MgKyAnIHJvdyAjOiAnICsgbmV3UG9zKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5yZW9yZGVyUm93cyhvcmlnUG9zLCBuZXdQb3MsIGRyb3BQb3MpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIG9uT3V0bGluZUV4cGFuZENoYW5nZShldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBpdGVtID0gZXZlbnQuaXRlbTtcblxuICAgICAgICAvLyBXZSBkb250IHJlYWxseSBuZWVkIHRvIHN0b3JlIGEgc3RhdGUgZm9ybSBvdXRsaW5lIGxvY2FsbHkgYXMgd2UgYXJlIHVzaW5nIHRoZSBzYW1lIG9iamVjdFxuICAgICAgICAvLyByZWZlcmVuY2VcbiAgICAgICAgLy8gdGhpcy5zdGF0ZS5vdXRsaW5lU3RhdGUgPSB0aGlzLm91dGxpbmVTdGF0ZS5leHBhbnNpb25TdGF0ZXM7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuVXNlRm9yRGV0YWlsUm93KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLnRvZ2dsZShpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRTaW5nbGUoKTogdm9pZCB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSAmJiBpc1ByZXNlbnQodGhpcy5zb3J0Q29sdW1uKSkge1xuXG4gICAgICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMuc29ydENvbHVtbi5rZXkpLCAnSW52YWxpZCBjb2x1bW4gdG8gc29ydCcpO1xuICAgICAgICAgICAgdGhpcy5kYXRhU291cmNlLnNvcnQodGhpcy5zb3J0Q29sdW1uLmtleSwgdGhpcy5zb3J0Q29sdW1uLnNvcnRPcmRlcik7XG5cbiAgICAgICAgICAgIHRoaXMub25Tb3J0LmVtaXQoe1xuICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLnNvcnRDb2x1bW4ua2V5LFxuICAgICAgICAgICAgICAgIG9yZGVyOiB0aGlzLnNvcnRDb2x1bW4uc29ydE9yZGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFuZGxlRGF0YUNoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc29ydEtleSB8fCB0aGlzLnNvcnRDb2x1bW4pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zb3J0Q29sdW1uICYmIHRoaXMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ydENvbHVtbiA9IHRoaXMuY29sdW1ucy5maW5kKFxuICAgICAgICAgICAgICAgICAgICBjb2wgPT4gY29sLmtleSA9PT0gdGhpcy5zdGF0ZS5zb3J0S2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlRGF0YVRvUmVuZGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLmxpc3QpO1xuICAgIH1cblxuICAgIHVwZGF0ZURhdGFUb1JlbmRlcihkYXRhc291cmNlPzogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGF0YVRvUmVuZGVyID0gZGF0YXNvdXJjZSB8fCB0aGlzLmxpc3Q7XG4gICAgICAgIC8vIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY3VycmVudCBpbW11dGFibGUgbGlzdCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uLiBOZWVkIHRvIHdyYXAgaXQgd2l0aFxuICAgICAqIHNldFRpbWVvdXQgYXMgdGhlIGNoYW5nZSBjYW4gZWFzaWx5IGNvbWUgYWZ0ZXIgdmlldyBjaGVja2VkIGFuZCB0aGlzIHdvdWxkIHJlc3VsdCBzb21lIGVycm9yc1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSB1cGRhdGVMaXN0KG5ld0xpc3Q6IGFueVtdKTogdm9pZCB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0ID0gbmV3TGlzdDtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGF0YUNoYW5nZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zb3J0Q29sdW1uID0gbnVsbDtcbiAgICAgICAgdGhpcy51cGRhdGVEYXRhVG9SZW5kZXIoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqL1xuICAgIGlzSGVhZGVyU2VsZWN0ZWQoaXRlbTogRFRDb2x1bW4yQ29tcG9uZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChpc0JsYW5rKHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNvbE1hdGNoZWQgPSBpdGVtLmtleSB8fCBpdGVtLmxhYmVsO1xuICAgICAgICBsZXQgY3VycmVudENvbCA9IHRoaXMuc3RhdGUuaGVhZGVyU2VsZWN0aW9uLmtleSB8fCB0aGlzLnN0YXRlLmhlYWRlclNlbGVjdGlvbi5sYWJlbDtcbiAgICAgICAgcmV0dXJuIGNvbE1hdGNoZWQgPT09IGN1cnJlbnRDb2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzQm9keUNlbGxTZWxlY3RlZChjb2x1bW46IERUQ29sdW1uMkNvbXBvbmVudCwgaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBsb29rdXBLZXkgPSB7XG4gICAgICAgICAgICBjb2w6IGNvbHVtbi5rZXkgfHwgY29sdW1uLmxhYmVsLFxuICAgICAgICAgICAgaXRlbTogaXRlbVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgTGlzdFdyYXBwZXIuZmluZEluZGV4Q29tcGxleCh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgbG9va3VwS2V5KSAhPT0gLTE7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc1Jvd1NlbGVjdGVkKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgaXNQcmVzZW50KHRoaXMuc3RhdGUuc2VsZWN0aW9uKSkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExpc3RXcmFwcGVyLmZpbmRJbmRleENvbXBsZXgodGhpcy5zdGF0ZS5zZWxlY3Rpb24sIGl0ZW0pICE9PSAtMTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVxdWFscyh0aGlzLnN0YXRlLnNlbGVjdGlvbiwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEbyB3ZSBoYXZlIGRhdGEgdG8gcmVuZGVyIFVzZWQgaW5zaWRlIHRlbXBsYXRlIHRvIHRlbGwgaWYgd2Ugc2hvdWxkIHVzZSB0aGUgTm9EYXRhIHRlbXBsYXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gaXNCbGFuayh0aGlzLmRhdGFUb1JlbmRlcikgfHwgKHRoaXMuZGF0YVRvUmVuZGVyLmxlbmd0aCA9PT0gMCk7XG4gICAgfVxuXG5cbiAgICBoYXNGcm96ZW5Db2x1bW5zKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMuZnJvemVuQ29sdW1ucykgJiYgdGhpcy5mcm96ZW5Db2x1bW5zLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICovXG4gICAgaGFzSW52aXNpYmxlU2VsZWN0aW9uQ29sdW1uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCkgJiYgIXRoaXMuc2hvd1NlbGVjdGlvbkNvbHVtbjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2VlIEFXRGF0YVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNMZWFkaW5nU2VsZWN0Q29sdW1uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlICE9PSAnbm9uZScgJiYgdGhpcy5zZWxlY3Rpb25Nb2RlICE9PSAnY2VsbCc7XG4gICAgfVxuXG5cbiAgICB2aXNpYmxlQ29sdW1ucygpOiBEVENvbHVtbjJDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnMgPyB0aGlzLmNvbHVtbnMuZmlsdGVyKGMgPT4gYy5pc1Zpc2libGUpIDogW107XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRPcmRlcmluZ0ZvclN0cmluZyhkaXJlY3Rpb246IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGlmIChpc0JsYW5rKGRpcmVjdGlvbikgfHwgZGlyZWN0aW9uID09PSAnYXNjZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gJ2Rlc2NlbmRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogbG9nIGJhZCBrZXlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG5cbiAgICBzb3J0T3JkZXJpbmdGb3JOdW1iZXIoZGlyZWN0aW9uOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZiAoaXNCbGFuayhkaXJlY3Rpb24pIHx8IGRpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuICdhc2NlbmRpbmcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxhbmsoZGlyZWN0aW9uKSB8fCBkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Rlc2NlbmRpbmcnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRvZG86IGxvZyBiYWQga2V5XG4gICAgICAgIHJldHVybiAnYXNjZW5kaW5nJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFNlZSBBV0RhdGFUYWJsZVxuICAgICAqXG4gICAgICovXG4gICAgdG9nZ2xlQWxsQ29sdW1ucyhldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcbiAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0ID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24gfHwgW107XG4gICAgICAgIGlmIChzZWxlY3RlZE9iamVjdC5sZW5ndGggPj0gY3VycmVudEl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zZWxlY3Rpb24gPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2VsZWN0aW9uID0gW107XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNlbGVjdGlvbiA9IFsuLi5jdXJyZW50SXRlbXNdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzVG9nZ2xlQWxsQ29sdW1uU2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcbiAgICAgICAgbGV0IHNlbGVjdGVkT2JqZWN0ID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24gfHwgW107XG5cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRJdGVtcy5sZW5ndGggPiAwICYmIHNlbGVjdGVkT2JqZWN0Lmxlbmd0aCA+PSBjdXJyZW50SXRlbXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGlzVG9nZ2xlQWxsQ29sdW1uRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBjdXJyZW50SXRlbXMgPSB0aGlzLmRhdGFUb1JlbmRlciB8fCBbXTtcblxuICAgICAgICByZXR1cm4gY3VycmVudEl0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVXNlZCBieSB0ZW1wbGF0ZSB0byBkZWNpZGUgaWYgd2UgbmVlZCB0byByZW5kZXIgRGV0YWlsUm93IHRlbXBsYXRlLiBXZSBuZWVkIHRvIGhhdmVcbiAgICAgKiBEZXRhaWxSb3cgQ29udGVudENoaWxkIGFuZCB1c2luZyBEZXRhaWxSb3cgY29tcG9uZW50IFtpc1Zpc2libGVGbl0gZnVuY3Rpb24gYmluZGluZyB3ZVxuICAgICAqIGNoZWNrIGlmIHRoZSBpdGVtIHRoYXQgaXMgYWJvdXQgdG8gYmUgcmVuZGVyZWQgaXMgZWxpZ2libGUgZm9yIGRldGFpbCByb3dcbiAgICAgKlxuICAgICAqL1xuICAgIHNob3dEZXRhaWxDb2x1bW4oaXRlbTogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLmNhblVzZUZvckRldGFpbFJvdyhpdGVtKSAmJiB0aGlzLmRldGFpbFJvd0V4cGFuc2lvblN0YXRlLmlzRXhwYW5kZWQoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhblVzZUZvckRldGFpbFJvdyhpdGVtOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnJvd0RldGFpbENvbHVtbikgJiZcbiAgICAgICAgICAgICg8RFREZXRhaWxSb3dDb21wb25lbnQ+dGhpcy5yb3dEZXRhaWxDb2x1bW4pLnNob3dEZXRhaWxSb3coaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYXRhVGFibGVcbiAgICAgKlxuICAgICAqL1xuICAgIGlzT3V0bGluZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogV2hlbiBkZWFsaW5nIHdpdGggZGV0YWlsIGNvbHVtbiAoZGV0YWlsIHJvdykgYW5kIG91dGxpbmUgYWxsIHRvZ2V0aGVyIHdlIG5lZWQgaGF2ZSBhXG4gICAgICogbWVjaGFuaXNtIHRvIHRlbGwgdG8gdGhlIG91dGxpbmUgXCJkb24ndCByZW5kZXIgdGhlIG5leHQgbGV2ZWwgb2YgaXRlbXNcIiBhbmQgdXNlIGRldGFpbCByb3cuXG4gICAgICogU28gY2VydGFpbiBpdGVtIHR5cGUgbmVlZHMgdG8gYmUgc2tpcHBlZC5cbiAgICAgKlxuICAgICAqIFRoZSB3YXkgd2Ugc2tpcCB0aG9zZSBpdGVtIGlzIHdlIHVzZSBpc1Zpc2libGVGbiBjb25kaXRpb24gb2YgdGhlIGRldGFpbCByb3cgYW5kIGxvb2sgYWhlYWRcbiAgICAgKiBpZiB3ZSBzaG91bGQgc2tpcCBuZXh0IGxldmVsLlxuICAgICAqXG4gICAgICovXG4gICAgc2tpcE91dGxpbmVJdGVtKGl0ZW06IGFueSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5Vc2VGb3JEZXRhaWxSb3coaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBTZWUgQVdEYVRhYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRWYWx1ZShkYXRhOiBhbnksIGZpZWxkOiBzdHJpbmcpOiBhbnkge1xuICAgICAgICByZXR1cm4gRmllbGRQYXRoLmdldEZpZWxkVmFsdWUoZGF0YSwgZmllbGQpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW5zU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIFBMQVRGT1JNX0lELFxuICAgIFJlbmRlcmVyMixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2Fzc2VydCwgRW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge1N1YmplY3QsIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiwgb2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtkZWJvdW5jZVRpbWUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBzd2l0Y2hNYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7aXNQbGF0Zm9ybUJyb3dzZXJ9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0luZmluaXRlU2Nyb2xsQ29tcG9uZW50fSBmcm9tICcuLi8uLi8uLi9jb3JlL2luZml0ZS1zY3JvbGwvaW5maXRlLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4uLy4uLy4uL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcblxuXG4vKipcbiAqIFBsZWFzZSBzZWUgZGF0YXRhYmxlIGZvciBtb3JlIGRldGFpbCBkZXNjcmlwdGlvbi4gQnV0IHRoZSBtYWluIGdvYWwgb2YgdGhpcyB3cmFwcGVyIHRvIHJlbW92ZVxuICogYWxsIHRoZSBjb21tb24gc3Vycm91bmRpbmcgcGFydHMgYXJvdW5kIHRoZSBkYXRhdGFibGUgYW5kIG1ha2Ugc3VyZSBEVCBjYW4gZm9jdXMgb25seSBhY3R1YWxcbiAqIGhlYWRlciBhbmQgYm9keSBzdHJ1Y3R1cmVcbiAqXG4gKiBJdCBpcyBleHBlY3RlZCB0aGF0IHdyYXBwZXIgYWxzbyBwcm92aWRlcyBzb21lIGNvZGUgZm9yIHRoZSBzbGlkaW5nIHVwIHBhbmVsIGNvbnRhaW5pbmdcbiAqIGJ1dHRvbnMgYW5kIG90aGVyIGFjdGlvbnMgdGhhdCB3aWxsIGJlIHVzZWQgZHVyaW5nIGVkaXRpbmdcbiAqXG4gKlxuICogVG9kbzogRXh0cmFjdCB0aGUgZXhwYW5kIGxvZ2ljIG91dCBpbnRvIHNvbWUgZGlyZWN0aXZlIG9yIGNvbXBvbmVudCBvciBqdXN0IGEgY2xhc3NcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctZHQtd3JhcHBlcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IFtuZ0NsYXNzXT1cImR0LnN0eWxlQ2xhc3NcIiBbY2xhc3MuZHQtZnVsbC1zY3JlZW4tbW9kZV09XCJpc0Z1bGxTY3JlZW5Nb2RlXCJcbiAgICAgW3N0eWxlLndpZHRoXT1cImR0LndpZHRoXCJcbj5cbiAgICA8ZGl2IGNsYXNzPVwiZHQtbG9hZGluZy1vdmVybGF5XCIgKm5nSWY9XCJkdC5sb2FkaW5nXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImR0LWxvYWRpbmctY29udGVudFwiICpuZ0lmPVwiZHQubG9hZGluZ1wiPlxuICAgICAgICA8aSBbY2xhc3NdPVwiJ3NhcC1pY29uIHUtZHQtc3Bpbi1pY29uICcgKyBkdC5sb2FkaW5nSWNvblwiPjwvaT5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJkdC1oZWFkZXJcIiAqbmdJZj1cImR0LnNob3dUYWJsZUhlYWRlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJkdC5oZWFkZXI7IHRoZW4gYXBwRGVmaW5lZEhlYWRlciBlbHNlIGRlZmF1bHRIZWFkZXJcIj48L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBEVCBCT0RZIHdpdGggdGFibGUgaGVhZGVycyBhbmQgdmFsdWVzIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJkdC1ib2R5LXdyYXBwZXItdmlld1wiPlxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgICpuZ0lmPVwiZHQuaGFzRnJvemVuQ29sdW1ucygpOyB0aGVuIGR0Qm9keVdpdGhGcm96ZW5Db2x1bW5zIGVsc2UgZHRCb2R5Tm9Gcm96ZW5Db2x1bW5zXCI+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tPGRpdiBjbGFzcz1cImR0LWZvb3RlclwiICpuZ0lmPVwiZm9vdGVyXCI+LS0+XG4gICAgPCEtLSZsdDshJm5kYXNoOyBmb290ZXJBcmVhJm5kYXNoOyZndDstLT5cbiAgICA8IS0tPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctZHQtZm9vdGVyXCI+PC9uZy1jb250ZW50Pi0tPlxuICAgIDwhLS08L2Rpdj4tLT5cbjwvZGl2PlxuXG48IS0tIHRvZG86IGRvbnQgYWN0aXZhdGUgdGhpcyBpZiB3ZSByZWFjaGVkIHRoZSBlbmQgb2YgbGlzdCAtIC0tPlxuPGF3LWluZmluaXRlLXNjcm9sbCAjaW5maW5pdGVTY3JvbGwgKm5nSWY9XCJpc0Z1bGxTY3JlZW5Nb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgW2Rpc3RhbmNlXT1cIicxMCUnXCJcbiAgICAgICAgICAgICAgICAgICAgW2ZldGNoU2l6ZV09XCJkdC5zdGF0ZS5saW1pdFwiXG4gICAgICAgICAgICAgICAgICAgIChvbkxvYWQpPVwib25MYXp5TG9hZCgkZXZlbnQpXCI+XG48L2F3LWluZmluaXRlLXNjcm9sbD5cblxuXG48bmctdGVtcGxhdGUgI2FwcERlZmluZWRIZWFkZXI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRpbmc7XCI+PC9uZy1jb250YWluZXI+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRIZWFkZXI+XG4gICAgPGRpdiBjbGFzcz1cImR0LWdsb2JhbC1maWx0ZXJcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzYXAtaWNvbiBpY29uLWZpbHRlclwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJkdC1nbG9iYWwtYWN0aW9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZHQtYWN0aW9uLWNvbWJvXCI+XG4gICAgICAgICAgICA8c3BhbiAqbmdJZj1cInN1cHBvcnRGdWxsU2NyZWVuXCIgY2xhc3M9XCJzYXAtaWNvbiBpY29uLXJlc2l6ZVwiXG4gICAgICAgICAgICAgICAgICAoY2xpY2spPVwidG9nZ2xlRnVsbFNjcmVlbigkZXZlbnQpXCI+PC9zcGFuPlxuXG4gICAgICAgICAgICA8YXctaW5wdXQtZmllbGQgKm5nSWY9XCJkdC5zaG93R2xvYmFsU2VhcmNoXCIgc3R5bGVDbGFzcz1cImR0LXRhYmxlLXNlYXJjaFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJkdC5zdGF0ZS5jdXJyZW50U2VhcmNoUXVlcnlcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlSG9sZGVyPVwic2VhcmNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpY29uPVwiaWNvbi1zZWFyY2hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuZ01vZGVsQ2hhbmdlKT1cInNlYXJjaFRlcm1zLm5leHQoJGV2ZW50KVwiPlxuICAgICAgICAgICAgPC9hdy1pbnB1dC1maWVsZD5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYXJpYmEtaWNvbiBpY29uLW1vcmVcIj48L3NwYW4+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2R0Qm9keU5vRnJvemVuQ29sdW1ucz5cbiAgICA8IS0tXG4gICAgICAgIEZvciBub24tZnJvemVuIGNhc2Ugd2UgYWxzbyBuZWVkIHRvIHNldCBUUlVFIGFzIHRoZSB2aWV3IGlzIGFjdHVhbGx5IGZyb3plbiBhbmQgZG9lcyBub3RcbiAgICAgICAgc2Nyb2xsLlxuICAgICAgICBXZSB1c2UgdGhpcyBmcm96ZW5Db2x1bW5zIGZsYWcgaW5zaWRlIERUIHRvIHByb3Blcmx5IHNldCBjb2x1bW4gaW5kZXggb24gdGhlIGhlYWRlciBsZXZlbFxuICAgICAgICBjb2x1bW5JbmRleDooZnJvemVuID8gY29sdW1uSW5kZXg6IChjb2x1bW5zLmxlbmd0aCArIGNvbHVtbkluZGV4KSlcblxuICAgICAgICB0aGVyZWZvcmUgd2UgbmVlZCB0byBzZXQgdHJ1ZSBldmVuIGluIHRoaXMgY2FzZSB0byByZXR1cm4gcmVhbCBjb2x1bW5JbmRleCBzaW5jZSB3ZSBkb250XG4gICAgICAgIGhhdmUgdGhlIHNlY29uZCB0YWJsZS5cbiAgICAtLT5cbiAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHRCb2R5OyBjb250ZXh0OnskaW1wbGljaXQ6IGR0LmNvbHVtbnMsIGZyb3plbkNvbHVtbnM6IHRydWUgfVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkdEJvZHlXaXRoRnJvemVuQ29sdW1ucz5cbiAgICA8bmctY29udGFpbmVyXG4gICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHRCb2R5OyBjb250ZXh0OnskaW1wbGljaXQ6IGR0LmZyb3plbkNvbHVtbnMsIGZyb3plbkNvbHVtbnM6IHRydWUgfVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJkdEJvZHk7IGNvbnRleHQ6eyRpbXBsaWNpdDogZHQuY29sdW1ucywgZnJvemVuQ29sdW1uczogZmFsc2UgfVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48bmctdGVtcGxhdGUgI2R0Qm9keSBsZXQtY29sdW1ucyBsZXQtZnJvemVuQ29sdW1ucz1cImZyb3plbkNvbHVtbnNcIj5cblxuICAgIDxkaXYgI2R0Q29udGFpbmVyIGNsYXNzPVwiZHQtYm9keS13cmFwcGVyXCJcbiAgICAgICAgIFtzdHlsZS53aWR0aC5weF09XCJ0aGlzLmNhbGN1bGF0ZUZyb3plbldpZHRoKClcIlxuICAgICAgICAgW2NsYXNzLmR0LWJvZHktdW5mcm96ZW5dPVwiZHQuaGFzRnJvemVuQ29sdW1ucygpICYmICFmcm96ZW5Db2x1bW5zXCJcbiAgICAgICAgIFtjbGFzcy5kdC1ib2R5LWZyb3plbl09XCJkdC5oYXNGcm96ZW5Db2x1bW5zKCkgJiYgZnJvemVuQ29sdW1uc1wiXG4gICAgPlxuXG4gICAgICAgIDx0YWJsZSBbbmdDbGFzc109XCJkdC50YWJsZVN0eWxlQ2xhc3NcIlxuICAgICAgICAgICAgICAgW3N0eWxlLndpZHRoXT1cImZyb3plbkNvbHVtbnMgPyBudWxsIDogZHQuc2Nyb2xsV2lkdGhcIlxuICAgICAgICAgICAgICAgW2NsYXNzLmR0LXBpdm90LWxheW91dF09XCJkdC5waXZvdGFsTGF5b3V0XCJcbiAgICAgICAgICAgICAgIFtjbGFzcy5kdC1wbGFpbi1sYXlvdXRdPVwiIWR0LnBpdm90YWxMYXlvdXQgJiYgIWR0LmlzT3V0bGluZSgpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gUmVuZGVyIFRIIGhlYWRlciByb3dzLS0+XG4gICAgICAgICAgICA8dGhlYWQgY2xhc3M9XCJkdC10aGVhZFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXJSb3dzOyBjb250ZXh0OnskaW1wbGljaXQ6IGNvbHVtbnMsZnJvemVuQ29sdW1uczpmcm96ZW5Db2x1bW5zIH1cIj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvdGhlYWQ+XG5cbiAgICAgICAgICAgIDwhLS1cbiAgICAgICAgICAgICAgICBSZW5kZXIgZGF0YSByb3dzLiBGb3IgZGF0YSByb3dzIHdlIG5lZWQgdG8ga2VlcCB0Ym9keSB0YWcgaW5zaWRlIERUIHRhYmxlXG4gICAgICAgICAgICAgICAgZHVlIHRvIE91dGxpbmVcbiAgICAgICAgICAgICAtLT5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJib2R5Um93czsgY29udGV4dDp7JGltcGxpY2l0OiBjb2x1bW5zLCAgZnJvemVuQ29sdW1uczpmcm96ZW5Db2x1bW5zIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3RhYmxlPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuXG48ZGl2ICNkdEZ1bGxTY3JlZW5PdmVybGF5IGNsYXNzPVwiZHQtZnVsbC1zY3JlZW4tb3ZlcmxheSB1LWZ1bGwtc2NyZWVuLWVsZW1lbnRcIj48L2Rpdj5cbmAsXG4gICAgc3R5bGVzOiBbYC5kdC1mb290ZXIsLmR0LWhlYWRlcnt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOi41ZW0gLjc1ZW07Ym94LXNpemluZzpib3JkZXItYm94fS5kdC1mb290ZXJ7Ym9yZGVyLXRvcDowfS5kdC10aGVhZCB0cntib3JkZXItd2lkdGg6MH0uZHQtYm9keS13cmFwcGVyLXZpZXd7cG9zaXRpb246cmVsYXRpdmV9LmR0LWJvZHktd3JhcHBlcntvdmVyZmxvdzpoaWRkZW47Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3fS5kdC1ib2R5LXdyYXBwZXIuZHQtYm9keS11bmZyb3plbntib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtvdmVyZmxvdy14OmF1dG99LmR0LWxvYWRpbmctb3ZlcmxheXtwb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kLWNvbG9yOiM5YjliOWI7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvcGFjaXR5Oi4xO3otaW5kZXg6MX0uZHQtbG9hZGluZy1jb250ZW50e3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6NTAlO3RvcDoyNSU7ei1pbmRleDoyfS5kdC1oZWFkZXJ7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7ZmxleC1mbG93OnJvdyBub3dyYXA7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47Y29sb3I6IzM2MzYzNjtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZjFmMWYxO21hcmdpbi1ib3R0b206MzBweH0uZHQtaGVhZGVyIC5kdC1nbG9iYWwtZmlsdGVye2ZsZXg6MCAwO2FsaWduLWl0ZW1zOmZsZXgtc3RhcnQ7Zm9udC1zaXplOjE4cHh9LmR0LWhlYWRlciAuZHQtZ2xvYmFsLWFjdGlvbnN7ZmxleDowIDA7YWxpZ24taXRlbXM6ZmxleC1lbmR9LmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJve2Rpc3BsYXk6ZmxleDtmbGV4LWZsb3c6cm93IG5vd3JhcDtjb2xvcjojN2Q3ZDdkfS5kdC1oZWFkZXIgLmR0LWFjdGlvbi1jb21ibyAuYXJpYmEtaWNvbiwuZHQtaGVhZGVyIC5kdC1hY3Rpb24tY29tYm8gLnNhcC1pY29ue21hcmdpbi1sZWZ0OjE1cHg7Zm9udC1zaXplOjIwcHg7YWxpZ24tc2VsZjpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9LmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJvIC5kdC10YWJsZS1zZWFyY2h7Ym9yZGVyLXRvcC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnR9LmR0LWhlYWRlciAuZHQtYWN0aW9uLWNvbWJvIC5pY29uLXJlc2l6ZXtjb2xvcjojNGE0YTRhO2ZvbnQtc2l6ZToxNnB4O2xpbmUtaGVpZ2h0OjE4cHg7bWFyZ2luLXJpZ2h0OjE1cHh9LnUtZHQtc3Bpbi1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrOy13ZWJraXQtYW5pbWF0aW9uOjJzIGxpbmVhciBpbmZpbml0ZSBkb1NwaW47YW5pbWF0aW9uOjJzIGxpbmVhciBpbmZpbml0ZSBkb1NwaW59QC13ZWJraXQta2V5ZnJhbWVzIGRvU3BpbnswJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMCk7dHJhbnNmb3JtOnJvdGF0ZSgwKX0xMDAley13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgzNjBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKX19QGtleWZyYW1lcyBkb1NwaW57MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9MTAwJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMzYwZGVnKTt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fS5kdC1mdWxsLXNjcmVlbi1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MTAwOy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTt0cmFuc2l0aW9uOmFsbCAuNHMgZWFzZS1pbi1vdXR9LmR0LWZ1bGwtc2NyZWVue3dpZHRoOjk4dnc7ei1pbmRleDoxMjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjE1cHg7cG9pbnRlci1ldmVudHM6YWxsO3RyYW5zaXRpb246b3BhY2l0eSAuNXMgZWFzZS1pbi1vdXR9LnUtZnMtZWxlbWVudC1vdXR7ZGlzcGxheTpub25lfWBdLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcblxufSlcbmV4cG9ydCBjbGFzcyBEVFdyYXBwZXIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZFxue1xuXG4gICAgLyoqXG4gICAgICogQ29sb3IgdGhhdCBpcyB1c2VkIGJ5IGZ1bGwgc2NyZWVuIGRpdiBvdmVybGF5IHRvIGNyZWF0ZSBleHBhbmRpbmcgZWZmZWN0IHdoaWNoIG5lZWRzIHRvIGhhdmVcbiAgICAgKiBsaXR0bGUgdGVudDtcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQ29sb3JGcm9tOiBzdHJpbmcgPSAnI2YzZjNmMyc7XG5cblxuICAgIC8qKlxuICAgICAqIENvbG9yIHRoYXQgaXMgdXNlZCB0byBzZXQgYWZ0ZXIgd2UgYXJlIGluIHRoZSBmdWxsIHNjcmVlbiBzbyBvdXIgb3ZlcmxheSBkaXYgaGlkZSBldmVyeXRoaW5nXG4gICAgICogb24gdGhlIHBhZ2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZXhwYW5kQ29sb3JUbzogc3RyaW5nID0gJyNGRkZGRkYnO1xuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRhYmxlIGhlYWRpbmcgYXJlYSBvZmZlcnMgZGV2ZWxvcGVyIHRvIGNvbXBsZXRlbHkgb3ZlcnJpZGUgdGhlIHRvcCBiYXIgd2hlcmUgd2UgaGF2ZSBmaWx0ZXJzXG4gICAgICogYW5kIG90aGVycyBhY3Rpb25zLlxuICAgICAqXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGluZ0FyZWEnKVxuICAgIGhlYWRpbmc6IFRlbXBsYXRlUmVmPGFueT47XG5cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGFibGUgaGVhZGVycyBhbmQgd3JhcHMgdGhlbSB3aXRoaW4gdGhlYWQgdGFnXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnaGVhZGVyUm93cycpXG4gICAgaGVhZGVyUm93czogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0YWJsZSBib2R5XG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZCgnYm9keVJvd3MnKVxuICAgIGJvZHlSb3dzOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2FtZSBhcyBoZWFkaW5nIHRlbXBsYXRlLiBXZSBuZWVkIHRvIHJlbW92ZSB0aGlzIGRlcGVuZGVuY3kgb24gcHJpbWVORyBzbyBmYXIgaXQgaXMgdXNpbmdcbiAgICAgKiBwLWZvb3RlclxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2Zvb3RlckFyZWEnKVxuICAgIGZvb3RlcjogVGVtcGxhdGVSZWY8YW55PjtcblxuXG4gICAgLyoqXG4gICAgICogRGl2IHVzZWQgdG8gbWFrZSB0aGUgZnVsbCBzY3JlZW4gZXhwYW5zaW9uIGVmZmVjdFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2R0RnVsbFNjcmVlbk92ZXJsYXknKVxuICAgIGR0RnVsbFNjcmVlbk92ZXJsYXk6IEVsZW1lbnRSZWY7XG5cblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byBpbmZpdGUgc2Nyb2xsLiBXZSBhcmUgdXNpbmcgdGhpcyB0byB0cmlnZ2VyIGxvYWRpbmcgZmluaXNoIGV2ZW50IHNvIHdlIGNhblxuICAgICAqIGhpZGUgbG9hZGluZyBhbmltYXRpb25cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdpbmZpbml0ZVNjcm9sbCcpXG4gICAgaW5maW5pdGVTY3JvbGw6IEluZmluaXRlU2Nyb2xsQ29tcG9uZW50O1xuXG5cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBkZWJvdW5jZSB0aGUgdHlwaW5nIHdlIG5lZWQgdG8gdXNlIHN1YmplY3RcbiAgICAgKlxuICAgICAqL1xuICAgIHNlYXJjaFRlcm1zID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiAgU3BlY2lmaWVzIGlmIHdlIGFyZSBpbiB2aWV3aW5nL2VkaXRpbmcgbW9kZSB0aGF0IGNhbiBicm93c2Ugd2hvbGUgZGF0YXNldCBsYXppbHlcbiAgICAgKlxuICAgICAqL1xuICAgIGlzRnVsbFNjcmVlbk1vZGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRlbGxzIGlmIHdlIGNhbiBzdXBwb3J0IGZ1bGwgc2NyZWVuIG1vZGUgLSBvbmx5IGF2YWlsYWJsZSBmb3IgdGhlIGJyb3dzZXJcbiAgICAgKlxuICAgICAqL1xuICAgIHN1cHBvcnRGdWxsU2NyZWVuOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICogIFNhdmVzIG9yaWdpbmFsIGJvdW5kaW5nIHJlY3QgY29vcmRpbmF0ZXMgYmVmb3JlIHdlIGV4cGFuZCB0aGUgRFQgdG8gZnVsbCBzY3JlZW5cbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgZHRCb3VuZGluZ0NsaWVudFJlY3Q6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFJlbWVtYmVycyBvcmlnaW5hbCBzY3JvbGwgcG9zaXRpb24gYmVmb3JlIHdlIHN3aXRjaCB0byBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICovXG4gICAgcHJpdmF0ZSBvcmlnaW5hbFNjcm9sbFBvc2l0aW9uOiBudW1iZXI7XG5cbiAgICBxdWVyeVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIGxvYWRpbmdTdWI6IFN1YnNjcmlwdGlvbjtcblxuXG4gICAgY29uc3RydWN0b3IgKHB1YmxpYyBlbnY6IEVudmlyb25tZW50LFxuICAgICAgICAgICAgICAgICBwcml2YXRlIHJlbmRlcjogUmVuZGVyZXIyLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIHRoaXNFbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICAgICAgICAgICBwcml2YXRlIGRvbVV0aWxzOiBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgICAgICAgICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YXRhYmxlMkNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgIHB1YmxpYyBkdDogRGF0YXRhYmxlMkNvbXBvbmVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICB0aGlzLnF1ZXJ5U3Vic2NyaXB0aW9uID0gdGhpcy5zZWFyY2hUZXJtcy5waXBlKFxuICAgICAgICAgICAgLy8gd2FpdCAzMDBtcyBhZnRlciBlYWNoIGtleXN0cm9rZSBiZWZvcmUgY29uc2lkZXJpbmcgdGhlIHRlcm1cbiAgICAgICAgICAgIGRlYm91bmNlVGltZSgzMDApLFxuXG4gICAgICAgICAgICAvLyBpZ25vcmUgbmV3IHRlcm0gaWYgc2FtZSBhcyBwcmV2aW91cyB0ZXJtXG4gICAgICAgICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKHRlcm06IHN0cmluZykgPT4gb2YodGVybSkpXG4gICAgICAgICkuc3Vic2NyaWJlKCh0ZXJtOiBhbnkpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0ZXJtKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZpbmQodGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubG9hZGluZ1N1YiA9IHRoaXMuZHQudmFsdWVDaGFuZ2VcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGRhdGE6IGFueSkgPT4gdGhpcy5sb2FkaW5nRmluaXNoZWQoKSk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBjb2x1bW5zIG1hcmtlZCBhcyBmcm96ZW4gYW5kIHJldHJpZXZlIGEgd2lkdGggc28gd2UgY2FuIHVwZGF0ZVxuICAgICAqIHBhcmVudCBkaXZcbiAgICAgKlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUZyb3plbldpZHRoICgpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGlmICghdGhpcy5kdC5oYXNGcm96ZW5Db2x1bW5zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuZHQuZnJvemVuQ29sdW1ucy5mb3JFYWNoKChjb2w6IERUQ29sdW1uMkNvbXBvbmVudCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKGNvbC5tYXhXaWR0aFB4ID4gMCkge1xuICAgICAgICAgICAgICAgIGZXaWR0aCArPSBjb2wud2lkZXN0Q2VsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZldpZHRoICs9IHBhcnNlSW50KGNvbC53aWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmV2lkdGg7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGhhdmluZyB0d28gc2VwYXJhdGUgdGFibGVzIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgcm93cyBvZiB0aGUgdGFibGVzIGFyZSBhbGlnbmVkLlxuICAgICAqXG4gICAgICogVGhlcmVmb3JlIHRoaXMgbWV0aG9kIHRha2VzIGZpcnN0IGNvbHVtbiBmcm9tIGVhY2ggdGFibGUgcmVhZCB0aGUgaGVpZ2h0IG9mIHRoZSByb3dzIGFuZCBzZXRcbiAgICAgKiB0aGUgbWF4IGhlaWdodCB0byBib3RoIHJvd3MuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGFsaWduVGFibGVzSGVpZ2h0cyAoZnJvemVuVmlldzogYW55LCB1bkZyb3plblZpZXc6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGFzc2VydChpc1ByZXNlbnQoZnJvemVuVmlldykgJiYgaXNQcmVzZW50KGZyb3plblZpZXcpLFxuICAgICAgICAgICAgJ0NhbnQgYWxpZ24gdGFibGUgdmlld3MgYXMgb25lIG9mIHRoZSB2aWV3IGlzIHVuZGVmaW5lZCcpO1xuXG4gICAgICAgIGxldCBmcm96ZW5Sb3dzOiBhbnlbXSA9IGZyb3plblZpZXcucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdHInKTtcbiAgICAgICAgbGV0IHVuRnJvemVuUm93czogYW55W10gPSB1bkZyb3plblZpZXcucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdHInKTtcblxuICAgICAgICBhc3NlcnQoZnJvemVuUm93cy5sZW5ndGggPT09IHVuRnJvemVuUm93cy5sZW5ndGgsXG4gICAgICAgICAgICAnRnJvemVuIENvbHVtbjogVHdvIHRhYmxlcyBkb2VzIG5vdCBtdWNoIScpO1xuXG4gICAgICAgIEFycmF5LmZyb20oZnJvemVuUm93cykuZm9yRWFjaCgoZnJvemVuOiBhbnksIGluZGV4OiBudW1iZXIpID0+XG4gICAgICAgIHtcbiAgICAgICAgICAgIGxldCBoID0gTWF0aC5tYXgoZnJvemVuLm9mZnNldEhlaWdodCwgdW5Gcm96ZW5Sb3dzW2luZGV4XS5vZmZzZXRIZWlnaHQpO1xuICAgICAgICAgICAgZnJvemVuLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICAgICAgICAgICAgdW5Gcm96ZW5Sb3dzW2luZGV4XS5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0ICgpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmluaXRGdWxsU2NyZWVuKCk7XG4gICAgfVxuXG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmICh0aGlzLmR0Lmhhc0Zyb3plbkNvbHVtbnMoKSkge1xuICAgICAgICAgICAgbGV0IGZyb3plblZpZXcgPSB0aGlzLnRoaXNFbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmR0LWJvZHktZnJvemVuJyk7XG4gICAgICAgICAgICBsZXQgdW5Gcm96ZW5WaWV3ID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kdC1ib2R5LXVuZnJvemVuJyk7XG5cbiAgICAgICAgICAgIGxldCBmcm96ZW5XaWR0aCA9IHRoaXMuY2FsY3VsYXRlRnJvemVuV2lkdGgoKTtcbiAgICAgICAgICAgIGZyb3plblZpZXcuc3R5bGUud2lkdGggPSBmcm96ZW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KHVuRnJvemVuVmlldykpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIGJvcmRlciBhbmQgY3JlYXRlIGluZGVudCBlZmZlY3QgYnkgaGF2aW5nIDFweCB3aGl0ZSBzcGFjZVxuICAgICAgICAgICAgICAgIHVuRnJvemVuVmlldy5zdHlsZS5sZWZ0ID0gKGZyb3plbldpZHRoICsgMikgKyAncHgnO1xuICAgICAgICAgICAgICAgIHVuRnJvemVuVmlldy5zdHlsZS53aWR0aCA9IHVuRnJvemVuVmlldy5wYXJlbnRFbGVtZW50Lm9mZnNldFdpZHRoXG4gICAgICAgICAgICAgICAgICAgIC0gZnJvemVuVmlldy5vZmZzZXRXaWR0aCArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFsaWduVGFibGVzSGVpZ2h0cyhmcm96ZW5WaWV3LCB1bkZyb3plblZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3kgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLnF1ZXJ5U3Vic2NyaXB0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5xdWVyeVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmxvYWRpbmdTdWIpKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmdTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogRlVMTCBTQ1JFRU4gTU9ERSBtZXRob2RzXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gZnVsbHNjcmVlbiBmdW5jdGlvbmFsaXR5IGlzIGVuYWJsZWQgdGhpcyBtZXRob2Qgc3dpdGNoZXMgYmV0d2VlbiBub3JtbCBhbmQgZnVsbCBzY3JlZW5cbiAgICAgKiBtb2RlXG4gICAgICpcbiAgICAgKi9cbiAgICB0b2dnbGVGdWxsU2NyZWVuIChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsU2NyZWVuTW9kZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUZ1bGxTY3JlZW4oZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuRnVsbFNjcmVlbihldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUbyBwdXNoIHRoaXMgY29tcG9uZW50IHRvIGZ1bGwgc2NyZWVuIG1vZGUgb3IgbWF5YmUgZnVsbCBwYWdlIG1vZGUgd2UgbmVlZCBydW4gZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogIC0gRXhlY3V0ZSBleHBhbmQgdHJhbnNmb3JtYXRpb24sIHdoZXJlIHdlIGhhdmUgYWRkaXRpb25hbCBvdmVybGF5IGRpdiB0aGF0IHdlIHNsb3dseSBleHBhbmRcbiAgICAgKiAgYW5kIHRoaXMgY3JlYXRlcyBpbXByZXNzaW9uIHRoZSBEVCBpcyBleHBhbmRpbmdcbiAgICAgKlxuICAgICAqICAtIGFwcGx5IGZ1bGwtc2NyZWVuIGNsYXNzIG9uIHRvcCBob3N0IGVsZW1lbnQgIC0gaW4gdGhpcyBjYXNlIGl0cyBEYXRhVGFibGUgdG8gc3dpdGNoXG4gICAgICogIHRvIGFic29sdXRlIHBvc2l0aW9uaW5nXG4gICAgICpcbiAgICAgKiAgLSBtYWtlIHN1cmUgd2UgYXJlIHNjcm9sbGVkIGFsbCB0aGUgd2F5IHVwXG4gICAgICpcbiAgICAgKiAgLSBoaWRlIGFsbCB0aGUgZWxlbWVudHMgb24gdGhlIHBhZ2Ugc28gdGhlaXIgZGltZW5zaW9uIGRvbid0IGludGVyZmVyZSB3aXRoIHRoaXMgdGFibGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIG9wZW5GdWxsU2NyZWVuIChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pc0Z1bGxTY3JlZW5Nb2RlID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJ1bkV4cGFuZEVmZmVjdCgpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHdpbmRvdy5zY3JvbGwoMCwgMCk7XG4gICAgICAgIHRoaXMudG9nZ2xlRnVsbFNjcmVlbk9uRFQodHJ1ZSk7XG5cblxuICAgICAgICAvLyBtYXJrIG15IGVsZW1lbnQgaW4gdGhlIHBhdGggdGhhdCBuZWVkcyB0byBzdGF5XG4gICAgICAgIGxldCBwYXJlbnROb2RlID0gdGhpcy50aGlzRWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlIChpc1ByZXNlbnQocGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZS50YWdOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgIHBhcmVudE5vZGUuY2xhc3NMaXN0LmFkZCgndS1mdWxsLXNjcmVlbi1lbGVtZW50Jyk7XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlkZU5vbkZ1bGxTY3JlZW5FbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuXG4gICAgICAgIHRoaXMuZHQuc3RhdGUubGltaXQgPSBNYXRoLnJvdW5kKHRoaXMuY2FsY3VsYXRlTGltaXQoKSk7XG4gICAgICAgIHRoaXMuZHQuZGF0YVNvdXJjZS5mZXRjaCh0aGlzLmR0LnN0YXRlKTtcblxuICAgICAgICAvLyBvbmNlIGxvYWRlZCBzZXQgYmFjayBjb3JyZWN0IHBhZ2Ugc2l6ZSB3ZSB1c2Ugd2hlbiBsb2FkaW5nIGRhdGFcbiAgICAgICAgdGhpcy5kdC5zdGF0ZS5saW1pdCA9IHRoaXMuZHQucGFnZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGUgc2FtZSBsaWtlIGFib3ZlIG1ldGhvZCAob3BlbkZ1bGxTY3JlZW4pIGJ1dCBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAqXG4gICAgICovXG4gICAgY2xvc2VGdWxsU2NyZWVuIChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pc0Z1bGxTY3JlZW5Nb2RlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5zaG93Tm9uRnVsbFNjcmVlbkVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5ydW5Db2xsYXBzZUVmZmVjdCgpO1xuICAgICAgICB0aGlzLnRvZ2dsZUZ1bGxTY3JlZW5PbkRUKGZhbHNlKTtcblxuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUubGltaXQgPSB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUuZGlzcGxheUxpbWl0O1xuICAgICAgICB0aGlzLmR0LmRhdGFTb3VyY2Uuc3RhdGUub2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZldGNoKHRoaXMuZHQuZGF0YVNvdXJjZS5zdGF0ZSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIHRoaXMub3JpZ2luYWxTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgIH0sIDMwMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuaW1hdGlvbiBlZmZlY3QgdG8gbWFrZSBpdCBmZWVsIGxpa2UgdGhlIGVsZW1lbnQgKGluIHRoaXMgY2FzZSBEVCkgaXMgZXhwYW5kaW5nXG4gICAgICogZnJvbSB0aGUgbWlkZGxlIHRvIHRoZSBmdWxsIHBhZ2UgbW9kZS5cbiAgICAgKlxuICAgICAqIFdlIHRha2UgdGhlIGRpbWVuc2lvbiBvZiB0aGUgdGFibGUgdGhlbiBpdCBpcyBzY2FsZWQgc2xvd2x5IHRvIHRoZSBmdWxsIHBhZ2VcbiAgICAgKi9cbiAgICBwcml2YXRlIHJ1bkV4cGFuZEVmZmVjdCAoKVxuICAgIHtcbiAgICAgICAgdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5kdEZ1bGxTY3JlZW5PdmVybGF5Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5leHBhbmRDb2xvckZyb207XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3JtYXRpb24odHJ1ZSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmV4cGFuZENvbG9yVG87XG4gICAgICAgIH0sIDMwMCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSB0cmFuc2Zvcm1hdGlvbiBhbmQgc2NhbGUgdGhlIGhlbHBlciBkaXYgKG92ZXJsYXkpIGRvd24gdG8gbWFrZSBpdCBsb29rIGxpa2VcbiAgICAgKiBpdCBjb2xsYXBzZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIHJ1bkNvbGxhcHNlRWZmZWN0ICgpXG4gICAge1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKGZhbHNlKTtcblxuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT5cbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdCwgdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3AsIDAsXG4gICAgICAgICAgICAgICAgMCk7XG4gICAgICAgIH0sIDQwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogREZTICAtIHRvIGdvIHRocnUgYWxsIHRoZSBlbGVtZW50IHVuZGVyIEJPRFkgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIHBhZ2UuXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGhpZGVOb25GdWxsU2NyZWVuRWxlbWVudCAocGFyZW50RWxlbWVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMudGhpc0VsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlID09PSBwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBlbGVtZW50ID0gcGFyZW50RWxlbWVudC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRUcmF2ZXJzZURvd24oZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVOb25GdWxsU2NyZWVuRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2R0LWZ1bGwtc2NyZWVuJykpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3UtZnMtZWxlbWVudC1vdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1dCBhbGwgdGhlIGVsZW1lbnQgdGhhdCB3ZXJlIHByZXZpb3VzbHkgcmVtb3ZlZCBieSBoaWRlTm9uRnVsbFNjcmVlbkVsZW1lbnQoKSBiYWNrXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaG93Tm9uRnVsbFNjcmVlbkVsZW1lbnQgKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnUtZnMtZWxlbWVudC1vdXQnKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChlbGVtOiBhbnkpID0+IGVsZW0uY2xhc3NMaXN0LnJlbW92ZSgndS1mcy1lbGVtZW50LW91dCcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBASW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgbmVlZFRyYXZlcnNlRG93biAoZWxlbWVudDogYW55KTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudChlbGVtZW50KSAmJiBlbGVtZW50LnRhZ05hbWUgIT09ICdTQ1JJUFQnICYmXG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygndS1mdWxsLXNjcmVlbi1lbGVtZW50JykgJiZcbiAgICAgICAgICAgICFlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZHQtZnVsbC1zY3JlZW4nKTtcblxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSBlbnRlciBmdWxsIHNjcmVlbiAvcGFnZSBtb2RlIHdoZW4gbmVlZCB0byBjYWxjdWxhdGUgaG93IG1hbnkgcm93cyB0byBsb2FkIGluaXRpYWxseVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVMaW1pdCAoKTogbnVtYmVyXG4gICAge1xuICAgICAgICBsZXQgYnJvd3NlckggPSB0aGlzLmRvbVV0aWxzLmJyb3dzZXJEaW1lbnRpb25zKCkuaGVpZ2h0O1xuICAgICAgICBsZXQgcm93SCA9IHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keSB0cjpmaXJzdC1jaGlsZCcpLm9mZnNldEhlaWdodDtcblxuICAgICAgICByZXR1cm4gKGlzUHJlc2VudChyb3dIKSAmJiByb3dIID4gMCkgPyAoYnJvd3NlckggLyByb3dIKSArIDIwIDogNTA7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBASW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlRWxlbWVudCAobDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBudW1iZXIgPSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogbnVtYmVyID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gbCArICdweCc7XG4gICAgICAgIHRoaXMuZHRGdWxsU2NyZWVuT3ZlcmxheS5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IHQgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IHcgKyAncHgnO1xuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBoICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBASW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgYXBwbHlUcmFuc2Zvcm1hdGlvbiAoZXhwYW5kOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgbGV0IHgsIHksIHR4LCB0eTtcbiAgICAgICAgaWYgKGV4cGFuZCkge1xuICAgICAgICAgICAgeCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aDtcbiAgICAgICAgICAgIHkgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLyB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIHR4ID0gKHdpbmRvdy5pbm5lcldpZHRoIC8gMiAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3Qud2lkdGggLyAyXG4gICAgICAgICAgICAgICAgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmxlZnQpIC8geDtcbiAgICAgICAgICAgIHR5ID0gKHdpbmRvdy5pbm5lckhlaWdodCAvIDIgLSB0aGlzLmR0Qm91bmRpbmdDbGllbnRSZWN0LmhlaWdodCAvIDJcbiAgICAgICAgICAgICAgICAtIHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QudG9wKSAvIHk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSAxO1xuICAgICAgICAgICAgeSA9IDE7XG4gICAgICAgICAgICB0eCA9IHRoaXMuZHRCb3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIHR5ID0gdGhpcy5kdEJvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPVxuICAgICAgICAgICAgJ3NjYWxlWCgnICsgeCArICcpIHNjYWxlWSgnICsgeSArICcpIHRyYW5zbGF0ZTNkKCcgKyAodHgpICsgJ3B4LCAnICsgKHR5KSArICdweCwgMHB4KSc7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbml0RnVsbFNjcmVlbiAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKCFpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRGdWxsU2NyZWVuID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlbmRlci5hcHBlbmRDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLmR0RnVsbFNjcmVlbk92ZXJsYXkubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBzZXQgb2Ygc2V0IG9mIGNzcyBwcm9wZXJ0aWVzIHRvIG1ha2UgdGhlIERUIG1haW4gY29tcG9uZW50IG9uIHRoZSBwYWdlIGV4cGFuZCB0b1xuICAgICAqIGZ1bGwgcGFnZSBtb2RlIGFuZCBiYWNrXG4gICAgICpcbiAgICAgKiBXZSB3YW50IHRvIG1ha2UgaXQgd2l0aCBsaXR0bGUgZGVsYXkgdG8gbGV0IG90aGVyIGFuaW1hdGlvbiBmaW5pc2hcbiAgICAgKi9cbiAgICB0b2dnbGVGdWxsU2NyZWVuT25EVCAoZnVsbFNjcmVlbjogYm9vbGVhbik6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuZHQuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PlxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZnVsbFNjcmVlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuY2xhc3NMaXN0ICs9ICdkdC1mdWxsLXNjcmVlbic7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZHQuY2xhc3NMaXN0ID0gdGhpcy5kdC5jbGFzc0xpc3QucmVwbGFjZSgnZHQtZnVsbC1zY3JlZW4nLFxuICAgICAgICAgICAgICAgICAgICAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kdC5lbC5uYXRpdmVFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuXG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJTkZJTklURSBTQ1JPTExJTkcgTUVUSE9EU1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTGlzdGVuIGZvciBpbmZpbml0ZSBzY3JvbGwgZXZlbnQgYW5kIHJlcXVlc3QgbmV3IGRhdGEgZnJvbSBkYXRhIHNvdXJjZVxuICAgICAqXG4gICAgICovXG4gICAgb25MYXp5TG9hZCAoZXZlbnQ6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIGlmIChldmVudC5pc0xvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHQuc3RhdGUub2Zmc2V0ID0gZXZlbnQub2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5kdC5kYXRhU291cmNlLmZldGNoKHRoaXMuZHQuc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRhdGFQcm92aWRlciA9IHRoaXMuZHQuZGF0YVNvdXJjZS5kYXRhUHJvdmlkZXI7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGRhdGFQcm92aWRlci5kYXRhQ2hhbmdlcy5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgZGF0YVByb3ZpZGVyLmRhdGFDaGFuZ2VzLm5leHQoZGF0YS5zbGljZSgwLCBldmVudC5vZmZzZXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV2hlbiBsb2FkaW5nIGlzIGZpbmlzaGVkIG1hcmsgbG9hZGluZyBpY29uIGlzIGRvbmUgc28gd2UgY2FuIGhpZGUgaXQuIEkgYW0gdXNpbmcgbGl0dGxlXG4gICAgICogZGVsYXkgdG8gbWFrZSB0aGUgYW5pbWF0aW9uIHZpc2libGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGxvYWRpbmdGaW5pc2hlZCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmluZmluaXRlU2Nyb2xsKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmluZmluaXRlU2Nyb2xsLmNvbXBsZXRlKCksIDIwMCk7XG5cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7QWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25Jbml0LCBSZW5kZXJlcjJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtEVENvbHVtbjJDb21wb25lbnR9IGZyb20gJy4uL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgaXMgcmVzcG9uc2libGUgZm9yIGNoZWNraW5nIGFuZCBzZXR0aW5nIHRoZSB3aWRlc3QgY29udGVudCB3aWR0aCBvbnRvXG4gKiBDb2x1bW4gY29tcG9uZW50IGFzIHRoZSB3aWRlc3RDZWxsIHByb3BlcnR5LlxuICpcbiAqXG4gKlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbWF4V2lkdGhdJ1xufSlcbmV4cG9ydCBjbGFzcyBTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXRcbntcblxuICAgIEBJbnB1dCgpXG4gICAgbWF4V2lkdGg6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yIChwcml2YXRlIGVsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgcmVuZGVyOiBSZW5kZXJlcjIsXG4gICAgICAgICAgICAgICAgIHByaXZhdGUgdGQ6IERUQ29sdW1uMkNvbXBvbmVudClcbiAgICB7XG4gICAgfVxuXG5cbiAgICBuZ09uSW5pdCAoKTogdm9pZFxuICAgIHtcblxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCAoKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLm1heFdpZHRoKSAmJiB0aGlzLm1heFdpZHRoID4gMCkge1xuICAgICAgICAgICAgbGV0IGlubGluZURhdGEgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuZHQtY29sLWNlbGwtZGF0YScpO1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudChpbmxpbmVEYXRhKSkge1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUud2hpdGVTcGFjZSA9ICdub3dyYXAnO1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBpbmxpbmVEYXRhLm9mZnNldFdpZHRoOyAvLyB0ZFxuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuICAgICAgICAgICAgICAgIGlubGluZURhdGEuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUnO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzSW5UaHJlc0hvbGQoY2VsbFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2VsbFdpZHRoICs9IHRoaXMudGRQYWRkaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxXaWR0aCA+IHRoaXMudGQud2lkdGhQeCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbFdpZHRoIDwgdGhpcy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsID0gY2VsbFdpZHRoID4gdGhpcy50ZC53aWRlc3RDZWxsID8gY2VsbFdpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRkLndpZGVzdENlbGw7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjZWxsV2lkdGggPj0gdGhpcy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50ZC53aWRlc3RDZWxsID0gdGhpcy5tYXhXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbCA/IHRoaXMubWF4V2lkdGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGQud2lkZXN0Q2VsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSXMgdGhlIG5ldyB3aWR0aCB0aGUgc2FtZSBhcyB0aGUgb25lIGFscmVhZHkgc2V0IG9uIHRoZSBjb2x1bW4/IElmIHllcyB0aGVuIHByb2JhYmx5XG4gICAgICogbmV3IGNvbnRlbnQgZG9lcyBub3QgZGlmZmVyIHRoYXQgbXVjaC4gV2Ugc3RpbGwga2VlcCBjZXJ0YWluIHRocmVzaG9sZCBhcyB0aGUgbmV3IGNvbnRlbnRcbiAgICAgKiB3aWR0aCBtaWdodCBkaWZmZXIgMSBvciAyIHBpeGVzIGRlcGVuZGluZyBob3cgc2V0IHRoZSBjc3MuXG4gICAgICpcbiAgICAgKiBUbyBtYWtlIHN1cmUgd2UgcmVzaXplIGNvbHVtbiBvbmx5IGlmIG5lY2Vzc2FyeSBiZWNhdXNlIGl0IGNvdWxkIGJlIG9yaWdpbmFsIHNpemVcbiAgICAgKiBpcyA0MDBweCBidXQgdGhlIG5ldyBvbmUgaXMgNDAxcHggc2luY2Ugc29tZXdoZXJlIGFkZCBzb21lIGV4dHJhIGJvcmRlciB3ZSBoYXZlIHRoaXNcbiAgICAgKiBzYWZlIHRocmVzaG9sZFxuICAgICAqXG4gICAgICovXG4gICAgaXNJblRocmVzSG9sZCAobmV3V2lkdGg6IG51bWJlcik6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIGlmICh0aGlzLnRkLndpZGVzdENlbGwgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy50ZC53aWRlc3RDZWxsIC0gbmV3V2lkdGgpID4gMyAmJiBuZXdXaWR0aCA+IHRoaXMudGQud2lkZXN0Q2VsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIHByaXZhdGUgdGRQYWRkaW5nICgpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIGxldCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIGxldCBjZWxsID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5wYWRkaW5nTGVmdCkgfHwgMDtcbiAgICAgICAgY2VsbCArPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCkgfHwgMDtcbiAgICAgICAgY2VsbCArPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlclJpZ2h0V2lkdGgpIHx8IDA7XG4gICAgICAgIGNlbGwgKz0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgpIHx8IDA7XG5cbiAgICAgICAgLy8gcGx1cyBnaXZlIGl0IHNvbWUgbGl0dGxlIHNwYWNlIGFyb3VuZCB0aGUgdGV4dCBzbyBpdCBub3RzIHB4IHRvIHB4IGlubmVyIHdpZHRoIG9mIHRoZSB0ZFxuICAgICAgICAvLyBjdXogaXQgY291bGQgd3JhcFxuICAgICAgICBjZWxsICs9IDU7XG5cbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5cbmltcG9ydCB7XG4gICAgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBJbmplY3QsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSxcbiAgICBPbkluaXRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0RhdGF0YWJsZTJDb21wb25lbnR9IGZyb20gJy4uL2RhdGF0YWJsZTIuY29tcG9uZW50JztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuLi8uLi8uLi9jb3JlL2RvbS11dGlscy5zZXJ2aWNlJztcbmltcG9ydCB7aXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7RHJhZ0RpcmVjdGlvbiwgRHJhZ0V2ZW50cywgRHJvcFBvc2l0aW9ufSBmcm9tICcuLi9hdy1kYXRhdGFibGUnO1xuXG5cbi8qKlxuICogRGlyZWN0aXZlIHVzZWQgaW5zaWRlIERUIGluIG9yZGVyIHRvIHN1cHBvcnQgdGFibGUgcm93cyByZS1vcmRlcmluZy4gVGhpcyBtYW5hZ2VzIGFsbCB0aGVcbiAqIEQmRCBuZWNlc3NhcnkgbG9naWMgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBbZHREcmFnZ2FibGVSb3ddIGlzIHVzZWQgaW5zaWRlIHRoZSBgcm93VGVtcGxhdGVgIGxpa2UgdGhpczpcbiAqXG4gKlxuICogYGBgaHRtbFxuICpcbiAqIDxuZy10ZW1wbGF0ZSAjcm93VGVtcGxhdGUgbGV0LXJvd0RhdGEgbGV0LWV2ZW49J2V2ZW50XCIgbGV0LW9kZD1cIm9kZFwiIGxldC1yb3dJbmRleD1cInJvd0luZGV4XCJcbiAqICAgICAgICAgICAgICBsZXQtbmVzdGluZ0xldmVsPVwibmVzdGluZ0xldmVsXCIgbGV0LWNvbHNUb1JlbmRlcj1cImNvbHNUb1JlbmRlclwiPlxuICpcbiAqICAgICA8dHIgI3Jvd0VsZW1lbnQgZHREcmFnZ2FibGVSb3cgW2RuZFJvd0luZGV4XT1cInJvd0luZGV4XCJcbiAqICAgICAgICAgIGNsYXNzPVwiZHQtYm9keS1yb3dcIlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogd2hpY2ggZW5hYmxlZCBvciBkaXNhYmxlcyBiYXNlZCBvbiB0aGUgdXNlZCBEVCBiaW5kaW5nIFtkbmRSb3dFbmFibGVkXS4gQnkgZGVmYXVsdCBpdHMgZGlzYWJsZWQuXG4gKlxuICpcbiAqXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2R0RHJhZ2dhYmxlUm93XSdcbn0pXG5leHBvcnQgY2xhc3MgRFREcmFnZ2FibGVSb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFRlbGxzIHRoZSBkaXJlY3RpdmUgaWYgd2UgZW5hYmxlIG1pZGRsZSByb3cgem9uZSB0byBjcmVhdGUgYW4gZWZmZWN0IHRoYXQgd2UgYXJlIGRyb3BwaW5nXG4gICAgICogaW50byB0aGUgcm93LiBVc2VkIGZvciBvdXRsaW5lIERUIG1haW5seS5cbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZHJvcEludG9FbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IFRSIGluZGV4IG51bWJlclxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkbmRSb3dJbmRleDogbnVtYmVyID0gMDtcblxuICAgIC8qKlxuICAgICAqIEhvbGRzIGluZm9ybWF0aW9uIGFib3V0IG91ciBkcmFnZ2luZyBkaXJlY3Rpb24gVVAgYW5kIERPV04gaW4gb3JkZXIgdG8gYXNzaWduIGNvcnJlY3Qgc3R5bGVcbiAgICAgKiB0aGF0IGhpZ2hsaWdodHMgdGhlIHJvdyBhdCB0aGUgdG9wIG9yIGJvdHRvbVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnRGlyOiBEcmFnRGlyZWN0aW9uID0gRHJhZ0RpcmVjdGlvbi5Ob25lO1xuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgd2UgZHJhZ2dlZCBvdXIgcm93IGFuZCBzdG9wcGVkIGluIHRoZSBtaWRkbGUgb2YgdGhlIG90aGVyIHJvd1xuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBpbk1pZGRsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBDdXJyZW50IGRyYWcgWSBjb29yZGluYXRlcyB3aGljaCBpcyB1c2VkIHRvZ2V0aGVyIHdpdGggdGhlIGRyYWdEaXIgd2hlbiBhc3NpbmdpbmcgZHJhZ2dpbmdcbiAgICAgKiBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRyYWdZOiBudW1iZXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogbGlzdGVuZXJzIGhhbmRsZXJzIGhlcmUgLSB0aGUgcmV0dXJuIGZyb20gLmJpbmQodGhpcykuXG4gICAgICovXG4gICAgcHJpdmF0ZSBldmVudEhhbmRsZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gRGF0YXRhYmxlMkNvbXBvbmVudCkpXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBkdDogRGF0YXRhYmxlMkNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGRvbVV0aWxzOiBEb21VdGlsc1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSkge1xuICAgIH1cblxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmR0LmRuZFJvd0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZHQuZG5kUm93RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZWxlYXNlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwcyBsaXN0ZW5lcnMgYW5kIHJldHVybnMgaGFuZGxlIHRvIHRoZW0gc28gd2UgY2FuIGxhdGVyIG9uIHVuc3Vic2NyaWJlLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0dXBFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ21vdXNlZG93biddID0gdGhpcy5vbk1vdXNlRG93bkV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snbW91c2Vkb3duJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdzdGFydCddID0gdGhpcy5vbkRyYWdTdGFydEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ3N0YXJ0J10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdvdmVyJ10gPSB0aGlzLm9uRHJhZ092ZXJFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ292ZXInXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2xlYXZlJ10gPSB0aGlzLm9uRHJhZ0xlYXZlRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcmFnbGVhdmUnXSk7XG5cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJvcCddID0gdGhpcy5vbkRyb3BFdmVudC5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzWydkcm9wJ10pO1xuXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnNbJ2RyYWdlbmQnXSA9IHRoaXMub25EcmFnRW5kRXZlbnQuYmluZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVyc1snZHJhZ2VuZCddKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIGNyZWF0ZWQgbGlzdGVuZXJzIGluc2lkZSBkZXN0cm95KCkgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlbGVhc2VFdmVudExpc3RlbmVycygpOiB2b2lkIHtcbiAgICAgICAgRHJhZ0V2ZW50cy5mb3JFYWNoKChuYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ25hbWUnLCB0aGlzLmV2ZW50SGFuZGxlcnNbbmFtZV0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBpcyBmaXJzdCBldmVudCB3aGVyZSB3ZTpcbiAgICAgKlxuICAgICAqICAtIE1hcmsgZWxlbWVudCBkcmFnZ2FibGUgdG8gZW5hYmxlIEQmRFxuICAgICAqICAtIFNldCBjbGljayBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgbWlkZGxlIG9mIHRoZSBjdXJyZW50IHJvd1xuICAgICAqICAgICAgVGhpcyBpcyBtYWlubHkgbmVlZGVkIHdoZW4gd2UgYXJlIHRyeWluZyB0byBjYWxjdWxhdGUgc29tZXRoaW5nIGZvclxuICAgICAqICAgICAgZHJvcEludG8gcm93IChvdXRsaW5lKVxuICAgICAqXG4gICAgICogZXZlbnQudGFyZ2V0IHVzdWFsbHkgY29udGFpbnMgcmVmZXJlbmNlIHRvIFREIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uTW91c2VEb3duRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoZXZlbnQuYWx0S2V5ICYmIHRoaXMuZG9tVXRpbHMuaGFzUGFyZW50KGV2ZW50LnRhcmdldCwgJy5kdC1yb3ctZHJhZ2dhYmxlJykpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgZWxUb0JlRHJhZ2dlZCA9IHRoaXMuZG9tVXRpbHMuZWxlbWVudERpbWVuc2lvbnMoZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHRoaXMuZHQuZW52LnNldFZhbHVlKCdkZENsaWNrRGV2aWFuY2UnLCAoZWxUb0JlRHJhZ2dlZC5oZWlnaHQgLyAyKSAtIGV2ZW50Lm9mZnNldFkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5kcmFnZ2FibGUgPSBmYWxzZTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZWNvbmQgdHJpZ2dlcmVkIGV2ZW50IHdoZW4gdGhlIGFjdHVhbCBkcmFnZ2luZyBzdGFydHMuIEhlcmUgd2UgbmVlZCB0byBkaXNhYmxlXG4gICAgICogZHJhZ2dlZCByb3cgYW5kIHNhdmUgaW5mb3JtYXRpb24gdGhhdCBhcmUgY29tbW9uIHRvIGEgdGFibGUuXG4gICAgICpcbiAgICAgKiBNYXJraW5nIHJvdyBkaXNhYmxlZCB3aXRoIHRoZSBzdHlsZSAuZHQtcm93LWRyYWdnaW5nIHVzaW5nIHNldFRpbWVvdXQgaXMgbmVlZGVkIGFzXG4gICAgICogaWYgd2Ugd291bGQgZ28gd2l0aG91dCBpdCB0aGVuIEQmRCBmcmFtZXdvcmsgd291bGQgY3JlYXRlIGEgY29weSBvZiByb3cgaW4gZGlzYWJsZWQgc3RhdGUuXG4gICAgICogTm93IHdlIGdyYWIgYSByb3cgd2l0aCBhY3RpdmUgc3RhdGUgYW5kIGFmdGVyIGEgMjAwbXMgZGVsYXkgd2UgZGlzYWJsZSB0aGUgb3JpZ2luYWwgcm93LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdTdGFydEV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KGV2ZW50LnRhcmdldC5jbGFzc0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2R0LXJvdy1kcmFnZ2luZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuXG4gICAgICAgIHRoaXMuZHQuZW52LnNldFZhbHVlKCdpc0RyYWdnaW5nJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZHQuZW52LnNldFZhbHVlKCdkbmRJZCcsIHRoaXMuZG5kUm93SW5kZXgpO1xuICAgICAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YSgndGV4dCcsIHRoaXMuZG5kUm93SW5kZXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBldmVudHMgaGFwcGVucyBhbnl0aW1lIGFzIHdlIGRyYWcgb3ZlciByb3dzLiBUaGlzIGV2ZW50IHRyaWdnZXJlZCBhZnRlciBjZXJ0YWluXG4gICAgICogZGVsYXkuIEluIGhlcmUgd2UgY2FsY3VsYXRlIHRoZSBtb3VzZSBtb3ZlbWVudCB0byBpZGVudGlmeSBpZiB3ZSBhcmUgZ29pbmcgVVAgb3IgRE9XTi5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgbWFpbmx5IG5lZWRlZCB0byBtYXJrIGEgcm93IHdpdGggdGhlIGNvcnJlY3QgbGluZSBvbiBUT1Agb3IgQk9UVE9NIHRvIHZpc3VhbGx5XG4gICAgICogc2hvdyBhIHVzZXIgd2hlcmUgd2UgYXJlLlxuICAgICAqXG4gICAgICogT25jZSB3ZSBrbm93IHRoZSBkaXJlY3Rpb24gYW5kIHRoZSBkcm9wIHRhcmdldCBpcyB2YWxpZCB3ZSBtYXJrIHRoZSByb3cgd2l0aCBjb3JyZWN0IGNsYXNzXG4gICAgICogdGhhdCBkb2VzIHRoZSB0cmlja1xuICAgICAqL1xuICAgIHByaXZhdGUgb25EcmFnT3ZlckV2ZW50KGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAnbW92ZSc7XG4gICAgICAgIGlmICh0aGlzLmRyYWdZIDwgZXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uRG93bjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdZID4gZXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9IERyYWdEaXJlY3Rpb24uVXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9udCBzZXQgYWdhaW4gdW5sZXNzIGl0cyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKHRoaXMuZHJhZ1kgIT09IGV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdZID0gZXZlbnQucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkRHJvcFRhcmdldChldmVudCkpIHtcbiAgICAgICAgICAgIC8vIHRvZG8gdGVzdCB0aGlzIHByZXZlbnREZWZhdWx0KCkgc28gaXQgZG9lcyBub3QgY3JlYXRlIHNvbWUgc2lkZWVmZmVjdFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMubWFya1Jvd1dpdGhDbGFzcyhldmVudCwgdGhpcy5kb21VdGlscy5jbG9zZXN0KGV2ZW50LnRhcmdldCwgJ3RyJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBmaW5pc2hpbmcgZXZlbnQganVzdCBiZWZvcmUgRCZEIGlzIGRvbmUuIEl0IHRha2VzIGN1cnJlbnQgaW5mb3JtYXRpb24gYW5kXG4gICAgICogYnJvYWRjYXN0IHRoZW0gdG8gdGhlIERUIHNvIERUIGNhbiBkbyBuZWNlc3Nhcnkgcm93IHJlb3JkZXJpbmdcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyb3BFdmVudChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGV2ZW50LnRhcmdldC5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBsZXQgb3JpZ0luZHggPSB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgbGV0IGRyb3BQb3M6IERyb3BQb3NpdGlvbiA9IHRoaXMuaW5NaWRkbGUgPyBEcm9wUG9zaXRpb24uSW50byA6IChcbiAgICAgICAgICAgIHRoaXMuZHJhZ0RpciA9PT0gRHJhZ0RpcmVjdGlvbi5VcCA/IERyb3BQb3NpdGlvbi5CZWZvcmUgOiBEcm9wUG9zaXRpb24uQWZ0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5kdC5vbkRuRFJvd0Ryb3Aob3JpZ0luZHgsIHRoaXMuZG5kUm93SW5kZXgsIGRyb3BQb3MpO1xuXG4gICAgICAgIHRoaXMuaW5NaWRkbGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kcmFnWSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlcnkgdGltZSB3ZSBkcmFnIG92ZXIgdGhlIGVsZW1lbnQgd2UgYXBwbHkgc29tZSBjbGFzc2VzIHRvIHRoZSBpdC4gdGhpcyBtZXRob2QgZG9lcyB0aGVcbiAgICAgKiBvcHBvc2l0ZSB3aGljaCBpcyB0byByZW1vdmUgZXZlcnl0aGluZyBzbyB3ZSBhcmUgcmVhZHkgZm9yIHRoZSBuZXh0IHJvd1xuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIG9uRHJhZ0xlYXZlRXZlbnQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgdHIgPSB0aGlzLmRvbVV0aWxzLmNsb3Nlc3QoZXZlbnQudGFyZ2V0LCAndHInKTtcbiAgICAgICAgdGhpcy5jbGVhckNsYXNzZXModHIpO1xuXG4gICAgICAgIHRoaXMuZHQuZW52LmRlbGV0ZVZhbHVlKCdkbmRPbkhvbGRJbmRleCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVGhpcyBpcyBsYXN0IGV2ZW50IHdpdGhpbiBEJkQgZmxvdy4gTWFpbmx5IHVzZWQgdG8gY2xlYW4gdXAgYWxsIHRoZSByZXNvdXJjZSB0aGF0IGhhcyBub3RcbiAgICAgKiBiZWVuIGNsZWFuIHVwIGFscmVhZHkgaW5zaWRlIG9uRHJvcEV2ZW50LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBvbkRyYWdFbmRFdmVudChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQoZXZlbnQudGFyZ2V0LmNsYXNzTGlzdCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdkdC1yb3ctZHJhZ2dpbmcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnaXNEcmFnZ2luZycpO1xuICAgICAgICB0aGlzLmR0LmVudi5kZWxldGVWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgdGhpcy5kdC5lbnYuZGVsZXRlVmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXNzaWduIENTUyBjbGFzc2VzIHRvIHRoZSByb3cgdG8gY3JlYXRlIGFuIGhpZ2hsaWdodGluZyBlZmZlY3QgdG8gY2FwdHVyZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICogZm9yIHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogQmFzZWQgb24gdGhlIERyYWcgZGlyZWN0aW9uIHdlIGVpdGhlciBhcHBseVxuICAgICAqIGNzcyBjbGFzcyB0aGF0IGNyZWF0ZXMgYSBsaW5lIG9uIHRvcCBvciBib3R0b20uICBPbmx5IGZvciB0aGUgZHJvcEludG8gZnVuY3Rpb25hbGl0eSB3ZVxuICAgICAqIG5lZWQgdG8gY2FsY3VsYXRlIHNvbWUgbW9yZSB0byBpZGVudGlmeSBpZiB3ZSBhcmUgcmVhbGx5IGluIHRoZSBtaWRkbGUgb2YgdGhlIHJvdy5cbiAgICAgKlxuICAgICAqIERyb3BJbnRvOlxuICAgICAqIC0tLS0tLS0tLVxuICAgICAqXG4gICAgICogSW5pdGlhbGx5IHdlIGNhcHR1cmVkIGEgcG9zaXRpb24gKGluIG1vdXNlZG93bikgdGhlIGRpc3RhbmNlIHRvIHRoZSBtaWRkbGUgb2YgdGhlIHJvdyBhbmRcbiAgICAgKiB0aGlzIHdlIGFyZSB1c2luZyBoZXJlIHdpdGggc29tZSB0aHJlc2hvbGQgb2YgMiBwaXhlcyBzbyB3ZSBkb250IGhhdmUgdG8gYmUgZXhhY3RseSBvbiBwaXhlbFxuICAgICAqIHBlcmZlY3QuXG4gICAgICpcbiAgICAgKiAtIGxldCBjdXJyZW50VHJDZW50ZXIgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGFjdGl2ZVJvdykuaGVpZ2h0IC8gMjtcbiAgICAgKiAgICAgIFJlYWQgY2VudGVyIG9mIGN1cnJlbnQgcm93XG4gICAgICpcbiAgICAgKiAtIGxldCBkcmFnZ2VkVHJDZW50ZXIgPSBldmVudC5vZmZzZXRZICsgdGhpcy5kdC5lbnYuZ2V0VmFsdWUoJ2RkQ2xpY2tEZXZpYW5jZScpO1xuICAgICAqICAgICAgUmVhZCBtb3VzZSBjb29yZGluYXRlcyByZWxhdGl2ZSB0byBjdXJyZW50IHJvdy90ZCBhbmQgYWRkIHRvIGl0IG91ciBkZXZpYXRpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIHByaXZhdGUgbWFya1Jvd1dpdGhDbGFzcyhldmVudDogYW55LCBhY3RpdmVSb3c6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuY2xlYXJDbGFzc2VzKGFjdGl2ZVJvdyk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgZHJhZyBpdGVtIGlzIGluIHRoZSBtaWRkbGUgb2Ygb3RoZXIgcm93XG4gICAgICAgIGxldCBjdXJyZW50VHJDZW50ZXIgPSB0aGlzLmRvbVV0aWxzLmVsZW1lbnREaW1lbnNpb25zKGFjdGl2ZVJvdykuaGVpZ2h0IC8gMjtcbiAgICAgICAgbGV0IGRyYWdnZWRUckNlbnRlciA9IGV2ZW50Lm9mZnNldFkgKyB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZGRDbGlja0RldmlhbmNlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMuZHJvcEludG9FbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmluTWlkZGxlID0gTWF0aC5hYnMoY3VycmVudFRyQ2VudGVyIC0gZHJhZ2dlZFRyQ2VudGVyKSA8IDI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pbk1pZGRsZSkge1xuICAgICAgICAgICAgYWN0aXZlUm93LmNsYXNzTGlzdC5hZGQoRHJhZ0RpcmVjdGlvbi5NaWRkbGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVSb3cuY2xhc3NMaXN0LmFkZCh0aGlzLmRyYWdEaXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEcm9wIHRhcmdldCBtdXN0IGJlIG9ubHkgYW5vdGhlciBUUiBhbmQgaXQgY2Fubm90IGJlIHRoZSBlbGVtZW50IGl0c2VsZiB0aGUgb25lIHdlIGFyZVxuICAgICAqIGRyYWdnaW5nIGFuZCBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIGFsbG93IHRvIGRyb3AgdG8gdGhlIHNhbWUgcG9zaXRpb24gd2Ugc3RhcnRlZCBmcm9tXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzVmFsaWREcm9wVGFyZ2V0KGV2ZW50OiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IG9yaWdJbnggPSB0aGlzLmR0LmVudi5nZXRWYWx1ZSgnZG5kSWQnKTtcbiAgICAgICAgbGV0IHNpYmxpbmdSb3cgPSB0aGlzLmRuZFJvd0luZGV4IC0gb3JpZ0lueDtcblxuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0LnBhcmVudEVsZW1lbnQudGFnTmFtZSA9PT0gJ1RSJyAmJiB0aGlzLmRuZFJvd0luZGV4ICE9PSBvcmlnSW54ICYmXG4gICAgICAgICAgICAhKHNpYmxpbmdSb3cgPT09IDEgJiYgdGhpcy5kcmFnRGlyID09PSBEcmFnRGlyZWN0aW9uLlVwKSAmJlxuICAgICAgICAgICAgIShzaWJsaW5nUm93ID09PSAtMSAmJiB0aGlzLmRyYWdEaXIgPT09IERyYWdEaXJlY3Rpb24uRG93bik7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgcHJpdmF0ZVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBjbGVhckNsYXNzZXModHI6IGFueSk6IHZvaWQge1xuICAgICAgICB0ci5jbGFzc0xpc3QucmVtb3ZlKCdkdC1kcmFnLXJvdy10b3AnKTtcbiAgICAgICAgdHIuY2xhc3NMaXN0LnJlbW92ZSgnZHQtZHJhZy1yb3ctYm90dG9tJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5yZW1vdmUoJ2R0LWRyYWctcm93LWJvdGgnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgcHJpdmF0ZVxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBkcmFnRGlyVG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmRyYWdEaXIpIHtcbiAgICAgICAgICAgIGNhc2UgRHJhZ0RpcmVjdGlvbi5VcDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VwJztcbiAgICAgICAgICAgIGNhc2UgRHJhZ0RpcmVjdGlvbi5Eb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiAnRG93bic7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnTm90IFN1cmUnO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtBV0NvcmVDb21wb25lbnRNb2R1bGV9IGZyb20gJy4uLy4uL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV091dGxpbmVGb3JNb2R1bGV9IGZyb20gJy4uL291dGxpbmUvb3V0bGluZS1mb3IubW9kdWxlJztcbmltcG9ydCB7RGF0YXRhYmxlMkNvbXBvbmVudH0gZnJvbSAnLi9kYXRhdGFibGUyLmNvbXBvbmVudCc7XG5pbXBvcnQge0RUV3JhcHBlcn0gZnJvbSAnLi90YWJsZS13cmFwcGVyL3RhYmxlLXdyYXBwZXIuY29tcG9uZW50JztcbmltcG9ydCB7RFRDb2x1bW4yQ29tcG9uZW50fSBmcm9tICcuL2NvbHVtbi9kdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdJbnB1dEZpZWxkTW9kdWxlfSBmcm9tICcuLi9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUnO1xuaW1wb3J0IHtEVEhlYWRlckNvbXBvbmVudDJ9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHtEVERldGFpbFJvd0NvbXBvbmVudH0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy9kdC1kZXRhaWwtcm93LmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vZGV0YWlsLXJvdy1leHBhbmRlci9kdC1kZXRhaWwtcm93LWV4cGFuZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQge1xuICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnRcbn0gZnJvbSAnLi9jb2x1bW4vbXVsdGktc2VsZWN0L2R0LW11bHRpLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdDaGVja0JveE1vZHVsZX0gZnJvbSAnLi4vY2hlY2tib3gvY2hlY2stYm94Lm1vZHVsZSc7XG5pbXBvcnQge1xuICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG59IGZyb20gJy4vY29sdW1uL3NpbmdsZS1zZWxlY3QvZHQtc2luZ2xlLXNlbGVjdC1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7QVdSYWRpb0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtTZXRDZWxsTWF4V2lkdGhEaXJlY3RpdmV9IGZyb20gJy4vZGlyZWN0aXZlcy9kdC1jZWxsLWRpcmVjdGl2ZXMnO1xuaW1wb3J0IHtEVERyYWdnYWJsZVJvd0RpcmVjdGl2ZX0gZnJvbSAnLi9kaXJlY3RpdmVzL2R0LWRyYWdnYWJsZS1yb3cuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBEYXRhdGFibGUyQ29tcG9uZW50LFxuICAgICAgICBEVFdyYXBwZXIsXG4gICAgICAgIERUQ29sdW1uMkNvbXBvbmVudCxcbiAgICAgICAgRFRIZWFkZXJDb21wb25lbnQyLFxuICAgICAgICBEVERldGFpbFJvd0NvbXBvbmVudCxcbiAgICAgICAgRFREZXRhaWxSb3dFeHBhbmRlckNvbXBvbmVudCxcbiAgICAgICAgRFRNdWx0aVNlbGVjdENvbHVtbkNvbXBvbmVudCxcbiAgICAgICAgRFRTaW5nbGVTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIFNldENlbGxNYXhXaWR0aERpcmVjdGl2ZSxcbiAgICAgICAgRFREcmFnZ2FibGVSb3dEaXJlY3RpdmVcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV091dGxpbmVGb3JNb2R1bGUsXG4gICAgICAgIEFXUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZVxuICAgIF0sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG4gICAgICAgIERURGV0YWlsUm93RXhwYW5kZXJDb21wb25lbnQsXG4gICAgICAgIERUTXVsdGlTZWxlY3RDb2x1bW5Db21wb25lbnQsXG4gICAgICAgIERUU2luZ2xlU2VsZWN0Q29sdW1uQ29tcG9uZW50XG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIERhdGF0YWJsZTJDb21wb25lbnQsXG4gICAgICAgIERUQ29sdW1uMkNvbXBvbmVudCxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBEVEhlYWRlckNvbXBvbmVudDIsXG4gICAgICAgIERURGV0YWlsUm93Q29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXRGF0YXRhYmxlMk1vZHVsZVxue1xufVxuXG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbi8qKlxuICogQW4gY29uZmlybWF0aW9uIGhlYWRlciBhcmVhLlxuICpcbiAqIFNlZSB7QGxpbmsgQ29uZmlybWF0aW9uQ29tcG9uZW50fSBmb3IgbW9yZSBleHBsYW5hdGlvbi5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24taGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50PjwvbmctY29udGVudD4nXG59KVxuZXhwb3J0IGNsYXNzIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudFxue1xufVxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50fSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBbiBjb25maXJtYXRpb24gaGVhZGVyIGFyZWEuXG4gKlxuICogU2VlIHtAbGluayBDb25maXJtYXRpb25Db21wb25lbnR9IGZvciBtb3JlIGV4cGxhbmF0aW9uLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2F3LWNvbmZpcm1hdGlvbi1mb290ZXInLFxuICAgIHRlbXBsYXRlOiAnPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50Pidcbn0pXG5leHBvcnQgY2xhc3MgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG57XG59XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RW52aXJvbm1lbnQsIGlzUHJlc2VudH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5pbXBvcnQge01vZGFsQ29udGFpbmVyfSBmcm9tICcuLi8uLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwtY29udGFpbmVyJztcbmltcG9ydCB7Q29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50JztcblxuLyoqXG4gKiBDb25maXJtYXRpb24gQ29tcG9uZW50IGlzIGEgc3BlY2lmaWMgdmVyc2lvbiBvZiB0aGUgZGlhbG9nIHdoZXJlIGl0IHN1cHBvcnRzIGNvbmZpcm0gYW5kIGNhbmNlbFxuICogZnVuY3Rpb25hbGl0eS4gSXQgYmVoYXZlcyBsaWtlIGEgZGlhbG9nLCBpcyBtb2RhbCwgYW5kIG5vdCBjbG9zYWJsZSBieSBkZWZhdWx0LlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSB0eXBlcyBvZiBwb3B1cC5cbiAqICAgMS4gIGEgcmVndWxhciBkaWFsb2cgYm94IHRoYXQgaGFzIGhlYWRlciwgYm9keSBhbmQgZm9vdGVyLiBJdCdzIHRoZSBtb3N0IGN1c3RvbWl6YWJsZS5cbiAqICAgMi4gIGEgY29uZmlybWF0aW9uIGJveCBpcyBzaW1pbGFyIHRvIGEgZGlhbG9nIGJveCBidXQgaGFzIGFjY2VwdCBhbmQgcmVqZWN0IGFjdGlvbiBidXR0b25zLlxuICogICAzLiAgYSBvdmVybGF5LCB3aGljaCBpcyBhIHZlcnkgYmFzaWMgcG9wdXAgd2l0aCB3aGF0IHlvdSBwdXQgaW5zaWRlLlxuICogICAgICAgSXQgZG9lc24ndCBoYXZlIGhlYWRlciBhbmQgZm9vdGVyLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gd2F5cyB0byB1c2UgYW55IHBvcHVwIGNvbXBvbmVudC5cbiAqICAgMS4gIEVpdGhlciBkaXJlY3RseSBieSB1c2luZyBjb21wb25lbnQsIGF3LWRpYWxvZywgYXctY29uZmlybWF0aW9uIG9yIGF3LW92ZXJsYXlcbiAqICAgMi4gIG9yIHRoZSBNb2RhbFNlcnZpY2UgIHNlcnZpY2Uub3Blbig8Q29uZmlybWF0aW9uQ29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIE1vZGFsU2VydmljZSBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoaXMgdXNhZ2UgaXMgYSBxdWljayB3YXkgdG8gc2hvd1xuICogICAgICAgIGEgY29uZmlybWF0aW9uIHRvIHRoZSB1c2VyLlxuICpcbiAqICAgICAgICAgIHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48Q29uZmlybWF0aW9uQ29tcG9uZW50PihDb25maXJtYXRpb25Db21wb25lbnQsIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdDb25maXJtYXRpb24nLFxuICogICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBgIEFyZSB5b3Ugc3VyZSA/IGAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAzMDAsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29uZmlybTogKCkgPT4ge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24oKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgb25DYW5jZWw6ICgpID0+IHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBY3Rpb24oKTtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgIH0pO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWNvbmZpcm1hdGlvbiBbdGl0bGVdPVwiJ0NvbmZpcm1hdGlvbidcIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsodmlzaWJsZSldPVwiZGlzcGxheVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25Db25maXJtKT1cImNvbmZpcm1BY3Rpb24oKVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChvbkNhbmNlbCk9XCJjYW5jZWxBY3Rpb24oKVwiPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cInNhcC1pY29uIGljb24tYWxlcnRcIj48L2k+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkZWxldGUgeW91ciBoYXJkIGRyaXZlP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9hdy1jb25maXJtYXRpb24+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhdy1idXR0b24gW3NpemVdPVwiJ3NtYWxsJ1wiIChjbGljayk9XCJvcGVuKClcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BlbiBDb25maXJtYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2F3LWJ1dHRvbj5cbiAqICAgICAgICAgICAgICAgICAgYFxuICogICAgICAgICBleHBvcnQgY2xhc3MgTXlQYWdlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGJvb2xlYW4gPSBmYWxzZTtcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1BY3Rpb246IHN0cmluZztcbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgbW9kYWxTZXJ2aWNlOiBNb2RhbFNlcnZpY2UpIHtcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBzdXBlcigpO1xuICogICAgICAgICAgICAgICAgICAgICAgIH1cbiAqICAgICAgICAgICAgICAgICAgICAgbmdPbkluaXQoKSB7IH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIG9wZW4oKSB7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheSA9IHRydWU7XG4gKiAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1BY3Rpb24oKSAge1xuICogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpcm1BY3Rpb24gPSBcImNvbmZpcm1lZFwiO1xuICogICAgICAgICAgICAgICAgICAgICAgfVxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5ID0gZmFsc2U7XG4gKiAgICAgICAgICAgICAgICAgICAgICB9XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgY2FuY2VsQWN0aW9uKCkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUFjdGlvbiA9IFwiY2FuY2VsZWRcIjtcbiAqICAgICAgICAgICAgICAgICAgICAgIH1cbiAqXG4gKiAgICAgICB9XG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1jb25maXJtYXRpb24nLFxuICAgIHRlbXBsYXRlOiBgPGF3LWRpYWxvZyBbdGl0bGVdPVwidGl0bGVcIiBbKHZpc2libGUpXT1cInZpc2libGVcIlxuICAgICAgICAgICBbbW9kYWxdPVwidHJ1ZVwiIFtjbG9zYWJsZV09XCJjbG9zYWJsZVwiIFt3aWR0aF09XCJ3aWR0aFwiIFtoZWlnaHRdPVwiaGVpZ2h0XCJcbiAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFthcHBlbmRUb109XCJhcHBlbmRUb1wiIChvbk9wZW4pPVwib3BlbigpXCIgKG9uQ2xvc2UpPVwiY2xvc2UoKVwiPlxuXG4gICAgPGF3LWRpYWxvZy1oZWFkZXIgKm5nSWY9XCJoYXNIZWFkZXIoKVwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJhdy1jb25maXJtYXRpb24taGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgIDwvYXctZGlhbG9nLWhlYWRlcj5cblxuICAgIHt7Ym9keX19XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXG5cbiAgICA8YXctZGlhbG9nLWZvb3RlciAqbmdJZj1cImhhc0Zvb3RlcigpOyBlbHNlIGRlZmF1bHRGb290ZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiYXctY29uZmlybWF0aW9uLWZvb3RlclwiPjwvbmctY29udGVudD5cbiAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG5cbiAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRGb290ZXI+XG4gICAgICAgIDxhdy1kaWFsb2ctZm9vdGVyPlxuICAgICAgICAgICAgPGF3LWJ1dHRvbiBuYW1lPVwiY29uZmlybVwiIFtzdHlsZV09XCIncHJpbWFyeSdcIiAoYWN0aW9uKT1cImNvbmZpcm0oKVwiPlxuICAgICAgICAgICAgICAgIHt7Y29uZmlybUFjdGlvbkxhYmVsfX1cbiAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuXG4gICAgICAgICAgICA8YXctYnV0dG9uIG5hbWU9XCJjYW5jZWxcIiBbc3R5bGVdPVwiJ3NlY29uZGFyeSdcIiAoYWN0aW9uKT1cImNhbmNlbCgpXCI+XG4gICAgICAgICAgICAgICAge3tjYW5jZWxBY3Rpb25MYWJlbH19XG4gICAgICAgICAgICA8L2F3LWJ1dHRvbj5cblxuICAgICAgICA8L2F3LWRpYWxvZy1mb290ZXI+XG4gICAgPC9uZy10ZW1wbGF0ZT5cblxuPC9hdy1kaWFsb2c+XG5gLFxuICAgIHN0eWxlczogW2AuY29uZmlybWF0aW9uLWZvb3Rlci1zZXBhcmF0b3J7Ym9yZGVyLXRvcDoxcHggc29saWQgI2Q3ZDdkNztoZWlnaHQ6MTRweH1gXVxufSlcbmV4cG9ydCBjbGFzcyBDb25maXJtYXRpb25Db21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lclxue1xuICAgIC8qKlxuICAgICAqIFRpdGxlIGZvciB0aGUgRGlhbG9nLiAgaWYgdGl0bGUgYW5kICdUaXRsZVRlbXBsYXRlJyBhcmUgYm90aCBzZXQsIHRpdGxlVGVtcGxhdGUgdGFrZXNcbiAgICAgKiBwcmVjZWRlbmNlLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEJvZHkgc2VjdGlvbiBmb3IgRGlhbG9nLiBDYWxsZXIgc2hvdWxkIHVzZSBlaXRoZXIgdGhlIGJvZHkgc3RyaW5nLCBvciBjb250ZW50IHByb2plY3Rpb25cbiAgICAgKiB0byBhZGQgdmFsdWVzIHRvIHRoZSBkaWFsb2cuIElmIGJvdGggYXJlIHVzZWQsIHRoZXkgd2lsbCBib3RoIHNob3cgdXAuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBib2R5OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UgYXJlIG5vdCB1c2luZyBjdXN0b20gYnV0dG9ucyB5b3UgY2FuIHBhc3MgYSBsYWJlbCB0byBPSyBhY3Rpb25cbiAgICAgKlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgT0tcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbmZpcm1BY3Rpb25MYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogSWYgeW91IGFyZSBub3QgdXNpbmcgY3VzdG9tIGJ1dHRvbnMgeW91IGNhbiBwYXNzIGEgbGFiZWwgdG8gQ2FuY2VsIGFjdGlvblxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBPS1xuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgY2FuY2VsQWN0aW9uTGFiZWw6IHN0cmluZztcblxuXG4gICAgLyoqXG4gICAgICogc3VwcG9ydCB0d28gd2F5IGRhdGEgYmluZGluZyBvbiB2aXNpYmxlIHByb3BlcnR5LlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHZpc2libGVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGVyZSdzIGFuIHggYXQgdGhlIHRvcCByaWdodCB0aGF0IG1ha2VzIHRoZSBkaWFsb2cgY2xvc2FibGUuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjbG9zYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBkaWFsb2cuIFwiYm9keVwiIG9yIGxvY2FsIG5nLXRlbXBsYXRlIHZhcmlhYmxlIGFyZSB2YWxpZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGFwcGVuZFRvOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGRpYWxvZyBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgb25DbG9zZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBkaWFsb2cgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHVzZXIgY2xpY2tlZCBvbiBjb25maXJtIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNvbmZpcm06IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB1c2VyIGNsaWNrZWQgb24gY2FuY2VsIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNhbmNlbDogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWFkZXIgY29tcG9uZW50LiBVc3VhbGx5IGNvbnRhaW5zIHRoZSB0aXRsZS5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCkgaGVhZGVyOiBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBEaWFsb2cgZm9vdGVyLiBVc3VhbGx5IGNvbnRhaW5zIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudCkgZm9vdGVyOiBDb25maXJtYXRpb25Gb290ZXJDb21wb25lbnQ7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbnY6IEVudmlyb25tZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52KTtcblxuICAgICAgICB0aGlzLndpZHRoID0gNDAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgLy8gVG9kbzogaW50ZXJuYXRpb25hbGl6ZS5cbiAgICAgICAgdGhpcy5jb25maXJtQWN0aW9uTGFiZWwgPSAnQ29uZmlybSc7XG4gICAgICAgIHRoaXMuY2FuY2VsQWN0aW9uTGFiZWwgPSAnQ2FuY2VsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvcGVuIGNvbmZpcm1hdGlvbi5cbiAgICAgKi9cbiAgICBvcGVuKClcbiAgICB7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25PcGVuLmVtaXQoKTtcblxuICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjbG9zZSBjb25maXJtYXRpb24uXG4gICAgICovXG4gICAgY2xvc2UoKVxuICAgIHtcbiAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG5cbiAgICAgICAgLy8gSW1wb3J0YW50IHRvIG1ha2Ugc3VyZSBjaGFuZ2UgaXMgc2V0IG9uIHBhcmVudCBiaW5kaW5nLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YXJpYWJsZSBhbmQgZGlhbG9nIG9wZW4vY2xvc2Ugc3RhdGUgY2FuIGJlIG91dFxuICAgICAgICAvLyBvZiBzeW5jIGFuZCB3ZSB3b3VsZG4ndCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICAgIHRoaXMudmlzaWJsZUNoYW5nZS5lbWl0KGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEb2VzIHRoZSBjb25maXJtYXRpb24gaGF2ZSBoZWFkZXIgY29udGVudD9cbiAgICAgKi9cbiAgICBoYXNIZWFkZXIoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLmhlYWRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRG9lcyB0aGUgY29uZmlybWF0aW9uIGhhdmUgZm9vdGVyIGNvbnRlbnQ/XG4gICAgICovXG4gICAgaGFzRm9vdGVyKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiBpc1ByZXNlbnQodGhpcy5mb290ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbmZpcm0gYWN0aW9uLlxuICAgICAqL1xuICAgIGNvbmZpcm0oKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ29uZmlybS5lbWl0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VsIGFjdGlvbi5cbiAgICAgKi9cbiAgICBjYW5jZWwoKVxuICAgIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ2FuY2VsLmVtaXQoKTtcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0FXQ29yZUNvbXBvbmVudE1vZHVsZX0gZnJvbSAnLi4vLi4vY29yZS9jb3JlLm1vZHVsZSc7XG5pbXBvcnQge0NvbmZpcm1hdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9jb25maXJtYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uSGVhZGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7Q29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50fSBmcm9tICcuL2NvbmZpcm1hdGlvbi1mb290ZXIuY29tcG9uZW50JztcbmltcG9ydCB7TW9kYWxDb21wb25lbnR9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC9tb2RhbC5jb21wb25lbnQnO1xuaW1wb3J0IHtBV0RpYWxvZ01vZHVsZX0gZnJvbSAnLi4vZGlhbG9nL2RpYWxvZy5tb2R1bGUnO1xuaW1wb3J0IHtBV0J1dHRvbk1vZHVsZX0gZnJvbSAnLi4vYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBNb2RhbENvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uQ29tcG9uZW50LFxuICAgICAgICBDb25maXJtYXRpb25IZWFkZXJDb21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkZvb3RlckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBDb25maXJtYXRpb25Db21wb25lbnQsXG4gICAgICAgIENvbmZpcm1hdGlvbkhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgQ29uZmlybWF0aW9uRm9vdGVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXQ29uZmlybWF0aW9uTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0NvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFNpbXBsZUNoYW5nZXN9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgaXNCbGFuaywgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5cbi8qKlxuICpcbiAqIENvbnRhaW5lciBwYW5lbCBwcm92aWRpbmcgc2Nyb2xsaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIGl0cyBjaGlsZHJlbi4gWW91IGNhbiBjb25maWd1cmUgdGhpc1xuICogY29udGFpbmVyIHRvIGxldCBpdCB0byBzY3JvbGwgaXRzIGNvbnRlbnQgZWl0aGVyIGhvcml6b250YWxseSwgdmVydGljYWxseSBvciBsZXQgdGhlIGNvbnRlbnRcbiAqIHdyYXAuXG4gKlxuICpcbiAqIFVzYWdlIGlzIHByZXR0eSBzaW1wbGU6XG4gKlxuICogICMjIyBFeGFtcGxlIHVzaW5nIGhvcml6b250YWwgc2Nyb2xsIChkZWZhdWx0IGJlaGF2aW9yKTpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAyPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDM8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNDwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA1PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDY8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA4PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDk8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgIDwvYXctc2Nyb2xsYWJsZT5cbiAqXG4gKiAgYGBgXG4gKlxuICogICMjIyBFeGFtcGxlIHVzaW5nIHZlcnRpY2FsIHNjcm9sbDpcbiAqXG4gKiAgYGBgXG4gKiAgICAgICAgICAgIDxhdy1zY3JvbGxhYmxlIFtkaXJlY3Rpb25dPVwiJ3ZlcnRpY2FsJ1wiIFtoZWlnaHRdPVwiJzQwdmgnXCI+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAxPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDI8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMzwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA0PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDU8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA3PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDg8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgOTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgPC9hdy1zY3JvbGxhYmxlPlxuICpcbiAqIGBgYFxuICpcbiAqICAjIyMgRXhhbXBsZSBzY3JvbGxpbmcgaXMgZGlzYWJsZWQgYW5kIGNvbnRlbnQgd3JhcHMgYW5kIGNlbnRlcnM6XG4gKlxuICogIGBgYFxuICogICAgICAgICAgICA8YXctc2Nyb2xsYWJsZSBbZGlyZWN0aW9uXT1cIidub25lJ1wiIFthbGlnbm1lbnRdPVwiJ2NlbnRlcidcIj5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDE8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgMjwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCAzPC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDQ8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgNTwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA2PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICAgICAgPHctZGVtby1jYXJkPiBDYXJkIDc8L3ctZGVtby1jYXJkPlxuICogICAgICAgICAgICAgICAgICA8dy1kZW1vLWNhcmQ+IENhcmQgODwvdy1kZW1vLWNhcmQ+XG4gKiAgICAgICAgICAgICAgICAgIDx3LWRlbW8tY2FyZD4gQ2FyZCA5PC93LWRlbW8tY2FyZD5cbiAqICAgICAgICAgICAgICA8L2F3LXNjcm9sbGFibGU+XG4gKiAgYGBgXG4gKlxuICogIyMjIEhlaWdodCBwcm9wZXJ0eTpcbiAqXG4gKiBXaGVuIHVzaW5nIFwiaG9yaXpvbnRhbCBzY3JvbGxpbmdcIiBpdCBzZXQgXCJmbGV4Ym94LWRpcmVjdGlvblwiIHRvIFwicm93XCIgd2hlcmUgaGVpZ2h0XG4gKiBpcyBzZXQgYXV0b21hdGljYWxseSBiYXNlZCBvbiBpdHMgY29udGVudC4gVGhlIGhlaWdodCBzaG91bGQgYmUgYWx3YXlzIDEwMCUgd2hlbiB1c2luZ1xuICogdGhpcyBpbiBwYXJlbnQgY29udGFpbmVyLlxuICpcbiAqIElmIFwidmVydGljYWwgc2Nyb2xsaW5nXCIgaXMgdXNlZCB5b3UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdDpcbiAqICAgLSB5b3VyIHBhcmVudCBjb250YWluZXIgc2V0cyB0aGUgYm91bmRhcmllcyB3aXRoIGNvcnJlY3RseSBzZXQgd2lkdGggYW5kIGhlaWdodFxuICogICBvdGhlcndpc2UgaXQgd2lsbCB1c2UgMTAwJSBvZiB0aGUgdmlld3BvcnRcbiAqICAgLSBpZiB1c2VkIGFzIHN0YW5kYWxvbmUgeW91IG5lZWQgdG8gbGltaXQgdGhlIGhlaWdodCBvdGhlcndpc2UgaXQgd2lsbCBleHBhbmQgdG8gMTAwJSBvZlxuICogICB0aGUgZG9jdW1lbnRcbiAqXG4gKlxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctc2Nyb2xsYWJsZScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidy1zY3JvbGxhYmxlXCIgW25nQ2xhc3NdPVwibGF5b3V0Q2xhc3NcIiBbc3R5bGUud2lkdGhdPVwid2lkdGhcIlxuICAgICBbc3R5bGUuaGVpZ2h0XT1cImhlaWdodFwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuYCxcbiAgICBzdHlsZXM6IFtgLnctc2Nyb2xsYWJsZXtkaXNwbGF5OmZsZXg7ZGlzcGxheTotd2Via2l0LWZsZXg7YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjt3aWxsLWNoYW5nZTpvdmVyZmxvd30udy1zY3JvbGxhYmxlIC9kZWVwLz4qe2ZsZXg6MCAwIGF1dG87LXdlYmtpdC1mbGV4OjAgMCBhdXRvOy1tcy1mbGV4OjAgMCBhdXRvO21hcmdpbjoxMHB4fS51LXNjcm9sbGFibGUtZmh7ZmxleC1mbG93OnJvdyBub3dyYXA7b3ZlcmZsb3cteDphdXRvO292ZXJmbG93LXk6aGlkZGVufS51LXNjcm9sbGFibGUtZnZ7ZmxleC1mbG93OmNvbHVtbiBub3dyYXA7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvfS51LXNjcm9sbGFibGUtZmJ7ZmxleC1mbG93OnJvdyBub3dyYXA7b3ZlcmZsb3cteDphdXRvO292ZXJmbG93LXk6YXV0b30udS1zY3JvbGxhYmxlLWZ2LXJvd3tmbGV4LWZsb3c6cm93IHdyYXA7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvfS51LXNjcm9sbGFibGUtZm57ZmxleC1mbG93OnJvdyB3cmFwfS51LXNjcm9sbGFibGUtYWx7anVzdGlmeS1jb250ZW50OmZsZXgtc3RhcnQ7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6ZmxleC1zdGFydH0udS1zY3JvbGxhYmxlLWFye2p1c3RpZnktY29udGVudDpmbGV4LWVuZDstd2Via2l0LWp1c3RpZnktY29udGVudDpmbGV4LWVuZH0udS1zY3JvbGxhYmxlLWFje2p1c3RpZnktY29udGVudDpjZW50ZXI7LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfS51LXNjcm9sbGFibGUtYWosLnUtc2Nyb2xsYWJsZS1hai1hcm91bmR7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47LXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn1gXVxufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50IGV4dGVuZHMgQmFzZUNvbXBvbmVudFxue1xuXG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHNjcm9sbGluZyBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5lciBtZWFuaW5nIHRlbGxzIHdoaWNoIG92ZXJmbG93IGF4aWVzIHdpbGwgYmVcbiAgICAgKiBkaXNhYmxlZCBvciBlbmFibGVkLlxuICAgICAqXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBcImhvcml6b250YWxcIjogSGVyZSB3ZSBsb2NrIG92ZXJmbG93LXkgYW5kIG92ZXJmbG93LXggc2V0IHRvIGF1dG8uXG4gICAgICpcbiAgICAgKiBXaGVuIHNjcm9sbGluZyBkaXJlY3Rpb24gaXMgXCJ2ZXJ0aWNhbFwiIHBsZWFzZSBtYWtlIHN1cmUgeW91IG1haW50YWluIGNvcnJlY3QgaGVpZ2h0IGFuZFxuICAgICAqIHdpZHRoLlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBkaXJlY3Rpb246IFNjcm9sbGluZ0RpcmVjdGlvbiA9ICdob3Jpem9udGFsJztcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaG93IGZsZXhib3ggY29udGFpbmVyIGl0ZW1zIHNob3VsZCBiZSBhbGlnbmVkLiBEZWZhdWx0IGJlaGF2aW9yIGlzIExFRlRcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYWxpZ25tZW50OiBDb250YWluZXJJdGVtc0FsaWdubWVudCA9ICdsZWZ0JztcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgcHJvcGVydGllcyBmb3IgY2FsY3VsYXRlZCBjbGFzcyBsaXN0XG4gICAgICovXG5cbiAgICBsYXlvdXRDbGFzczogc3RyaW5nO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCwgcHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpXG4gICAge1xuICAgICAgICBzdXBlcihlbnYpO1xuXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0aGlzLndpZHRoID0gJzEwMCUnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMuaW5pdERlZmF1bHQoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB3ZSByZS1pbml0aWFsaXplIGRlZmF1bHQgd2hlbiBJbnB1dCBCaW5kaW5ncyBjaGFuZ2VzXG4gICAgICpcbiAgICAgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5pbml0RGVmYXVsdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBkZWZhdWx0IHZhbHVlcyBhbmQgQ2FsY3VsYXRlcyBsYXlvdXQgYW5kIGFsaWdubWVudCBjbGFzcy4gVGhlIHJlYXNvbiBmb3IgdXNpbmdcbiAgICAgKiB0aGVzZSB1dGlsaXR5IGNsYXNzZXMgaXMgdGhhdCB3ZSBjYW4gY2hhbmdlIHRoZSBiZWhhdmlvciBhbnl0aW1lIGFzIGNvbXBhcmVkIHRvIHVzaW5nXG4gICAgICogZGlyZWN0bHkgW3N0eWxlLnh4eF0gYmluZGluZ3MuXG4gICAgICpcbiAgICAgKiAjIyMgRGlyZWN0aW9uIGZsb3cgY2xhc3M6XG4gICAgICogIC0gdS1zY3JvbGxhYmxlLWY8ZGlyZWN0aW9uPlxuICAgICAqXG4gICAgICogIyMjIEFsaWdubWVudCBjbGFzczpcbiAgICAgKiAgLSB1LXNjcm9sbGFibGUtYTxhbGlnbm1lbnQ+XG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXREZWZhdWx0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgPSAndS1zY3JvbGxhYmxlLWZoJztcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mdic7XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbC1yb3cnKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dENsYXNzID0gJ3Utc2Nyb2xsYWJsZS1mdi1yb3cnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdib3RoJykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZmInO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdub25lJykge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyA9ICd1LXNjcm9sbGFibGUtZm4nO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXlvdXRDbGFzcyArPSAnIHUtc2Nyb2xsYWJsZS1hJyArIHRoaXMuYWxpZ25tZW50LnN1YnN0cmluZygwLCAxKTtcblxuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuc3R5bGVDbGFzcykpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q2xhc3MgKz0gYCAke3RoaXMuc3R5bGVDbGFzc31gO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRlZmF1bHQgd2lkdGggYW5kIGhlaWdodCB0byBzb21lIHZhbHVlIGluIGNhc2Ugc29tZWJvZHkgcGFzc2VzIG51bGxcbiAgICAgICAgaWYgKGlzQmxhbmsodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbGFuayh0aGlzLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUZWxscyBpZiB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIgaXMgdmlzaWJsZVxuICAgICAqXG4gICAgICovXG4gICAgaGFzSG9yaXpvbnRhbFNjcm9sbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnctc2Nyb2xsYWJsZScpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFdpZHRoID4gc2Nyb2xsQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVGVsbHMgaWYgdGhlIHZlcnRpY2FsIHNjcm9sbGJhciBpcyB2aXNpYmxlXG4gICAgICpcbiAgICAgKi9cbiAgICBoYXNWZXJ0aWNhbFNjcm9sbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICBsZXQgc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLnctc2Nyb2xsYWJsZScpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsQ29udGFpbmVyLnNjcm9sbEhlaWdodCA+IHNjcm9sbENvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIFNjcm9sbGluZ0RpcmVjdGlvbiBpcyBhIG5ldyB0eXBlIHRoYXQgZHJpdmVzIHNjcm9sbGluZyBiZWhhdmlvcjpcbiAqICAtIGhvcml6b250YWwgPT4gb3ZlcmZsb3cteDogYXV0bywgb3ZlcmZsb3cteTpoaWRkZW5cbiAqICAtIHZlcnRpY2FsID0+IG92ZXJmbG93LXg6IGhpZGRlbiwgb3ZlcmZsb3cteTphdXRvXG4gKiAgLSB2ZXJ0aWNhbC1yb3cgPT4gb3ZlcmZsb3cteDogaGlkZGVuLCBvdmVyZmxvdy15OmF1dG87IGZsb3c6IHJvdyB3cmFwXG4gKiAgLSBib3RoID0+IG92ZXJmbG93LXg6IGF1dG8sIG92ZXJmbG93LXk6YXV0b1xuICogIC0gbm9uZSA9PiBzZXRzIGZsb3ctZmxvdyB0byByb3cgd3JhcFxuICovXG5leHBvcnQgdHlwZSBTY3JvbGxpbmdEaXJlY3Rpb24gPSAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnIHwgJ3ZlcnRpY2FsLXJvdycgfCAnYm90aCcgfCAnbm9uZSc7XG5cblxuLyoqXG4gKlxuICogQ29udHJvbHMgdGhlIGp1c3RpZnktY29udGVudCBwcm9wZXJ0eTpcbiAqXG4gKiAtIGxlZnQgPT4gZmxleC1zdGFydFxuICogLSByaWdodCA9PiBmbGV4LWVuZFxuICogLSBjZW50ZXIgPT4gY2VudGVyXG4gKiAtIGp1c3RpZnkgPT4gc3BhY2UtYmV0d2VlblxuICpcbiAqL1xuZXhwb3J0IHR5cGUgQ29udGFpbmVySXRlbXNBbGlnbm1lbnQgPSAnbGVmdCcgfCAncmlnaHQnIHwgJ2NlbnRlcicgfCAnanVzdGlmeSc7XG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7U2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudH0gZnJvbSAnLi9zY3JvbGxhYmxlLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFNjcm9sbGFibGVDb250YWluZXJDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgU2Nyb2xsYWJsZUNvbnRhaW5lckNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBTY3JvbGxhYmxlQ29udGFpbmVyQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXU2Nyb2xsYWJsZUNvbnRhaW5lck1vZHVsZVxue1xufVxuXG5cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgU2tpcFNlbGYsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtFbnZpcm9ubWVudCwgZXF1YWxzLCBpc0JsYW5rLCBpc1ByZXNlbnR9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtOR19WQUxVRV9BQ0NFU1NPUn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHtCYXNlRm9ybUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLWZvcm0uY29tcG9uZW50JztcbmltcG9ydCB7TGlzdGJveCwgU2VsZWN0SXRlbX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7Q2hlY2tib3hDb21wb25lbnR9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5cblxuZXhwb3J0IGNvbnN0IExCX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBMaXN0Q29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuLyoqXG4gKlxuICogVGhlIExpc3QgY29tcG9uZW50IHJlcHJlc2VudCBhIHN0cnVjdHVyZSB3aGljaCBjb250YWlucyBhIGxpc3Qgb2Ygc2VsZWN0YWJsZSBpdGVtcy4gSXRlbXNcbiAqIHNlbGVjdGlvbiBjYW4gYmUgY29uZmlndXJlZCBpbiBzaW5nbGUtc2VsZWN0aW9uLCBtdWx0aS1zZWxlY3Rpb24gb3IgbXVsdGktc2VsZWN0aW9uIHdpdGggdmlzaWJsZVxuICogY2hlY2tib3hlcyBtb2RlLlxuICogSW4gYWRkaXRpb24gaXQgY2FuIGRpc3BsYXkgZGF0YSBpbnNpZGUgMyB6b25lcyBMRUZULCBNSURETEUgYW5kIFJJR0hUIGluIG9yZGVyIHRvIHByb3ZpZGVcbiAqIGVhc3kgd2F5IGZvciBhcHBsaWNhdGlvbiBkZXZlbG9wZXIgdG8gbGF5b3V0IGl0cyBvd24gY3VzdG9tIGNvbnRlbnQgb3IgZXZlbiBjaGFuZ2Ugb3V0IG9mIGJveFxuICogYmVoYXZpb3IuXG4gKlxuICpcbiAqICAjIyMgRXhhbXBsZXNcbiAqXG4gKiAgMS4gUmVuZGVyIHNpbXBsZSBzaW5nbGUgc2VsZWN0aW9uIGxpc3RcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgICAgPGF3LWxpc3QgW2xpc3RdPVwibGlzdFwiPjwvYXctbGlzdD5cbiAqXG4gKiAgYGBgXG4gKiAgMi4gUmVuZGVyIGxpc3QgLSBtdWx0aSBzZWxlY3Rpb24gd2l0aCBjdXN0b20gUklHSFQgY29udGVudCB0byBzaG93IGEgQ2hlY2tNYXJrIHdoZW4gaXRlbVxuICogIGlzIHNlbGVjdGVkXG4gKlxuICogIGBgYGh0bWxcbiAqXG4gKiAgIDxhdy1saXN0ICNhd2xpc3QgW2xpc3RdPVwibGlzdFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0PVwiMTUwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIHdpZHRoPVwiMjUwcHhcIlxuICogICAgICAgICAgICAgICAgICAgICAgIFtzZWxlY3Rpb25Nb2RlXT1cIidtdWx0aSdcIj5cbiAqXG4gKiAgICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjcmlnaHQgbGV0LWl0ZW0+XG4gKlxuICogICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzYXAtaWNvblwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdDbGFzc109XCJ7J2ljb24tYWNjZXB0JzogYXdsaXN0LnBMaXN0Qm94LmlzU2VsZWN0ZWQoaXRlbSksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnJzogIWF3bGlzdC5wTGlzdEJveC5pc1NlbGVjdGVkKGl0ZW0pfVwiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAqICAgICAgICAgICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgPC9hdy1saXN0PlxuICpcbiAqICBgYGBcbiAqXG4gKiAzLiBSZW5kZXIgbGlzdCAtIG11bHRpIHNlbGVjdGlvbiB3aXRoIHZpc2libGUgY2hlY2tib3hlcyBhbmQgY3VzdG9tIE1JRERMRSBjb250ZW50IHRvIGNoYW5nZVxuICogIHRoZSB3YXkgaXRlbSBuYW1lIGlzIHJlbmRlcmVkXG4gKlxuICpcbiAqXG4gKiAgYGBgaHRtbFxuICpcbiAqICAgPGF3LWxpc3QgW2xpc3RdPVwibGlzdFwiIGhlaWdodD1cIjE4MHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWR0aD1cIjIwMHB4XCJcbiAqICAgICAgICAgICAgICAgICAgICAgICBbc2VsZWN0aW9uXT1cInNlbGVjdGlvblwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgW3NlbGVjdGlvbk1vZGVdPVwiJ211bHRpV2l0aENoZWNrYm94J1wiPlxuICpcbiAqICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNtaWRkbGUgbGV0LWl0ZW0+XG4gKiAgICAgICAgICAgICAgICAgICAgICBYWC17e2l0ZW0udmFsdWV9fVxuICogICAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICogICAgPC9hdy1saXN0PlxuICpcbiAqICBgYGBcbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1saXN0JyxcbiAgICB0ZW1wbGF0ZTogYDxwLWxpc3Rib3ggI2xpc3Rib3ggW29wdGlvbnNdPVwiaW50ZXJuYWxMaXN0XCIgW211bHRpcGxlXT1cImlzTXVsdGlwbGVcIiBbY2hlY2tib3hdPVwic2hvd0NoZWNrYm94XCJcbiAgICAgICAgICAgWyhuZ01vZGVsKV09XCJzZWxlY3Rpb25cIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIiBbc3R5bGVdPVwibGlzdFN0eWxlXCIgW3Nob3dUb2dnbGVBbGxdPVwiZmFsc2VcIlxuICAgICAgICAgICAob25DaGFuZ2UpPVwib25JdGVtU2VsZWN0ZWQoJGV2ZW50KVwiIChvbkRibENsaWNrKT1cImFjdGlvbi5lbWl0KCRldmVudC52YWx1ZSlcIlxuICAgICAgICAgICBbc3R5bGVDbGFzc109XCJzdHlsZUNsYXNzXCI+XG5cblxuICAgIDxuZy10ZW1wbGF0ZSBsZXQtaXRlbSBwVGVtcGxhdGU9XCJpdGVtXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ3LWxpLXdyYXBwZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ3LWxpLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCJoYXNMZWZ0VGVtcGwoKTsgZWxzZSBkZWZhdWx0TGVmdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxab25lVGVtcGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXRlbX1cIj48L25nLXRlbXBsYXRlPlxuXG5cbiAgICAgICAgICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRMZWZ0PlxuICAgICAgICAgICAgICAgICAgICA8YXctY2hlY2tib3ggI2NoZWNrICpuZ0lmPVwiaXNNdWx0aXBsZSAmJiBzaG93Q2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2lzU3RhbmRhbG9uZV09XCJmYWxzZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdPVwibGlzdGJveC5pc1NlbGVjdGVkKGl0ZW0pXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJhY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFjdGlvbik9XCJpdGVtQ2xpY2tlZCgkZXZlbnQsIGl0ZW0sIGNoZWNrKVwiPlxuICAgICAgICAgICAgICAgICAgICA8L2F3LWNoZWNrYm94PlxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInctbGktbWlkZGxlXCIgKGNsaWNrKT1cIml0ZW1DbGlja2VkKCRldmVudCwgaXRlbSwgbnVsbClcIj5cblxuICAgICAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAqbmdJZj1cImhhc01pZGRsZVRlbXBsKCk7IGVsc2UgZGVmYXVsdE1pZGRsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm1ab25lVGVtcGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXRlbX1cIj48L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0TWlkZGxlPlxuICAgICAgICAgICAgICAgICAgICB7e2l0ZW0ubGFiZWx9fVxuICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidy1saS1yaWdodFwiICpuZ0lmPVwiaGFzUmlnaHRUZW1wbCgpXCI+XG4gICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInJab25lVGVtcGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwieyRpbXBsaWNpdDogaXRlbX1cIj5cbiAgICAgICAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbjwvcC1saXN0Ym94PlxuYCxcbiAgICBzdHlsZXM6IFtgOjpuZy1kZWVwIC51aS1saXN0Ym94LWl0ZW0+LnVpLWNoa2JveHtkaXNwbGF5Om5vbmV9OjpuZy1kZWVwIC51aS1saXN0Ym94LWl0ZW0gLnVpLWNoa2JveHttYXJnaW4tcmlnaHQ6MWVtfS53LWxpLXdyYXBwZXJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmZsZXgtc3RhcnR9LnctbGktd3JhcHBlciAudy1saS1sZWZ0LC53LWxpLXdyYXBwZXIgLnctbGktcmlnaHR7ZmxleDowIDEgYXV0b30udy1saS13cmFwcGVyIC53LWxpLW1pZGRsZXtmbGV4OjEgMSBhdXRvfWBdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBMQl9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICB7cHJvdmlkZTogQmFzZUZvcm1Db21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExpc3RDb21wb25lbnQpfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTGlzdENvbXBvbmVudCBleHRlbmRzIEJhc2VGb3JtQ29tcG9uZW50XG57XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIG9wdGlvbiB0aGF0IHdpbGwgc2hvdyBpbiB0aGUgbGlzdC4gUGxlYXNlIG5vdCB0aGF0IHRoaXMgbGlzdCBpcyBjdXJyZW50IHVzZWQgdG9cbiAgICAgKiBzaG93IGxpbWl0ZWQgbnVtYmVyIG9mIGl0ZW1zLiBJdCBkb2VzIG5vdCBoYXZlIGFueSBzY3JvbGxpbmcgZmVhdHVyZSBhbmQgbGF6eSBsb2FkaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGxpc3Q6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgICogSXRlbXMgd2hpY2ggd2FzIHNlbGVjdGVkIGFzIGEgZGVmYXVsdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbjogYW55O1xuXG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHJlY29nbml6ZXMgMyBtb2Rlczogc2luZ2xlLCBtdWx0aSwgbXVsdGkgd2l0aCB2aXNpYmxlIGNoZWNrYm94ZXNcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNlbGVjdGlvbk1vZGU6IFNlbGVjdGlvbk1vZGUgPSAnc2luZ2xlJztcblxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0dGVyIHVzZWQgdG8gZm9ybWF0IGVhY2ggc2VsZWN0aW9uIGZvciBkaXNwbGF5LlxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICB2YWx1ZVRyYW5zZm9ybWVyOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB3aGVuIGRlYWxpbmcgd2l0aCBvYmplY3QgdG8gaWRlbnRpZnkgc3BlY2lmaWMgZmllbGQgb24gdGhlIG9iamVjdCBmb3Jjb21wYXJpc29uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmaWVsZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBEb24ndCByZW5kZXIgTGlzdGJveCBib3JkZXIuIFVzZWQgZm9yIGVtYmVkZGluZyB0aGlzIGluc2lkZSBvdGhlciBjb21wb25lbnRzXG4gICAgICpcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGJvcmRlcmxlc3M6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXJlZCB3aGVuIHdlIGRvdWJsZSBjbGljayBvbiB0aGUgbGlzdCBJdGVtXG4gICAgICpcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBhY3Rpb246IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB1c2VyIHNlbGVjdCBhIGl0ZW1cbiAgICAgKlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uU2VsZWN0aW9uOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuXG4gICAgLyoqXG4gICAgICogSW4gY2FzZSB3ZSB3YW50IHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3Igb3IgTGVmdCB6b25lLiBXZSBleHBvc2UgdGhpcyBsaXN0Qm94IGluIG9yZGVyIHRvXG4gICAgICogaGF2ZSBhY2Nlc3MgcHJpbWVOZyBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2xpc3Rib3gnKVxuICAgIHBMaXN0Qm94OiBMaXN0Ym94O1xuXG5cbiAgICAvKipcbiAgICAgKiBDdXN0b20gdGVtcGxhdGVzIHRvIG92ZXJyaWRlIGRlZmF1bHQgYmVoYXZpb3IuIFRoZSBsaXN0IGl0ZW0gaXMgZGl2aWRlZCBpbnRvIDMgem9uZXNcbiAgICAgKlxuICAgICAqXG4gICAgICogIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAgICAgKiAgfCAgIEwgICB8ICAgICAgICAgICAgIE0gICAgICAgICAgICAgICAgICAgICB8ICAgUiAgICB8XG4gICAgICogIHwgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgfFxuICAgICAqICB8ICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAgICAgKiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoJ2xlZnQnKVxuICAgIGxab25lVGVtcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAQ29udGVudENoaWxkKCdtaWRkbGUnKVxuICAgIG1ab25lVGVtcGw6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBAQ29udGVudENoaWxkKCdyaWdodCcpXG4gICAgclpvbmVUZW1wbDogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsXG4gICAgICovXG4gICAgaW50ZXJuYWxMaXN0OiBTZWxlY3RJdGVtW107XG5cbiAgICBsaXN0U3R5bGU6IHtbbmFtZTogc3RyaW5nXTogYW55fSA9IHt9O1xuXG4gICAgaXNNdWx0aXBsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHNob3dDaGVja2JveDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudCxcbiAgICAgICAgICAgICAgICBAU2tpcFNlbGYoKSBAT3B0aW9uYWwoKSBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gQmFzZUZvcm1Db21wb25lbnQpKVxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCBwYXJlbnRDb250YWluZXI6IEJhc2VGb3JtQ29tcG9uZW50KVxuICAgIHtcbiAgICAgICAgc3VwZXIoZW52LCBwYXJlbnRDb250YWluZXIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG5cbiAgICAgICAgdGhpcy5pc011bHRpcGxlID0gdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGknIHx8XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGUgPT09ICdtdWx0aVdpdGhDaGVja2JveCc7XG4gICAgICAgIHRoaXMuc2hvd0NoZWNrYm94ID0gdGhpcy5zZWxlY3Rpb25Nb2RlID09PSAnbXVsdGlXaXRoQ2hlY2tib3gnO1xuXG4gICAgICAgIC8vIGNhbm5vdCBoYXZlIGJvdGggZWl0aGVyIHdlIHVzZSBmaWVsZCB0byBnZXQgZGlzcGxheSB2YWx1ZSBvciB2YWx1ZVRyYW5zZm9ybWVyXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5maWVsZCkgJiYgaXNQcmVzZW50KHRoaXMudmFsdWVUcmFuc2Zvcm1lcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBoYXZlIGVpdGhlciBbZmllbGRdIG9yIFt2YWx1ZVRyYW5zZm9ybWVyXS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0TGlzdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFtsaXN0XSBiaW5kaW5nLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWxzbyBhZGQgb3ZlcmZsb3dZIHRvIG1ha2Ugc3VyZSBpdCBjYW4gc2Nyb2xsIGFuZCBkb2VzIG5vdCBleHBhbmQgYmFzZWQgb24gaXRzIGNvbnRlbnRcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWydoZWlnaHQnXSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5saXN0U3R5bGVbJ292ZXJmbG93LXknXSA9ICdhdXRvJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWyd3aWR0aCddID0gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJvcmRlcmxlc3MpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdFN0eWxlWydib3JkZXItY29sb3InXSA9ICd0cmFuc3BhcmVudCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlZ2lzdGVyRm9ybUNvbnRyb2wodGhpcy5zZWxlY3Rpb24pO1xuXG4gICAgICAgICAgICBpZiAoaXNCbGFuayh0aGlzLnNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHRoaXMuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogU2luY2Ugd2UgYXJlIHVzaW5nIDxhdy1jaGVja2JveD4gd2UgbmVlZCB0byBoYXZlIGN1c3RvbSBoYW5kbGluZyBib3RoIHdoZW4gY2xpY2tpbmcgb24gdGhlXG4gICAgICogY2hlY2tib3ggYXMgd2VsbCBhcyBpdGVtIHRleHQuXG4gICAgICpcbiAgICAgKlxuICAgICAqL1xuICAgIGl0ZW1DbGlja2VkKGV2ZW50OiBhbnksIGl0ZW06IGFueSwgY2hlY2tib3g6IENoZWNrYm94Q29tcG9uZW50KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzUHJlc2VudChjaGVja2JveCkpIHtcbiAgICAgICAgICAgIHRoaXMucExpc3RCb3gub25DaGVja2JveENsaWNrKGV2ZW50LCBpdGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJlc2VudCh0aGlzLnBMaXN0Qm94KSkge1xuICAgICAgICAgICAgdGhpcy5wTGlzdEJveC5vbk9wdGlvbkNsaWNrKGV2ZW50LCBpdGVtKTtcblxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWxcbiAgICAgKlxuICAgICAqL1xuICAgIGhhc1JpZ2h0VGVtcGwoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuIGlzUHJlc2VudCh0aGlzLnJab25lVGVtcGwpO1xuICAgIH1cblxuICAgIGhhc0xlZnRUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubFpvbmVUZW1wbCk7XG4gICAgfVxuXG5cbiAgICBoYXNNaWRkbGVUZW1wbCgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gaXNQcmVzZW50KHRoaXMubVpvbmVUZW1wbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUcmlnZ2VyZWQgYnkgcC1saXN0Ym94IGNvbXBvbmVudCB3aGVuIGl0ZW0gaXMgc2VsZWN0ZWQuIFdoZW4gc3RhdGUgaXMgbWFuYWdlZCBpbnRlcm5hbGx5XG4gICAgICogd2UgYWxzbyB1cGRhdGUgRm9ybUNvbnRyb2wgbW9kZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBvbkl0ZW1TZWxlY3RlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYgKGlzQmxhbmsoZXZlbnQudmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQoZXZlbnQudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5pc1N0YW5kYWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUNvbnRyb2wuc2V0VmFsdWUoZXZlbnQudmFsdWUsIHtlbWl0RXZlbnQ6IHRydWV9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uTW9kZWxDaGFuZ2VkKGV2ZW50LnZhbHVlKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsLiBQbGVhc2Ugc2VlIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gICAgICpcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpXG4gICAge1xuICAgICAgICBpZiAoIWVxdWFscyh2YWx1ZSwgdGhpcy5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGFuZGFsb25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtQ29udHJvbC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIGV4dGVybmFsIGZvcm0gb2YgdGhlIGxpc3QgaW50byBQcmltZU5HIGV4cGVjdGVkIGZvcm1hdCB3aGVyZSBpdCB1c2VzXG4gICAgICogU2VsZWN0aW9uSXRlbSBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRMaXN0KClcbiAgICB7XG4gICAgICAgIGlmIChpc1ByZXNlbnQodGhpcy5saXN0KSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbExpc3QgPSB0aGlzLmxpc3QubWFwKChpdGVtOiBhbnkpID0+XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtsYWJlbDogdGhpcy5kaXNwbGF5VmFsdWUoaXRlbSksIHZhbHVlOiBpdGVtfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgR2VuZXJhdGVzIGxhYmVsIHZhbHVlIGZvciB0aGUgbGlzdCBib3guXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGRpc3BsYXlWYWx1ZShpdGVtOiBhbnkpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGlmIChpc0JsYW5rKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFsID0gaXRlbS50b1N0cmluZygpO1xuICAgICAgICBpZiAoaXNQcmVzZW50KHRoaXMuZmllbGQpKSB7XG4gICAgICAgICAgICB2YWwgPSBpdGVtW3RoaXMuZmllbGRdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcmVzZW50KHRoaXMudmFsdWVUcmFuc2Zvcm1lcikpIHtcbiAgICAgICAgICAgIHZhbCA9IHRoaXMudmFsdWVUcmFuc2Zvcm1lcihpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBMaXN0IHN1cHBvcnQgdGhlc2UgdGhyZWUgc2VsZWN0aW9uIG1vZGVzXG4gKlxuICovXG5leHBvcnQgdHlwZSBTZWxlY3Rpb25Nb2RlID0gJ3NpbmdsZScgfCAnbXVsdGknIHwgJ211bHRpV2l0aENoZWNrYm94JztcbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7TGlzdGJveE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcbmltcG9ydCB7TGlzdENvbXBvbmVudH0gZnJvbSAnLi9saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4uL2NoZWNrYm94L2NoZWNrLWJveC5tb2R1bGUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZSwgUmVhY3RpdmVGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIExpc3RDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgTGlzdGJveE1vZHVsZSxcbiAgICAgICAgQVdDaGVja0JveE1vZHVsZVxuXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgTGlzdENvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBMaXN0Q29tcG9uZW50LFxuICAgICAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBBV0xpc3RNb2R1bGVcbntcbn1cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kYWxDb250YWluZXJ9IGZyb20gJy4uLy4uL2NvcmUvbW9kYWwtc2VydmljZS9tb2RhbC1jb250YWluZXInO1xuaW1wb3J0IHtPdmVybGF5UGFuZWx9IGZyb20gJ3ByaW1lbmcvcHJpbWVuZyc7XG5pbXBvcnQge0Vudmlyb25tZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcblxuLyoqXG4gKiBPdmVybGF5IENvbXBvbmVudCBpcyBhIHNpbXBsZSB2ZXJzaW9uIG9mIHRoZSBkaWFsb2cgd2hlcmUgdGhlcmUncyBvbmx5IGNvbnRlbnQuXG4gKiBPdmVybGF5IHdpbGwgYXBwZWFyIGF0IHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgYWN0aW9uIHBlcmZvcm1lZCB0cmlnZ2VyIGFuIG92ZXJsYXkuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHR5cGVzIG9mIHBvcHVwLlxuICogICAxLiAgYSByZWd1bGFyIGRpYWxvZyBib3ggdGhhdCBoYXMgaGVhZGVyLCBib2R5IGFuZCBmb290ZXIuIEl0J3MgdGhlIG1vc3QgY3VzdG9taXphYmxlLlxuICogICAyLiAgYSBjb25maXJtYXRpb24gYm94IGlzIHNpbWlsYXIgdG8gYSBkaWFsb2cgYm94IGJ1dCBoYXMgYWNjZXB0IGFuZCByZWplY3QgYWN0aW9uIGJ1dHRvbnMuXG4gKiAgIDMuICBhIG92ZXJsYXksIHdoaWNoIGlzIGEgdmVyeSBiYXNpYyBwb3B1cCB3aXRoIHdoYXQgeW91IHB1dCBpbnNpZGUuXG4gKiAgICAgICBJdCBkb2Vzbid0IGhhdmUgaGVhZGVyIGFuZCBmb290ZXIuXG4gKlxuICogVGhlcmUgYXJlIHR3byB3YXlzIHRvIHVzZSBhbnkgcG9wdXAgY29tcG9uZW50LlxuICogICAxLiAgRWl0aGVyIGRpcmVjdGx5IGJ5IHVzaW5nIGNvbXBvbmVudCwgYXctZGlhbG9nLCBhdy1jb25maXJtYXRpb24gb3IgYXctb3ZlcmxheVxuICogICAyLiAgb3IgdGhlIE1vZGFsU2VydmljZSAgc2VydmljZS5vcGVuKDxPdmVybGF5Q29tcG9uZW50PiksIHNlcnZpY2UuY2xvc2UoKVxuICpcbiAqIFVzYWdlOlxuICogICAgMS4gIFVzaW5nIE1vZGFsU2VydmljZSBkaXJlY3RseSB0byBkaXNwbGF5IGEgbW9kYWwgcG9wdXAuIFRoZSB1c2FnZSBpcyBhIGxpdHRsZSB0cmlja3lcbiAqICAgICAgICBiZWNhdXNlIGFuZ3VsYXIgY3VycmVudGx5IGRvZXNuJ3Qgc3VwcG9ydCBkeW5hbWljIGNvbnRlbnQgcHJvamVjdGlvbi5cbiAqXG4gKiAgICAgICAgICBsZXQgb3ZlcmxheSA9IHRoaXMubW9kYWxTZXJ2aWNlLm9wZW48T3ZlcmxheUNvbXBvbmVudD4oT3ZlcmxheUNvbXBvbmVudCwge30pO1xuICpcbiAqICAgICAgICAgICAgLy8gQWRkIGNvbnRlbnQuIFRoZXJlJ3Mgbm90IHN1cHBvcnQgZm9yIGR5bmFtaWMgY29udGVudCBwcm9qZWN0aW9uIHlldC5cbiAqICAgICAgICAgICAgLy8gU28gaGF2ZSBhZGQgY29udGVudCBkaXJlY3RseS5cbiAqICAgICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBub3QgdGhlIGJlc3Qgd2F5LlxuICogICAgICAgICAgb3ZlcmxheS5pbnN0YW5jZS5vdmVybGF5LmVsLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi51aS1vdmVybGF5cGFuZWwtY29udGVudFwiKVxuICogICAgICAgICAgICAgICAuaW5uZXJIVE1MID0gYDxpbWcgc3R5bGU9J3dpZHRoOjMwMHB4Oycgc3JjPVwic2FsZXMucG5nXCIgYWx0PVwiU2FsZXMgQ2hhcnRcIiAvPmA7XG4gKlxuICogICAgICAgICAgLy8gZGVsYXkgdGhlIG9wZW5pbmcgYWZ0ZXIgbmcgbGlmZWN5Y2xlIGhhcyBiZWVuIGluaXRpYWxpemVkLlxuICogICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IG92ZXJsYXkuaW5zdGFuY2Uub3BlbihldmVudCk7IH0sIDEpO1xuICpcbiAqXG4gKiAgIDIuICAgVXNlIHRoZSBjb21wb25lbnQgaW5zaWRlIHlvdXIgdGVtcGxhdGUuXG4gKlxuICogICAgICAgICAgQENvbXBvbmVudCh7XG4gKiAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2F3LXBhZ2UnICxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YXctb3ZlcmxheSAjb3ZlcmxheSAob25PcGVuKT1cIm92ZXJsYXlBY3Rpb249J29wZW4nXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob25DbG9zZSk9XCJvdmVybGF5QWN0aW9uPSdjbG9zZSdcIj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz1cInNhbGVzLnBuZ1wiIGFsdD1cIkNoYXJ0XCIvPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctb3ZlcmxheT5cbiAqXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGF3LWJ1dHRvbiBbc2l6ZV09XCInc21hbGwnXCIgKGNsaWNrKT1cIm92ZXJsYXkub3BlbigkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9wZW4gT3ZlcmxheVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYXctYnV0dG9uPlxuICogICAgICAgICAgICAgICAgICBgXG4gKiAgICAgICAgIGV4cG9ydCBjbGFzcyBNeVBhZ2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheUFjdGlvbjogc3RyaW5nO1xuICpcbiAqICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0b3IocHJpdmF0ZSBtb2RhbFNlcnZpY2U6IE1vZGFsU2VydmljZSkge1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gKiAgICAgICAgICAgICAgICAgICAgICAgfVxuICogICAgICAgICAgICAgICAgICAgICBuZ09uSW5pdCgpIHsgfVxuICogICAgICAgfVxuICpcbiAqXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYXctb3ZlcmxheScsXG4gICAgdGVtcGxhdGU6IGA8cC1vdmVybGF5UGFuZWwgW2Rpc21pc3NhYmxlXT1cImRpc21pc3NhYmxlXCIgW3Nob3dDbG9zZUljb25dPVwic2hvd0Nsb3NlSWNvblwiXG4gICAgICAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwic3R5bGVDbGFzc1wiIFthcHBlbmRUb109XCJhcHBlbmRUb1wiXG4gICAgICAgICAgICAgICAgKG9uQWZ0ZXJIaWRlKT1cIm9uQ2xvc2VkKCRldmVudClcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L3Atb3ZlcmxheVBhbmVsPlxuYCxcbiAgICBzdHlsZXM6IFtgOjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWx7Ym9yZGVyOjFweCBzb2xpZCAjZDdkN2Q3O2JveC1zaGFkb3c6MCAycHggNHB4IDAgcmdiYSgwLDAsMCwuMil9OjpuZy1kZWVwIC51aS1vdmVybGF5cGFuZWwtY29udGVudHtwYWRkaW5nOjJlbSAzLjRlbSAuNmVtIDEuNDNlbX06Om5nLWRlZXAgLnVpLW92ZXJsYXlwYW5lbC1jbG9zZXtib3JkZXItcmFkaXVzOjA7dG9wOi41ZW07cmlnaHQ6LjVlbX06Om5nLWRlZXAgLnVpLW92ZXJsYXlwYW5lbC1jbG9zZS51aS1zdGF0ZS1kZWZhdWx0e2JvcmRlcjpub25lfWBdXG59KVxuZXhwb3J0IGNsYXNzIE92ZXJsYXlDb21wb25lbnQgZXh0ZW5kcyBNb2RhbENvbnRhaW5lciBpbXBsZW1lbnRzIE9uSW5pdFxue1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgaGlkZSBvdmVybGF5IHdoZW4gb3V0c2lkZSBpcyBjbGlja2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZGlzbWlzc2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogZGlzcGxheXMgdGhlIGNsb3NlIGljb24gJ3gnIGF0IHRvcCBvZiByaWdodCBjb3JuZXIuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93Q2xvc2VJY29uOiBib29sZWFuID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGFyZ2V0IGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBvdmVybGF5LiBcImJvZHlcIiBvciBsb2NhbCBuZy10ZW1wbGF0ZSB2YXJpYWJsZSBhcmUgdmFsaWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBhcHBlbmRUbzogYW55O1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiBvdmVybGF5IGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsb3NlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIG92ZXJsYXkgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG9uT3BlbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW50ZXJuYWwgb3ZlcmxheSBwYW5lbC5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKE92ZXJsYXlQYW5lbClcbiAgICBvdmVybGF5OiBPdmVybGF5UGFuZWw7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZW52OiBFbnZpcm9ubWVudClcbiAgICB7XG4gICAgICAgIHN1cGVyKGVudik7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKVxuICAgIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIE92ZXJsYXlcbiAgICAgKiBAcGFyYW0gZXZlbnRcbiAgICAgKi9cbiAgICBvcGVuKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm92ZXJsYXkuc2hvdyhldmVudCk7XG4gICAgICAgIHRoaXMub25PcGVuZWQobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgT3ZlcmxheVxuICAgICAqL1xuICAgIGNsb3NlKClcbiAgICB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5oaWRlKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiB0b2dnbGUgb3BlbiBhbmQgY2xvc2UuXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICovXG4gICAgdG9nZ2xlKGV2ZW50OiBhbnkpXG4gICAge1xuICAgICAgICB0aGlzLm92ZXJsYXkudG9nZ2xlKGV2ZW50KTtcbiAgICB9XG5cblxuICAgIG9uT3BlbmVkKGV2ZW50OiBhbnkpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLm9uT3Blbi5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBvbkNsb3NlZChldmVudDogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5vbkNsb3NlLmVtaXQoZXZlbnQpO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdDaGVja2VkLFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7YXNzZXJ0LCBFbnZpcm9ubWVudCwgaXNQcmVzZW50fSBmcm9tICdAYXJpYmF1aS9jb3JlJztcbmltcG9ydCB7QmFzZUNvbXBvbmVudH0gZnJvbSAnLi4vLi4vY29yZS9iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQge092ZXJsYXlDb21wb25lbnR9IGZyb20gJy4uL292ZXJsYXkvb3ZlcmxheS5jb21wb25lbnQnO1xuXG5cbi8qKlxuICogRGVmaW5lcyB3aGVyZSB0aGUgQ2FyZCBpcyBwb3NpdGlvbmVkLiBJdCBjYW4gYmUgZWl0aGVyOlxuICogICAgLSBhYm92ZSB0aGUgdHJpZ2dlcmluZyBsaW5rXG4gKiAgICAtIHVuZGVyIHRoZSB0cmlnZ2VyaW5nIGxpbmtcbiAqICAgIC0gY29tcGxldGVseSBvbiB0b3Agb2YgaXQgLSBjb3ZlcmluZyBpdC4gRm9yIHRoaXMgY2FzZSB0aGVyZSBpcyBub25lIGFzIG5vIHN0eWxlIGlzIGFwcGxpZWRcbiAqL1xuZXhwb3J0IGVudW0gSENDYXJkUG9zaXRpb24ge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbm9uZVxufVxuXG4vKipcbiAqIERlZmluZXMgd2hlcmUgdGhlIENhcmQgaXMgcG9zaXRpb25lZCBieSBkZWZhdWx0LiBNZWFuaW5nIHdoZXJlIHByaW1lTkcgY29kZSBwdXQgaXQuXG4gKlxuICogV2hlbiB0aGVyZSBpcyBhbGxvdCBvZiBzcGFjZSBvbiB0aGUgc2lkZXMgPj0gIChMZWZ0IG9yIFJpZ2h0KSBpcyB1c2VkXG4gKiAocGFkZGVkTGVmdCwgcGFkZGVkUmlnaHQpIG90aGVyd2lzZS4gV2hlbiB0aGVyZSBpcyBub3QgbXVjaCBzcGFjZSBhbmQgY2FyZCBjb250YWluZXJcbiAqICBpcyBub3QgYWxpZ25lZCAobGVmdCwgcmlnaHQpIHdpdGggdGhlIHRyaWdlcmluZyBpY29uIGJ1dCBpdCBpcyBzaGlmdGVkIHRvIGZpdCBpbnRvIHRoZSBzY3JlZW5cbiAqL1xuZW51bSBIQ0NhcmRBbGlnbm1lbnQge1xuICAgIGxlZnQsXG4gICAgcGFkZGVkTGVmdCxcbiAgICByaWdodCxcbiAgICBwYWRkZWRSaWdodCxcbiAgICBkZWZhdWx0XG59XG5cbi8qKlxuICogTWFwcyBwb3NpdGlvbiB0byBzdHlsZXMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgQ2FyZCBjb250YWluZXIuIFRoaXMgaXMganVzdCB0byBtYWtlIGl0IGVhc2llclxuICogYXMgd2UgYXJlIHdvcmtpbmcgd2l0aCBlbnVtZXJhdGlvbnMgYW5kIGhhdmUgYWxyZWFkeSBlbnVtIHR5cGUuXG4gKlxuICogdS1oYy1hcnJvdy1iOiBBcnJvdyB3aWxsIGFwcGVhciBhdCB0aGUgYm90dG9tXG4gKiB1LWhjLWFycm93LXQ6IEFycm93IHdpbGwgYXBwZWFyIGF0IHRoZSB0b3BcbiAqXG4gKiB1LWhjLXNoYWRvdy10OiBCb3JkZXIgc2hhZG93IHdpbGwgYXBwZWFyIGF0IHRoZSB0b3BcbiAqIHUtaGMtc2hhZG93LWI6IEJvcmRlciBzaGFkb3cgd2lsbCBhcHBlYXIgYXQgdGhlIGJvdHRvbVxuICovXG5jb25zdCBQb3NpdGlvblRvU3R5bGUgPSB7XG4gICAgdG9wOiAnIHctaGMtcGFuZWwtYXJyb3cgdS1oYy1hcnJvdy1iIHUtaGMtc2hhZG93LXQnLFxuICAgIGJvdHRvbTogJyB3LWhjLXBhbmVsLWFycm93IHUtaGMtYXJyb3ctdCB1LWhjLXNoYWRvdy1iJyxcbiAgICBub25lOiAnJ1xufTtcblxuXG4vKipcbiAqXG4gKiBNYXBzIGFsaWduZWQgQ2FyZCBjb250YWluZXIgdG8gY3VzdG9tIHN0eWxlcyBpbiBvcmRlciB0byBhcHBseSBjb3JyZWN0IGFycm93XG4gKlxuICogLWxsOiBTdGFuZHMgZm9yIExhcmdlIExlZnQgKGxhcmdlOiB0aGVyZSBpcyBwbGVudHkgb2Ygc3BhY2UgYXJvdW5kIClcbiAqIC1scjogU3RhbmRzIGZvciBMYXJnZSByaWdodFxuICogLXNsOiBTdGFuZHMgZm9yIFNtYWxsIGxlZnQgKFNtYWxsIGFuZCByZXNpemVkIHNjcmVlbiB3aGVyZSB3ZSB0cnkgdG8gZml0IGNhcmQgY29udGFpbmVyXG4gKiBzb21ld2hlcmUgaW4gYmV0d2VlbilcbiAqIC1zcjogU3RhbmRzIGZvciBMYXJnZSByaWdodFxuICpcbiAqL1xuY29uc3QgQWxpZ25tZW50VG9TdHlsZSA9IHtcbiAgICBsZWZ0OiAnIHUtaGMtYXJyb3ctbGwnLFxuICAgIHJpZ2h0OiAnIHUtaGMtYXJyb3ctbHInLFxuICAgIHBhZGRlZExlZnQ6ICcgdS1oYy1hcnJvdy1zbCcsXG4gICAgcGFkZGVkUmlnaHQ6ICcgdS1oYy1hcnJvdy1zcicsXG4gICAgZGVmYXVsdDogJyB1LWhjLWFycm93LWxsJyxcbn07XG5cbi8qKlxuICogVGhlIEhvdmVyQ2FyZCBjb21wb25lbnRzIGFkZHMgaG92ZXIgYmVoYXZpb3IgdG8gdGV4dCwgdGhlIHNwZWNpZmllZCBjb250ZW50IGlzIGxvYWRlZFxuICogb24gdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgZWxlbWVudC5cbiAqXG4gKiBUb2RvOiBleHRlbmRzIHNvIHdlIGNhbiB3cmFwIGFueSBlbGVtZW50IGFuZCBhbnkgZWxlbWVudCBjYW4gYmUgdHJpZ2dlcmluZyB0aGlzLiBOb3Qgb25seVxuICogbGlua1RpdGxlXG4gKlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIGBgYFxuICpcbiAqICAgPGF3LWhvdmVyLWNhcmQgW2xpbmtUaXRsZV09XCInRnJhbmsga29sYXInXCI+XG4gKiAgICAgICA8aDM+TXkgQ2FyZCBUaXRsZTwvaDM+XG4gKiAgICAgICA8ZGl2PlxuICpcbiAqICAgICAgICAgICBUaGlzIGlzIG15IGNvbnRlbnRzXG4gKlxuICogICAgICAgPC9kaXY+XG4gKlxuICpcbiAqICAgIDwvYXctaG92ZXItY2FyZD5cbiAqIGBgYFxuICpcbiAqIEJ5IGRlZmF1bHQgdGhlcmUgaXMgW2ZvcmNlQ2xvc2VdPXRydWUgd2hpY2ggZm9yY2VzIHRoZSB1c2VyIHRvIHVzZSBYIGNsb3NlIGljb25cbiAqXG4gKlxuICpcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhdy1ob3Zlci1jYXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxzcGFuIGNsYXNzPVwidy1oY1wiPlxuICAgIDxzcGFuIGNsYXNzPVwidy1oYy10aXRsZVwiPlxuICAgICAgICA8YXctc3RyaW5nIFt2YWx1ZV09XCJsaW5rVGl0bGVcIj48L2F3LXN0cmluZz5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJzYXAtaWNvbiBpY29uLXNsaW0tYXJyb3ctZG93blwiIChtb3VzZW92ZXIpPVwib3BlbkNhcmQoJGV2ZW50KVwiPjwvc3Bhbj5cbiAgICA8L3NwYW4+XG5cbiAgICA8ZGl2IGNsYXNzPVwidy1oYy1ib2R5XCI+XG5cbiAgICAgICAgIDxhdy1vdmVybGF5ICNvdmVybGF5IFtzaG93Q2xvc2VJY29uXT1cImZvcmNlQ2xvc2VcIiBbZGlzbWlzc2FibGVdPVwiIWZvcmNlQ2xvc2VcIlxuICAgICAgICAgICAgICAgICAgICAgW3N0eWxlQ2xhc3NdPVwiYXJyb3dDbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgICBbYXBwZW5kVG9dPVwiYXBwZW5kVG9cIlxuICAgICAgICAgICAgICAgICAgICAgKG9uT3Blbik9XCJjYXJkT3BlbmVkKCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgKG9uQ2xvc2UpPVwiY2FyZENsb3NlZCgkZXZlbnQpXCI+XG5cbiAgICAgICAgPCEtLSB0aGlzIGlzIHdvcmthcm91bmQgdG8gY3JlYXRlIGEgX25nY29udGVudC1JTkRFWCByZWZlcmVuY2Ugc28gd2UgY2FuXG4gICAgICAgIHJlZmVyIHRvIHRoaXMgbmctY29udGVudC4gQW5ndWxhciBkb2VzIG5vdCBoYXZlIGFueSB3YXkgcmlnaHQgbm93IHRvIHRyYWNrIHRoaXNcbiAgICAgICAgLS0+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwidS1uZ2NvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8L3NwYW4+XG5cbiAgICA8L2F3LW92ZXJsYXk+XG5cbiAgICA8L2Rpdj5cbjwvc3Bhbj5cblxuXG48IS0tPG5nLXRlbXBsYXRlICNjb250ZW50VG9Cb2R5Pi0tPlxuICAgIDwhLS08YXctb3ZlcmxheSAjb3ZlcmxheSBbc2hvd0Nsb3NlSWNvbl09XCJmb3JjZUNsb3NlXCIgW2Rpc21pc3NhYmxlXT1cIiFmb3JjZUNsb3NlXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tW3N0eWxlQ2xhc3NdPVwiYXJyb3dDbGFzc1wiLS0+XG4gICAgICAgICAgICAgICAgPCEtLVthcHBlbmRUb109XCJhcHBlbmRUb1wiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbk9wZW4pPVwiY2FyZE9wZW5lZCgkZXZlbnQpXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tKG9uQ2xvc2UpPVwiY2FyZENsb3NlZCgkZXZlbnQpXCI+LS0+XG5cbiAgICAgICAgPCEtLSZsdDshJm5kYXNoOyB0aGlzIGlzIHdvcmthcm91bmQgdG8gY3JlYXRlIGEgX25nY29udGVudC1JTkRFWCByZWZlcmVuY2Ugc28gd2UgY2FuLS0+XG4gICAgICAgIDwhLS1yZWZlciB0byB0aGlzIG5nLWNvbnRlbnQuIEFuZ3VsYXIgZG9lcyBub3QgaGF2ZSBhbnkgd2F5IHJpZ2h0IG5vdyB0byB0cmFjayB0aGlzLS0+XG4gICAgICAgIDwhLS0mbmRhc2g7Jmd0Oy0tPlxuICAgICAgICA8IS0tPHNwYW4gY2xhc3M9XCJ1LW5nY29udGVudFwiPi0tPlxuICAgICAgICAgICAgICAgIDwhLS08bmctY29udGVudD48L25nLWNvbnRlbnQ+LS0+XG4gICAgICAgICAgICA8IS0tPC9zcGFuPi0tPlxuXG4gICAgPCEtLTwvYXctb3ZlcmxheT4tLT5cblxuPCEtLTwvbmctdGVtcGxhdGU+LS0+XG5cblxuPCEtLTxuZy10ZW1wbGF0ZSAjY29udGVudFRvT3ZlcmxheT4tLT5cblxuICAgIDwhLS08YXctb3ZlcmxheSAjb3ZlcmxheSBbc2hvd0Nsb3NlSWNvbl09XCJmb3JjZUNsb3NlXCIgW2Rpc21pc3NhYmxlXT1cIiFmb3JjZUNsb3NlXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tW3N0eWxlQ2xhc3NdPVwiYXJyb3dDbGFzc1wiLS0+XG4gICAgICAgICAgICAgICAgPCEtLShvbk9wZW4pPVwiY2FyZE9wZW5lZCgkZXZlbnQpXCItLT5cbiAgICAgICAgICAgICAgICA8IS0tKG9uQ2xvc2UpPVwiY2FyZENsb3NlZCgkZXZlbnQpXCI+LS0+XG5cbiAgICAgICAgPCEtLSZsdDshJm5kYXNoOyB0aGlzIGlzIHdvcmthcm91bmQgdG8gY3JlYXRlIGEgX25nY29udGVudC1JTkRFWCByZWZlcmVuY2Ugc28gd2UgY2FuLS0+XG4gICAgICAgIDwhLS1yZWZlciB0byB0aGlzIG5nLWNvbnRlbnQuIEFuZ3VsYXIgZG9lcyBub3QgaGF2ZSBhbnkgd2F5IHJpZ2h0IG5vdyB0byB0cmFjayB0aGlzLS0+XG4gICAgICAgIDwhLS0mbmRhc2g7Jmd0Oy0tPlxuICAgICAgICA8IS0tPHNwYW4gY2xhc3M9XCJ1LW5nY29udGVudFwiPi0tPlxuICAgICAgICAgICAgICAgIDwhLS08bmctY29udGVudD48L25nLWNvbnRlbnQ+LS0+XG4gICAgICAgICAgICA8IS0tPC9zcGFuPi0tPlxuXG4gICAgPCEtLTwvYXctb3ZlcmxheT4tLT5cbjwhLS08L25nLXRlbXBsYXRlPi0tPlxuXG5cbmAsXG4gICAgc3R5bGVzOiBbYC53LWhjLXRpdGxle3BhZGRpbmctcmlnaHQ6MS40ZW07cG9zaXRpb246cmVsYXRpdmU7d2hpdGUtc3BhY2U6bm93cmFwfS53LWhjLXRpdGxlIC5zYXAtaWNvbntmb250LXNpemU6MWVtO2NvbG9yOiMwMDY3OWU7cG9zaXRpb246YWJzb2x1dGU7cGFkZGluZy10b3A6LjJlbTtyaWdodDowfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdy51LWhjLXNoYWRvdy1ie2JveC1zaGFkb3c6MCAycHggNHB4IDAgcmdiYSgwLDAsMCwuMil9OjpuZy1kZWVwIC53LWhjLXBhbmVsLWFycm93LnUtaGMtc2hhZG93LXR7Ym94LXNoYWRvdzowIC0ycHggNHB4IDAgcmdiYSgwLDAsMCwuMil9OjpuZy1kZWVwIC53LWhjLXBhbmVsLWFycm93OmFmdGVyLDo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdzpiZWZvcmV7bGVmdDoyNSU7Ym9yZGVyOnNvbGlkIHRyYW5zcGFyZW50O2NvbnRlbnQ6XCIgXCI7aGVpZ2h0OjA7d2lkdGg6MDtwb3NpdGlvbjphYnNvbHV0ZTtwb2ludGVyLWV2ZW50czpub25lfTo6bmctZGVlcCAudy1oYy1wYW5lbC1hcnJvdzphZnRlcntib3JkZXItY29sb3I6cmdiYSgxMzYsMTgzLDIxMywwKTtib3JkZXItd2lkdGg6LjdlbTttYXJnaW4tbGVmdDotLjdlbX06Om5nLWRlZXAgLnctaGMtcGFuZWwtYXJyb3c6YmVmb3Jle2JvcmRlci1jb2xvcjpyZ2JhKDI1NSwxMzYsNTYsMCk7Ym9yZGVyLXdpZHRoOi44ZW07bWFyZ2luLWxlZnQ6LS44ZW19OjpuZy1kZWVwIC51LWhjLWFycm93LWxsOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1sbDpiZWZvcmV7bGVmdDoyNSV9OjpuZy1kZWVwIC51LWhjLWFycm93LWxyOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1scjpiZWZvcmV7bGVmdDo3NSV9OjpuZy1kZWVwIC51LWhjLWFycm93LXNsOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1zbDpiZWZvcmV7bGVmdDoxMCV9OjpuZy1kZWVwIC51LWhjLWFycm93LXNyOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1zcjpiZWZvcmV7bGVmdDo5MCV9OjpuZy1kZWVwIC51LWhjLWFycm93LXQ6YWZ0ZXIsOjpuZy1kZWVwIC51LWhjLWFycm93LXQ6YmVmb3Jle2JvdHRvbToxMDAlfTo6bmctZGVlcCAudS1oYy1hcnJvdy10OmFmdGVye2JvcmRlci1ib3R0b20tY29sb3I6I2ZmZn06Om5nLWRlZXAgLnUtaGMtYXJyb3ctdDpiZWZvcmV7Ym9yZGVyLWJvdHRvbS1jb2xvcjojZDdkN2Q3fTo6bmctZGVlcCAudS1oYy1hcnJvdy1iOmFmdGVyLDo6bmctZGVlcCAudS1oYy1hcnJvdy1iOmJlZm9yZXt0b3A6MTAwJX06Om5nLWRlZXAgLnUtaGMtYXJyb3ctYjphZnRlcntib3JkZXItdG9wLWNvbG9yOiNmZmZ9OjpuZy1kZWVwIC51LWhjLWFycm93LWI6YmVmb3Jle2JvcmRlci10b3AtY29sb3I6I2Q3ZDdkN31gXVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckNhcmRDb21wb25lbnQgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3Q2hlY2tlZCB7XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHBhZGRpbmcgcmVwcmVzZW50aW5nIGEgaGVpZ2h0IG9mIHRoZSBBcnJvdyBmb3Igd2hpY2ggd2UgbmVlZCB0byB2ZXJ0aWNhbGx5IGFkanVzdFxuICAgICAqIENhcmQgY29udGFpbmVyXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IEFycm93UGFkID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHNhZmUgdGhyZXNob2xkIHdoZXJlIHRoZXJlIG1pZ2h0IG5vdCBiZSBlbm91Z2ggc3BhY2UgYXJvdW5kIG9yIENhcmQgaXMgYWxpZ25lZCB3aXRoXG4gICAgICogdGhlIGxlZnQgb3IgcmlnaHQgZWRnZSBvZiB0aGUgdmlld3BvcnQgZm9yIHdoaWNoIHdlIG5lZWQgdG8gcG9zaXRpb24gdGhlIEFycm93IGNsb3NlciB0byB0aGVcbiAgICAgKiBzaWRlIG9mIHRoZSBjYXJkXG4gICAgICpcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFNwYWNpbmdMaW1pdCA9IDUwO1xuXG5cbiAgICBASW5wdXQoKVxuICAgIGxpbmtUaXRsZTogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIHdlIGtlZXAgdGhlIGhvdmVyIGNhcmQgb3BlbiBhbmQgZm9yY2UgdXNlciB0byBtYW51YWxseSBjbG9zZVxuICAgICAqXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBmb3JjZUNsb3NlOiBib29sZWFuID0gdHJ1ZTtcblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBUaGlzIGN1cnJlbnQgd29ya2Fyb3VuZCB1bnRpbCB3ZSBmaW5kIGJldHRlciBzb2x1dGlvbi4gUHJpbWVORyBvdmVybGF5cyBvcGVyYXRlcyB3aXRoaW5cbiAgICAgKiBpdHMgcmVsYXRpdmUgZWxlbWVudCBzbyBpZiB0aGUgb3ZlcmxheSBpcyB3cmFwcGVkIGluc2lkZSBzb21lIG90aGVyIHJlbGF0aXZlIGNvbnRhaW5lclxuICAgICAqIHRoZSBvdmVybGF5IGNvbnRlbnQgaXMgY3JvcGVkIGJ5IGl0cyBwYXJlbnQgYW5kIGNvbnRlbnQgaXMgbm90IHZpc2libGUuXG4gICAgICpcbiAgICAgKiBUaGV5IGhhdmUgW2FwcGVuZFRvXSBiaW5kaW5nIHdoaWNoIHdlIG5lZWQgdG8gdXNlIGZvciB0aGlzIHB1cnBvc2VcbiAgICAgKlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgYXBwZW5kQ29udGVudFRvQm9keTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gT3ZlcmxheUNvbXBvbmVudCB0byBjYW4gYWNjZXNzIFByaW1lTkcgY29tcG9uZW50IGFzIHdlbGxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdvdmVybGF5JylcbiAgICBhd092ZXJsYXk6IE92ZXJsYXlDb21wb25lbnQ7XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogSW50ZXJuYWwgc3R5bGUgY2xhc3MgdG8gdXNlIHRvIGFwcGx5IGFkZGl0aW9uYWwgc3R5bGVzIHdoZW4gaXQgbmVlZHMgdG8gc2hvdyBhIEFycm93IG9uIHRoZVxuICAgICAqIGNhcmRcbiAgICAgKlxuICAgICAqL1xuICAgIGFycm93Q2xhc3M6IHN0cmluZyA9ICcnO1xuXG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBwcm9wZXJ0aWVzIHRvIHJlZmVyZW5jZXMgdGVtcGxhdGUgZWxlbWVudHMgaW4gb3JkZXIgdG8gY2FsY3VsYXRlIHBvc2l0aW9uaW5nXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIHRpdGxlQXJlYVJlY3Q6IGFueTtcbiAgICB0cmlnUmVjdDogYW55O1xuICAgIHRyaWdJY29uTWlkZGxlOiBhbnk7XG5cbiAgICBvcGVuaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBhcHBlbmRUbzogJ2JvZHknO1xuXG4gICAgY3VycnJlbnRQb3NpdGlvbjogSENDYXJkUG9zaXRpb24gPSBIQ0NhcmRQb3NpdGlvbi5ub25lO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZWxlbTogRWxlbWVudFJlZiwgcHVibGljIGVudjogRW52aXJvbm1lbnQsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgc3VwZXIoZW52KTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcblxuICAgICAgICBhc3NlcnQoaXNQcmVzZW50KHRoaXMubGlua1RpdGxlKSwgJ1lvdSBtdXN0IHByb3ZpZGUgW2xpbmtUaXRsZV0gYmluZGluZyAhJyk7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZXJlIGlzIG9wZW4gSEMgd2hlbiB3ZSBzdGFydCBuZXcgY29tcG9uZW50XG4gICAgICAgIHRoaXMuZW52LmRlbGV0ZVZhbHVlKCdoYy1vcGVuJyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmFwcGVuZENvbnRlbnRUb0JvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG8gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBBcyBvZiBBbmd1bGFyIDUgd2UgaGF2ZSB0byBpbnRyb2R1Y2UgdGhpcyBWaWV3Q2hlY2tlZCBhcyBQcmltZU5HIGRvZXMgZmluYWwgY2FsY3VsYXRpb25cbiAgICAgKiBkdXJpbmcgdGhpcyBwaGFzZS5cbiAgICAgKlxuICAgICAqIFNvIG5vdyBpdHMgYnJva2VuIGRvd24gaW50byB0d28gcGFydHM6XG4gICAgICogICAtIEFwcGx5IGNsYXNzIHN0eWxlc1xuICAgICAqICAgLSBQb3NpdGlvbiBpdC5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm9wZW5pbmcpIHtcbiAgICAgICAgICAgIGxldCBjb250YWluZXIgPSB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmNvbnRhaW5lcjtcblxuICAgICAgICAgICAgbGV0IGNudFJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJycmVudFBvc2l0aW9uICE9PSBIQ0NhcmRQb3NpdGlvbi5ub25lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGp1c3RDYXJkKGNvbnRhaW5lciwgY250UmVjdCwgdGhpcy5hd092ZXJsYXkub3ZlcmxheSk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcnJvd0NsYXNzID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub3BlbmluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0IGVsZW1lbnRzIEJvdW5kaW5nQ2xpZW50UmVjdCB0aGF0IHdlIHVzZSBmb3IgY2FsY3VsYXRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIGluaXRFbGVtZW50cygpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRpdGxlRWxlbSA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy53LWhjLXRpdGxlJyk7XG4gICAgICAgIGxldCB0cmlnZ2VyRWxlbSA9IHRoaXMuZWxlbS5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zYXAtaWNvbicpO1xuICAgICAgICB0aGlzLnRpdGxlQXJlYVJlY3QgPSB0aXRsZUVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMudHJpZ1JlY3QgPSB0cmlnZ2VyRWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy50cmlnSWNvbk1pZGRsZSA9IHRoaXMudHJpZ1JlY3Qud2lkdGggLyAyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGaXJlcyB3aGVuIHVzZXIgbW91c2Ugb3ZlciB0aGUgdHJpZ2dlcmluZyBpY29uIGFuZCBvcGVucyB1cCBvdmVybGF5IGNvbXBvbmVudC4gVG8gbWFrZSBzdXJlXG4gICAgICogb25seSBvbmUgQ2FyZCBpcyBvcGVuZWQgYXQgdGhlIHRpbWUgaXQgdXNlcyBFbnZpcm9ubWVudCB0byBzYXZlIGV4dHJhIGluZm9ybWF0aW9uIGZvciBpdFxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuQ2FyZChldmVudDogYW55KTogYW55IHtcbiAgICAgICAgaWYgKGlzUHJlc2VudCh0aGlzLmF3T3ZlcmxheSkgJiYgIXRoaXMuZW52Lmhhc1ZhbHVlKCdoYy1vcGVuJykpIHtcbiAgICAgICAgICAgIHRoaXMuYXdPdmVybGF5Lm9wZW4oZXZlbnQpO1xuXG4gICAgICAgICAgICB0aGlzLmVudi5zZXRWYWx1ZSgnaGMtb3BlbicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEZpcmVkIGF0IHRoZSBlbmQgb2YgdGhlIG9wZW5pbmcgY3ljbGUgd2hlbiBhbGwgaXMgaW5pdGlhbGl6ZWQgYW5kIHRoZSBjYXJkIGlzIGFib3V0IHRvXG4gICAgICogZmFkZSBpbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGZpcnN0IHNpbXVsYXRlcyBkaXNwbGF5aW5nIGNhcmQgYnkgc2V0dGluZyBkaXNwbGF5OmJsb2NrIGFuZFxuICAgICAqIGRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbiBzbyB3ZSBjYW4gcmVhZCBkaW1lbnNpb25zIGFuZCB0aGVuIGxhdGVyIG9uIHBvc2l0aW9uIHRoZSBjYXJkXG4gICAgICogYWNjb3JkaW5nbHkuXG4gICAgICpcbiAgICAgKi9cbiAgICBjYXJkT3BlbmVkKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMuYXdPdmVybGF5Lm92ZXJsYXkuY29udGFpbmVyO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5hd092ZXJsYXkub3ZlcmxheS50YXJnZXQ7XG4gICAgICAgIHRoaXMub3BlbkZvckFkanVzdG1lbnRzKGNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gcHJlLXJ1biBwb3NpdGlvbmluZyBzbyB3ZSBjYW4gY2FsY3VsYXRlIG5ldyBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLmF3T3ZlcmxheS5vdmVybGF5LmRvbUhhbmRsZXIuYWJzb2x1dGVQb3NpdGlvbihjb250YWluZXIsIHRhcmdldCk7XG4gICAgICAgIGxldCBjbnRSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmN1cnJyZW50UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uRm9yQ2FyZChjb250YWluZXIsIGNudFJlY3QpO1xuXG4gICAgICAgIHRoaXMuYXBwbHlTdHlsZUNsYXNzKGNvbnRhaW5lciwgY250UmVjdCwgdGhpcy5hd092ZXJsYXkub3ZlcmxheSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZUZvckFkanVzdG1lbnRzKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMub3BlbmluZyA9IHRydWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFdoZW4gY2FyZCBpcyBjbG9zZWQgd2UgbmVlZCB0byByZWxlYXNlIGl0IGFuZCBkZWxldGUgYWxsIHRoZSByZWZlcmVuY2VzIGZyb20gRW52aXJvbm1lbnRcbiAgICAgKlxuICAgICAqXG4gICAgICovXG4gICAgY2FyZENsb3NlZChldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZW52LmRlbGV0ZVZhbHVlKCdoYy1vcGVuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBcHBsaWVzIHN0eWxlLlRPUCBhbmQgc3R5bGUuTEVGVCB0byB0aGUgY29udGFpbmVyIGluIG9yZGVyIHRvIHJlcG9zaXRpb24gaXQgYW5kIGFkZFxuICAgICAqIGV4dHJhIGFycm93LlxuICAgICAqXG4gICAgICogRmlyc3QgYmFzZWQgb24gdGhlIGluaXRpYWwgcG9zaXRpb24gd2UgYXBwbHkgc3R5bGUuVE9QIGFuZCBkZXBlbmRpbmcgaWYgaXRzIG9uIHRoZVxuICAgICAqIHRvcCBvciBib3R0b20gd2UgYXBwbHkgZWl0aGVyIC1Ib3ZlckNhcmRDb21wb25lbnQuQXJyb3dQYWQgb3IgK0hvdmVyQ2FyZENvbXBvbmVudC5BcnJvd1BhZC5cbiAgICAgKlxuICAgICAqIFRoZW4gZm9yIHBvc2l0aW9uaW5nIGhvcml6b250YWxseSB3ZSB1c2UgdHdvIHR5cGVzLlxuICAgICAqICAtIFdoZW4gdGhlcmUgaXMgYWxsb3Qgb2Ygc3BhY2UgdGhlIGFycm93IGlzIDI1JSBmcm9tIHRoZSBlZGdlXG4gICAgICpcbiAgICAgKiAgICAtLS0tLV4tLS0tLS0tLS0tLS0gICBvciAgICAgICAtLS0tLS0tLS0tLV4tLS0tXG4gICAgICpcbiAgICAgKlxuICAgICAqICAtIFdoZW4gdGhlcmUgaXMgbGVzcyBvciBub25lIHNwYWNlIHdlIGhhdmUgb25seSAxMCUgZmFyIGF3YXkgZm9ybSB0aGUgZWRnZVxuICAgICAqXG4gICAgICogICAgLS1eLS0tLS0tLS0tLS0tICAgb3IgICAgICAgLS0tLS0tLS0tLS1eLS1cbiAgICAgKlxuICAgICAqICBPbmNlIHdlIHBpY2sgdGhlIGNvcnJlY3QgcG9zaXRpb25pbmcgKDI1JSwgMTAlKSB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGFuZCBzaGlmdCB0aGUgY2FyZFxuICAgICAqICBlaXRoZXIgdG8gdGhlIGxlZnQgb3IgcmlnaHQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhZGp1c3RDYXJkKGNvbnRhaW5lcjogYW55LCBjb250YWluZXJSZWN0OiBhbnksIG1vZGFsQ29udGFpbmVyOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgbGV0IGRpZmYgPSAodGhpcy5jdXJycmVudFBvc2l0aW9uID09PSBIQ0NhcmRQb3NpdGlvbi5ib3R0b20pID8gMSA6IC0xO1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gbW9kYWxDb250YWluZXIuZG9tSGFuZGxlci5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgbGV0IHBvc1dpdGhTY3JvbGwgPSBjb250YWluZXJSZWN0LnRvcCArIHNjcm9sbFRvcDtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IChwb3NXaXRoU2Nyb2xsICsgKEhvdmVyQ2FyZENvbXBvbmVudC5BcnJvd1BhZCAqIGRpZmYpKSArICdweCc7XG5cbiAgICAgICAgbGV0IGFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50Rm9yQ2FyZChjb250YWluZXJSZWN0LCBtb2RhbENvbnRhaW5lcik7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gdGhpcy5jYWxjTGVmdEZvckFsaWdubWVudChjb250YWluZXJSZWN0LCBhbGlnbm1lbnQpICsgJ3B4JztcbiAgICB9XG5cblxuICAgIGFwcGx5U3R5bGVDbGFzcyhjb250YWluZXI6IGFueSwgY29udGFpbmVyUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycnJlbnRQb3NpdGlvbiAhPT0gSENDYXJkUG9zaXRpb24ubm9uZSkge1xuICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9IHRoaXMuYWxpZ25tZW50Rm9yQ2FyZChjb250YWluZXJSZWN0LCBtb2RhbENvbnRhaW5lcik7XG5cbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICg8YW55PlBvc2l0aW9uVG9TdHlsZSlbKDxhbnk+SENDYXJkUG9zaXRpb24pW3RoaXMuY3VycnJlbnRQb3NpdGlvbl1dO1xuICAgICAgICAgICAgdGhpcy5hcnJvd0NsYXNzICs9ICg8YW55PkFsaWdubWVudFRvU3R5bGUpWyg8YW55PkhDQ2FyZEFsaWdubWVudClbYWxpZ25tZW50XV07XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXJyb3dDbGFzcyA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEZXRlY3RzIGlmIHRoZSBjYXJkIGlzIGdvaW5nIHRvIGJlIHNob3duIG9uIHRoZSB0b3Agb2YgdGhlIExpbmsgbGFiZWwgb3IgdW5kZXIuIE9yIGlmXG4gICAgICogaXRzIGNvdmVyaW5nIGl0LlxuICAgICAqXG4gICAgICovXG4gICAgcG9zaXRpb25Gb3JDYXJkKGNvbnRhaW5lcjogYW55LCBib3VuZGluZ1JlY3Q6IGFueSk6IEhDQ2FyZFBvc2l0aW9uIHtcbiAgICAgICAgLy8gc2VjdXJlIHRoaXMgaW4gY2FzZSBvZiBJRSByZXR1cm5pbmcgdW5kZWZpbmVkXG4gICAgICAgIGxldCBib3JkZXJXaWR0aCA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKS5ib3JkZXJXaWR0aDtcbiAgICAgICAgbGV0IGNudFdpZHRoID0gcGFyc2VGbG9hdChib3JkZXJXaWR0aCB8fCAnMCcpO1xuICAgICAgICBsZXQgcG9zID0gSENDYXJkUG9zaXRpb24ubm9uZTtcblxuICAgICAgICBpZiAodGhpcy50cmlnUmVjdC5ib3R0b20gPCBib3VuZGluZ1JlY3QudG9wKSB7XG4gICAgICAgICAgICBwb3MgPSBIQ0NhcmRQb3NpdGlvbi5ib3R0b207XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnUmVjdC50b3AgPiAoYm91bmRpbmdSZWN0LmJvdHRvbSAtIGNudFdpZHRoKSkge1xuICAgICAgICAgICAgcG9zID0gSENDYXJkUG9zaXRpb24udG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogRGV0ZWN0IGhvcml6b250YWwgYWxpZ25tZW50LlxuICAgICAqXG4gICAgICovXG4gICAgcHJpdmF0ZSBhbGlnbm1lbnRGb3JDYXJkKGJvdW5kaW5nUmVjdDogYW55LCBtb2RhbENvbnRhaW5lcjogYW55KTogSENDYXJkQWxpZ25tZW50IHtcbiAgICAgICAgbGV0IGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5sZWZ0O1xuICAgICAgICBsZXQgdmlld1BvcnQgPSBtb2RhbENvbnRhaW5lci5kb21IYW5kbGVyLmdldFZpZXdwb3J0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMudHJpZ1JlY3QubGVmdC50b0ZpeGVkKDApID09PSBib3VuZGluZ1JlY3QubGVmdC50b0ZpeGVkKDApICYmXG4gICAgICAgICAgICBib3VuZGluZ1JlY3QubGVmdCA+IEhvdmVyQ2FyZENvbXBvbmVudC5TcGFjaW5nTGltaXQpIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IEhDQ2FyZEFsaWdubWVudC5sZWZ0O1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYm91bmRpbmdSZWN0LmxlZnQgPCBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkTGVmdDtcblxuICAgICAgICB9IGVsc2UgaWYgKCh2aWV3UG9ydC53aWR0aCAtIGJvdW5kaW5nUmVjdC5yaWdodCkgPCBIb3ZlckNhcmRDb21wb25lbnQuU3BhY2luZ0xpbWl0KSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkUmlnaHQ7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyaWdSZWN0LnJpZ2h0LnRvRml4ZWQoMCkgPT09IGJvdW5kaW5nUmVjdC5yaWdodC50b0ZpeGVkKDApIHx8XG4gICAgICAgICAgICAodmlld1BvcnQud2lkdGggLSBib3VuZGluZ1JlY3QucmlnaHQpID4gSG92ZXJDYXJkQ29tcG9uZW50LlNwYWNpbmdMaW1pdCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gSENDYXJkQWxpZ25tZW50LnJpZ2h0O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGlnbm1lbnQgPSBIQ0NhcmRBbGlnbm1lbnQuZGVmYXVsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxpZ25tZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogVHVybiBvbiB0ZW1wb3JhcnkgZGlzcGxheSB0byBCTE9DSyBzbyB3ZSBjYW4gcmVhZCBkaW1lbnNpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBvcGVuRm9yQWRqdXN0bWVudHMoY29udGFpbmVyOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICAgIHRoaXMuaW5pdEVsZW1lbnRzKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIFR1cm4gb2ZmIGRpc3BsYXkgYmFjayBOT05FXG4gICAgICpcbiAgICAgKi9cbiAgICBjbG9zZUZvckFkanVzdG1lbnRzKGNvbnRhaW5lcjogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAvLyBjb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQ2FsY3VsYXRlcyBwb3NpdGlvbmluZyBmb3Igc3R5bGUuTEVGVC4gQXMgYWxyZWFkeSBzYWlkIHRoZXkgYXJlIHR3byB0eXBlcyBvZiB0cmlhbmdsZXMgdGhhdFxuICAgICAqIGFyZSBhcHBsaWVzIGZvciB0aGVzZSBjYXNlOlxuICAgICAqXG4gICAgICpcbiAgICAgKiBhKSBMYXJnZSBsZWZ0LCBMYXJnZSByaWdodFxuICAgICAqXG4gICAgICogIFByaW1lTkcgYWxpZ25zIHRoZSBjYXJkIHdpdGggZWl0aGVyIHRoZSByaWdodCBzaWRlIG9yIGxlZnQgc2lkZSBvZiB0aGUgdHJpZ2dlcmluZyBpY29uXG4gICAgICpcbiAgICAgKlxuICAgICAqICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZcbiAgICAgKiAgLi4uLi4uXi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLiBvciAgLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi5eLi4uLi4uXG4gICAgICpcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKiAgYikgU21hbGwgbGVmdCAsIHNtYWxsIHJpZ2h0XG4gICAgICpcbiAgICAgKiAgVGhpcyBpcyBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgaXMgbm90IGVub3VnaCBzcGFjZSBhbmQgUHJpbWVORyBwb3NpdGlvbiB0aGUgY2FyZCBvZmYgdG8gdGhlXG4gICAgICogIHRyaWdnZXJpbmcgaWNvbnMsIHNvIGV2ZW4gcHJpbWVOZyBkb2VzIG5vdCBoYXZlIHNwYWNlIHRvIGFsaWduIGl0IHdpdGggdGhlIFZcbiAgICAgKlxuICAgICAqXG4gICAgICogICAgIFYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBWXG4gICAgICogIC4uLi5eLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uIG9yICAuLi4uLi4uLi4uLi4uLi4uLi4uLi4uLl4uLi4uXG4gICAgICpcbiAgICAgKlxuICAgICAqIGMpQWxpZ25lZCB3aXRoIHRoZSBlZGdlIG9mIGJyb3dzZXJcbiAgICAgKlxuICAgICAqIE9uIHRoZSByaWdodCBzaWRlIHRoaXMgaXMgcHJvYmxlbSBhcyB3ZSBjYW5ub3QgY2FsY3VsYXRlIGZ1bGwgZnV0dXJlIHdpZHRoIG9mIHRoZSBjYXJkLlxuICAgICAqIGJ1dCB3ZSBhcHBsbHkgZm9yIHRoaXMgY2FzZSAjYiAoYXJyb3cgMTAlIClcbiAgICAgKlxuICAgICAqXG4gICAgICpcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbGNMZWZ0Rm9yQWxpZ25tZW50KGJvdW5kaW5nUmVjdDogYW55LCBhbGlnbm1lbnQ6IEhDQ2FyZEFsaWdubWVudCk6IG51bWJlciB7XG4gICAgICAgIC8vIHdpZHRoIGZvciB3aGljaCB3ZSBuZWVkIHRvIHNoaWZ0IGNhcmQuIDI1JSBvciAxMCUgb2YgdGhlIGNvbnRhaW5lciB3aWR0aFxuICAgICAgICBsZXQgd0xhcmdlVHJpYW5nbGUgPSBib3VuZGluZ1JlY3Qud2lkdGggKiAwLjI1O1xuICAgICAgICBsZXQgd1NtYWxsVHJpYW5nbGUgPSBib3VuZGluZ1JlY3Qud2lkdGggKiAwLjEwO1xuXG4gICAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XG4gICAgICAgICAgICBjYXNlIEhDQ2FyZEFsaWdubWVudC5yaWdodDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRSaWdodCA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgd0xhcmdlVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgbGV0IHRyaWdSaWdodCA9IHRoaXMudHJpZ1JlY3QucmlnaHQgLSB0aGlzLnRyaWdJY29uTWlkZGxlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGlmdFJpZ2h0IC0gKGJvdW5kaW5nUmVjdC5yaWdodCAtIHRyaWdSaWdodCk7XG5cbiAgICAgICAgICAgIGNhc2UgSENDYXJkQWxpZ25tZW50LnBhZGRlZFJpZ2h0OlxuICAgICAgICAgICAgICAgIGxldCBzaGlmdFJpZ2h0UyA9IGJvdW5kaW5nUmVjdC5sZWZ0ICsgd1NtYWxsVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgbGV0IHRyaWdSaWdodFMgPSB0aGlzLnRyaWdSZWN0LnJpZ2h0IC0gdGhpcy50cmlnSWNvbk1pZGRsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRSaWdodFMgLSAoYm91bmRpbmdSZWN0LnJpZ2h0IC0gdHJpZ1JpZ2h0Uyk7XG5cblxuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQucGFkZGVkTGVmdDpcbiAgICAgICAgICAgICAgICBsZXQgc2hpZnRMZWZ0UGFkID0gYm91bmRpbmdSZWN0LmxlZnQgLSB3U21hbGxUcmlhbmdsZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hpZnRMZWZ0UGFkICsgdGhpcy50cmlnSWNvbk1pZGRsZTtcblxuICAgICAgICAgICAgY2FzZSBIQ0NhcmRBbGlnbm1lbnQubGVmdDpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbGV0IHNoaWZ0TGVmdCA9IGJvdW5kaW5nUmVjdC5sZWZ0IC0gd0xhcmdlVHJpYW5nbGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaWZ0TGVmdCArIHRoaXMudHJpZ0ljb25NaWRkbGU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIEFmdGVyVmlld0NoZWNrZWQsXG4gICAgQWZ0ZXJWaWV3SW5pdCxcbiAgICBEaXJlY3RpdmUsXG4gICAgRG9DaGVjayxcbiAgICBFbGVtZW50UmVmLFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIFNpbXBsZUNoYW5nZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7aXNQcmVzZW50LCBwcmludH0gZnJvbSAnQGFyaWJhdWkvY29yZSc7XG5cblxuLyoqXG4gKiBTcHkgbGlmZWN5Y2xlIGRpcmVjdGl2ZSBpcyB1c2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgdG8gdHJhY2sgbGlmZWN5Y2xlIGNhbGxiYWNrXG4gKlxuICogIyMjVXNhZ2VcbiAqXG4gKiBgYGBcbiAqICAgPG15LWRpcmVjdGl2ZSBzcHlob29rcz48bXktZGlyZWN0aXZlPlxuICpcbiAqIGBgYFxuICovXG5ARGlyZWN0aXZlKHtzZWxlY3RvcjogJ1tzcHlIb29rc10nfSlcbmV4cG9ydCBjbGFzcyBTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0LCBEb0NoZWNrLCBPbkNoYW5nZXMsXG4gICAgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJDb250ZW50Q2hlY2tlZCwgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJWaWV3Q2hlY2tlZFxue1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmKVxuICAgIHtcbiAgICB9XG5cblxuICAgIG5nT25Jbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ29uSW5pdCcpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ29uRGVzdHJveScpO1xuICAgIH1cblxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczoge1sgcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZX0pXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ09uQ2hhbmdlcyA9ICcgKyBjaGFuZ2VzKTtcbiAgICB9XG5cbiAgICBuZ0RvQ2hlY2soKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdEb0NoZWNrJyk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KClcbiAgICB7XG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJDb250ZW50SW5pdCcpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpXG4gICAge1xuXG4gICAgICAgIHRoaXMubG9nSXQoJ25nQWZ0ZXJDb250ZW50Q2hlY2tlZCcpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpXG4gICAge1xuICAgICAgICB0aGlzLmxvZ0l0KCduZ0FmdGVyVmlld0luaXQnKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKVxuICAgIHtcbiAgICAgICAgdGhpcy5sb2dJdCgnbmdBZnRlclZpZXdDaGVja2VkJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBsb2dJdChtc2c6IHN0cmluZylcbiAgICB7XG4gICAgICAgIGxldCBsZXZlbCA9IDA7XG4gICAgICAgIGxldCBtZSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBsZXQgdGFnQm9keSA9IG1lO1xuXG4gICAgICAgIHdoaWxlICgodGFnQm9keSA9IHRhZ0JvZHkucGFyZW50Tm9kZSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgICAgIGlmICh0YWdCb2R5LnRhZ05hbWUgPT09ICdBUFAtUk9PVCcgfHwgbGV2ZWwgPT09IDYpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZW50ID0gJyc7XG4gICAgICAgIGxldCBpbmRlbnROdW1iZXIgPSBsZXZlbDtcbiAgICAgICAgd2hpbGUgKGxldmVsID4gMCkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICdcXHQnO1xuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgbGV0IHBhcmFtcyA9ICcnO1xuICAgICAgICBpZiAoaXNQcmVzZW50KG1lLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgYXR0cjogQXR0ciA9IG1lLmF0dHJpYnV0ZXMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZ25vcmUoYXR0ci5uYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgcGFyYW1zICs9ICcoJyArIGF0dHIubmFtZSArICc9JyArIGF0dHIudmFsdWUgKyAnKSwgICc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJpbnQoaW5kZW50ICsgbWUudGFnTmFtZSArICcoJyArIGluZGVudE51bWJlciArICcpOiAnICsgbXNnICsgJyA9PiAnICsgcGFyYW1zKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGlnbm9yZShuYW1lOiBzdHJpbmcpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gbmFtZS5pbmRleE9mKCdfbmcnKSA+IC0xIHx8XG4gICAgICAgICAgICBuYW1lLmluZGV4T2YoJ25nLScpID4gLTEgfHxcbiAgICAgICAgICAgIG5hbWUuaW5kZXhPZignc3B5aG9va3MnKSA+IC0xO1xuICAgIH1cbn1cbiIsIi8qKlxuICpcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBTQVAgQXJpYmFcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKlxuICpcbiAqL1xuaW1wb3J0IHtOZ01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0NvbW1vbk1vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuLi8uLi9jb3JlL2NvcmUubW9kdWxlJztcbmltcG9ydCB7T3ZlcmxheUNvbXBvbmVudH0gZnJvbSAnLi9vdmVybGF5LmNvbXBvbmVudCc7XG5pbXBvcnQge092ZXJsYXlQYW5lbE1vZHVsZX0gZnJvbSAncHJpbWVuZy9wcmltZW5nJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEFXQ29yZUNvbXBvbmVudE1vZHVsZSxcbiAgICAgICAgT3ZlcmxheVBhbmVsTW9kdWxlXG4gICAgXSxcbiAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgT3ZlcmxheUNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBPdmVybGF5Q29tcG9uZW50LFxuICAgICAgICBBV0NvcmVDb21wb25lbnRNb2R1bGVcbiAgICBdLFxuICAgIHByb3ZpZGVyczogW11cbn0pXG5leHBvcnQgY2xhc3MgQVdPdmVybGF5TW9kdWxlXG57XG59XG4iLCIvKipcbiAqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgU0FQIEFyaWJhXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICpcbiAqXG4gKi9cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0hvdmVyQ2FyZENvbXBvbmVudH0gZnJvbSAnLi9ob3Zlci1jYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQge0FXT3ZlcmxheU1vZHVsZX0gZnJvbSAnLi4vb3ZlcmxheS9vdmVybGF5Lm1vZHVsZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4uL3N0cmluZy9zdHJpbmcubW9kdWxlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBIb3ZlckNhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBBV092ZXJsYXlNb2R1bGUsXG4gICAgICAgIEFXU3RyaW5nRmllbGRNb2R1bGVcbiAgICBdLFxuICAgIGVudHJ5Q29tcG9uZW50czogW1xuICAgICAgICBIb3ZlckNhcmRDb21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSG92ZXJDYXJkQ29tcG9uZW50XG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFXSG92ZXJDYXJkTW9kdWxlXG57XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FQUF9JTklUSUFMSVpFUiwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge0Zvcm1zTW9kdWxlLCBSZWFjdGl2ZUZvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICAgIEFjY29yZGlvbk1vZHVsZSxcbiAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgQnV0dG9uTW9kdWxlLFxuICAgIENhbGVuZGFyTW9kdWxlLFxuICAgIENoZWNrYm94LFxuICAgIENoZWNrYm94TW9kdWxlLFxuICAgIERhdGFUYWJsZU1vZHVsZSxcbiAgICBEaWFsb2csXG4gICAgRGlhbG9nTW9kdWxlLFxuICAgIERyb3Bkb3duTW9kdWxlLFxuICAgIEVkaXRvck1vZHVsZSxcbiAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgIElucHV0VGV4dE1vZHVsZSxcbiAgICBNZW51TW9kdWxlLFxuICAgIE92ZXJsYXlQYW5lbE1vZHVsZSxcbiAgICBQYWdpbmF0b3JNb2R1bGUsXG4gICAgUGFuZWxNb2R1bGUsXG4gICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgU2hhcmVkTW9kdWxlLFxuICAgIFRhYk1lbnVNb2R1bGUsXG4gICAgVG9vbGJhck1vZHVsZVxufSBmcm9tICdwcmltZW5nL3ByaW1lbmcnO1xuaW1wb3J0IHtBcmliYUNvcmVNb2R1bGV9IGZyb20gJ0BhcmliYXVpL2NvcmUnO1xuaW1wb3J0IHtTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZX0gZnJvbSAnLi9zcHktbGlmZWN5Y2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQge0VtYmVkZGVkSXRlbURpcmVjdGl2ZX0gZnJvbSAnLi9jb3JlL2VtYmVkZGVkLWl0ZW0nO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi9lbnRyeS1jb21wb25lbnRzJztcbmltcG9ydCB7QVdDb3JlQ29tcG9uZW50TW9kdWxlfSBmcm9tICcuL2NvcmUvY29yZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvYmFzaWMtbmF2aWdhdG9yL2Jhc2ljLW5hdmlnYXRvci5tb2R1bGUnO1xuaW1wb3J0IHtBV0NoZWNrQm94TGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2NoZWNrLWJveC1saXN0L2NoZWNrLWJveC1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXQ2hlY2tCb3hNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9jaGVja2JveC9jaGVjay1ib3gubW9kdWxlJztcbmltcG9ydCB7QVdDaG9vc2VyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2hvb3Nlci9jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXQ29uZmlybWF0aW9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY29uZmlybWF0aW9uL2NvbmZpcm1hdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0N1cnJlbmN5TW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY3VycmVuY3kvY3VycmVuY3kubW9kdWxlJztcbmltcG9ydCB7QVdEYXRlQW5kVGltZU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RhdGUtYW5kLXRpbWUvZGF0YS1hbmQtdGltZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0RpYWxvZ01vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RpYWxvZy9kaWFsb2cubW9kdWxlJztcbmltcG9ydCB7QVdEcm9wZG93bk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2Ryb3Bkb3duL2Ryb3Bkb3duLm1vZHVsZSc7XG5pbXBvcnQge0FXR2VuZXJpY0Nob29zZXJNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9nZW5lcmljLWNob29zZXIvZ2VuZXJpYy1jaG9vc2VyLm1vZHVsZSc7XG5pbXBvcnQge0FXSHlwZXJsaW5rTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvaHlwZXJsaW5rL2h5cGVybGluay5tb2R1bGUnO1xuaW1wb3J0IHtBV0lucHV0RmllbGRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9pbnB1dC1maWVsZC9pbnB1dC1maWVsZC5tb2R1bGUnO1xuaW1wb3J0IHtBV091dGxpbmVGb3JNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9vdXRsaW5lL291dGxpbmUtZm9yLm1vZHVsZSc7XG5pbXBvcnQge0FXT3ZlcmxheU1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL292ZXJsYXkvb3ZlcmxheS5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VOb3RpZmljYXRpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9wYWdlLW5vdGlmaWNhdGlvbi9wYWdlLW5vdGlmaWNhdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1BhZ2VXcmFwcGVyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcGFnZS13cmFwcGVyL3BhZ2Utd3JhcHBlci5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmFkaW8tYnV0dG9uL3JhZGlvLWJ1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV1JhZGlvQnV0dG9uTGlzdE1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL3JhZGlvLWJ1dHRvbi1saXN0L3JhZGlvLWJ1dHRvbi1saXN0Lm1vZHVsZSc7XG5pbXBvcnQge0FXUmljaFRleHRBcmVhTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvcmljaC10ZXh0LWFyZWEvcmljaC10ZXh0LWFyZWEubW9kdWxlJztcbmltcG9ydCB7QVdIb3ZlckNhcmRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9ob3Zlci1jYXJkL2hvdmVyLWNhcmQubW9kdWxlJztcbmltcG9ydCB7XG4gICAgQVdTY3JvbGxhYmxlQ29udGFpbmVyTW9kdWxlXG59IGZyb20gJy4vd2lkZ2V0cy9zY3JvbGxhYmxlLWNvbnRhaW5lci9zY3JvbGxhYmxlLWNvbnRhaW5lci5tb2R1bGUnO1xuaW1wb3J0IHtBV1NlY3Rpb25Nb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zZWN0aW9uL3NlY3Rpb24ubW9kdWxlJztcbmltcG9ydCB7QVdTdGVwcGVyTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvc3RlcHBlci9zdGVwcGVyLm1vZHVsZSc7XG5pbXBvcnQge0FXU3RyaW5nRmllbGRNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9zdHJpbmcvc3RyaW5nLm1vZHVsZSc7XG5pbXBvcnQge0FXVGV4dEFyZWFNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy90ZXh0LWFyZWEvdGV4dC1hcmVhLm1vZHVsZSc7XG5pbXBvcnQge0FXQnV0dG9uTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvYnV0dG9uL2J1dHRvbi5tb2R1bGUnO1xuaW1wb3J0IHtBV0Zvcm1UYWJsZU1vZHVsZX0gZnJvbSAnLi9sYXlvdXRzL2Zvcm0tdGFibGUvZm9ybS10YWJsZS5tb2R1bGUnO1xuaW1wb3J0IHtBV0xpc3RNb2R1bGV9IGZyb20gJy4vd2lkZ2V0cy9saXN0L2xpc3QubW9kdWxlJztcbmltcG9ydCB7QVdDYXJkTW9kdWxlfSBmcm9tICcuL3dpZGdldHMvY2FyZC9jYXJkLm1vZHVsZSc7XG5pbXBvcnQge0FXRGF0YXRhYmxlMk1vZHVsZX0gZnJvbSAnLi93aWRnZXRzL2RhdGF0YWJsZTIvZGF0YXRhYmxlMi5tb2R1bGUnO1xuaW1wb3J0IHtEb21VdGlsc1NlcnZpY2V9IGZyb20gJy4vY29yZS9kb20tdXRpbHMuc2VydmljZSc7XG5pbXBvcnQge01vZGFsU2VydmljZX0gZnJvbSAnLi9jb3JlL21vZGFsLXNlcnZpY2UvbW9kYWwuc2VydmljZSc7XG5pbXBvcnQge0RhdGFQcm92aWRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtcHJvdmlkZXJzJztcbmltcG9ydCB7RGF0YUZpbmRlcnN9IGZyb20gJy4vY29yZS9kYXRhL2RhdGEtZmluZGVycyc7XG5pbXBvcnQge0Vycm9yTWFuYWdlclNlcnZpY2V9IGZyb20gJy4vY29yZS9lcnJvci1tYW5hZ2VyLnNlcnZpY2UnO1xuaW1wb3J0IHtBd05hbWVTdG9yZX0gZnJvbSAnLi9jb3JlL2F3LW5hbWUvYXctbmFtZS5zdG9yZSc7XG5pbXBvcnQge0RhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2RhdGEvZGF0YXR5cGUtcmVnaXN0cnkuc2VydmljZSc7XG5cbi8qKlxuICogQ29tcG9uZW50IG1vZHVsZSBpcyBjb3JlIG1vZHVsZSBmb3IgdGhlIGNvbW1vbiBsYXlvdXRzIGFuZCB3aWRnZXRzIGxpYnJhcmllcy5cbiAqXG4gKiB0b2RvOiBUaGVyZSBhcmUgc29tZSB0aGluZ3MgdGhhdCBJIHN0aWxsIG5lZWQgdG8gcmVzb2x2ZSAtIHBsZWFzZSBzZWUgYW5kIG5vdGljZXMgQER1cGxpY2F0ZXNcbiAqIGpzZG9jIEkgd2FudCB0byBrZWVwIHRoaXMgdGhlcmUgdG8gcmVtaW5kIG1lIHRoYXQgSSBuZWVkIHRvIHJlZmFjdG9yIHRoaXMgYXMgb2Ygbm93IHRoZXJlIGFyZVxuICogbm90IG11Y2ggb3B0aW9uIHdpdGggYW5ndWxhci5cbiAqXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBBcmliYUNvcmVNb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG5cbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlLFxuICAgICAgICBBV0NhcmRNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXQ29uZmlybWF0aW9uTW9kdWxlLFxuICAgICAgICBBV0N1cnJlbmN5TW9kdWxlLFxuICAgICAgICBBV0RhdGVBbmRUaW1lTW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdHZW5lcmljQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBBV092ZXJsYXlNb2R1bGUsXG4gICAgICAgIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZSxcbiAgICAgICAgQVdQYWdlV3JhcHBlck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGUsXG4gICAgICAgIEFXUmljaFRleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGUsXG4gICAgICAgIEFXU2VjdGlvbk1vZHVsZSxcbiAgICAgICAgQVdTdGVwcGVyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV1RleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV0Zvcm1UYWJsZU1vZHVsZSxcbiAgICAgICAgQVdCdXR0b25Nb2R1bGUsXG4gICAgICAgIEFXSG92ZXJDYXJkTW9kdWxlLFxuICAgICAgICBBV0xpc3RNb2R1bGUsXG4gICAgICAgIEFXRGF0YXRhYmxlMk1vZHVsZSxcblxuICAgICAgICAvLyBQcmltZU5HIHJlbW92ZSB3aGVuIGFsbCBBVyBhcmUgaW1wb3J0ZWRcbiAgICAgICAgUGFuZWxNb2R1bGUsXG4gICAgICAgIEJ1dHRvbk1vZHVsZSxcbiAgICAgICAgVG9vbGJhck1vZHVsZSxcbiAgICAgICAgSW5wdXRUZXh0TW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRhcmVhTW9kdWxlLFxuICAgICAgICBBdXRvQ29tcGxldGVNb2R1bGUsXG4gICAgICAgIERyb3Bkb3duTW9kdWxlLFxuICAgICAgICBDYWxlbmRhck1vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgIFJhZGlvQnV0dG9uTW9kdWxlLFxuICAgICAgICBTaGFyZWRNb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZSxcbiAgICAgICAgTWVudU1vZHVsZSxcbiAgICAgICAgVGFiTWVudU1vZHVsZSxcbiAgICAgICAgQWNjb3JkaW9uTW9kdWxlLFxuICAgICAgICBFZGl0b3JNb2R1bGUsXG4gICAgICAgIERhdGFUYWJsZU1vZHVsZSxcbiAgICAgICAgUGFnaW5hdG9yTW9kdWxlLFxuICAgICAgICBPdmVybGF5UGFuZWxNb2R1bGVcblxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFNweUxpZmVDeWNsZUhvb2tzRGlyZWN0aXZlLFxuICAgICAgICAvLyAzdGggcGFydHkgZGVjbGFyYXRpb25cbiAgICBdLFxuICAgIGJvb3RzdHJhcDogW10sXG4gICAgZW50cnlDb21wb25lbnRzOiBbXG5cbiAgICAgICAgLy8gUHJpbWVOR1xuICAgICAgICBDaGVja2JveCxcbiAgICAgICAgRGlhbG9nXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJlYWN0aXZlRm9ybXNNb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBTcHlMaWZlQ3ljbGVIb29rc0RpcmVjdGl2ZSxcbiAgICAgICAgQVdDb3JlQ29tcG9uZW50TW9kdWxlLFxuICAgICAgICBBV0Jhc2ljTmF2aWdhdG9yTW9kdWxlLFxuICAgICAgICBBV0NhcmRNb2R1bGUsXG4gICAgICAgIEFXQ2hlY2tCb3hMaXN0TW9kdWxlLFxuICAgICAgICBBV0NoZWNrQm94TW9kdWxlLFxuICAgICAgICBBV0Nob29zZXJNb2R1bGUsXG4gICAgICAgIEFXQ29uZmlybWF0aW9uTW9kdWxlLFxuICAgICAgICBBV0N1cnJlbmN5TW9kdWxlLFxuICAgICAgICBBV0RhdGVBbmRUaW1lTW9kdWxlLFxuICAgICAgICBBV0RpYWxvZ01vZHVsZSxcbiAgICAgICAgQVdEcm9wZG93bk1vZHVsZSxcbiAgICAgICAgQVdHZW5lcmljQ2hvb3Nlck1vZHVsZSxcbiAgICAgICAgQVdIeXBlcmxpbmtNb2R1bGUsXG4gICAgICAgIEFXSW5wdXRGaWVsZE1vZHVsZSxcbiAgICAgICAgQVdPdXRsaW5lRm9yTW9kdWxlLFxuICAgICAgICBBV092ZXJsYXlNb2R1bGUsXG4gICAgICAgIEFXUGFnZU5vdGlmaWNhdGlvbk1vZHVsZSxcbiAgICAgICAgQVdQYWdlV3JhcHBlck1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdSYWRpb0J1dHRvbkxpc3RNb2R1bGUsXG4gICAgICAgIEFXUmljaFRleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV1Njcm9sbGFibGVDb250YWluZXJNb2R1bGUsXG4gICAgICAgIEFXU2VjdGlvbk1vZHVsZSxcbiAgICAgICAgQVdTdGVwcGVyTW9kdWxlLFxuICAgICAgICBBV1N0cmluZ0ZpZWxkTW9kdWxlLFxuICAgICAgICBBV1RleHRBcmVhTW9kdWxlLFxuICAgICAgICBBV0Zvcm1UYWJsZU1vZHVsZSxcbiAgICAgICAgRW1iZWRkZWRJdGVtRGlyZWN0aXZlLFxuICAgICAgICBBV0J1dHRvbk1vZHVsZSxcbiAgICAgICAgQVdIb3ZlckNhcmRNb2R1bGUsXG4gICAgICAgIEFXTGlzdE1vZHVsZSxcbiAgICAgICAgQVdEYXRhdGFibGUyTW9kdWxlLFxuXG4gICAgICAgIC8vIFByaW1lTkdcbiAgICAgICAgU2hhcmVkTW9kdWxlLFxuICAgICAgICBQYW5lbE1vZHVsZSxcbiAgICAgICAgQnV0dG9uTW9kdWxlLFxuICAgICAgICBUb29sYmFyTW9kdWxlLFxuICAgICAgICBJbnB1dFRleHRNb2R1bGUsXG4gICAgICAgIElucHV0VGV4dGFyZWFNb2R1bGUsXG4gICAgICAgIEF1dG9Db21wbGV0ZU1vZHVsZSxcbiAgICAgICAgRHJvcGRvd25Nb2R1bGUsXG4gICAgICAgIENhbGVuZGFyTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZSxcbiAgICAgICAgUmFkaW9CdXR0b25Nb2R1bGUsXG4gICAgICAgIERpYWxvZ01vZHVsZSxcbiAgICAgICAgTWVudU1vZHVsZSxcbiAgICAgICAgVGFiTWVudU1vZHVsZSxcbiAgICAgICAgRWRpdG9yTW9kdWxlLFxuICAgICAgICBEYXRhVGFibGVNb2R1bGUsXG4gICAgICAgIFBhZ2luYXRvck1vZHVsZSxcbiAgICAgICAgT3ZlcmxheVBhbmVsTW9kdWxlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBcmliYUNvbXBvbmVudHNNb2R1bGVcbntcblxuXG4gICAgc3RhdGljIGZvclJvb3QgKCk6IE1vZHVsZVdpdGhQcm92aWRlcnNcbiAgICB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogQXJpYmFDb21wb25lbnRzTW9kdWxlLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTW9kYWxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudFJlZ2lzdHJ5LFxuICAgICAgICAgICAgICAgIEVycm9yTWFuYWdlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgRG9tVXRpbHNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERhdGFUeXBlUHJvdmlkZXJSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBEYXRhUHJvdmlkZXJzLFxuICAgICAgICAgICAgICAgIERhdGFGaW5kZXJzLFxuICAgICAgICAgICAgICAgIEF3TmFtZVN0b3JlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQVBQX0lOSVRJQUxJWkVSLFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiByZWdpc3RlckNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGRlcHM6IFtDb21wb25lbnRSZWdpc3RyeV0sXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckNvbXBvbmVudHMgKGNvbXBSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnkpOiBGdW5jdGlvblxue1xuICAgIHJldHVybiBjb21wUmVnaXN0cnkuaW5pdGlhbGl6ZS5iaW5kKGNvbXBSZWdpc3RyeSwgY29tcG9uZW50cyk7XG59XG5cblxuIiwiLyoqXG4gKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IFNBUCBBcmliYVxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqXG4gKlxuICovXG5pbXBvcnQge0FQUF9JTklUSUFMSVpFUiwgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21wb25lbnRSZWdpc3RyeX0gZnJvbSAnLi9jb3JlL2NvbXBvbmVudC1yZWdpc3RyeS5zZXJ2aWNlJztcbmltcG9ydCAqIGFzIGNvbXBvbmVudHMgZnJvbSAnLi9lbnRyeS1jb21wb25lbnRzJztcbmltcG9ydCB7RG9tVXRpbHNTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZG9tLXV0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHtNb2RhbFNlcnZpY2V9IGZyb20gJy4vY29yZS9tb2RhbC1zZXJ2aWNlL21vZGFsLnNlcnZpY2UnO1xuaW1wb3J0IHtEYXRhUHJvdmlkZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLXByb3ZpZGVycyc7XG5pbXBvcnQge0RhdGFGaW5kZXJzfSBmcm9tICcuL2NvcmUvZGF0YS9kYXRhLWZpbmRlcnMnO1xuaW1wb3J0IHtFcnJvck1hbmFnZXJTZXJ2aWNlfSBmcm9tICcuL2NvcmUvZXJyb3ItbWFuYWdlci5zZXJ2aWNlJztcbmltcG9ydCB7QXdOYW1lU3RvcmV9IGZyb20gJy4vY29yZS9hdy1uYW1lL2F3LW5hbWUuc3RvcmUnO1xuaW1wb3J0IHtEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnl9IGZyb20gJy4vY29yZS9kYXRhL2RhdGF0eXBlLXJlZ2lzdHJ5LnNlcnZpY2UnO1xuXG5cbi8qKlxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIHVzZWQgbWFpbmx5IGZvciB0ZXN0cyBhcyBpbXBvcnRpbmcgYSBtb2R1bGUgd2l0aCBhbGwgdGhlIGNvbXBvbmVudHMgYW5kIHlvdVxuICogdXNlIG9ubHkgMSBvciB0d28gaGFzIGEgYmlnIGltcGFjdCBvbiB0aGUgcGVyZm9ybWFuY2UgZXhlY3V0aW9uLiBlLmcuIGZyb20gZXhlY3V0aW5nIGNvdXBsZVxuICogdGVzdHMgdW5kZXIgMSBzZWMgY2FuIGdvIHVwIHRvIDEwc2VjIGlmIHlvdSBpbXBvcnQgYWxsIHRoZSB0aGluZ3MgdGhhdCB5b3UgYXJlIG5vdCB1c2luZy5cbiAqXG4gKiBJIGhhdmVudCBub3RpY2VkIGFueXRoaW5nIHNpbWlsYXIgaW4gYXBwbGljYXRpb24gaXRzIG9ubHkgamFzbWluZS9rYXJtYSB0aGF0IG5lZWRzIHRvIGluaXRcbiAqIGNvbXBvbmVudHMgZm9yIGV2ZXJ5IHRlc3QuXG4gKlxuICovXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdXG59KVxuZXhwb3J0IGNsYXNzIEFyaWJhQ29tcG9uZW50c1Rlc3RQcm92aWRlck1vZHVsZSB7XG5cblxuICAgIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IEFyaWJhQ29tcG9uZW50c1Rlc3RQcm92aWRlck1vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE1vZGFsU2VydmljZSxcbiAgICAgICAgICAgICAgICBDb21wb25lbnRSZWdpc3RyeSxcbiAgICAgICAgICAgICAgICBFcnJvck1hbmFnZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIERvbVV0aWxzU2VydmljZSxcbiAgICAgICAgICAgICAgICBEYXRhVHlwZVByb3ZpZGVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgRGF0YVByb3ZpZGVycyxcbiAgICAgICAgICAgICAgICBEYXRhRmluZGVycyxcbiAgICAgICAgICAgICAgICBBd05hbWVTdG9yZSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IEFQUF9JTklUSUFMSVpFUixcbiAgICAgICAgICAgICAgICAgICAgdXNlRmFjdG9yeTogcmVnaXN0ZXJDb21wb25lbnRzLFxuICAgICAgICAgICAgICAgICAgICBkZXBzOiBbQ29tcG9uZW50UmVnaXN0cnldLFxuICAgICAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXJDb21wb25lbnRzKGNvbXBSZWdpc3RyeTogQ29tcG9uZW50UmVnaXN0cnkpOiBGdW5jdGlvbiB7XG4gICAgcmV0dXJuIGNvbXBSZWdpc3RyeS5pbml0aWFsaXplLmJpbmQoY29tcFJlZ2lzdHJ5LCBjb21wb25lbnRzKTtcbn1cblxuXG4iXSwibmFtZXMiOlsiaXNQcmVzZW50IiwiRGlyZWN0aXZlIiwiVmlld0NvbnRhaW5lclJlZiIsIklucHV0IiwiaXNCbGFuayIsIk1hcFdyYXBwZXIiLCJDb21wb25lbnQiLCJSZW5kZXJlcjIiLCJFbGVtZW50UmVmIiwiQXBwQ29uZmlnIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJub29wIiwiRm9ybUdyb3VwIiwidXVpZCIsIkZvcm1Db250cm9sIiwiRW52aXJvbm1lbnQiLCJJbmplY3QiLCJTa2lwU2VsZiIsIk9wdGlvbmFsIiwiZm9yd2FyZFJlZiIsIkRvbVNhbml0aXplciIsImlzU3RyaW5nTWFwIiwiSW5qZWN0YWJsZSIsImFzc2VydCIsIkNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciIsIkNoYW5nZURldGVjdG9yUmVmIiwiU3RyaW5nV3JhcHBlciIsIlZpZXdDaGlsZCIsIlBpcGUiLCJDdXJyZW5jeVBpcGUiLCJFdmVudEVtaXR0ZXIiLCJPdXRwdXQiLCJOZ1pvbmUiLCJOZ01vZHVsZSIsIkNvbW1vbk1vZHVsZSIsImlzVHlwZSIsIm9iamVjdFRvTmFtZSIsIkJlaGF2aW9yU3ViamVjdCIsIm9ic2VydmFibGVPZiIsIkZpZWxkUGF0aCIsImlzQXJyYXkiLCJpc1N0cmluZyIsInVuaW1wbGVtZW50ZWQiLCJpc0Z1bmN0aW9uIiwiaXNKc09iamVjdCIsIkluamVjdGlvblRva2VuIiwiSG9zdEJpbmRpbmciLCJWYWxpZGF0b3JzIiwiTGlzdFdyYXBwZXIiLCJDb250ZW50Q2hpbGQiLCJDb250ZW50Q2hpbGRyZW4iLCJGb3Jtc01vZHVsZSIsIlJlYWN0aXZlRm9ybXNNb2R1bGUiLCJJbnB1dFRleHRNb2R1bGUiLCJOR19WQUxVRV9BQ0NFU1NPUiIsIkRlY2ltYWxQaXBlIiwiZGlzdGluY3RVbnRpbENoYW5nZWQiLCJlcXVhbHMiLCJCdXR0b25Nb2R1bGUiLCJUb29sYmFyTW9kdWxlIiwiaXNCb29sZWFuIiwiQ2hlY2tib3hNb2R1bGUiLCJBdXRvQ29tcGxldGVNb2R1bGUiLCJEcm9wZG93bk1vZHVsZSIsImlzRGF0ZSIsIkNhbGVuZGFyTW9kdWxlIiwiRGlhbG9nTW9kdWxlIiwiUmFkaW9CdXR0b25Nb2R1bGUiLCJpc0VudGl0eSIsInRyaWdnZXIiLCJzdGF0ZSIsInN0eWxlIiwidHJhbnNpdGlvbiIsImFuaW1hdGUiLCJBbmltYXRpb25CdWlsZGVyIiwiSW5wdXRUZXh0YXJlYU1vZHVsZSIsIlN1YmplY3QiLCJSb3V0aW5nU2VydmljZSIsIlJvdXRlck1vZHVsZSIsIkVkaXRvck1vZHVsZSIsIkFjY29yZGlvbk1vZHVsZSIsIkFyaWJhQ29yZU1vZHVsZSIsIlNoYXJlZE1vZHVsZSIsIkJvb2xlYW5XcmFwcGVyIiwiVmlld0VuY2Fwc3VsYXRpb24iLCJEb21IYW5kbGVyIiwidHNsaWJfMS5fX3ZhbHVlcyIsIk9iamVjdFV0aWxzIiwiQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kiLCJJbmplY3RvciIsImRlYm91bmNlVGltZSIsInN3aXRjaE1hcCIsIm9mIiwiaXNQbGF0Zm9ybUJyb3dzZXIiLCJQTEFURk9STV9JRCIsIkxpc3Rib3hNb2R1bGUiLCJPdmVybGF5UGFuZWwiLCJwcmludCIsIk92ZXJsYXlQYW5lbE1vZHVsZSIsIkFQUF9JTklUSUFMSVpFUiIsIlBhbmVsTW9kdWxlIiwiTWVudU1vZHVsZSIsIlRhYk1lbnVNb2R1bGUiLCJEYXRhVGFibGVNb2R1bGUiLCJQYWdpbmF0b3JNb2R1bGUiLCJDaGVja2JveCIsIkRpYWxvZyIsInJlZ2lzdGVyQ29tcG9uZW50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQW9CQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWtGSSwrQkFBb0IsY0FBZ0M7WUFBaEMsbUJBQWMsR0FBZCxjQUFjLENBQWtCO1NBRW5EO1FBWkQsc0JBQ0ksdUNBQUk7Ozs7Z0JBRFIsVUFDUyxJQUFTO2dCQUVkLElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDO2FBQzlCOzs7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